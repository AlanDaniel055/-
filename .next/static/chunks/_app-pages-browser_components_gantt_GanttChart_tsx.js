/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_components_gantt_GanttChart_tsx"],{

/***/ "(app-pages-browser)/./node_modules/dhtmlx-gantt/codebase/dhtmlxgantt.es.js":
/*!**************************************************************!*\
  !*** ./node_modules/dhtmlx-gantt/codebase/dhtmlxgantt.es.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Xa; },\n/* harmony export */   gantt: function() { return /* binding */ Xa; }\n/* harmony export */ });\n/** @license\n\ndhtmlxGantt v.9.0.10 Standard\n\nThis version of dhtmlxGantt is distributed under GPL 2.0 license and can be legally used in GPL projects.\n\nTo use dhtmlxGantt in non-GPL projects (and get Pro version of the product), please obtain Individual, Commercial, Enterprise or Ultimate license on our site https://dhtmlx.com/docs/products/dhtmlxGantt/#licensing or contact us at info@dhtmlx.com\n\n(c) XB Software\n\n*/\nfunction V(t) {\n  var e = 0, n = 0, i = 0, a = 0;\n  if (t.getBoundingClientRect) {\n    var r = t.getBoundingClientRect(), s = document.body, o = document.documentElement || document.body.parentNode || document.body, l = window.pageYOffset || o.scrollTop || s.scrollTop, d = window.pageXOffset || o.scrollLeft || s.scrollLeft, c = o.clientTop || s.clientTop || 0, u = o.clientLeft || s.clientLeft || 0;\n    e = r.top + l - c, n = r.left + d - u, i = document.body.offsetWidth - r.right, a = document.body.offsetHeight - r.bottom;\n  } else {\n    for (; t; ) e += parseInt(t.offsetTop, 10), n += parseInt(t.offsetLeft, 10), t = t.offsetParent;\n    i = document.body.offsetWidth - t.offsetWidth - n, a = document.body.offsetHeight - t.offsetHeight - e;\n  }\n  return { y: Math.round(e), x: Math.round(n), width: t.offsetWidth, height: t.offsetHeight, right: Math.round(i), bottom: Math.round(a) };\n}\nfunction Dn(t) {\n  var e = !1, n = !1;\n  if (window.getComputedStyle) {\n    var i = window.getComputedStyle(t, null);\n    e = i.display, n = i.visibility;\n  } else t.currentStyle && (e = t.currentStyle.display, n = t.currentStyle.visibility);\n  return e != \"none\" && n != \"hidden\";\n}\nfunction An(t) {\n  return !isNaN(t.getAttribute(\"tabindex\")) && 1 * t.getAttribute(\"tabindex\") >= 0;\n}\nfunction In(t) {\n  return !{ a: !0, area: !0 }[t.nodeName.loLowerCase()] || !!t.getAttribute(\"href\");\n}\nfunction Mn(t) {\n  return !{ input: !0, select: !0, textarea: !0, button: !0, object: !0 }[t.nodeName.toLowerCase()] || !t.hasAttribute(\"disabled\");\n}\nfunction Lt(t) {\n  for (var e = t.querySelectorAll([\"a[href]\", \"area[href]\", \"input\", \"select\", \"textarea\", \"button\", \"iframe\", \"object\", \"embed\", \"[tabindex]\", \"[contenteditable]\"].join(\", \")), n = Array.prototype.slice.call(e, 0), i = 0; i < n.length; i++) n[i].$position = i;\n  for (n.sort(function(r, s) {\n    return r.tabIndex === 0 && s.tabIndex !== 0 ? 1 : r.tabIndex !== 0 && s.tabIndex === 0 ? -1 : r.tabIndex === s.tabIndex ? r.$position - s.$position : r.tabIndex < s.tabIndex ? -1 : 1;\n  }), i = 0; i < n.length; i++) {\n    var a = n[i];\n    (An(a) || Mn(a) || In(a)) && Dn(a) || (n.splice(i, 1), i--);\n  }\n  return n;\n}\nfunction Xe() {\n  var t = document.createElement(\"div\");\n  t.style.cssText = \"visibility:hidden;position:absolute;left:-1000px;width:100px;padding:0px;margin:0px;height:110px;min-height:100px;overflow-y:scroll;\", document.body.appendChild(t);\n  var e = t.offsetWidth - t.clientWidth;\n  return document.body.removeChild(t), Math.max(e, 15);\n}\nfunction X(t) {\n  if (!t) return \"\";\n  var e = t.className || \"\";\n  return e.baseVal && (e = e.baseVal), e.indexOf || (e = \"\"), _e(e);\n}\nfunction wt(t, e) {\n  e && t.className.indexOf(e) === -1 && (t.className += \" \" + e);\n}\nfunction Gt(t, e) {\n  e = e.split(\" \");\n  for (var n = 0; n < e.length; n++) {\n    var i = new RegExp(\"\\\\s?\\\\b\" + e[n] + \"\\\\b(?![-_.])\", \"\");\n    t.className = t.className.replace(i, \"\");\n  }\n}\nfunction we(t) {\n  return typeof t == \"string\" ? document.getElementById(t) || document.querySelector(t) || document.body : t || document.body;\n}\nvar Bt;\nfunction Ze(t, e) {\n  Bt || (Bt = document.createElement(\"div\")), Bt.innerHTML = e;\n  var n = Bt.firstChild;\n  return t.appendChild(n), n;\n}\nfunction Qe(t) {\n  t && t.parentNode && t.parentNode.removeChild(t);\n}\nfunction tn(t, e) {\n  for (var n = t.childNodes, i = n.length, a = [], r = 0; r < i; r++) {\n    var s = n[r];\n    s.className && s.className.indexOf(e) !== -1 && a.push(s);\n  }\n  return a;\n}\nfunction yt(t) {\n  var e;\n  return t.tagName ? e = t : (e = (t = t || window.event).target || t.srcElement).shadowRoot && t.composedPath && (e = t.composedPath()[0]), e;\n}\nfunction et(t, e) {\n  if (e) {\n    for (var n = yt(t); n; ) {\n      if (n.getAttribute && n.getAttribute(e)) return n;\n      n = n.parentNode;\n    }\n    return null;\n  }\n}\nfunction _e(t) {\n  return (String.prototype.trim || function() {\n    return this.replace(/^\\s+|\\s+$/g, \"\");\n  }).apply(t);\n}\nfunction pt(t, e, n) {\n  var i = yt(t), a = \"\";\n  for (n === void 0 && (n = !0); i; ) {\n    if (a = X(i)) {\n      var r = a.indexOf(e);\n      if (r >= 0) {\n        if (!n) return i;\n        var s = r === 0 || !_e(a.charAt(r - 1)), o = r + e.length >= a.length || !_e(a.charAt(r + e.length));\n        if (s && o) return i;\n      }\n    }\n    i = i.parentNode;\n  }\n  return null;\n}\nfunction rt(t, e) {\n  var n = document.documentElement, i = V(e);\n  return { x: t.clientX + n.scrollLeft - n.clientLeft - i.x + e.scrollLeft, y: t.clientY + n.scrollTop - n.clientTop - i.y + e.scrollTop };\n}\nfunction en(t, e) {\n  const n = V(t), i = V(e);\n  return { x: n.x - i.x, y: n.y - i.y };\n}\nfunction Y(t, e) {\n  if (!t || !e) return !1;\n  for (; t && t != e; ) t = t.parentNode;\n  return t === e;\n}\nfunction ct(t, e) {\n  if (t.closest) return t.closest(e);\n  if (t.matches || t.msMatchesSelector || t.webkitMatchesSelector) {\n    var n = t;\n    if (!document.documentElement.contains(n)) return null;\n    do {\n      if ((n.matches || n.msMatchesSelector || n.webkitMatchesSelector).call(n, e)) return n;\n      n = n.parentElement || n.parentNode;\n    } while (n !== null && n.nodeType === 1);\n    return null;\n  }\n  return console.error(\"Your browser is not supported\"), null;\n}\nfunction nn(t) {\n  for (; t; ) {\n    if (t.offsetWidth > 0 && t.offsetHeight > 0) return t;\n    t = t.parentElement;\n  }\n  return null;\n}\nfunction an() {\n  return document.head.createShadowRoot || document.head.attachShadow;\n}\nfunction ge() {\n  var t = document.activeElement;\n  return t.shadowRoot && (t = t.shadowRoot.activeElement), t === document.body && document.getSelection && (t = document.getSelection().focusNode || document.body), t;\n}\nfunction vt(t) {\n  if (!t || !an()) return document.body;\n  for (; t.parentNode && (t = t.parentNode); ) if (t instanceof ShadowRoot) return t.host;\n  return document.body;\n}\nconst rn = Object.freeze(Object.defineProperty({ __proto__: null, addClassName: wt, closest: ct, getActiveElement: ge, getChildNodes: tn, getClassName: X, getClosestSizedElement: nn, getFocusableNodes: Lt, getNodePosition: V, getRelativeEventPosition: rt, getRelativeNodePosition: en, getRootNode: vt, getScrollSize: Xe, getTargetNode: yt, hasClass: function(t, e) {\n  return \"classList\" in t ? t.classList.contains(e) : new RegExp(\"\\\\b\" + e + \"\\\\b\").test(t.className);\n}, hasShadowParent: function(t) {\n  return !!vt(t);\n}, insertNode: Ze, isChildOf: Y, isShadowDomSupported: an, locateAttribute: et, locateClassName: pt, removeClassName: Gt, removeNode: Qe, toNode: we }, Symbol.toStringTag, { value: \"Module\" })), dt = typeof window < \"u\" ? window : __webpack_require__.g;\nlet Nn = class {\n  constructor(t) {\n    this._mouseDown = !1, this._touchStarts = !1, this._touchActive = !1, this._longTapTimer = !1, this._gantt = t, this._domEvents = t._createDomEventScope();\n  }\n  attach(t, e, n) {\n    const i = this._gantt, a = t.getViewPort();\n    this._originPosition = dt.getComputedStyle(a).display, this._restoreOriginPosition = () => {\n      a.style.position = this._originPosition;\n    }, this._originPosition === \"static\" && (a.style.position = \"relative\");\n    const r = i.$services.getService(\"state\");\n    r.registerProvider(\"clickDrag\", () => ({ autoscroll: !1 }));\n    let s = null;\n    const o = () => {\n      s && (this._mouseDown = !0, t.setStart(i.copy(s)), t.setPosition(i.copy(s)), t.setEnd(i.copy(s)), s = null);\n    };\n    this._domEvents.attach(a, \"mousedown\", (p) => {\n      u(p);\n    });\n    const l = vt(i.$root) || document.body;\n    function d(p) {\n      return p.changedTouches && p.changedTouches[0] || p;\n    }\n    this._domEvents.attach(l, \"mouseup\", (p) => {\n      h(p);\n    }), this._domEvents.attach(a, \"mousemove\", (p) => {\n      g(p);\n    }), this._domEvents.attach(a, \"touchstart\", (p) => {\n      this._touchStarts = !0, this._longTapTimer = setTimeout(() => {\n        this._touchStarts && (u(d(p)), this._touchStarts = !1, this._touchActive = !0);\n      }, this._gantt.config.touch_drag);\n    }), this._domEvents.attach(l, \"touchend\", (p) => {\n      this._touchStarts = !1, this._touchActive = !1, clearTimeout(this._longTapTimer), h(d(p));\n    }), this._domEvents.attach(a, \"touchmove\", (p) => {\n      if (this._touchActive) {\n        let y = c();\n        if (y && i.utils.dom.closest(p.target, y)) return;\n        g(d(p)), p.preventDefault();\n      } else this._touchStarts = !1, clearTimeout(this._longTapTimer);\n    });\n    const c = () => {\n      let p = \".gantt_task_line, .gantt_task_link\";\n      return n !== void 0 && (p = n instanceof Array ? n.join(\", \") : n), p;\n    }, u = (p) => {\n      s = null;\n      let y = c();\n      y && i.utils.dom.closest(p.target, y) || (r.registerProvider(\"clickDrag\", () => ({ autoscroll: this._mouseDown })), e && p[e] !== !0 || (s = this._getCoordinates(p, t)));\n    }, h = (p) => {\n      if (s = null, (!e || p[e] === !0) && this._mouseDown === !0) {\n        this._mouseDown = !1;\n        const y = this._getCoordinates(p, t);\n        t.dragEnd(y);\n      }\n    }, g = (p) => {\n      if (e && p[e] !== !0) return;\n      const y = this._gantt.ext.clickDrag, v = (this._gantt.config.drag_timeline || {}).useKey;\n      if (y && v && !e && p[v]) return;\n      let b = null;\n      if (!this._mouseDown && s) return b = this._getCoordinates(p, t), void (Math.abs(s.relative.left - b.relative.left) > 5 && o());\n      this._mouseDown === !0 && (b = this._getCoordinates(p, t), t.setEnd(b), t.render());\n    };\n  }\n  detach() {\n    const t = this._gantt;\n    this._domEvents.detachAll(), this._restoreOriginPosition && this._restoreOriginPosition(), t.$services.getService(\"state\").unregisterProvider(\"clickDrag\");\n  }\n  destructor() {\n    this.detach();\n  }\n  _getCoordinates(t, e) {\n    const n = e.getViewPort(), i = n.getBoundingClientRect(), { clientX: a, clientY: r } = t;\n    return { absolute: { left: a, top: r }, relative: { left: a - i.left + n.scrollLeft, top: r - i.top + n.scrollTop } };\n  }\n};\nvar sn = function() {\n  this._silent_mode = !1, this.listeners = {};\n};\nsn.prototype = { _silentStart: function() {\n  this._silent_mode = !0;\n}, _silentEnd: function() {\n  this._silent_mode = !1;\n} };\nfunction ot(t) {\n  var e = new sn();\n  t.attachEvent = function(n, i, a) {\n    n = \"ev_\" + n.toLowerCase(), e.listeners[n] || (e.listeners[n] = function(s) {\n      var o = {}, l = 0, d = function() {\n        var c = !0;\n        for (var u in o) {\n          var h = o[u].apply(s, arguments);\n          c = c && h;\n        }\n        return c;\n      };\n      return d.addEvent = function(c, u) {\n        if (typeof c == \"function\") {\n          var h;\n          if (u && u.id ? h = u.id : (h = l, l++), u && u.once) {\n            var g = c;\n            c = function() {\n              g(), d.removeEvent(h);\n            };\n          }\n          return o[h] = c, h;\n        }\n        return !1;\n      }, d.removeEvent = function(c) {\n        delete o[c];\n      }, d.clear = function() {\n        o = {};\n      }, d;\n    }(this)), a && a.thisObject && (i = i.bind(a.thisObject));\n    var r = n + \":\" + e.listeners[n].addEvent(i, a);\n    return a && a.id && (r = a.id), r;\n  }, t.attachAll = function(n) {\n    this.attachEvent(\"listen_all\", n);\n  }, t.callEvent = function(n, i) {\n    if (e._silent_mode) return !0;\n    var a = \"ev_\" + n.toLowerCase(), r = e.listeners;\n    return r.ev_listen_all && r.ev_listen_all.apply(this, [n].concat(i)), !r[a] || r[a].apply(this, i);\n  }, t.checkEvent = function(n) {\n    return !!e.listeners[\"ev_\" + n.toLowerCase()];\n  }, t.detachEvent = function(n) {\n    if (n) {\n      var i = e.listeners;\n      for (var a in i) i[a].removeEvent(n);\n      var r = n.split(\":\");\n      if (i = e.listeners, r.length === 2) {\n        var s = r[0], o = r[1];\n        i[s] && i[s].removeEvent(o);\n      }\n    }\n  }, t.detachAllEvents = function() {\n    for (var n in e.listeners) e.listeners[n].clear();\n  };\n}\nvar Ce = { second: 1, minute: 60, hour: 3600, day: 86400, week: 604800, month: 2592e3, quarter: 7776e3, year: 31536e3 };\nfunction Vt(t) {\n  return Ce[t] || Ce.hour;\n}\nfunction kt(t, e) {\n  if (t.forEach) t.forEach(e);\n  else for (var n = t.slice(), i = 0; i < n.length; i++) e(n[i], i);\n}\nfunction Ln(t, e) {\n  if (t.find) return t.find(e);\n  for (var n = 0; n < t.length; n++) if (e(t[n], n)) return t[n];\n}\nfunction zt(t, e) {\n  if (t.includes) return t.includes(e);\n  for (var n = 0; n < t.length; n++) if (t[n] === e) return !0;\n  return !1;\n}\nfunction fe(t) {\n  return Array.isArray ? Array.isArray(t) : t && t.length !== void 0 && t.pop && t.push;\n}\nfunction Z(t) {\n  return !(!t || typeof t != \"object\") && !!(t.getFullYear && t.getMonth && t.getDate);\n}\nfunction bt(t) {\n  return Z(t) && !isNaN(t.getTime());\n}\nfunction De(t, e) {\n  var n, i = function() {\n    i.$cancelTimeout(), i.$pending = !0;\n    var a = Array.prototype.slice.call(arguments);\n    n = setTimeout(function() {\n      t.apply(this, a), i.$pending = !1;\n    }, e);\n  };\n  return i.$pending = !1, i.$cancelTimeout = function() {\n    clearTimeout(n), i.$pending = !1;\n  }, i.$execute = function() {\n    var a = Array.prototype.slice.call(arguments);\n    t.apply(this, a), i.$cancelTimeout();\n  }, i;\n}\nfunction at(t, e) {\n  return Ae(t) && !Ae(e) && (t = \"0\"), t;\n}\nfunction Ae(t) {\n  return t === 0;\n}\nfunction At(t, e) {\n  for (var n, i, a, r = 0, s = t.length - 1; r <= s; ) if (i = +t[n = Math.floor((r + s) / 2)], a = +t[n - 1], i < e) r = n + 1;\n  else {\n    if (!(i > e)) {\n      for (; +t[n] == +t[n + 1]; ) n++;\n      return n;\n    }\n    if (!isNaN(a) && a < e) return n - 1;\n    s = n - 1;\n  }\n  return t.length - 1;\n}\nclass Pn {\n  constructor(e, n, i) {\n    var a;\n    this._el = document.createElement(\"div\"), this.defaultRender = (r, s) => {\n      this._el || (this._el = document.createElement(\"div\"));\n      const o = this._el, l = Math.min(r.relative.top, s.relative.top), d = Math.max(r.relative.top, s.relative.top), c = Math.min(r.relative.left, s.relative.left), u = Math.max(r.relative.left, s.relative.left);\n      if (this._singleRow) {\n        const h = this._getTaskPositionByTop(this._startPoint.relative.top);\n        o.style.height = h.height + \"px\", o.style.top = h.top + \"px\";\n      } else o.style.height = Math.abs(d - l) + \"px\", o.style.top = l + \"px\";\n      return o.style.width = Math.abs(u - c) + \"px\", o.style.left = c + \"px\", o;\n    }, this._gantt = n, this._view = i, this._viewPort = e.viewPort, this._el.classList.add(e.className), typeof e.callback == \"function\" && (this._callback = e.callback), this.render = () => {\n      let r;\n      r = e.render ? e.render(this._startPoint, this._endPoint) : this.defaultRender(this._startPoint, this._endPoint), r !== this._el && (this._el && this._el.parentNode && this._el.parentNode.removeChild(this._el), this._el = r), e.className !== \"\" && this._el.classList.add(e.className), this.draw();\n    }, (a = this._viewPort).attachEvent && a.detachEvent || ot(this._viewPort), this._singleRow = e.singleRow, this._useRequestAnimationFrame = e.useRequestAnimationFrame;\n  }\n  draw() {\n    if (this._useRequestAnimationFrame) return requestAnimationFrame(() => {\n      this._viewPort.appendChild(this.getElement());\n    });\n    this._viewPort.appendChild(this.getElement());\n  }\n  clear() {\n    if (this._useRequestAnimationFrame) return requestAnimationFrame(() => {\n      this._el.parentNode && this._viewPort.removeChild(this._el);\n    });\n    this._el.parentNode && this._viewPort.removeChild(this._el);\n  }\n  getElement() {\n    return this._el;\n  }\n  getViewPort() {\n    return this._viewPort;\n  }\n  setStart(e) {\n    const n = this._gantt;\n    this._startPoint = e, this._startDate = n.dateFromPos(this._startPoint.relative.left), this._viewPort.callEvent(\"onBeforeDrag\", [this._startPoint]);\n  }\n  setEnd(e) {\n    const n = this._gantt;\n    if (this._endPoint = e, this._singleRow) {\n      const i = this._getTaskPositionByTop(this._startPoint.relative.top);\n      this._endPoint.relative.top = i.top;\n    }\n    this._endDate = n.dateFromPos(this._endPoint.relative.left), this._startPoint.relative.left > this._endPoint.relative.left && (this._positionPoint = { relative: { left: this._endPoint.relative.left, top: this._positionPoint.relative.top }, absolute: { left: this._endPoint.absolute.left, top: this._positionPoint.absolute.top } }), this._startPoint.relative.top > this._endPoint.relative.top && (this._positionPoint = { relative: { left: this._positionPoint.relative.left, top: this._endPoint.relative.top }, absolute: { left: this._positionPoint.absolute.left, top: this._endPoint.absolute.top } }), this._viewPort.callEvent(\"onDrag\", [this._startPoint, this._endPoint]);\n  }\n  setPosition(e) {\n    this._positionPoint = e;\n  }\n  dragEnd(e) {\n    const n = this._gantt;\n    e.relative.left < 0 && (e.relative.left = 0), this._viewPort.callEvent(\"onBeforeDragEnd\", [this._startPoint, e]), this.setEnd(e), this._endDate = this._endDate || n.getState().max_date, this._startDate.valueOf() > this._endDate.valueOf() && ([this._startDate, this._endDate] = [this._endDate, this._startDate]), this.clear();\n    const i = n.getTaskByTime(this._startDate, this._endDate), a = this._getTasksByTop(this._startPoint.relative.top, this._endPoint.relative.top);\n    this._viewPort.callEvent(\"onDragEnd\", [this._startPoint, this._endPoint]), this._callback && this._callback(this._startPoint, this._endPoint, this._startDate, this._endDate, i, a);\n  }\n  getInBounds() {\n    return this._singleRow;\n  }\n  _getTasksByTop(e, n) {\n    const i = this._gantt;\n    let a = e, r = n;\n    e > n && (a = n, r = e);\n    const s = this._getTaskPositionByTop(a).index, o = this._getTaskPositionByTop(r).index, l = [];\n    for (let d = s; d <= o; d++)\n      i.getTaskByIndex(d) && l.push(i.getTaskByIndex(d));\n    return l;\n  }\n  _getTaskPositionByTop(e) {\n    const n = this._gantt, i = this._view, a = i.getItemIndexByTopPosition(e), r = n.getTaskByIndex(a);\n    if (r) {\n      const s = i.getItemHeight(r.id);\n      return { top: i.getItemTop(r.id) || 0, height: s || 0, index: a };\n    }\n    {\n      const s = i.getTotalHeight();\n      return { top: e > s ? s : 0, height: n.config.row_height, index: e > s ? n.getTaskCount() : 0 };\n    }\n  }\n}\nlet te = !1;\nclass Yt {\n  constructor(e) {\n    this._mouseDown = !1, this._calculateDirectionVector = () => {\n      if (this._trace.length >= 10) {\n        const n = this._trace.slice(this._trace.length - 10), i = [];\n        for (let r = 1; r < n.length; r++) i.push({ x: n[r].x - n[r - 1].x, y: n[r].y - n[r - 1].y });\n        const a = { x: 0, y: 0 };\n        return i.forEach((r) => {\n          a.x += r.x, a.y += r.y;\n        }), { magnitude: Math.sqrt(a.x * a.x + a.y * a.y), angleDegrees: 180 * Math.atan2(Math.abs(a.y), Math.abs(a.x)) / Math.PI };\n      }\n      return null;\n    }, this._applyDndReadyStyles = () => {\n      this._timeline.$task.classList.add(\"gantt_timeline_move_available\");\n    }, this._clearDndReadyStyles = () => {\n      this._timeline.$task.classList.remove(\"gantt_timeline_move_available\");\n    }, this._getScrollPosition = (n) => {\n      const i = this._gantt;\n      return { x: i.$ui.getView(n.$config.scrollX).getScrollState().position, y: i.$ui.getView(n.$config.scrollY).getScrollState().position };\n    }, this._countNewScrollPosition = (n) => {\n      const i = this._calculateDirectionVector();\n      let a = this._startPoint.x - n.x, r = this._startPoint.y - n.y;\n      return i && (i.angleDegrees < 15 ? r = 0 : i.angleDegrees > 75 && (a = 0)), { x: this._scrollState.x + a, y: this._scrollState.y + r };\n    }, this._setScrollPosition = (n, i) => {\n      const a = this._gantt;\n      requestAnimationFrame(() => {\n        a.scrollLayoutCell(n.$id, i.x, i.y);\n      });\n    }, this._stopDrag = (n) => {\n      const i = this._gantt;\n      if (this._trace = [], i.$root.classList.remove(\"gantt_noselect\"), this._originalReadonly !== void 0 && (i.config.readonly = this._originalReadonly, this._mouseDown && i.config.drag_timeline && i.config.drag_timeline.render && i.render()), this._originAutoscroll !== void 0 && (i.config.autoscroll = this._originAutoscroll), i.config.drag_timeline) {\n        const { useKey: a } = i.config.drag_timeline;\n        if (a && n[a] !== !0) return;\n      }\n      this._mouseDown = !1, te = !1;\n    }, this._startDrag = (n) => {\n      const i = this._gantt;\n      this._originAutoscroll = i.config.autoscroll, i.config.autoscroll = !1, te = !0, i.$root.classList.add(\"gantt_noselect\"), this._originalReadonly = i.config.readonly, i.config.readonly = !0, i.config.drag_timeline && i.config.drag_timeline.render && i.render(), this._trace = [], this._mouseDown = !0;\n      const { x: a, y: r } = this._getScrollPosition(this._timeline);\n      this._scrollState = { x: a, y: r }, this._startPoint = { x: n.clientX, y: n.clientY }, this._trace.push(this._startPoint);\n    }, this._gantt = e, this._domEvents = e._createDomEventScope(), this._trace = [];\n  }\n  static create(e) {\n    return new Yt(e);\n  }\n  static _isDragInProgress() {\n    return te;\n  }\n  destructor() {\n    this._domEvents.detachAll();\n  }\n  attach(e) {\n    this._timeline = e;\n    const n = this._gantt;\n    this._domEvents.attach(e.$task, \"mousedown\", (i) => {\n      if (!n.config.drag_timeline) return;\n      const { useKey: a, ignore: r, enabled: s } = n.config.drag_timeline;\n      if (s === !1) return;\n      let o = \".gantt_task_line, .gantt_task_link\";\n      r !== void 0 && (o = r instanceof Array ? r.join(\", \") : r), o && n.utils.dom.closest(i.target, o) || a && i[a] !== !0 || this._startDrag(i);\n    }), this._domEvents.attach(document, \"keydown\", (i) => {\n      if (!n.config.drag_timeline) return;\n      const { useKey: a } = n.config.drag_timeline;\n      a && i[a] === !0 && this._applyDndReadyStyles();\n    }), this._domEvents.attach(document, \"keyup\", (i) => {\n      if (!n.config.drag_timeline) return;\n      const { useKey: a } = n.config.drag_timeline;\n      a && i[a] === !1 && (this._clearDndReadyStyles(), this._stopDrag(i));\n    }), this._domEvents.attach(document, \"mouseup\", (i) => {\n      this._stopDrag(i);\n    }), this._domEvents.attach(n.$root, \"mouseup\", (i) => {\n      this._stopDrag(i);\n    }), this._domEvents.attach(document, \"mouseleave\", (i) => {\n      this._stopDrag(i);\n    }), this._domEvents.attach(n.$root, \"mouseleave\", (i) => {\n      this._stopDrag(i);\n    }), this._domEvents.attach(n.$root, \"mousemove\", (i) => {\n      if (!n.config.drag_timeline) return;\n      const { useKey: a } = n.config.drag_timeline;\n      if (a && i[a] !== !0) return;\n      const r = this._gantt.ext.clickDrag, s = (this._gantt.config.click_drag || {}).useKey;\n      if ((!r || !s || a || !i[s]) && this._mouseDown === !0) {\n        this._trace.push({ x: i.clientX, y: i.clientY });\n        const o = this._countNewScrollPosition({ x: i.clientX, y: i.clientY });\n        this._setScrollPosition(e, o), this._scrollState = o, this._startPoint = { x: i.clientX, y: i.clientY };\n      }\n    });\n  }\n}\nfunction Rn(t) {\n  (function() {\n    var e = [];\n    function n() {\n      return !!e.length;\n    }\n    function i(d) {\n      setTimeout(function() {\n        n() || t.$destroyed || t.focus();\n      }, 1);\n    }\n    function a(d) {\n      t.eventRemove(d, \"keydown\", s), t.event(d, \"keydown\", s), e.push(d);\n    }\n    function r() {\n      var d = e.pop();\n      d && t.eventRemove(d, \"keydown\", s), i();\n    }\n    function s(d) {\n      var c = d.currentTarget;\n      c == e[e.length - 1] && t.$keyboardNavigation.trapFocus(c, d);\n    }\n    function o() {\n      a(t.getLightbox());\n    }\n    t.attachEvent(\"onLightbox\", o), t.attachEvent(\"onAfterLightbox\", r), t.attachEvent(\"onLightboxChange\", function() {\n      r(), o();\n    }), t.attachEvent(\"onAfterQuickInfo\", function() {\n      i();\n    }), t.attachEvent(\"onMessagePopup\", function(d) {\n      l = t.utils.dom.getActiveElement(), a(d);\n    }), t.attachEvent(\"onAfterMessagePopup\", function() {\n      r(), setTimeout(function() {\n        l && (l.focus(), l = null);\n      }, 1);\n    });\n    var l = null;\n    t.$keyboardNavigation.isModal = n;\n  })();\n}\nclass Hn {\n  constructor(e) {\n    this.show = (n, i) => {\n      i === void 0 ? this._showForTask(n) : this._showAtCoordinates(n, i);\n    }, this.hide = (n) => {\n      const i = this._gantt, a = this._quickInfoBox;\n      this._quickInfoBoxId = 0;\n      const r = this._quickInfoTask;\n      if (this._quickInfoTask = null, a && a.parentNode) {\n        if (i.config.quick_info_detached) return i.callEvent(\"onAfterQuickInfo\", [r]), a.parentNode.removeChild(a);\n        a.className += \" gantt_qi_hidden\", a.style.right === \"auto\" ? a.style.left = \"-350px\" : a.style.right = \"-350px\", n && (a.style.left = a.style.right = \"\", a.parentNode.removeChild(a)), i.callEvent(\"onAfterQuickInfo\", [r]);\n      }\n    }, this.getNode = () => this._quickInfoBox ? this._quickInfoBox : null, this.setContainer = (n) => {\n      n && (this._container = typeof n == \"string\" ? document.getElementById(n) : n);\n    }, this.setContent = (n) => {\n      const i = this._gantt, a = { taskId: null, header: { title: \"\", date: \"\" }, content: \"\", buttons: i.config.quickinfo_buttons };\n      n || (n = a), n.taskId || (n.taskId = a.taskId), n.header || (n.header = a.header), n.header.title || (n.header.title = a.header.title), n.header.date || (n.header.date = a.header.date), n.content || (n.content = a.content), n.buttons || (n.buttons = a.buttons);\n      let r = this.getNode();\n      r || (r = this._createQuickInfoElement()), n.taskId && (this._quickInfoBoxId = n.taskId);\n      const s = r.querySelector(\".gantt_cal_qi_title\"), o = s.querySelector(\".gantt_cal_qi_tcontent\"), l = s.querySelector(\".gantt_cal_qi_tdate\"), d = r.querySelector(\".gantt_cal_qi_content\"), c = r.querySelector(\".gantt_cal_qi_controls\");\n      i._waiAria.quickInfoHeader(r, [n.header.title, n.header.date].join(\" \")), o.innerHTML = n.header.title, l.innerHTML = n.header.date, n.header.title || n.header.date ? s.style.display = \"\" : s.style.display = \"none\", d.innerHTML = n.content;\n      const u = n.buttons;\n      u.length ? c.style.display = \"\" : c.style.display = \"none\";\n      let h = \"\";\n      for (let g = 0; g < u.length; g++) {\n        const p = i._waiAria.quickInfoButtonAttrString(i.locale.labels[u[g]]);\n        h += `<div class=\"gantt_qi_big_icon ${u[g]} dhx_gantt_${u[g]}\" title=\"${i.locale.labels[u[g]]}\" ${p}>\n            <div class='dhx_menu_icon dhx_gantt_icon ${u[g]} gantt_menu_icon dhx_gantt_${u[g]}'></div>\n            <div>${i.locale.labels[u[g]]}</div>\n         </div>`;\n      }\n      c.innerHTML = h, i.eventRemove(r, \"click\", this._qiButtonClickHandler), i.eventRemove(r, \"keypress\", this._qiKeyPressHandler), i.event(r, \"click\", this._qiButtonClickHandler), i.event(r, \"keypress\", this._qiKeyPressHandler);\n    }, this._qiButtonClickHandler = (n) => {\n      this._qi_button_click(n.target);\n    }, this._qiKeyPressHandler = (n) => {\n      const i = n.which;\n      i !== 13 && i !== 32 || setTimeout(() => {\n        this._qi_button_click(n.target);\n      }, 1);\n    }, this._gantt = e;\n  }\n  _showAtCoordinates(e, n) {\n    this.hide(!0), this._quickInfoBoxId = 0, this._quickInfoTask = null, this._quickInfoBox || (this._createQuickInfoElement(), this.setContent()), this._appendAtCoordinates(e, n), this._gantt.callEvent(\"onQuickInfo\", [null]);\n  }\n  _showForTask(e) {\n    const n = this._gantt;\n    if (e === this._quickInfoBoxId && n.utils.dom.isChildOf(this._quickInfoBox, document.body) || !n.config.show_quick_info) return;\n    this.hide(!0);\n    const i = this._getContainer(), a = this._get_event_counter_part(e, 6, i.xViewport, i.yViewport);\n    a && (this._quickInfoBox = this._init_quick_info(e), this._quickInfoTask = e, this._quickInfoBox.className = this._prepare_quick_info_classname(e), this._fill_quick_data(e), this._show_quick_info(a, 6), n.callEvent(\"onQuickInfo\", [e]));\n  }\n  _get_event_counter_part(e, n, i, a) {\n    const r = this._gantt;\n    let s = r.getTaskNode(e);\n    if (!s && (s = r.getTaskRowNode(e), !s)) return null;\n    let o = 0;\n    const l = n + s.offsetTop + s.offsetHeight;\n    let d = s;\n    if (r.utils.dom.isChildOf(d, i)) for (; d && d !== i; ) o += d.offsetLeft, d = d.offsetParent;\n    const c = r.getScrollState();\n    return d ? { left: o, top: l, dx: o + s.offsetWidth / 2 - c.x > i.offsetWidth / 2 ? 1 : 0, dy: l + s.offsetHeight / 2 - c.y > a.offsetHeight / 2 ? 1 : 0, width: s.offsetWidth, height: s.offsetHeight } : null;\n  }\n  _createQuickInfoElement() {\n    const e = this._gantt, n = document.createElement(\"div\");\n    n.className += \"gantt_cal_quick_info\", e._waiAria.quickInfoAttr(n);\n    var i = `\n\t\t<div class=\"gantt_cal_qi_tcontrols\">\n\t\t\t<a class=\"gantt_cal_qi_close_btn dhx_gantt_icon dhx_gantt_icon_close\"></a>\n\t\t</div>\n\t\t<div class=\"gantt_cal_qi_title\" ${e._waiAria.quickInfoHeaderAttrString()}>\n\t\t\t\t\n\t\t\t\t<div class=\"gantt_cal_qi_tcontent\"></div>\n\t\t\t\t<div class=\"gantt_cal_qi_tdate\"></div>\n\t\t\t</div>\n\t\t\t<div class=\"gantt_cal_qi_content\"></div>`;\n    if (i += '<div class=\"gantt_cal_qi_controls\">', i += \"</div>\", n.innerHTML = i, e.config.quick_info_detached) {\n      const a = this._getContainer();\n      e.event(a.parent, \"scroll\", () => {\n        this.hide();\n      });\n    }\n    return this._quickInfoBox = n, n;\n  }\n  _init_quick_info(e) {\n    const n = this._gantt, i = n.getTask(e);\n    return typeof this._quickInfoReadonly == \"boolean\" && n.isReadonly(i) !== this._quickInfoReadonly && (this.hide(!0), this._quickInfoBox = null), this._quickInfoReadonly = n.isReadonly(i), this._quickInfoBox || (this._quickInfoBox = this._createQuickInfoElement()), this._quickInfoBox;\n  }\n  _prepare_quick_info_classname(e) {\n    const n = this._gantt, i = n.getTask(e);\n    let a = `gantt_cal_quick_info gantt_${n.getTaskType(i)}`;\n    const r = n.templates.quick_info_class(i.start_date, i.end_date, i);\n    return r && (a += \" \" + r), a;\n  }\n  _fill_quick_data(e) {\n    const n = this._gantt, i = n.getTask(e);\n    this._quickInfoBoxId = e;\n    let a = [];\n    if (this._quickInfoReadonly) {\n      const r = n.config.quickinfo_buttons, s = { icon_delete: !0, icon_edit: !0 };\n      for (let o = 0; o < r.length; o++) this._quickInfoReadonly && s[r[o]] || a.push(r[o]);\n    } else a = n.config.quickinfo_buttons;\n    this.setContent({ header: { title: n.templates.quick_info_title(i.start_date, i.end_date, i), date: n.templates.quick_info_date(i.start_date, i.end_date, i) }, content: n.templates.quick_info_content(i.start_date, i.end_date, i), buttons: a });\n  }\n  _appendAtCoordinates(e, n) {\n    const i = this._quickInfoBox, a = this._getContainer();\n    i.parentNode && i.parentNode.nodeName.toLowerCase() !== \"#document-fragment\" || a.parent.appendChild(i), i.style.left = e + \"px\", i.style.top = n + \"px\";\n  }\n  _show_quick_info(e, n) {\n    const i = this._gantt, a = this._quickInfoBox;\n    if (i.config.quick_info_detached) {\n      const r = this._getContainer();\n      a.parentNode && a.parentNode.nodeName.toLowerCase() !== \"#document-fragment\" || r.parent.appendChild(a);\n      const s = a.offsetWidth, o = a.offsetHeight, l = i.getScrollState(), d = r.xViewport, c = r.yViewport, u = d.offsetWidth + l.x - s, h = e.top - l.y + o;\n      let g = e.top;\n      h > c.offsetHeight / 2 && (g = e.top - (o + e.height + 2 * n), g < l.y && h <= c.offsetHeight && (g = e.top)), g < l.y && (g = l.y);\n      const p = Math.min(Math.max(l.x, e.left - e.dx * (s - e.width)), u), y = g;\n      this._appendAtCoordinates(p, y);\n    } else a.style.top = \"20px\", e.dx === 1 ? (a.style.right = \"auto\", a.style.left = \"-300px\", setTimeout(() => {\n      a.style.left = \"10px\";\n    }, 1)) : (a.style.left = \"auto\", a.style.right = \"-300px\", setTimeout(() => {\n      a.style.right = \"10px\";\n    }, 1)), a.className += \" gantt_qi_\" + (e.dx === 1 ? \"left\" : \"right\"), i.$root.appendChild(a);\n  }\n  _qi_button_click(e) {\n    const n = this._gantt, i = this._quickInfoBox;\n    if (!e || e === i) return;\n    if (e.closest(\".gantt_cal_qi_close_btn\")) return void this.hide();\n    const a = e.className;\n    if (a.indexOf(\"_icon\") !== -1) {\n      const r = this._quickInfoBoxId;\n      n.$click.buttons[a.split(\" \")[1].replace(\"icon_\", \"\")](r);\n    } else this._qi_button_click(e.parentNode);\n  }\n  _getContainer() {\n    const e = this._gantt;\n    let n = this._container ? this._container : e.$task_data;\n    return n && n.offsetHeight && n.offsetWidth ? { parent: n, xViewport: e.$task, yViewport: e.$task_data } : (n = this._container ? this._container : e.$grid_data, n && n.offsetHeight && n.offsetWidth ? { parent: n, xViewport: e.$grid, yViewport: e.$grid_data } : { parent: this._container ? this._container : e.$layout, xViewport: e.$layout, yViewport: e.$layout });\n  }\n}\nvar ee, On = {}.constructor.toString();\nfunction q(t) {\n  var e, n;\n  if (t && typeof t == \"object\") switch (!0) {\n    case Z(t):\n      n = new Date(t);\n      break;\n    case fe(t):\n      for (n = new Array(t.length), e = 0; e < t.length; e++) n[e] = q(t[e]);\n      break;\n    default:\n      if (function(i) {\n        return i.constructor.toString() !== On;\n      }(t)) n = Object.create(t);\n      else {\n        if (function(i) {\n          return i.$$typeof && i.$$typeof.toString().includes(\"react.\");\n        }(t)) return n = t;\n        n = {};\n      }\n      for (e in t) Object.prototype.hasOwnProperty.apply(t, [e]) && (n[e] = q(t[e]));\n  }\n  return n || t;\n}\nfunction P(t, e, n) {\n  for (var i in e) (t[i] === void 0 || n) && (t[i] = e[i]);\n  return t;\n}\nfunction W(t) {\n  return t !== void 0;\n}\nfunction st() {\n  return ee || (ee = (/* @__PURE__ */ new Date()).valueOf()), ++ee;\n}\nfunction R(t, e) {\n  return t.bind ? t.bind(e) : function() {\n    return t.apply(e, arguments);\n  };\n}\nfunction on(t, e, n, i) {\n  t.addEventListener ? t.addEventListener(e, n, i !== void 0 && i) : t.attachEvent && t.attachEvent(\"on\" + e, n);\n}\nfunction ln(t, e, n, i) {\n  t.removeEventListener ? t.removeEventListener(e, n, i !== void 0 && i) : t.detachEvent && t.detachEvent(\"on\" + e, n);\n}\nconst Bn = Object.freeze(Object.defineProperty({ __proto__: null, bind: R, copy: q, defined: W, event: on, eventRemove: ln, mixin: P, uid: st }, Symbol.toStringTag, { value: \"Module\" }));\nfunction Se(t, e) {\n  t = t || on, e = e || ln;\n  var n = [], i = { attach: function(a, r, s, o) {\n    n.push({ element: a, event: r, callback: s, capture: o }), t(a, r, s, o);\n  }, detach: function(a, r, s, o) {\n    e(a, r, s, o);\n    for (var l = 0; l < n.length; l++) {\n      var d = n[l];\n      d.element === a && d.event === r && d.callback === s && d.capture === o && (n.splice(l, 1), l--);\n    }\n  }, detachAll: function() {\n    for (var a = n.slice(), r = 0; r < a.length; r++) {\n      var s = a[r];\n      i.detach(s.element, s.event, s.callback, s.capture), i.detach(s.element, s.event, s.callback, void 0), i.detach(s.element, s.event, s.callback, !1), i.detach(s.element, s.event, s.callback, !0);\n    }\n    n.splice(0, n.length);\n  }, extend: function() {\n    return Se(this.event, this.eventRemove);\n  } };\n  return i;\n}\nclass zn {\n  constructor(e) {\n    this._gantt = e;\n  }\n  getNode() {\n    const e = this._gantt;\n    return this._tooltipNode || (this._tooltipNode = document.createElement(\"div\"), this._tooltipNode.className = \"gantt_tooltip\", e._waiAria.tooltipAttr(this._tooltipNode)), this._tooltipNode;\n  }\n  setViewport(e) {\n    return this._root = e, this;\n  }\n  show(e, n) {\n    const i = this._gantt, a = document.body, r = this.getNode();\n    if (Y(r, a) || (this.hide(), r.style.top = r.style.top || \"0px\", r.style.left = r.style.left || \"0px\", a.appendChild(r)), this._isLikeMouseEvent(e)) {\n      const s = this._calculateTooltipPosition(e);\n      n = s.top, e = s.left;\n    }\n    return r.style.top = n + \"px\", r.style.left = e + \"px\", i._waiAria.tooltipVisibleAttr(r), this;\n  }\n  hide() {\n    const e = this._gantt, n = this.getNode();\n    return n && n.parentNode && n.parentNode.removeChild(n), e._waiAria.tooltipHiddenAttr(n), this;\n  }\n  setContent(e) {\n    return this.getNode().innerHTML = e, this;\n  }\n  _isLikeMouseEvent(e) {\n    return !(!e || typeof e != \"object\") && \"clientX\" in e && \"clientY\" in e;\n  }\n  _getViewPort() {\n    return this._root || document.body;\n  }\n  _calculateTooltipPosition(e) {\n    const n = this._gantt, i = this._getViewPortSize(), a = this.getNode(), r = { top: 0, left: 0, width: a.offsetWidth, height: a.offsetHeight, bottom: 0, right: 0 }, s = n.config.tooltip_offset_x, o = n.config.tooltip_offset_y, l = document.body, d = rt(e, l), c = V(l);\n    d.y += c.y, r.top = d.y, r.left = d.x, r.top += o, r.left += s, r.bottom = r.top + r.height, r.right = r.left + r.width;\n    const u = window.scrollY + l.scrollTop;\n    return r.top < i.top - u ? (r.top = i.top, r.bottom = r.top + r.height) : r.bottom > i.bottom && (r.bottom = i.bottom, r.top = r.bottom - r.height), r.left < i.left ? (r.left = i.left, r.right = i.left + r.width) : r.right > i.right && (r.right = i.right, r.left = r.right - r.width), d.x >= r.left && d.x <= r.right && (r.left = d.x - r.width - s, r.right = r.left + r.width), d.y >= r.top && d.y <= r.bottom && (r.top = d.y - r.height - o, r.bottom = r.top + r.height), r;\n  }\n  _getViewPortSize() {\n    const e = this._gantt, n = this._getViewPort();\n    let i, a = n, r = window.scrollY + document.body.scrollTop, s = window.scrollX + document.body.scrollLeft;\n    return n === e.$task_data ? (a = e.$task, r = 0, s = 0, i = V(e.$task)) : i = V(a), { left: i.x + s, top: i.y + r, width: i.width, height: i.height, bottom: i.y + i.height + r, right: i.x + i.width + s };\n  }\n}\nclass Wn {\n  constructor(e) {\n    this._listeners = {}, this.tooltip = new zn(e), this._gantt = e, this._domEvents = Se(), this._initDelayedFunctions();\n  }\n  destructor() {\n    this.tooltip.hide(), this._domEvents.detachAll();\n  }\n  hideTooltip() {\n    this.delayHide();\n  }\n  attach(e) {\n    let n = document.body;\n    const i = this._gantt;\n    e.global || (n = i.$root);\n    let a = null;\n    const r = (s) => {\n      const o = yt(s), l = ct(o, e.selector);\n      if (Y(o, this.tooltip.getNode())) return;\n      const d = () => {\n        a = l, e.onmouseenter(s, l);\n      };\n      a ? l && l === a ? e.onmousemove(s, l) : (e.onmouseleave(s, a), a = null, l && l !== a && d()) : l && d();\n    };\n    this.detach(e.selector), this._domEvents.attach(n, \"mousemove\", r), this._listeners[e.selector] = { node: n, handler: r };\n  }\n  detach(e) {\n    const n = this._listeners[e];\n    n && this._domEvents.detach(n.node, \"mousemove\", n.handler);\n  }\n  tooltipFor(e) {\n    const n = (i) => {\n      let a = i;\n      return document.createEventObject && !document.createEvent && (a = document.createEventObject(i)), a;\n    };\n    this._initDelayedFunctions(), this.attach({ selector: e.selector, global: e.global, onmouseenter: (i, a) => {\n      const r = e.html(i, a);\n      r && this.delayShow(n(i), r);\n    }, onmousemove: (i, a) => {\n      const r = e.html(i, a);\n      r ? this.delayShow(n(i), r) : (this.delayShow.$cancelTimeout(), this.delayHide());\n    }, onmouseleave: () => {\n      this.delayShow.$cancelTimeout(), this.delayHide();\n    } });\n  }\n  _initDelayedFunctions() {\n    const e = this._gantt;\n    this.delayShow && this.delayShow.$cancelTimeout(), this.delayHide && this.delayHide.$cancelTimeout(), this.tooltip.hide(), this.delayShow = De((n, i) => {\n      e.callEvent(\"onBeforeTooltip\", [n]) === !1 ? this.tooltip.hide() : (this.tooltip.setContent(i), this.tooltip.show(n));\n    }, e.config.tooltip_timeout || 1), this.delayHide = De(() => {\n      this.delayShow.$cancelTimeout(), this.tooltip.hide();\n    }, e.config.tooltip_hide_timeout || 1);\n  }\n}\nconst Ie = { onBeforeUndo: \"onAfterUndo\", onBeforeRedo: \"onAfterRedo\" }, Me = [\"onTaskDragStart\", \"onAfterTaskUpdate\", \"onAfterParentExpand\", \"onAfterTaskDelete\", \"onBeforeBatchUpdate\"];\nclass jn {\n  constructor(e, n) {\n    this._batchAction = null, this._batchMode = !1, this._ignore = !1, this._ignoreMoveEvents = !1, this._initialTasks = {}, this._initialLinks = {}, this._nestedTasks = {}, this._nestedLinks = {}, this._undo = e, this._gantt = n, this._attachEvents();\n  }\n  store(e, n, i = !1) {\n    return n === this._gantt.config.undo_types.task ? this._storeTask(e, i) : n === this._gantt.config.undo_types.link && this._storeLink(e, i);\n  }\n  isMoveEventsIgnored() {\n    return this._ignoreMoveEvents;\n  }\n  toggleIgnoreMoveEvents(e) {\n    this._ignoreMoveEvents = e || !1;\n  }\n  startIgnore() {\n    this._ignore = !0;\n  }\n  stopIgnore() {\n    this._ignore = !1;\n  }\n  startBatchAction() {\n    this._timeout || (this._timeout = setTimeout(() => {\n      this.stopBatchAction(), this._timeout = null;\n    }, 10)), this._ignore || this._batchMode || (this._batchMode = !0, this._batchAction = this._undo.action.create());\n  }\n  stopBatchAction() {\n    if (this._ignore) return;\n    const e = this._undo;\n    this._batchAction && e.logAction(this._batchAction), this._batchMode = !1, this._batchAction = null;\n  }\n  onTaskAdded(e) {\n    this._ignore || this._storeTaskCommand(e, this._undo.command.type.add);\n  }\n  onTaskUpdated(e) {\n    this._ignore || this._storeTaskCommand(e, this._undo.command.type.update);\n  }\n  onTaskMoved(e) {\n    this._ignore || (e.$local_index = this._gantt.getTaskIndex(e.id), this._storeEntityCommand(e, this.getInitialTask(e.id), this._undo.command.type.move, this._undo.command.entity.task));\n  }\n  onTaskDeleted(e) {\n    if (!this._ignore) {\n      if (this._storeTaskCommand(e, this._undo.command.type.remove), this._nestedTasks[e.id]) {\n        const n = this._nestedTasks[e.id];\n        for (let i = 0; i < n.length; i++) this._storeTaskCommand(n[i], this._undo.command.type.remove);\n      }\n      if (this._nestedLinks[e.id]) {\n        const n = this._nestedLinks[e.id];\n        for (let i = 0; i < n.length; i++) this._storeLinkCommand(n[i], this._undo.command.type.remove);\n      }\n    }\n  }\n  onLinkAdded(e) {\n    this._ignore || this._storeLinkCommand(e, this._undo.command.type.add);\n  }\n  onLinkUpdated(e) {\n    this._ignore || this._storeLinkCommand(e, this._undo.command.type.update);\n  }\n  onLinkDeleted(e) {\n    this._ignore || this._storeLinkCommand(e, this._undo.command.type.remove);\n  }\n  setNestedTasks(e, n) {\n    const i = this._gantt;\n    let a = null;\n    const r = [];\n    let s = this._getLinks(i.getTask(e));\n    for (let d = 0; d < n.length; d++) a = this.setInitialTask(n[d]), s = s.concat(this._getLinks(a)), r.push(a);\n    const o = {};\n    for (let d = 0; d < s.length; d++) o[s[d]] = !0;\n    const l = [];\n    for (const d in o) l.push(this.setInitialLink(d));\n    this._nestedTasks[e] = r, this._nestedLinks[e] = l;\n  }\n  setInitialTask(e, n) {\n    const i = this._gantt;\n    if (n || !this._initialTasks[e] || !this._batchMode) {\n      const a = i.copy(i.getTask(e));\n      a.$index = i.getGlobalTaskIndex(e), a.$local_index = i.getTaskIndex(e), this.setInitialTaskObject(e, a);\n    }\n    return this._initialTasks[e];\n  }\n  getInitialTask(e) {\n    return this._initialTasks[e];\n  }\n  clearInitialTasks() {\n    this._initialTasks = {};\n  }\n  setInitialTaskObject(e, n) {\n    this._initialTasks[e] = n;\n  }\n  setInitialLink(e, n) {\n    return this._initialLinks[e] && this._batchMode || (this._initialLinks[e] = this._gantt.copy(this._gantt.getLink(e))), this._initialLinks[e];\n  }\n  getInitialLink(e) {\n    return this._initialLinks[e];\n  }\n  clearInitialLinks() {\n    this._initialLinks = {};\n  }\n  _attachEvents() {\n    let e = null;\n    const n = this._gantt, i = () => {\n      e || (e = setTimeout(() => {\n        e = null;\n      }), this.clearInitialTasks(), n.eachTask((l) => {\n        this.setInitialTask(l.id);\n      }), this.clearInitialLinks(), n.getLinks().forEach((l) => {\n        this.setInitialLink(l.id);\n      }));\n    }, a = (l) => n.copy(n.getTask(l));\n    for (const l in Ie) n.attachEvent(l, () => (this.startIgnore(), !0)), n.attachEvent(Ie[l], () => (this.stopIgnore(), !0));\n    for (let l = 0; l < Me.length; l++) n.attachEvent(Me[l], () => (this.startBatchAction(), !0));\n    n.attachEvent(\"onParse\", () => {\n      this._undo.clearUndoStack(), this._undo.clearRedoStack(), i();\n    }), n.attachEvent(\"onAfterTaskAdd\", (l, d) => {\n      this.setInitialTask(l, !0), this.onTaskAdded(d);\n    }), n.attachEvent(\"onAfterTaskUpdate\", (l, d) => {\n      this.onTaskUpdated(d);\n    }), n.attachEvent(\"onAfterParentExpand\", (l, d) => {\n      this.onTaskUpdated(d);\n    }), n.attachEvent(\"onAfterTaskDelete\", (l, d) => {\n      this.onTaskDeleted(d);\n    }), n.attachEvent(\"onAfterLinkAdd\", (l, d) => {\n      this.setInitialLink(l, !0), this.onLinkAdded(d);\n    }), n.attachEvent(\"onAfterLinkUpdate\", (l, d) => {\n      this.onLinkUpdated(d);\n    }), n.attachEvent(\"onAfterLinkDelete\", (l, d) => {\n      this.onLinkDeleted(d);\n    }), n.attachEvent(\"onRowDragEnd\", (l, d) => (this.onTaskMoved(a(l)), this.toggleIgnoreMoveEvents(), !0)), n.attachEvent(\"onBeforeTaskDelete\", (l) => {\n      this.store(l, n.config.undo_types.task);\n      const d = [];\n      return i(), n.eachTask((c) => {\n        d.push(c.id);\n      }, l), this.setNestedTasks(l, d), !0;\n    });\n    const r = n.getDatastore(\"task\");\n    r.attachEvent(\"onBeforeItemMove\", (l, d, c) => (this.isMoveEventsIgnored() || i(), !0)), r.attachEvent(\"onAfterItemMove\", (l, d, c) => (this.isMoveEventsIgnored() || this.onTaskMoved(a(l)), !0)), n.attachEvent(\"onRowDragStart\", (l, d, c) => (this.toggleIgnoreMoveEvents(!0), i(), !0));\n    let s = null, o = !1;\n    if (n.attachEvent(\"onBeforeTaskDrag\", (l) => {\n      if (s = n.getState().drag_id, s === l) {\n        const d = n.getTask(l);\n        n.isSummaryTask(d) && n.config.drag_project && (o = !0);\n      }\n      if (n.plugins().multiselect) {\n        const d = n.getSelectedTasks();\n        d.length > 1 && d.forEach((c) => {\n          this.store(c, n.config.undo_types.task, !0);\n        });\n      }\n      return this.store(l, n.config.undo_types.task);\n    }), n.attachEvent(\"onAfterTaskDrag\", (l) => {\n      (o || n.plugins().multiselect && n.getSelectedTasks().length > 1) && s === l && (o = !1, s = null, this.stopBatchAction()), this.store(l, n.config.undo_types.task, !0);\n    }), n.attachEvent(\"onLightbox\", (l) => this.store(l, n.config.undo_types.task)), n.attachEvent(\"onBeforeTaskAutoSchedule\", (l) => (this.store(l.id, n.config.undo_types.task, !0), !0)), n.ext.inlineEditors) {\n      let l = null, d = null;\n      n.attachEvent(\"onGanttLayoutReady\", () => {\n        l && n.ext.inlineEditors.detachEvent(l), d && n.ext.inlineEditors.detachEvent(d), d = n.ext.inlineEditors.attachEvent(\"onEditStart\", (c) => {\n          this.store(c.id, n.config.undo_types.task);\n        }), l = n.ext.inlineEditors.attachEvent(\"onBeforeEditStart\", (c) => (this.stopBatchAction(), !0));\n      });\n    }\n  }\n  _storeCommand(e) {\n    const n = this._undo;\n    if (n.updateConfigs(), n.undoEnabled) if (this._batchMode) this._batchAction.commands.push(e);\n    else {\n      const i = n.action.create([e]);\n      n.logAction(i);\n    }\n  }\n  _storeEntityCommand(e, n, i, a) {\n    const r = this._undo.command.create(e, n, i, a);\n    this._storeCommand(r);\n  }\n  _storeTaskCommand(e, n) {\n    this._gantt.isTaskExists(e.id) && (e.$local_index = this._gantt.getTaskIndex(e.id)), this._storeEntityCommand(e, this.getInitialTask(e.id), n, this._undo.command.entity.task);\n  }\n  _storeLinkCommand(e, n) {\n    this._storeEntityCommand(e, this.getInitialLink(e.id), n, this._undo.command.entity.link);\n  }\n  _getLinks(e) {\n    return e.$source.concat(e.$target);\n  }\n  _storeTask(e, n = !1) {\n    const i = this._gantt;\n    return this.setInitialTask(e, n), i.eachTask((a) => {\n      this.setInitialTask(a.id);\n    }, e), !0;\n  }\n  _storeLink(e, n = !1) {\n    return this.setInitialLink(e, n), !0;\n  }\n}\nclass Fn {\n  constructor(e) {\n    this.maxSteps = 100, this.undoEnabled = !0, this.redoEnabled = !0, this.action = { create: (n) => ({ commands: n ? n.slice() : [] }), invert: (n) => {\n      const i = this._gantt.copy(n), a = this.command;\n      for (let r = 0; r < n.commands.length; r++) {\n        const s = i.commands[r] = a.invert(i.commands[r]);\n        s.type !== a.type.update && s.type !== a.type.move || ([s.value, s.oldValue] = [s.oldValue, s.value]);\n      }\n      return i;\n    } }, this.command = { entity: null, type: null, create: (n, i, a, r) => {\n      const s = this._gantt;\n      return { entity: r, type: a, value: s.copy(n), oldValue: s.copy(i || n) };\n    }, invert: (n) => {\n      const i = this._gantt.copy(n);\n      return i.type = this.command.inverseCommands(n.type), i;\n    }, inverseCommands: (n) => {\n      const i = this._gantt, a = this.command.type;\n      switch (n) {\n        case a.update:\n          return a.update;\n        case a.remove:\n          return a.add;\n        case a.add:\n          return a.remove;\n        case a.move:\n          return a.move;\n        default:\n          return i.assert(!1, \"Invalid command \" + n), null;\n      }\n    } }, this._undoStack = [], this._redoStack = [], this._gantt = e;\n  }\n  getUndoStack() {\n    return this._undoStack;\n  }\n  setUndoStack(e) {\n    this._undoStack = e;\n  }\n  getRedoStack() {\n    return this._redoStack;\n  }\n  setRedoStack(e) {\n    this._redoStack = e;\n  }\n  clearUndoStack() {\n    this._undoStack = [];\n  }\n  clearRedoStack() {\n    this._redoStack = [];\n  }\n  updateConfigs() {\n    const e = this._gantt;\n    this.maxSteps = e.config.undo_steps || 100, this.command.entity = e.config.undo_types, this.command.type = e.config.undo_actions, this.undoEnabled = !!e.config.undo, this.redoEnabled = !!e.config.redo;\n  }\n  undo() {\n    const e = this._gantt;\n    if (this.updateConfigs(), !this.undoEnabled) return;\n    const n = this._pop(this._undoStack);\n    if (n && this._reorderCommands(n), e.callEvent(\"onBeforeUndo\", [n]) !== !1 && n) return this._applyAction(this.action.invert(n)), this._push(this._redoStack, e.copy(n)), void e.callEvent(\"onAfterUndo\", [n]);\n    e.callEvent(\"onAfterUndo\", [null]);\n  }\n  redo() {\n    const e = this._gantt;\n    if (this.updateConfigs(), !this.redoEnabled) return;\n    const n = this._pop(this._redoStack);\n    if (n && this._reorderCommands(n), e.callEvent(\"onBeforeRedo\", [n]) !== !1 && n) return this._applyAction(n), this._push(this._undoStack, e.copy(n)), void e.callEvent(\"onAfterRedo\", [n]);\n    e.callEvent(\"onAfterRedo\", [null]);\n  }\n  logAction(e) {\n    this._push(this._undoStack, e), this._redoStack = [];\n  }\n  _push(e, n) {\n    const i = this._gantt;\n    if (!n.commands.length) return;\n    const a = e === this._undoStack ? \"onBeforeUndoStack\" : \"onBeforeRedoStack\";\n    if (i.callEvent(a, [n]) !== !1 && n.commands.length) {\n      for (e.push(n); e.length > this.maxSteps; ) e.shift();\n      return n;\n    }\n  }\n  _pop(e) {\n    return e.pop();\n  }\n  _reorderCommands(e) {\n    const n = { any: 0, link: 1, task: 2 }, i = { move: 1, any: 0 };\n    e.commands.sort(function(a, r) {\n      if (a.entity === \"task\" && r.entity === \"task\") return a.type !== r.type ? (i[r.type] || 0) - (i[a.type] || 0) : a.type === \"move\" && a.oldValue && r.oldValue && r.oldValue.parent === a.oldValue.parent ? a.oldValue.$index - r.oldValue.$index : 0;\n      {\n        const s = n[a.entity] || n.any;\n        return (n[r.entity] || n.any) - s;\n      }\n    });\n  }\n  _applyAction(e) {\n    let n = null;\n    const i = this.command.entity, a = this.command.type, r = this._gantt, s = {};\n    s[i.task] = { add: \"addTask\", get: \"getTask\", update: \"updateTask\", remove: \"deleteTask\", move: \"moveTask\", isExists: \"isTaskExists\" }, s[i.link] = { add: \"addLink\", get: \"getLink\", update: \"updateLink\", remove: \"deleteLink\", isExists: \"isLinkExists\" }, r.batchUpdate(function() {\n      for (let o = 0; o < e.commands.length; o++) {\n        n = e.commands[o];\n        const l = s[n.entity][n.type], d = s[n.entity].get, c = s[n.entity].isExists;\n        if (n.type === a.add) r[l](n.oldValue, n.oldValue.parent, n.oldValue.$local_index);\n        else if (n.type === a.remove) r[c](n.value.id) && r[l](n.value.id);\n        else if (n.type === a.update) {\n          const u = r[d](n.value.id);\n          for (const h in n.value) {\n            let g = !(h.startsWith(\"$\") || h.startsWith(\"_\"));\n            [\"$open\"].indexOf(h) > -1 && (g = !0), g && (u[h] = n.value[h]);\n          }\n          r[l](n.value.id);\n        } else n.type === a.move && (r[l](n.value.id, n.value.$local_index, n.value.parent), r.callEvent(\"onRowDragEnd\", [n.value.id]));\n      }\n    });\n  }\n}\nconst Vn = { click_drag: function(t) {\n  t.ext || (t.ext = {});\n  const e = { className: \"gantt_click_drag_rect\", useRequestAnimationFrame: !0, callback: void 0, singleRow: !1 };\n  function n() {\n    const i = { viewPort: t.$task_data, ...e };\n    t.ext.clickDrag && t.ext.clickDrag.destructor(), t.ext.clickDrag = new Nn(t);\n    const a = t.config.click_drag;\n    i.render = a.render || e.render, i.className = a.className || e.className, i.callback = a.callback || e.callback, i.viewPort = a.viewPort || t.$task_data, i.useRequestAnimationFrame = a.useRequestAnimationFrame === void 0 ? e.useRequestAnimationFrame : a.useRequestAnimationFrame, i.singleRow = a.singleRow === void 0 ? e.singleRow : a.singleRow;\n    const r = t.$ui.getView(\"timeline\"), s = new Pn(i, t, r);\n    t.ext.clickDrag.attach(s, a.useKey, a.ignore);\n  }\n  t.attachEvent(\"onGanttReady\", () => {\n    t.config.click_drag && n();\n  }), t.attachEvent(\"onGanttLayoutReady\", function() {\n    t.$container && t.config.click_drag && t.attachEvent(\"onGanttRender\", function() {\n      n();\n    }, { once: !0 });\n  }), t.attachEvent(\"onDestroy\", () => {\n    t.ext.clickDrag && t.ext.clickDrag.destructor();\n  });\n}, drag_timeline: function(t) {\n  t.ext || (t.ext = {}), t.ext.dragTimeline = { create: () => Yt.create(t), _isDragInProgress: () => Yt._isDragInProgress }, t.config.drag_timeline = { enabled: !0, render: !1 };\n}, fullscreen: function(t) {\n  function e() {\n    const c = document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement || document.msFullscreenElement;\n    return !(!c || c !== document.body);\n  }\n  function n() {\n    try {\n      return document.fullscreenEnabled || document.webkitFullscreenEnabled || document.mozFullScreenEnabled || document.msFullscreenEnabled;\n    } catch (c) {\n      console.error(\"Fullscreen is not available:\", c);\n    }\n  }\n  t.$services.getService(\"state\").registerProvider(\"fullscreen\", () => n() ? { fullscreen: e() } : void 0);\n  let i = { overflow: null, padding: null, paddingTop: null, paddingRight: null, paddingBottom: null, paddingLeft: null };\n  const a = { width: null, height: null, top: null, left: null, position: null, zIndex: null, modified: !1 };\n  let r = null;\n  function s(c, u) {\n    u.width = c.width, u.height = c.height, u.top = c.top, u.left = c.left, u.position = c.position, u.zIndex = c.zIndex;\n  }\n  let o = !1;\n  function l() {\n    if (!t.$container) return;\n    let c;\n    e() ? o && (c = \"onExpand\", function() {\n      const u = t.ext.fullscreen.getFullscreenElement(), h = document.body;\n      s(u.style, a), i = { overflow: h.style.overflow, padding: h.style.padding ? h.style.padding : null, paddingTop: h.style.paddingTop ? h.style.paddingTop : null, paddingRight: h.style.paddingRight ? h.style.paddingRight : null, paddingBottom: h.style.paddingBottom ? h.style.paddingBottom : null, paddingLeft: h.style.paddingLeft ? h.style.paddingLeft : null }, h.style.padding && (h.style.padding = \"0\"), h.style.paddingTop && (h.style.paddingTop = \"0\"), h.style.paddingRight && (h.style.paddingRight = \"0\"), h.style.paddingBottom && (h.style.paddingBottom = \"0\"), h.style.paddingLeft && (h.style.paddingLeft = \"0\"), h.style.overflow = \"hidden\", u.style.width = \"100vw\", u.style.height = \"100vh\", u.style.top = \"0px\", u.style.left = \"0px\", u.style.position = \"absolute\", u.style.zIndex = 1, a.modified = !0, r = function(g) {\n        let p = g.parentNode;\n        const y = [];\n        for (; p && p.style; ) y.push({ element: p, originalPositioning: p.style.position }), p.style.position = \"static\", p = p.parentNode;\n        return y;\n      }(u);\n    }()) : o && (o = !1, c = \"onCollapse\", function() {\n      const u = t.ext.fullscreen.getFullscreenElement(), h = document.body;\n      a.modified && (i.padding && (h.style.padding = i.padding), i.paddingTop && (h.style.paddingTop = i.paddingTop), i.paddingRight && (h.style.paddingRight = i.paddingRight), i.paddingBottom && (h.style.paddingBottom = i.paddingBottom), i.paddingLeft && (h.style.paddingLeft = i.paddingLeft), h.style.overflow = i.overflow, i = { overflow: null, padding: null, paddingTop: null, paddingRight: null, paddingBottom: null, paddingLeft: null }, s(a, u.style), a.modified = !1), r.forEach((g) => {\n        g.element.style.position = g.originalPositioning;\n      }), r = null;\n    }()), setTimeout(() => {\n      t.render();\n    }), setTimeout(() => {\n      t.callEvent(c, [t.ext.fullscreen.getFullscreenElement()]);\n    });\n  }\n  function d() {\n    return !t.$container || !t.ext.fullscreen.getFullscreenElement() ? !0 : n() ? !1 : ((console.warning || console.log)(\"The `fullscreen` feature not being allowed, or full-screen mode not being supported\"), !0);\n  }\n  t.ext.fullscreen = { expand() {\n    if (d() || e() || !t.callEvent(\"onBeforeExpand\", [this.getFullscreenElement()])) return;\n    o = !0;\n    const c = document.body, u = c.webkitRequestFullscreen ? [Element.ALLOW_KEYBOARD_INPUT] : [], h = c.msRequestFullscreen || c.mozRequestFullScreen || c.webkitRequestFullscreen || c.requestFullscreen;\n    h && h.apply(c, u);\n  }, collapse() {\n    if (d() || !e() || !t.callEvent(\"onBeforeCollapse\", [this.getFullscreenElement()])) return;\n    const c = document.msExitFullscreen || document.mozCancelFullScreen || document.webkitExitFullscreen || document.exitFullscreen;\n    c && c.apply(document);\n  }, toggle() {\n    d() || (e() ? this.collapse() : this.expand());\n  }, getFullscreenElement: () => t.$root }, t.expand = function() {\n    t.ext.fullscreen.expand();\n  }, t.collapse = function() {\n    t.ext.fullscreen.collapse();\n  }, t.attachEvent(\"onGanttReady\", function() {\n    t.event(document, \"webkitfullscreenchange\", l), t.event(document, \"mozfullscreenchange\", l), t.event(document, \"MSFullscreenChange\", l), t.event(document, \"fullscreenChange\", l), t.event(document, \"fullscreenchange\", l);\n  });\n}, keyboard_navigation: function(t) {\n  (function(e) {\n    e.config.keyboard_navigation = !0, e.config.keyboard_navigation_cells = !1, e.$keyboardNavigation = {}, e._compose = function() {\n      for (var n = Array.prototype.slice.call(arguments, 0), i = {}, a = 0; a < n.length; a++) {\n        var r = n[a];\n        for (var s in typeof r == \"function\" && (r = new r()), r) i[s] = r[s];\n      }\n      return i;\n    }, function(n) {\n      n.$keyboardNavigation.shortcuts = { createCommand: function() {\n        return { modifiers: { shift: !1, alt: !1, ctrl: !1, meta: !1 }, keyCode: null };\n      }, parse: function(i) {\n        for (var a = [], r = this.getExpressions(this.trim(i)), s = 0; s < r.length; s++) {\n          for (var o = this.getWords(r[s]), l = this.createCommand(), d = 0; d < o.length; d++) this.commandKeys[o[d]] ? l.modifiers[o[d]] = !0 : this.specialKeys[o[d]] ? l.keyCode = this.specialKeys[o[d]] : l.keyCode = o[d].charCodeAt(0);\n          a.push(l);\n        }\n        return a;\n      }, getCommandFromEvent: function(i) {\n        var a = this.createCommand();\n        a.modifiers.shift = !!i.shiftKey, a.modifiers.alt = !!i.altKey, a.modifiers.ctrl = !!i.ctrlKey, a.modifiers.meta = !!i.metaKey, a.keyCode = i.which || i.keyCode, a.keyCode >= 96 && a.keyCode <= 105 && (a.keyCode -= 48);\n        var r = String.fromCharCode(a.keyCode);\n        return r && (a.keyCode = r.toLowerCase().charCodeAt(0)), a;\n      }, getHashFromEvent: function(i) {\n        return this.getHash(this.getCommandFromEvent(i));\n      }, getHash: function(i) {\n        var a = [];\n        for (var r in i.modifiers) i.modifiers[r] && a.push(r);\n        return a.push(i.keyCode), a.join(this.junctionChar);\n      }, getExpressions: function(i) {\n        return i.split(this.junctionChar);\n      }, getWords: function(i) {\n        return i.split(this.combinationChar);\n      }, trim: function(i) {\n        return i.replace(/\\s/g, \"\");\n      }, junctionChar: \",\", combinationChar: \"+\", commandKeys: { shift: 16, alt: 18, ctrl: 17, meta: !0 }, specialKeys: { backspace: 8, tab: 9, enter: 13, esc: 27, space: 32, up: 38, down: 40, left: 37, right: 39, home: 36, end: 35, pageup: 33, pagedown: 34, delete: 46, insert: 45, plus: 107, f1: 112, f2: 113, f3: 114, f4: 115, f5: 116, f6: 117, f7: 118, f8: 119, f9: 120, f10: 121, f11: 122, f12: 123 } };\n    }(e), function(n) {\n      n.$keyboardNavigation.EventHandler = { _handlers: null, findHandler: function(i) {\n        this._handlers || (this._handlers = {});\n        var a = n.$keyboardNavigation.shortcuts.getHash(i);\n        return this._handlers[a];\n      }, doAction: function(i, a) {\n        var r = this.findHandler(i);\n        if (r) {\n          if (n.$keyboardNavigation.facade.callEvent(\"onBeforeAction\", [i, a]) === !1) return;\n          r.call(this, a), a.preventDefault ? a.preventDefault() : a.returnValue = !1;\n        }\n      }, bind: function(i, a) {\n        this._handlers || (this._handlers = {});\n        for (var r = n.$keyboardNavigation.shortcuts, s = r.parse(i), o = 0; o < s.length; o++) this._handlers[r.getHash(s[o])] = a;\n      }, unbind: function(i) {\n        for (var a = n.$keyboardNavigation.shortcuts, r = a.parse(i), s = 0; s < r.length; s++) this._handlers[a.getHash(r[s])] && delete this._handlers[a.getHash(r[s])];\n      }, bindAll: function(i) {\n        for (var a in i) this.bind(a, i[a]);\n      }, initKeys: function() {\n        this._handlers || (this._handlers = {}), this.keys && this.bindAll(this.keys);\n      } };\n    }(e), function(n) {\n      n.$keyboardNavigation.getFocusableNodes = Lt, n.$keyboardNavigation.trapFocus = function(i, a) {\n        if (a.keyCode != 9) return !1;\n        for (var r = n.$keyboardNavigation.getFocusableNodes(i), s = ge(), o = -1, l = 0; l < r.length; l++) if (r[l] == s) {\n          o = l;\n          break;\n        }\n        if (a.shiftKey) {\n          if (o <= 0) {\n            var d = r[r.length - 1];\n            if (d) return d.focus(), a.preventDefault(), !0;\n          }\n        } else if (o >= r.length - 1) {\n          var c = r[0];\n          if (c) return c.focus(), a.preventDefault(), !0;\n        }\n        return !1;\n      };\n    }(e), function(n) {\n      n.$keyboardNavigation.GanttNode = function() {\n      }, n.$keyboardNavigation.GanttNode.prototype = n._compose(n.$keyboardNavigation.EventHandler, { focus: function() {\n        n.focus();\n      }, blur: function() {\n      }, isEnabled: function() {\n        return n.$container.hasAttribute(\"tabindex\");\n      }, scrollHorizontal: function(i) {\n        var a = n.dateFromPos(n.getScrollState().x), r = n.getScale(), s = i < 0 ? -r.step : r.step;\n        a = n.date.add(a, s, r.unit), n.scrollTo(n.posFromDate(a));\n      }, scrollVertical: function(i) {\n        var a = n.getScrollState().y, r = n.config.row_height;\n        n.scrollTo(null, a + (i < 0 ? -1 : 1) * r);\n      }, keys: { \"alt+left\": function(i) {\n        this.scrollHorizontal(-1);\n      }, \"alt+right\": function(i) {\n        this.scrollHorizontal(1);\n      }, \"alt+up\": function(i) {\n        this.scrollVertical(-1);\n      }, \"alt+down\": function(i) {\n        this.scrollVertical(1);\n      }, \"ctrl+z\": function() {\n        n.undo && n.undo();\n      }, \"ctrl+r\": function() {\n        n.redo && n.redo();\n      } } }), n.$keyboardNavigation.GanttNode.prototype.bindAll(n.$keyboardNavigation.GanttNode.prototype.keys);\n    }(e), function(n) {\n      n.$keyboardNavigation.KeyNavNode = function() {\n      }, n.$keyboardNavigation.KeyNavNode.prototype = n._compose(n.$keyboardNavigation.EventHandler, { isValid: function() {\n        return !0;\n      }, fallback: function() {\n        return null;\n      }, moveTo: function(i) {\n        n.$keyboardNavigation.dispatcher.setActiveNode(i);\n      }, compareTo: function(i) {\n        if (!i) return !1;\n        for (var a in this) {\n          if (!!this[a] != !!i[a]) return !1;\n          var r = !(!this[a] || !this[a].toString), s = !(!i[a] || !i[a].toString);\n          if (s != r) return !1;\n          if (s && r) {\n            if (i[a].toString() != this[a].toString()) return !1;\n          } else if (i[a] != this[a]) return !1;\n        }\n        return !0;\n      }, getNode: function() {\n      }, focus: function() {\n        var i = this.getNode();\n        if (i) {\n          var a = n.$keyboardNavigation.facade;\n          a.callEvent(\"onBeforeFocus\", [i]) !== !1 && i && (i.setAttribute(\"tabindex\", \"-1\"), i.$eventAttached || (i.$eventAttached = !0, n.event(i, \"focus\", function(r) {\n            return r.preventDefault(), !1;\n          }, !1)), n.utils.dom.isChildOf(document.activeElement, i) && (i = document.activeElement), i.focus && i.focus(), a.callEvent(\"onFocus\", [this.getNode()]));\n        }\n      }, blur: function() {\n        var i = this.getNode();\n        i && (n.$keyboardNavigation.facade.callEvent(\"onBlur\", [i]), i.setAttribute(\"tabindex\", \"-1\"));\n      } });\n    }(e), function(n) {\n      n.$keyboardNavigation.HeaderCell = function(i) {\n        this.index = i || 0;\n      }, n.$keyboardNavigation.HeaderCell.prototype = n._compose(n.$keyboardNavigation.KeyNavNode, { _handlers: null, isValid: function() {\n        return !(!n.config.show_grid && n.getVisibleTaskCount() || !n.getGridColumns()[this.index] && n.getVisibleTaskCount());\n      }, fallback: function() {\n        if (!n.config.show_grid) return n.getVisibleTaskCount() ? new n.$keyboardNavigation.TaskRow() : null;\n        for (var i = n.getGridColumns(), a = this.index; a >= 0 && !i[a]; ) a--;\n        return i[a] ? new n.$keyboardNavigation.HeaderCell(a) : null;\n      }, fromDomElement: function(i) {\n        var a = pt(i, \"gantt_grid_head_cell\");\n        if (a) {\n          for (var r = 0; a && a.previousSibling; ) a = a.previousSibling, r += 1;\n          return new n.$keyboardNavigation.HeaderCell(r);\n        }\n        return null;\n      }, getNode: function() {\n        const i = n.$grid_scale;\n        return i ? i.childNodes[this.index] : null;\n      }, keys: { left: function() {\n        this.index > 0 && this.moveTo(new n.$keyboardNavigation.HeaderCell(this.index - 1));\n      }, right: function() {\n        var i = n.getGridColumns();\n        this.index < i.length - 1 && this.moveTo(new n.$keyboardNavigation.HeaderCell(this.index + 1));\n      }, down: function() {\n        var i, a = n.getChildren(n.config.root_id);\n        n.isTaskExists(a[0]) && (i = a[0]), i && (n.config.keyboard_navigation_cells ? this.moveTo(new n.$keyboardNavigation.TaskCell(i, this.index)) : this.moveTo(new n.$keyboardNavigation.TaskRow(i)));\n      }, end: function() {\n        var i = n.getGridColumns();\n        this.moveTo(new n.$keyboardNavigation.HeaderCell(i.length - 1));\n      }, home: function() {\n        this.moveTo(new n.$keyboardNavigation.HeaderCell(0));\n      }, \"enter, space\": function() {\n        ge().click();\n      }, \"ctrl+enter\": function() {\n        n.isReadonly(this) || n.createTask({}, this.taskId);\n      } } }), n.$keyboardNavigation.HeaderCell.prototype.bindAll(n.$keyboardNavigation.HeaderCell.prototype.keys);\n    }(e), function(n) {\n      n.$keyboardNavigation.TaskRow = function(i) {\n        if (!i) {\n          var a = n.getChildren(n.config.root_id);\n          a[0] && (i = a[0]);\n        }\n        this.taskId = i, n.isTaskExists(this.taskId) && (this.index = n.getTaskIndex(this.taskId), this.globalIndex = n.getGlobalTaskIndex(this.taskId), this.splitItem = !!n.getTask(this.taskId).$split_subtask, this.parentId = n.getParent(this.taskId));\n      }, n.$keyboardNavigation.TaskRow.prototype = n._compose(n.$keyboardNavigation.KeyNavNode, { _handlers: null, isValid: function() {\n        return n.isTaskExists(this.taskId) && n.getTaskIndex(this.taskId) > -1;\n      }, fallback: function() {\n        if (!n.getVisibleTaskCount()) {\n          var i = new n.$keyboardNavigation.HeaderCell();\n          return i.isValid() ? i : null;\n        }\n        if (this.splitItem) return new n.$keyboardNavigation.TaskRow(this.parentId);\n        var a = -1;\n        if (n.getTaskByIndex(this.globalIndex - 1)) a = this.globalIndex - 1;\n        else if (n.getTaskByIndex(this.globalIndex + 1)) a = this.globalIndex + 1;\n        else for (var r = this.globalIndex; r >= 0; ) {\n          if (n.getTaskByIndex(r)) {\n            a = r;\n            break;\n          }\n          r--;\n        }\n        return a > -1 ? new n.$keyboardNavigation.TaskRow(n.getTaskByIndex(a).id) : void 0;\n      }, fromDomElement: function(i) {\n        if (n.config.keyboard_navigation_cells) return null;\n        var a = n.locate(i);\n        return n.isTaskExists(a) ? new n.$keyboardNavigation.TaskRow(a) : null;\n      }, getNode: function() {\n        if (n.isTaskExists(this.taskId) && n.isTaskVisible(this.taskId)) return n.config.show_grid ? n.$grid.querySelector(`.gantt_row[${n.config.task_attribute}=\"${String(this.taskId).replaceAll('\"', '\\\\\"')}\"]`) : n.getTaskNode(this.taskId);\n      }, focus: function(i) {\n        if (!i) {\n          const a = n.getTaskPosition(n.getTask(this.taskId)), r = n.getTaskHeight(this.taskId), s = n.getScrollState();\n          let o, l;\n          o = n.$task ? n.$task.offsetWidth : s.inner_width, l = n.$grid_data || n.$task_data ? (n.$grid_data || n.$task_data).offsetHeight : s.inner_height;\n          const d = n.config.show_chart && n.$ui.getView(\"timeline\");\n          a.top < s.y || a.top + r > s.y + l ? n.scrollTo(null, a.top - 20) : n.config.scroll_on_click && d && (a.left > s.x + o ? n.scrollTo(a.left - n.config.task_scroll_offset) : a.left + a.width < s.x && n.scrollTo(a.left + a.width - n.config.task_scroll_offset));\n        }\n        n.$keyboardNavigation.KeyNavNode.prototype.focus.apply(this, [i]), function() {\n          var a = n.$ui.getView(\"grid\");\n          if (a && a.$grid_data) {\n            var r = parseInt(a.$grid.scrollLeft), s = parseInt(a.$grid_data.scrollTop), o = a.$config.scrollX;\n            if (o && a.$config.scrollable) {\n              var l = n.$ui.getView(o);\n              l && l.scrollTo(r, s);\n            }\n            var d = a.$config.scrollY;\n            if (d) {\n              var c = n.$ui.getView(d);\n              c && c.scrollTo(r, s);\n            }\n          }\n        }();\n      }, keys: { pagedown: function() {\n        n.getVisibleTaskCount() && this.moveTo(new n.$keyboardNavigation.TaskRow(n.getTaskByIndex(n.getVisibleTaskCount() - 1).id));\n      }, pageup: function() {\n        n.getVisibleTaskCount() && this.moveTo(new n.$keyboardNavigation.TaskRow(n.getTaskByIndex(0).id));\n      }, up: function() {\n        var i = null, a = n.getPrev(this.taskId);\n        i = n.isTaskExists(a) ? new n.$keyboardNavigation.TaskRow(a) : new n.$keyboardNavigation.HeaderCell(), this.moveTo(i);\n      }, down: function() {\n        var i = n.getNext(this.taskId);\n        n.isTaskExists(i) && this.moveTo(new n.$keyboardNavigation.TaskRow(i));\n      }, \"shift+down\": function() {\n        n.hasChild(this.taskId) && !n.getTask(this.taskId).$open && n.open(this.taskId);\n      }, \"shift+up\": function() {\n        n.hasChild(this.taskId) && n.getTask(this.taskId).$open && n.close(this.taskId);\n      }, \"shift+right\": function() {\n        if (!n.isReadonly(this)) {\n          var i = n.getPrevSibling(this.taskId);\n          n.isTaskExists(i) && !n.isChildOf(this.taskId, i) && (n.getTask(i).$open = !0, n.moveTask(this.taskId, -1, i) !== !1 && n.updateTask(this.taskId));\n        }\n      }, \"shift+left\": function() {\n        if (!n.isReadonly(this)) {\n          var i = n.getParent(this.taskId);\n          n.isTaskExists(i) && n.moveTask(this.taskId, n.getTaskIndex(i) + 1, n.getParent(i)) !== !1 && n.updateTask(this.taskId);\n        }\n      }, space: function(i) {\n        n.isSelectedTask(this.taskId) ? n.unselectTask(this.taskId) : n.selectTask(this.taskId);\n      }, \"ctrl+left\": function(i) {\n        n.close(this.taskId);\n      }, \"ctrl+right\": function(i) {\n        n.open(this.taskId);\n      }, delete: function(i) {\n        n.isReadonly(this) || n.$click.buttons.delete(this.taskId);\n      }, enter: function() {\n        n.isReadonly(this) || n.showLightbox(this.taskId);\n      }, \"ctrl+enter\": function() {\n        n.isReadonly(this) || n.createTask({}, this.taskId);\n      } } }), n.$keyboardNavigation.TaskRow.prototype.bindAll(n.$keyboardNavigation.TaskRow.prototype.keys);\n    }(e), function(n) {\n      n.$keyboardNavigation.TaskCell = function(i, a) {\n        if (!(i = at(i, n.config.root_id))) {\n          var r = n.getChildren(n.config.root_id);\n          r[0] && (i = r[0]);\n        }\n        this.taskId = i, this.columnIndex = a || 0, n.isTaskExists(this.taskId) && (this.index = n.getTaskIndex(this.taskId), this.globalIndex = n.getGlobalTaskIndex(this.taskId));\n      }, n.$keyboardNavigation.TaskCell.prototype = n._compose(n.$keyboardNavigation.TaskRow, { _handlers: null, isValid: function() {\n        return n.$keyboardNavigation.TaskRow.prototype.isValid.call(this) && !!n.getGridColumns()[this.columnIndex];\n      }, fallback: function() {\n        var i = n.$keyboardNavigation.TaskRow.prototype.fallback.call(this), a = i;\n        if (i instanceof n.$keyboardNavigation.TaskRow) {\n          for (var r = n.getGridColumns(), s = this.columnIndex; s >= 0 && !r[s]; ) s--;\n          r[s] && (a = new n.$keyboardNavigation.TaskCell(i.taskId, s));\n        }\n        return a;\n      }, fromDomElement: function(i) {\n        if (!n.config.keyboard_navigation_cells) return null;\n        var a = n.locate(i);\n        if (n.isTaskExists(a)) {\n          var r = 0, s = et(i, \"data-column-index\");\n          return s && (r = 1 * s.getAttribute(\"data-column-index\")), new n.$keyboardNavigation.TaskCell(a, r);\n        }\n        return null;\n      }, getNode: function() {\n        if (n.isTaskExists(this.taskId) && (n.isTaskVisible(this.taskId) || n.config.show_tasks_outside_timescale)) {\n          if (n.config.show_grid && n.$grid) {\n            var i = n.$grid.querySelector(\".gantt_row[\" + n.config.task_attribute + \"='\" + this.taskId + \"']\");\n            return i ? i.querySelector(\"[data-column-index='\" + this.columnIndex + \"']\") : null;\n          }\n          return n.getTaskNode(this.taskId);\n        }\n      }, keys: { up: function() {\n        var i = null, a = n.getPrev(this.taskId);\n        i = n.isTaskExists(a) ? new n.$keyboardNavigation.TaskCell(a, this.columnIndex) : new n.$keyboardNavigation.HeaderCell(this.columnIndex), this.moveTo(i);\n      }, down: function() {\n        var i = n.getNext(this.taskId);\n        n.isTaskExists(i) && this.moveTo(new n.$keyboardNavigation.TaskCell(i, this.columnIndex));\n      }, left: function() {\n        this.columnIndex > 0 && this.moveTo(new n.$keyboardNavigation.TaskCell(this.taskId, this.columnIndex - 1));\n      }, right: function() {\n        var i = n.getGridColumns();\n        this.columnIndex < i.length - 1 && this.moveTo(new n.$keyboardNavigation.TaskCell(this.taskId, this.columnIndex + 1));\n      }, end: function() {\n        var i = n.getGridColumns();\n        this.moveTo(new n.$keyboardNavigation.TaskCell(this.taskId, i.length - 1));\n      }, home: function() {\n        this.moveTo(new n.$keyboardNavigation.TaskCell(this.taskId, 0));\n      }, pagedown: function() {\n        n.getVisibleTaskCount() && this.moveTo(new n.$keyboardNavigation.TaskCell(n.getTaskByIndex(n.getVisibleTaskCount() - 1).id, this.columnIndex));\n      }, pageup: function() {\n        n.getVisibleTaskCount() && this.moveTo(new n.$keyboardNavigation.TaskCell(n.getTaskByIndex(0).id, this.columnIndex));\n      } } }), n.$keyboardNavigation.TaskCell.prototype.bindAll(n.$keyboardNavigation.TaskRow.prototype.keys), n.$keyboardNavigation.TaskCell.prototype.bindAll(n.$keyboardNavigation.TaskCell.prototype.keys);\n    }(e), Rn(e), function(n) {\n      n.$keyboardNavigation.dispatcher = { isActive: !1, activeNode: null, globalNode: new n.$keyboardNavigation.GanttNode(), enable: function() {\n        this.isActive = !0, this.setActiveNode(this.getActiveNode());\n      }, disable: function() {\n        this.isActive = !1;\n      }, isEnabled: function() {\n        return !!this.isActive;\n      }, getDefaultNode: function() {\n        var i;\n        return (i = n.config.keyboard_navigation_cells ? new n.$keyboardNavigation.TaskCell() : new n.$keyboardNavigation.TaskRow()).isValid() || (i = i.fallback()), i;\n      }, setDefaultNode: function() {\n        this.setActiveNode(this.getDefaultNode());\n      }, getActiveNode: function() {\n        var i = this.activeNode;\n        return i && !i.isValid() && (i = i.fallback()), i;\n      }, fromDomElement: function(i) {\n        for (var a = [n.$keyboardNavigation.TaskRow, n.$keyboardNavigation.TaskCell, n.$keyboardNavigation.HeaderCell], r = 0; r < a.length; r++) if (a[r].prototype.fromDomElement) {\n          var s = a[r].prototype.fromDomElement(i);\n          if (s) return s;\n        }\n        return null;\n      }, focusGlobalNode: function() {\n        this.blurNode(this.globalNode), this.focusNode(this.globalNode);\n      }, setActiveNode: function(i) {\n        var a = !0;\n        this.activeNode && this.activeNode.compareTo(i) && (a = !1), this.isEnabled() && (a && this.blurNode(this.activeNode), this.activeNode = i, this.focusNode(this.activeNode, !a));\n      }, focusNode: function(i, a) {\n        i && i.focus && i.focus(a);\n      }, blurNode: function(i) {\n        i && i.blur && i.blur();\n      }, keyDownHandler: function(i) {\n        if (!n.$keyboardNavigation.isModal() && this.isEnabled() && !i.defaultPrevented) {\n          var a = this.globalNode, r = n.$keyboardNavigation.shortcuts.getCommandFromEvent(i), s = this.getActiveNode();\n          n.$keyboardNavigation.facade.callEvent(\"onKeyDown\", [r, i]) !== !1 && (s ? s.findHandler(r) ? s.doAction(r, i) : a.findHandler(r) && a.doAction(r, i) : this.setDefaultNode());\n        }\n      }, _timeout: null, awaitsFocus: function() {\n        return this._timeout !== null;\n      }, delay: function(i, a) {\n        clearTimeout(this._timeout), this._timeout = setTimeout(n.bind(function() {\n          this._timeout = null, i();\n        }, this), a || 1);\n      }, clearDelay: function() {\n        clearTimeout(this._timeout);\n      } };\n    }(e), function() {\n      var n = e.$keyboardNavigation.dispatcher;\n      n.isTaskFocused = function(v) {\n        var b = n.activeNode;\n        return (b instanceof e.$keyboardNavigation.TaskRow || b instanceof e.$keyboardNavigation.TaskCell) && b.taskId == v;\n      };\n      var i = function(v) {\n        if (e.config.keyboard_navigation && (e.config.keyboard_navigation_cells || !s(v)) && !o(v) && !function(b) {\n          return !!ct(b.target, \".gantt_cal_light\");\n        }(v)) return n.keyDownHandler(v);\n      }, a = function(v) {\n        if (n.$preventDefault) return v.preventDefault(), e.$container.blur(), !1;\n        n.awaitsFocus() || n.focusGlobalNode();\n      }, r = function() {\n        if (!n.isEnabled()) return;\n        const v = !Y(document.activeElement, e.$container) && document.activeElement.localName != \"body\";\n        var b = n.getActiveNode();\n        if (b && !v) {\n          var _, m, f = b.getNode();\n          f && f.parentNode && (_ = f.parentNode.scrollTop, m = f.parentNode.scrollLeft), b.focus(!0), f && f.parentNode && (f.parentNode.scrollTop = _, f.parentNode.scrollLeft = m);\n        }\n      };\n      function s(v) {\n        return !!ct(v.target, \".gantt_grid_editor_placeholder\");\n      }\n      function o(v) {\n        return !!ct(v.target, \".no_keyboard_navigation\");\n      }\n      function l(v) {\n        if (!e.config.keyboard_navigation || !e.config.keyboard_navigation_cells && s(v)) return !0;\n        if (!o(v)) {\n          var b, _ = n.fromDomElement(v);\n          if (_ && (n.activeNode instanceof e.$keyboardNavigation.TaskCell && Y(v.target, e.$task) && (_ = new e.$keyboardNavigation.TaskCell(_.taskId, n.activeNode.columnIndex)), b = _, e.config.show_grid && e.$ui.getView(\"grid\") && e.config.keyboard_navigation_cells)) {\n            const m = v.target.classList.contains(\"gantt_row\"), f = v.target.closest(\".gantt_task_line\"), k = e.utils.dom.getNodePosition(e.$grid).x, x = k + e.$grid.offsetWidth, $ = e.utils.dom.getNodePosition(document.activeElement).x;\n            if (m || f && ($ < k || x < $)) {\n              let w = e.$grid.scrollLeft;\n              const S = w + e.$grid.offsetWidth;\n              let T = 0;\n              m && (w = e.utils.dom.getRelativeEventPosition(v, e.$grid).x);\n              for (let E = 0; E < e.config.columns.length; E++) {\n                const C = e.config.columns[E];\n                if (!C.hide && (T += C.width, w < T)) {\n                  S < T && (T -= C.width), b.columnIndex = E;\n                  break;\n                }\n              }\n            }\n          }\n          b ? n.isEnabled() ? n.delay(function() {\n            n.setActiveNode(b);\n          }) : n.activeNode = b : (n.$preventDefault = !0, setTimeout(function() {\n            n.$preventDefault = !1;\n          }, 300));\n        }\n      }\n      e.attachEvent(\"onDataRender\", function() {\n        e.config.keyboard_navigation && r();\n      }), e.attachEvent(\"onGanttRender\", function() {\n        e.$root && (e.eventRemove(e.$root, \"keydown\", i), e.eventRemove(e.$container, \"focus\", a), e.eventRemove(e.$container, \"mousedown\", l), e.config.keyboard_navigation ? (e.event(e.$root, \"keydown\", i), e.event(e.$container, \"focus\", a), e.event(e.$container, \"mousedown\", l), e.$container.setAttribute(\"tabindex\", \"0\")) : e.$container.removeAttribute(\"tabindex\"));\n      });\n      var d = e.attachEvent(\"onGanttReady\", function() {\n        if (e.detachEvent(d), e.$data.tasksStore.attachEvent(\"onStoreUpdated\", function(b) {\n          if (e.config.keyboard_navigation && n.isEnabled()) {\n            const _ = n.getActiveNode(), m = e.$ui.getView(\"grid\");\n            if (!m || !m.$grid_data) return;\n            const f = m.getItemTop(b), k = m.$grid_data.scrollTop, x = k + m.$grid_data.getBoundingClientRect().height;\n            _ && _.taskId == b && k <= f && x >= f && r();\n          }\n        }), e._smart_render) {\n          var v = e._smart_render._redrawTasks;\n          e._smart_render._redrawTasks = function(b, _) {\n            if (e.config.keyboard_navigation && n.isEnabled()) {\n              var m = n.getActiveNode();\n              if (m && m.taskId !== void 0) {\n                for (var f = !1, k = 0; k < _.length; k++) if (_[k].id == m.taskId && _[k].start_date) {\n                  f = !0;\n                  break;\n                }\n                f || _.push(e.getTask(m.taskId));\n              }\n            }\n            return v.apply(this, arguments);\n          };\n        }\n      });\n      let c = null, u = !1;\n      e.attachEvent(\"onTaskCreated\", function(v) {\n        return c = v.id, !0;\n      }), e.attachEvent(\"onAfterTaskAdd\", function(v, b) {\n        if (!e.config.keyboard_navigation) return !0;\n        if (n.isEnabled()) {\n          if (v == c && (u = !0, setTimeout(() => {\n            u = !1, c = null;\n          })), u && b.type == e.config.types.placeholder) return;\n          var _ = 0, m = n.activeNode;\n          m instanceof e.$keyboardNavigation.TaskCell && (_ = m.columnIndex);\n          var f = e.config.keyboard_navigation_cells ? e.$keyboardNavigation.TaskCell : e.$keyboardNavigation.TaskRow;\n          b.type == e.config.types.placeholder && e.config.placeholder_task.focusOnCreate === !1 || n.setActiveNode(new f(v, _));\n        }\n      }), e.attachEvent(\"onTaskIdChange\", function(v, b) {\n        if (!e.config.keyboard_navigation) return !0;\n        var _ = n.activeNode;\n        return n.isTaskFocused(v) && (_.taskId = b), !0;\n      });\n      var h = setInterval(function() {\n        e.config.keyboard_navigation && (n.isEnabled() || n.enable());\n      }, 500);\n      function g(v) {\n        var b = { gantt: e.$keyboardNavigation.GanttNode, headerCell: e.$keyboardNavigation.HeaderCell, taskRow: e.$keyboardNavigation.TaskRow, taskCell: e.$keyboardNavigation.TaskCell };\n        return b[v] || b.gantt;\n      }\n      function p(v) {\n        for (var b = e.getGridColumns(), _ = 0; _ < b.length; _++) if (b[_].name == v) return _;\n        return 0;\n      }\n      e.attachEvent(\"onDestroy\", function() {\n        clearInterval(h);\n      });\n      var y = {};\n      ot(y), e.mixin(y, { addShortcut: function(v, b, _) {\n        var m = g(_);\n        m && m.prototype.bind(v, b);\n      }, getShortcutHandler: function(v, b) {\n        var _ = e.$keyboardNavigation.shortcuts.parse(v);\n        if (_.length) return y.getCommandHandler(_[0], b);\n      }, getCommandHandler: function(v, b) {\n        var _ = g(b);\n        if (_ && v) return _.prototype.findHandler(v);\n      }, removeShortcut: function(v, b) {\n        var _ = g(b);\n        _ && _.prototype.unbind(v);\n      }, focus: function(v) {\n        var b, _ = v ? v.type : null, m = g(_);\n        switch (_) {\n          case \"taskCell\":\n            b = new m(v.id, p(v.column));\n            break;\n          case \"taskRow\":\n            b = new m(v.id);\n            break;\n          case \"headerCell\":\n            b = new m(p(v.column));\n        }\n        n.delay(function() {\n          b ? n.setActiveNode(b) : (n.enable(), n.getActiveNode() ? n.awaitsFocus() || n.enable() : n.setDefaultNode());\n        });\n      }, getActiveNode: function() {\n        if (n.isEnabled()) {\n          var v = n.getActiveNode(), b = (m = v) instanceof e.$keyboardNavigation.GanttNode ? \"gantt\" : m instanceof e.$keyboardNavigation.HeaderCell ? \"headerCell\" : m instanceof e.$keyboardNavigation.TaskRow ? \"taskRow\" : m instanceof e.$keyboardNavigation.TaskCell ? \"taskCell\" : null, _ = e.getGridColumns();\n          switch (b) {\n            case \"taskCell\":\n              return { type: \"taskCell\", id: v.taskId, column: _[v.columnIndex].name };\n            case \"taskRow\":\n              return { type: \"taskRow\", id: v.taskId };\n            case \"headerCell\":\n              return { type: \"headerCell\", column: _[v.index].name };\n          }\n        }\n        var m;\n        return null;\n      } }), e.$keyboardNavigation.facade = y, e.ext.keyboardNavigation = y, e.focus = function() {\n        y.focus();\n      }, e.addShortcut = y.addShortcut, e.getShortcutHandler = y.getShortcutHandler, e.removeShortcut = y.removeShortcut;\n    }();\n  })(t);\n}, quick_info: function(t) {\n  t.ext || (t.ext = {}), t.ext.quickInfo = new Hn(t), t.config.quickinfo_buttons = [\"icon_edit\", \"icon_delete\"], t.config.quick_info_detached = !0, t.config.show_quick_info = !0, t.templates.quick_info_title = function(a, r, s) {\n    return s.text.substr(0, 50);\n  }, t.templates.quick_info_content = function(a, r, s) {\n    return s.details || s.text;\n  }, t.templates.quick_info_date = function(a, r, s) {\n    return t.templates.task_time(a, r, s);\n  }, t.templates.quick_info_class = function(a, r, s) {\n    return \"\";\n  }, t.attachEvent(\"onTaskClick\", function(a, r) {\n    const s = t.utils.dom.closest(r.target, \".gantt_add\"), o = t.utils.dom.closest(r.target, \".gantt_close\"), l = t.utils.dom.closest(r.target, \".gantt_open\");\n    return !s && !o && !l && setTimeout(function() {\n      t.ext.quickInfo.show(a);\n    }, 0), !0;\n  });\n  const e = [\"onViewChange\", \"onLightbox\", \"onBeforeTaskDelete\", \"onBeforeDrag\"], n = function() {\n    return t.ext.quickInfo.hide(), !0;\n  };\n  for (let a = 0; a < e.length; a++) t.attachEvent(e[a], n);\n  function i() {\n    return t.ext.quickInfo.hide(), t.ext.quickInfo._quickInfoBox = null, !0;\n  }\n  t.attachEvent(\"onEmptyClick\", function(a) {\n    let r = !0;\n    const s = document.querySelector(\".gantt_cal_quick_info\");\n    s && t.utils.dom.isChildOf(a.target, s) && (r = !1), r && n();\n  }), t.attachEvent(\"onGanttReady\", i), t.attachEvent(\"onDestroy\", i), t.event(window, \"keydown\", function(a) {\n    a.keyCode === 27 && t.ext.quickInfo.hide();\n  }), t.showQuickInfo = function() {\n    t.ext.quickInfo.show.apply(t.ext.quickInfo, arguments);\n  }, t.hideQuickInfo = function() {\n    t.ext.quickInfo.hide.apply(t.ext.quickInfo, arguments);\n  };\n}, tooltip: function(t) {\n  t.config.tooltip_timeout = 30, t.config.tooltip_offset_y = 20, t.config.tooltip_offset_x = 10, t.config.tooltip_hide_timeout = 30;\n  const e = new Wn(t);\n  t.ext.tooltips = e, t.attachEvent(\"onGanttReady\", function() {\n    t.$root && e.tooltipFor({ selector: \"[\" + t.config.task_attribute + \"]:not(.gantt_task_row)\", html: (n) => {\n      if (t.config.touch && !t.config.touch_tooltip) return;\n      const i = t.locate(n);\n      if (t.isTaskExists(i)) {\n        const a = t.getTask(i);\n        return t.templates.tooltip_text(a.start_date, a.end_date, a);\n      }\n      return null;\n    }, global: !1 });\n  }), t.attachEvent(\"onDestroy\", function() {\n    e.destructor();\n  }), t.attachEvent(\"onLightbox\", function() {\n    e.hideTooltip();\n  }), t.attachEvent(\"onBeforeTooltip\", function() {\n    if (t.getState().link_source_id) return !1;\n  }), t.attachEvent(\"onGanttScroll\", function() {\n    e.hideTooltip();\n  });\n}, undo: function(t) {\n  const e = new Fn(t), n = new jn(e, t);\n  function i(c, u) {\n    return String(c) === String(u);\n  }\n  function a(c, u, h) {\n    c && (i(c.id, u) && (c.id = h), i(c.parent, u) && (c.parent = h));\n  }\n  function r(c, u, h) {\n    a(c.value, u, h), a(c.oldValue, u, h);\n  }\n  function s(c, u, h) {\n    c && (i(c.source, u) && (c.source = h), i(c.target, u) && (c.target = h));\n  }\n  function o(c, u, h) {\n    s(c.value, u, h), s(c.oldValue, u, h);\n  }\n  function l(c, u, h) {\n    const g = e;\n    for (let p = 0; p < c.length; p++) {\n      const y = c[p];\n      for (let v = 0; v < y.commands.length; v++) y.commands[v].entity === g.command.entity.task ? r(y.commands[v], u, h) : y.commands[v].entity === g.command.entity.link && o(y.commands[v], u, h);\n    }\n  }\n  function d(c, u, h) {\n    const g = e;\n    for (let p = 0; p < c.length; p++) {\n      const y = c[p];\n      for (let v = 0; v < y.commands.length; v++) {\n        const b = y.commands[v];\n        b.entity === g.command.entity.link && (b.value && b.value.id === u && (b.value.id = h), b.oldValue && b.oldValue.id === u && (b.oldValue.id = h));\n      }\n    }\n  }\n  t.config.undo = !0, t.config.redo = !0, t.config.undo_types = { link: \"link\", task: \"task\" }, t.config.undo_actions = { update: \"update\", remove: \"remove\", add: \"add\", move: \"move\" }, t.ext || (t.ext = {}), t.ext.undo = { undo: () => e.undo(), redo: () => e.redo(), getUndoStack: () => e.getUndoStack(), setUndoStack: (c) => e.setUndoStack(c), getRedoStack: () => e.getRedoStack(), setRedoStack: (c) => e.setRedoStack(c), clearUndoStack: () => e.clearUndoStack(), clearRedoStack: () => e.clearRedoStack(), saveState: (c, u) => n.store(c, u, !0), getInitialState: (c, u) => u === t.config.undo_types.link ? n.getInitialLink(c) : n.getInitialTask(c) }, t.undo = t.ext.undo.undo, t.redo = t.ext.undo.redo, t.getUndoStack = t.ext.undo.getUndoStack, t.getRedoStack = t.ext.undo.getRedoStack, t.clearUndoStack = t.ext.undo.clearUndoStack, t.clearRedoStack = t.ext.undo.clearRedoStack, t.attachEvent(\"onTaskIdChange\", (c, u) => {\n    const h = e;\n    l(h.getUndoStack(), c, u), l(h.getRedoStack(), c, u);\n  }), t.attachEvent(\"onLinkIdChange\", (c, u) => {\n    const h = e;\n    d(h.getUndoStack(), c, u), d(h.getRedoStack(), c, u);\n  }), t.attachEvent(\"onGanttReady\", () => {\n    e.updateConfigs();\n  });\n}, marker: function(t) {\n  function e(i) {\n    if (!t.config.show_markers || !i.start_date) return !1;\n    var a = t.getState();\n    if (+i.start_date > +a.max_date || (!i.end_date || +i.end_date < +a.min_date) && +i.start_date < +a.min_date) return;\n    var r = document.createElement(\"div\");\n    r.setAttribute(\"data-marker-id\", i.id);\n    var s = \"gantt_marker\";\n    t.templates.marker_class && (s += \" \" + t.templates.marker_class(i)), i.css && (s += \" \" + i.css), t.templates.marker_class && (s += \" \" + t.templates.marker_class(i)), i.title && (r.title = i.title), r.className = s;\n    var o = t.posFromDate(i.start_date);\n    r.style.left = o + \"px\";\n    let l = Math.max(t.getRowTop(t.getVisibleTaskCount()), 0) + \"px\";\n    if (t.config.timeline_placeholder && t.$task_data && (l = t.$task_data.scrollHeight + \"px\"), r.style.height = l, i.end_date) {\n      var d = t.posFromDate(i.end_date);\n      r.style.width = Math.max(d - o, 0) + \"px\";\n    }\n    if (i.text) {\n      let c = null;\n      c = typeof i.text == \"function\" ? i.text(i) : i.text, c && (t.config.external_render && t.config.external_render.isElement(c) ? (r.innerHTML = \"<div class='gantt_marker_content' ></div>\", t.config.external_render.renderElement(c, r.querySelector(\".gantt_marker_content\"))) : r.innerHTML = \"<div class='gantt_marker_content' >\" + i.text + \"</div>\");\n    }\n    return r;\n  }\n  function n() {\n    if (t.$task_data && t.$root.contains(t.$task_data)) {\n      if (!t.$marker_area || !t.$task_data.contains(t.$marker_area)) {\n        var i = document.createElement(\"div\");\n        i.className = \"gantt_marker_area\", t.$task_data.appendChild(i), t.$marker_area = i;\n      }\n    } else t.$marker_area = null;\n  }\n  t._markers || (t._markers = t.createDatastore({ name: \"marker\", initItem: function(i) {\n    return i.id = i.id || t.uid(), i;\n  } })), t.config.show_markers = !0, t.attachEvent(\"onBeforeGanttRender\", function() {\n    t.$marker_area || n();\n  }), t.attachEvent(\"onDataRender\", function() {\n    t.$marker_area || (n(), t.renderMarkers());\n  }), t.attachEvent(\"onGanttLayoutReady\", function() {\n    t.attachEvent(\"onBeforeGanttRender\", function() {\n      t.$marker_area && (t.$marker_area.innerHTML = \"\"), n(), t.$services.getService(\"layers\").createDataRender({ name: \"marker\", defaultContainer: function() {\n        return t.$marker_area;\n      } }).addLayer(e);\n    }, { once: !0 });\n  }), t.getMarker = function(i) {\n    return this._markers ? this._markers.getItem(i) : null;\n  }, t.addMarker = function(i) {\n    return this._markers.addItem(i);\n  }, t.deleteMarker = function(i) {\n    return !!this._markers.exists(i) && (this._markers.removeItem(i), !0);\n  }, t.updateMarker = function(i) {\n    this._markers.refresh(i);\n  }, t._getMarkers = function() {\n    return this._markers.getItems();\n  }, t.renderMarkers = function() {\n    this._markers.refresh();\n  };\n}, multiselect: function(t) {\n  t.config.multiselect = !0, t.config.multiselect_one_level = !1, t._multiselect = { _selected: {}, _one_level: !1, _active: !0, _first_selected_when_shift: null, getDefaultSelected: function() {\n    var e = this.getSelected();\n    return e.length ? e[e.length - 1] : null;\n  }, setFirstSelected: function(e) {\n    this._first_selected_when_shift = e;\n  }, getFirstSelected: function() {\n    return this._first_selected_when_shift;\n  }, isActive: function() {\n    return this.updateState(), this._active;\n  }, updateState: function() {\n    this._one_level = t.config.multiselect_one_level;\n    var e = this._active;\n    this._active = t.config.select_task, this._active != e && this.reset();\n  }, reset: function() {\n    this._selected = {};\n  }, setLastSelected: function(e) {\n    t.$data.tasksStore.silent(function() {\n      var n = t.$data.tasksStore;\n      e ? n.select(e + \"\") : n.unselect(null);\n    });\n  }, getLastSelected: function() {\n    var e = t.$data.tasksStore.getSelectedId();\n    return e && t.isTaskExists(e) ? e : null;\n  }, select: function(e, n) {\n    return !!(e && t.callEvent(\"onBeforeTaskMultiSelect\", [e, !0, n]) && t.callEvent(\"onBeforeTaskSelected\", [e])) && (this._selected[e] = !0, this.setLastSelected(e), this.afterSelect(e), t.callEvent(\"onTaskMultiSelect\", [e, !0, n]), t.callEvent(\"onTaskSelected\", [e]), !0);\n  }, toggle: function(e, n) {\n    this._selected[e] ? this.unselect(e, n) : this.select(e, n);\n  }, unselect: function(e, n) {\n    e && t.callEvent(\"onBeforeTaskMultiSelect\", [e, !1, n]) && (this._selected[e] = !1, this.getLastSelected() == e && this.setLastSelected(this.getDefaultSelected()), this.afterSelect(e), t.callEvent(\"onTaskMultiSelect\", [e, !1, n]), t.callEvent(\"onTaskUnselected\", [e]));\n  }, isSelected: function(e) {\n    return !(!t.isTaskExists(e) || !this._selected[e]);\n  }, getSelected: function() {\n    var e = [];\n    for (var n in this._selected) this._selected[n] && t.isTaskExists(n) ? e.push(n) : this._selected[n] = !1;\n    return e.sort(function(i, a) {\n      return t.getGlobalTaskIndex(i) > t.getGlobalTaskIndex(a) ? 1 : -1;\n    }), e;\n  }, forSelected: function(e) {\n    for (var n = this.getSelected(), i = 0; i < n.length; i++) e(n[i]);\n  }, isSameLevel: function(e) {\n    if (!this._one_level) return !0;\n    var n = this.getLastSelected();\n    return !n || !t.isTaskExists(n) || !t.isTaskExists(e) || t.calculateTaskLevel(t.getTask(n)) == t.calculateTaskLevel(t.getTask(e));\n  }, afterSelect: function(e) {\n    t.isTaskExists(e) && t._quickRefresh(function() {\n      t.refreshTask(e);\n    });\n  }, doSelection: function(e) {\n    if (!this.isActive() || t._is_icon_open_click(e)) return !1;\n    var n = t.locate(e);\n    if (!n || !t.callEvent(\"onBeforeMultiSelect\", [e])) return !1;\n    var i = this.getSelected(), a = this.getFirstSelected(), r = !1, s = this.getLastSelected(), o = t.config.multiselect, l = (function() {\n      const c = t.ext.inlineEditors;\n      if (c && c.getState) {\n        const h = c.getState(), g = c.locateCell(e.target);\n        t.config.inline_editors_multiselect_open && g && c.getEditorConfig(g.columnName) && (c.isVisible() && h.id == g.id && h.columnName == g.columnName || c.startEdit(g.id, g.columnName));\n      }\n      this.setFirstSelected(n), this.isSelected(n) || this.select(n, e), i = this.getSelected();\n      for (var u = 0; u < i.length; u++) i[u] !== n && this.unselect(i[u], e);\n    }).bind(this), d = (function() {\n      if (s) {\n        if (n) {\n          var c = t.getGlobalTaskIndex(this.getFirstSelected()), u = t.getGlobalTaskIndex(n), h = t.getGlobalTaskIndex(s);\n          c != -1 && h != -1 || (c = u, this.reset());\n          for (var g = s; t.getGlobalTaskIndex(g) !== c; ) this.unselect(g, e), g = c > h ? t.getNext(g) : t.getPrev(g);\n          for (g = n; t.getGlobalTaskIndex(g) !== c; ) this.select(g, e) && !r && (r = !0, a = g), g = c > u ? t.getNext(g) : t.getPrev(g);\n        }\n      } else s = n;\n    }).bind(this);\n    return o && (e.ctrlKey || e.metaKey) ? (this.isSelected(n) || this.setFirstSelected(n), n && this.toggle(n, e)) : o && e.shiftKey ? (t.isTaskExists(this.getFirstSelected()) && this.getFirstSelected() !== null || this.setFirstSelected(n), i.length ? d() : l()) : l(), this.isSelected(n) ? this.setLastSelected(n) : a ? n == s && this.setLastSelected(e.shiftKey ? a : this.getDefaultSelected()) : this.setLastSelected(null), this.getSelected().length || this.setLastSelected(null), this.getLastSelected() && this.isSelected(this.getFirstSelected()) || this.setFirstSelected(this.getLastSelected()), !0;\n  } }, function() {\n    var e = t.selectTask;\n    t.selectTask = function(i) {\n      if (!(i = at(i, this.config.root_id))) return !1;\n      var a = t._multiselect, r = i;\n      return a.isActive() ? (a.select(i, null) && a.setLastSelected(i), a.setFirstSelected(a.getLastSelected())) : r = e.call(this, i), r;\n    };\n    var n = t.unselectTask;\n    t.unselectTask = function(i) {\n      var a = t._multiselect, r = a.isActive();\n      (i = i || a.getLastSelected()) && r && (a.unselect(i, null), i == a.getLastSelected() && a.setLastSelected(null), t.refreshTask(i), a.setFirstSelected(a.getLastSelected()));\n      var s = i;\n      return r || (s = n.call(this, i)), s;\n    }, t.toggleTaskSelection = function(i) {\n      var a = t._multiselect;\n      i && a.isActive() && (a.toggle(i), a.setFirstSelected(a.getLastSelected()));\n    }, t.getSelectedTasks = function() {\n      var i = t._multiselect;\n      return i.isActive(), i.getSelected();\n    }, t.eachSelectedTask = function(i) {\n      return this._multiselect.forSelected(i);\n    }, t.isSelectedTask = function(i) {\n      return this._multiselect.isSelected(i);\n    }, t.getLastSelectedTask = function() {\n      return this._multiselect.getLastSelected();\n    }, t.attachEvent(\"onGanttReady\", function() {\n      var i = t.$data.tasksStore.isSelected;\n      t.$data.tasksStore.isSelected = function(a) {\n        return t._multiselect.isActive() ? t._multiselect.isSelected(a) : i.call(this, a);\n      };\n    });\n  }(), t.attachEvent(\"onTaskIdChange\", function(e, n) {\n    var i = t._multiselect;\n    if (!i.isActive()) return !0;\n    t.isSelectedTask(e) && (i.unselect(e, null), i.select(n, null));\n  }), t.attachEvent(\"onAfterTaskDelete\", function(e, n) {\n    var i = t._multiselect;\n    if (!i.isActive()) return !0;\n    i._selected[e] && (i._selected[e] = !1, i.setLastSelected(i.getDefaultSelected())), i.forSelected(function(a) {\n      t.isTaskExists(a) || i.unselect(a, null);\n    });\n  }), t.attachEvent(\"onBeforeTaskMultiSelect\", function(e, n, i) {\n    const a = t._multiselect;\n    if (n && a.isActive()) {\n      let r = t.getSelectedId(), s = null;\n      r && (s = t.getTask(r));\n      let o = t.getTask(e), l = !1;\n      if (s && s.$level != o.$level && (l = !0), t.config.multiselect_one_level && l && !i.ctrlKey && !i.shiftKey) return !0;\n      if (a._one_level) return a.isSameLevel(e);\n    }\n    return !0;\n  }), t.attachEvent(\"onTaskClick\", function(e, n) {\n    return t._multiselect.doSelection(n) && t.callEvent(\"onMultiSelect\", [n]), !0;\n  });\n}, export_api: function(t) {\n  return t.ext = t.ext || {}, t.ext.export_api = t.ext.export_api || { _apiUrl: \"https://export.dhtmlx.com/gantt\", _preparePDFConfigRaw(e, n) {\n    let i = null;\n    e.start && e.end && (i = { start_date: t.config.start_date, end_date: t.config.end_date }, t.config.start_date = t.date.str_to_date(t.config.date_format)(e.start), t.config.end_date = t.date.str_to_date(t.config.date_format)(e.end)), e = t.mixin(e, { name: \"gantt.\" + n, data: t.ext.export_api._serializeHtml() }), i && (t.config.start_date = i.start_date, t.config.end_date = i.end_date);\n  }, _prepareConfigPDF: (e, n) => (e = t.mixin(e || {}, { name: \"gantt.\" + n, data: t.ext.export_api._serializeAll(), config: t.config }), t.ext.export_api._fixColumns(e.config.columns), e), _pdfExportRouter(e, n) {\n    e && e.raw ? t.ext.export_api._preparePDFConfigRaw(e, n) : e = t.ext.export_api._prepareConfigPDF(e, n), e.version = t.version, t.ext.export_api._sendToExport(e, n);\n  }, exportToPDF(e) {\n    t.ext.export_api._pdfExportRouter(e, \"pdf\");\n  }, exportToPNG(e) {\n    t.ext.export_api._pdfExportRouter(e, \"png\");\n  }, exportToICal(e) {\n    e = t.mixin(e || {}, { name: \"gantt.ical\", data: t.ext.export_api._serializePlain().data, version: t.version }), t.ext.export_api._sendToExport(e, \"ical\");\n  }, exportToExcel(e) {\n    let n, i, a, r;\n    e = e || {};\n    const s = t.config.smart_rendering;\n    if (e.visual === \"base-colors\" && (t.config.smart_rendering = !1), e.start || e.end) {\n      a = t.getState(), i = [t.config.start_date, t.config.end_date], r = t.getScrollState();\n      const o = t.date.str_to_date(t.config.date_format);\n      n = t.eachTask, e.start && (t.config.start_date = o(e.start)), e.end && (t.config.end_date = o(e.end)), t.render(), t.config.smart_rendering = s, t.eachTask = t.ext.export_api._eachTaskTimed(t.config.start_date, t.config.end_date);\n    } else e.visual === \"base-colors\" && (t.render(), t.config.smart_rendering = s);\n    t._no_progress_colors = e.visual === \"base-colors\", (e = t.mixin(e, { name: \"gantt.xlsx\", title: \"Tasks\", data: t.ext.export_api._serializeTimeline(e).data, columns: t.ext.export_api._serializeGrid({ rawDates: !0 }), version: t.version })).visual && (e.scales = t.ext.export_api._serializeScales(e)), t.ext.export_api._sendToExport(e, \"excel\"), (e.start || e.end) && (t.config.start_date = a.min_date, t.config.end_date = a.max_date, t.eachTask = n, t.render(), t.scrollTo(r.x, r.y), t.config.start_date = i[0], t.config.end_date = i[1]);\n  }, exportToJSON(e) {\n    e = t.mixin(e || {}, { name: \"gantt.json\", data: t.ext.export_api._serializeAll(), config: t.config, columns: t.ext.export_api._serializeGrid(), worktime: t.ext.export_api._getWorktimeSettings(), version: t.version }), t.ext.export_api._sendToExport(e, \"json\");\n  }, importFromExcel(e) {\n    try {\n      const n = e.data;\n      if (n instanceof File) {\n        const i = new FormData();\n        i.append(\"file\", n), e.data = i;\n      }\n    } catch {\n    }\n    t.ext.export_api._sendImportAjaxExcel(e);\n  }, importFromMSProject(e) {\n    const n = e.data;\n    try {\n      if (n instanceof File) {\n        const i = new FormData();\n        i.append(\"file\", n), e.data = i;\n      }\n    } catch {\n    }\n    t.ext.export_api._sendImportAjaxMSP(e);\n  }, importFromPrimaveraP6: (e) => (e.type = \"primaveraP6-parse\", t.importFromMSProject(e)), exportToMSProject(e) {\n    (e = e || {}).skip_circular_links = e.skip_circular_links === void 0 || !!e.skip_circular_links;\n    const n = t.templates.xml_format, i = t.templates.format_date, a = t.config.xml_date, r = t.config.date_format, s = \"%d-%m-%Y %H:%i:%s\";\n    t.config.xml_date = s, t.config.date_format = s, t.templates.xml_format = t.date.date_to_str(s), t.templates.format_date = t.date.date_to_str(s);\n    const o = t.ext.export_api._serializeAll();\n    t.ext.export_api._customProjectProperties(o, e), t.ext.export_api._customTaskProperties(o, e), e.skip_circular_links && t.ext.export_api._clearRecLinks(o), e = t.ext.export_api._exportConfig(o, e), t.ext.export_api._sendToExport(e, e.type || \"msproject\"), t.config.xml_date = a, t.config.date_format = r, t.templates.xml_format = n, t.templates.format_date = i, t.config.$custom_data = null, t.config.custom = null;\n  }, exportToPrimaveraP6: (e) => ((e = e || {}).type = \"primaveraP6\", t.exportToMSProject(e)), _fixColumns(e) {\n    for (let n = 0; n < e.length; n++) e[n].label = e[n].label || t.locale.labels[\"column_\" + e[n].name], typeof e[n].width == \"string\" && (e[n].width = 1 * e[n].width);\n  }, _xdr(e, n, i) {\n    t.ajax.post(e, n, i);\n  }, _markColumns(e) {\n    const n = e.config.columns;\n    if (n) for (let i = 0; i < n.length; i++) n[i].template && (n[i].$template = !0);\n  }, _sendImportAjaxExcel(e) {\n    const n = e.server || t.ext.export_api._apiUrl, i = e.store || 0, a = e.data, r = e.callback;\n    a.append(\"type\", \"excel-parse\"), a.append(\"data\", JSON.stringify({ sheet: e.sheet || 0 })), i && a.append(\"store\", i);\n    const s = new XMLHttpRequest();\n    s.onreadystatechange = function(o) {\n      s.readyState === 4 && s.status === 0 && r && r(null);\n    }, s.onload = function() {\n      let o = null;\n      if (!(s.status > 400)) try {\n        o = JSON.parse(s.responseText);\n      } catch {\n      }\n      r && r(o);\n    }, s.open(\"POST\", n, !0), s.setRequestHeader(\"X-Requested-With\", \"XMLHttpRequest\"), s.send(a);\n  }, _ajaxToExport(e, n, i) {\n    delete e.callback;\n    const a = e.server || t.ext.export_api._apiUrl, r = \"type=\" + n + \"&store=1&data=\" + encodeURIComponent(JSON.stringify(e));\n    t.ext.export_api._xdr(a, r, function(s) {\n      const o = s.xmlDoc || s;\n      let l = null;\n      if (!(o.status > 400)) try {\n        l = JSON.parse(o.responseText);\n      } catch {\n      }\n      i(l);\n    });\n  }, _serializableGanttConfig(e) {\n    const n = t.mixin({}, e);\n    return n.columns && (n.columns = n.columns.map(function(i) {\n      const a = t.mixin({}, i);\n      return delete a.editor, a;\n    })), delete n.editor_types, n;\n  }, _sendToExport(e, n) {\n    const i = t.date.date_to_str(t.config.date_format || t.config.xml_date);\n    if (e.skin || (e.skin = t.skin), e.config && (e.config = t.copy(t.ext.export_api._serializableGanttConfig(e.config)), t.ext.export_api._markColumns(e, n), e.config.start_date && e.config.end_date && (e.config.start_date instanceof Date && (e.config.start_date = i(e.config.start_date)), e.config.end_date instanceof Date && (e.config.end_date = i(e.config.end_date)))), e.callback) return t.ext.export_api._ajaxToExport(e, n, e.callback);\n    const a = t.ext.export_api._createHiddenForm();\n    a.firstChild.action = e.server || t.ext.export_api._apiUrl, a.firstChild.childNodes[0].value = JSON.stringify(e), a.firstChild.childNodes[1].value = n, a.firstChild.submit();\n  }, _createHiddenForm() {\n    if (!t.ext.export_api._hidden_export_form) {\n      const e = t.ext.export_api._hidden_export_form = document.createElement(\"div\");\n      e.style.display = \"none\", e.innerHTML = \"<form method='POST' target='_blank'><textarea name='data' style='width:0px; height:0px;' readonly='true'></textarea><input type='hidden' name='type' value=''></form>\", document.body.appendChild(e);\n    }\n    return t.ext.export_api._hidden_export_form;\n  }, _copyObjectBase(e) {\n    const n = { start_date: void 0, end_date: void 0, constraint_date: void 0, deadline: void 0 };\n    for (const a in e) a.charAt(0) !== \"$\" && a !== \"baselines\" && (n[a] = e[a]);\n    const i = t.templates.xml_format || t.templates.format_date;\n    return n.start_date = i(n.start_date), n.end_date && (n.end_date = i(n.end_date)), n.constraint_date && (n.constraint_date = i(n.constraint_date)), n.deadline && (n.deadline = i(n.deadline)), n;\n  }, _color_box: null, _color_hash: {}, _getStyles(e) {\n    if (t.ext.export_api._color_box || (t.ext.export_api._color_box = document.createElement(\"DIV\"), t.ext.export_api._color_box.style.cssText = \"position:absolute; display:none;\", document.body.appendChild(t.ext.export_api._color_box)), t.ext.export_api._color_hash[e]) return t.ext.export_api._color_hash[e];\n    t.ext.export_api._color_box.className = e;\n    const n = t.ext.export_api._getColor(t.ext.export_api._color_box, \"color\"), i = t.ext.export_api._getColor(t.ext.export_api._color_box, \"backgroundColor\");\n    return t.ext.export_api._color_hash[e] = n + \";\" + i;\n  }, _getMinutesWorktimeSettings(e) {\n    const n = [];\n    return e.forEach(function(i) {\n      n.push(i.startMinute), n.push(i.endMinute);\n    }), n;\n  }, _getWorktimeSettings() {\n    const e = { hours: [0, 24], minutes: null, dates: { 0: !0, 1: !0, 2: !0, 3: !0, 4: !0, 5: !0, 6: !0 } };\n    let n;\n    if (t.config.work_time) {\n      const i = t._working_time_helper;\n      if (i && i.get_calendar) n = i.get_calendar();\n      else if (i) n = { hours: i.hours, minutes: null, dates: i.dates };\n      else if (t.config.worktimes && t.config.worktimes.global) {\n        const a = t.config.worktimes.global;\n        if (a.parsed) {\n          n = { hours: null, minutes: t.ext.export_api._getMinutesWorktimeSettings(a.parsed.hours), dates: {} };\n          for (const r in a.parsed.dates) Array.isArray(a.parsed.dates[r]) ? n.dates[r] = t.ext.export_api._getMinutesWorktimeSettings(a.parsed.dates[r]) : n.dates[r] = a.parsed.dates[r];\n        } else n = { hours: a.hours, minutes: null, dates: a.dates };\n      } else n = e;\n    } else n = e;\n    return n;\n  }, _eachTaskTimed: (e, n) => function(i, a, r) {\n    a = a || t.config.root_id, r = r || t;\n    const s = t.getChildren(a);\n    if (s) for (let o = 0; o < s.length; o++) {\n      const l = t._pull[s[o]];\n      (!e || l.end_date > e) && (!n || l.start_date < n) && i.call(r, l), t.hasChild(l.id) && t.eachTask(i, l.id, r);\n    }\n  }, _originalCopyObject: t.json._copyObject, _copyObjectPlain(e) {\n    const n = t.templates.task_text(e.start_date, e.end_date, e), i = t.ext.export_api._copyObjectBase(e);\n    return i.text = n || i.text, i;\n  }, _getColor(e, n) {\n    const i = e.currentStyle ? e.currentStyle[n] : getComputedStyle(e, null)[n], a = i.replace(/\\s/g, \"\").match(/^rgba?\\((\\d+),(\\d+),(\\d+)/i);\n    return (a && a.length === 4 ? (\"0\" + parseInt(a[1], 10).toString(16)).slice(-2) + (\"0\" + parseInt(a[2], 10).toString(16)).slice(-2) + (\"0\" + parseInt(a[3], 10).toString(16)).slice(-2) : i).replace(\"#\", \"\");\n  }, _copyObjectTable(e) {\n    const n = t.date.date_to_str(\"%Y-%m-%dT%H:%i:%s.000Z\"), i = t.ext.export_api._copyObjectColumns(e, t.ext.export_api._copyObjectPlain(e));\n    i.start_date && (i.start_date = n(e.start_date)), i.end_date && (i.end_date = n(e.end_date));\n    const a = t._day_index_by_date ? t._day_index_by_date : t.columnIndexByDate;\n    i.$start = a.call(t, e.start_date), i.$end = a.call(t, e.end_date);\n    let r = 0;\n    const s = t.getScale().width;\n    if (s.indexOf(0) > -1) {\n      let l = 0;\n      for (; l < i.$start; l++) s[l] || r++;\n      for (i.$start -= r; l < i.$end; l++) s[l] || r++;\n      i.$end -= r;\n    }\n    i.$level = e.$level, i.$type = e.$rendered_type;\n    const o = t.templates;\n    return i.$text = o.task_text(e.start, e.end_date, e), i.$left = o.leftside_text ? o.leftside_text(e.start, e.end_date, e) : \"\", i.$right = o.rightside_text ? o.rightside_text(e.start, e.end_date, e) : \"\", i;\n  }, _copyObjectColors(e) {\n    const n = t.ext.export_api._copyObjectTable(e), i = t.getTaskNode(e.id);\n    if (i && i.firstChild) {\n      let a = t.ext.export_api._getColor(t._no_progress_colors ? i : i.firstChild, \"backgroundColor\");\n      a === \"363636\" && (a = t.ext.export_api._getColor(i, \"backgroundColor\")), n.$color = a;\n    } else e.color && (n.$color = e.color);\n    return n;\n  }, _copyObjectColumns(e, n) {\n    for (let i = 0; i < t.config.columns.length; i++) {\n      const a = t.config.columns[i].template;\n      if (a) {\n        let r = a(e);\n        r instanceof Date && (r = t.templates.date_grid(r, e)), n[\"_\" + i] = r;\n      }\n    }\n    return n;\n  }, _copyObjectAll(e) {\n    const n = t.ext.export_api._copyObjectBase(e), i = [\"leftside_text\", \"rightside_text\", \"task_text\", \"progress_text\", \"task_class\"];\n    for (let a = 0; a < i.length; a++) {\n      const r = t.templates[i[a]];\n      r && (n[\"$\" + a] = r(e.start_date, e.end_date, e));\n    }\n    return t.ext.export_api._copyObjectColumns(e, n), n.open = e.$open, n;\n  }, _serializeHtml() {\n    const e = t.config.smart_scales, n = t.config.smart_rendering;\n    (e || n) && (t.config.smart_rendering = !1, t.config.smart_scales = !1, t.render());\n    const i = t.$container.parentNode.innerHTML;\n    return (e || n) && (t.config.smart_scales = e, t.config.smart_rendering = n, t.render()), i;\n  }, _serializeAll() {\n    t.json._copyObject = t.ext.export_api._copyObjectAll;\n    const e = t.ext.export_api._exportSerialize();\n    return t.json._copyObject = t.ext.export_api._originalCopyObject, e;\n  }, _serializePlain() {\n    const e = t.templates.xml_format, n = t.templates.format_date;\n    t.templates.xml_format = t.date.date_to_str(\"%Y%m%dT%H%i%s\", !0), t.templates.format_date = t.date.date_to_str(\"%Y%m%dT%H%i%s\", !0), t.json._copyObject = t.ext.export_api._copyObjectPlain;\n    const i = t.ext.export_api._exportSerialize();\n    return t.templates.xml_format = e, t.templates.format_date = n, t.json._copyObject = t.ext.export_api._originalCopyObject, delete i.links, i;\n  }, _getRaw() {\n    if (t._scale_helpers) {\n      const e = t._get_scales(), n = t.config.min_column_width, i = t._get_resize_options().x ? Math.max(t.config.autosize_min_width, 0) : t.config.$task.offsetWidth, a = t.config.config.scale_height - 1;\n      return t._scale_helpers.prepareConfigs(e, n, i, a);\n    }\n    {\n      const e = t.$ui.getView(\"timeline\");\n      if (e) {\n        let n = e.$config.width;\n        t.config.autosize !== \"x\" && t.config.autosize !== \"xy\" || (n = Math.max(t.config.autosize_min_width, 0));\n        const i = t.getState(), a = e._getScales(), r = t.config.min_column_width, s = t.config.scale_height - 1, o = t.config.rtl;\n        return e.$scaleHelper.prepareConfigs(a, r, n, s, i.min_date, i.max_date, o);\n      }\n    }\n  }, _serializeTimeline(e) {\n    t.json._copyObject = e.visual ? t.ext.export_api._copyObjectColors : t.ext.export_api._copyObjectTable;\n    const n = t.ext.export_api._exportSerialize();\n    if (t.json._copyObject = t.ext.export_api._originalCopyObject, delete n.links, e.cellColors) {\n      const i = t.templates.timeline_cell_class || t.templates.task_cell_class;\n      if (i) {\n        const a = t.ext.export_api._getRaw();\n        let r = a[0].trace_x;\n        for (let s = 1; s < a.length; s++) a[s].trace_x.length > r.length && (r = a[s].trace_x);\n        for (let s = 0; s < n.data.length; s++) {\n          n.data[s].styles = [];\n          const o = t.getTask(n.data[s].id);\n          for (let l = 0; l < r.length; l++) {\n            const d = i(o, r[l]);\n            d && n.data[s].styles.push({ index: l, styles: t.ext.export_api._getStyles(d) });\n          }\n        }\n      }\n    }\n    return n;\n  }, _serializeScales(e) {\n    const n = [], i = t.ext.export_api._getRaw();\n    let a = 1 / 0, r = 0;\n    for (let s = 0; s < i.length; s++) a = Math.min(a, i[s].col_width);\n    for (let s = 0; s < i.length; s++) {\n      let o = 0, l = 0;\n      const d = [];\n      n.push(d);\n      const c = i[s];\n      r = Math.max(r, c.trace_x.length);\n      const u = c.format || c.template || (c.date ? t.date.date_to_str(c.date) : t.config.date_scale);\n      for (let h = 0; h < c.trace_x.length; h++) {\n        const g = c.trace_x[h];\n        l = o + Math.round(c.width[h] / a);\n        const p = { text: u(g), start: o, end: l, styles: \"\" };\n        if (e.cellColors) {\n          const y = c.css || t.templates.scaleCell_class;\n          if (y) {\n            const v = y(g);\n            v && (p.styles = t.ext.export_api._getStyles(v));\n          }\n        }\n        d.push(p), o = l;\n      }\n    }\n    return { width: r, height: n.length, data: n };\n  }, _serializeGrid(e) {\n    t.exportMode = !0;\n    const n = [], i = t.config.columns;\n    let a = 0;\n    for (let r = 0; r < i.length; r++) i[r].name !== \"add\" && i[r].name !== \"buttons\" && (n[a] = { id: i[r].template ? \"_\" + r : i[r].name, header: i[r].label || t.locale.labels[\"column_\" + i[r].name], width: i[r].width ? Math.floor(i[r].width / 4) : \"\", tree: i[r].tree || !1 }, i[r].name === \"duration\" && (n[a].type = \"number\"), i[r].name !== \"start_date\" && i[r].name !== \"end_date\" || (n[a].type = \"date\", e && e.rawDates && (n[a].id = i[r].name)), a++);\n    return t.exportMode = !1, n;\n  }, _exportSerialize() {\n    t.exportMode = !0;\n    const e = t.templates.xml_format, n = t.templates.format_date;\n    t.templates.xml_format = t.templates.format_date = t.date.date_to_str(t.config.date_format || t.config.xml_date);\n    const i = t.serialize();\n    return t.templates.xml_format = e, t.templates.format_date = n, t.exportMode = !1, i;\n  }, _setLevel(e) {\n    for (let n = 0; n < e.length; n++) {\n      e[n].parent == 0 && (e[n]._lvl = 1);\n      for (let i = n + 1; i < e.length; i++) e[n].id == e[i].parent && (e[i]._lvl = e[n]._lvl + 1);\n    }\n  }, _clearLevel(e) {\n    for (let n = 0; n < e.length; n++) delete e[n]._lvl;\n  }, _clearRecLinks(e) {\n    t.ext.export_api._setLevel(e.data);\n    const n = {};\n    for (let r = 0; r < e.data.length; r++) n[e.data[r].id] = e.data[r];\n    const i = {};\n    for (let r = 0; r < e.links.length; r++) {\n      const s = e.links[r];\n      t.isTaskExists(s.source) && t.isTaskExists(s.target) && n[s.source] && n[s.target] && (i[s.id] = s);\n    }\n    for (const r in i) t.ext.export_api._makeLinksSameLevel(i[r], n);\n    const a = {};\n    for (const r in n) t.ext.export_api._clearCircDependencies(n[r], i, n, {}, a, null);\n    Object.keys(i) && t.ext.export_api._clearLinksSameLevel(i, n);\n    for (let r = 0; r < e.links.length; r++) i[e.links[r].id] || (e.links.splice(r, 1), r--);\n    t.ext.export_api._clearLevel(e.data);\n  }, _clearCircDependencies(e, n, i, a, r, s) {\n    const o = e.$_source;\n    if (!o) return;\n    a[e.id] && t.ext.export_api._onCircDependencyFind(s, n, a, r), a[e.id] = !0;\n    const l = {};\n    for (let d = 0; d < o.length; d++) {\n      if (r[o[d]]) continue;\n      const c = n[o[d]], u = i[c._target];\n      l[u.id] && t.ext.export_api._onCircDependencyFind(c, n, a, r), l[u.id] = !0, t.ext.export_api._clearCircDependencies(u, n, i, a, r, c);\n    }\n    a[e.id] = !1;\n  }, _onCircDependencyFind(e, n, i, a) {\n    e && (t.callEvent(\"onExportCircularDependency\", [e.id, e]) && delete n[e.id], delete i[e._source], delete i[e._target], a[e.id] = !0);\n  }, _makeLinksSameLevel(e, n) {\n    let i, a;\n    const r = { target: n[e.target], source: n[e.source] };\n    if (r.target._lvl != r.source._lvl) {\n      r.target._lvl < r.source._lvl ? (i = \"source\", a = r.target._lvl) : (i = \"target\", a = r.source._lvl);\n      do {\n        const l = n[r[i].parent];\n        if (!l) break;\n        r[i] = l;\n      } while (r[i]._lvl < a);\n      let s = n[r.source.parent], o = n[r.target.parent];\n      for (; s && o && s.id != o.id; ) r.source = s, r.target = o, s = n[r.source.parent], o = n[r.target.parent];\n    }\n    e._target = r.target.id, e._source = r.source.id, r.target.$_target || (r.target.$_target = []), r.target.$_target.push(e.id), r.source.$_source || (r.source.$_source = []), r.source.$_source.push(e.id);\n  }, _clearLinksSameLevel(e, n) {\n    for (const i in e) delete e[i]._target, delete e[i]._source;\n    for (const i in n) delete n[i].$_source, delete n[i].$_target;\n  }, _customProjectProperties(e, n) {\n    if (n && n.project) {\n      for (const i in n.project) t.config.$custom_data || (t.config.$custom_data = {}), t.config.$custom_data[i] = typeof n.project[i] == \"function\" ? n.project[i](t.config) : n.project[i];\n      delete n.project;\n    }\n  }, _customTaskProperties(e, n) {\n    n && n.tasks && (e.data.forEach(function(i) {\n      for (const a in n.tasks) i.$custom_data || (i.$custom_data = {}), i.$custom_data[a] = typeof n.tasks[a] == \"function\" ? n.tasks[a](i, t.config) : n.tasks[a];\n    }), delete n.tasks);\n  }, _exportConfig(e, n) {\n    const i = n.name || \"gantt.xml\";\n    delete n.name, t.config.custom = n;\n    const a = t.ext.export_api._getWorktimeSettings(), r = t.getSubtaskDates();\n    if (r.start_date && r.end_date) {\n      const l = t.templates.format_date || t.templates.xml_format;\n      t.config.start_end = { start_date: l(r.start_date), end_date: l(r.end_date) };\n    }\n    const s = n.auto_scheduling !== void 0 && !!n.auto_scheduling, o = { callback: n.callback || null, config: t.config, data: e, manual: s, name: i, worktime: a };\n    for (const l in n) o[l] = n[l];\n    return o;\n  }, _sendImportAjaxMSP(e) {\n    const n = e.server || t.ext.export_api._apiUrl, i = e.store || 0, a = e.data, r = e.callback, s = { durationUnit: e.durationUnit || void 0, projectProperties: e.projectProperties || void 0, taskProperties: e.taskProperties || void 0 };\n    a.append(\"type\", e.type || \"msproject-parse\"), a.append(\"data\", JSON.stringify(s)), i && a.append(\"store\", i);\n    const o = new XMLHttpRequest();\n    o.onreadystatechange = function(l) {\n      o.readyState === 4 && o.status === 0 && r && r(null);\n    }, o.onload = function() {\n      let l = null;\n      if (!(o.status > 400)) try {\n        l = JSON.parse(o.responseText);\n      } catch {\n      }\n      r && r(l);\n    }, o.open(\"POST\", n, !0), o.setRequestHeader(\"X-Requested-With\", \"XMLHttpRequest\"), o.send(a);\n  } }, t.exportToPDF = t.ext.export_api.exportToPDF, t.exportToPNG = t.ext.export_api.exportToPNG, t.exportToICal = t.ext.export_api.exportToICal, t.exportToExcel = t.ext.export_api.exportToExcel, t.exportToJSON = t.ext.export_api.exportToJSON, t.importFromExcel = t.ext.export_api.importFromExcel, t.importFromMSProject = t.ext.export_api.importFromMSProject, t.exportToMSProject = t.ext.export_api.exportToMSProject, t.importFromPrimaveraP6 = t.ext.export_api.importFromPrimaveraP6, t.exportToPrimaveraP6 = t.ext.export_api.exportToPrimaveraP6, t.ext.export_api;\n} }, Un = { KEY_CODES: { UP: 38, DOWN: 40, LEFT: 37, RIGHT: 39, SPACE: 32, ENTER: 13, DELETE: 46, ESC: 27, TAB: 9 } };\nclass qn {\n  constructor(e) {\n    this.addExtension = (n, i) => {\n      this._extensions[n] = i;\n    }, this.getExtension = (n) => this._extensions[n], this._extensions = {};\n    for (const n in e) this._extensions[n] = e[n];\n  }\n}\nvar nt = typeof window < \"u\";\nconst mt = { isIE: nt && (navigator.userAgent.indexOf(\"MSIE\") >= 0 || navigator.userAgent.indexOf(\"Trident\") >= 0), isIE6: nt && !XMLHttpRequest && navigator.userAgent.indexOf(\"MSIE\") >= 0, isIE7: nt && navigator.userAgent.indexOf(\"MSIE 7.0\") >= 0 && navigator.userAgent.indexOf(\"Trident\") < 0, isIE8: nt && navigator.userAgent.indexOf(\"MSIE 8.0\") >= 0 && navigator.userAgent.indexOf(\"Trident\") >= 0, isOpera: nt && navigator.userAgent.indexOf(\"Opera\") >= 0, isChrome: nt && navigator.userAgent.indexOf(\"Chrome\") >= 0, isKHTML: nt && (navigator.userAgent.indexOf(\"Safari\") >= 0 || navigator.userAgent.indexOf(\"Konqueror\") >= 0), isFF: nt && navigator.userAgent.indexOf(\"Firefox\") >= 0, isIPad: nt && navigator.userAgent.search(/iPad/gi) >= 0, isEdge: nt && navigator.userAgent.indexOf(\"Edge\") != -1, isNode: !nt || typeof navigator > \"u\" || !1 };\nfunction Ne(t) {\n  if (typeof t == \"string\" || typeof t == \"number\") return t;\n  let e = \"\";\n  for (const n in t) {\n    let i = \"\";\n    t.hasOwnProperty(n) && (i = typeof t[n] == \"string\" ? encodeURIComponent(t[n]) : typeof t[n] == \"number\" ? String(t[n]) : encodeURIComponent(JSON.stringify(t[n])), i = n + \"=\" + i, e.length && (i = \"&\" + i), e += i);\n  }\n  return e;\n}\nfunction xt(t, e) {\n  var n = { method: t };\n  if (e.length === 0) throw new Error(\"Arguments list of query is wrong.\");\n  if (e.length === 1) return typeof e[0] == \"string\" ? (n.url = e[0], n.async = !0) : (n.url = e[0].url, n.async = e[0].async || !0, n.callback = e[0].callback, n.headers = e[0].headers), e[0].data ? typeof e[0].data != \"string\" ? n.data = Ne(e[0].data) : n.data = e[0].data : n.data = \"\", n;\n  switch (n.url = e[0], t) {\n    case \"GET\":\n    case \"DELETE\":\n      n.callback = e[1], n.headers = e[2];\n      break;\n    case \"POST\":\n    case \"PUT\":\n      e[1] ? typeof e[1] != \"string\" ? n.data = Ne(e[1]) : n.data = e[1] : n.data = \"\", n.callback = e[2], n.headers = e[3];\n  }\n  return n;\n}\nconst Le = { date_to_str: (t, e, n) => {\n  t = t.replace(/%[a-zA-Z]/g, (a) => {\n    switch (a) {\n      case \"%d\":\n        return `\"+to_fixed(date.get${e ? \"UTC\" : \"\"}Date())+\"`;\n      case \"%m\":\n        return `\"+to_fixed((date.get${e ? \"UTC\" : \"\"}Month()+1))+\"`;\n      case \"%j\":\n        return `\"+date.get${e ? \"UTC\" : \"\"}Date()+\"`;\n      case \"%n\":\n        return `\"+(date.get${e ? \"UTC\" : \"\"}Month()+1)+\"`;\n      case \"%y\":\n        return `\"+to_fixed(date.get${e ? \"UTC\" : \"\"}FullYear()%100)+\"`;\n      case \"%Y\":\n        return `\"+date.get${e ? \"UTC\" : \"\"}FullYear()+\"`;\n      case \"%D\":\n        return `\"+locale.date.day_short[date.get${e ? \"UTC\" : \"\"}Day()]+\"`;\n      case \"%l\":\n        return `\"+locale.date.day_full[date.get${e ? \"UTC\" : \"\"}Day()]+\"`;\n      case \"%M\":\n        return `\"+locale.date.month_short[date.get${e ? \"UTC\" : \"\"}Month()]+\"`;\n      case \"%F\":\n        return `\"+locale.date.month_full[date.get${e ? \"UTC\" : \"\"}Month()]+\"`;\n      case \"%h\":\n        return `\"+to_fixed((date.get${e ? \"UTC\" : \"\"}Hours()+11)%12+1)+\"`;\n      case \"%g\":\n        return `\"+((date.get${e ? \"UTC\" : \"\"}Hours()+11)%12+1)+\"`;\n      case \"%G\":\n        return `\"+date.get${e ? \"UTC\" : \"\"}Hours()+\"`;\n      case \"%H\":\n        return `\"+to_fixed(date.get${e ? \"UTC\" : \"\"}Hours())+\"`;\n      case \"%i\":\n        return `\"+to_fixed(date.get${e ? \"UTC\" : \"\"}Minutes())+\"`;\n      case \"%a\":\n        return `\"+(date.get${e ? \"UTC\" : \"\"}Hours()>11?\"pm\":\"am\")+\"`;\n      case \"%A\":\n        return `\"+(date.get${e ? \"UTC\" : \"\"}Hours()>11?\"PM\":\"AM\")+\"`;\n      case \"%s\":\n        return `\"+to_fixed(date.get${e ? \"UTC\" : \"\"}Seconds())+\"`;\n      case \"%W\":\n        return '\"+to_fixed(getISOWeek(date))+\"';\n      case \"%w\":\n        return '\"+to_fixed(getWeek(date))+\"';\n      default:\n        return a;\n    }\n  });\n  const i = new Function(\"date\", \"to_fixed\", \"locale\", \"getISOWeek\", \"getWeek\", `return \"${t}\";`);\n  return (a) => i(a, n.date.to_fixed, n.locale, n.date.getISOWeek, n.date.getWeek);\n}, str_to_date: (t, e, n) => {\n  let i = \"var temp=date.match(/[a-zA-Z]+|[0-9]+/g);\";\n  const a = t.match(/%[a-zA-Z]/g);\n  for (let o = 0; o < a.length; o++) switch (a[o]) {\n    case \"%j\":\n    case \"%d\":\n      i += `set[2]=temp[${o}]||1;`;\n      break;\n    case \"%n\":\n    case \"%m\":\n      i += `set[1]=(temp[${o}]||1)-1;`;\n      break;\n    case \"%y\":\n      i += `set[0]=temp[${o}]*1+(temp[${o}]>50?1900:2000);`;\n      break;\n    case \"%g\":\n    case \"%G\":\n    case \"%h\":\n    case \"%H\":\n      i += `set[3]=temp[${o}]||0;`;\n      break;\n    case \"%i\":\n      i += `set[4]=temp[${o}]||0;`;\n      break;\n    case \"%Y\":\n      i += `set[0]=temp[${o}]||0;`;\n      break;\n    case \"%a\":\n    case \"%A\":\n      i += `set[3]=set[3]%12+((temp[${o}]||'').toLowerCase()=='am'?0:12);`;\n      break;\n    case \"%s\":\n      i += `set[5]=temp[${o}]||0;`;\n      break;\n    case \"%M\":\n      i += `set[1]=locale.date.month_short_hash[temp[${o}]]||0;`;\n      break;\n    case \"%F\":\n      i += `set[1]=locale.date.month_full_hash[temp[${o}]]||0;`;\n  }\n  let r = \"set[0],set[1],set[2],set[3],set[4],set[5]\";\n  e && (r = ` Date.UTC(${r})`);\n  const s = new Function(\"date\", \"locale\", `var set=[0,0,1,0,0,0]; ${i} return new Date(${r});`);\n  return (o) => s(o, n.locale);\n} }, Pe = { date_to_str: (t, e, n) => (i) => t.replace(/%[a-zA-Z]/g, (a) => {\n  switch (a) {\n    case \"%d\":\n      return e ? n.date.to_fixed(i.getUTCDate()) : n.date.to_fixed(i.getDate());\n    case \"%m\":\n      return e ? n.date.to_fixed(i.getUTCMonth() + 1) : n.date.to_fixed(i.getMonth() + 1);\n    case \"%j\":\n      return e ? i.getUTCDate() : i.getDate();\n    case \"%n\":\n      return e ? i.getUTCMonth() + 1 : i.getMonth() + 1;\n    case \"%y\":\n      return e ? n.date.to_fixed(i.getUTCFullYear() % 100) : n.date.to_fixed(i.getFullYear() % 100);\n    case \"%Y\":\n      return e ? i.getUTCFullYear() : i.getFullYear();\n    case \"%D\":\n      return e ? n.locale.date.day_short[i.getUTCDay()] : n.locale.date.day_short[i.getDay()];\n    case \"%l\":\n      return e ? n.locale.date.day_full[i.getUTCDay()] : n.locale.date.day_full[i.getDay()];\n    case \"%M\":\n      return e ? n.locale.date.month_short[i.getUTCMonth()] : n.locale.date.month_short[i.getMonth()];\n    case \"%F\":\n      return e ? n.locale.date.month_full[i.getUTCMonth()] : n.locale.date.month_full[i.getMonth()];\n    case \"%h\":\n      return e ? n.date.to_fixed((i.getUTCHours() + 11) % 12 + 1) : n.date.to_fixed((i.getHours() + 11) % 12 + 1);\n    case \"%g\":\n      return e ? (i.getUTCHours() + 11) % 12 + 1 : (i.getHours() + 11) % 12 + 1;\n    case \"%G\":\n      return e ? i.getUTCHours() : i.getHours();\n    case \"%H\":\n      return e ? n.date.to_fixed(i.getUTCHours()) : n.date.to_fixed(i.getHours());\n    case \"%i\":\n      return e ? n.date.to_fixed(i.getUTCMinutes()) : n.date.to_fixed(i.getMinutes());\n    case \"%a\":\n      return e ? i.getUTCHours() > 11 ? \"pm\" : \"am\" : i.getHours() > 11 ? \"pm\" : \"am\";\n    case \"%A\":\n      return e ? i.getUTCHours() > 11 ? \"PM\" : \"AM\" : i.getHours() > 11 ? \"PM\" : \"AM\";\n    case \"%s\":\n      return e ? n.date.to_fixed(i.getUTCSeconds()) : n.date.to_fixed(i.getSeconds());\n    case \"%W\":\n      return e ? n.date.to_fixed(n.date.getUTCISOWeek(i)) : n.date.to_fixed(n.date.getISOWeek(i));\n    default:\n      return a;\n  }\n}), str_to_date: (t, e, n) => (i) => {\n  const a = [0, 0, 1, 0, 0, 0], r = i.match(/[a-zA-Z]+|[0-9]+/g), s = t.match(/%[a-zA-Z]/g);\n  for (let o = 0; o < s.length; o++) switch (s[o]) {\n    case \"%j\":\n    case \"%d\":\n      a[2] = r[o] || 1;\n      break;\n    case \"%n\":\n    case \"%m\":\n      a[1] = (r[o] || 1) - 1;\n      break;\n    case \"%y\":\n      a[0] = 1 * r[o] + (r[o] > 50 ? 1900 : 2e3);\n      break;\n    case \"%g\":\n    case \"%G\":\n    case \"%h\":\n    case \"%H\":\n      a[3] = r[o] || 0;\n      break;\n    case \"%i\":\n      a[4] = r[o] || 0;\n      break;\n    case \"%Y\":\n      a[0] = r[o] || 0;\n      break;\n    case \"%a\":\n    case \"%A\":\n      a[3] = a[3] % 12 + ((r[o] || \"\").toLowerCase() === \"am\" ? 0 : 12);\n      break;\n    case \"%s\":\n      a[5] = r[o] || 0;\n      break;\n    case \"%M\":\n      a[1] = n.locale.date.month_short_hash[r[o]] || 0;\n      break;\n    case \"%F\":\n      a[1] = n.locale.date.month_full_hash[r[o]] || 0;\n  }\n  return e ? new Date(Date.UTC(a[0], a[1], a[2], a[3], a[4], a[5])) : new Date(a[0], a[1], a[2], a[3], a[4], a[5]);\n} };\nfunction Gn(t) {\n  var e = null;\n  function n() {\n    var a = !1;\n    return t.config.csp === \"auto\" ? (e === null && function() {\n      try {\n        new Function(\"canUseCsp = false;\");\n      } catch {\n        e = !0;\n      }\n    }(), a = e) : a = t.config.csp, a;\n  }\n  var i = { init: function() {\n    for (var a = t.locale, r = a.date.month_short, s = a.date.month_short_hash = {}, o = 0; o < r.length; o++) s[r[o]] = o;\n    for (r = a.date.month_full, s = a.date.month_full_hash = {}, o = 0; o < r.length; o++) s[r[o]] = o;\n  }, date_part: function(a) {\n    var r = new Date(a);\n    return a.setHours(0), this.hour_start(a), a.getHours() && (a.getDate() < r.getDate() || a.getMonth() < r.getMonth() || a.getFullYear() < r.getFullYear()) && a.setTime(a.getTime() + 36e5 * (24 - a.getHours())), a;\n  }, time_part: function(a) {\n    return (a.valueOf() / 1e3 - 60 * a.getTimezoneOffset()) % 86400;\n  }, week_start: function(a) {\n    var r = a.getDay();\n    return t.config.start_on_monday && (r === 0 ? r = 6 : r--), this.date_part(this.add(a, -1 * r, \"day\"));\n  }, month_start: function(a) {\n    return a.setDate(1), this.date_part(a);\n  }, quarter_start: function(a) {\n    this.month_start(a);\n    var r, s = a.getMonth();\n    return r = s >= 9 ? 9 : s >= 6 ? 6 : s >= 3 ? 3 : 0, a.setMonth(r), a;\n  }, year_start: function(a) {\n    return a.setMonth(0), this.month_start(a);\n  }, day_start: function(a) {\n    return this.date_part(a);\n  }, hour_start: function(a) {\n    return a.getMinutes() && a.setMinutes(0), this.minute_start(a), a;\n  }, minute_start: function(a) {\n    return a.getSeconds() && a.setSeconds(0), a.getMilliseconds() && a.setMilliseconds(0), a;\n  }, _add_days: function(a, r, s) {\n    a.setDate(a.getDate() + r);\n    var o = r >= 0, l = !s.getHours() && a.getHours(), d = a.getDate() <= s.getDate() || a.getMonth() < s.getMonth() || a.getFullYear() < s.getFullYear();\n    return o && l && d && a.setTime(a.getTime() + 36e5 * (24 - a.getHours())), r > 1 && l && a.setHours(0), a;\n  }, add: function(a, r, s) {\n    var o = new Date(a.valueOf());\n    switch (s) {\n      case \"day\":\n        o = this._add_days(o, r, a);\n        break;\n      case \"week\":\n        o = this._add_days(o, 7 * r, a);\n        break;\n      case \"month\":\n        o.setMonth(o.getMonth() + r);\n        break;\n      case \"year\":\n        o.setYear(o.getFullYear() + r);\n        break;\n      case \"hour\":\n        o.setTime(o.getTime() + 60 * r * 60 * 1e3);\n        break;\n      case \"minute\":\n        o.setTime(o.getTime() + 60 * r * 1e3);\n        break;\n      default:\n        return this[\"add_\" + s](a, r, s);\n    }\n    return o;\n  }, add_quarter: function(a, r) {\n    return this.add(a, 3 * r, \"month\");\n  }, to_fixed: function(a) {\n    return a < 10 ? \"0\" + a : a;\n  }, copy: function(a) {\n    return new Date(a.valueOf());\n  }, date_to_str: function(a, r) {\n    var s = Le;\n    return n() && (s = Pe), s.date_to_str(a, r, t);\n  }, str_to_date: function(a, r) {\n    var s = Le;\n    return n() && (s = Pe), s.str_to_date(a, r, t);\n  }, getISOWeek: function(a) {\n    return t.date._getWeekNumber(a, !0);\n  }, _getWeekNumber: function(a, r) {\n    if (!a) return !1;\n    var s = a.getDay();\n    r && s === 0 && (s = 7);\n    var o = new Date(a.valueOf());\n    o.setDate(a.getDate() + (4 - s));\n    var l = o.getFullYear(), d = Math.round((o.getTime() - new Date(l, 0, 1).getTime()) / 864e5);\n    return 1 + Math.floor(d / 7);\n  }, getWeek: function(a) {\n    return t.date._getWeekNumber(a, t.config.start_on_monday);\n  }, getUTCISOWeek: function(a) {\n    return t.date.getISOWeek(a);\n  }, convert_to_utc: function(a) {\n    return new Date(a.getUTCFullYear(), a.getUTCMonth(), a.getUTCDate(), a.getUTCHours(), a.getUTCMinutes(), a.getUTCSeconds());\n  }, parseDate: function(a, r) {\n    return a && !a.getFullYear && (typeof r != \"function\" && (r = typeof r == \"string\" ? r === \"parse_date\" || r === \"xml_date\" ? t.defined(t.templates.xml_date) ? t.templates.xml_date : t.templates.parse_date : t.defined(t.templates[r]) ? t.templates[r] : t.date.str_to_date(r) : t.defined(t.templates.xml_date) ? t.templates.xml_date : t.templates.parse_date), a = a ? r(a) : null), a;\n  } };\n  return i;\n}\nclass Yn {\n  constructor(e) {\n    const { url: n, token: i } = e;\n    this._url = n, this._token = i, this._mode = 1, this._seed = 1, this._queue = [], this.data = {}, this.api = {}, this._events = {};\n  }\n  headers() {\n    return { Accept: \"application/json\", \"Content-Type\": \"application/json\", \"Remote-Token\": this._token };\n  }\n  fetch(e, n) {\n    const i = { credentials: \"include\", headers: this.headers() };\n    return n && (i.method = \"POST\", i.body = n), fetch(e, i).then((a) => a.json());\n  }\n  load(e) {\n    return e && (this._url = e), this.fetch(this._url).then((n) => this.parse(n));\n  }\n  parse(e) {\n    const { key: n, websocket: i } = e;\n    n && (this._token = e.key);\n    for (const a in e.data) this.data[a] = e.data[a];\n    for (const a in e.api) {\n      const r = this.api[a] = {}, s = e.api[a];\n      for (const o in s) r[o] = this._wrapper(a + \".\" + o);\n    }\n    return i && this.connect(), this;\n  }\n  connect() {\n    const e = this._socket;\n    e && (this._socket = null, e.onclose = function() {\n    }, e.close()), this._mode = 2, this._socket = function(n, i, a, r) {\n      let s = i;\n      s[0] === \"/\" && (s = document.location.protocol + \"//\" + document.location.host + i), s = s.replace(/^http(s|):/, \"ws$1:\");\n      const o = s.indexOf(\"?\") != -1 ? \"&\" : \"?\";\n      s = `${s}${o}token=${a}&ws=1`;\n      const l = new WebSocket(s);\n      return l.onclose = () => setTimeout(() => n.connect(), 2e3), l.onmessage = (d) => {\n        const c = JSON.parse(d.data);\n        switch (c.action) {\n          case \"result\":\n            n.result(c.body, []);\n            break;\n          case \"event\":\n            n.fire(c.body.name, c.body.value);\n            break;\n          case \"start\":\n            r();\n            break;\n          default:\n            n.onError(c.data);\n        }\n      }, l;\n    }(this, this._url, this._token, () => (this._mode = 3, this._send(), this._resubscribe(), this));\n  }\n  _wrapper(e) {\n    return (function() {\n      const n = [].slice.call(arguments);\n      let i = null;\n      const a = new Promise((r, s) => {\n        i = { data: { id: this._uid(), name: e, args: n }, status: 1, resolve: r, reject: s }, this._queue.push(i);\n      });\n      return this.onCall(i, a), this._mode === 3 ? this._send(i) : setTimeout(() => this._send(), 1), a;\n    }).bind(this);\n  }\n  _uid() {\n    return (this._seed++).toString();\n  }\n  _send(e) {\n    if (this._mode == 2) return void setTimeout(() => this._send(), 100);\n    const n = e ? [e] : this._queue.filter((a) => a.status === 1);\n    if (!n.length) return;\n    const i = n.map((a) => (a.status = 2, a.data));\n    this._mode !== 3 ? this.fetch(this._url, JSON.stringify(i)).catch((a) => this.onError(a)).then((a) => this.result(a, i)) : this._socket.send(JSON.stringify({ action: \"call\", body: i }));\n  }\n  result(e, n) {\n    const i = {};\n    if (e) for (let a = 0; a < e.length; a++) i[e[a].id] = e[a];\n    else for (let a = 0; a < n.length; a++) i[n[a].id] = { id: n[a].id, error: \"Network Error\", data: null };\n    for (let a = this._queue.length - 1; a >= 0; a--) {\n      const r = this._queue[a], s = i[r.data.id];\n      s && (this.onResponse(r, s), s.error ? r.reject(s.error) : r.resolve(s.data), this._queue.splice(a, 1));\n    }\n  }\n  on(e, n) {\n    const i = this._uid();\n    let a = this._events[e];\n    const r = !!a;\n    return r || (a = this._events[e] = []), a.push({ id: i, handler: n }), r || this._mode != 3 || this._socket.send(JSON.stringify({ action: \"subscribe\", name: e })), { name: e, id: i };\n  }\n  _resubscribe() {\n    if (this._mode == 3) for (const e in this._events) this._socket.send(JSON.stringify({ action: \"subscribe\", name: e }));\n  }\n  detach(e) {\n    if (!e) {\n      if (this._mode == 3) for (const r in this._events) this._socket.send(JSON.stringify({ action: \"unsubscribe\", key: r }));\n      return void (this._events = {});\n    }\n    const { id: n, name: i } = e, a = this._events[i];\n    if (a) {\n      const r = a.filter((s) => s.id != n);\n      r.length ? this._events[i] = r : (delete this._events[i], this._mode == 3 && this._socket.send(JSON.stringify({ action: \"unsubscribe\", name: i })));\n    }\n  }\n  fire(e, n) {\n    const i = this._events[e];\n    if (i) for (let a = 0; a < i.length; a++) i[a].handler(n);\n  }\n  onError(e) {\n    return null;\n  }\n  onCall(e, n) {\n  }\n  onResponse(e, n) {\n  }\n}\nconst Jn = function(t, e) {\n  const n = new Yn({ url: t, token: e });\n  n.fetch = function(i, a) {\n    const r = { headers: this.headers() };\n    return a && (r.method = \"POST\", r.body = a), fetch(i, r).then((s) => s.json());\n  }, this._ready = n.load().then((i) => this._remote = i), this.ready = function() {\n    return this._ready;\n  }, this.on = function(i, a) {\n    this.ready().then((r) => {\n      if (typeof i == \"string\") r.on(i, a);\n      else for (const s in i) r.on(s, i[s]);\n    });\n  };\n};\nfunction dn(t, e) {\n  if (!e) return !0;\n  if (t._on_timeout) return !1;\n  var n = Math.ceil(1e3 / e);\n  return n < 2 || (setTimeout(function() {\n    delete t._on_timeout;\n  }, n), t._on_timeout = !0), !0;\n}\nvar Kn = function() {\n  var t = {};\n  return { getState: function(e) {\n    if (t[e]) return t[e].method();\n    var n = {};\n    for (var i in t) t[i].internal || P(n, t[i].method(), !0);\n    return n;\n  }, registerProvider: function(e, n, i) {\n    t[e] = { method: n, internal: i };\n  }, unregisterProvider: function(e) {\n    delete t[e];\n  } };\n};\nconst Xn = Promise;\nvar tt = { $create: function(t) {\n  return P(t || [], this);\n}, $removeAt: function(t, e) {\n  t >= 0 && this.splice(t, e || 1);\n}, $remove: function(t) {\n  this.$removeAt(this.$find(t));\n}, $insertAt: function(t, e) {\n  if (e || e === 0) {\n    var n = this.splice(e, this.length - e);\n    this[e] = t, this.push.apply(this, n);\n  } else this.push(t);\n}, $find: function(t) {\n  for (var e = 0; e < this.length; e++) if (t == this[e]) return e;\n  return -1;\n}, $each: function(t, e) {\n  for (var n = 0; n < this.length; n++) t.call(e || this, this[n]);\n}, $map: function(t, e) {\n  for (var n = 0; n < this.length; n++) this[n] = t.call(e || this, this[n]);\n  return this;\n}, $filter: function(t, e) {\n  for (var n = 0; n < this.length; n++) t.call(e || this, this[n]) || (this.splice(n, 1), n--);\n  return this;\n} };\nfunction Rt(t, e, n, i) {\n  return (i = e ? e.config : i) && i.placeholder_task && n.exists(t) ? n.getItem(t).type === i.types.placeholder : !1;\n}\nvar it = function(t) {\n  return this.pull = {}, this.$initItem = t.initItem, this.visibleOrder = tt.$create(), this.fullOrder = tt.$create(), this._skip_refresh = !1, this._filterRule = null, this._searchVisibleOrder = {}, this._indexRangeCache = {}, this._getItemsCache = null, this.$config = t, ot(this), this._attachDataChange(function() {\n    return this._indexRangeCache = {}, this._getItemsCache = null, !0;\n  }), this;\n};\nit.prototype = { _attachDataChange: function(t) {\n  this.attachEvent(\"onClearAll\", t), this.attachEvent(\"onBeforeParse\", t), this.attachEvent(\"onBeforeUpdate\", t), this.attachEvent(\"onBeforeDelete\", t), this.attachEvent(\"onBeforeAdd\", t), this.attachEvent(\"onParse\", t), this.attachEvent(\"onBeforeFilter\", t);\n}, _parseInner: function(t) {\n  for (var e = null, n = [], i = 0, a = t.length; i < a; i++) e = t[i], this.$initItem && (this.$config.copyOnParse() && (e = q(e)), e = this.$initItem(e)), this.callEvent(\"onItemLoading\", [e]) && (this.pull.hasOwnProperty(e.id) || this.fullOrder.push(e.id), n.push(e), this.pull[e.id] = e);\n  return n;\n}, parse: function(t) {\n  this.isSilent() || this.callEvent(\"onBeforeParse\", [t]);\n  var e = this._parseInner(t);\n  this.isSilent() || (this.refresh(), this.callEvent(\"onParse\", [e]));\n}, getItem: function(t) {\n  return this.pull[t];\n}, _updateOrder: function(t) {\n  t.call(this.visibleOrder), t.call(this.fullOrder);\n}, updateItem: function(t, e) {\n  if (W(e) || (e = this.getItem(t)), !this.isSilent() && this.callEvent(\"onBeforeUpdate\", [e.id, e]) === !1) return !1;\n  P(this.pull[t], e, !0), this.isSilent() || (this.callEvent(\"onAfterUpdate\", [e.id, e]), this.callEvent(\"onStoreUpdated\", [e.id, e, \"update\"]));\n}, _removeItemInner: function(t) {\n  this._updateOrder(function() {\n    this.$remove(t);\n  }), delete this.pull[t];\n}, removeItem: function(t) {\n  var e = this.getItem(t);\n  if (!this.isSilent() && this.callEvent(\"onBeforeDelete\", [e.id, e]) === !1) return !1;\n  this.callEvent(\"onAfterDeleteConfirmed\", [e.id, e]), this._removeItemInner(t), this.isSilent() && this.callEvent(\"onAfterSilentDelete\", [e.id, e]), this.isSilent() || (this.filter(), this.callEvent(\"onAfterDelete\", [e.id, e]), this.callEvent(\"onStoreUpdated\", [e.id, e, \"delete\"]));\n}, _addItemInner: function(t, e) {\n  if (this.exists(t.id)) this.silent(function() {\n    this.updateItem(t.id, t);\n  });\n  else {\n    var n = this.visibleOrder, i = n.length;\n    (!W(e) || e < 0) && (e = i), e > i && (e = Math.min(n.length, e));\n  }\n  this.pull[t.id] = t, this._updateOrder(function() {\n    this.$find(t.id) === -1 && this.$insertAt(t.id, e);\n  }), this.filter();\n}, isVisible: function(t) {\n  return this.visibleOrder.$find(t) > -1;\n}, getVisibleItems: function() {\n  return this.getIndexRange();\n}, addItem: function(t, e) {\n  return W(t.id) || (t.id = st()), this.$initItem && (t = this.$initItem(t)), !(!this.isSilent() && this.callEvent(\"onBeforeAdd\", [t.id, t]) === !1) && (this._addItemInner(t, e), this.isSilent() || (this.callEvent(\"onAfterAdd\", [t.id, t]), this.callEvent(\"onStoreUpdated\", [t.id, t, \"add\"])), t.id);\n}, _changeIdInner: function(t, e) {\n  this.pull[t] && (this.pull[e] = this.pull[t]);\n  var n = this._searchVisibleOrder[t];\n  this.pull[e].id = e, this._updateOrder(function() {\n    this[this.$find(t)] = e;\n  }), this._searchVisibleOrder[e] = n, delete this._searchVisibleOrder[t], delete this.pull[t];\n}, changeId: function(t, e) {\n  this._changeIdInner(t, e), this.callEvent(\"onIdChange\", [t, e]);\n}, exists: function(t) {\n  return !!this.pull[t];\n}, _moveInner: function(t, e) {\n  var n = this.getIdByIndex(t);\n  this._updateOrder(function() {\n    this.$removeAt(t), this.$insertAt(n, Math.min(this.length, e));\n  });\n}, move: function(t, e) {\n  var n = this.getIdByIndex(t), i = this.getItem(n);\n  this._moveInner(t, e), this.isSilent() || this.callEvent(\"onStoreUpdated\", [i.id, i, \"move\"]);\n}, clearAll: function() {\n  this.$destroyed || (this.silent(function() {\n    this.unselect();\n  }), this.pull = {}, this.visibleOrder = tt.$create(), this.fullOrder = tt.$create(), this.isSilent() || (this.callEvent(\"onClearAll\", []), this.refresh()));\n}, silent: function(t, e) {\n  var n = !1;\n  this.isSilent() && (n = !0), this._skip_refresh = !0, t.call(e || this), n || (this._skip_refresh = !1);\n}, isSilent: function() {\n  return !!this._skip_refresh;\n}, arraysEqual: function(t, e) {\n  if (t.length !== e.length) return !1;\n  for (var n = 0; n < t.length; n++) if (t[n] !== e[n]) return !1;\n  return !0;\n}, refresh: function(t, e) {\n  var n, i;\n  if (!this.$destroyed && !this.isSilent() && (t && (n = this.getItem(t)), i = t ? [t, n, \"paint\"] : [null, null, null], this.callEvent(\"onBeforeStoreUpdate\", i) !== !1)) {\n    var a = this._quick_refresh && !this._mark_recompute;\n    if (this._mark_recompute = !1, t) {\n      if (!e && !a) {\n        var r = this.visibleOrder;\n        this.filter(), this.arraysEqual(r, this.visibleOrder) || (t = void 0);\n      }\n    } else a || this.filter();\n    i = t ? [t, n, \"paint\"] : [null, null, null], this.callEvent(\"onStoreUpdated\", i);\n  }\n}, count: function() {\n  return this.fullOrder.length;\n}, countVisible: function() {\n  return this.visibleOrder.length;\n}, sort: function(t) {\n}, serialize: function() {\n}, eachItem: function(t) {\n  for (var e = 0; e < this.fullOrder.length; e++) {\n    var n = this.getItem(this.fullOrder[e]);\n    t.call(this, n);\n  }\n}, find: function(t) {\n  var e = [];\n  return this.eachItem(function(n) {\n    t(n) && e.push(n);\n  }), e;\n}, filter: function(t) {\n  this.isSilent() || this.callEvent(\"onBeforeFilter\", []), this.callEvent(\"onPreFilter\", []);\n  var e = tt.$create(), n = [];\n  this.eachItem(function(a) {\n    this.callEvent(\"onFilterItem\", [a.id, a]) && (Rt(a.id, null, this, this._ganttConfig) ? n.push(a.id) : e.push(a.id));\n  });\n  for (var i = 0; i < n.length; i++) e.push(n[i]);\n  for (this.visibleOrder = e, this._searchVisibleOrder = {}, i = 0; i < this.visibleOrder.length; i++) this._searchVisibleOrder[this.visibleOrder[i]] = i;\n  this.isSilent() || this.callEvent(\"onFilter\", []);\n}, getIndexRange: function(t, e) {\n  var n = Math.min(e || 1 / 0, this.countVisible() - 1), i = t || 0, a = i + \"-\" + n;\n  if (this._indexRangeCache[a]) return this._indexRangeCache[a].slice();\n  for (var r = [], s = i; s <= n; s++) r.push(this.getItem(this.visibleOrder[s]));\n  return this._indexRangeCache[a] = r.slice(), r;\n}, getItems: function() {\n  if (this._getItemsCache) return this._getItemsCache.slice();\n  var t = [];\n  for (var e in this.pull) t.push(this.pull[e]);\n  return this._getItemsCache = t.slice(), t;\n}, getIdByIndex: function(t) {\n  return this.visibleOrder[t];\n}, getIndexById: function(t) {\n  var e = this._searchVisibleOrder[t];\n  return e === void 0 && (e = -1), e;\n}, _getNullIfUndefined: function(t) {\n  return t === void 0 ? null : t;\n}, getFirst: function() {\n  return this._getNullIfUndefined(this.visibleOrder[0]);\n}, getLast: function() {\n  return this._getNullIfUndefined(this.visibleOrder[this.visibleOrder.length - 1]);\n}, getNext: function(t) {\n  return this._getNullIfUndefined(this.visibleOrder[this.getIndexById(t) + 1]);\n}, getPrev: function(t) {\n  return this._getNullIfUndefined(this.visibleOrder[this.getIndexById(t) - 1]);\n}, destructor: function() {\n  this.callEvent(\"onDestroy\", []), this.detachAllEvents(), this.$destroyed = !0, this.pull = null, this.$initItem = null, this.visibleOrder = null, this.fullOrder = null, this._skip_refresh = null, this._filterRule = null, this._searchVisibleOrder = null, this._indexRangeCache = {};\n} };\nvar cn = function(t) {\n  var e;\n  it.apply(this, [t]), this._branches = {}, this.pull = {}, this.$initItem = function(o) {\n    var l = o;\n    t.initItem && (l = t.initItem(l));\n    var d = this.getItem(o.id);\n    return d && !lt(d.parent, l.parent) && this.move(l.id, l.$index || -1, l.parent || this._ganttConfig.root_id), l;\n  }, this.$parentProperty = t.parentProperty || \"parent\", typeof t.rootId != \"function\" ? this.$getRootId = (e = t.rootId || 0, function() {\n    return e;\n  }) : this.$getRootId = t.rootId, this.$openInitially = t.openInitially, this.visibleOrder = tt.$create(), this.fullOrder = tt.$create(), this._searchVisibleOrder = {}, this._indexRangeCache = {}, this._eachItemMainRangeCache = null, this._getItemsCache = null, this._skip_refresh = !1, this._ganttConfig = null, t.getConfig && (this._ganttConfig = t.getConfig());\n  var n = {}, i = {}, a = {}, r = {}, s = !1;\n  return this._attachDataChange(function() {\n    return this._indexRangeCache = {}, this._eachItemMainRangeCache = null, this._getItemsCache = null, !0;\n  }), this.attachEvent(\"onPreFilter\", function() {\n    this._indexRangeCache = {}, this._eachItemMainRangeCache = null, n = {}, i = {}, a = {}, r = {}, s = !1, this.eachItem(function(o) {\n      var l = this.getParent(o.id);\n      o.$open && a[l] !== !1 ? a[o.id] = !0 : a[o.id] = !1, this._isSplitItem(o) && (s = !0, n[o.id] = !0, i[o.id] = !0), s && i[l] && (i[o.id] = !0), a[l] || a[l] === void 0 ? r[o.id] = !0 : r[o.id] = !1;\n    });\n  }), this.attachEvent(\"onFilterItem\", function(o, l) {\n    var d = !1;\n    this._ganttConfig && (d = this._ganttConfig.open_split_tasks);\n    var c = r[l.id];\n    return s && (c && i[l.id] && !n[l.id] && (c = !!d), i[l.id] && !n[l.id] && (l.$split_subtask = !0)), l.$expanded_branch = !!r[l.id], !!c;\n  }), this.attachEvent(\"onFilter\", function() {\n    n = {}, i = {}, a = {}, r = {};\n  }), this;\n};\nfunction lt(t, e) {\n  return String(t) === String(e);\n}\nfunction F(t) {\n  return mt.isNode || !t.$root;\n}\ncn.prototype = P({ _buildTree: function(t) {\n  for (var e = null, n = this.$getRootId(), i = 0, a = t.length; i < a; i++) e = t[i], this.setParent(e, at(this.getParent(e), n) || n);\n  for (i = 0, a = t.length; i < a; i++) e = t[i], this._add_branch(e), e.$level = this.calculateItemLevel(e), e.$local_index = this.getBranchIndex(e.id), W(e.$open) || (e.$open = W(e.open) ? e.open : this.$openInitially());\n  this._updateOrder();\n}, _isSplitItem: function(t) {\n  return t.render == \"split\" && this.hasChild(t.id);\n}, parse: function(t) {\n  this._skip_refresh || this.callEvent(\"onBeforeParse\", [t]);\n  var e = this._parseInner(t);\n  this._buildTree(e), this.filter(), this._skip_refresh || this.callEvent(\"onParse\", [e]);\n}, _addItemInner: function(t, e) {\n  var n = this.getParent(t);\n  W(n) || (n = this.$getRootId(), this.setParent(t, n));\n  var i = this.getIndexById(n) + Math.min(Math.max(e, 0), this.visibleOrder.length);\n  1 * i !== i && (i = void 0), it.prototype._addItemInner.call(this, t, i), this.setParent(t, n), t.hasOwnProperty(\"$rendered_parent\") && this._move_branch(t, t.$rendered_parent), this._add_branch(t, e);\n}, _changeIdInner: function(t, e) {\n  var n = this.getChildren(t), i = this._searchVisibleOrder[t];\n  it.prototype._changeIdInner.call(this, t, e);\n  var a = this.getParent(e);\n  this._replace_branch_child(a, t, e), this._branches[t] && (this._branches[e] = this._branches[t]);\n  for (var r = 0; r < n.length; r++) {\n    var s = this.getItem(n[r]);\n    s[this.$parentProperty] = e, s.$rendered_parent = e;\n  }\n  this._searchVisibleOrder[e] = i, delete this._branches[t];\n}, _traverseBranches: function(t, e) {\n  W(e) || (e = this.$getRootId());\n  var n = this._branches[e];\n  if (n) for (var i = 0; i < n.length; i++) {\n    var a = n[i];\n    t.call(this, a), this._branches[a] && this._traverseBranches(t, a);\n  }\n}, _updateOrder: function(t) {\n  this.fullOrder = tt.$create(), this._traverseBranches(function(e) {\n    this.fullOrder.push(e);\n  }), t && it.prototype._updateOrder.call(this, t);\n}, _removeItemInner: function(t) {\n  var e = [];\n  this.eachItem(function(i) {\n    e.push(i);\n  }, t), e.push(this.getItem(t));\n  for (var n = 0; n < e.length; n++) this._move_branch(e[n], this.getParent(e[n]), null), it.prototype._removeItemInner.call(this, e[n].id), this._move_branch(e[n], this.getParent(e[n]), null);\n}, move: function(t, e, n) {\n  var i = arguments[3], a = (this._ganttConfig || {}).root_id || 0;\n  if (i = at(i, a)) {\n    if (i === t) return;\n    n = this.getParent(i), e = this.getBranchIndex(i);\n  }\n  if (!lt(t, n)) {\n    W(n) || (n = this.$getRootId());\n    var r = this.getItem(t), s = this.getParent(r.id), o = this.getChildren(n);\n    if (e == -1 && (e = o.length + 1), lt(s, n) && this.getBranchIndex(t) == e) return;\n    if (this.callEvent(\"onBeforeItemMove\", [t, n, e]) === !1) return !1;\n    for (var l = [], d = 0; d < o.length; d++) Rt(o[d], null, this, this._ganttConfig) && (l.push(o[d]), o.splice(d, 1), d--);\n    this._replace_branch_child(s, t);\n    var c = (o = this.getChildren(n))[e];\n    (c = at(c, a)) ? o = o.slice(0, e).concat([t]).concat(o.slice(e)) : o.push(t), l.length && (o = o.concat(l)), lt(r.$rendered_parent, s) || lt(s, n) || (r.$rendered_parent = s), this.setParent(r, n), this._branches[n] = o;\n    var u = this.calculateItemLevel(r) - r.$level;\n    r.$level += u, this.eachItem(function(h) {\n      h.$level += u;\n    }, r.id, this), this._moveInner(this.getIndexById(t), this.getIndexById(n) + e), this.callEvent(\"onAfterItemMove\", [t, n, e]), this.refresh();\n  }\n}, getBranchIndex: function(t) {\n  var e = this.getChildren(this.getParent(t));\n  let n = e.indexOf(t + \"\");\n  return n == -1 && (n = e.indexOf(+t)), n;\n}, hasChild: function(t) {\n  var e = this._branches[t];\n  return e && e.length;\n}, getChildren: function(t) {\n  var e = this._branches[t];\n  return e || tt.$create();\n}, isChildOf: function(t, e) {\n  if (!this.exists(t)) return !1;\n  if (e === this.$getRootId()) return !0;\n  if (!this.hasChild(e)) return !1;\n  var n = this.getItem(t), i = this.getParent(t);\n  if (this.getItem(e).$level >= n.$level) return !1;\n  for (; n && this.exists(i); ) {\n    if ((n = this.getItem(i)) && lt(n.id, e)) return !0;\n    i = this.getParent(n);\n  }\n  return !1;\n}, getSiblings: function(t) {\n  if (!this.exists(t)) return tt.$create();\n  var e = this.getParent(t);\n  return this.getChildren(e);\n}, getNextSibling: function(t) {\n  for (var e = this.getSiblings(t), n = 0, i = e.length; n < i; n++) if (lt(e[n], t)) {\n    var a = e[n + 1];\n    return a === 0 && n > 0 && (a = \"0\"), a || null;\n  }\n  return null;\n}, getPrevSibling: function(t) {\n  for (var e = this.getSiblings(t), n = 0, i = e.length; n < i; n++) if (lt(e[n], t)) {\n    var a = e[n - 1];\n    return a === 0 && n > 0 && (a = \"0\"), a || null;\n  }\n  return null;\n}, getParent: function(t) {\n  var e = null;\n  return (e = t.id !== void 0 ? t : this.getItem(t)) ? e[this.$parentProperty] : this.$getRootId();\n}, clearAll: function() {\n  this._branches = {}, it.prototype.clearAll.call(this);\n}, calculateItemLevel: function(t) {\n  var e = 0;\n  return this.eachParent(function() {\n    e++;\n  }, t), e;\n}, _setParentInner: function(t, e, n) {\n  n || (t.hasOwnProperty(\"$rendered_parent\") ? this._move_branch(t, t.$rendered_parent, e) : this._move_branch(t, t[this.$parentProperty], e));\n}, setParent: function(t, e, n) {\n  this._setParentInner(t, e, n), t[this.$parentProperty] = e;\n}, _eachItemCached: function(t, e) {\n  for (var n = 0, i = e.length; n < i; n++) t.call(this, e[n]);\n}, _eachItemIterate: function(t, e, n) {\n  var i = this.getChildren(e);\n  for (i.length && (i = i.slice().reverse()); i.length; ) {\n    var a = i.pop(), r = this.getItem(a);\n    if (t.call(this, r), n && n.push(r), this.hasChild(r.id)) for (var s = this.getChildren(r.id), o = s.length - 1; o >= 0; o--) i.push(s[o]);\n  }\n}, eachItem: function(t, e) {\n  var n = this.$getRootId();\n  W(e) || (e = n);\n  var i = at(e, n) || n, a = !1, r = !1, s = null;\n  i === n && (this._eachItemMainRangeCache ? (a = !0, s = this._eachItemMainRangeCache) : (r = !0, s = this._eachItemMainRangeCache = [])), a ? this._eachItemCached(t, s) : this._eachItemIterate(t, i, r ? s : null);\n}, eachParent: function(t, e) {\n  for (var n = {}, i = e, a = this.getParent(i); this.exists(a); ) {\n    if (n[a]) throw new Error(\"Invalid tasks tree. Cyclic reference has been detected on task \" + a);\n    n[a] = !0, i = this.getItem(a), t.call(this, i), a = this.getParent(i);\n  }\n}, _add_branch: function(t, e, n) {\n  var i = n === void 0 ? this.getParent(t) : n;\n  this.hasChild(i) || (this._branches[i] = tt.$create());\n  var a = this.getChildren(i);\n  a.indexOf(t.id + \"\") > -1 || a.indexOf(+t.id) > -1 || (1 * e == e ? a.splice(e, 0, t.id) : a.push(t.id), t.$rendered_parent = i);\n}, _move_branch: function(t, e, n) {\n  this._eachItemMainRangeCache = null, this._replace_branch_child(e, t.id), this.exists(n) || lt(n, this.$getRootId()) ? this._add_branch(t, void 0, n) : delete this._branches[t.id], t.$level = this.calculateItemLevel(t), this.eachItem(function(i) {\n    i.$level = this.calculateItemLevel(i);\n  }, t.id);\n}, _replace_branch_child: function(t, e, n) {\n  var i = this.getChildren(t);\n  if (i && t !== void 0) {\n    var a = tt.$create();\n    let r = i.indexOf(e + \"\");\n    r != -1 || isNaN(+e) || (r = i.indexOf(+e)), r > -1 && (n ? i.splice(r, 1, n) : i.splice(r, 1)), a = i, this._branches[t] = a;\n  }\n}, sort: function(t, e, n) {\n  this.exists(n) || (n = this.$getRootId()), t || (t = \"order\");\n  var i = typeof t == \"string\" ? function(l, d) {\n    return l[t] == d[t] || Z(l[t]) && Z(d[t]) && l[t].valueOf() == d[t].valueOf() ? 0 : l[t] > d[t] ? 1 : -1;\n  } : t;\n  if (e) {\n    var a = i;\n    i = function(l, d) {\n      return a(d, l);\n    };\n  }\n  var r = this.getChildren(n);\n  if (r) {\n    for (var s = [], o = r.length - 1; o >= 0; o--) s[o] = this.getItem(r[o]);\n    for (s.sort(i), o = 0; o < s.length; o++) r[o] = s[o].id, this.sort(t, e, r[o]);\n  }\n}, filter: function(t) {\n  for (let e in this.pull) {\n    const n = this.pull[e].$rendered_parent, i = this.getParent(this.pull[e]);\n    lt(n, i) || this._move_branch(this.pull[e], n, i);\n  }\n  return it.prototype.filter.apply(this, arguments);\n}, open: function(t) {\n  this.exists(t) && (this.getItem(t).$open = !0, this._skipTaskRecalculation = !0, this.callEvent(\"onItemOpen\", [t]));\n}, close: function(t) {\n  this.exists(t) && (this.getItem(t).$open = !1, this._skipTaskRecalculation = !0, this.callEvent(\"onItemClose\", [t]));\n}, destructor: function() {\n  it.prototype.destructor.call(this), this._branches = null, this._indexRangeCache = {}, this._eachItemMainRangeCache = null;\n} }, it.prototype);\nconst Zn = function(t, e) {\n  const n = e.getDatastore(t), i = function(o, l) {\n    const d = l.getLayers(), c = n.getItem(o);\n    if (c && n.isVisible(o)) for (let u = 0; u < d.length; u++) d[u].render_item(c);\n  }, a = function(o) {\n    const l = o.getLayers();\n    for (let g = 0; g < l.length; g++) l[g].clear();\n    let d = null;\n    const c = {};\n    for (let g = 0; g < l.length; g++) {\n      const p = l[g];\n      let y;\n      if (p.get_visible_range) {\n        var u = p.get_visible_range(n);\n        if (u.start !== void 0 && u.end !== void 0) {\n          var h = u.start + \" - \" + u.end;\n          c[h] ? y = c[h] : (y = n.getIndexRange(u.start, u.end), c[h] = y);\n        } else {\n          if (u.ids === void 0) throw new Error(\"Invalid range returned from 'getVisibleRange' of the layer\");\n          y = u.ids.map(function(v) {\n            return n.getItem(v);\n          });\n        }\n      } else d || (d = n.getVisibleItems()), y = d;\n      p.prepare_data && p.prepare_data(y), l[g].render_items(y);\n    }\n  }, r = function(o) {\n    if (o.update_items) {\n      let d = [];\n      if (o.get_visible_range) {\n        var l = o.get_visible_range(n);\n        if (l.start !== void 0 && l.end !== void 0 && (d = n.getIndexRange(l.start, l.end)), l.ids !== void 0) {\n          let c = l.ids.map(function(u) {\n            return n.getItem(u);\n          });\n          c.length > 0 && (c = c.filter((u) => u !== void 0), d = d.concat(c));\n        }\n        if ((l.start == null || l.end == null) && l.ids == null) throw new Error(\"Invalid range returned from 'getVisibleRange' of the layer\");\n      } else d = n.getVisibleItems();\n      o.prepare_data && o.prepare_data(d, o), o.update_items(d);\n    }\n  };\n  function s(o) {\n    return !!o.$services.getService(\"state\").getState(\"batchUpdate\").batch_update;\n  }\n  n.attachEvent(\"onStoreUpdated\", function(o, l, d) {\n    if (F(e)) return !0;\n    const c = e.$services.getService(\"layers\").getDataRender(t);\n    c && (c.onUpdateRequest = function(u) {\n      r(u);\n    });\n  }), n.attachEvent(\"onStoreUpdated\", function(o, l, d) {\n    s(e) || (o && d != \"move\" && d != \"delete\" ? (n.callEvent(\"onBeforeRefreshItem\", [l.id]), n.callEvent(\"onAfterRefreshItem\", [l.id])) : (n.callEvent(\"onBeforeRefreshAll\", []), n.callEvent(\"onAfterRefreshAll\", [])));\n  }), n.attachEvent(\"onAfterRefreshAll\", function() {\n    if (F(e)) return !0;\n    const o = e.$services.getService(\"layers\").getDataRender(t);\n    o && !s(e) && a(o);\n  }), n.attachEvent(\"onAfterRefreshItem\", function(o) {\n    if (F(e)) return !0;\n    const l = e.$services.getService(\"layers\").getDataRender(t);\n    l && i(o, l);\n  }), n.attachEvent(\"onItemOpen\", function() {\n    if (F(e) || n.isSilent()) return !0;\n    e.render();\n  }), n.attachEvent(\"onItemClose\", function() {\n    if (F(e) || n.isSilent()) return !0;\n    e.render();\n  }), n.attachEvent(\"onIdChange\", function(o, l) {\n    if (F(e)) return !0;\n    if (n.callEvent(\"onBeforeIdChange\", [o, l]), !s(e) && !n.isSilent()) {\n      const d = e.$services.getService(\"layers\").getDataRender(t);\n      d ? (function(c, u, h) {\n        for (let g = 0; g < c.length; g++) c[g].change_id(u, h);\n      }(d.getLayers(), o, l, n.getItem(l)), i(l, d)) : e.render();\n    }\n  });\n};\nfunction ne() {\n  for (var t = this.$services.getService(\"datastores\"), e = [], n = 0; n < t.length; n++) {\n    var i = this.getDatastore(t[n]);\n    i.$destroyed || e.push(i);\n  }\n  return e;\n}\nconst Qn = { create: function() {\n  var t = P({}, { createDatastore: function(e) {\n    var n = (e.type || \"\").toLowerCase() == \"treedatastore\" ? cn : it;\n    if (e) {\n      var i = this;\n      e.openInitially = function() {\n        return i.config.open_tree_initially;\n      }, e.copyOnParse = function() {\n        return i.config.deepcopy_on_parse;\n      };\n    }\n    var a = new n(e);\n    if (this.mixin(a, function(o) {\n      var l = null, d = o._removeItemInner;\n      function c(u) {\n        l = null, this.callEvent(\"onAfterUnselect\", [u]);\n      }\n      return o._removeItemInner = function(u) {\n        return l == u && c.call(this, u), l && this.eachItem && this.eachItem(function(h) {\n          h.id == l && c.call(this, h.id);\n        }, u), d.apply(this, arguments);\n      }, o.attachEvent(\"onIdChange\", function(u, h) {\n        o.getSelectedId() == u && o.silent(function() {\n          o.unselect(u), o.select(h);\n        });\n      }), { select: function(u) {\n        if (u) {\n          if (l == u) return l;\n          if (!this._skip_refresh && !this.callEvent(\"onBeforeSelect\", [u])) return !1;\n          this.unselect(), l = u, this._skip_refresh || (this.refresh(u), this.callEvent(\"onAfterSelect\", [u]));\n        }\n        return l;\n      }, getSelectedId: function() {\n        return l;\n      }, isSelected: function(u) {\n        return u == l;\n      }, unselect: function(u) {\n        (u = u || l) && (l = null, this._skip_refresh || (this.refresh(u), c.call(this, u)));\n      } };\n    }(a)), e.name) {\n      var r = \"datastore:\" + e.name;\n      a.attachEvent(\"onDestroy\", (function() {\n        this.$services.dropService(r);\n        for (var o = this.$services.getService(\"datastores\"), l = 0; l < o.length; l++) if (o[l] === e.name) {\n          o.splice(l, 1);\n          break;\n        }\n      }).bind(this)), this.$services.dropService(r), this.$services.setService(r, function() {\n        return a;\n      });\n      var s = this.$services.getService(\"datastores\");\n      s ? s.indexOf(e.name) < 0 && s.push(e.name) : (s = [], this.$services.setService(\"datastores\", function() {\n        return s;\n      }), s.push(e.name)), Zn(e.name, this);\n    }\n    return a;\n  }, getDatastore: function(e) {\n    return this.$services.getService(\"datastore:\" + e);\n  }, _getDatastores: ne, refreshData: function() {\n    var e;\n    F(this) || (e = this.getScrollState()), this.callEvent(\"onBeforeDataRender\", []);\n    for (var n = ne.call(this), i = 0; i < n.length; i++) n[i].refresh();\n    this.config.preserve_scroll && !F(this) && (e.x || e.y) && this.scrollTo(e.x, e.y), this.callEvent(\"onDataRender\", []);\n  }, isChildOf: function(e, n) {\n    return this.$data.tasksStore.isChildOf(e, n);\n  }, refreshTask: function(e, n) {\n    var i = this.getTask(e), a = this;\n    function r() {\n      if (n === void 0 || n) {\n        for (var o = 0; o < i.$source.length; o++) a.refreshLink(i.$source[o]);\n        for (o = 0; o < i.$target.length; o++) a.refreshLink(i.$target[o]);\n      }\n    }\n    if (i && this.isTaskVisible(e)) this.$data.tasksStore.refresh(e, !!this.getState(\"tasksDnd\").drag_id || n === !1), r();\n    else if (this.isTaskExists(e) && this.isTaskExists(this.getParent(e)) && !this._bulk_dnd) {\n      this.refreshTask(this.getParent(e));\n      var s = !1;\n      this.eachParent(function(o) {\n        (s || this.isSplitTask(o)) && (s = !0);\n      }, e), s && r();\n    }\n  }, refreshLink: function(e) {\n    this.$data.linksStore.refresh(e, !!this.getState(\"tasksDnd\").drag_id);\n  }, silent: function(e) {\n    var n = this;\n    n.$data.tasksStore.silent(function() {\n      n.$data.linksStore.silent(function() {\n        e();\n      });\n    });\n  }, clearAll: function() {\n    for (var e = ne.call(this), n = 0; n < e.length; n++) e[n].silent(function() {\n      e[n].clearAll();\n    });\n    for (n = 0; n < e.length; n++) e[n].clearAll();\n    this._update_flags(), this.userdata = {}, this.callEvent(\"onClear\", []), this.render();\n  }, _clear_data: function() {\n    this.$data.tasksStore.clearAll(), this.$data.linksStore.clearAll(), this._update_flags(), this.userdata = {};\n  }, selectTask: function(e) {\n    var n = this.$data.tasksStore;\n    if (!this.config.select_task) return !1;\n    if (e = at(e, this.config.root_id)) {\n      let i = this.getSelectedId();\n      n._skipResourceRepaint = !0, n.select(e), n._skipResourceRepaint = !1, i && n.pull[i].$split_subtask && i != e && this.refreshTask(i), n.pull[e].$split_subtask && i != e && this.refreshTask(e);\n    }\n    return n.getSelectedId();\n  }, unselectTask: function(e) {\n    var n = this.$data.tasksStore;\n    n.unselect(e), e && n.pull[e].$split_subtask && this.refreshTask(e);\n  }, isSelectedTask: function(e) {\n    return this.$data.tasksStore.isSelected(e);\n  }, getSelectedId: function() {\n    return this.$data.tasksStore.getSelectedId();\n  } });\n  return P(t, { getTask: function(e) {\n    e = at(e, this.config.root_id), this.assert(e, \"Invalid argument for gantt.getTask\");\n    var n = this.$data.tasksStore.getItem(e);\n    return this.assert(n, \"Task not found id=\" + e), n;\n  }, getTaskByTime: function(e, n) {\n    var i = this.$data.tasksStore.getItems(), a = [];\n    if (e || n) {\n      e = +e || -1 / 0, n = +n || 1 / 0;\n      for (var r = 0; r < i.length; r++) {\n        var s = i[r];\n        +s.start_date < n && +s.end_date > e && a.push(s);\n      }\n    } else a = i;\n    return a;\n  }, isTaskExists: function(e) {\n    return !(!this.$data || !this.$data.tasksStore) && this.$data.tasksStore.exists(e);\n  }, updateTask: function(e, n) {\n    W(n) || (n = this.getTask(e)), this.$data.tasksStore.updateItem(e, n), this.isTaskExists(e) && this.refreshTask(e);\n  }, addTask: function(e, n, i) {\n    if (W(e.id) || (e.id = st()), this.isTaskExists(e.id) && this.getTask(e.id).$index != e.$index) return e.start_date && typeof e.start_date == \"string\" && (e.start_date = this.date.parseDate(e.start_date, \"parse_date\")), e.end_date && typeof e.end_date == \"string\" && (e.end_date = this.date.parseDate(e.end_date, \"parse_date\")), this.$data.tasksStore.updateItem(e.id, e);\n    if (W(n) || (n = this.getParent(e) || 0), this.isTaskExists(n) || (n = this.config.root_id), this.setParent(e, n), this.getState().lightbox && this.isTaskExists(n)) {\n      var a = this.getTask(n);\n      this.callEvent(\"onAfterParentExpand\", [n, a]);\n    }\n    return this.$data.tasksStore.addItem(e, i, n);\n  }, deleteTask: function(e) {\n    return e = at(e, this.config.root_id), this.$data.tasksStore.removeItem(e);\n  }, getTaskCount: function() {\n    return this.$data.tasksStore.count();\n  }, getVisibleTaskCount: function() {\n    return this.$data.tasksStore.countVisible();\n  }, getTaskIndex: function(e) {\n    return this.$data.tasksStore.getBranchIndex(e);\n  }, getGlobalTaskIndex: function(e) {\n    return e = at(e, this.config.root_id), this.assert(e, \"Invalid argument\"), this.$data.tasksStore.getIndexById(e);\n  }, eachTask: function(e, n, i) {\n    return this.$data.tasksStore.eachItem(R(e, i || this), n);\n  }, eachParent: function(e, n, i) {\n    return this.$data.tasksStore.eachParent(R(e, i || this), n);\n  }, changeTaskId: function(e, n) {\n    this.$data.tasksStore.changeId(e, n);\n    var i = this.$data.tasksStore.getItem(n), a = [];\n    i.$source && (a = a.concat(i.$source)), i.$target && (a = a.concat(i.$target));\n    for (var r = 0; r < a.length; r++) {\n      var s = this.getLink(a[r]);\n      s.source == e && (s.source = n), s.target == e && (s.target = n);\n    }\n  }, calculateTaskLevel: function(e) {\n    return this.$data.tasksStore.calculateItemLevel(e);\n  }, getNext: function(e) {\n    return this.$data.tasksStore.getNext(e);\n  }, getPrev: function(e) {\n    return this.$data.tasksStore.getPrev(e);\n  }, getParent: function(e) {\n    return this.$data.tasksStore.getParent(e);\n  }, setParent: function(e, n, i) {\n    return this.$data.tasksStore.setParent(e, n, i);\n  }, getSiblings: function(e) {\n    return this.$data.tasksStore.getSiblings(e).slice();\n  }, getNextSibling: function(e) {\n    return this.$data.tasksStore.getNextSibling(e);\n  }, getPrevSibling: function(e) {\n    return this.$data.tasksStore.getPrevSibling(e);\n  }, getTaskByIndex: function(e) {\n    var n = this.$data.tasksStore.getIdByIndex(e);\n    return this.isTaskExists(n) ? this.getTask(n) : null;\n  }, getChildren: function(e) {\n    return this.hasChild(e) ? this.$data.tasksStore.getChildren(e).slice() : [];\n  }, hasChild: function(e) {\n    return this.$data.tasksStore.hasChild(e);\n  }, open: function(e) {\n    this.$data.tasksStore.open(e);\n  }, close: function(e) {\n    this.$data.tasksStore.close(e);\n  }, moveTask: function(e, n, i) {\n    return i = at(i, this.config.root_id), this.$data.tasksStore.move.apply(this.$data.tasksStore, arguments);\n  }, sort: function(e, n, i, a) {\n    var r = !a;\n    this.$data.tasksStore.sort(e, n, i), this.callEvent(\"onAfterSort\", [e, n, i]), r && this.render();\n  } }), P(t, { getLinkCount: function() {\n    return this.$data.linksStore.count();\n  }, getLink: function(e) {\n    return this.$data.linksStore.getItem(e);\n  }, getLinks: function() {\n    return this.$data.linksStore.getItems();\n  }, isLinkExists: function(e) {\n    return this.$data.linksStore.exists(e);\n  }, addLink: function(e) {\n    const n = this.$data.linksStore.addItem(e);\n    return this.$data.linksStore.isSilent() && this.$data.linksStore.fullOrder.push(n), n;\n  }, updateLink: function(e, n) {\n    W(n) || (n = this.getLink(e)), this.$data.linksStore.updateItem(e, n);\n  }, deleteLink: function(e) {\n    return this.$data.linksStore.removeItem(e);\n  }, changeLinkId: function(e, n) {\n    return this.$data.linksStore.changeId(e, n);\n  } }), t;\n} };\nfunction pe(t) {\n  var e = t.date, n = t.$services;\n  return { getSum: function(i, a, r) {\n    r === void 0 && (r = i.length - 1), a === void 0 && (a = 0);\n    for (var s = 0, o = a; o <= r; o++) s += i[o];\n    return s;\n  }, setSumWidth: function(i, a, r, s) {\n    var o = a.width;\n    s === void 0 && (s = o.length - 1), r === void 0 && (r = 0);\n    var l = s - r + 1;\n    if (!(r > o.length - 1 || l <= 0 || s > o.length - 1)) {\n      var d = i - this.getSum(o, r, s);\n      this.adjustSize(d, o, r, s), this.adjustSize(-d, o, s + 1), a.full_width = this.getSum(o);\n    }\n  }, splitSize: function(i, a) {\n    for (var r = [], s = 0; s < a; s++) r[s] = 0;\n    return this.adjustSize(i, r), r;\n  }, adjustSize: function(i, a, r, s) {\n    r || (r = 0), s === void 0 && (s = a.length - 1);\n    for (var o = s - r + 1, l = this.getSum(a, r, s), d = r; d <= s; d++) {\n      var c = Math.floor(i * (l ? a[d] / l : 1 / o));\n      l -= a[d], i -= c, o--, a[d] += c;\n    }\n    a[a.length - 1] += i;\n  }, sortScales: function(i) {\n    function a(s, o) {\n      var l = new Date(1970, 0, 1);\n      return e.add(l, o, s) - l;\n    }\n    i.sort(function(s, o) {\n      return a(s.unit, s.step) < a(o.unit, o.step) ? 1 : a(s.unit, s.step) > a(o.unit, o.step) ? -1 : 0;\n    });\n    for (var r = 0; r < i.length; r++) i[r].index = r;\n  }, _isLegacyMode: function(i) {\n    var a = i || t.config;\n    return a.scale_unit || a.date_scale || a.subscales;\n  }, _prepareScaleObject: function(i) {\n    var a = i.format;\n    return a || (a = i.template || i.date || \"%d %M\"), typeof a == \"string\" && (a = t.date.date_to_str(a)), { unit: i.unit || \"day\", step: i.step || 1, format: a, css: i.css };\n  }, primaryScale: function(i) {\n    var a, r = n.getService(\"templateLoader\"), s = this._isLegacyMode(i), o = i || t.config;\n    if (s) r.initTemplate(\"date_scale\", void 0, void 0, o, t.config.templates), a = { unit: t.config.scale_unit, step: t.config.step, template: t.templates.date_scale, date: t.config.date_scale, css: t.templates.scale_cell_class };\n    else {\n      var l = o.scales[0];\n      a = { unit: l.unit, step: l.step, template: l.template, format: l.format, date: l.date, css: l.css || t.templates.scale_cell_class };\n    }\n    return this._prepareScaleObject(a);\n  }, getSubScales: function(i) {\n    var a, r = this._isLegacyMode(i), s = i || t.config;\n    if (r) {\n      let o = \"https://docs.dhtmlx.com/gantt/migrating.html#:~:text=%3D%20false%3B-,Time%20scale%20settings,-Configuration%20of%20time\";\n      t.env.isFF && (o = \"https://docs.dhtmlx.com/gantt/migrating.html#6162\"), console.warn(`You are using the obsolete scale configuration.\nIt will stop working in the future versions.\nPlease migrate the configuration to the newer version:\n${o}`), a = s.subscales || [];\n    } else a = s.scales.slice(1);\n    return a.map((function(o) {\n      return this._prepareScaleObject(o);\n    }).bind(this));\n  }, prepareConfigs: function(i, a, r, s, o, l, d) {\n    for (var c = this.splitSize(s, i.length), u = r, h = [], g = i.length - 1; g >= 0; g--) {\n      var p = g == i.length - 1, y = this.initScaleConfig(i[g], o, l);\n      p && this.processIgnores(y), this.initColSizes(y, a, u, c[g]), this.limitVisibleRange(y), p && (u = y.full_width), h.unshift(y);\n    }\n    for (g = 0; g < h.length - 1; g++) this.alineScaleColumns(h[h.length - 1], h[g]);\n    for (g = 0; g < h.length; g++) d && this.reverseScale(h[g]), this.setPosSettings(h[g]);\n    return h;\n  }, reverseScale: function(i) {\n    i.width = i.width.reverse(), i.trace_x = i.trace_x.reverse();\n    var a = i.trace_indexes;\n    i.trace_indexes = {}, i.trace_index_transition = {}, i.rtl = !0;\n    for (var r = 0; r < i.trace_x.length; r++) i.trace_indexes[i.trace_x[r].valueOf()] = r, i.trace_index_transition[a[i.trace_x[r].valueOf()]] = r;\n    return i;\n  }, setPosSettings: function(i) {\n    for (var a = 0, r = i.trace_x.length; a < r; a++) i.left.push((i.width[a - 1] || 0) + (i.left[a - 1] || 0));\n  }, _ignore_time_config: function(i, a) {\n    if (t.config.skip_off_time) {\n      for (var r = !0, s = i, o = 0; o < a.step; o++) o && (s = e.add(i, o, a.unit)), r = r && !this.isWorkTime(s, a.unit);\n      return r;\n    }\n    return !1;\n  }, processIgnores: function(i) {\n    i.ignore_x = {}, i.display_count = i.count;\n  }, initColSizes: function(i, a, r, s) {\n    var o = r;\n    i.height = s;\n    var l = i.display_count === void 0 ? i.count : i.display_count;\n    l || (l = 1), i.col_width = Math.floor(o / l), a && i.col_width < a && (i.col_width = a, o = i.col_width * l), i.width = [];\n    for (var d = i.ignore_x || {}, c = 0; c < i.trace_x.length; c++) if (d[i.trace_x[c].valueOf()] || i.display_count == i.count) i.width[c] = 0;\n    else {\n      var u = 1;\n      i.unit == \"month\" && (u = Math.round((e.add(i.trace_x[c], i.step, i.unit) - i.trace_x[c]) / 864e5)), i.width[c] = u;\n    }\n    this.adjustSize(o - this.getSum(i.width), i.width), i.full_width = this.getSum(i.width);\n  }, initScaleConfig: function(i, a, r) {\n    var s = P({ count: 0, col_width: 0, full_width: 0, height: 0, width: [], left: [], trace_x: [], trace_indexes: {}, min_date: new Date(a), max_date: new Date(r) }, i);\n    return this.eachColumn(i.unit, i.step, a, r, function(o) {\n      s.count++, s.trace_x.push(new Date(o)), s.trace_indexes[o.valueOf()] = s.trace_x.length - 1;\n    }), s.trace_x_ascending = s.trace_x.slice(), s;\n  }, iterateScales: function(i, a, r, s, o) {\n    for (var l = a.trace_x, d = i.trace_x, c = r || 0, u = s || d.length - 1, h = 0, g = 1; g < l.length; g++) {\n      var p = i.trace_indexes[+l[g]];\n      p !== void 0 && p <= u && (o && o.apply(this, [h, g, c, p]), c = p, h = g);\n    }\n  }, alineScaleColumns: function(i, a, r, s) {\n    this.iterateScales(i, a, r, s, function(o, l, d, c) {\n      var u = this.getSum(i.width, d, c - 1);\n      this.getSum(a.width, o, l - 1) != u && this.setSumWidth(u, a, o, l - 1);\n    });\n  }, eachColumn: function(i, a, r, s, o) {\n    var l = new Date(r), d = new Date(s);\n    e[i + \"_start\"] && (l = e[i + \"_start\"](l));\n    var c = new Date(l);\n    for (+c >= +d && (d = e.add(c, a, i)); +c < +d; ) {\n      o.call(this, new Date(c));\n      var u = c.getTimezoneOffset();\n      c = e.add(c, a, i), c = t._correct_dst_change(c, u, a, i), e[i + \"_start\"] && (c = e[i + \"_start\"](c));\n    }\n  }, limitVisibleRange: function(i) {\n    var a = i.trace_x, r = i.width.length - 1, s = 0;\n    if (+a[0] < +i.min_date && r != 0) {\n      var o = Math.floor(i.width[0] * ((a[1] - i.min_date) / (a[1] - a[0])));\n      s += i.width[0] - o, i.width[0] = o, a[0] = new Date(i.min_date);\n    }\n    var l = a.length - 1, d = a[l], c = e.add(d, i.step, i.unit);\n    if (+c > +i.max_date && l > 0 && (o = i.width[l] - Math.floor(i.width[l] * ((c - i.max_date) / (c - d))), s += i.width[l] - o, i.width[l] = o), s) {\n      for (var u = this.getSum(i.width), h = 0, g = 0; g < i.width.length; g++) {\n        var p = Math.floor(s * (i.width[g] / u));\n        i.width[g] += p, h += p;\n      }\n      this.adjustSize(s - h, i.width);\n    }\n  } };\n}\nfunction ti(t) {\n  var e = function(c) {\n    var u = new pe(c).primaryScale(), h = u.unit, g = u.step;\n    if (c.config.scale_offset_minimal) {\n      var p = new pe(c), y = [p.primaryScale()].concat(p.getSubScales());\n      p.sortScales(y), h = y[y.length - 1].unit, g = y[y.length - 1].step || 1;\n    }\n    return { unit: h, step: g };\n  }(t), n = e.unit, i = e.step, a = function(c, u) {\n    var h = { start_date: null, end_date: null };\n    if (u.config.start_date && u.config.end_date) {\n      h.start_date = u.date[c + \"_start\"](new Date(u.config.start_date));\n      var g = new Date(u.config.end_date), p = u.date[c + \"_start\"](new Date(g));\n      g = +g != +p ? u.date.add(p, 1, c) : p, h.end_date = g;\n    }\n    return h;\n  }(n, t);\n  if (!a.start_date || !a.end_date) {\n    for (var r = !0, s = t.getTaskByTime(), o = 0; o < s.length; o++)\n      if (s[o].type !== t.config.types.project) {\n        r = !1;\n        break;\n      }\n    if (s.length && r) {\n      var l = s[0].start_date, d = t.date.add(l, 1, t.config.duration_unit);\n      a = { start_date: new Date(l), end_date: new Date(d) };\n    } else a = t.getSubtaskDates();\n    a.start_date && a.end_date || (a = { start_date: /* @__PURE__ */ new Date(), end_date: /* @__PURE__ */ new Date() }), t.eachTask(function(c) {\n      t.config.deadlines && c.deadline && ie(a, c.deadline, c.deadline), c.constraint_date && c.constraint_type && t.config.constraint_types && c.constraint_type !== t.config.constraint_types.ASAP && c.constraint_type !== t.config.constraint_types.ALAP && ie(a, c.constraint_date, c.constraint_date), t.config.baselines && c.baselines && c.baselines.forEach(function(u) {\n        ie(a, u.start_date, u.end_date);\n      });\n    }), a.start_date = t.date[n + \"_start\"](a.start_date), a.start_date = t.calculateEndDate({ start_date: t.date[n + \"_start\"](a.start_date), duration: -1, unit: n, step: i }), a.end_date = t.date[n + \"_start\"](a.end_date), a.end_date = t.calculateEndDate({ start_date: a.end_date, duration: 2, unit: n, step: i });\n  }\n  t._min_date = a.start_date, t._max_date = a.end_date;\n}\nfunction ie(t, e, n) {\n  e < t.start_date && (t.start_date = new Date(e)), n > t.end_date && (t.end_date = new Date(n));\n}\nfunction me(t) {\n  ti(t), function(e) {\n    if (e.config.fit_tasks) {\n      var n = +e._min_date, i = +e._max_date;\n      if (+e._min_date != n || +e._max_date != i) return e.render(), e.callEvent(\"onScaleAdjusted\", []), !0;\n    }\n  }(t);\n}\nfunction Re(t, e, n) {\n  for (var i = 0; i < e.length; i++) t.isLinkExists(e[i]) && (n[e[i]] = t.getLink(e[i]));\n}\nfunction He(t, e, n) {\n  Re(t, e.$source, n), Re(t, e.$target, n);\n}\nconst ve = { getSubtreeLinks: function(t, e) {\n  var n = {};\n  return t.isTaskExists(e) && He(t, t.getTask(e), n), t.eachTask(function(i) {\n    He(t, i, n);\n  }, e), n;\n}, getSubtreeTasks: function(t, e) {\n  var n = {};\n  return t.eachTask(function(i) {\n    n[i.id] = i;\n  }, e), n;\n} };\nclass ei {\n  constructor(e, n) {\n    this.$gantt = e, this.$dp = n, this._dataProcessorHandlers = [];\n  }\n  attach() {\n    const e = this.$dp, n = this.$gantt, i = {}, a = (o) => this.clientSideDelete(o, e, n);\n    this._dataProcessorHandlers.push(n.attachEvent(\"onAfterTaskAdd\", function(o, l) {\n      n.isTaskExists(o) && (e.setGanttMode(\"tasks\"), e.setUpdated(o, !0, \"inserted\"));\n    })), this._dataProcessorHandlers.push(n.attachEvent(\"onAfterTaskUpdate\", function(o, l) {\n      n.isTaskExists(o) && (e.setGanttMode(\"tasks\"), e.setUpdated(o, !0), n._sendTaskOrder && n._sendTaskOrder(o, l));\n    })), this._dataProcessorHandlers.push(n.attachEvent(\"onBeforeTaskDelete\", function(o, l) {\n      return n.config.cascade_delete && (i[o] = { tasks: ve.getSubtreeTasks(n, o), links: ve.getSubtreeLinks(n, o) }), !e.deleteAfterConfirmation || (e.setGanttMode(\"tasks\"), e.setUpdated(o, !0, \"deleted\"), !1);\n    })), this._dataProcessorHandlers.push(n.attachEvent(\"onAfterTaskDelete\", function(o, l) {\n      e.setGanttMode(\"tasks\");\n      const d = !a(o), c = n.config.cascade_delete && i[o];\n      if (d || c) {\n        if (c) {\n          const u = e.updateMode;\n          e.setUpdateMode(\"off\");\n          const h = i[o];\n          for (const g in h.tasks) a(g) || (e.storeItem(h.tasks[g]), e.setUpdated(g, !0, \"deleted\"));\n          e.setGanttMode(\"links\");\n          for (const g in h.links) a(g) || (e.storeItem(h.links[g]), e.setUpdated(g, !0, \"deleted\"));\n          i[o] = null, u !== \"off\" && e.sendAllData(), e.setGanttMode(\"tasks\"), e.setUpdateMode(u);\n        }\n        d && (e.storeItem(l), e.deleteAfterConfirmation || e.setUpdated(o, !0, \"deleted\")), e.updateMode === \"off\" || e._tSend || e.sendAllData();\n      }\n    })), this._dataProcessorHandlers.push(n.attachEvent(\"onAfterLinkUpdate\", function(o, l) {\n      n.isLinkExists(o) && (e.setGanttMode(\"links\"), e.setUpdated(o, !0));\n    })), this._dataProcessorHandlers.push(n.attachEvent(\"onAfterLinkAdd\", function(o, l) {\n      n.isLinkExists(o) && (e.setGanttMode(\"links\"), e.setUpdated(o, !0, \"inserted\"));\n    })), this._dataProcessorHandlers.push(n.attachEvent(\"onAfterLinkDelete\", function(o, l) {\n      e.setGanttMode(\"links\"), !a(o) && (e.storeItem(l), e.setUpdated(o, !0, \"deleted\"));\n    })), this._dataProcessorHandlers.push(n.attachEvent(\"onRowDragEnd\", function(o, l) {\n      n._sendTaskOrder(o, n.getTask(o));\n    }));\n    let r = null, s = null;\n    this._dataProcessorHandlers.push(n.attachEvent(\"onTaskIdChange\", function(o, l) {\n      if (!e._waitMode) return;\n      const d = n.getChildren(l);\n      if (d.length) {\n        r = r || {};\n        for (let u = 0; u < d.length; u++) {\n          const h = this.getTask(d[u]);\n          r[h.id] = h;\n        }\n      }\n      const c = function(u) {\n        let h = [];\n        return u.$source && (h = h.concat(u.$source)), u.$target && (h = h.concat(u.$target)), h;\n      }(this.getTask(l));\n      if (c.length) {\n        s = s || {};\n        for (let u = 0; u < c.length; u++) {\n          const h = this.getLink(c[u]);\n          s[h.id] = h;\n        }\n      }\n    })), e.attachEvent(\"onAfterUpdateFinish\", function() {\n      (r || s) && (n.batchUpdate(function() {\n        for (const o in r) n.updateTask(r[o].id);\n        for (const o in s) n.updateLink(s[o].id);\n        r = null, s = null;\n      }), r ? n._dp.setGanttMode(\"tasks\") : n._dp.setGanttMode(\"links\"));\n    }), e.attachEvent(\"onBeforeDataSending\", function() {\n      if (this._tMode === \"CUSTOM\") return !0;\n      let o = this._serverProcessor;\n      if (this._tMode === \"REST-JSON\" || this._tMode === \"REST\") {\n        const l = this._ganttMode;\n        o = o.substring(0, o.indexOf(\"?\") > -1 ? o.indexOf(\"?\") : o.length), this.serverProcessor = o + (o.slice(-1) === \"/\" ? \"\" : \"/\") + l;\n      } else {\n        const l = this._ganttMode + \"s\";\n        this.serverProcessor = o + n.ajax.urlSeparator(o) + \"gantt_mode=\" + l;\n      }\n      return !0;\n    }), e.attachEvent(\"insertCallback\", function(o, l, d, c) {\n      const u = o.data || n.xml._xmlNodeToJSON(o.firstChild), h = { add: n.addTask, isExist: n.isTaskExists };\n      c === \"links\" && (h.add = n.addLink, h.isExist = n.isLinkExists), h.isExist.call(n, l) || (u.id = l, h.add.call(n, u));\n    }), e.attachEvent(\"updateCallback\", function(o, l) {\n      const d = o.data || n.xml._xmlNodeToJSON(o.firstChild);\n      if (!n.isTaskExists(l)) return;\n      const c = n.getTask(l);\n      for (const u in d) {\n        let h = d[u];\n        switch (u) {\n          case \"id\":\n            continue;\n          case \"start_date\":\n          case \"end_date\":\n            h = n.defined(n.templates.xml_date) ? n.templates.xml_date(h) : n.templates.parse_date(h);\n            break;\n          case \"duration\":\n            c.end_date = n.calculateEndDate({ start_date: c.start_date, duration: h, task: c });\n        }\n        c[u] = h;\n      }\n      n.updateTask(l), n.refreshData();\n    }), e.attachEvent(\"deleteCallback\", function(o, l, d, c) {\n      const u = { delete: n.deleteTask, isExist: n.isTaskExists };\n      c === \"links\" ? (u.delete = n.deleteLink, u.isExist = n.isLinkExists) : c === \"assignment\" && (u.delete = function(h) {\n        n.$data.assignmentsStore.remove(h);\n      }, u.isExist = function(h) {\n        return n.$data.assignmentsStore.exists(h);\n      }), u.isExist.call(n, l) && u.delete.call(n, l);\n    }), this.handleResourceCRUD(e, n), this.handleResourceAssignmentCRUD(e, n), this.handleBaselineCRUD(e, n);\n  }\n  clientSideDelete(e, n, i) {\n    const a = n.updatedRows.slice();\n    let r = !1;\n    i.getUserData(e, \"!nativeeditor_status\", n._ganttMode) === \"true_deleted\" && (r = !0, n.setUpdated(e, !1));\n    for (let s = 0; s < a.length && !n._in_progress[e]; s++) a[s] === e && (i.getUserData(e, \"!nativeeditor_status\", n._ganttMode) === \"inserted\" && (r = !0), n.setUpdated(e, !1));\n    return r;\n  }\n  handleResourceAssignmentCRUD(e, n) {\n    if (!n.config.resources || n.config.resources.dataprocessor_assignments !== !0) return;\n    const i = n.getDatastore(n.config.resource_assignment_store), a = {}, r = {};\n    function s(o) {\n      const l = o.id;\n      i.exists(l) && (e.setGanttMode(\"assignment\"), e.setUpdated(l, !0, \"inserted\")), delete r[l];\n    }\n    n.attachEvent(\"onBeforeTaskAdd\", function(o, l) {\n      return a[o] = !0, !0;\n    }), n.attachEvent(\"onTaskIdChange\", function(o, l) {\n      delete a[o];\n    }), i.attachEvent(\"onAfterAdd\", (o, l) => {\n      a[l.task_id] ? function(d) {\n        r[d.id] = d, a[d.task_id] = !0;\n      }(l) : s(l);\n    }), i.attachEvent(\"onAfterUpdate\", (o, l) => {\n      i.exists(o) && (r[o] ? s(l) : (e.setGanttMode(\"assignment\"), e.setUpdated(o, !0)));\n    }), i.attachEvent(\"onAfterDelete\", (o, l) => {\n      e.setGanttMode(\"assignment\"), !this.clientSideDelete(o, e, n) && (e.storeItem(l), e.setUpdated(o, !0, \"deleted\"));\n    });\n  }\n  handleResourceCRUD(e, n) {\n    if (!n.config.resources || n.config.resources.dataprocessor_resources !== !0) return;\n    const i = n.getDatastore(n.config.resource_store);\n    i.attachEvent(\"onAfterAdd\", (a, r) => {\n      (function(s) {\n        const o = s.id;\n        i.exists(o) && (e.setGanttMode(\"resource\"), e.setUpdated(o, !0, \"inserted\"));\n      })(r);\n    }), i.attachEvent(\"onAfterUpdate\", (a, r) => {\n      i.exists(a) && (e.setGanttMode(\"resource\"), e.setUpdated(a, !0));\n    }), i.attachEvent(\"onAfterDelete\", (a, r) => {\n      e.setGanttMode(\"resource\"), !this.clientSideDelete(a, e, n) && (e.storeItem(r), e.setUpdated(a, !0, \"deleted\"));\n    });\n  }\n  handleBaselineCRUD(e, n) {\n    if (!n.config.baselines || n.config.baselines.dataprocessor_baselines !== !0) return;\n    const i = n.getDatastore(n.config.baselines.datastore);\n    i.attachEvent(\"onAfterAdd\", (a, r) => {\n      (function(s) {\n        const o = s.id;\n        i.exists(o) && (e.setGanttMode(\"baseline\"), e.setUpdated(o, !0, \"inserted\"));\n      })(r);\n    }), i.attachEvent(\"onAfterUpdate\", (a, r) => {\n      i.exists(a) && (e.setGanttMode(\"baseline\"), e.setUpdated(a, !0));\n    }), i.attachEvent(\"onAfterDelete\", (a, r) => {\n      e.setGanttMode(\"baseline\"), !this.clientSideDelete(a, e, n) && (e.storeItem(r), e.setUpdated(a, !0, \"deleted\"));\n    });\n  }\n  detach() {\n    kt(this._dataProcessorHandlers, (e) => {\n      this.$gantt.detachEvent(e);\n    }), this._dataProcessorHandlers = [];\n  }\n}\nconst Xt = class Xt {\n  constructor() {\n    this.clear = () => {\n      this._storage = {};\n    }, this.storeItem = (e) => {\n      this._storage[e.id] = q(e);\n    }, this.getStoredItem = (e) => this._storage[e] || null, this._storage = {};\n  }\n};\nXt.create = () => new Xt();\nlet Jt = Xt, un = class {\n  constructor(t) {\n    this.serverProcessor = t, this.action_param = \"!nativeeditor_status\", this.updatedRows = [], this.autoUpdate = !0, this.updateMode = \"cell\", this._headers = null, this._payload = null, this._postDelim = \"_\", this._routerParametersFormat = \"parameters\", this._waitMode = 0, this._in_progress = {}, this._storage = Jt.create(), this._invalid = {}, this.messages = [], this.styles = { updated: \"font-weight:bold;\", inserted: \"font-weight:bold;\", deleted: \"text-decoration : line-through;\", invalid: \"background-color:FFE0E0;\", invalid_cell: \"border-bottom:2px solid red;\", error: \"color:red;\", clear: \"font-weight:normal;text-decoration:none;\" }, this.enableUTFencoding(!0), ot(this);\n  }\n  setTransactionMode(t, e) {\n    typeof t == \"object\" ? (this._tMode = t.mode || this._tMode, W(t.headers) && (this._headers = t.headers), W(t.payload) && (this._payload = t.payload), this._tSend = !!e) : (this._tMode = t, this._tSend = e), this._tMode === \"REST\" && (this._tSend = !1), this._tMode === \"JSON\" || this._tMode === \"REST-JSON\" ? (this._tSend = !1, this._serializeAsJson = !0, this._headers = this._headers || {}, this._headers[\"Content-Type\"] = \"application/json\") : this._headers && !this._headers[\"Content-Type\"] && (this._headers[\"Content-Type\"] = \"application/x-www-form-urlencoded\"), this._tMode === \"CUSTOM\" && (this._tSend = !1, this._router = t.router);\n  }\n  escape(t) {\n    return this._utf ? encodeURIComponent(t) : escape(t);\n  }\n  enableUTFencoding(t) {\n    this._utf = !!t;\n  }\n  getSyncState() {\n    return !this.updatedRows.length;\n  }\n  setUpdateMode(t, e) {\n    this.autoUpdate = t === \"cell\", this.updateMode = t, this.dnd = e;\n  }\n  ignore(t, e) {\n    this._silent_mode = !0, t.call(e || dt), this._silent_mode = !1;\n  }\n  setUpdated(t, e, n) {\n    if (this._silent_mode) return;\n    const i = this.findRow(t);\n    n = n || \"updated\";\n    const a = this.$gantt.getUserData(t, this.action_param, this._ganttMode);\n    a && n === \"updated\" && (n = a), e ? (this.set_invalid(t, !1), this.updatedRows[i] = t, this.$gantt.setUserData(t, this.action_param, n, this._ganttMode), this._in_progress[t] && (this._in_progress[t] = \"wait\")) : this.is_invalid(t) || (this.updatedRows.splice(i, 1), this.$gantt.setUserData(t, this.action_param, \"\", this._ganttMode)), this.markRow(t, e, n), e && this.autoUpdate && this.sendData(t);\n  }\n  markRow(t, e, n) {\n    let i = \"\";\n    const a = this.is_invalid(t);\n    if (a && (i = this.styles[a], e = !0), this.callEvent(\"onRowMark\", [t, e, n, a]) && (i = this.styles[e ? n : \"clear\"] + \" \" + i, this.$gantt[this._methods[0]](t, i), a && a.details)) {\n      i += this.styles[a + \"_cell\"];\n      for (let r = 0; r < a.details.length; r++) a.details[r] && this.$gantt[this._methods[1]](t, r, i);\n    }\n  }\n  getActionByState(t) {\n    return t === \"inserted\" ? \"create\" : t === \"updated\" ? \"update\" : t === \"deleted\" ? \"delete\" : \"update\";\n  }\n  getState(t) {\n    return this.$gantt.getUserData(t, this.action_param, this._ganttMode);\n  }\n  is_invalid(t) {\n    return this._invalid[t];\n  }\n  set_invalid(t, e, n) {\n    n && (e = { value: e, details: n, toString: function() {\n      return this.value.toString();\n    } }), this._invalid[t] = e;\n  }\n  checkBeforeUpdate(t) {\n    return !0;\n  }\n  sendData(t) {\n    if (this.$gantt.editStop && this.$gantt.editStop(), t === void 0 || this._tSend) {\n      const e = [];\n      if (this.modes && [\"task\", \"link\", \"assignment\", \"baseline\"].forEach((n) => {\n        this.modes[n] && this.modes[n].updatedRows.length && e.push(n);\n      }), e.length) {\n        for (let n = 0; n < e.length; n++) this.setGanttMode(e[n]), this.sendAllData();\n        return;\n      }\n      return this.sendAllData();\n    }\n    return !this._in_progress[t] && (this.messages = [], !(!this.checkBeforeUpdate(t) && this.callEvent(\"onValidationError\", [t, this.messages])) && void this._beforeSendData(this._getRowData(t), t));\n  }\n  serialize(t, e) {\n    if (this._serializeAsJson) return this._serializeAsJSON(t);\n    if (typeof t == \"string\") return t;\n    if (e !== void 0) return this.serialize_one(t, \"\");\n    {\n      const n = [], i = [];\n      for (const a in t) t.hasOwnProperty(a) && (n.push(this.serialize_one(t[a], a + this._postDelim)), i.push(a));\n      return n.push(\"ids=\" + this.escape(i.join(\",\"))), this.$gantt.security_key && n.push(\"dhx_security=\" + this.$gantt.security_key), n.join(\"&\");\n    }\n  }\n  serialize_one(t, e) {\n    if (typeof t == \"string\") return t;\n    const n = [];\n    let i = \"\";\n    for (const a in t) if (t.hasOwnProperty(a)) {\n      if ((a === \"id\" || a == this.action_param) && this._tMode === \"REST\") continue;\n      i = typeof t[a] == \"string\" || typeof t[a] == \"number\" ? String(t[a]) : JSON.stringify(t[a]), n.push(this.escape((e || \"\") + a) + \"=\" + this.escape(i));\n    }\n    return n.join(\"&\");\n  }\n  sendAllData() {\n    if (!this.updatedRows.length) return;\n    this.messages = [];\n    let t = !0;\n    if (this._forEachUpdatedRow(function(e) {\n      t = t && this.checkBeforeUpdate(e);\n    }), !t && !this.callEvent(\"onValidationError\", [\"\", this.messages])) return !1;\n    this._tSend ? this._sendData(this._getAllData()) : this._forEachUpdatedRow(function(e) {\n      if (!this._in_progress[e]) {\n        if (this.is_invalid(e)) return;\n        this._beforeSendData(this._getRowData(e), e);\n      }\n    });\n  }\n  findRow(t) {\n    let e = 0;\n    for (e = 0; e < this.updatedRows.length && t != this.updatedRows[e]; e++) ;\n    return e;\n  }\n  defineAction(t, e) {\n    this._uActions || (this._uActions = {}), this._uActions[t] = e;\n  }\n  afterUpdateCallback(t, e, n, i, a) {\n    if (!this.$gantt) return;\n    this.setGanttMode(a);\n    const r = t, s = n !== \"error\" && n !== \"invalid\";\n    if (s || this.set_invalid(t, n), this._uActions && this._uActions[n] && !this._uActions[n](i)) return delete this._in_progress[r];\n    this._in_progress[r] !== \"wait\" && this.setUpdated(t, !1);\n    const o = t;\n    switch (n) {\n      case \"inserted\":\n      case \"insert\":\n        e != t && (this.setUpdated(t, !1), this.$gantt[this._methods[2]](t, e), t = e);\n        break;\n      case \"delete\":\n      case \"deleted\":\n        if (this.deleteAfterConfirmation && this._ganttMode === \"task\") {\n          if (this._ganttMode === \"task\" && this.$gantt.isTaskExists(t)) {\n            this.$gantt.setUserData(t, this.action_param, \"true_deleted\", this._ganttMode);\n            const l = this.$gantt.getTask(t);\n            this.$gantt.silent(() => {\n              this.$gantt.deleteTask(t);\n            }), this.$gantt.callEvent(\"onAfterTaskDelete\", [t, l]), this.$gantt.render(), delete this._in_progress[r];\n          }\n          return this.callEvent(\"onAfterUpdate\", [t, n, e, i]);\n        }\n        return this.$gantt.setUserData(t, this.action_param, \"true_deleted\", this._ganttMode), this.$gantt[this._methods[3]](t), delete this._in_progress[r], this.callEvent(\"onAfterUpdate\", [t, n, e, i]);\n    }\n    this._in_progress[r] !== \"wait\" ? (s && this.$gantt.setUserData(t, this.action_param, \"\", this._ganttMode), delete this._in_progress[r]) : (delete this._in_progress[r], this.setUpdated(e, !0, this.$gantt.getUserData(t, this.action_param, this._ganttMode))), this.callEvent(\"onAfterUpdate\", [o, n, e, i]);\n  }\n  afterUpdate(t, e, n) {\n    let i;\n    i = arguments.length === 3 ? arguments[1] : arguments[4];\n    let a = this.getGanttMode();\n    const r = i.filePath || i.url;\n    a = this._tMode !== \"REST\" && this._tMode !== \"REST-JSON\" ? r.indexOf(\"gantt_mode=links\") !== -1 ? \"link\" : r.indexOf(\"gantt_mode=assignments\") !== -1 ? \"assignment\" : r.indexOf(\"gantt_mode=baselines\") !== -1 ? \"baseline\" : \"task\" : r.indexOf(\"/link\") >= 0 ? \"link\" : r.indexOf(\"/assignment\") >= 0 ? \"assignment\" : r.indexOf(\"/baseline\") >= 0 ? \"baseline\" : \"task\", this.setGanttMode(a);\n    const s = this.$gantt.ajax;\n    let o;\n    try {\n      o = JSON.parse(e.xmlDoc.responseText);\n    } catch {\n      e.xmlDoc.responseText.length || (o = {});\n    }\n    const l = (u) => {\n      const h = o.action || this.getState(u) || \"updated\", g = o.sid || u[0], p = o.tid || u[0];\n      t.afterUpdateCallback(g, p, h, o, a);\n    };\n    if (o) return Array.isArray(n) && n.length > 1 ? n.forEach((u) => l(u)) : l(n), t.finalizeUpdate(), void this.setGanttMode(a);\n    const d = s.xmltop(\"data\", e.xmlDoc);\n    if (!d) return this.cleanUpdate(n);\n    const c = s.xpath(\"//data/action\", d);\n    if (!c.length) return this.cleanUpdate(n);\n    for (let u = 0; u < c.length; u++) {\n      const h = c[u], g = h.getAttribute(\"type\"), p = h.getAttribute(\"sid\"), y = h.getAttribute(\"tid\");\n      t.afterUpdateCallback(p, y, g, h, a);\n    }\n    t.finalizeUpdate();\n  }\n  cleanUpdate(t) {\n    if (t) for (let e = 0; e < t.length; e++) delete this._in_progress[t[e]];\n  }\n  finalizeUpdate() {\n    this._waitMode && this._waitMode--, this.callEvent(\"onAfterUpdateFinish\", []), this.updatedRows.length || this.callEvent(\"onFullSync\", []);\n  }\n  init(t) {\n    if (this._initialized) return;\n    this.$gantt = t, this.$gantt._dp_init && this.$gantt._dp_init(this), this._setDefaultTransactionMode(), this.styles = { updated: \"gantt_updated\", order: \"gantt_updated\", inserted: \"gantt_inserted\", deleted: \"gantt_deleted\", delete_confirmation: \"gantt_deleted\", invalid: \"gantt_invalid\", error: \"gantt_error\", clear: \"\" }, this._methods = [\"_row_style\", \"setCellTextStyle\", \"_change_id\", \"_delete_task\"], function(n, i) {\n      n.getUserData = function(a, r, s) {\n        return this.userdata || (this.userdata = {}), this.userdata[s] = this.userdata[s] || {}, this.userdata[s][a] && this.userdata[s][a][r] ? this.userdata[s][a][r] : \"\";\n      }, n.setUserData = function(a, r, s, o) {\n        this.userdata || (this.userdata = {}), this.userdata[o] = this.userdata[o] || {}, this.userdata[o][a] = this.userdata[o][a] || {}, this.userdata[o][a][r] = s;\n      }, n._change_id = function(a, r) {\n        switch (this._dp._ganttMode) {\n          case \"task\":\n            this.changeTaskId(a, r);\n            break;\n          case \"link\":\n            this.changeLinkId(a, r);\n            break;\n          case \"assignment\":\n            this.$data.assignmentsStore.changeId(a, r);\n            break;\n          case \"resource\":\n            this.$data.resourcesStore.changeId(a, r);\n            break;\n          case \"baseline\":\n            this.$data.baselineStore.changeId(a, r);\n            break;\n          default:\n            throw new Error(`Invalid mode of the dataProcessor after database id is received: ${this._dp._ganttMode}, new id: ${r}`);\n        }\n      }, n._row_style = function(a, r) {\n        this._dp._ganttMode === \"task\" && n.isTaskExists(a) && (n.getTask(a).$dataprocessor_class = r, n.refreshTask(a));\n      }, n._delete_task = function(a, r) {\n      }, n._sendTaskOrder = function(a, r) {\n        r.$drop_target && (this._dp.setGanttMode(\"task\"), this.getTask(a).target = r.$drop_target, this._dp.setUpdated(a, !0, \"order\"), delete this.getTask(a).$drop_target);\n      }, n.setDp = function() {\n        this._dp = i;\n      }, n.setDp();\n    }(this.$gantt, this);\n    const e = new ei(this.$gantt, this);\n    e.attach(), this.attachEvent(\"onDestroy\", function() {\n      delete this.setGanttMode, delete this._getRowData, delete this.$gantt._dp, delete this.$gantt._change_id, delete this.$gantt._row_style, delete this.$gantt._delete_task, delete this.$gantt._sendTaskOrder, delete this.$gantt, e.detach();\n    }), this.$gantt.callEvent(\"onDataProcessorReady\", [this]), this._initialized = !0;\n  }\n  setOnAfterUpdate(t) {\n    this.attachEvent(\"onAfterUpdate\", t);\n  }\n  setOnBeforeUpdateHandler(t) {\n    this.attachEvent(\"onBeforeDataSending\", t);\n  }\n  setAutoUpdate(t, e) {\n    t = t || 2e3, this._user = e || (/* @__PURE__ */ new Date()).valueOf(), this._needUpdate = !1, this._updateBusy = !1, this.attachEvent(\"onAfterUpdate\", this.afterAutoUpdate), this.attachEvent(\"onFullSync\", this.fullSync), setInterval(() => {\n      this.loadUpdate();\n    }, t);\n  }\n  afterAutoUpdate(t, e, n, i) {\n    return e !== \"collision\" || (this._needUpdate = !0, !1);\n  }\n  fullSync() {\n    return this._needUpdate && (this._needUpdate = !1, this.loadUpdate()), !0;\n  }\n  getUpdates(t, e) {\n    const n = this.$gantt.ajax;\n    if (this._updateBusy) return !1;\n    this._updateBusy = !0, n.get(t, e);\n  }\n  loadUpdate() {\n    const t = this.$gantt.ajax, e = this.$gantt.getUserData(0, \"version\", this._ganttMode);\n    let n = this.serverProcessor + t.urlSeparator(this.serverProcessor) + [\"dhx_user=\" + this._user, \"dhx_version=\" + e].join(\"&\");\n    n = n.replace(\"editing=true&\", \"\"), this.getUpdates(n, (i) => {\n      const a = t.xpath(\"//userdata\", i);\n      this.$gantt.setUserData(0, \"version\", this._getXmlNodeValue(a[0]), this._ganttMode);\n      const r = t.xpath(\"//update\", i);\n      if (r.length) {\n        this._silent_mode = !0;\n        for (let s = 0; s < r.length; s++) {\n          const o = r[s].getAttribute(\"status\"), l = r[s].getAttribute(\"id\"), d = r[s].getAttribute(\"parent\");\n          switch (o) {\n            case \"inserted\":\n              this.callEvent(\"insertCallback\", [r[s], l, d]);\n              break;\n            case \"updated\":\n              this.callEvent(\"updateCallback\", [r[s], l, d]);\n              break;\n            case \"deleted\":\n              this.callEvent(\"deleteCallback\", [r[s], l, d]);\n          }\n        }\n        this._silent_mode = !1;\n      }\n      this._updateBusy = !1;\n    });\n  }\n  destructor() {\n    this.callEvent(\"onDestroy\", []), this.detachAllEvents(), this.updatedRows = [], this._in_progress = {}, this._invalid = {}, this._storage.clear(), this._storage = null, this._headers = null, this._payload = null, delete this._initialized;\n  }\n  setGanttMode(t) {\n    t === \"tasks\" ? t = \"task\" : t === \"links\" && (t = \"link\");\n    const e = this.modes || {}, n = this.getGanttMode();\n    n && (e[n] = { _in_progress: this._in_progress, _invalid: this._invalid, _storage: this._storage, updatedRows: this.updatedRows });\n    let i = e[t];\n    i || (i = e[t] = { _in_progress: {}, _invalid: {}, _storage: Jt.create(), updatedRows: [] }), this._in_progress = i._in_progress, this._invalid = i._invalid, this._storage = i._storage, this.updatedRows = i.updatedRows, this.modes = e, this._ganttMode = t;\n  }\n  getGanttMode() {\n    return this._ganttMode;\n  }\n  storeItem(t) {\n    this._storage.storeItem(t);\n  }\n  url(t) {\n    this.serverProcessor = this._serverProcessor = t;\n  }\n  _beforeSendData(t, e) {\n    if (!this.callEvent(\"onBeforeUpdate\", [e, this.getState(e), t])) return !1;\n    this._sendData(t, e);\n  }\n  _serializeAsJSON(t) {\n    if (typeof t == \"string\") return t;\n    const e = q(t);\n    return this._tMode === \"REST-JSON\" && (delete e.id, delete e[this.action_param]), JSON.stringify(e);\n  }\n  _applyPayload(t) {\n    const e = this.$gantt.ajax;\n    if (this._payload) for (const n in this._payload) t = t + e.urlSeparator(t) + this.escape(n) + \"=\" + this.escape(this._payload[n]);\n    return t;\n  }\n  _cleanupArgumentsBeforeSend(t) {\n    let e;\n    if (t[this.action_param] === void 0) {\n      e = {};\n      for (const n in t) e[n] = this._cleanupArgumentsBeforeSend(t[n]);\n    } else e = this._cleanupItemBeforeSend(t);\n    return e;\n  }\n  _cleanupItemBeforeSend(t) {\n    let e = null;\n    return t && (t[this.action_param] === \"deleted\" ? (e = {}, e.id = t.id, e[this.action_param] = t[this.action_param]) : e = t), e;\n  }\n  _sendData(t, e) {\n    if (!t) return;\n    if (!this.callEvent(\"onBeforeDataSending\", e ? [e, this.getState(e), t] : [null, null, t])) return !1;\n    e && (this._in_progress[e] = (/* @__PURE__ */ new Date()).valueOf());\n    const n = this.$gantt.ajax;\n    if (this._tMode === \"CUSTOM\") {\n      const l = this.getState(e), d = this.getActionByState(l), c = this.getGanttMode(), u = (g) => {\n        let p = l || \"updated\", y = e, v = e;\n        g && (p = g.action || l, y = g.sid || y, v = g.id || g.tid || v), this.afterUpdateCallback(y, v, p, g, c);\n      };\n      let h;\n      if (this._router instanceof Function) if (this._routerParametersFormat === \"object\") {\n        const g = { entity: c, action: d, data: t, id: e };\n        h = this._router(g);\n      } else h = this._router(c, d, t, e);\n      else if (this._router[c] instanceof Function) h = this._router[c](d, t, e);\n      else {\n        const g = \"Incorrect configuration of gantt.createDataProcessor\", p = `\nYou need to either add missing properties to the dataProcessor router object or to use a router function.\nSee https://docs.dhtmlx.com/gantt/desktop__server_side.html#customrouting and https://docs.dhtmlx.com/gantt/api__gantt_createdataprocessor.html for details.`;\n        if (!this._router[c]) throw new Error(`${g}: router for the **${c}** entity is not defined. ${p}`);\n        switch (l) {\n          case \"inserted\":\n            if (!this._router[c].create) throw new Error(`${g}: **create** action for the **${c}** entity is not defined. ${p}`);\n            h = this._router[c].create(t);\n            break;\n          case \"deleted\":\n            if (!this._router[c].delete) throw new Error(`${g}: **delete** action for the **${c}** entity is not defined. ${p}`);\n            h = this._router[c].delete(e);\n            break;\n          default:\n            if (!this._router[c].update) throw new Error(`${g}: **update**\" action for the **${c}** entity is not defined. ${p}`);\n            h = this._router[c].update(t, e);\n        }\n      }\n      if (h) {\n        if (!h.then && h.id === void 0 && h.tid === void 0 && h.action === void 0) throw new Error(\"Incorrect router return value. A Promise or a response object is expected\");\n        h.then ? h.then(u).catch((g) => {\n          g && g.action ? u(g) : u({ action: \"error\", value: g });\n        }) : u(h);\n      } else u(null);\n      return;\n    }\n    let i;\n    i = { callback: (l) => {\n      const d = [];\n      if (e) d.push(e);\n      else if (t) for (const c in t) d.push(c);\n      return this.afterUpdate(this, l, d);\n    }, headers: this._headers };\n    const a = \"dhx_version=\" + this.$gantt.getUserData(0, \"version\", this._ganttMode), r = this.serverProcessor + (this._user ? n.urlSeparator(this.serverProcessor) + [\"dhx_user=\" + this._user, a].join(\"&\") : \"\");\n    let s, o = this._applyPayload(r);\n    switch (this._tMode) {\n      case \"GET\":\n        s = this._cleanupArgumentsBeforeSend(t), i.url = o + n.urlSeparator(o) + this.serialize(s, e), i.method = \"GET\";\n        break;\n      case \"POST\":\n        s = this._cleanupArgumentsBeforeSend(t), i.url = o, i.method = \"POST\", i.data = this.serialize(s, e);\n        break;\n      case \"JSON\":\n        s = {};\n        const l = this._cleanupItemBeforeSend(t);\n        for (const d in l) d !== this.action_param && d !== \"id\" && d !== \"gr_id\" && (s[d] = l[d]);\n        i.url = o, i.method = \"POST\", i.data = JSON.stringify({ id: e, action: t[this.action_param], data: s });\n        break;\n      case \"REST\":\n      case \"REST-JSON\":\n        switch (o = r.replace(/(&|\\?)editing=true/, \"\"), s = \"\", this.getState(e)) {\n          case \"inserted\":\n            i.method = \"POST\", i.data = this.serialize(t, e);\n            break;\n          case \"deleted\":\n            i.method = \"DELETE\", o = o + (o.slice(-1) === \"/\" ? \"\" : \"/\") + e;\n            break;\n          default:\n            i.method = \"PUT\", i.data = this.serialize(t, e), o = o + (o.slice(-1) === \"/\" ? \"\" : \"/\") + e;\n        }\n        i.url = this._applyPayload(o);\n    }\n    return this._waitMode++, n.query(i);\n  }\n  _forEachUpdatedRow(t) {\n    const e = this.updatedRows.slice();\n    for (let n = 0; n < e.length; n++) {\n      const i = e[n];\n      this.$gantt.getUserData(i, this.action_param, this._ganttMode) && t.call(this, i);\n    }\n  }\n  _setDefaultTransactionMode() {\n    this.serverProcessor && (this.setTransactionMode(\"POST\", !0), this.serverProcessor += (this.serverProcessor.indexOf(\"?\") !== -1 ? \"&\" : \"?\") + \"editing=true\", this._serverProcessor = this.serverProcessor);\n  }\n  _getXmlNodeValue(t) {\n    return t.firstChild ? t.firstChild.nodeValue : \"\";\n  }\n  _getAllData() {\n    const t = {};\n    let e = !1;\n    return this._forEachUpdatedRow(function(n) {\n      if (this._in_progress[n] || this.is_invalid(n)) return;\n      const i = this._getRowData(n);\n      this.callEvent(\"onBeforeUpdate\", [n, this.getState(n), i]) && (t[n] = i, e = !0, this._in_progress[n] = (/* @__PURE__ */ new Date()).valueOf());\n    }), e ? t : null;\n  }\n  _prepareDate(t) {\n    return this.$gantt.defined(this.$gantt.templates.xml_format) ? this.$gantt.templates.xml_format(t) : this.$gantt.templates.format_date(t);\n  }\n  _prepareArray(t, e) {\n    return e.push(t), t.map((n) => Z(n) ? this._prepareDate(n) : Array.isArray(n) && !zt(e, n) ? this._prepareArray(n, e) : n && typeof n == \"object\" && !zt(e, n) ? this._prepareObject(n, e) : n);\n  }\n  _prepareObject(t, e) {\n    const n = {};\n    e.push(t);\n    for (const i in t) {\n      if (i.substr(0, 1) === \"$\") continue;\n      const a = t[i];\n      Z(a) ? n[i] = this._prepareDate(a) : a === null ? n[i] = \"\" : Array.isArray(a) && !zt(e, a) ? n[i] = this._prepareArray(a, e) : a && typeof a == \"object\" && !zt(e, a) ? n[i] = this._prepareObject(a, e) : n[i] = a;\n    }\n    return n;\n  }\n  _prepareDataItem(t) {\n    const e = this._prepareObject(t, []);\n    return e[this.action_param] = this.$gantt.getUserData(t.id, this.action_param, this._ganttMode), e;\n  }\n  getStoredItem(t) {\n    return this._storage.getStoredItem(t);\n  }\n  _getRowData(t) {\n    let e;\n    const n = this.$gantt;\n    return this.getGanttMode() === \"task\" ? n.isTaskExists(t) && (e = this.$gantt.getTask(t)) : this.getGanttMode() === \"assignment\" ? this.$gantt.$data.assignmentsStore.exists(t) && (e = this.$gantt.$data.assignmentsStore.getItem(t)) : this.getGanttMode() === \"baseline\" ? this.$gantt.$data.baselineStore.exists(t) && (e = this.$gantt.$data.baselineStore.getItem(t)) : n.isLinkExists(t) && (e = this.$gantt.getLink(t)), e || (e = this.getStoredItem(t)), e || (e = { id: t }), this._prepareDataItem(e);\n  }\n};\nconst ni = function(t) {\n  return new un(t);\n}, ii = function(t) {\n  let e, n, i;\n  t instanceof Function ? e = t : t.hasOwnProperty(\"router\") ? e = t.router : t.hasOwnProperty(\"assignment\") || t.hasOwnProperty(\"baseline\") || t.hasOwnProperty(\"link\") || t.hasOwnProperty(\"task\") ? e = t : t.hasOwnProperty(\"headers\") && (i = t.headers), n = e ? \"CUSTOM\" : t.mode || \"REST-JSON\";\n  const a = new un(t.url);\n  return a.init(this), a.setTransactionMode({ mode: n, router: e, headers: i }, t.batchUpdate), t.deleteAfterConfirmation && (a.deleteAfterConfirmation = t.deleteAfterConfirmation), a;\n};\nfunction ai(t) {\n  var e = {}, n = !1;\n  function i(l, d) {\n    d = typeof d == \"function\" ? d : function() {\n    }, e[l] || (e[l] = this[l], this[l] = d);\n  }\n  function a(l) {\n    e[l] && (this[l] = e[l], e[l] = null);\n  }\n  function r(l) {\n    for (var d in l) i.call(this, d, l[d]);\n  }\n  function s() {\n    for (var l in e) a.call(this, l);\n  }\n  function o(l) {\n    try {\n      l();\n    } catch (d) {\n      dt.console.error(d);\n    }\n  }\n  return t.$services.getService(\"state\").registerProvider(\"batchUpdate\", function() {\n    return { batch_update: n };\n  }, !1), function(l, d) {\n    if (n) o(l);\n    else {\n      var c, u = this._dp && this._dp.updateMode != \"off\";\n      u && (c = this._dp.updateMode, this._dp.setUpdateMode(\"off\"));\n      var h = {}, g = { render: !0, refreshData: !0, refreshTask: !0, refreshLink: !0, resetProjectDates: function(y) {\n        h[y.id] = y;\n      } };\n      for (var p in r.call(this, g), n = !0, this.callEvent(\"onBeforeBatchUpdate\", []), o(l), this.callEvent(\"onAfterBatchUpdate\", []), s.call(this), h) this.resetProjectDates(h[p]);\n      n = !1, d || this.render(), u && (this._dp.setUpdateMode(c), this._dp.setGanttMode(\"task\"), this._dp.sendData(), this._dp.setGanttMode(\"link\"), this._dp.sendData());\n    }\n  };\n}\nfunction ri(t) {\n  t.batchUpdate = ai(t);\n}\nfunction si(t) {\n  const e = /* @__PURE__ */ function(i) {\n    return { _needRecalc: !0, reset: function() {\n      this._needRecalc = !0;\n    }, _isRecalcNeeded: function() {\n      return !this._isGroupSort() && this._needRecalc;\n    }, _isGroupSort: function() {\n      return !!i.getState().group_mode;\n    }, _getWBSCode: function(a) {\n      return a ? (this._isRecalcNeeded() && this._calcWBS(), a.$virtual ? \"\" : this._isGroupSort() ? a.$wbs || \"\" : (a.$wbs || (this.reset(), this._calcWBS()), a.$wbs)) : \"\";\n    }, _setWBSCode: function(a, r) {\n      a.$wbs = r;\n    }, getWBSCode: function(a) {\n      return this._getWBSCode(a);\n    }, getByWBSCode: function(a) {\n      let r = a.split(\".\"), s = i.config.root_id;\n      for (let o = 0; o < r.length; o++) {\n        const l = i.getChildren(s);\n        let d = 1 * r[o] - 1;\n        if (!i.isTaskExists(l[d])) return null;\n        s = l[d];\n      }\n      return i.isTaskExists(s) ? i.getTask(s) : null;\n    }, _calcWBS: function() {\n      if (!this._isRecalcNeeded()) return;\n      let a = !0;\n      i.eachTask(function(r) {\n        if (r.type == i.config.types.placeholder) return;\n        if (a) return a = !1, void this._setWBSCode(r, \"1\");\n        const s = this._getPrevNonPlaceholderSibling(r.id);\n        if (s !== null) this._increaseWBS(r, s);\n        else {\n          let o = i.getParent(r.id);\n          this._setWBSCode(r, i.getTask(o).$wbs + \".1\");\n        }\n      }, i.config.root_id, this), this._needRecalc = !1;\n    }, _increaseWBS: function(a, r) {\n      let s = i.getTask(r).$wbs;\n      s && (s = s.split(\".\"), s[s.length - 1]++, this._setWBSCode(a, s.join(\".\")));\n    }, _getPrevNonPlaceholderSibling: function(a) {\n      let r, s = a;\n      do\n        r = i.getPrevSibling(s), s = r;\n      while (r !== null && i.getTask(r).type == i.config.types.placeholder);\n      return r;\n    } };\n  }(t);\n  function n() {\n    return e.reset(), !0;\n  }\n  t.getWBSCode = function(i) {\n    return e.getWBSCode(i);\n  }, t.getTaskByWBSCode = function(i) {\n    return e.getByWBSCode(i);\n  }, t.attachEvent(\"onAfterTaskMove\", n), t.attachEvent(\"onBeforeParse\", n), t.attachEvent(\"onAfterTaskDelete\", n), t.attachEvent(\"onAfterTaskAdd\", n), t.attachEvent(\"onAfterSort\", n);\n}\nfunction oi(t) {\n  var e = {}, n = !1;\n  t.$data.tasksStore.attachEvent(\"onStoreUpdated\", function() {\n    e = {}, n = !1;\n  }), t.attachEvent(\"onBeforeGanttRender\", function() {\n    e = {};\n  });\n  var i = String(Math.random());\n  function a(l) {\n    return l === null ? i + String(l) : String(l);\n  }\n  function r(l, d, c) {\n    return Array.isArray(l) ? l.map(function(u) {\n      return a(u);\n    }).join(\"_\") + `_${d}_${c}` : a(l) + `_${d}_${c}`;\n  }\n  function s(l, d, c) {\n    var u, h = r(d, l, JSON.stringify(c)), g = {};\n    return kt(d, function(p) {\n      g[a(p)] = !0;\n    }), e[h] ? u = e[h] : (u = e[h] = [], t.eachTask(function(p) {\n      if (c) {\n        if (!c[t.getTaskType(p)]) return;\n      } else if (p.type == t.config.types.project) return;\n      l in p && kt(fe(p[l]) ? p[l] : [p[l]], function(y) {\n        var v = y && y.resource_id ? y.resource_id : y;\n        if (g[a(v)]) u.push(p);\n        else if (!n) {\n          var b = r(y, l);\n          e[b] || (e[b] = []), e[b].push(p);\n        }\n      });\n    }), n = !0), u;\n  }\n  function o(l, d, c) {\n    var u = t.config.resource_property, h = [];\n    if (t.getDatastore(\"task\").exists(d)) {\n      var g = t.getTask(d);\n      h = g[u] || [];\n    }\n    Array.isArray(h) || (h = [h]);\n    for (var p = 0; p < h.length; p++) h[p].resource_id == l && c.push({ task_id: g.id, resource_id: h[p].resource_id, value: h[p].value });\n  }\n  return { getTaskBy: function(l, d, c) {\n    return typeof l == \"function\" ? (u = l, h = [], t.eachTask(function(g) {\n      u(g) && h.push(g);\n    }), h) : fe(d) ? s(l, d, c) : s(l, [d], c);\n    var u, h;\n  }, getResourceAssignments: function(l, d) {\n    var c = [], u = t.config.resource_property;\n    return d !== void 0 ? o(l, d, c) : t.getTaskBy(u, l).forEach(function(h) {\n      o(l, h.id, c);\n    }), c;\n  } };\n}\nfunction li(t) {\n  var e = oi(t);\n  t.ext.resources = /* @__PURE__ */ function(a) {\n    const r = { renderEditableLabel: function(s, o, l, d, c) {\n      const u = a.config.readonly ? \"\" : \"contenteditable\";\n      if (s < l.end_date && o > l.start_date) {\n        for (let h = 0; h < c.length; h++) {\n          const g = c[h];\n          return \"<div \" + u + \" data-assignment-cell data-assignment-id='\" + g.id + \"' data-row-id='\" + l.id + \"' data-task='\" + l.$task_id + \"' data-start-date='\" + a.templates.format_date(s) + \"' data-end-date='\" + a.templates.format_date(o) + \"'>\" + g.value + \"</div>\";\n        }\n        return \"<div \" + u + \" data-assignment-cell data-empty  data-row-id='\" + l.id + \"' data-resource-id='\" + l.$resource_id + \"' data-task='\" + l.$task_id + \"' data-start-date='\" + a.templates.format_date(s) + \"''  data-end-date='\" + a.templates.format_date(o) + \"'>-</div>\";\n      }\n      return \"\";\n    }, renderSummaryLabel: function(s, o, l, d, c) {\n      let u = c.reduce(function(h, g) {\n        return h + Number(g.value);\n      }, 0);\n      return u % 1 && (u = Math.round(10 * u) / 10), u ? \"<div>\" + u + \"</div>\" : \"\";\n    }, editableResourceCellTemplate: function(s, o, l, d, c) {\n      return l.$role === \"task\" ? r.renderEditableLabel(s, o, l, d, c) : r.renderSummaryLabel(s, o, l, d, c);\n    }, editableResourceCellClass: function(s, o, l, d, c) {\n      const u = [];\n      u.push(\"resource_marker\"), l.$role === \"task\" ? u.push(\"task_cell\") : u.push(\"resource_cell\");\n      const h = c.reduce(function(p, y) {\n        return p + Number(y.value);\n      }, 0);\n      let g = Number(l.capacity);\n      return isNaN(g) && (g = 8), h <= g ? u.push(\"workday_ok\") : u.push(\"workday_over\"), u.join(\" \");\n    }, getSummaryResourceAssignments: function(s) {\n      let o;\n      const l = a.getDatastore(a.config.resource_store), d = l.getItem(s);\n      return d.$role === \"task\" ? o = a.getResourceAssignments(d.$resource_id, d.$task_id) : (o = a.getResourceAssignments(s), l.eachItem && l.eachItem(function(c) {\n        c.$role !== \"task\" && (o = o.concat(a.getResourceAssignments(c.id)));\n      }, s)), o;\n    }, initEditableDiagram: function() {\n      a.config.resource_render_empty_cells = !0, function() {\n        let l = null;\n        function d() {\n          return l && cancelAnimationFrame(l), l = requestAnimationFrame(function() {\n            a.$container && Array.prototype.slice.call(a.$container.querySelectorAll(\".resourceTimeline_cell [data-assignment-cell]\")).forEach(function(c) {\n              c.contentEditable = !0;\n            });\n          }), !0;\n        }\n        a.attachEvent(\"onGanttReady\", function() {\n          a.getDatastore(a.config.resource_assignment_store).attachEvent(\"onStoreUpdated\", d), a.getDatastore(a.config.resource_store).attachEvent(\"onStoreUpdated\", d);\n        }, { once: !0 }), a.attachEvent(\"onGanttLayoutReady\", function() {\n          a.$layout.getCellsByType(\"viewCell\").forEach(function(c) {\n            c.$config && c.$config.view === \"resourceTimeline\" && c.$content && c.$content.attachEvent(\"onScroll\", d);\n          });\n        });\n      }();\n      let s = null;\n      function o() {\n        setTimeout(function() {\n          const l = Lt(a.$container);\n          s > -1 && l[s + 1].focus();\n        }, 300);\n      }\n      a.attachEvent(\"onGanttReady\", function() {\n        let l = !1;\n        a.event(a.$container, \"keypress\", function(d) {\n          var c = d.target.closest(\".resourceTimeline_cell [data-assignment-cell]\");\n          c && (d.keyCode !== 13 && d.keyCode !== 27 || c.blur());\n        }), a.event(a.$container, \"keydown\", function(d) {\n          d.key === \"Tab\" && (s = Lt(a.$container).indexOf(document.activeElement));\n        }), a.event(a.$container, \"focusout\", function(d) {\n          if (!l) {\n            l = !0, setTimeout(function() {\n              l = !1;\n            }, 300);\n            var c = d.target.closest(\".resourceTimeline_cell [data-assignment-cell]\");\n            if (c) {\n              var u = (c.innerText || \"\").trim();\n              u == \"-\" && (u = \"0\");\n              var h = Number(u), g = c.getAttribute(\"data-row-id\"), p = c.getAttribute(\"data-assignment-id\"), y = c.getAttribute(\"data-task\"), v = c.getAttribute(\"data-resource-id\"), b = a.templates.parse_date(c.getAttribute(\"data-start-date\")), _ = a.templates.parse_date(c.getAttribute(\"data-end-date\")), m = a.getDatastore(a.config.resource_assignment_store);\n              if (isNaN(h)) a.getDatastore(a.config.resource_store).refresh(g);\n              else {\n                var f = a.getTask(y);\n                if (a.plugins().undo && a.ext.undo.saveState(y, \"task\"), p) {\n                  if (h === (x = m.getItem(p)).value) return;\n                  if (x.start_date.valueOf() === b.valueOf() && x.end_date.valueOf() === _.valueOf()) x.value = h, h ? m.updateItem(x.id) : m.removeItem(x.id);\n                  else {\n                    if (x.end_date.valueOf() > _.valueOf()) {\n                      var k = a.copy(x);\n                      k.id = a.uid(), k.start_date = _, k.duration = a.calculateDuration({ start_date: k.start_date, end_date: k.end_date, task: f }), k.delay = a.calculateDuration({ start_date: f.start_date, end_date: k.start_date, task: f }), k.mode = x.mode || \"default\", k.duration !== 0 && m.addItem(k);\n                    }\n                    x.start_date.valueOf() < b.valueOf() ? (x.end_date = b, x.duration = a.calculateDuration({ start_date: x.start_date, end_date: x.end_date, task: f }), x.mode = \"fixedDuration\", x.duration === 0 ? m.removeItem(x.id) : m.updateItem(x.id)) : m.removeItem(x.id), h && m.addItem({ task_id: x.task_id, resource_id: x.resource_id, value: h, start_date: b, end_date: _, duration: a.calculateDuration({ start_date: b, end_date: _, task: f }), delay: a.calculateDuration({ start_date: f.start_date, end_date: b, task: f }), mode: \"fixedDuration\" });\n                  }\n                  a.updateTaskAssignments(f.id), a.updateTask(f.id), o();\n                } else if (h) {\n                  var x = { task_id: y, resource_id: v, value: h, start_date: b, end_date: _, duration: a.calculateDuration({ start_date: b, end_date: _, task: f }), delay: a.calculateDuration({ start_date: f.start_date, end_date: b, task: f }), mode: \"fixedDuration\" };\n                  m.addItem(x), a.updateTaskAssignments(f.id), a.updateTask(f.id), o();\n                }\n              }\n            }\n          }\n        });\n      }, { once: !0 });\n    } };\n    return r;\n  }(t), t.config.resources = { dataprocessor_assignments: !1, dataprocessor_resources: !1, editable_resource_diagram: !1, resource_store: { type: \"treeDataStore\", fetchTasks: !1, initItem: function(a) {\n    return a.parent = a.parent || t.config.root_id, a[t.config.resource_property] = a.parent, a.open = !0, a;\n  } }, lightbox_resources: function(a) {\n    const r = [], s = t.getDatastore(t.config.resource_store);\n    return a.forEach(function(o) {\n      if (!s.hasChild(o.id)) {\n        const l = t.copy(o);\n        l.key = o.id, l.label = o.text, r.push(l);\n      }\n    }), r;\n  } }, t.attachEvent(\"onBeforeGanttReady\", function() {\n    if (t.getDatastore(t.config.resource_store)) return;\n    const a = t.config.resources ? t.config.resources.resource_store : void 0;\n    let r = a ? a.fetchTasks : void 0;\n    t.config.resources && t.config.resources.editable_resource_diagram && (r = !0);\n    let s = function(l) {\n      return l.parent = l.parent || t.config.root_id, l[t.config.resource_property] = l.parent, l.open = !0, l;\n    };\n    a && a.initItem && (s = a.initItem);\n    const o = a && a.type ? a.type : \"treeDatastore\";\n    t.$resourcesStore = t.createDatastore({ name: t.config.resource_store, type: o, fetchTasks: r !== void 0 && r, initItem: s }), t.$data.resourcesStore = t.$resourcesStore, t.$resourcesStore.attachEvent(\"onParse\", function() {\n      let l, d = function(c) {\n        const u = [];\n        return c.forEach(function(h) {\n          const g = t.copy(h);\n          g.key = h.id, g.label = h.text, u.push(g);\n        }), u;\n      };\n      t.config.resources && t.config.resources.lightbox_resources && (d = t.config.resources.lightbox_resources), t.config.resources && t.config.resources.editable_resource_diagram ? l = d(t.$resourcesStore.getItems().filter((c) => {\n        let u = t.getResourceAssignments(c.id);\n        if (!t.$resourcesStore.hasChild(c.id) || u && u.length) return !c.$resource_id || !c.$task_id;\n      })) : l = d(t.$resourcesStore.getItems()), t.updateCollection(\"resourceOptions\", l);\n    });\n  }), t.getTaskBy = e.getTaskBy, t.getResourceAssignments = e.getResourceAssignments, t.config.resource_property = \"owner_id\", t.config.resource_store = \"resource\", t.config.resource_render_empty_cells = !1, t.templates.histogram_cell_class = function(a, r, s, o, l) {\n  }, t.templates.histogram_cell_label = function(a, r, s, o, l) {\n    return o.length + \"/3\";\n  }, t.templates.histogram_cell_allocated = function(a, r, s, o, l) {\n    return o.length / 3;\n  }, t.templates.histogram_cell_capacity = function(a, r, s, o, l) {\n    return 0;\n  };\n  const n = function(a, r, s, o, l) {\n    return o.length <= 1 ? \"gantt_resource_marker_ok\" : \"gantt_resource_marker_overtime\";\n  }, i = function(a, r, s, o, l) {\n    return 8 * o.length;\n  };\n  t.templates.resource_cell_value = i, t.templates.resource_cell_class = n, t.attachEvent(\"onBeforeGanttReady\", function() {\n    t.config.resources && t.config.resources.editable_resource_diagram && (t.config.resource_render_empty_cells = !0, t.templates.resource_cell_value === i && (t.templates.resource_cell_value = t.ext.resources.editableResourceCellTemplate), t.templates.resource_cell_class === n && (t.templates.resource_cell_class = t.ext.resources.editableResourceCellClass), t.ext.resources.initEditableDiagram(t));\n  });\n}\nfunction di(t) {\n  var e = \"$resourceAssignments\";\n  t.config.resource_assignment_store = \"resourceAssignments\", t.config.process_resource_assignments = !0;\n  var n = \"auto\", i = \"singleValue\", a = \"valueArray\", r = \"resourceValueArray\", s = \"assignmentsArray\", o = n, l = \"fixedDates\", d = \"fixedDuration\", c = \"default\";\n  function u(f, k) {\n    f.start_date ? f.start_date = t.date.parseDate(f.start_date, \"parse_date\") : f.start_date = null, f.end_date ? f.end_date = t.date.parseDate(f.end_date, \"parse_date\") : f.end_date = null;\n    var x = Number(f.delay), $ = !1;\n    if (isNaN(x) ? (f.delay = 0, $ = !0) : f.delay = x, t.defined(f.value) || (f.value = null), !f.task_id || !f.resource_id) return !1;\n    if (f.mode = f.mode || c, f.mode === d && (isNaN(Number(f.duration)) && (k = k || t.getTask(f.task_id), f.duration = t.calculateDuration({ start_date: f.start_date, end_date: f.end_date, id: k })), $ && (k = k || t.getTask(f.task_id), f.delay = t.calculateDuration({ start_date: k.start_date, end_date: f.start_date, id: k }))), f.mode !== l && (k || t.isTaskExists(f.task_id))) {\n      var w = g(f, k = k || t.getTask(f.task_id));\n      f.start_date = w.start_date, f.end_date = w.end_date, f.duration = w.duration;\n    }\n  }\n  var h = t.createDatastore({ name: t.config.resource_assignment_store, initItem: function(f) {\n    return f.id || (f.id = t.uid()), u(f), f;\n  } });\n  function g(f, k) {\n    if (f.mode === l) return { start_date: f.start_date, end_date: f.end_date, duration: f.duration };\n    var x, $, w = f.delay ? t.calculateEndDate({ start_date: k.start_date, duration: f.delay, task: k }) : new Date(k.start_date);\n    return f.mode === d ? (x = t.calculateEndDate({ start_date: w, duration: f.duration, task: k }), $ = f.duration) : (x = new Date(k.end_date), $ = k.duration - f.delay), { start_date: w, end_date: x, duration: $ };\n  }\n  function p(f) {\n    const k = t.config.resource_property;\n    let x = f[k];\n    const $ = [];\n    let w = o === n;\n    if (t.defined(x) && x) {\n      Array.isArray(x) || (x = [x], w && (o = i, w = !1));\n      const S = {};\n      x.forEach(function(T) {\n        T.resource_id || (T = { resource_id: T }, w && (o = a, w = !1)), w && (T.id && T.resource_id ? (o = s, w = !1) : (o = r, w = !1));\n        let E, C = c;\n        T.mode || (T.start_date && T.end_date || T.start_date && T.duration) && (C = d), E = T.id || !T.$id || S[T.$id] ? T.id && !S[T.id] ? T.id : t.uid() : T.$id, S[E] = !0;\n        const D = { id: E, start_date: T.start_date, duration: T.duration, end_date: T.end_date, delay: T.delay, task_id: f.id, resource_id: T.resource_id, value: T.value, mode: T.mode || C };\n        Object.keys(T).forEach((M) => {\n          M != \"$id\" && (D[M] = T[M]);\n        }), D.start_date && D.start_date.getMonth && D.end_date && D.end_date.getMonth && typeof D.duration == \"number\" || u(D, f), $.push(D);\n      });\n    }\n    return $;\n  }\n  function y(f) {\n    if (t.isTaskExists(f)) {\n      var k = t.getTask(f);\n      v(k, t.getTaskAssignments(k.id));\n    }\n  }\n  function v(f, k) {\n    k.sort(function(x, $) {\n      return x.start_date && $.start_date && x.start_date.valueOf() != $.start_date.valueOf() ? x.start_date - $.start_date : 0;\n    }), o == s ? f[t.config.resource_property] = k : o == r && (f[t.config.resource_property] = k.map(function(x) {\n      return { $id: x.id, start_date: x.start_date, duration: x.duration, end_date: x.end_date, delay: x.delay, resource_id: x.resource_id, value: x.value, mode: x.mode };\n    })), f[e] = k;\n  }\n  function b(f) {\n    var k = p(f);\n    return k.forEach(function(x) {\n      x.id = x.id || t.uid();\n    }), k;\n  }\n  function _(f, k) {\n    var x = function($, w) {\n      var S = { inBoth: [], inTaskNotInStore: [], inStoreNotInTask: [] };\n      if (o == i) {\n        var T = $[0], E = T ? T.resource_id : null, C = !1;\n        w.forEach(function(A) {\n          A.resource_id != E ? S.inStoreNotInTask.push(A) : A.resource_id == E && (S.inBoth.push({ store: A, task: T }), C = !0);\n        }), !C && T && S.inTaskNotInStore.push(T);\n      } else if (o == a) {\n        var D = {}, M = {}, I = {};\n        $.forEach(function(A) {\n          D[A.resource_id] = A;\n        }), w.forEach(function(A) {\n          M[A.resource_id] = A;\n        }), $.concat(w).forEach(function(A) {\n          if (!I[A.resource_id]) {\n            I[A.resource_id] = !0;\n            var N = D[A.resource_id], L = M[A.resource_id];\n            N && L ? S.inBoth.push({ store: L, task: N }) : N && !L ? S.inTaskNotInStore.push(N) : !N && L && S.inStoreNotInTask.push(L);\n          }\n        });\n      } else o != s && o != r || (D = {}, M = {}, I = {}, $.forEach(function(A) {\n        D[A.id || A.$id] = A;\n      }), w.forEach(function(A) {\n        M[A.id] = A;\n      }), $.concat(w).forEach(function(A) {\n        var N = A.id || A.$id;\n        if (!I[N]) {\n          I[N] = !0;\n          var L = D[N], O = M[N];\n          L && O ? S.inBoth.push({ store: O, task: L }) : L && !O ? S.inTaskNotInStore.push(L) : !L && O && S.inStoreNotInTask.push(O);\n        }\n      }));\n      return S;\n    }(p(f), k);\n    x.inStoreNotInTask.forEach(function($) {\n      h.removeItem($.id);\n    }), x.inTaskNotInStore.forEach(function($) {\n      h.addItem($);\n    }), x.inBoth.forEach(function($) {\n      if (function(S, T) {\n        var E = { id: !0 };\n        for (var C in S) if (!E[C] && String(S[C]) !== String(T[C])) return !0;\n        return !1;\n      }($.task, $.store)) (function(S, T) {\n        var E = { id: !0 };\n        for (var C in S) E[C] || (T[C] = S[C]);\n      })($.task, $.store), h.updateItem($.store.id);\n      else if ($.task.start_date && $.task.end_date && $.task.mode !== l) {\n        var w = g($.store, f);\n        $.store.start_date.valueOf() == w.start_date.valueOf() && $.store.end_date.valueOf() == w.end_date.valueOf() || ($.store.start_date = w.start_date, $.store.end_date = w.end_date, $.store.duration = w.duration, h.updateItem($.store.id));\n      }\n    }), y(f.id);\n  }\n  function m(f) {\n    var k = f[e] || h.find(function(x) {\n      return x.task_id == f.id;\n    });\n    _(f, k);\n  }\n  t.$data.assignmentsStore = h, t.attachEvent(\"onGanttReady\", function() {\n    if (t.config.process_resource_assignments) {\n      t.attachEvent(\"onParse\", function() {\n        t.silent(function() {\n          h.clearAll();\n          var E = [];\n          t.eachTask(function(C) {\n            if (C.type !== t.config.types.project) {\n              var D = b(C);\n              v(C, D), D.forEach(function(M) {\n                E.push(M);\n              });\n            }\n          }), h.parse(E);\n        });\n      });\n      var f = !1, k = !1, x = {}, $ = !1;\n      t.attachEvent(\"onBeforeBatchUpdate\", function() {\n        f = !0;\n      }), t.attachEvent(\"onAfterBatchUpdate\", function() {\n        if (k) {\n          var E = {};\n          for (var C in x) E[C] = t.getTaskAssignments(x[C].id);\n          for (var C in t.config.process_resource_assignments && o === \"resourceValueArray\" && (T = null), x) _(x[C], E[C]);\n        }\n        k = !1, f = !1, x = {};\n      }), t.attachEvent(\"onTaskCreated\", function(E) {\n        var C = b(E);\n        return h.parse(C), v(E, C), !0;\n      }), t.attachEvent(\"onAfterTaskUpdate\", function(E, C) {\n        f ? (k = !0, x[E] = C) : C.unscheduled || m(C);\n      }), t.attachEvent(\"onAfterTaskAdd\", function(E, C) {\n        f ? (k = !0, x[E] = C) : m(C);\n      }), t.attachEvent(\"onRowDragEnd\", function(E) {\n        m(t.getTask(E));\n      }), t.$data.tasksStore.attachEvent(\"onAfterDeleteConfirmed\", function(E, C) {\n        var D, M = [E];\n        t.eachTask(function(I) {\n          M.push(I.id);\n        }, E), D = {}, M.forEach(function(I) {\n          D[I] = !0;\n        }), h.find(function(I) {\n          return D[I.task_id];\n        }).forEach(function(I) {\n          h.removeItem(I.id);\n        });\n      }), t.$data.tasksStore.attachEvent(\"onClearAll\", function() {\n        return w = null, S = null, T = null, h.clearAll(), !0;\n      }), t.attachEvent(\"onTaskIdChange\", function(E, C) {\n        h.find(function(D) {\n          return D.task_id == E;\n        }).forEach(function(D) {\n          D.task_id = C, h.updateItem(D.id);\n        }), y(C);\n      }), t.attachEvent(\"onBeforeUndo\", function(E) {\n        return $ = !0, !0;\n      }), t.attachEvent(\"onAfterUndo\", function(E) {\n        $ = !0;\n      });\n      var w = null, S = null, T = null;\n      h.attachEvent(\"onStoreUpdated\", function() {\n        return f && !$ || (w = null, S = null, T = null), !0;\n      }), t.getResourceAssignments = function(E, C) {\n        var D = t.defined(C) && C !== null;\n        return w === null && (w = {}, S = {}, h.eachItem(function(M) {\n          w[M.resource_id] || (w[M.resource_id] = []), w[M.resource_id].push(M);\n          var I = M.resource_id + \"-\" + M.task_id;\n          S[I] || (S[I] = []), S[I].push(M);\n        })), D ? (S[E + \"-\" + C] || []).slice() : (w[E] || []).slice();\n      }, t.getTaskAssignments = function(E) {\n        if (T === null) {\n          var C = [];\n          T = {}, h.eachItem(function(D) {\n            T[D.task_id] || (T[D.task_id] = []), T[D.task_id].push(D), D.task_id == E && C.push(D);\n          });\n        }\n        return (T[E] || []).slice();\n      }, t.getTaskResources = function(E) {\n        const C = t.getDatastore(\"resource\"), D = t.getTaskAssignments(E), M = {};\n        D.forEach(function(A) {\n          M[A.resource_id] || (M[A.resource_id] = A.resource_id);\n        });\n        const I = [];\n        for (const A in M) {\n          const N = C.getItem(M[A]);\n          N && I.push(N);\n        }\n        return I;\n      }, t.updateTaskAssignments = y;\n    }\n  }, { once: !0 });\n}\nfunction ci(t) {\n  function e(o) {\n    return function() {\n      return !t.config.placeholder_task || o.apply(this, arguments);\n    };\n  }\n  function n() {\n    var o = t.getTaskBy(\"type\", t.config.types.placeholder);\n    if (!o.length || !t.isTaskExists(o[0].id)) {\n      var l = { unscheduled: !0, type: t.config.types.placeholder, duration: 0, text: t.locale.labels.new_task };\n      if (t.callEvent(\"onTaskCreated\", [l]) === !1) return;\n      t.addTask(l);\n    }\n  }\n  function i(o) {\n    var l = t.getTask(o);\n    l.type == t.config.types.placeholder && (l.start_date && l.end_date && l.unscheduled && (l.unscheduled = !1), t.batchUpdate(function() {\n      var d = t.copy(l);\n      t.silent(function() {\n        t.deleteTask(l.id);\n      }), delete d[\"!nativeeditor_status\"], d.type = t.config.types.task, d.id = t.uid(), t.addTask(d);\n    }));\n  }\n  t.config.types.placeholder = \"placeholder\", t.attachEvent(\"onDataProcessorReady\", e(function(o) {\n    o && !o._silencedPlaceholder && (o._silencedPlaceholder = !0, o.attachEvent(\"onBeforeUpdate\", e(function(l, d, c) {\n      return c.type != t.config.types.placeholder || (o.setUpdated(l, !1), !1);\n    })));\n  }));\n  var a = !1;\n  function r(o) {\n    return !!(t.config.types.placeholder && t.isTaskExists(o) && t.getTask(o).type == t.config.types.placeholder);\n  }\n  function s(o) {\n    return !(!r(o.source) && !r(o.target));\n  }\n  t.attachEvent(\"onGanttReady\", function() {\n    a || (a = !0, t.attachEvent(\"onAfterTaskUpdate\", e(i)), t.attachEvent(\"onAfterTaskAdd\", e(function(o, l) {\n      l.type != t.config.types.placeholder && (t.getTaskBy(\"type\", t.config.types.placeholder).forEach(function(d) {\n        t.silent(function() {\n          t.isTaskExists(d.id) && t.deleteTask(d.id);\n        });\n      }), n());\n    })), t.attachEvent(\"onParse\", e(n)));\n  }), t.attachEvent(\"onLinkValidation\", function(o) {\n    return !s(o);\n  }), t.attachEvent(\"onBeforeLinkAdd\", function(o, l) {\n    return !s(l);\n  }), t.attachEvent(\"onBeforeUndoStack\", function(o) {\n    for (var l = 0; l < o.commands.length; l++) {\n      var d = o.commands[l];\n      d.entity === \"task\" && d.value.type === t.config.types.placeholder && (o.commands.splice(l, 1), l--);\n    }\n    return !0;\n  });\n}\nfunction ui(t) {\n  function e(c) {\n    return function() {\n      return !t.config.auto_types || t.getTaskType(t.config.types.project) != t.config.types.project || c.apply(this, arguments);\n    };\n  }\n  function n(c, u) {\n    var h = t.getTask(c), g = r(h);\n    g !== !1 && t.getTaskType(h) !== g && (u.$needsUpdate = !0, u[h.id] = { task: h, type: g });\n  }\n  function i(c) {\n    if (!t.getState().group_mode) {\n      var u = function(h, g) {\n        return n(h, g = g || {}), t.eachParent(function(p) {\n          n(p.id, g);\n        }, h), g;\n      }(c);\n      u.$needsUpdate && t.batchUpdate(function() {\n        (function(h) {\n          for (var g in h) if (h[g] && h[g].task) {\n            var p = h[g].task;\n            p.type = h[g].type, t.updateTask(p.id);\n          }\n        })(u);\n      });\n    }\n  }\n  var a;\n  function r(c) {\n    var u = t.config.types, h = t.hasChild(c.id), g = t.getTaskType(c.type);\n    return h && g === u.task ? u.project : !h && g === u.project && u.task;\n  }\n  var s, o, l = !0;\n  function d(c) {\n    c != t.config.root_id && t.isTaskExists(c) && i(c);\n  }\n  t.attachEvent(\"onParse\", e(function() {\n    l = !1, t.getState().group_mode || (t.batchUpdate(function() {\n      t.eachTask(function(c) {\n        var u = r(c);\n        u !== !1 && function(h, g) {\n          t.getState().group_mode || (h.type = g, t.updateTask(h.id));\n        }(c, u);\n      });\n    }), l = !0);\n  })), t.attachEvent(\"onAfterTaskAdd\", e(function(c) {\n    l && i(c);\n  })), t.attachEvent(\"onAfterTaskUpdate\", e(function(c) {\n    l && i(c);\n  })), t.attachEvent(\"onBeforeTaskDelete\", e(function(c, u) {\n    return a = t.getParent(c), !0;\n  })), t.attachEvent(\"onAfterTaskDelete\", e(function(c, u) {\n    d(a);\n  })), t.attachEvent(\"onRowDragStart\", e(function(c, u, h) {\n    return s = t.getParent(c), !0;\n  })), t.attachEvent(\"onRowDragEnd\", e(function(c, u) {\n    d(s), i(c);\n  })), t.attachEvent(\"onBeforeTaskMove\", e(function(c, u, h) {\n    return o = t.getParent(c), !0;\n  })), t.attachEvent(\"onAfterTaskMove\", e(function(c, u, h) {\n    document.querySelector(\".gantt_drag_marker\") || (d(o), i(c));\n  }));\n}\nconst Zt = class Zt {\n  constructor() {\n    this.canParse = (e) => !isNaN(this.parse(e)), this.format = (e) => String(e), this.parse = (e) => parseInt(e, 10);\n  }\n};\nZt.create = (e = null) => new Zt();\nlet Pt = Zt;\nconst Qt = class Qt {\n  constructor(e) {\n    this.format = (n) => this._getWBSCode(n.source), this.canParse = (n) => this._linkReg.test(n), this.parse = (n) => {\n      if (!this.canParse(n)) return null;\n      const i = this._linkReg.exec(n)[0].trim();\n      return { id: void 0, source: this._findSource(i) || null, target: null, type: this._gantt.config.links.finish_to_start, lag: 0 };\n    }, this._getWBSCode = (n) => {\n      const i = this._gantt.getTask(n);\n      return this._gantt.getWBSCode(i);\n    }, this._findSource = (n) => {\n      const i = new RegExp(\"^[0-9.]+\", \"i\");\n      if (i.exec(n)) {\n        const a = i.exec(n)[0], r = this._gantt.getTaskByWBSCode(a);\n        if (r) return r.id;\n      }\n      return null;\n    }, this._linkReg = /^[0-9\\.]+/, this._gantt = e;\n  }\n};\nQt.create = (e = null, n) => new Qt(n);\nlet ke = Qt;\nfunction hi(t) {\n  t.ext.formatters = { durationFormatter: function(e) {\n    return e || (e = {}), e.store || (e.store = t.config.duration_unit), e.enter || (e.enter = t.config.duration_unit), Pt.create(e, t);\n  }, linkFormatter: function(e) {\n    return ke.create(e, t);\n  } };\n}\nfunction _i(t) {\n  t.ext = t.ext || {}, t.config.show_empty_state = !1, t.ext.emptyStateElement = t.ext.emptyStateElement || { isEnabled: () => t.config.show_empty_state === !0, isGanttEmpty: () => !t.getTaskByTime().length, renderContent(e) {\n    const n = `<div class='gantt_empty_state'><div class='gantt_empty_state_image'></div>${`<div class='gantt_empty_state_text'>\n    <div class='gantt_empty_state_text_link' data-empty-state-create-task>${t.locale.labels.empty_state_text_link}</div>\n    <div class='gantt_empty_state_text_description'>${t.locale.labels.empty_state_text_description}</div>\n    </div>`}</div>`;\n    e.innerHTML = n;\n  }, clickEvents: [], attachAddTaskEvent() {\n    const e = t.attachEvent(\"onEmptyClick\", function(n) {\n      t.utils.dom.closest(n.target, \"[data-empty-state-create-task]\") && t.createTask({ id: t.uid(), text: \"New Task\" });\n    });\n    this.clickEvents.push(e);\n  }, detachAddTaskEvents() {\n    this.clickEvents.forEach(function(e) {\n      t.detachEvent(e);\n    }), this.clickEvents = [];\n  }, getContainer() {\n    if (t.$container) {\n      const e = t.utils.dom;\n      if (t.$container.contains(t.$grid_data)) return e.closest(t.$grid_data, \".gantt_layout_content\");\n      if (t.$container.contains(t.$task_data)) return e.closest(t.$task_data, \".gantt_layout_content\");\n    }\n    return null;\n  }, getNode() {\n    const e = this.getContainer();\n    return e ? e.querySelector(\".gantt_empty_state_wrapper\") : null;\n  }, show() {\n    const e = this.getContainer();\n    if (!e && this.isGanttEmpty()) return null;\n    const n = document.createElement(\"div\");\n    n.className = \"gantt_empty_state_wrapper\", n.style.marginTop = t.config.scale_height - e.offsetHeight + \"px\";\n    const i = t.$container.querySelectorAll(\".gantt_empty_state_wrapper\");\n    Array.prototype.forEach.call(i, function(a) {\n      a.parentNode.removeChild(a);\n    }), this.detachAddTaskEvents(), this.attachAddTaskEvent(), e.appendChild(n), this.renderContent(n);\n  }, hide() {\n    const e = this.getNode();\n    if (!e) return !1;\n    e.parentNode.removeChild(e);\n  }, init() {\n  } }, t.attachEvent(\"onDataRender\", function() {\n    const e = t.ext.emptyStateElement;\n    e.isEnabled() && e.isGanttEmpty() ? e.show() : e.hide();\n  });\n}\nconst hn = function(t, e) {\n  const n = e.baselines && e.baselines.length, i = t.config.baselines.render_mode == \"separateRow\" || t.config.baselines.render_mode == \"individualRow\";\n  if (n && i) return !0;\n}, $t = function(t) {\n  return t.render && t.render == \"split\" && !t.$open;\n};\nfunction gi(t) {\n  t.config.baselines = { datastore: \"baselines\", render_mode: !1, dataprocessor_baselines: !1, row_height: 16, bar_height: 8 };\n  const e = t.createDatastore({ name: t.config.baselines.datastore, initItem: function(a) {\n    return a.id || (a.id = t.uid()), function(r) {\n      if (!r.task_id || !r.start_date && !r.end_date) return !1;\n      r.start_date ? r.start_date = t.date.parseDate(r.start_date, \"parse_date\") : r.start_date = null, r.end_date ? r.end_date = t.date.parseDate(r.end_date, \"parse_date\") : r.end_date = null, r.duration = r.duration || 1, r.start_date && !r.end_date ? r.end_date = t.calculateEndDate(r.start_date, r.duration) : r.end_date && !r.start_date && (r.start_date = t.calculateEndDate(r.end_date, -r.duration));\n    }(a), a;\n  } });\n  function n(a) {\n    let r = 0;\n    t.adjustTaskHeightForBaselines(a), t.eachTask(function(s) {\n      let o = s.row_height || t.config.row_height;\n      r = r || o, o > r && (r = o);\n    }, a.id), a.row_height < r && (a.row_height = r);\n  }\n  function i(a) {\n    t.eachParent(function(r) {\n      if ($t(r)) {\n        const s = r.row_height || t.getLayoutView(\"timeline\").getBarHeight(r.id);\n        let o = a.row_height;\n        t.getChildren(r.id).forEach(function(l) {\n          const d = t.getTask(l);\n          if (d.id == a.id) return;\n          const c = d.row_height || t.getLayoutView(\"timeline\").getBarHeight(d.id);\n          o = o || c, c > o && (o = c);\n        }), r.row_height = o, r.bar_height = r.bar_height || s;\n      }\n    }, a.id);\n  }\n  t.$data.baselineStore = e, t.adjustTaskHeightForBaselines = function(a) {\n    let r, s, o = a.baselines && a.baselines.length || 0;\n    const l = t.config.baselines.row_height, d = t.getLayoutView(\"timeline\");\n    if (d && t.config.show_chart) switch (t.config.baselines.render_mode) {\n      case \"taskRow\":\n      default:\n        a.row_height = a.bar_height + 8;\n        break;\n      case \"separateRow\":\n        r = d.getBarHeight(a.id), o ? (a.bar_height = a.bar_height || r, a.bar_height > r && (r = a.bar_height), a.row_height = r + l) : a.bar_height && (a.row_height = a.bar_height + 4), i(a);\n        break;\n      case \"individualRow\":\n        r = d.getBarHeight(a.id), o ? (a.bar_height = a.bar_height || r, a.bar_height > r && (r = a.bar_height), s = l * o, a.row_height = r + s + 2) : a.bar_height && (a.row_height = a.bar_height + 4), i(a);\n    }\n  }, t.attachEvent(\"onGanttReady\", function() {\n    t.config.baselines && (t.attachEvent(\"onParse\", function() {\n      e.eachItem(function(a) {\n        const r = a.task_id;\n        if (t.isTaskExists(r)) {\n          const s = t.getTask(r);\n          s.baselines = s.baselines || [];\n          let o = !0;\n          for (let l = 0; l < s.baselines.length; l++) {\n            let d = s.baselines[l];\n            if (d.id == a.id) {\n              o = !1, t.mixin(d, a, !0);\n              break;\n            }\n          }\n          o && s.baselines.push(a), F(t) || ($t(s) ? n(s) : t.adjustTaskHeightForBaselines(s));\n        }\n      });\n    }), t.attachEvent(\"onBeforeTaskUpdate\", function(a, r) {\n      return function(s) {\n        let o = !1;\n        const l = {}, d = s.baselines || [], c = t.getTaskBaselines(s.id);\n        d.length != c.length && (o = !0), d.forEach(function(u) {\n          l[u.id] = !0;\n          const h = e.getItem(u.id);\n          if (h) {\n            const g = +h.start_date != +u.start_date, p = +h.end_date != +u.end_date;\n            (g || p) && e.updateItem(u.id, u);\n          } else e.addItem(u);\n        }), c.forEach(function(u) {\n          l[u.id] || e.removeItem(u.id);\n        }), o && ($t(s) ? n(s) : t.adjustTaskHeightForBaselines(s), t.render());\n      }(r), !0;\n    }), t.attachEvent(\"onAfterUndo\", function(a) {\n      if ((t.config.baselines.render_mode == \"separateRow\" || t.config.baselines.render_mode == \"individualRow\") && a) {\n        let r = !1;\n        a.commands.forEach(function(s) {\n          if (s.entity == \"task\") {\n            const o = s.value.id;\n            if (t.isTaskExists(o)) {\n              const l = t.getTask(o);\n              if (l.parent && t.isTaskExists(l.parent)) {\n                const d = t.getTask(l.parent);\n                $t(d) && (n(d), r = !0);\n              }\n            }\n          }\n        }), r && t.render();\n      }\n    }), t.attachEvent(\"onAfterTaskDelete\", function(a, r) {\n      if (hn && r.parent && t.isTaskExists(r.parent)) {\n        const s = t.getTask(r.parent);\n        $t(s) && n(s);\n      }\n      e.eachItem(function(s) {\n        t.isTaskExists(s.task_id) || e.removeItem(s.id);\n      });\n    }), t.getTaskBaselines = function(a) {\n      const r = [];\n      return e.eachItem(function(s) {\n        s.task_id == a && r.push(s);\n      }), r;\n    }, t.$data.baselineStore.attachEvent(\"onClearAll\", function() {\n      return t.eachTask(function(a) {\n        a.baselines && delete a.baselines;\n      }), !0;\n    }), t.$data.tasksStore.attachEvent(\"onClearAll\", function() {\n      return e.clearAll(), !0;\n    }), t.attachEvent(\"onTaskIdChange\", function(a, r) {\n      e.find(function(s) {\n        return s.task_id == a;\n      }).forEach(function(s) {\n        s.task_id = r, e.updateItem(s.id);\n      });\n    }));\n  }, { once: !0 });\n}\nfunction fi(t) {\n  function e(n) {\n    throw t.assert(!1, \"Can't parse data: incorrect value of gantt.parse or gantt.load method. Actual argument value: \" + JSON.stringify(n)), new Error(\"Invalid argument for gantt.parse or gantt.load. An object or a JSON string of format https://docs.dhtmlx.com/gantt/desktop__supported_data_formats.html#json is expected. Actual argument value: \" + JSON.stringify(n));\n  }\n  t.load = function() {\n    throw new Error(\"gantt.load() method is not available in the node.js, use gantt.parse() instead\");\n  }, t.parse = function(n, i) {\n    this.on_load({ xmlDoc: { responseText: n } }, i);\n  }, t.serialize = function(n) {\n    return this[n = n || \"json\"].serialize();\n  }, t.on_load = function(n, i) {\n    if (n.xmlDoc && n.xmlDoc.status === 404) this.assert(!1, \"Failed to load the data from <a href='\" + n.xmlDoc.responseURL + \"' target='_blank'>\" + n.xmlDoc.responseURL + \"</a>, server returns 404\");\n    else if (!t.$destroyed) {\n      this.callEvent(\"onBeforeParse\", []), i || (i = \"json\"), this.assert(this[i], \"Invalid data type:'\" + i + \"'\");\n      var a = n.xmlDoc.responseText, r = this[i].parse(a, n);\n      this._process_loading(r);\n    }\n  }, t._process_loading = function(n) {\n    n.collections && this._load_collections(n.collections), n.resources && this.$data.resourcesStore && this.$data.resourcesStore.parse(n.resources), t.config.baselines && n.baselines && this.$data.baselineStore && this.$data.baselineStore.parse(n.baselines);\n    const i = n.data || n.tasks;\n    n.assignments && function(r, s) {\n      const o = {};\n      s.forEach((l) => {\n        o[l.task_id] || (o[l.task_id] = []), o[l.task_id].push(l);\n      }), r.forEach((l) => {\n        l[t.config.resource_property] = o[l.id] || [];\n      });\n    }(i, n.assignments), this.$data.tasksStore.parse(i);\n    var a = n.links || (n.collections && n.collections.links ? n.collections.links : []);\n    this.$data.linksStore.parse(a), this.callEvent(\"onParse\", []), this.render();\n  }, t._load_collections = function(n) {\n    var i = !1;\n    for (var a in n) if (n.hasOwnProperty(a)) {\n      i = !0;\n      var r = n[a];\n      this.serverList[a] = this.serverList[a] || [];\n      var s = this.serverList[a];\n      if (!s) continue;\n      s.splice(0, s.length);\n      for (var o = 0; o < r.length; o++) {\n        var l = r[o], d = this.copy(l);\n        for (var c in d.key = d.value, l) if (l.hasOwnProperty(c)) {\n          if (c == \"value\" || c == \"label\") continue;\n          d[c] = l[c];\n        }\n        s.push(d);\n      }\n    }\n    i && this.callEvent(\"onOptionsLoad\", []);\n  }, t.attachEvent(\"onBeforeTaskDisplay\", function(n, i) {\n    return !i.$ignore;\n  }), t.json = { parse: function(n) {\n    if (n || e(n), typeof n == \"string\") if (typeof JSON != null) try {\n      n = JSON.parse(n);\n    } catch {\n      e(n);\n    }\n    else t.assert(!1, \"JSON is not supported\");\n    return n.data || n.tasks || e(n), n.dhx_security && (t.security_key = n.dhx_security), n;\n  }, serializeTask: function(n) {\n    return this._copyObject(n);\n  }, serializeLink: function(n) {\n    return this._copyLink(n);\n  }, _copyLink: function(n) {\n    var i = {};\n    for (var a in n) i[a] = n[a];\n    return i;\n  }, _copyObject: function(n) {\n    var i = {};\n    for (var a in n) a.charAt(0) != \"$\" && (i[a] = n[a], Z(i[a]) && (i[a] = t.defined(t.templates.xml_format) ? t.templates.xml_format(i[a]) : t.templates.format_date(i[a])));\n    return i;\n  }, serialize: function() {\n    var n = [], i = [];\n    let a = [];\n    t.eachTask(function(o) {\n      t.resetProjectDates(o), n.push(this.serializeTask(o));\n    }, t.config.root_id, this);\n    for (var r = t.getLinks(), s = 0; s < r.length; s++) i.push(this.serializeLink(r[s]));\n    return t.getDatastore(\"baselines\").eachItem(function(o) {\n      const l = t.json.serializeTask(o);\n      a.push(l);\n    }), { data: n, links: i, baselines: a };\n  } }, t.xml = { _xmlNodeToJSON: function(n, i) {\n    for (var a = {}, r = 0; r < n.attributes.length; r++) a[n.attributes[r].name] = n.attributes[r].value;\n    if (!i) {\n      for (r = 0; r < n.childNodes.length; r++) {\n        var s = n.childNodes[r];\n        s.nodeType == 1 && (a[s.tagName] = s.firstChild ? s.firstChild.nodeValue : \"\");\n      }\n      a.text || (a.text = n.firstChild ? n.firstChild.nodeValue : \"\");\n    }\n    return a;\n  }, _getCollections: function(n) {\n    for (var i = {}, a = t.ajax.xpath(\"//coll_options\", n), r = 0; r < a.length; r++) for (var s = i[a[r].getAttribute(\"for\")] = [], o = t.ajax.xpath(\".//item\", a[r]), l = 0; l < o.length; l++) {\n      for (var d = o[l].attributes, c = { key: o[l].getAttribute(\"value\"), label: o[l].getAttribute(\"label\") }, u = 0; u < d.length; u++) {\n        var h = d[u];\n        h.nodeName != \"value\" && h.nodeName != \"label\" && (c[h.nodeName] = h.nodeValue);\n      }\n      s.push(c);\n    }\n    return i;\n  }, _getXML: function(n, i, a) {\n    a = a || \"data\", i.getXMLTopNode || (i = t.ajax.parse(i));\n    var r = t.ajax.xmltop(a, i.xmlDoc);\n    r && r.tagName == a || function(o) {\n      throw t.assert(!1, \"Can't parse data: incorrect value of gantt.parse or gantt.load method. Actual argument value: \" + JSON.stringify(o)), new Error(\"Invalid argument for gantt.parse or gantt.load. An XML of format https://docs.dhtmlx.com/gantt/desktop__supported_data_formats.html#xmldhtmlxgantt20 is expected. Actual argument value: \" + JSON.stringify(o));\n    }(n);\n    var s = r.getAttribute(\"dhx_security\");\n    return s && (t.security_key = s), r;\n  }, parse: function(n, i) {\n    i = this._getXML(n, i);\n    for (var a = {}, r = a.data = [], s = t.ajax.xpath(\"//task\", i), o = 0; o < s.length; o++) r[o] = this._xmlNodeToJSON(s[o]);\n    return a.collections = this._getCollections(i), a;\n  }, _copyLink: function(n) {\n    return \"<item id='\" + n.id + \"' source='\" + n.source + \"' target='\" + n.target + \"' type='\" + n.type + \"' />\";\n  }, _copyObject: function(n) {\n    return \"<task id='\" + n.id + \"' parent='\" + (n.parent || \"\") + \"' start_date='\" + n.start_date + \"' duration='\" + n.duration + \"' open='\" + !!n.open + \"' progress='\" + n.progress + \"' end_date='\" + n.end_date + \"'><![CDATA[\" + n.text + \"]]></task>\";\n  }, serialize: function() {\n    for (var n = [], i = [], a = t.json.serialize(), r = 0, s = a.data.length; r < s; r++) n.push(this._copyObject(a.data[r]));\n    for (r = 0, s = a.links.length; r < s; r++) i.push(this._copyLink(a.links[r]));\n    return \"<data>\" + n.join(\"\") + \"<coll_options for='links'>\" + i.join(\"\") + \"</coll_options></data>\";\n  } }, t.oldxml = { parse: function(n, i) {\n    i = t.xml._getXML(n, i, \"projects\");\n    for (var a = { collections: { links: [] } }, r = a.data = [], s = t.ajax.xpath(\"//task\", i), o = 0; o < s.length; o++) {\n      r[o] = t.xml._xmlNodeToJSON(s[o]);\n      var l = s[o].parentNode;\n      l.tagName == \"project\" ? r[o].parent = \"project-\" + l.getAttribute(\"id\") : r[o].parent = l.parentNode.getAttribute(\"id\");\n    }\n    for (s = t.ajax.xpath(\"//project\", i), o = 0; o < s.length; o++)\n      (d = t.xml._xmlNodeToJSON(s[o], !0)).id = \"project-\" + d.id, r.push(d);\n    for (o = 0; o < r.length; o++) {\n      var d;\n      (d = r[o]).start_date = d.startdate || d.est, d.end_date = d.enddate, d.text = d.name, d.duration = d.duration / 8, d.open = 1, d.duration || d.end_date || (d.duration = 1), d.predecessortasks && a.collections.links.push({ target: d.id, source: d.predecessortasks, type: t.config.links.finish_to_start });\n    }\n    return a;\n  }, serialize: function() {\n    t.message(\"Serialization to 'old XML' is not implemented\");\n  } }, t.serverList = function(n, i) {\n    return i ? this.serverList[n] = i.slice(0) : this.serverList[n] || (this.serverList[n] = []), this.serverList[n];\n  };\n}\nfunction ae(t, e, n, i, a) {\n  return this.date = t, this.unit = e, this.task = n, this.id = i, this.calendar = a, this;\n}\nfunction re(t, e, n, i, a, r) {\n  return this.date = t, this.dir = e, this.unit = n, this.task = i, this.id = a, this.calendar = r, this;\n}\nfunction se(t, e, n, i, a, r, s) {\n  return this.start_date = t, this.duration = e, this.unit = n, this.step = i, this.task = a, this.id = r, this.calendar = s, this;\n}\nfunction pi(t, e, n, i) {\n  return this.start_date = t, this.end_date = e, this.task = n, this.calendar = i, this.unit = null, this.step = null, this;\n}\nvar _n = function(t) {\n  return { getWorkHoursArguments: function() {\n    var e = arguments[0];\n    if (!bt((e = Z(e) ? { date: e } : P({}, e)).date)) throw t.assert(!1, \"Invalid date argument for getWorkHours method\"), new Error(\"Invalid date argument for getWorkHours method\");\n    return e;\n  }, setWorkTimeArguments: function() {\n    return arguments[0];\n  }, unsetWorkTimeArguments: function() {\n    return arguments[0];\n  }, isWorkTimeArguments: function() {\n    var e, n = arguments[0];\n    if (n instanceof ae) return n;\n    if ((e = n.date ? new ae(n.date, n.unit, n.task, null, n.calendar) : new ae(arguments[0], arguments[1], arguments[2], null, arguments[3])).unit = e.unit || t.config.duration_unit, !bt(e.date)) throw t.assert(!1, \"Invalid date argument for isWorkTime method\"), new Error(\"Invalid date argument for isWorkTime method\");\n    return e;\n  }, getClosestWorkTimeArguments: function(e) {\n    var n, i = arguments[0];\n    if (i instanceof re) return i;\n    if (n = Z(i) ? new re(i) : new re(i.date, i.dir, i.unit, i.task, null, i.calendar), i.id && (n.task = i), n.dir = i.dir || \"any\", n.unit = i.unit || t.config.duration_unit, !bt(n.date)) throw t.assert(!1, \"Invalid date argument for getClosestWorkTime method\"), new Error(\"Invalid date argument for getClosestWorkTime method\");\n    return n;\n  }, _getStartEndConfig: function(e) {\n    var n, i = pi;\n    if (e instanceof i) return e;\n    if (Z(e) ? n = new i(arguments[0], arguments[1], arguments[2], arguments[3]) : (n = new i(e.start_date, e.end_date, e.task), e.id !== null && e.id !== void 0 && (n.task = e)), n.unit = n.unit || t.config.duration_unit, n.step = n.step || t.config.duration_step, n.start_date = n.start_date || n.start || n.date, !bt(n.start_date)) throw t.assert(!1, \"Invalid start_date argument for getDuration method\"), new Error(\"Invalid start_date argument for getDuration method\");\n    if (!bt(n.end_date)) throw t.assert(!1, \"Invalid end_date argument for getDuration method\"), new Error(\"Invalid end_date argument for getDuration method\");\n    return n;\n  }, getDurationArguments: function(e, n, i, a) {\n    return this._getStartEndConfig.apply(this, arguments);\n  }, hasDurationArguments: function(e, n, i, a) {\n    return this._getStartEndConfig.apply(this, arguments);\n  }, calculateEndDateArguments: function(e, n, i, a) {\n    var r, s = arguments[0];\n    if (s instanceof se) return s;\n    if (r = Z(s) ? new se(arguments[0], arguments[1], arguments[2], void 0, arguments[3], void 0, arguments[4]) : new se(s.start_date, s.duration, s.unit, s.step, s.task, null, s.calendar), s.id !== null && s.id !== void 0 && (r.task = s, r.unit = null, r.step = null), r.unit = r.unit || t.config.duration_unit, r.step = r.step || t.config.duration_step, !bt(r.start_date)) throw t.assert(!1, \"Invalid start_date argument for calculateEndDate method\"), new Error(\"Invalid start_date argument for calculateEndDate method\");\n    return r;\n  } };\n};\nfunction gn() {\n}\ngn.prototype = { _getIntervals: function(t) {\n  for (var e = [], n = 0; n < t.length; n += 2) e.push({ start: t[n], end: t[n + 1] });\n  return e;\n}, _toHoursArray: function(t) {\n  var e = [];\n  function n(a) {\n    var r, s = Math.floor(a / 3600), o = a - 60 * s * 60, l = Math.floor(o / 60);\n    return s + \":\" + ((r = String(l)).length < 2 && (r = \"0\" + r), r);\n  }\n  for (var i = 0; i < t.length; i++) e.push(n(t[i].start) + \"-\" + n(t[i].end));\n  return e;\n}, _intersectHourRanges: function(t, e) {\n  var n = [], i = t.length > e.length ? t : e, a = t === i ? e : t;\n  i = i.slice(), a = a.slice(), n = [];\n  for (var r = 0; r < i.length; r++) for (var s = i[r], o = 0; o < a.length; o++) {\n    var l = a[o];\n    l.start < s.end && l.end > s.start && (n.push({ start: Math.max(s.start, l.start), end: Math.min(s.end, l.end) }), s.end > l.end && (a.splice(o, 1), o--, r--));\n  }\n  return n;\n}, _mergeAdjacentIntervals: function(t) {\n  var e = t.slice();\n  e.sort(function(r, s) {\n    return r.start - s.start;\n  });\n  for (var n = e[0], i = 1; i < e.length; i++) {\n    var a = e[i];\n    a.start <= n.end ? (a.end > n.end && (n.end = a.end), e.splice(i, 1), i--) : n = a;\n  }\n  return e;\n}, _mergeHoursConfig: function(t, e) {\n  return this._mergeAdjacentIntervals(this._intersectHourRanges(t, e));\n}, merge: function(t, e) {\n  var n = q(t.getConfig().parsed), i = q(e.getConfig().parsed), a = { hours: this._toHoursArray(this._mergeHoursConfig(n.hours, i.hours)), dates: {}, customWeeks: {} };\n  const r = (o, l) => {\n    for (let d in o.dates) {\n      const c = o.dates[d];\n      +d > 1e3 && (a.dates[d] = !1);\n      for (const u in l.dates) {\n        const h = l.dates[u];\n        if (u == d && (a.dates[d] = !(!c || !h)), Array.isArray(c)) {\n          const g = Array.isArray(h) ? h : l.hours;\n          a.dates[d] = this._toHoursArray(this._mergeHoursConfig(c, g));\n        }\n      }\n    }\n  };\n  if (r(n, i), r(i, n), n.customWeeks) for (var s in n.customWeeks) a.customWeeks[s] = n.customWeeks[s];\n  if (i.customWeeks) for (var s in i.customWeeks) a.customWeeks[s] = i.customWeeks[s];\n  return a;\n} };\nclass mi {\n  constructor() {\n    this.clear();\n  }\n  getItem(e, n, i) {\n    if (this._cache.has(e)) {\n      const a = this._cache.get(e)[i.getFullYear()];\n      if (a && a.has(n)) return a.get(n);\n    }\n    return -1;\n  }\n  setItem(e, n, i, a) {\n    if (!e || !n) return;\n    const r = this._cache, s = a.getFullYear();\n    let o;\n    r.has(e) ? o = r.get(e) : (o = [], r.set(e, o));\n    let l = o[s];\n    l || (l = o[s] = /* @__PURE__ */ new Map()), l.set(n, i);\n  }\n  clear() {\n    this._cache = /* @__PURE__ */ new Map();\n  }\n}\nclass vi {\n  constructor() {\n    this.clear();\n  }\n  getItem(e, n, i) {\n    const a = this._cache;\n    if (a && a[e]) {\n      const r = a[e];\n      if (r === void 0) return -1;\n      const s = r[i.getFullYear()];\n      if (s && s[n] !== void 0) return s[n];\n    }\n    return -1;\n  }\n  setItem(e, n, i, a) {\n    if (!e || !n) return;\n    const r = this._cache;\n    if (!r) return;\n    r[e] || (r[e] = []);\n    const s = r[e], o = a.getFullYear();\n    let l = s[o];\n    l || (l = s[o] = {}), l[n] = i;\n  }\n  clear() {\n    this._cache = {};\n  }\n}\nclass ki {\n  constructor(e) {\n    this.getMinutesPerWeek = (n) => {\n      const i = n.valueOf();\n      if (this._weekCache.has(i)) return this._weekCache.get(i);\n      const a = this._calendar, r = this._calendar.$gantt;\n      let s = 0, o = r.date.week_start(new Date(n));\n      for (let l = 0; l < 7; l++) s += 60 * a.getHoursPerDay(o), o = r.date.add(o, 1, \"day\");\n      return this._weekCache.set(i, s), s;\n    }, this.getMinutesPerMonth = (n) => {\n      const i = n.valueOf();\n      if (this._monthCache.has(i)) return this._monthCache.get(i);\n      const a = this._calendar, r = this._calendar.$gantt;\n      let s = 0, o = r.date.week_start(new Date(n));\n      const l = r.date.add(o, 1, \"month\").valueOf();\n      for (; o.valueOf() < l; ) s += 60 * a.getHoursPerDay(o), o = r.date.add(o, 1, \"day\");\n      return this._monthCache.set(i, s), s;\n    }, this.clear = () => {\n      this._weekCache = /* @__PURE__ */ new Map(), this._monthCache = /* @__PURE__ */ new Map();\n    }, this.clear(), this._calendar = e;\n  }\n}\nclass yi {\n  constructor() {\n    this.clear();\n  }\n  _getCacheObject(e, n, i) {\n    const a = this._cache;\n    a[n] || (a[n] = []);\n    let r = a[n];\n    r || (r = a[n] = {});\n    let s = r[i];\n    s || (s = r[i] = {});\n    const o = e.getFullYear();\n    let l = s[o];\n    return l || (l = s[o] = { durations: {}, endDates: {} }), l;\n  }\n  _endDateCacheKey(e, n) {\n    return String(e) + \"-\" + String(n);\n  }\n  _durationCacheKey(e, n) {\n    return String(e) + \"-\" + String(n);\n  }\n  getEndDate(e, n, i, a, r) {\n    const s = this._getCacheObject(e, i, a), o = e.valueOf(), l = this._endDateCacheKey(o, n);\n    let d;\n    if (s.endDates[l] === void 0) {\n      const c = r(), u = c.valueOf();\n      s.endDates[l] = u, s.durations[this._durationCacheKey(o, u)] = n, d = c;\n    } else d = new Date(s.endDates[l]);\n    return d;\n  }\n  getDuration(e, n, i, a, r) {\n    const s = this._getCacheObject(e, i, a), o = e.valueOf(), l = n.valueOf(), d = this._durationCacheKey(o, l);\n    let c;\n    if (s.durations[d] === void 0) {\n      const u = r();\n      s.durations[d] = u.valueOf(), c = u;\n    } else c = s.durations[d];\n    return c;\n  }\n  clear() {\n    this._cache = {};\n  }\n}\nfunction ye(t, e) {\n  this.argumentsHelper = e, this.$gantt = t, this._workingUnitsCache = typeof Map < \"u\" ? new mi() : new vi(), this._largeUnitsCache = new ki(this), this._dateDurationCache = new yi(), this._worktime = null, this._cached_timestamps = {}, this._cached_timestamps_count = 0;\n}\nye.prototype = { units: [\"year\", \"month\", \"week\", \"day\", \"hour\", \"minute\"], _clearCaches: function() {\n  this._workingUnitsCache.clear(), this._largeUnitsCache.clear(), this._dateDurationCache.clear();\n}, _getUnitOrder: function(t) {\n  for (var e = 0, n = this.units.length; e < n; e++) if (this.units[e] == t) return e;\n}, _resetTimestampCache: function() {\n  this._cached_timestamps = {}, this._cached_timestamps_count = 0;\n}, _timestamp: function(t) {\n  this._cached_timestamps_count > 1e6 && this._resetTimestampCache();\n  var e = null;\n  if (t.day || t.day === 0) e = t.day;\n  else if (t.date) {\n    var n = String(t.date.valueOf());\n    this._cached_timestamps[n] ? e = this._cached_timestamps[n] : (e = Date.UTC(t.date.getFullYear(), t.date.getMonth(), t.date.getDate()), this._cached_timestamps[n] = e, this._cached_timestamps_count++);\n  }\n  return e;\n}, _checkIfWorkingUnit: function(t, e) {\n  if (!this[\"_is_work_\" + e]) {\n    const n = this.$gantt.date[`${e}_start`](new Date(t)), i = this.$gantt.date.add(n, 1, e);\n    return this.hasDuration(n, i);\n  }\n  return this[\"_is_work_\" + e](t);\n}, _is_work_day: function(t) {\n  var e = this._getWorkHours(t);\n  return !!Array.isArray(e) && e.length > 0;\n}, _is_work_hour: function(t) {\n  for (var e = this._getWorkHours(t), n = t.getHours(), i = 0; i < e.length; i++) if (n >= e[i].startHour && n < e[i].endHour) return !0;\n  return !1;\n}, _getTimeOfDayStamp: function(t, e) {\n  var n = t.getHours();\n  return t.getHours() || t.getMinutes() || !e || (n = 24), 60 * n * 60 + 60 * t.getMinutes();\n}, _is_work_minute: function(t) {\n  for (var e = this._getWorkHours(t), n = this._getTimeOfDayStamp(t), i = 0; i < e.length; i++) if (n >= e[i].start && n < e[i].end) return !0;\n  return !1;\n}, _nextDate: function(t, e, n) {\n  return this.$gantt.date.add(t, n, e);\n}, _getWorkUnitsBetweenGeneric: function(t, e, n, i) {\n  var a = this.$gantt.date, r = new Date(t), s = new Date(e);\n  i = i || 1;\n  var o, l, d = 0, c = null, u = !1;\n  (o = a[n + \"_start\"](new Date(r))).valueOf() != r.valueOf() && (u = !0);\n  var h = !1;\n  (l = a[n + \"_start\"](new Date(e))).valueOf() != e.valueOf() && (h = !0);\n  for (var g = !1; r.valueOf() < s.valueOf(); ) {\n    if (g = (c = this._nextDate(r, n, i)).valueOf() > s.valueOf(), this._isWorkTime(r, n)) (u || h && g) && (o = a[n + \"_start\"](new Date(r)), l = a.add(o, i, n)), u ? (u = !1, c = this._nextDate(o, n, i), d += (l.valueOf() - r.valueOf()) / (l.valueOf() - o.valueOf())) : h && g ? (h = !1, d += (s.valueOf() - r.valueOf()) / (l.valueOf() - o.valueOf())) : d++;\n    else {\n      var p = this._getUnitOrder(n), y = this.units[p - 1];\n      y && !this._isWorkTime(r, y) && (c = this._getClosestWorkTimeFuture(r, y));\n    }\n    r = c;\n  }\n  return d;\n}, _getMinutesPerHour: function(t) {\n  var e = this._getTimeOfDayStamp(t), n = this._getTimeOfDayStamp(this._nextDate(t, \"hour\", 1));\n  n === 0 && (n = 86400);\n  for (var i = this._getWorkHours(t), a = 0; a < i.length; a++) {\n    var r = i[a];\n    if (e >= r.start && n <= r.end) return 60;\n    if (e < r.end && n > r.start) return (Math.min(n, r.end) - Math.max(e, r.start)) / 60;\n  }\n  return 0;\n}, _getMinutesPerDay: function(t) {\n  var e = this._getWorkHours(t), n = 0;\n  return e.forEach(function(i) {\n    n += i.durationMinutes;\n  }), n;\n}, getHoursPerDay: function(t) {\n  var e = this._getWorkHours(t), n = 0;\n  return e.forEach(function(i) {\n    n += i.durationHours;\n  }), n;\n}, _getWorkUnitsForRange: function(t, e, n, i) {\n  var a, r = 0, s = new Date(t), o = new Date(e);\n  for (a = R(n == \"minute\" ? this._getMinutesPerDay : this.getHoursPerDay, this); s.valueOf() < o.valueOf(); ) if (o - s > 27648e5 && s.getDate() === 0) {\n    var l = this._largeUnitsCache.getMinutesPerMonth(s);\n    n == \"hour\" && (l /= 60), r += l, s = this.$gantt.date.add(s, 1, \"month\");\n  } else {\n    if (o - s > 13824e5) {\n      var d = this.$gantt.date.week_start(new Date(s));\n      if (s.valueOf() === d.valueOf()) {\n        l = this._largeUnitsCache.getMinutesPerWeek(s), n == \"hour\" && (l /= 60), r += l, s = this.$gantt.date.add(s, 7, \"day\");\n        continue;\n      }\n    }\n    r += a(s), s = this._nextDate(s, \"day\", 1);\n  }\n  return r / i;\n}, _getMinutesBetweenSingleDay: function(t, e) {\n  for (var n = this._getIntervalTimestamp(t, e), i = this._getWorkHours(t), a = 0, r = 0; r < i.length; r++) {\n    var s = i[r];\n    if (n.end >= s.start && n.start <= s.end) {\n      var o = Math.max(s.start, n.start), l = Math.min(s.end, n.end);\n      a += (l - o) / 60, n.start = l;\n    }\n  }\n  return Math.floor(a);\n}, _getMinutesBetween: function(t, e, n, i) {\n  var a = new Date(t), r = new Date(e);\n  i = i || 1;\n  var s = new Date(a), o = this.$gantt.date.add(this.$gantt.date.day_start(new Date(a)), 1, \"day\");\n  if (r.valueOf() <= o.valueOf()) return this._getMinutesBetweenSingleDay(t, e);\n  var l = this.$gantt.date.day_start(new Date(r)), d = r, c = this._getMinutesBetweenSingleDay(s, o), u = this._getMinutesBetweenSingleDay(l, d);\n  return c + this._getWorkUnitsForRange(o, l, n, i) + u;\n}, _getHoursBetween: function(t, e, n, i) {\n  var a = new Date(t), r = new Date(e);\n  i = i || 1;\n  var s = new Date(a), o = this.$gantt.date.add(this.$gantt.date.day_start(new Date(a)), 1, \"day\");\n  if (r.valueOf() <= o.valueOf()) return Math.round(this._getMinutesBetweenSingleDay(t, e) / 60);\n  var l = this.$gantt.date.day_start(new Date(r)), d = r, c = this._getMinutesBetweenSingleDay(s, o, n, i) / 60, u = this._getMinutesBetweenSingleDay(l, d, n, i) / 60, h = c + this._getWorkUnitsForRange(o, l, n, i) + u;\n  return Math.round(h);\n}, getConfig: function() {\n  return this._worktime;\n}, _setConfig: function(t) {\n  this._worktime = t, this._parseSettings(), this._clearCaches();\n}, _parseSettings: function() {\n  var t = this.getConfig();\n  for (var e in t.parsed = { dates: {}, hours: null, haveCustomWeeks: !1, customWeeks: {}, customWeeksRangeStart: null, customWeeksRangeEnd: null, customWeeksBoundaries: [] }, t.parsed.hours = this._parseHours(t.hours), t.dates) t.parsed.dates[e] = this._parseHours(t.dates[e]);\n  if (t.customWeeks) {\n    var n = null, i = null;\n    for (var e in t.customWeeks) {\n      var a = t.customWeeks[e];\n      if (a.from && a.to) {\n        var r = a.from, s = a.to;\n        (!n || n > r.valueOf()) && (n = r.valueOf()), (!i || i < s.valueOf()) && (i = s.valueOf()), t.parsed.customWeeksBoundaries.push({ from: r.valueOf(), fromReadable: new Date(r), to: s.valueOf(), toReadable: new Date(s), name: e }), t.parsed.haveCustomWeeks = !0;\n        var o = t.parsed.customWeeks[e] = { from: a.from, to: a.to, hours: this._parseHours(a.hours), dates: {} };\n        for (var l in a.dates) o.dates[l] = this._parseHours(a.dates[l]);\n      }\n    }\n    t.parsed.customWeeksRangeStart = n, t.parsed.customWeeksRangeEnd = i;\n  }\n}, _tryChangeCalendarSettings: function(t) {\n  var e = JSON.stringify(this.getConfig());\n  return t(), !!this.hasWorkTime() || (this._setConfig(JSON.parse(e)), this._clearCaches(), !1);\n}, _arraysEqual: function(t, e) {\n  if (t === e) return !0;\n  if (!t || !e || t.length != e.length) return !1;\n  for (var n = 0; n < t.length; ++n) if (t[n] !== e[n]) return !1;\n  return !0;\n}, _compareSettings: function(t, e) {\n  if (!this._arraysEqual(t.hours, e.hours)) return !1;\n  var n = Object.keys(t.dates), i = Object.keys(e.dates);\n  if (n.sort(), i.sort(), !this._arraysEqual(n, i)) return !1;\n  for (var a = 0; a < n.length; a++) {\n    var r = n[a], s = t.dates[r], o = t.dates[r];\n    if (s !== o && !(Array.isArray(s) && Array.isArray(o) && this._arraysEqual(s, o))) return !1;\n  }\n  return !0;\n}, equals: function(t) {\n  if (!(t instanceof ye)) return !1;\n  var e = this.getConfig(), n = t.getConfig();\n  if (!this._compareSettings(e, n)) return !1;\n  if (e.parsed.haveCustomWeeks && n.parsed.haveCustomWeeks) {\n    if (e.parsed.customWeeksBoundaries.length != n.parsed.customWeeksBoundaries.length) return !1;\n    for (var i in e.parsed.customWeeks) {\n      var a = e.parsed.customWeeks[i], r = n.parsed.customWeeks[i];\n      if (!r || !this._compareSettings(a, r)) return !1;\n    }\n  } else if (e.parse.haveCustomWeeks !== n.parsed.haveCustomWeeks) return !1;\n  return !0;\n}, getWorkHours: function() {\n  var t = this.argumentsHelper.getWorkHoursArguments.apply(this.argumentsHelper, arguments);\n  return this._getWorkHours(t.date, !1);\n}, _getWorkHours: function(t, e) {\n  var n = this.getConfig();\n  if (e !== !1 && (n = n.parsed), !t) return n.hours;\n  var i = this._timestamp({ date: t });\n  if (n.haveCustomWeeks && n.customWeeksRangeStart <= i && n.customWeeksRangeEnd > i) {\n    for (var a = 0; a < n.customWeeksBoundaries.length; a++) if (n.customWeeksBoundaries[a].from <= i && n.customWeeksBoundaries[a].to > i) {\n      n = n.customWeeks[n.customWeeksBoundaries[a].name];\n      break;\n    }\n  }\n  var r = !0;\n  return n.dates[i] !== void 0 ? r = n.dates[i] : n.dates[t.getDay()] !== void 0 && (r = n.dates[t.getDay()]), r === !0 ? n.hours : r || [];\n}, _getIntervalTimestamp: function(t, e) {\n  var n = { start: 0, end: 0 };\n  n.start = 60 * t.getHours() * 60 + 60 * t.getMinutes() + t.getSeconds();\n  var i = e.getHours();\n  return !i && !e.getMinutes() && !e.getSeconds() && t.valueOf() < e.valueOf() && (i = 24), n.end = 60 * i * 60 + 60 * e.getMinutes() + e.getSeconds(), n;\n}, _parseHours: function(t) {\n  if (Array.isArray(t)) {\n    var e = [];\n    t.forEach(function(o) {\n      typeof o == \"number\" ? e.push(60 * o * 60) : typeof o == \"string\" && o.split(\"-\").map(function(l) {\n        return l.trim();\n      }).forEach(function(l) {\n        var d = l.split(\":\").map(function(u) {\n          return u.trim();\n        }), c = parseInt(60 * d[0] * 60);\n        d[1] && (c += parseInt(60 * d[1])), d[2] && (c += parseInt(d[2])), e.push(c);\n      });\n    });\n    for (var n = [], i = 0; i < e.length; i += 2) {\n      var a = e[i], r = e[i + 1], s = r - a;\n      n.push({ start: a, end: r, startHour: Math.floor(a / 3600), startMinute: Math.floor(a / 60), endHour: Math.ceil(r / 3600), endMinute: Math.ceil(r / 60), durationSeconds: s, durationMinutes: s / 60, durationHours: s / 3600 });\n    }\n    return n;\n  }\n  return t;\n}, setWorkTime: function(t) {\n  return this._tryChangeCalendarSettings(R(function() {\n    var e = t.hours === void 0 || t.hours, n = this._timestamp(t), i = this.getConfig();\n    if (n !== null ? i.dates[n] = e : t.customWeeks || (i.hours = e), t.customWeeks) {\n      if (i.customWeeks || (i.customWeeks = {}), typeof t.customWeeks == \"string\") n !== null ? i.customWeeks[t.customWeeks].dates[n] = e : t.customWeeks || (i.customWeeks[t.customWeeks].hours = e);\n      else if (typeof t.customWeeks == \"object\" && Function.prototype.toString.call(t.customWeeks.constructor) === \"function Object() { [native code] }\") for (var a in t.customWeeks) i.customWeeks[a] = t.customWeeks[a];\n    }\n    this._parseSettings(), this._clearCaches();\n  }, this));\n}, unsetWorkTime: function(t) {\n  return this._tryChangeCalendarSettings(R(function() {\n    if (t) {\n      var e = this._timestamp(t);\n      e !== null && delete this.getConfig().dates[e];\n    } else this.reset_calendar();\n    this._parseSettings(), this._clearCaches();\n  }, this));\n}, _isWorkTime: function(t, e) {\n  var n, i = -1;\n  return n = String(t.valueOf()), (i = this._workingUnitsCache.getItem(e, n, t)) == -1 && (i = this._checkIfWorkingUnit(t, e), this._workingUnitsCache.setItem(e, n, i, t)), i;\n}, isWorkTime: function() {\n  var t = this.argumentsHelper.isWorkTimeArguments.apply(this.argumentsHelper, arguments);\n  return this._isWorkTime(t.date, t.unit);\n}, calculateDuration: function() {\n  var t = this.argumentsHelper.getDurationArguments.apply(this.argumentsHelper, arguments);\n  if (!t.unit) return !1;\n  var e = this;\n  return this._dateDurationCache.getDuration(t.start_date, t.end_date, t.unit, t.step, function() {\n    return e._calculateDuration(t.start_date, t.end_date, t.unit, t.step);\n  });\n}, _calculateDuration: function(t, e, n, i) {\n  var a = 0, r = 1;\n  if (t.valueOf() > e.valueOf()) {\n    var s = e;\n    e = t, t = s, r = -1;\n  }\n  return a = n == \"hour\" && i == 1 ? this._getHoursBetween(t, e, n, i) : n == \"minute\" && i == 1 ? this._getMinutesBetween(t, e, n, i) : this._getWorkUnitsBetweenGeneric(t, e, n, i), r * Math.round(a);\n}, hasDuration: function() {\n  var t = this.argumentsHelper.getDurationArguments.apply(this.argumentsHelper, arguments), e = t.start_date, n = t.end_date, i = t.unit, a = t.step;\n  if (!i) return !1;\n  var r = new Date(e), s = new Date(n);\n  for (a = a || 1; r.valueOf() < s.valueOf(); ) {\n    if (this._isWorkTime(r, i)) return !0;\n    r = this._nextDate(r, i, a);\n  }\n  return !1;\n}, calculateEndDate: function() {\n  var t = this.argumentsHelper.calculateEndDateArguments.apply(this.argumentsHelper, arguments), e = t.start_date, n = t.duration, i = t.unit, a = t.step;\n  if (!i) return !1;\n  var r = t.duration >= 0 ? 1 : -1;\n  n = Math.abs(1 * n);\n  var s = this;\n  return this._dateDurationCache.getEndDate(e, n, i, a * r, function() {\n    return s._calculateEndDate(e, n, i, a * r);\n  });\n}, _calculateEndDate: function(t, e, n, i) {\n  return !!n && (i == 1 && n == \"minute\" ? this._calculateMinuteEndDate(t, e, i) : i == -1 && n == \"minute\" ? this._subtractMinuteDate(t, e, i) : i == 1 && n == \"hour\" ? this._calculateHourEndDate(t, e, i) : this._addInterval(t, e, n, i, null).end);\n}, _addInterval: function(t, e, n, i, a) {\n  for (var r = 0, s = t, o = !1; r < e && (!a || !a(s)); ) {\n    var l = this._nextDate(s, n, i);\n    n == \"day\" && (o = o || !s.getHours() && l.getHours()) && (l.setHours(0), l.getHours() || (o = !1));\n    var d = new Date(l.valueOf() + 1);\n    i > 0 && (d = new Date(l.valueOf() - 1)), this._isWorkTime(d, n) && !o && r++, s = l;\n  }\n  return { end: s, start: t, added: r };\n}, _addHoursUntilDayEnd: function(t, e) {\n  for (var n = this.$gantt.date.add(this.$gantt.date.day_start(new Date(t)), 1, \"day\"), i = 0, a = e, r = this._getIntervalTimestamp(t, n), s = this._getWorkHours(t), o = 0; o < s.length && i < e; o++) {\n    var l = s[o];\n    if (r.end >= l.start && r.start <= l.end) {\n      var d = Math.max(l.start, r.start), c = Math.min(l.end, r.end), u = (c - d) / 3600;\n      u > a && (u = a, c = d + 60 * a * 60);\n      var h = Math.round((c - d) / 3600);\n      i += h, a -= h, r.start = c;\n    }\n  }\n  var g = n;\n  return i === e && (g = new Date(t.getFullYear(), t.getMonth(), t.getDate(), 0, 0, r.start)), { added: i, end: g };\n}, _calculateHourEndDate: function(t, e, n) {\n  var i = new Date(t), a = 0;\n  n = n || 1, e = Math.abs(1 * e);\n  var r = this._addHoursUntilDayEnd(i, e);\n  if (a = r.added, i = r.end, d = e - a) {\n    for (var s = i; a < e; ) {\n      var o = this._nextDate(s, \"day\", n);\n      o.setHours(0), o.setMinutes(0), o.setSeconds(0);\n      var l = 0;\n      if (a + (l = n > 0 ? this.getHoursPerDay(new Date(o.valueOf() - 1)) : this.getHoursPerDay(new Date(o.valueOf() + 1))) >= e) break;\n      a += l, s = o;\n    }\n    i = s;\n  }\n  if (a < e) {\n    var d = e - a;\n    i = (r = this._addHoursUntilDayEnd(i, d)).end;\n  }\n  return i;\n}, _addMinutesUntilHourEnd: function(t, e) {\n  if (t.getMinutes() === 0) return { added: 0, end: new Date(t) };\n  for (var n = this.$gantt.date.add(this.$gantt.date.hour_start(new Date(t)), 1, \"hour\"), i = 0, a = e, r = this._getIntervalTimestamp(t, n), s = this._getWorkHours(t), o = 0; o < s.length && i < e; o++) {\n    var l = s[o];\n    if (r.end >= l.start && r.start <= l.end) {\n      var d = Math.max(l.start, r.start), c = Math.min(l.end, r.end), u = (c - d) / 60;\n      u > a && (u = a, c = d + 60 * a);\n      var h = Math.round((c - d) / 60);\n      a -= h, i += h, r.start = c;\n    }\n  }\n  var g = n;\n  return i === e && (g = new Date(t.getFullYear(), t.getMonth(), t.getDate(), 0, 0, r.start)), { added: i, end: g };\n}, _subtractMinutesUntilHourStart: function(t, e) {\n  for (var n = this.$gantt.date.hour_start(new Date(t)), i = 0, a = e, r = 60 * n.getHours() * 60 + 60 * n.getMinutes() + n.getSeconds(), s = 60 * t.getHours() * 60 + 60 * t.getMinutes() + t.getSeconds(), o = this._getWorkHours(t), l = o.length - 1; l >= 0 && i < e; l--) {\n    var d = o[l];\n    if (s > d.start && r <= d.end) {\n      var c = Math.min(s, d.end), u = Math.max(r, d.start), h = (c - u) / 60;\n      h > a && (h = a, u = c - 60 * a);\n      var g = Math.abs(Math.round((c - u) / 60));\n      a -= g, i += g, s = u;\n    }\n  }\n  var p = n;\n  return i === e && (p = new Date(t.getFullYear(), t.getMonth(), t.getDate(), 0, 0, s)), { added: i, end: p };\n}, _subtractMinuteDate: function(t, e, n) {\n  var i = this.getClosestWorkTime({ date: t, dir: \"past\", unit: \"minute\" }), a = 0;\n  n = n || -1, e = Math.abs(1 * e), e = Math.round(e);\n  const r = this._isMinutePrecision(i);\n  let s = this._subtractMinutesUntilHourStart(i, e);\n  a += s.added, i = s.end;\n  for (var o = 0, l = [], d = 0; a < e; ) {\n    var c = this.$gantt.date.day_start(new Date(i)), u = !1;\n    i.valueOf() === c.valueOf() && (c = this.$gantt.date.add(c, -1, \"day\"), u = !0);\n    var h = new Date(c.getFullYear(), c.getMonth(), c.getDate(), 23, 59, 59, 999).valueOf();\n    h !== o && (l = this._getWorkHours(c), d = this._getMinutesPerDay(c), o = h);\n    var g = e - a, p = this._getTimeOfDayStamp(i, u);\n    if (l.length && d) if (l[l.length - 1].end <= p && g > d) a += d, i = this.$gantt.date.add(i, -1, \"day\");\n    else {\n      for (var y = !1, v = null, b = null, _ = l.length - 1; _ >= 0; _--) if (l[_].start < p - 1 && l[_].end >= p - 1) {\n        y = !0, v = l[_], b = l[_ - 1];\n        break;\n      }\n      if (y) if (p === v.end && g >= v.durationMinutes) a += v.durationMinutes, i = this.$gantt.date.add(i, -v.durationMinutes, \"minute\");\n      else if (!r && g <= p / 60 - v.startMinute) a += g, i = this.$gantt.date.add(i, -g, \"minute\");\n      else if (r) g <= p / 60 - v.startMinute ? (a += g, i = this.$gantt.date.add(i, -g, \"minute\")) : (a += p / 60 - v.startMinute, i = b ? new Date(i.getFullYear(), i.getMonth(), i.getDate(), 0, 0, b.end) : this.$gantt.date.day_start(i));\n      else {\n        var m = this._getMinutesPerHour(i);\n        m <= g ? (a += m, i = this._nextDate(i, \"hour\", n)) : (s = this._subtractMinutesUntilHourStart(i, g), a += s.added, i = s.end);\n      }\n      else if (i.getHours() === 0 && i.getMinutes() === 0 && i.getSeconds() === 0) {\n        if ((f = this._getClosestWorkTimePast(i, \"hour\")).valueOf() === i.valueOf()) {\n          var f = this.$gantt.date.add(i, -1, \"day\"), k = this._getWorkHours(f);\n          if (k.length) {\n            var x = k[k.length - 1];\n            f.setSeconds(x.durationSeconds);\n          }\n        }\n        i = f;\n      } else i = this._getClosestWorkTimePast(new Date(i - 1), \"hour\");\n    }\n    else i = this.$gantt.date.add(i, -1, \"day\");\n  }\n  if (a < e) {\n    var $ = e - a;\n    s = this._subtractMinutesUntilHourStart(i, $), a += s.added, i = s.end;\n  }\n  return i;\n}, _calculateMinuteEndDate: function(t, e, n) {\n  var i = new Date(t), a = 0;\n  n = n || 1, e = Math.abs(1 * e), e = Math.round(e);\n  var r = this._addMinutesUntilHourEnd(i, e);\n  a += r.added, i = r.end;\n  for (var s = 0, o = [], l = 0, d = this._isMinutePrecision(i); a < e; ) {\n    var c = this.$gantt.date.day_start(new Date(i)).valueOf();\n    c !== s && (o = this._getWorkHours(i), l = this._getMinutesPerDay(i), s = c);\n    var u = e - a, h = this._getTimeOfDayStamp(i);\n    if (o.length && l) if (o[0].start >= h && u >= l) {\n      if (a += l, u == l) {\n        i = new Date(i.getFullYear(), i.getMonth(), i.getDate(), 0, 0, o[o.length - 1].end);\n        break;\n      }\n      i = this.$gantt.date.add(i, 1, \"day\"), i = this.$gantt.date.day_start(i);\n    } else {\n      for (var g = !1, p = null, y = 0; y < o.length; y++) if (o[y].start <= h && o[y].end > h) {\n        g = !0, p = o[y];\n        break;\n      }\n      if (g) if (h === p.start && u >= p.durationMinutes) a += p.durationMinutes, i = this.$gantt.date.add(i, p.durationMinutes, \"minute\");\n      else if (u <= p.endMinute - h / 60) a += u, i = this.$gantt.date.add(i, u, \"minute\");\n      else {\n        var v = this._getMinutesPerHour(i);\n        v <= u ? (a += v, i = d ? this.$gantt.date.add(i, v, \"minute\") : this._nextDate(i, \"hour\", n)) : (a += (r = this._addMinutesUntilHourEnd(i, u)).added, i = r.end);\n      }\n      else i = this._getClosestWorkTimeFuture(i, \"hour\");\n    }\n    else i = this.$gantt.date.add(this.$gantt.date.day_start(i), 1, \"day\");\n  }\n  if (a < e) {\n    var b = e - a;\n    a += (r = this._addMinutesUntilHourEnd(i, b)).added, i = r.end;\n  }\n  return i;\n}, getClosestWorkTime: function() {\n  var t = this.argumentsHelper.getClosestWorkTimeArguments.apply(this.argumentsHelper, arguments);\n  return this._getClosestWorkTime(t.date, t.unit, t.dir);\n}, _getClosestWorkTime: function(t, e, n) {\n  var i = new Date(t);\n  if (this._isWorkTime(i, e)) return i;\n  if (i = this.$gantt.date[e + \"_start\"](i), n != \"any\" && n) i = n == \"past\" ? this._getClosestWorkTimePast(i, e) : this._getClosestWorkTimeFuture(i, e);\n  else {\n    var a = this._getClosestWorkTimeFuture(i, e), r = this._getClosestWorkTimePast(i, e);\n    i = Math.abs(a - t) <= Math.abs(t - r) ? a : r;\n  }\n  return i;\n}, _getClosestWorkTimeFuture: function(t, e) {\n  return this._getClosestWorkTimeGeneric(t, e, 1);\n}, _getClosestWorkTimePast: function(t, e) {\n  var n = this._getClosestWorkTimeGeneric(t, e, -1);\n  return this.$gantt.date.add(n, 1, e);\n}, _findClosestTimeInDay: function(t, e, n) {\n  var i = new Date(t), a = null, r = !1;\n  this._getWorkHours(i).length || (i = this._getClosestWorkTime(i, \"day\", e < 0 ? \"past\" : \"future\"), e < 0 && (i = new Date(i.valueOf() - 1), r = !0), n = this._getWorkHours(i));\n  var s = this._getTimeOfDayStamp(i);\n  if (r && (s = this._getTimeOfDayStamp(new Date(i.valueOf() + 1), r)), e > 0) {\n    for (var o = 0; o < n.length; o++) if (n[o].start >= s) {\n      a = new Date(i.getFullYear(), i.getMonth(), i.getDate(), 0, 0, n[o].start);\n      break;\n    }\n  } else for (o = n.length - 1; o >= 0; o--) {\n    if (n[o].end <= s) {\n      a = new Date(i.getFullYear(), i.getMonth(), i.getDate(), 0, 0, n[o].end);\n      break;\n    }\n    if (n[o].end > s && n[o].start <= s) {\n      a = new Date(i.getFullYear(), i.getMonth(), i.getDate(), 0, 0, s);\n      break;\n    }\n  }\n  return a;\n}, _getClosestWorkMinute: function(t, e, n) {\n  var i = new Date(t), a = this._getWorkHours(i), r = this._findClosestTimeInDay(i, n, a);\n  return r || (n > 0 ? (i = this.calculateEndDate(i, n, e), i = this.$gantt.date.day_start(i)) : (i = this.calculateEndDate(i, n, \"day\"), i = this.$gantt.date.day_start(i), i = this.$gantt.date.add(i, 1, \"day\"), i = new Date(i.valueOf() - 1)), a = this._getWorkHours(i), r = this._findClosestTimeInDay(i, n, a)), n < 0 && (r = this.$gantt.date.add(r, -1, e)), r;\n}, _getClosestWorkTimeGeneric: function(t, e, n) {\n  if (e === \"hour\" || e === \"minute\") return this._getClosestWorkMinute(t, e, n);\n  for (var i = this._getUnitOrder(e), a = this.units[i - 1], r = t, s = 0; !this._isWorkTime(r, e) && (!a || this._isWorkTime(r, a) || (r = n > 0 ? this._getClosestWorkTimeFuture(r, a) : this._getClosestWorkTimePast(r, a), !this._isWorkTime(r, e))); ) {\n    if (++s > 3e3) return this.$gantt.assert(!1, \"Invalid working time check\"), !1;\n    var o = r.getTimezoneOffset();\n    r = this.$gantt.date.add(r, n, e), r = this.$gantt._correct_dst_change(r, o, n, e), this.$gantt.date[e + \"_start\"] && (r = this.$gantt.date[e + \"_start\"](r));\n  }\n  return r;\n}, hasWorkTime: function() {\n  var t = this.getConfig(), e = t.dates;\n  for (var n in t.dates) ;\n  var i = this._checkWorkHours(t.hours), a = !1;\n  return [0, 1, 2, 3, 4, 5, 6].forEach((function(r) {\n    if (!a) {\n      var s = e[r];\n      s === !0 ? a = i : Array.isArray(s) && (a = this._checkWorkHours(s));\n    }\n  }).bind(this)), a;\n}, _checkWorkHours: function(t) {\n  if (t.length === 0) return !1;\n  for (var e = !1, n = 0; n < t.length; n += 2) t[n] !== t[n + 1] && (e = !0);\n  return e;\n}, _isMinutePrecision: function(t) {\n  let e = !1;\n  return this._getWorkHours(t).forEach(function(n) {\n    (n.startMinute % 60 || n.endMinute % 60) && (e = !0);\n  }), e;\n} };\nconst It = { isLegacyResourceCalendarFormat: function(t) {\n  if (!t) return !1;\n  for (var e in t) if (t[e] && typeof t[e] == \"object\") return !0;\n  return !1;\n}, getResourceProperty: function(t) {\n  var e = t.resource_calendars, n = t.resource_property;\n  if (this.isLegacyResourceCalendarFormat(e)) for (var i in t) {\n    n = i;\n    break;\n  }\n  return n;\n}, getCalendarIdFromLegacyConfig: function(t, e) {\n  if (e) for (var n in e) {\n    var i = e[n];\n    if (t[n]) {\n      var a = i[t[n]];\n      if (a) return a;\n    }\n  }\n  return null;\n} }, bi = (Wt = {}, { getCalendarIdFromMultipleResources: function(t, e) {\n  var n = function(a) {\n    return a.map(function(r) {\n      return r && r.resource_id ? r.resource_id : r;\n    }).sort().join(\"-\");\n  }(t);\n  if (t.length) {\n    if (t.length === 1) return e.getResourceCalendar(n).id;\n    if (Wt[n]) return Wt[n].id;\n    var i = function(a, r) {\n      return r.mergeCalendars(a.map(function(s) {\n        var o = s && s.resource_id ? s.resource_id : s;\n        return r.getResourceCalendar(o);\n      }));\n    }(t, e);\n    return Wt[n] = i, e.addCalendar(i);\n  }\n  return null;\n} });\nvar Wt;\nfunction fn(t) {\n  this.$gantt = t, this._calendars = {}, this._legacyConfig = void 0, this.$gantt.attachEvent(\"onGanttReady\", (function() {\n    this.$gantt.config.resource_calendars && (this._isLegacyConfig = It.isLegacyResourceCalendarFormat(this.$gantt.config.resource_calendars));\n  }).bind(this)), this.$gantt.attachEvent(\"onBeforeGanttReady\", (function() {\n    this.createDefaultCalendars();\n  }).bind(this)), this.$gantt.attachEvent(\"onBeforeGanttRender\", (function() {\n    this.createDefaultCalendars();\n  }).bind(this));\n}\nfunction be(t, e) {\n  this.argumentsHelper = e, this.$gantt = t;\n}\nfunction pn(t) {\n  this.$gantt = t.$gantt, this.argumentsHelper = _n(this.$gantt), this.calendarManager = t, this.$disabledCalendar = new be(this.$gantt, this.argumentsHelper);\n}\nfn.prototype = { _calendars: {}, _convertWorkTimeSettings: function(t) {\n  var e = t.days;\n  if (e && !t.dates) {\n    t.dates = t.dates || {};\n    for (var n = 0; n < e.length; n++) t.dates[n] = e[n], e[n] instanceof Array || (t.dates[n] = !!e[n]);\n  }\n  return delete t.days, t;\n}, mergeCalendars: function() {\n  var t = [], e = arguments;\n  if (Array.isArray(e[0])) t = e[0].slice();\n  else for (var n = 0; n < arguments.length; n++) t.push(arguments[n]);\n  var i, a = new gn();\n  return t.forEach((function(r) {\n    i = i ? this._createCalendarFromConfig(a.merge(i, r)) : r;\n  }).bind(this)), this.createCalendar(i);\n}, _createCalendarFromConfig: function(t) {\n  var e = new ye(this.$gantt, _n(this.$gantt));\n  e.id = String(st());\n  var n = this._convertWorkTimeSettings(t);\n  if (n.customWeeks) for (var i in n.customWeeks) n.customWeeks[i] = this._convertWorkTimeSettings(n.customWeeks[i]);\n  return e._setConfig(n), e;\n}, createCalendar: function(t) {\n  var e;\n  return t || (t = {}), P(e = t.getConfig ? q(t.getConfig()) : t.worktime ? q(t.worktime) : q(t), q(this.defaults.fulltime.worktime)), this._createCalendarFromConfig(e);\n}, getCalendar: function(t) {\n  t = t || \"global\";\n  var e = this._calendars[t];\n  return e || (this.createDefaultCalendars(), e = this._calendars[t]), e;\n}, getCalendars: function() {\n  var t = [];\n  for (var e in this._calendars) t.push(this.getCalendar(e));\n  return t;\n}, _getOwnCalendar: function(t) {\n  var e = this.$gantt.config;\n  if (t[e.calendar_property]) return this.getCalendar(t[e.calendar_property]);\n  if (e.resource_calendars) {\n    var n;\n    if (n = this._legacyConfig === !1 ? e.resource_property : It.getResourceProperty(e), Array.isArray(t[n])) e.dynamic_resource_calendars ? i = bi.getCalendarIdFromMultipleResources(t[n], this) : a = this.getResourceCalendar(t[n]);\n    else if (this._legacyConfig === void 0 && (this._legacyConfig = It.isLegacyResourceCalendarFormat(e.resource_calendars)), this._legacyConfig) var i = It.getCalendarIdFromLegacyConfig(t, e.resource_calendars);\n    else if (n && t[n] && e.resource_calendars[t[n]]) var a = this.getResourceCalendar(t[n]);\n    if (i && (a = this.getCalendar(i)), a) return a;\n  }\n  return null;\n}, getResourceCalendar: function(t) {\n  if (t == null) return this.getCalendar();\n  var e = null;\n  e = typeof t == \"number\" || typeof t == \"string\" ? t : t.id || t.key;\n  var n = this.$gantt.config, i = n.resource_calendars, a = null;\n  if (Array.isArray(t) && t.length === 1 && (e = typeof t[0] == \"object\" ? t[0].resource_id : t[0]), i) {\n    if (this._legacyConfig === void 0 && (this._legacyConfig = It.isLegacyResourceCalendarFormat(n.resource_calendars)), this._legacyConfig) {\n      for (var r in i) if (i[r][e]) {\n        a = i[r][e];\n        break;\n      }\n    } else a = i[e];\n    if (a) return this.getCalendar(a);\n  }\n  return this.getCalendar();\n}, getTaskCalendar: function(t) {\n  var e, n = this.$gantt;\n  if (t == null) return this.getCalendar();\n  if (!(e = typeof t != \"number\" && typeof t != \"string\" || !n.isTaskExists(t) ? t : n.getTask(t))) return this.getCalendar();\n  var i = this._getOwnCalendar(e), a = !!n.getState().group_mode;\n  if (!i && n.config.inherit_calendar && n.isTaskExists(e.parent)) {\n    for (var r = e; n.isTaskExists(r.parent) && (r = n.getTask(r.parent), !n.isSummaryTask(r) || !(i = this._getOwnCalendar(r))); ) ;\n    a && !i && t.$effective_calendar && (i = this.getCalendar(t.$effective_calendar));\n  }\n  return i || this.getCalendar();\n}, addCalendar: function(t) {\n  if (!this.isCalendar(t)) {\n    var e = t.id;\n    (t = this.createCalendar(t)).id = e;\n  }\n  if (t._tryChangeCalendarSettings(function() {\n  })) {\n    var n = this.$gantt.config;\n    return t.id = t.id || st(), this._calendars[t.id] = t, n.worktimes || (n.worktimes = {}), n.worktimes[t.id] = t.getConfig(), t.id;\n  }\n  return this.$gantt.callEvent(\"onCalendarError\", [{ message: \"Invalid calendar settings, no worktime available\" }, t]), null;\n}, deleteCalendar: function(t) {\n  var e = this.$gantt.config;\n  return !!t && !!this._calendars[t] && (delete this._calendars[t], e.worktimes && e.worktimes[t] && delete e.worktimes[t], !0);\n}, restoreConfigCalendars: function(t) {\n  for (var e in t) if (!this._calendars[e]) {\n    var n = t[e], i = this.createCalendar(n);\n    i.id = e, this.addCalendar(i);\n  }\n}, defaults: { global: { id: \"global\", worktime: { hours: [8, 12, 13, 17], days: [0, 1, 1, 1, 1, 1, 0] } }, fulltime: { id: \"fulltime\", worktime: { hours: [0, 24], days: [1, 1, 1, 1, 1, 1, 1] } } }, createDefaultCalendars: function() {\n  var t = this.$gantt.config;\n  this.restoreConfigCalendars(this.defaults), this.restoreConfigCalendars(t.worktimes);\n}, isCalendar: function(t) {\n  return [t.isWorkTime, t.setWorkTime, t.getWorkHours, t.unsetWorkTime, t.getClosestWorkTime, t.calculateDuration, t.hasDuration, t.calculateEndDate].every(function(e) {\n    return e instanceof Function;\n  });\n} }, be.prototype = { getWorkHours: function() {\n  return [0, 24];\n}, setWorkTime: function() {\n  return !0;\n}, unsetWorkTime: function() {\n  return !0;\n}, isWorkTime: function() {\n  return !0;\n}, getClosestWorkTime: function(t) {\n  return this.argumentsHelper.getClosestWorkTimeArguments.apply(this.argumentsHelper, arguments).date;\n}, calculateDuration: function() {\n  var t = this.argumentsHelper.getDurationArguments.apply(this.argumentsHelper, arguments), e = t.start_date, n = t.end_date, i = t.unit, a = t.step;\n  return this._calculateDuration(e, n, i, a);\n}, _calculateDuration: function(t, e, n, i) {\n  var a = this.$gantt.date, r = { week: 6048e5, day: 864e5, hour: 36e5, minute: 6e4 }, s = 0;\n  if (r[n]) s = Math.round((e - t) / (i * r[n]));\n  else {\n    for (var o = new Date(t), l = new Date(e); o.valueOf() < l.valueOf(); ) s += 1, o = a.add(o, i, n);\n    o.valueOf() != e.valueOf() && (s += (l - o) / (a.add(o, i, n) - o));\n  }\n  return Math.round(s);\n}, hasDuration: function() {\n  var t = this.argumentsHelper.getDurationArguments.apply(this.argumentsHelper, arguments), e = t.start_date, n = t.end_date;\n  return !!t.unit && (e = new Date(e), n = new Date(n), e.valueOf() < n.valueOf());\n}, hasWorkTime: function() {\n  return !0;\n}, equals: function(t) {\n  return t instanceof be;\n}, calculateEndDate: function() {\n  var t = this.argumentsHelper.calculateEndDateArguments.apply(this.argumentsHelper, arguments), e = t.start_date, n = t.duration, i = t.unit, a = t.step;\n  return this.$gantt.date.add(e, a * n, i);\n} }, pn.prototype = { _getCalendar: function(t) {\n  var e;\n  if (this.$gantt.config.work_time) {\n    var n = this.calendarManager;\n    t.task ? e = n.getTaskCalendar(t.task) : t.id ? e = n.getTaskCalendar(t) : t.calendar && (e = t.calendar), e || (e = n.getTaskCalendar());\n  } else e = this.$disabledCalendar;\n  return e;\n}, getWorkHours: function(t) {\n  return t = this.argumentsHelper.getWorkHoursArguments.apply(this.argumentsHelper, arguments), this._getCalendar(t).getWorkHours(t.date);\n}, setWorkTime: function(t, e) {\n  return t = this.argumentsHelper.setWorkTimeArguments.apply(this.argumentsHelper, arguments), e || (e = this.calendarManager.getCalendar()), e.setWorkTime(t);\n}, unsetWorkTime: function(t, e) {\n  return t = this.argumentsHelper.unsetWorkTimeArguments.apply(this.argumentsHelper, arguments), e || (e = this.calendarManager.getCalendar()), e.unsetWorkTime(t);\n}, isWorkTime: function(t, e, n, i) {\n  var a = this.argumentsHelper.isWorkTimeArguments.apply(this.argumentsHelper, arguments);\n  return (i = this._getCalendar(a)).isWorkTime(a);\n}, getClosestWorkTime: function(t) {\n  return t = this.argumentsHelper.getClosestWorkTimeArguments.apply(this.argumentsHelper, arguments), this._getCalendar(t).getClosestWorkTime(t);\n}, calculateDuration: function() {\n  var t = this.argumentsHelper.getDurationArguments.apply(this.argumentsHelper, arguments);\n  return this._getCalendar(t).calculateDuration(t);\n}, hasDuration: function() {\n  var t = this.argumentsHelper.hasDurationArguments.apply(this.argumentsHelper, arguments);\n  return this._getCalendar(t).hasDuration(t);\n}, calculateEndDate: function(t) {\n  return t = this.argumentsHelper.calculateEndDateArguments.apply(this.argumentsHelper, arguments), this._getCalendar(t).calculateEndDate(t);\n} };\nconst xi = function(t, e) {\n  return { getWorkHours: function(n) {\n    return e.getWorkHours(n);\n  }, setWorkTime: function(n) {\n    return e.setWorkTime(n);\n  }, unsetWorkTime: function(n) {\n    e.unsetWorkTime(n);\n  }, isWorkTime: function(n, i, a) {\n    return e.isWorkTime(n, i, a);\n  }, getClosestWorkTime: function(n) {\n    return e.getClosestWorkTime(n);\n  }, calculateDuration: function(n, i, a) {\n    return e.calculateDuration(n, i, a);\n  }, _hasDuration: function(n, i, a) {\n    return e.hasDuration(n, i, a);\n  }, calculateEndDate: function(n, i, a, r) {\n    return e.calculateEndDate(n, i, a, r);\n  }, mergeCalendars: R(t.mergeCalendars, t), createCalendar: R(t.createCalendar, t), addCalendar: R(t.addCalendar, t), getCalendar: R(t.getCalendar, t), getCalendars: R(t.getCalendars, t), getResourceCalendar: R(t.getResourceCalendar, t), getTaskCalendar: R(t.getTaskCalendar, t), deleteCalendar: R(t.deleteCalendar, t) };\n};\nfunction $i(t) {\n  t.isUnscheduledTask = function(s) {\n    return t.assert(s && s instanceof Object, \"Invalid argument <b>task</b>=\" + s + \" of gantt.isUnscheduledTask. Task object was expected\"), !!s.unscheduled || !s.start_date;\n  }, t._isAllowedUnscheduledTask = function(s) {\n    return !(!s.unscheduled || !t.config.show_unscheduled);\n  }, t._isTaskInTimelineLimits = function(s) {\n    var o = s.start_date ? s.start_date.valueOf() : null, l = s.end_date ? s.end_date.valueOf() : null;\n    return !!(o && l && o <= this._max_date.valueOf() && l >= this._min_date.valueOf());\n  }, t.isTaskVisible = function(s) {\n    if (!this.isTaskExists(s)) return !1;\n    var o = this.getTask(s);\n    return !(!this._isAllowedUnscheduledTask(o) && !this._isTaskInTimelineLimits(o)) && this.getGlobalTaskIndex(s) >= 0;\n  }, t._getProjectEnd = function() {\n    if (t.config.project_end) return t.config.project_end;\n    var s = t.getTaskByTime();\n    return (s = s.sort(function(o, l) {\n      return +o.end_date > +l.end_date ? 1 : -1;\n    })).length ? s[s.length - 1].end_date : null;\n  }, t._getProjectStart = function() {\n    if (t.config.project_start) return t.config.project_start;\n    if (t.config.start_date) return t.config.start_date;\n    if (t.getState().min_date) return t.getState().min_date;\n    var s = t.getTaskByTime();\n    return (s = s.sort(function(o, l) {\n      return +o.start_date > +l.start_date ? 1 : -1;\n    })).length ? s[0].start_date : null;\n  };\n  var e = function(s, o) {\n    var l = !!(o && o != t.config.root_id && t.isTaskExists(o)) && t.getTask(o), d = null;\n    if (l) if (t.config.schedule_from_end) d = t.calculateEndDate({ start_date: l.end_date, duration: -t.config.duration_step, task: s });\n    else {\n      if (!l.start_date) return e(l, t.getParent(l));\n      d = l.start_date;\n    }\n    else if (t.config.schedule_from_end) d = t.calculateEndDate({ start_date: t._getProjectEnd(), duration: -t.config.duration_step, task: s });\n    else {\n      const c = t.getTaskByIndex(0), u = t.config.start_date || t.getState().min_date;\n      d = c ? c.start_date ? c.start_date : c.end_date ? t.calculateEndDate({ start_date: c.end_date, duration: -t.config.duration_step, task: s }) : u : u;\n    }\n    return t.assert(d, \"Invalid dates\"), new Date(d);\n  };\n  t._set_default_task_timing = function(s) {\n    s.start_date = s.start_date || e(s, t.getParent(s)), s.duration = s.duration || t.config.duration_step, s.end_date = s.end_date || t.calculateEndDate(s);\n  }, t.createTask = function(s, o, l) {\n    if (s = s || {}, t.defined(s.id) || (s.id = t.uid()), s.start_date || (s.start_date = e(s, o)), s.text === void 0 && (s.text = t.locale.labels.new_task), s.duration === void 0 && (s.duration = 1), this.isTaskExists(o)) {\n      this.setParent(s, o, !0);\n      var d = this.getTask(o);\n      d.$open = !0, this.config.details_on_create || this.callEvent(\"onAfterParentExpand\", [o, d]);\n    }\n    return this.callEvent(\"onTaskCreated\", [s]) ? (this.config.details_on_create ? (t.isTaskExists(s.id) ? t.getTask(s.id).$index != s.$index && (s.start_date && typeof s.start_date == \"string\" && (s.start_date = this.date.parseDate(s.start_date, \"parse_date\")), s.end_date && typeof s.end_date == \"string\" && (s.end_date = this.date.parseDate(s.end_date, \"parse_date\")), this.$data.tasksStore.updateItem(s.id, s)) : (s.$new = !0, this.silent(function() {\n      t.$data.tasksStore.addItem(s, l);\n    })), this.selectTask(s.id), this.refreshData(), this.showLightbox(s.id)) : this.addTask(s, o, l) && (this.showTask(s.id), this.selectTask(s.id)), s.id) : null;\n  }, t._update_flags = function(s, o) {\n    var l = t.$data.tasksStore;\n    s === void 0 ? (this._lightbox_id = null, l.silent(function() {\n      l.unselect();\n    }), this.getSelectedTasks && this._multiselect.reset(), this._tasks_dnd && this._tasks_dnd.drag && (this._tasks_dnd.drag.id = null)) : (this._lightbox_id == s && (this._lightbox_id = o), l.getSelectedId() == s && l.silent(function() {\n      l.unselect(s), l.select(o);\n    }), this._tasks_dnd && this._tasks_dnd.drag && this._tasks_dnd.drag.id == s && (this._tasks_dnd.drag.id = o));\n  };\n  var n = function(s, o) {\n    var l = t.getTaskType(s.type), d = { type: l, $no_start: !1, $no_end: !1, scheduled_summary: !1 };\n    return l === t.config.types.project && s.auto_scheduling === !1 && (d.scheduled_summary = !0), o || l != s.$rendered_type ? (l == t.config.types.project ? d.$no_end = d.$no_start = !0 : l != t.config.types.milestone && (d.$no_end = !(s.end_date || s.duration), d.$no_start = !s.start_date, t._isAllowedUnscheduledTask(s) && (d.$no_end = d.$no_start = !1)), d) : (d.$no_start = s.$no_start, d.$no_end = s.$no_end, d);\n  };\n  function i(s) {\n    s.$effective_calendar = t.getTaskCalendar(s).id, s.start_date = t.getClosestWorkTime({ dir: \"future\", date: s.start_date, unit: t.config.duration_unit, task: s }), s.end_date = t.calculateEndDate(s);\n  }\n  function a(s, o, l, d) {\n    const c = { start: \"start_date\", end: \"end_date\" }, u = { start: \"$auto_start_date\", end: \"$auto_end_date\" };\n    let h;\n    h = s.type === t.config.types.project && s.auto_scheduling === !1 ? u : c, o.$no_start && (s[h.start] = l ? new Date(l) : e(s, this.getParent(s))), o.$no_end && (s[h.end] = d ? new Date(d) : this.calculateEndDate({ start_date: s[h.start], duration: this.config.duration_step, task: s })), (o.$no_start || o.$no_end) && this._init_task_timing(s);\n  }\n  function r(s) {\n    var o = null, l = null, d = s !== void 0 ? s : t.config.root_id, c = [];\n    return t.eachTask(function(u) {\n      const h = t.getTaskType(u.type) == t.config.types.project && u.auto_scheduling === !1;\n      t.getTaskType(u.type) == t.config.types.project && !h || t.isUnscheduledTask(u) || (u.rollup && c.push(u.id), !u.start_date || u.$no_start && !h || o && !(o > u.start_date.valueOf()) || (o = u.start_date.valueOf()), !u.end_date || u.$no_end && !h || l && !(l < u.end_date.valueOf()) || (l = u.end_date.valueOf()));\n    }, d), { start_date: o ? new Date(o) : null, end_date: l ? new Date(l) : null, rollup: c };\n  }\n  t._init_task_timing = function(s) {\n    var o = n(s, !0), l = s.$rendered_type != o.type, d = o.type;\n    l && (s.$no_start = o.$no_start, s.$no_end = o.$no_end, s.$rendered_type = o.type), l && d != this.config.types.milestone && d == this.config.types.project && (this._set_default_task_timing(s), s.$calculate_duration = !1), d == this.config.types.milestone && (s.end_date = s.start_date), s.start_date && s.end_date && s.$calculate_duration !== !1 && (s.duration = this.calculateDuration(s)), s.$calculate_duration || (s.$calculate_duration = !0), s.end_date || (s.end_date = s.start_date), s.duration = s.duration || 0, this.config.min_duration === 0 && s.duration === 0 && (s.$no_end = !1);\n    var c = this.getTaskCalendar(s);\n    s.$effective_calendar && s.$effective_calendar !== c.id && (i(s), this.config.inherit_calendar && this.isSummaryTask(s) && this.eachTask(function(u) {\n      i(u);\n    }, s.id)), s.$effective_calendar = c.id;\n  }, t.isSummaryTask = function(s) {\n    t.assert(s && s instanceof Object, \"Invalid argument <b>task</b>=\" + s + \" of gantt.isSummaryTask. Task object was expected\");\n    var o = n(s);\n    return !(!o.$no_end && !o.$no_start);\n  }, t.resetProjectDates = function(s) {\n    var o = n(s);\n    if (o.$no_end || o.$no_start) {\n      var l = r(s.id);\n      a.call(this, s, o, l.start_date, l.end_date), s.$rollup = l.rollup;\n    }\n  }, t.getSubtaskDuration = function(s) {\n    var o = 0, l = s !== void 0 ? s : t.config.root_id;\n    return this.eachTask(function(d) {\n      this.getTaskType(d.type) == t.config.types.project || this.isUnscheduledTask(d) || (o += d.duration);\n    }, l), o;\n  }, t.getSubtaskDates = function(s) {\n    var o = r(s);\n    return { start_date: o.start_date, end_date: o.end_date };\n  }, t._update_parents = function(s, o, l) {\n    if (s) {\n      var d = this.getTask(s);\n      d.rollup && (l = !0);\n      var c = this.getParent(d), u = n(d), h = !0;\n      if (l || d.start_date && d.end_date && (u.$no_start || u.$no_end)) {\n        const y = d.$auto_start_date ? \"$auto_start_date\" : \"start_date\", v = d.$auto_end_date ? \"$auto_end_date\" : \"end_date\";\n        var g = d[y].valueOf(), p = d[v].valueOf();\n        t.resetProjectDates(d), l || g != d[y].valueOf() || p != d[v].valueOf() || (h = !1), h && !o && this.refreshTask(d.id, !0), u.scheduled_summary && (h = !0);\n      }\n      h && c && this.isTaskExists(c) && this._update_parents(c, o, l);\n    }\n  }, t.roundDate = function(s) {\n    var o = t.getScale();\n    Z(s) && (s = { date: s, unit: o ? o.unit : t.config.duration_unit, step: o ? o.step : t.config.duration_step });\n    var l, d, c, u = s.date, h = s.step, g = s.unit;\n    if (!o) return u;\n    if (g == o.unit && h == o.step && +u >= +o.min_date && +u <= +o.max_date) c = Math.floor(t.columnIndexByDate(u)), o.trace_x[c] || (c -= 1, o.rtl && (c = 0)), d = new Date(o.trace_x[c]), l = t.date.add(d, h, g);\n    else {\n      for (c = Math.floor(t.columnIndexByDate(u)), l = t.date[g + \"_start\"](new Date(o.min_date)), o.trace_x[c] && (l = t.date[g + \"_start\"](o.trace_x[c])); +l < +u; ) {\n        var p = (l = t.date[g + \"_start\"](t.date.add(l, h, g))).getTimezoneOffset();\n        l = t._correct_dst_change(l, p, l, g), t.date[g + \"_start\"] && (l = t.date[g + \"_start\"](l));\n      }\n      d = t.date.add(l, -1 * h, g);\n    }\n    return s.dir && s.dir == \"future\" ? l : s.dir && s.dir == \"past\" || Math.abs(u - d) < Math.abs(l - u) ? d : l;\n  }, t.correctTaskWorkTime = function(s) {\n    t.config.work_time && t.config.correct_work_time && (this.isWorkTime(s.start_date, void 0, s) ? this.isWorkTime(new Date(+s.end_date - 1), void 0, s) || (s.end_date = this.calculateEndDate(s)) : (s.start_date = this.getClosestWorkTime({ date: s.start_date, dir: \"future\", task: s }), s.end_date = this.calculateEndDate(s)));\n  }, t.attachEvent(\"onBeforeTaskUpdate\", function(s, o) {\n    return t._init_task_timing(o), !0;\n  }), t.attachEvent(\"onBeforeTaskAdd\", function(s, o) {\n    return t._init_task_timing(o), !0;\n  }), t.attachEvent(\"onAfterTaskMove\", function(s, o, l) {\n    return t._init_task_timing(t.getTask(s)), !0;\n  });\n}\nfunction Oe(t, e) {\n  var n, i = t.config.container_resize_timeout || 20;\n  let a = Be(t);\n  if (t.config.container_resize_method == \"timeout\") l();\n  else try {\n    t.event(e, \"resize\", function() {\n      if (t.$scrollbarRepaint) t.$scrollbarRepaint = null;\n      else {\n        let d = Be(t);\n        if (a.x == d.x && a.y == d.y) return;\n        a = d, r();\n      }\n    });\n  } catch {\n    l();\n  }\n  function r() {\n    clearTimeout(n), n = setTimeout(function() {\n      t.$destroyed || t.render();\n    }, i);\n  }\n  var s = t.$root.offsetHeight, o = t.$root.offsetWidth;\n  function l() {\n    t.$root.offsetHeight == s && t.$root.offsetWidth == o || r(), s = t.$root.offsetHeight, o = t.$root.offsetWidth, setTimeout(l, i);\n  }\n}\nfunction Be(t) {\n  return { x: t.$root.offsetWidth, y: t.$root.offsetHeight };\n}\nfunction wi(t) {\n  t.assert = /* @__PURE__ */ function(r) {\n    return function(s, o) {\n      s || r.config.show_errors && r.callEvent(\"onError\", [o]) !== !1 && (r.message ? r.message({ type: \"error\", text: o, expire: -1 }) : console.log(o));\n    };\n  }(t);\n  var e = \"Invalid value of the first argument of `gantt.init`. Supported values: HTMLElement, String (element id).This error means that either invalid object is passed into `gantt.init` or that the element with the specified ID doesn't exist on the page when `gantt.init` is called.\";\n  function n(r) {\n    if (!r || typeof r == \"string\" && document.getElementById(r) || function(s) {\n      try {\n        s.cloneNode(!1);\n      } catch {\n        return !1;\n      }\n      return !0;\n    }(r)) return !0;\n    throw t.assert(!1, e), new Error(e);\n  }\n  t.init = function(r, s, o) {\n    t.env.isNode ? r = null : n(r), s && o && (this.config.start_date = this._min_date = new Date(s), this.config.end_date = this._max_date = new Date(o)), this.date.init(), this.init = function(l) {\n      t.env.isNode ? l = null : n(l), this.$container && this.$container.parentNode && (this.$container.parentNode.removeChild(this.$container), this.$container = null), this.$layout && this.$layout.clear(), this._reinit(l);\n    }, this._reinit(r);\n  }, t._quickRefresh = function(r) {\n    for (var s = this._getDatastores.call(this), o = 0; o < s.length; o++) s[o]._quick_refresh = !0;\n    for (r(), o = 0; o < s.length; o++) s[o]._quick_refresh = !1;\n  };\n  var i = (function() {\n    this._clearTaskLayers && this._clearTaskLayers(), this._clearLinkLayers && this._clearLinkLayers(), this.$layout && (this.$layout.destructor(), this.$layout = null, this.$ui.reset());\n  }).bind(t), a = (function() {\n    F(t) || (this.$root.innerHTML = \"\", this.$root.gantt = this, me(this), this.config.layout.id = \"main\", this.$layout = this.$ui.createView(\"layout\", this.$root, this.config.layout), this.$layout.attachEvent(\"onBeforeResize\", function() {\n      for (var r = t.$services.getService(\"datastores\"), s = 0; s < r.length; s++) t.getDatastore(r[s]).filter(), t.$data.tasksStore._skipTaskRecalculation ? t.$data.tasksStore._skipTaskRecalculation != \"lightbox\" && (t.$data.tasksStore._skipTaskRecalculation = !1) : t.getDatastore(r[s]).callEvent(\"onBeforeRefreshAll\", []);\n    }), this.$layout.attachEvent(\"onResize\", function() {\n      t._quickRefresh(function() {\n        t.refreshData();\n      });\n    }), this.callEvent(\"onGanttLayoutReady\", []), this.$layout.render(), this.$container = this.$layout.$container.firstChild, function(r) {\n      window.getComputedStyle(r.$root).getPropertyValue(\"position\") == \"static\" && (r.$root.style.position = \"relative\");\n      var s = document.createElement(\"iframe\");\n      s.className = \"gantt_container_resize_watcher\", s.tabIndex = -1, r.config.wai_aria_attributes && (s.setAttribute(\"role\", \"none\"), s.setAttribute(\"aria-hidden\", !0)), (window.Sfdc || window.$A || window.Aura) && (r.config.container_resize_method = \"timeout\"), r.$root.appendChild(s), s.contentWindow ? Oe(r, s.contentWindow) : (r.$root.removeChild(s), Oe(r, window));\n    }(this));\n  }).bind(t);\n  t.resetLayout = function() {\n    i(), a(), this.render();\n  }, t._reinit = function(r) {\n    this.callEvent(\"onBeforeGanttReady\", []), this._update_flags(), this.$services.getService(\"templateLoader\").initTemplates(this), i(), this.$root = null, r && (this.$root = we(r), a(), this.$mouseEvents.reset(this.$root), function(s) {\n      s.$container && !s.config.autosize && s.$root.offsetHeight < 50 && console.warn(`The Gantt container has a small height, so you cannot see its content. If it is not intended, you need to set the 'height' style rule to the container:\nhttps://docs.dhtmlx.com/gantt/faq.html#theganttchartisntrenderedcorrectly`);\n    }(t)), this.callEvent(\"onTemplatesReady\", []), this.callEvent(\"onGanttReady\", []), this.render();\n  }, t.$click = { buttons: { edit: function(r) {\n    t.isReadonly(t.getTask(r)) || t.showLightbox(r);\n  }, delete: function(r) {\n    var s = t.getTask(r);\n    if (!t.isReadonly(s)) {\n      var o = t.locale.labels.confirm_deleting, l = t.locale.labels.confirm_deleting_title;\n      t._delete_task_confirm({ task: s, message: o, title: l, callback: function() {\n        t.isTaskExists(r) && (s.$new ? (t.$data.tasksStore._skipTaskRecalculation = \"lightbox\", t.silent(function() {\n          t.deleteTask(r, !0);\n        }), t.$data.tasksStore._skipTaskRecalculation = !1, t.refreshData()) : (t.$data.tasksStore._skipTaskRecalculation = !0, t.deleteTask(r))), t.hideLightbox();\n      } });\n    }\n  } } }, t.render = function() {\n    var r;\n    if (this.callEvent(\"onBeforeGanttRender\", []), !F(t)) {\n      !this.config.sort && this._sort && (this._sort = void 0), this.$root && (this.config.rtl ? (this.$root.classList.add(\"gantt_rtl\"), this.$root.firstChild.classList.add(\"gantt_rtl\")) : (this.$root.classList.remove(\"gantt_rtl\"), this.$root.firstChild.classList.remove(\"gantt_rtl\")));\n      var s = this.getScrollState(), o = s ? s.x : 0;\n      this._getHorizontalScrollbar() && (o = this._getHorizontalScrollbar().$config.codeScrollLeft || o || 0), r = null, o && (r = t.dateFromPos(o + this.config.task_scroll_offset));\n    }\n    if (me(this), F(t)) t.refreshData();\n    else {\n      this.$layout.$config.autosize = this.config.autosize;\n      var l = this.config.preserve_scroll;\n      if (this.config.preserve_scroll = !1, this.$layout.resize(), this.config.preserve_scroll = l, this.config.preserve_scroll && s) {\n        if (o || s.y) {\n          var d = t.getScrollState();\n          if (+r != +t.dateFromPos(d.x) || d.y != s.y) {\n            o = null;\n            var c = null;\n            r && (o = Math.max(t.posFromDate(r) - t.config.task_scroll_offset, 0)), s.y && (c = s.y), t.scrollTo(o, c);\n          }\n        }\n        this.$layout.getScrollbarsInfo().forEach((u) => {\n          const h = t.$ui.getView(u.id), g = t.utils.dom.isChildOf(h.$view, t.$container);\n          u.boundViews.forEach((p) => {\n            const y = t.$ui.getView(p);\n            u.y && u.y != s.y && y && !g && y.scrollTo(void 0, 0), u.x_pos && u.x_pos != s.x && y && g && y.scrollTo(u.x_pos, void 0);\n          });\n        });\n      }\n    }\n    this.callEvent(\"onGanttRender\", []);\n  }, t.setSizes = t.render, t.getTaskRowNode = function(r) {\n    for (var s = this.$grid_data.childNodes, o = this.config.task_attribute, l = 0; l < s.length; l++)\n      if (s[l].getAttribute && s[l].getAttribute(o) == r) return s[l];\n    return null;\n  }, t.changeLightboxType = function(r) {\n    if (this.getLightboxType() == r) return !0;\n    t._silent_redraw_lightbox(r);\n  }, t._get_link_type = function(r, s) {\n    var o = null;\n    return r && s ? o = t.config.links.start_to_start : !r && s ? o = t.config.links.finish_to_start : r || s ? r && !s && (o = t.config.links.start_to_finish) : o = t.config.links.finish_to_finish, o;\n  }, t.isLinkAllowed = function(r, s, o, l) {\n    var d = null;\n    if (!(d = typeof r == \"object\" ? r : { source: r, target: s, type: this._get_link_type(o, l) }) || !(d.source && d.target && d.type) || d.source == d.target) return !1;\n    var c = !0;\n    return this.checkEvent(\"onLinkValidation\") && (c = this.callEvent(\"onLinkValidation\", [d])), c;\n  }, t._correct_dst_change = function(r, s, o, l) {\n    var d = Vt(l) * o;\n    if (d > 3600 && d < 86400) {\n      var c = r.getTimezoneOffset() - s;\n      c && (r = t.date.add(r, c, \"minute\"));\n    }\n    return r;\n  }, t.isSplitTask = function(r) {\n    return t.assert(r && r instanceof Object, \"Invalid argument <b>task</b>=\" + r + \" of gantt.isSplitTask. Task object was expected\"), this.$data.tasksStore._isSplitItem(r);\n  }, t._is_icon_open_click = function(r) {\n    if (!r) return !1;\n    var s = r.target || r.srcElement;\n    if (!s || !s.className) return !1;\n    var o = X(s);\n    return o.indexOf(\"gantt_tree_icon\") !== -1 && (o.indexOf(\"gantt_close\") !== -1 || o.indexOf(\"gantt_open\") !== -1);\n  };\n}\nconst Si = { date: { month_full: [\" \", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \" \", \" \", \" \"], month_short: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"], day_full: [\"\", \"\", \"\", \"\", \"\", \"\", \"\"], day_short: [\"\", \"\", \"\", \"\", \"\", \"\", \"\"] }, labels: { new_task: \" \", icon_save: \"\", icon_cancel: \"\", icon_details: \"\", icon_edit: \"\", icon_delete: \"\", confirm_closing: \"  ,   \", confirm_deleting: \"       \", section_description: \"\", section_time: \" \", section_type: \"Type\", section_deadline: \"Deadline\", section_baselines: \"Baselines\", column_wbs: \"WBS\", column_text: \"Task name\", column_start_date: \"Start time\", column_duration: \"Duration\", column_add: \"\", link: \"Link\", confirm_link_deleting: \"will be deleted\", link_start: \" (start)\", link_end: \" (end)\", type_task: \"Task\", type_project: \"Project\", type_milestone: \"Milestone\", minutes: \"Minutes\", hours: \"Hours\", days: \"Days\", weeks: \"Week\", months: \"Months\", years: \"Years\", message_ok: \"OK\", message_cancel: \"\", section_constraint: \"Constraint\", constraint_type: \"Constraint type\", constraint_date: \"Constraint date\", asap: \"As Soon As Possible\", alap: \"As Late As Possible\", snet: \"Start No Earlier Than\", snlt: \"Start No Later Than\", fnet: \"Finish No Earlier Than\", fnlt: \"Finish No Later Than\", mso: \"Must Start On\", mfo: \"Must Finish On\", resources_filter_placeholder: \"type to filter\", resources_filter_label: \"hide empty\", empty_state_text_link: \"Click here\", empty_state_text_description: \"to create your first task\", baselines_section_placeholder: \"Start adding a new baseline\", baselines_add_button: \"Add Baseline\", baselines_remove_button: \"Remove\", baselines_remove_all_button: \"Remove All\", deadline_enable_button: \"Set\", deadline_disable_button: \"Remove\" } }, Ti = { date: { month_full: [\"\", \"\", \"\", \"\", \"Ma\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"], month_short: [\"\", \"\", \"\", \"\", \"Ma\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"], day_full: [\"\", \"\", \"\", \"\", \"\", \"\", \"\"], day_short: [\"\", \"\", \"\", \"\", \"\", \"\", \"\"] }, labels: { new_task: \" \", icon_save: \"\", icon_cancel: \"\", icon_details: \"\", icon_edit: \"\", icon_delete: \"\", confirm_closing: \"\", confirm_deleting: \"   , ?\", section_description: \"\", section_time: \" \", section_type: \"\", section_deadline: \"Deadline\", section_baselines: \"Baselines\", column_wbs: \"\", column_text: \"\", column_start_date: \"\", column_duration: \"\", column_add: \"\", link: \"\", confirm_link_deleting: \" \", link_start: \"()\", link_end: \"()\", type_task: \"Task\", type_project: \"Project\", type_milestone: \"Milestone\", minutes: \"ii\", hours: \"i\", days: \"\", weeks: \"\", months: \"\", years: \"\", message_ok: \"OK\", message_cancel: \"\", section_constraint: \"Constraint\", constraint_type: \"Constraint type\", constraint_date: \"Constraint date\", asap: \"As Soon As Possible\", alap: \"As Late As Possible\", snet: \"Start No Earlier Than\", snlt: \"Start No Later Than\", fnet: \"Finish No Earlier Than\", fnlt: \"Finish No Later Than\", mso: \"Must Start On\", mfo: \"Must Finish On\", resources_filter_placeholder: \"type to filter\", resources_filter_label: \"hide empty\", empty_state_text_link: \"Click here\", empty_state_text_description: \"to create your first task\", baselines_section_placeholder: \"Start adding a new baseline\", baselines_add_button: \"Add Baseline\", baselines_remove_button: \"Remove\", baselines_remove_all_button: \"Remove All\", deadline_enable_button: \"Set\", deadline_disable_button: \"Remove\" } }, Ei = { date: { month_full: [\"Gener\", \"Febrer\", \"Mar\", \"Abril\", \"Maig\", \"Juny\", \"Juliol\", \"Agost\", \"Setembre\", \"Octubre\", \"Novembre\", \"Desembre\"], month_short: [\"Gen\", \"Feb\", \"Mar\", \"Abr\", \"Mai\", \"Jun\", \"Jul\", \"Ago\", \"Set\", \"Oct\", \"Nov\", \"Des\"], day_full: [\"Diumenge\", \"Dilluns\", \"Dimarts\", \"Dimecres\", \"Dijous\", \"Divendres\", \"Dissabte\"], day_short: [\"Dg\", \"Dl\", \"Dm\", \"Dc\", \"Dj\", \"Dv\", \"Ds\"] }, labels: { new_task: \"Nova tasca\", icon_save: \"Guardar\", icon_cancel: \"Cancellar\", icon_details: \"Detalls\", icon_edit: \"Editar\", icon_delete: \"Esborrar\", confirm_closing: \"\", confirm_deleting: \"L'esdeveniment s'esborrar definitivament, continuar ?\", section_description: \"Descripci\", section_time: \"Periode de temps\", section_type: \"Type\", section_deadline: \"Deadline\", section_baselines: \"Baselines\", column_wbs: \"WBS\", column_text: \"Task name\", column_start_date: \"Start time\", column_duration: \"Duration\", column_add: \"\", link: \"Link\", confirm_link_deleting: \"will be deleted\", link_start: \" (start)\", link_end: \" (end)\", type_task: \"Task\", type_project: \"Project\", type_milestone: \"Milestone\", minutes: \"Minutes\", hours: \"Hours\", days: \"Days\", weeks: \"Week\", months: \"Months\", years: \"Years\", message_ok: \"OK\", message_cancel: \"Cancellar\", section_constraint: \"Constraint\", constraint_type: \"Constraint type\", constraint_date: \"Constraint date\", asap: \"As Soon As Possible\", alap: \"As Late As Possible\", snet: \"Start No Earlier Than\", snlt: \"Start No Later Than\", fnet: \"Finish No Earlier Than\", fnlt: \"Finish No Later Than\", mso: \"Must Start On\", mfo: \"Must Finish On\", resources_filter_placeholder: \"type to filter\", resources_filter_label: \"hide empty\", empty_state_text_link: \"Click here\", empty_state_text_description: \"to create your first task\", baselines_section_placeholder: \"Start adding a new baseline\", baselines_add_button: \"Add Baseline\", baselines_remove_button: \"Remove\", baselines_remove_all_button: \"Remove All\", deadline_enable_button: \"Set\", deadline_disable_button: \"Remove\" } }, Ci = { date: { month_full: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"], month_short: [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"11\", \"12\"], day_full: [\"\", \"\", \"\", \"\", \"\", \"\", \"\"], day_short: [\"\", \"\", \"\", \"\", \"\", \"\", \"\"] }, labels: { new_task: \"\", icon_save: \"\", icon_cancel: \"\", icon_details: \"\", icon_edit: \"\", icon_delete: \"\", confirm_closing: \"!\", confirm_deleting: \"?\", section_description: \"\", section_time: \"\", section_type: \"\", section_deadline: \"Deadline\", section_baselines: \"Baselines\", column_wbs: \"\", column_text: \"\", column_start_date: \"\", column_duration: \"\", column_add: \"\", link: \"\", confirm_link_deleting: \"\", link_start: \" ()\", link_end: \" ()\", type_task: \"\", type_project: \"\", type_milestone: \"\", minutes: \"\", hours: \"\", days: \"\", weeks: \"\", months: \"\", years: \"\", message_ok: \"OK\", message_cancel: \"\", section_constraint: \"Constraint\", constraint_type: \"Constraint type\", constraint_date: \"Constraint date\", asap: \"As Soon As Possible\", alap: \"As Late As Possible\", snet: \"Start No Earlier Than\", snlt: \"Start No Later Than\", fnet: \"Finish No Earlier Than\", fnlt: \"Finish No Later Than\", mso: \"Must Start On\", mfo: \"Must Finish On\", resources_filter_placeholder: \"type to filter\", resources_filter_label: \"hide empty\", empty_state_text_link: \"Click here\", empty_state_text_description: \"to create your first task\", baselines_section_placeholder: \"Start adding a new baseline\", baselines_add_button: \"Add Baseline\", baselines_remove_button: \"Remove\", baselines_remove_all_button: \"Remove All\", deadline_enable_button: \"Set\", deadline_disable_button: \"Remove\" } }, Di = { date: { month_full: [\"Leden\", \"nor\", \"Bezen\", \"Duben\", \"Kvten\", \"erven\", \"ervenec\", \"Srpen\", \"Z\", \"jen\", \"Listopad\", \"Prosinec\"], month_short: [\"Led\", \"n\", \"Be\", \"Dub\", \"Kv\", \"er\", \"ec\", \"Srp\", \"Z\", \"j\", \"List\", \"Pro\"], day_full: [\"Nedle\", \"Pondl\", \"ter\", \"Steda\", \"tvrtek\", \"Ptek\", \"Sobota\"], day_short: [\"Ne\", \"Po\", \"t\", \"St\", \"t\", \"P\", \"So\"] }, labels: { new_task: \"Nov prce\", icon_save: \"Uloit\", icon_cancel: \"Zpt\", icon_details: \"Detail\", icon_edit: \"Edituj\", icon_delete: \"Smazat\", confirm_closing: \"\", confirm_deleting: \"Udlost bude trvale smazna, opravdu?\", section_description: \"Poznmky\", section_time: \"Doba platnosti\", section_type: \"Type\", section_deadline: \"Deadline\", section_baselines: \"Baselines\", column_wbs: \"WBS\", column_text: \"Task name\", column_start_date: \"Start time\", column_duration: \"Duration\", column_add: \"\", link: \"Link\", confirm_link_deleting: \"will be deleted\", link_start: \" (start)\", link_end: \" (end)\", type_task: \"Task\", type_project: \"Project\", type_milestone: \"Milestone\", minutes: \"Minutes\", hours: \"Hours\", days: \"Days\", weeks: \"Week\", months: \"Months\", years: \"Years\", message_ok: \"OK\", message_cancel: \"Zpt\", section_constraint: \"Constraint\", constraint_type: \"Constraint type\", constraint_date: \"Constraint date\", asap: \"As Soon As Possible\", alap: \"As Late As Possible\", snet: \"Start No Earlier Than\", snlt: \"Start No Later Than\", fnet: \"Finish No Earlier Than\", fnlt: \"Finish No Later Than\", mso: \"Must Start On\", mfo: \"Must Finish On\", resources_filter_placeholder: \"type to filter\", resources_filter_label: \"hide empty\", empty_state_text_link: \"Click here\", empty_state_text_description: \"to create your first task\", baselines_section_placeholder: \"Start adding a new baseline\", baselines_add_button: \"Add Baseline\", baselines_remove_button: \"Remove\", baselines_remove_all_button: \"Remove All\", deadline_enable_button: \"Set\", deadline_disable_button: \"Remove\" } }, Ai = { date: { month_full: [\"Januar\", \"Februar\", \"Marts\", \"April\", \"Maj\", \"Juni\", \"Juli\", \"August\", \"September\", \"Oktober\", \"November\", \"December\"], month_short: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"Maj\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Okt\", \"Nov\", \"Dec\"], day_full: [\"Sndag\", \"Mandag\", \"Tirsdag\", \"Onsdag\", \"Torsdag\", \"Fredag\", \"Lrdag\"], day_short: [\"Sn\", \"Man\", \"Tir\", \"Ons\", \"Tor\", \"Fre\", \"Lr\"] }, labels: { new_task: \"Ny opgave\", icon_save: \"Gem\", icon_cancel: \"Fortryd\", icon_details: \"Detaljer\", icon_edit: \"Tilret\", icon_delete: \"Slet\", confirm_closing: \"Dine rettelser vil g tabt.. Er dy sikker?\", confirm_deleting: \"Bigivenheden vil blive slettet permanent. Er du sikker?\", section_description: \"Beskrivelse\", section_time: \"Tidsperiode\", section_type: \"Type\", section_deadline: \"Deadline\", section_baselines: \"Baselines\", column_wbs: \"WBS\", column_text: \"Task name\", column_start_date: \"Start time\", column_duration: \"Duration\", column_add: \"\", link: \"Link\", confirm_link_deleting: \"will be deleted\", link_start: \" (start)\", link_end: \" (end)\", type_task: \"Task\", type_project: \"Project\", type_milestone: \"Milestone\", minutes: \"Minutes\", hours: \"Hours\", days: \"Days\", weeks: \"Week\", months: \"Months\", years: \"Years\", message_ok: \"OK\", message_cancel: \"Fortryd\", section_constraint: \"Constraint\", constraint_type: \"Constraint type\", constraint_date: \"Constraint date\", asap: \"As Soon As Possible\", alap: \"As Late As Possible\", snet: \"Start No Earlier Than\", snlt: \"Start No Later Than\", fnet: \"Finish No Earlier Than\", fnlt: \"Finish No Later Than\", mso: \"Must Start On\", mfo: \"Must Finish On\", resources_filter_placeholder: \"type to filter\", resources_filter_label: \"hide empty\", empty_state_text_link: \"Click here\", empty_state_text_description: \"to create your first task\", baselines_section_placeholder: \"Start adding a new baseline\", baselines_add_button: \"Add Baseline\", baselines_remove_button: \"Remove\", baselines_remove_all_button: \"Remove All\", deadline_enable_button: \"Set\", deadline_disable_button: \"Remove\" } }, Ii = { date: { month_full: [\" Januar\", \" Februar\", \" Mrz \", \" April\", \" Mai\", \" Juni\", \" Juli\", \" August\", \" September \", \" Oktober\", \" November \", \" Dezember\"], month_short: [\"Jan\", \"Feb\", \"Mr\", \"Apr\", \"Mai\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Okt\", \"Nov\", \"Dez\"], day_full: [\"Sonntag\", \"Montag\", \"Dienstag\", \" Mittwoch\", \" Donnerstag\", \"Freitag\", \"Samstag\"], day_short: [\"So\", \"Mo\", \"Di\", \"Mi\", \"Do\", \"Fr\", \"Sa\"] }, labels: { new_task: \"Neue Aufgabe\", icon_save: \"Speichern\", icon_cancel: \"Abbrechen\", icon_details: \"Details\", icon_edit: \"ndern\", icon_delete: \"Lschen\", confirm_closing: \"\", confirm_deleting: \"Der Eintrag wird gelscht\", section_description: \"Beschreibung\", section_time: \"Zeitspanne\", section_type: \"Type\", section_deadline: \"Deadline\", section_baselines: \"Baselines\", column_wbs: \"PSP\", column_text: \"Task-Namen\", column_start_date: \"Startzeit\", column_duration: \"Dauer\", column_add: \"\", link: \"Link\", confirm_link_deleting: \"werden gelscht\", link_start: \"(starten)\", link_end: \"(ende)\", type_task: \"Task\", type_project: \"Project\", type_milestone: \"Milestone\", minutes: \"Minuten\", hours: \"Stunden\", days: \"Tage\", weeks: \"Wochen\", months: \"Monate\", years: \"Jahre\", message_ok: \"OK\", message_cancel: \"Abbrechen\", section_constraint: \"Regel\", constraint_type: \"Regel\", constraint_date: \"Regel - Datum\", asap: \"So bald wie mglich\", alap: \"So spt wie mglich\", snet: \"Beginn nicht vor\", snlt: \"Beginn nicht spter als\", fnet: \"Fertigstellung nicht vor\", fnlt: \"Fertigstellung nicht spter als\", mso: \"Muss beginnen am\", mfo: \"Muss fertig sein am\", resources_filter_placeholder: \"type to filter\", resources_filter_label: \"hide empty\", empty_state_text_link: \"Click here\", empty_state_text_description: \"to create your first task\", baselines_section_placeholder: \"Start adding a new baseline\", baselines_add_button: \"Add Baseline\", baselines_remove_button: \"Remove\", baselines_remove_all_button: \"Remove All\", deadline_enable_button: \"Set\", deadline_disable_button: \"Remove\" } }, Mi = { date: { month_full: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"], month_short: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"], day_full: [\"\", \"\", \"\", \"\", \"\", \"\", \"\"], day_short: [\"\", \"\", \"\", \"\", \"\", \"\", \"\"] }, labels: { new_task: \" \", icon_save: \"\", icon_cancel: \"\", icon_details: \"\", icon_edit: \"\", icon_delete: \"\", confirm_closing: \"\", confirm_deleting: \"    .   ;\", section_description: \"\", section_time: \" \", section_type: \"Type\", section_deadline: \"Deadline\", section_baselines: \"Baselines\", column_wbs: \"WBS\", column_text: \"Task name\", column_start_date: \"Start time\", column_duration: \"Duration\", column_add: \"\", link: \"Link\", confirm_link_deleting: \"will be deleted\", link_start: \" (start)\", link_end: \" (end)\", type_task: \"Task\", type_project: \"Project\", type_milestone: \"Milestone\", minutes: \"Minutes\", hours: \"Hours\", days: \"Days\", weeks: \"Week\", months: \"Months\", years: \"Years\", message_ok: \"OK\", message_cancel: \"\", section_constraint: \"Constraint\", constraint_type: \"Constraint type\", constraint_date: \"Constraint date\", asap: \"As Soon As Possible\", alap: \"As Late As Possible\", snet: \"Start No Earlier Than\", snlt: \"Start No Later Than\", fnet: \"Finish No Earlier Than\", fnlt: \"Finish No Later Than\", mso: \"Must Start On\", mfo: \"Must Finish On\", resources_filter_placeholder: \"type to filter\", resources_filter_label: \"hide empty\", empty_state_text_link: \"Click here\", empty_state_text_description: \"to create your first task\", baselines_section_placeholder: \"Start adding a new baseline\", baselines_add_button: \"Add Baseline\", baselines_remove_button: \"Remove\", baselines_remove_all_button: \"Remove All\", deadline_enable_button: \"Set\", deadline_disable_button: \"Remove\" } }, Ni = { date: { month_full: [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"], month_short: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"], day_full: [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"], day_short: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"] }, labels: { new_task: \"New task\", icon_save: \"Save\", icon_cancel: \"Cancel\", icon_details: \"Details\", icon_edit: \"Edit\", icon_delete: \"Delete\", confirm_closing: \"\", confirm_deleting: \"Task will be deleted permanently, are you sure?\", section_description: \"Description\", section_time: \"Time period\", section_type: \"Type\", section_deadline: \"Deadline\", section_baselines: \"Baselines\", column_wbs: \"WBS\", column_text: \"Task name\", column_start_date: \"Start time\", column_duration: \"Duration\", column_add: \"\", link: \"Link\", confirm_link_deleting: \"will be deleted\", link_start: \" (start)\", link_end: \" (end)\", type_task: \"Task\", type_project: \"Project\", type_milestone: \"Milestone\", minutes: \"Minutes\", hours: \"Hours\", days: \"Days\", weeks: \"Week\", months: \"Months\", years: \"Years\", message_ok: \"OK\", message_cancel: \"Cancel\", section_constraint: \"Constraint\", constraint_type: \"Constraint type\", constraint_date: \"Constraint date\", asap: \"As Soon As Possible\", alap: \"As Late As Possible\", snet: \"Start No Earlier Than\", snlt: \"Start No Later Than\", fnet: \"Finish No Earlier Than\", fnlt: \"Finish No Later Than\", mso: \"Must Start On\", mfo: \"Must Finish On\", resources_filter_placeholder: \"type to filter\", resources_filter_label: \"hide empty\", empty_state_text_link: \"Click here\", empty_state_text_description: \"to create your first task\", baselines_section_placeholder: \"Start adding a new baseline\", baselines_add_button: \"Add Baseline\", baselines_remove_button: \"Remove\", baselines_remove_all_button: \"Remove All\", deadline_enable_button: \"Set\", deadline_disable_button: \"Remove\" } }, Li = { date: { month_full: [\"Enero\", \"Febrero\", \"Marzo\", \"Abril\", \"Mayo\", \"Junio\", \"Julio\", \"Agosto\", \"Septiembre\", \"Octubre\", \"Noviembre\", \"Diciembre\"], month_short: [\"Ene\", \"Feb\", \"Mar\", \"Abr\", \"May\", \"Jun\", \"Jul\", \"Ago\", \"Sep\", \"Oct\", \"Nov\", \"Dic\"], day_full: [\"Domingo\", \"Lunes\", \"Martes\", \"Mircoles\", \"Jueves\", \"Viernes\", \"Sbado\"], day_short: [\"Dom\", \"Lun\", \"Mar\", \"Mi\", \"Jue\", \"Vie\", \"Sb\"] }, labels: { new_task: \"Nueva tarea\", icon_save: \"Guardar\", icon_cancel: \"Cancelar\", icon_details: \"Detalles\", icon_edit: \"Editar\", icon_delete: \"Eliminar\", confirm_closing: \"\", confirm_deleting: \"El evento se borrar definitivamente, continuar?\", section_description: \"Descripcin\", section_time: \"Perodo\", section_type: \"Tipo\", section_deadline: \"Deadline\", section_baselines: \"Baselines\", column_wbs: \"EDT\", column_text: \"Tarea\", column_start_date: \"Inicio\", column_duration: \"Duracin\", column_add: \"\", link: \"Enlace\", confirm_link_deleting: \"ser borrada\", link_start: \" (inicio)\", link_end: \" (fin)\", type_task: \"Tarea\", type_project: \"Proyecto\", type_milestone: \"Hito\", minutes: \"Minutos\", hours: \"Horas\", days: \"Das\", weeks: \"Semanas\", months: \"Meses\", years: \"Aos\", message_ok: \"OK\", message_cancel: \"Cancelar\", section_constraint: \"Constraint\", constraint_type: \"Constraint type\", constraint_date: \"Constraint date\", asap: \"As Soon As Possible\", alap: \"As Late As Possible\", snet: \"Start No Earlier Than\", snlt: \"Start No Later Than\", fnet: \"Finish No Earlier Than\", fnlt: \"Finish No Later Than\", mso: \"Must Start On\", mfo: \"Must Finish On\", resources_filter_placeholder: \"type to filter\", resources_filter_label: \"hide empty\", empty_state_text_link: \"Click here\", empty_state_text_description: \"to create your first task\", baselines_section_placeholder: \"Start adding a new baseline\", baselines_add_button: \"Add Baseline\", baselines_remove_button: \"Remove\", baselines_remove_all_button: \"Remove All\", deadline_enable_button: \"Set\", deadline_disable_button: \"Remove\" } }, Pi = { date: { month_full: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"], month_short: [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"11\", \"12\"], day_full: [\"\", \"\", \"\", \"\", \"\", \"\", \"\"], day_short: [\"\", \"\", \"\", \"\", \"\", \"\", \"\"] }, labels: { new_task: \" \", icon_save: \"\", icon_cancel: \"\", icon_details: \"\", icon_edit: \"\", icon_delete: \"\", confirm_closing: \"       \", confirm_deleting: \"         \", section_description: \"\", section_time: \" \", section_type: \"\", section_deadline: \"Deadline\", section_baselines: \"Baselines\", column_wbs: \"WBS\", column_text: \"\", column_start_date: \" \", column_duration: \"\", column_add: \"\", link: \"\", confirm_link_deleting: \"  \", link_start: \" ()\", link_end: \" ()\", type_task: \"\", type_project: \"\", type_milestone: \"\", minutes: \"\", hours: \"\", days: \"\", weeks: \"\", months: \"\", years: \"\", message_ok: \"\", message_cancel: \"\", section_constraint: \"Constraint\", constraint_type: \"Constraint type\", constraint_date: \"Constraint date\", asap: \"As Soon As Possible\", alap: \"As Late As Possible\", snet: \"Start No Earlier Than\", snlt: \"Start No Later Than\", fnet: \"Finish No Earlier Than\", fnlt: \"Finish No Later Than\", mso: \"Must Start On\", mfo: \"Must Finish On\", resources_filter_placeholder: \"type to filter\", resources_filter_label: \"hide empty\", empty_state_text_link: \"Click here\", empty_state_text_description: \"to create your first task\", baselines_section_placeholder: \"Start adding a new baseline\", baselines_add_button: \"Add Baseline\", baselines_remove_button: \"Remove\", baselines_remove_all_button: \"Remove All\", deadline_enable_button: \"Set\", deadline_disable_button: \"Remove\" } }, Ri = { date: { month_full: [\"Tammikuu\", \"Helmikuu\", \"Maaliskuu\", \"Huhtikuu\", \"Toukokuu\", \"Kes&auml;kuu\", \"Hein&auml;kuu\", \"Elokuu\", \"Syyskuu\", \"Lokakuu\", \"Marraskuu\", \"Joulukuu\"], month_short: [\"Tam\", \"Hel\", \"Maa\", \"Huh\", \"Tou\", \"Kes\", \"Hei\", \"Elo\", \"Syy\", \"Lok\", \"Mar\", \"Jou\"], day_full: [\"Sunnuntai\", \"Maanantai\", \"Tiistai\", \"Keskiviikko\", \"Torstai\", \"Perjantai\", \"Lauantai\"], day_short: [\"Su\", \"Ma\", \"Ti\", \"Ke\", \"To\", \"Pe\", \"La\"] }, labels: { new_task: \"Uusi tehtv\", icon_save: \"Tallenna\", icon_cancel: \"Peru\", icon_details: \"Tiedot\", icon_edit: \"Muokkaa\", icon_delete: \"Poista\", confirm_closing: \"\", confirm_deleting: \"Haluatko varmasti poistaa tapahtuman?\", section_description: \"Kuvaus\", section_time: \"Aikajakso\", section_type: \"Type\", section_deadline: \"Deadline\", section_baselines: \"Baselines\", column_wbs: \"WBS\", column_text: \"Task name\", column_start_date: \"Start time\", column_duration: \"Duration\", column_add: \"\", link: \"Link\", confirm_link_deleting: \"will be deleted\", link_start: \" (start)\", link_end: \" (end)\", type_task: \"Task\", type_project: \"Project\", type_milestone: \"Milestone\", minutes: \"Minutes\", hours: \"Hours\", days: \"Days\", weeks: \"Week\", months: \"Months\", years: \"Years\", message_ok: \"OK\", message_cancel: \"Peru\", section_constraint: \"Constraint\", constraint_type: \"Constraint type\", constraint_date: \"Constraint date\", asap: \"As Soon As Possible\", alap: \"As Late As Possible\", snet: \"Start No Earlier Than\", snlt: \"Start No Later Than\", fnet: \"Finish No Earlier Than\", fnlt: \"Finish No Later Than\", mso: \"Must Start On\", mfo: \"Must Finish On\", resources_filter_placeholder: \"type to filter\", resources_filter_label: \"hide empty\", empty_state_text_link: \"Click here\", empty_state_text_description: \"to create your first task\", baselines_section_placeholder: \"Start adding a new baseline\", baselines_add_button: \"Add Baseline\", baselines_remove_button: \"Remove\", baselines_remove_all_button: \"Remove All\", deadline_enable_button: \"Set\", deadline_disable_button: \"Remove\" } }, Hi = { date: { month_full: [\"Janvier\", \"Fvrier\", \"Mars\", \"Avril\", \"Mai\", \"Juin\", \"Juillet\", \"Aot\", \"Septembre\", \"Octobre\", \"Novembre\", \"Dcembre\"], month_short: [\"Jan\", \"Fv\", \"Mar\", \"Avr\", \"Mai\", \"Juin\", \"Juil\", \"Ao\", \"Sep\", \"Oct\", \"Nov\", \"Dc\"], day_full: [\"Dimanche\", \"Lundi\", \"Mardi\", \"Mercredi\", \"Jeudi\", \"Vendredi\", \"Samedi\"], day_short: [\"Dim\", \"Lun\", \"Mar\", \"Mer\", \"Jeu\", \"Ven\", \"Sam\"] }, labels: { new_task: \"Nouvelle tche\", icon_save: \"Enregistrer\", icon_cancel: \"Annuler\", icon_details: \"Dtails\", icon_edit: \"Modifier\", icon_delete: \"Effacer\", confirm_closing: \"\", confirm_deleting: \"L'vnement sera effac sans appel, tes-vous sr ?\", section_description: \"Description\", section_time: \"Priode\", section_type: \"Type\", section_deadline: \"Deadline\", section_baselines: \"Baselines\", column_wbs: \"OTP\", column_text: \"Nom de la tche\", column_start_date: \"Date initiale\", column_duration: \"Dure\", column_add: \"\", link: \"Le lien\", confirm_link_deleting: \"sera supprim\", link_start: \"(dbut)\", link_end: \"(fin)\", type_task: \"Task\", type_project: \"Project\", type_milestone: \"Milestone\", minutes: \"Minutes\", hours: \"Heures\", days: \"Jours\", weeks: \"Semaines\", months: \"Mois\", years: \"Annes\", message_ok: \"OK\", message_cancel: \"Annuler\", section_constraint: \"Constraint\", constraint_type: \"Constraint type\", constraint_date: \"Constraint date\", asap: \"As Soon As Possible\", alap: \"As Late As Possible\", snet: \"Start No Earlier Than\", snlt: \"Start No Later Than\", fnet: \"Finish No Earlier Than\", fnlt: \"Finish No Later Than\", mso: \"Must Start On\", mfo: \"Must Finish On\", resources_filter_placeholder: \"type to filter\", resources_filter_label: \"hide empty\", empty_state_text_link: \"Click here\", empty_state_text_description: \"to create your first task\", baselines_section_placeholder: \"Start adding a new baseline\", baselines_add_button: \"Add Baseline\", baselines_remove_button: \"Remove\", baselines_remove_all_button: \"Remove All\", deadline_enable_button: \"Set\", deadline_disable_button: \"Remove\" } }, Oi = { date: { month_full: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"], month_short: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"], day_full: [\"\", \"\", \"\", \"\", \"\", \"\", \"\"], day_short: [\"\", \"\", \"\", \"\", \"\", \"\", \"\"] }, labels: { new_task: \" \", icon_save: \"\", icon_cancel: \"\", icon_details: \"\", icon_edit: \"\", icon_delete: \"\", confirm_closing: \"\", confirm_deleting: \"  .?\", section_description: \"\", section_time: \"\", section_type: \"Type\", section_deadline: \"Deadline\", section_baselines: \"Baselines\", column_wbs: \"WBS\", column_text: \"Task name\", column_start_date: \"Start time\", column_duration: \"Duration\", column_add: \"\", link: \"Link\", confirm_link_deleting: \"will be deleted\", link_start: \" (start)\", link_end: \" (end)\", type_task: \"Task\", type_project: \"Project\", type_milestone: \"Milestone\", minutes: \"Minutes\", hours: \"Hours\", days: \"Days\", weeks: \"Week\", months: \"Months\", years: \"Years\", message_ok: \"OK\", message_cancel: \"\", section_constraint: \"Constraint\", constraint_type: \"Constraint type\", constraint_date: \"Constraint date\", asap: \"As Soon As Possible\", alap: \"As Late As Possible\", snet: \"Start No Earlier Than\", snlt: \"Start No Later Than\", fnet: \"Finish No Earlier Than\", fnlt: \"Finish No Later Than\", mso: \"Must Start On\", mfo: \"Must Finish On\", resources_filter_placeholder: \"type to filter\", resources_filter_label: \"hide empty\", empty_state_text_link: \"Click here\", empty_state_text_description: \"to create your first task\", baselines_section_placeholder: \"Start adding a new baseline\", baselines_add_button: \"Add Baseline\", baselines_remove_button: \"Remove\", baselines_remove_all_button: \"Remove All\", deadline_enable_button: \"Set\", deadline_disable_button: \"Remove\" } }, Bi = { date: { month_full: [\"Sijeanj\", \"Veljaa\", \"Oujak\", \"Travanj\", \"Svibanj\", \"Lipanj\", \"Srpanj\", \"Kolovoz\", \"Rujan\", \"Listopad\", \"Studeni\", \"Prosinac\"], month_short: [\"Sij\", \"Velj\", \"Ou\", \"Tra\", \"Svi\", \"Lip\", \"Srp\", \"Kol\", \"Ruj\", \"Lis\", \"Stu\", \"Pro\"], day_full: [\"Nedjelja\", \"Ponedjeljak\", \"Utorak\", \"Srijeda\", \"etvrtak\", \"Petak\", \"Subota\"], day_short: [\"Ned\", \"Pon\", \"Uto\", \"Sri\", \"et\", \"Pet\", \"Sub\"] }, labels: { new_task: \"Novi Zadatak\", icon_save: \"Spremi\", icon_cancel: \"Odustani\", icon_details: \"Detalji\", icon_edit: \"Izmjeni\", icon_delete: \"Obrii\", confirm_closing: \"\", confirm_deleting: \"Zadatak e biti trajno izbrisan, jeste li sigurni?\", section_description: \"Opis\", section_time: \"Vremenski Period\", section_type: \"Tip\", section_deadline: \"Deadline\", section_baselines: \"Baselines\", column_wbs: \"WBS\", column_text: \"Naziv Zadatka\", column_start_date: \"Poetno Vrijeme\", column_duration: \"Trajanje\", column_add: \"\", link: \"Poveznica\", confirm_link_deleting: \"e biti izbrisan\", link_start: \" (poetak)\", link_end: \" (kraj)\", type_task: \"Zadatak\", type_project: \"Projekt\", type_milestone: \"Milestone\", minutes: \"Minute\", hours: \"Sati\", days: \"Dani\", weeks: \"Tjedni\", months: \"Mjeseci\", years: \"Godine\", message_ok: \"OK\", message_cancel: \"Odustani\", section_constraint: \"Constraint\", constraint_type: \"Constraint type\", constraint_date: \"Constraint date\", asap: \"As Soon As Possible\", alap: \"As Late As Possible\", snet: \"Start No Earlier Than\", snlt: \"Start No Later Than\", fnet: \"Finish No Earlier Than\", fnlt: \"Finish No Later Than\", mso: \"Must Start On\", mfo: \"Must Finish On\", resources_filter_placeholder: \"type to filter\", resources_filter_label: \"hide empty\", empty_state_text_link: \"Click here\", empty_state_text_description: \"to create your first task\", baselines_section_placeholder: \"Start adding a new baseline\", baselines_add_button: \"Add Baseline\", baselines_remove_button: \"Remove\", baselines_remove_all_button: \"Remove All\", deadline_enable_button: \"Set\", deadline_disable_button: \"Remove\" } }, zi = { date: { month_full: [\"Janur\", \"Februr\", \"Mrcius\", \"prilis\", \"Mjus\", \"Jnius\", \"Jlius\", \"Augusztus\", \"Szeptember\", \"Oktber\", \"November\", \"December\"], month_short: [\"Jan\", \"Feb\", \"Mr\", \"pr\", \"Mj\", \"Jn\", \"Jl\", \"Aug\", \"Sep\", \"Okt\", \"Nov\", \"Dec\"], day_full: [\"Vasrnap\", \"Htf\", \"Kedd\", \"Szerda\", \"Cstrtk\", \"Pntek\", \"szombat\"], day_short: [\"Va\", \"H\", \"Ke\", \"Sze\", \"Cs\", \"P\", \"Szo\"] }, labels: { new_task: \"j feladat\", icon_save: \"Ments\", icon_cancel: \"Mgse\", icon_details: \"Rszletek\", icon_edit: \"Szerkeszts\", icon_delete: \"Trls\", confirm_closing: \"\", confirm_deleting: \"Az esemny trlve lesz, biztosan folytatja?\", section_description: \"Lers\", section_time: \"Idszak\", section_type: \"Type\", section_deadline: \"Deadline\", section_baselines: \"Baselines\", column_wbs: \"WBS\", column_text: \"Task name\", column_start_date: \"Start time\", column_duration: \"Duration\", column_add: \"\", link: \"Link\", confirm_link_deleting: \"will be deleted\", link_start: \" (start)\", link_end: \" (end)\", type_task: \"Task\", type_project: \"Project\", type_milestone: \"Milestone\", minutes: \"Minutes\", hours: \"Hours\", days: \"Days\", weeks: \"Week\", months: \"Months\", years: \"Years\", message_ok: \"OK\", message_cancel: \"Mgse\", section_constraint: \"Constraint\", constraint_type: \"Constraint type\", constraint_date: \"Constraint date\", asap: \"As Soon As Possible\", alap: \"As Late As Possible\", snet: \"Start No Earlier Than\", snlt: \"Start No Later Than\", fnet: \"Finish No Earlier Than\", fnlt: \"Finish No Later Than\", mso: \"Must Start On\", mfo: \"Must Finish On\", resources_filter_placeholder: \"type to filter\", resources_filter_label: \"hide empty\", empty_state_text_link: \"Click here\", empty_state_text_description: \"to create your first task\", baselines_section_placeholder: \"Start adding a new baseline\", baselines_add_button: \"Add Baseline\", baselines_remove_button: \"Remove\", baselines_remove_all_button: \"Remove All\", deadline_enable_button: \"Set\", deadline_disable_button: \"Remove\" } }, Wi = { date: { month_full: [\"Januari\", \"Februari\", \"Maret\", \"April\", \"Mei\", \"Juni\", \"Juli\", \"Agustus\", \"September\", \"Oktober\", \"November\", \"Desember\"], month_short: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"Mei\", \"Jun\", \"Jul\", \"Ags\", \"Sep\", \"Okt\", \"Nov\", \"Des\"], day_full: [\"Minggu\", \"Senin\", \"Selasa\", \"Rabu\", \"Kamis\", \"Jumat\", \"Sabtu\"], day_short: [\"Ming\", \"Sen\", \"Sel\", \"Rab\", \"Kam\", \"Jum\", \"Sab\"] }, labels: { new_task: \"Tugas baru\", icon_save: \"Simpan\", icon_cancel: \"Batal\", icon_details: \"Detail\", icon_edit: \"Edit\", icon_delete: \"Hapus\", confirm_closing: \"\", confirm_deleting: \"Acara akan dihapus\", section_description: \"Keterangan\", section_time: \"Periode\", section_type: \"Type\", section_deadline: \"Deadline\", section_baselines: \"Baselines\", column_wbs: \"WBS\", column_text: \"Task name\", column_start_date: \"Start time\", column_duration: \"Duration\", column_add: \"\", link: \"Link\", confirm_link_deleting: \"will be deleted\", link_start: \" (start)\", link_end: \" (end)\", type_task: \"Task\", type_project: \"Project\", type_milestone: \"Milestone\", minutes: \"Minutes\", hours: \"Hours\", days: \"Days\", weeks: \"Week\", months: \"Months\", years: \"Years\", message_ok: \"OK\", message_cancel: \"Batal\", section_constraint: \"Constraint\", constraint_type: \"Constraint type\", constraint_date: \"Constraint date\", asap: \"As Soon As Possible\", alap: \"As Late As Possible\", snet: \"Start No Earlier Than\", snlt: \"Start No Later Than\", fnet: \"Finish No Earlier Than\", fnlt: \"Finish No Later Than\", mso: \"Must Start On\", mfo: \"Must Finish On\", resources_filter_placeholder: \"type to filter\", resources_filter_label: \"hide empty\", empty_state_text_link: \"Click here\", empty_state_text_description: \"to create your first task\", baselines_section_placeholder: \"Start adding a new baseline\", baselines_add_button: \"Add Baseline\", baselines_remove_button: \"Remove\", baselines_remove_all_button: \"Remove All\", deadline_enable_button: \"Set\", deadline_disable_button: \"Remove\" } }, ji = { date: { month_full: [\"Gennaio\", \"Febbraio\", \"Marzo\", \"Aprile\", \"Maggio\", \"Giugno\", \"Luglio\", \"Agosto\", \"Settembre\", \"Ottobre\", \"Novembre\", \"Dicembre\"], month_short: [\"Gen\", \"Feb\", \"Mar\", \"Apr\", \"Mag\", \"Giu\", \"Lug\", \"Ago\", \"Set\", \"Ott\", \"Nov\", \"Dic\"], day_full: [\"Domenica\", \"Luned\", \"Marted\", \"Mercoled\", \"Gioved\", \"Venerd\", \"Sabato\"], day_short: [\"Dom\", \"Lun\", \"Mar\", \"Mer\", \"Gio\", \"Ven\", \"Sab\"] }, labels: { new_task: \"Nuovo compito\", icon_save: \"Salva\", icon_cancel: \"Chiudi\", icon_details: \"Dettagli\", icon_edit: \"Modifica\", icon_delete: \"Elimina\", confirm_closing: \"\", confirm_deleting: \"Sei sicuro di confermare l'eliminazione?\", section_description: \"Descrizione\", section_time: \"Periodo di tempo\", section_type: \"Tipo\", section_deadline: \"Deadline\", section_baselines: \"Baselines\", column_wbs: \"WBS\", column_text: \"Nome Attivit\", column_start_date: \"Inizio\", column_duration: \"Durata\", column_add: \"\", link: \"Link\", confirm_link_deleting: \"sar eliminato\", link_start: \" (inizio)\", link_end: \" (fine)\", type_task: \"Task\", type_project: \"Project\", type_milestone: \"Milestone\", minutes: \"Minuti\", hours: \"Ore\", days: \"Giorni\", weeks: \"Settimane\", months: \"Mesi\", years: \"Anni\", message_ok: \"OK\", message_cancel: \"Chiudi\", section_constraint: \"Constraint\", constraint_type: \"Constraint type\", constraint_date: \"Constraint date\", asap: \"As Soon As Possible\", alap: \"As Late As Possible\", snet: \"Start No Earlier Than\", snlt: \"Start No Later Than\", fnet: \"Finish No Earlier Than\", fnlt: \"Finish No Later Than\", mso: \"Must Start On\", mfo: \"Must Finish On\", resources_filter_placeholder: \"type to filter\", resources_filter_label: \"hide empty\", empty_state_text_link: \"Click here\", empty_state_text_description: \"to create your first task\", baselines_section_placeholder: \"Start adding a new baseline\", baselines_add_button: \"Add Baseline\", baselines_remove_button: \"Remove\", baselines_remove_all_button: \"Remove All\", deadline_enable_button: \"Set\", deadline_disable_button: \"Remove\" } }, Fi = { date: { month_full: [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"11\", \"12\"], month_short: [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"11\", \"12\"], day_full: [\"\", \"\", \"\", \"\", \"\", \"\", \"\"], day_short: [\"\", \"\", \"\", \"\", \"\", \"\", \"\"] }, labels: { new_task: \"\", icon_save: \"\", icon_cancel: \"\", icon_details: \"\", icon_edit: \"\", icon_delete: \"\", confirm_closing: \"\", confirm_deleting: \"\", section_description: \"\", section_time: \"\", section_type: \"Type\", section_deadline: \"Deadline\", section_baselines: \"Baselines\", column_wbs: \"WBS\", column_text: \"Task name\", column_start_date: \"Start time\", column_duration: \"Duration\", column_add: \"\", link: \"Link\", confirm_link_deleting: \"will be deleted\", link_start: \" (start)\", link_end: \" (end)\", type_task: \"Task\", type_project: \"Project\", type_milestone: \"Milestone\", minutes: \"Minutes\", hours: \"Hours\", days: \"Days\", weeks: \"Week\", months: \"Months\", years: \"Years\", message_ok: \"OK\", message_cancel: \"\", section_constraint: \"Constraint\", constraint_type: \"Constraint type\", constraint_date: \"Constraint date\", asap: \"As Soon As Possible\", alap: \"As Late As Possible\", snet: \"Start No Earlier Than\", snlt: \"Start No Later Than\", fnet: \"Finish No Earlier Than\", fnlt: \"Finish No Later Than\", mso: \"Must Start On\", mfo: \"Must Finish On\", resources_filter_placeholder: \"type to filter\", resources_filter_label: \"hide empty\", empty_state_text_link: \"Click here\", empty_state_text_description: \"to create your first task\", baselines_section_placeholder: \"Start adding a new baseline\", baselines_add_button: \"Add Baseline\", baselines_remove_button: \"Remove\", baselines_remove_all_button: \"Remove All\", deadline_enable_button: \"Set\", deadline_disable_button: \"Remove\" } }, Vi = { date: { month_full: [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"11\", \"12\"], month_short: [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"11\", \"12\"], day_full: [\"\", \"\", \"\", \"\", \"\", \"\", \"\"], day_short: [\"\", \"\", \"\", \"\", \"\", \"\", \"\"] }, labels: { new_task: \" \", icon_save: \"\", icon_cancel: \"\", icon_details: \" \", icon_edit: \"\", icon_delete: \"\", confirm_closing: \"\", confirm_deleting: \" ?\", section_description: \"\", section_time: \"\", section_type: \"Type\", section_deadline: \"Deadline\", section_baselines: \"Baselines\", column_wbs: \"WBS\", column_text: \"\", column_start_date: \"\", column_duration: \"\", column_add: \"\", link: \"\", confirm_link_deleting: \" ?\", link_start: \" (start)\", link_end: \" (end)\", type_task: \"\", type_project: \"\", type_milestone: \"\", minutes: \"\", hours: \"\", days: \"\", weeks: \"\", months: \"\", years: \"\", message_ok: \"OK\", message_cancel: \"\", section_constraint: \"Constraint\", constraint_type: \"Constraint type\", constraint_date: \"Constraint date\", asap: \"As Soon As Possible\", alap: \"As Late As Possible\", snet: \"Start No Earlier Than\", snlt: \"Start No Later Than\", fnet: \"Finish No Earlier Than\", fnlt: \"Finish No Later Than\", mso: \"Must Start On\", mfo: \"Must Finish On\", resources_filter_placeholder: \"type to filter\", resources_filter_label: \"hide empty\", empty_state_text_link: \"Click here\", empty_state_text_description: \"to create your first task\", baselines_section_placeholder: \"Start adding a new baseline\", baselines_add_button: \"Add Baseline\", baselines_remove_button: \"Remove\", baselines_remove_all_button: \"Remove All\", deadline_enable_button: \"Set\", deadline_disable_button: \"Remove\" } };\nclass Ui {\n  constructor(e) {\n    this.addLocale = (n, i) => {\n      this._locales[n] = i;\n    }, this.getLocale = (n) => this._locales[n], this._locales = {};\n    for (const n in e) this._locales[n] = e[n];\n  }\n}\nconst qi = { date: { month_full: [\"Januar\", \"Februar\", \"Mars\", \"April\", \"Mai\", \"Juni\", \"Juli\", \"August\", \"September\", \"Oktober\", \"November\", \"Desember\"], month_short: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"Mai\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Okt\", \"Nov\", \"Des\"], day_full: [\"Sndag\", \"Mandag\", \"Tirsdag\", \"Onsdag\", \"Torsdag\", \"Fredag\", \"Lrdag\"], day_short: [\"Sn\", \"Mon\", \"Tir\", \"Ons\", \"Tor\", \"Fre\", \"Lr\"] }, labels: { new_task: \"Ny oppgave\", icon_save: \"Lagre\", icon_cancel: \"Avbryt\", icon_details: \"Detaljer\", icon_edit: \"Rediger\", icon_delete: \"Slett\", confirm_closing: \"\", confirm_deleting: \"Hendelsen vil bli slettet permanent. Er du sikker?\", section_description: \"Beskrivelse\", section_time: \"Tidsperiode\", section_type: \"Type\", section_deadline: \"Deadline\", section_baselines: \"Baselines\", column_wbs: \"WBS\", column_text: \"Task name\", column_start_date: \"Start time\", column_duration: \"Duration\", column_add: \"\", link: \"Link\", confirm_link_deleting: \"will be deleted\", link_start: \" (start)\", link_end: \" (end)\", type_task: \"Task\", type_project: \"Project\", type_milestone: \"Milestone\", minutes: \"Minutes\", hours: \"Hours\", days: \"Days\", weeks: \"Week\", months: \"Months\", years: \"Years\", message_ok: \"OK\", message_cancel: \"Avbryt\", section_constraint: \"Constraint\", constraint_type: \"Constraint type\", constraint_date: \"Constraint date\", asap: \"As Soon As Possible\", alap: \"As Late As Possible\", snet: \"Start No Earlier Than\", snlt: \"Start No Later Than\", fnet: \"Finish No Earlier Than\", fnlt: \"Finish No Later Than\", mso: \"Must Start On\", mfo: \"Must Finish On\", resources_filter_placeholder: \"type to filter\", resources_filter_label: \"hide empty\", empty_state_text_link: \"Click here\", empty_state_text_description: \"to create your first task\", baselines_section_placeholder: \"Start adding a new baseline\", baselines_add_button: \"Add Baseline\", baselines_remove_button: \"Remove\", baselines_remove_all_button: \"Remove All\", deadline_enable_button: \"Set\", deadline_disable_button: \"Remove\" } }, Gi = { date: { month_full: [\"Januari\", \"Februari\", \"Maart\", \"April\", \"Mei\", \"Juni\", \"Juli\", \"Augustus\", \"September\", \"Oktober\", \"November\", \"December\"], month_short: [\"Jan\", \"Feb\", \"mrt\", \"Apr\", \"Mei\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Okt\", \"Nov\", \"Dec\"], day_full: [\"Zondag\", \"Maandag\", \"Dinsdag\", \"Woensdag\", \"Donderdag\", \"Vrijdag\", \"Zaterdag\"], day_short: [\"Zo\", \"Ma\", \"Di\", \"Wo\", \"Do\", \"Vr\", \"Za\"] }, labels: { new_task: \"Nieuwe taak\", icon_save: \"Opslaan\", icon_cancel: \"Annuleren\", icon_details: \"Details\", icon_edit: \"Bewerken\", icon_delete: \"Verwijderen\", confirm_closing: \"\", confirm_deleting: \"Item zal permanent worden verwijderd, doorgaan?\", section_description: \"Beschrijving\", section_time: \"Tijd periode\", section_type: \"Type\", section_deadline: \"Deadline\", section_baselines: \"Baselines\", column_wbs: \"WBS\", column_text: \"Taak omschrijving\", column_start_date: \"Startdatum\", column_duration: \"Duur\", column_add: \"\", link: \"Koppeling\", confirm_link_deleting: \"zal worden verwijderd\", link_start: \" (start)\", link_end: \" (eind)\", type_task: \"Task\", type_project: \"Project\", type_milestone: \"Milestone\", minutes: \"minuten\", hours: \"uren\", days: \"dagen\", weeks: \"weken\", months: \"maanden\", years: \"jaren\", message_ok: \"OK\", message_cancel: \"Annuleren\", section_constraint: \"Constraint\", constraint_type: \"Constraint type\", constraint_date: \"Constraint date\", asap: \"As Soon As Possible\", alap: \"As Late As Possible\", snet: \"Start No Earlier Than\", snlt: \"Start No Later Than\", fnet: \"Finish No Earlier Than\", fnlt: \"Finish No Later Than\", mso: \"Must Start On\", mfo: \"Must Finish On\", resources_filter_placeholder: \"type to filter\", resources_filter_label: \"hide empty\", empty_state_text_link: \"Click here\", empty_state_text_description: \"to create your first task\", baselines_section_placeholder: \"Start adding a new baseline\", baselines_add_button: \"Add Baseline\", baselines_remove_button: \"Remove\", baselines_remove_all_button: \"Remove All\", deadline_enable_button: \"Set\", deadline_disable_button: \"Remove\" } }, Yi = { date: { month_full: [\"Januar\", \"Februar\", \"Mars\", \"April\", \"Mai\", \"Juni\", \"Juli\", \"August\", \"September\", \"Oktober\", \"November\", \"Desember\"], month_short: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"Mai\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Okt\", \"Nov\", \"Des\"], day_full: [\"Sndag\", \"Mandag\", \"Tirsdag\", \"Onsdag\", \"Torsdag\", \"Fredag\", \"Lrdag\"], day_short: [\"Sn\", \"Man\", \"Tir\", \"Ons\", \"Tor\", \"Fre\", \"Lr\"] }, labels: { new_task: \"Ny oppgave\", icon_save: \"Lagre\", icon_cancel: \"Avbryt\", icon_details: \"Detaljer\", icon_edit: \"Endre\", icon_delete: \"Slett\", confirm_closing: \"Endringer blir ikke lagret, er du sikker?\", confirm_deleting: \"Oppfringen vil bli slettet, er du sikker?\", section_description: \"Beskrivelse\", section_time: \"Tidsperiode\", section_type: \"Type\", section_deadline: \"Deadline\", section_baselines: \"Baselines\", column_wbs: \"WBS\", column_text: \"Task name\", column_start_date: \"Start time\", column_duration: \"Duration\", column_add: \"\", link: \"Link\", confirm_link_deleting: \"will be deleted\", link_start: \" (start)\", link_end: \" (end)\", type_task: \"Task\", type_project: \"Project\", type_milestone: \"Milestone\", minutes: \"Minutes\", hours: \"Hours\", days: \"Days\", weeks: \"Week\", months: \"Months\", years: \"Years\", message_ok: \"OK\", message_cancel: \"Avbryt\", section_constraint: \"Constraint\", constraint_type: \"Constraint type\", constraint_date: \"Constraint date\", asap: \"As Soon As Possible\", alap: \"As Late As Possible\", snet: \"Start No Earlier Than\", snlt: \"Start No Later Than\", fnet: \"Finish No Earlier Than\", fnlt: \"Finish No Later Than\", mso: \"Must Start On\", mfo: \"Must Finish On\", resources_filter_placeholder: \"type to filter\", resources_filter_label: \"hide empty\", empty_state_text_link: \"Click here\", empty_state_text_description: \"to create your first task\", baselines_section_placeholder: \"Start adding a new baseline\", baselines_add_button: \"Add Baseline\", baselines_remove_button: \"Remove\", baselines_remove_all_button: \"Remove All\", deadline_enable_button: \"Set\", deadline_disable_button: \"Remove\" } }, Ji = { date: { month_full: [\"Stycze\", \"Luty\", \"Marzec\", \"Kwiecie\", \"Maj\", \"Czerwiec\", \"Lipiec\", \"Sierpie\", \"Wrzesie\", \"Padziernik\", \"Listopad\", \"Grudzie\"], month_short: [\"Sty\", \"Lut\", \"Mar\", \"Kwi\", \"Maj\", \"Cze\", \"Lip\", \"Sie\", \"Wrz\", \"Pa\", \"Lis\", \"Gru\"], day_full: [\"Niedziela\", \"Poniedziaek\", \"Wtorek\", \"roda\", \"Czwartek\", \"Pitek\", \"Sobota\"], day_short: [\"Nie\", \"Pon\", \"Wto\", \"ro\", \"Czw\", \"Pi\", \"Sob\"] }, labels: { new_task: \"Nowe zadanie\", icon_save: \"Zapisz\", icon_cancel: \"Anuluj\", icon_details: \"Szczegy\", icon_edit: \"Edytuj\", icon_delete: \"Usu\", confirm_closing: \"\", confirm_deleting: \"Zdarzenie zostanie usunite na zawsze, kontynuowa?\", section_description: \"Opis\", section_time: \"Okres czasu\", section_type: \"Typ\", section_deadline: \"Deadline\", section_baselines: \"Baselines\", column_wbs: \"WBS\", column_text: \"Nazwa zadania\", column_start_date: \"Pocztek\", column_duration: \"Czas trwania\", column_add: \"\", link: \"Link\", confirm_link_deleting: \"zostanie usunity\", link_start: \" (pocztek)\", link_end: \" (koniec)\", type_task: \"Zadanie\", type_project: \"Projekt\", type_milestone: \"Milestone\", minutes: \"Minuty\", hours: \"Godziny\", days: \"Dni\", weeks: \"Tydzie\", months: \"Miesice\", years: \"Lata\", message_ok: \"OK\", message_cancel: \"Anuluj\", section_constraint: \"Constraint\", constraint_type: \"Constraint type\", constraint_date: \"Constraint date\", asap: \"As Soon As Possible\", alap: \"As Late As Possible\", snet: \"Start No Earlier Than\", snlt: \"Start No Later Than\", fnet: \"Finish No Earlier Than\", fnlt: \"Finish No Later Than\", mso: \"Must Start On\", mfo: \"Must Finish On\", resources_filter_placeholder: \"type to filter\", resources_filter_label: \"hide empty\", empty_state_text_link: \"Click here\", empty_state_text_description: \"to create your first task\", baselines_section_placeholder: \"Start adding a new baseline\", baselines_add_button: \"Add Baseline\", baselines_remove_button: \"Remove\", baselines_remove_all_button: \"Remove All\", deadline_enable_button: \"Set\", deadline_disable_button: \"Remove\" } }, Ki = { date: { month_full: [\"Janeiro\", \"Fevereiro\", \"Maro\", \"Abril\", \"Maio\", \"Junho\", \"Julho\", \"Agosto\", \"Setembro\", \"Outubro\", \"Novembro\", \"Dezembro\"], month_short: [\"Jan\", \"Fev\", \"Mar\", \"Abr\", \"Mai\", \"Jun\", \"Jul\", \"Ago\", \"Set\", \"Out\", \"Nov\", \"Dez\"], day_full: [\"Domingo\", \"Segunda\", \"Tera\", \"Quarta\", \"Quinta\", \"Sexta\", \"Sbado\"], day_short: [\"Dom\", \"Seg\", \"Ter\", \"Qua\", \"Qui\", \"Sex\", \"Sab\"] }, labels: { new_task: \"Nova tarefa\", icon_save: \"Salvar\", icon_cancel: \"Cancelar\", icon_details: \"Detalhes\", icon_edit: \"Editar\", icon_delete: \"Excluir\", confirm_closing: \"\", confirm_deleting: \"As tarefas sero excluidas permanentemente, confirme?\", section_description: \"Descrio\", section_time: \"Perodo\", section_type: \"Tipo\", section_deadline: \"Deadline\", section_baselines: \"Baselines\", column_wbs: \"EAP\", column_text: \"Nome tarefa\", column_start_date: \"Data incio\", column_duration: \"Durao\", column_add: \"\", link: \"Link\", confirm_link_deleting: \"Ser excludo!\", link_start: \" (incio)\", link_end: \" (fim)\", type_task: \"Task\", type_project: \"Projeto\", type_milestone: \"Marco\", minutes: \"Minutos\", hours: \"Horas\", days: \"Dias\", weeks: \"Semanas\", months: \"Meses\", years: \"Anos\", message_ok: \"OK\", message_cancel: \"Cancelar\", section_constraint: \"Restrio\", constraint_type: \"Tipo Restrio\", constraint_date: \"Data restrio\", asap: \"Mais breve possvel\", alap: \"Mais tarde possvel\", snet: \"No comear antes de\", snlt: \"No comear depois de\", fnet: \"No terminar antes de\", fnlt: \"No terminar depois de\", mso: \"Precisa comear em\", mfo: \"Precisa terminar em\", resources_filter_placeholder: \"Tipo de filtros\", resources_filter_label: \"Ocultar vazios\", empty_state_text_link: \"Click here\", empty_state_text_description: \"to create your first task\", baselines_section_placeholder: \"Start adding a new baseline\", baselines_add_button: \"Add Baseline\", baselines_remove_button: \"Remove\", baselines_remove_all_button: \"Remove All\", deadline_enable_button: \"Set\", deadline_disable_button: \"Remove\" } }, Xi = { date: { month_full: [\"Ianuarie\", \"Februarie\", \"Martie\", \"Aprilie\", \"Mai\", \"Iunie\", \"Iulie\", \"August\", \"Septembrie\", \"Octombrie\", \"November\", \"December\"], month_short: [\"Ian\", \"Feb\", \"Mar\", \"Apr\", \"Mai\", \"Iun\", \"Iul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"], day_full: [\"Duminica\", \"Luni\", \"Marti\", \"Miercuri\", \"Joi\", \"Vineri\", \"Sambata\"], day_short: [\"Du\", \"Lu\", \"Ma\", \"Mi\", \"Jo\", \"Vi\", \"Sa\"] }, labels: { new_task: \"Sarcina noua\", icon_save: \"Salveaza\", icon_cancel: \"Anuleaza\", icon_details: \"Detalii\", icon_edit: \"Editeaza\", icon_delete: \"Sterge\", confirm_closing: \"Schimbarile nu vor fi salvate, esti sigur?\", confirm_deleting: \"Evenimentul va fi sters permanent, esti sigur?\", section_description: \"Descriere\", section_time: \"Interval\", section_type: \"Type\", section_deadline: \"Deadline\", section_baselines: \"Baselines\", column_wbs: \"WBS\", column_text: \"Task name\", column_start_date: \"Start time\", column_duration: \"Duration\", column_add: \"\", link: \"Link\", confirm_link_deleting: \"will be deleted\", link_start: \" (start)\", link_end: \" (end)\", type_task: \"Task\", type_project: \"Project\", type_milestone: \"Milestone\", minutes: \"Minutes\", hours: \"Hours\", days: \"Days\", weeks: \"Week\", months: \"Months\", years: \"Years\", message_ok: \"OK\", message_cancel: \"Anuleaza\", section_constraint: \"Constraint\", constraint_type: \"Constraint type\", constraint_date: \"Constraint date\", asap: \"As Soon As Possible\", alap: \"As Late As Possible\", snet: \"Start No Earlier Than\", snlt: \"Start No Later Than\", fnet: \"Finish No Earlier Than\", fnlt: \"Finish No Later Than\", mso: \"Must Start On\", mfo: \"Must Finish On\", resources_filter_placeholder: \"type to filter\", resources_filter_label: \"hide empty\", empty_state_text_link: \"Click here\", empty_state_text_description: \"to create your first task\", baselines_section_placeholder: \"Start adding a new baseline\", baselines_add_button: \"Add Baseline\", baselines_remove_button: \"Remove\", baselines_remove_all_button: \"Remove All\", deadline_enable_button: \"Set\", deadline_disable_button: \"Remove\" } }, Zi = { date: { month_full: [\"\", \"\", \"\", \"\", \"Ma\", \"\", \"\", \"\", \"\", \"O\", \"\", \"\"], month_short: [\"\", \"\", \"Ma\", \"A\", \"Ma\", \"\", \"\", \"A\", \"\", \"\", \"\", \"\"], day_full: [\"\", \"\", \"\", \"\", \"\", \"\", \"\"], day_short: [\"\", \"\", \"\", \"\", \"\", \"\", \"\"] }, labels: { new_task: \" \", icon_save: \"\", icon_cancel: \"\", icon_details: \"\", icon_edit: \"\", icon_delete: \"\", confirm_closing: \"\", confirm_deleting: \"   , ?\", section_description: \"\", section_time: \" \", section_type: \"\", section_deadline: \"Deadline\", section_baselines: \"Baselines\", column_wbs: \"\", column_text: \"\", column_start_date: \"\", column_duration: \"\", column_add: \"\", link: \"\", confirm_link_deleting: \" \", link_start: \" ()\", link_end: \" ()\", type_task: \"Task\", type_project: \"Project\", type_milestone: \"Milestone\", minutes: \"\", hours: \"\", days: \"\", weeks: \"\", months: \"\", years: \"\", message_ok: \"OK\", message_cancel: \"\", section_constraint: \"Constraint\", constraint_type: \"Constraint type\", constraint_date: \"Constraint date\", asap: \"As Soon As Possible\", alap: \"As Late As Possible\", snet: \"Start No Earlier Than\", snlt: \"Start No Later Than\", fnet: \"Finish No Earlier Than\", fnlt: \"Finish No Later Than\", mso: \"Must Start On\", mfo: \"Must Finish On\", resources_filter_placeholder: \"    \", resources_filter_label: \"  \", empty_state_text_link: \"Click here\", empty_state_text_description: \"to create your first task\", baselines_section_placeholder: \"Start adding a new baseline\", baselines_add_button: \"Add Baseline\", baselines_remove_button: \"Remove\", baselines_remove_all_button: \"Remove All\", deadline_enable_button: \"Set\", deadline_disable_button: \"Remove\" } }, Qi = { date: { month_full: [\"Januar\", \"Februar\", \"Marec\", \"April\", \"Maj\", \"Junij\", \"Julij\", \"Avgust\", \"September\", \"Oktober\", \"November\", \"December\"], month_short: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"Maj\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Okt\", \"Nov\", \"Dec\"], day_full: [\"Nedelja\", \"Ponedeljek\", \"Torek\", \"Sreda\", \"etrtek\", \"Petek\", \"Sobota\"], day_short: [\"Ned\", \"Pon\", \"Tor\", \"Sre\", \"et\", \"Pet\", \"Sob\"] }, labels: { new_task: \"Nova naloga\", icon_save: \"Shrani\", icon_cancel: \"Preklii\", icon_details: \"Podrobnosti\", icon_edit: \"Uredi\", icon_delete: \"Izbrii\", confirm_closing: \"\", confirm_deleting: \"Dogodek bo izbrisan. elite nadaljevati?\", section_description: \"Opis\", section_time: \"asovni okvir\", section_type: \"Type\", section_deadline: \"Deadline\", section_baselines: \"Baselines\", column_wbs: \"WBS\", column_text: \"Task name\", column_start_date: \"Start time\", column_duration: \"Duration\", column_add: \"\", link: \"Link\", confirm_link_deleting: \"will be deleted\", link_start: \" (start)\", link_end: \" (end)\", type_task: \"Task\", type_project: \"Project\", type_milestone: \"Milestone\", minutes: \"Minutes\", hours: \"Hours\", days: \"Days\", weeks: \"Week\", months: \"Months\", years: \"Years\", message_ok: \"OK\", message_cancel: \"Preklii\", section_constraint: \"Constraint\", constraint_type: \"Constraint type\", constraint_date: \"Constraint date\", asap: \"As Soon As Possible\", alap: \"As Late As Possible\", snet: \"Start No Earlier Than\", snlt: \"Start No Later Than\", fnet: \"Finish No Earlier Than\", fnlt: \"Finish No Later Than\", mso: \"Must Start On\", mfo: \"Must Finish On\", resources_filter_placeholder: \"type to filter\", resources_filter_label: \"hide empty\", empty_state_text_link: \"Click here\", empty_state_text_description: \"to create your first task\", baselines_section_placeholder: \"Start adding a new baseline\", baselines_add_button: \"Add Baseline\", baselines_remove_button: \"Remove\", baselines_remove_all_button: \"Remove All\", deadline_enable_button: \"Set\", deadline_disable_button: \"Remove\" } }, ta = { date: { month_full: [\"Janur\", \"Februr\", \"Marec\", \"Aprl\", \"Mj\", \"Jn\", \"Jl\", \"August\", \"September\", \"Oktber\", \"November\", \"December\"], month_short: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"Mj\", \"Jn\", \"Jl\", \"Aug\", \"Sept\", \"Okt\", \"Nov\", \"Dec\"], day_full: [\"Nedea\", \"Pondelok\", \"Utorok\", \"Streda\", \"tvrtok\", \"Piatok\", \"Sobota\"], day_short: [\"Ne\", \"Po\", \"Ut\", \"St\", \"t\", \"Pi\", \"So\"] }, labels: { new_task: \"Nov loha\", icon_save: \"Uloi\", icon_cancel: \"Sp\", icon_details: \"Detail\", icon_edit: \"Edituj\", icon_delete: \"Zmaza\", confirm_closing: \"Vae zmeny nebud uloen. Skutone?\", confirm_deleting: \"Udalos bude natrvalo vymazan. Skutone?\", section_description: \"Poznmky\", section_time: \"Doba platnosti\", section_type: \"Type\", section_deadline: \"Deadline\", section_baselines: \"Baselines\", column_wbs: \"WBS\", column_text: \"Task name\", column_start_date: \"Start time\", column_duration: \"Duration\", column_add: \"\", link: \"Link\", confirm_link_deleting: \"will be deleted\", link_start: \" (start)\", link_end: \" (end)\", type_task: \"Task\", type_project: \"Project\", type_milestone: \"Milestone\", minutes: \"Minutes\", hours: \"Hours\", days: \"Days\", weeks: \"Week\", months: \"Months\", years: \"Years\", message_ok: \"OK\", message_cancel: \"Sp\", section_constraint: \"Constraint\", constraint_type: \"Constraint type\", constraint_date: \"Constraint date\", asap: \"As Soon As Possible\", alap: \"As Late As Possible\", snet: \"Start No Earlier Than\", snlt: \"Start No Later Than\", fnet: \"Finish No Earlier Than\", fnlt: \"Finish No Later Than\", mso: \"Must Start On\", mfo: \"Must Finish On\", resources_filter_placeholder: \"type to filter\", resources_filter_label: \"hide empty\", empty_state_text_link: \"Click here\", empty_state_text_description: \"to create your first task\", baselines_section_placeholder: \"Start adding a new baseline\", baselines_add_button: \"Add Baseline\", baselines_remove_button: \"Remove\", baselines_remove_all_button: \"Remove All\", deadline_enable_button: \"Set\", deadline_disable_button: \"Remove\" } }, ea = { date: { month_full: [\"Januari\", \"Februari\", \"Mars\", \"April\", \"Maj\", \"Juni\", \"Juli\", \"Augusti\", \"September\", \"Oktober\", \"November\", \"December\"], month_short: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"Maj\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Okt\", \"Nov\", \"Dec\"], day_full: [\"Sndag\", \"Mndag\", \"Tisdag\", \"Onsdag\", \"Torsdag\", \"Fredag\", \"Lrdag\"], day_short: [\"Sn\", \"Mn\", \"Tis\", \"Ons\", \"Tor\", \"Fre\", \"Lr\"] }, labels: { new_task: \"Ny uppgift\", icon_save: \"Spara\", icon_cancel: \"Avbryt\", icon_details: \"Detajer\", icon_edit: \"ndra\", icon_delete: \"Ta bort\", confirm_closing: \"\", confirm_deleting: \"r du sker p att du vill ta bort hndelsen permanent?\", section_description: \"Beskrivning\", section_time: \"Tid\", section_type: \"Typ\", section_deadline: \"Deadline\", section_baselines: \"Baselines\", column_wbs: \"WBS\", column_text: \"Uppgiftsnamn\", column_start_date: \"Starttid\", column_duration: \"Varaktighet\", column_add: \"\", link: \"Lnk\", confirm_link_deleting: \"kommer tas bort\", link_start: \" (start)\", link_end: \" (slut)\", type_task: \"Uppgift\", type_project: \"Projekt\", type_milestone: \"Milstolpe\", minutes: \"Minuter\", hours: \"Timmar\", days: \"Dagar\", weeks: \"Veckor\", months: \"Mnader\", years: \"r\", message_ok: \"OK\", message_cancel: \"Avbryt\", section_constraint: \"Constraint\", constraint_type: \"Constraint type\", constraint_date: \"Constraint date\", asap: \"As Soon As Possible\", alap: \"As Late As Possible\", snet: \"Start No Earlier Than\", snlt: \"Start No Later Than\", fnet: \"Finish No Earlier Than\", fnlt: \"Finish No Later Than\", mso: \"Must Start On\", mfo: \"Must Finish On\", resources_filter_placeholder: \"type to filter\", resources_filter_label: \"hide empty\", empty_state_text_link: \"Click here\", empty_state_text_description: \"to create your first task\", baselines_section_placeholder: \"Start adding a new baseline\", baselines_add_button: \"Add Baseline\", baselines_remove_button: \"Remove\", baselines_remove_all_button: \"Remove All\", deadline_enable_button: \"Set\", deadline_disable_button: \"Remove\" } }, na = { date: { month_full: [\"Ocak\", \"ubat\", \"Mart\", \"Nisan\", \"Mays\", \"Haziran\", \"Temmuz\", \"Austos\", \"Eyll\", \"Ekim\", \"Kasm\", \"Aralk\"], month_short: [\"Oca\", \"ub\", \"Mar\", \"Nis\", \"May\", \"Haz\", \"Tem\", \"Au\", \"Eyl\", \"Eki\", \"Kas\", \"Ara\"], day_full: [\"Pazar\", \"Pazartesi\", \"Sal\", \"aramba\", \"Perembe\", \"Cuma\", \"Cumartesi\"], day_short: [\"Paz\", \"Pzt\", \"Sal\", \"ar\", \"Per\", \"Cum\", \"Cmt\"] }, labels: { new_task: \"Yeni grev\", icon_save: \"Kaydet\", icon_cancel: \"ptal\", icon_details: \"Detaylar\", icon_edit: \"Dzenle\", icon_delete: \"Sil\", confirm_closing: \"\", confirm_deleting: \"Grev silinecek, emin misiniz?\", section_description: \"Aklama\", section_time: \"Zaman Aral\", section_type: \"Tip\", section_deadline: \"Deadline\", section_baselines: \"Baselines\", column_wbs: \"WBS\", column_text: \"Grev Ad\", column_start_date: \"Balang\", column_duration: \"Sre\", column_add: \"\", link: \"Balant\", confirm_link_deleting: \"silinecek\", link_start: \" (balang)\", link_end: \" (biti)\", type_task: \"Grev\", type_project: \"Proje\", type_milestone: \"Kilometreta\", minutes: \"Dakika\", hours: \"Saat\", days: \"Gn\", weeks: \"Hafta\", months: \"Ay\", years: \"Yl\", message_ok: \"OK\", message_cancel: \"ptal\", section_constraint: \"Constraint\", constraint_type: \"Constraint type\", constraint_date: \"Constraint date\", asap: \"As Soon As Possible\", alap: \"As Late As Possible\", snet: \"Start No Earlier Than\", snlt: \"Start No Later Than\", fnet: \"Finish No Earlier Than\", fnlt: \"Finish No Later Than\", mso: \"Must Start On\", mfo: \"Must Finish On\", resources_filter_placeholder: \"type to filter\", resources_filter_label: \"hide empty\", empty_state_text_link: \"Click here\", empty_state_text_description: \"to create your first task\", baselines_section_placeholder: \"Start adding a new baseline\", baselines_add_button: \"Add Baseline\", baselines_remove_button: \"Remove\", baselines_remove_all_button: \"Remove All\", deadline_enable_button: \"Set\", deadline_disable_button: \"Remove\" } }, ia = { date: { month_full: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"], month_short: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"], day_full: [\"\", \"\", \"\", \"\", \"\", \"'\", \"\"], day_short: [\"\", \"\", \"\", \"\", \"\", \"\", \"\"] }, labels: { new_task: \" \", icon_save: \"\", icon_cancel: \"\", icon_details: \"\", icon_edit: \"\", icon_delete: \"\", confirm_closing: \"\", confirm_deleting: \"  .  ?\", section_description: \"\", section_time: \" \", section_type: \"\", section_deadline: \"Deadline\", section_baselines: \"Baselines\", column_wbs: \"WBS\", column_text: \"Task name\", column_start_date: \"Start time\", column_duration: \"Duration\", column_add: \"\", link: \"Link\", confirm_link_deleting: \"will be deleted\", link_start: \" (start)\", link_end: \" (end)\", type_task: \"Task\", type_project: \"Project\", type_milestone: \"Milestone\", minutes: \"Minutes\", hours: \"Hours\", days: \"Days\", weeks: \"Week\", months: \"Months\", years: \"Years\", message_ok: \"OK\", message_cancel: \"\", section_constraint: \"Constraint\", constraint_type: \"Constraint type\", constraint_date: \"Constraint date\", asap: \"As Soon As Possible\", alap: \"As Late As Possible\", snet: \"Start No Earlier Than\", snlt: \"Start No Later Than\", fnet: \"Finish No Earlier Than\", fnlt: \"Finish No Later Than\", mso: \"Must Start On\", mfo: \"Must Finish On\", resources_filter_placeholder: \"type to filter\", resources_filter_label: \"hide empty\", empty_state_text_link: \"Click here\", empty_state_text_description: \"to create your first task\", baselines_section_placeholder: \"Start adding a new baseline\", baselines_add_button: \"Add Baseline\", baselines_remove_button: \"Remove\", baselines_remove_all_button: \"Remove All\", deadline_enable_button: \"Set\", deadline_disable_button: \"Remove\" } };\nfunction aa() {\n  this.constants = Un, this.version = \"9.0.10\", this.license = \"gpl\", this.templates = {}, this.ext = {}, this.keys = { edit_save: this.constants.KEY_CODES.ENTER, edit_cancel: this.constants.KEY_CODES.ESC };\n}\nfunction ra(t) {\n  var e = new aa(), n = new qn(t), i = {};\n  e.plugins = function(l) {\n    for (var d in l) if (l[d] && !i[d]) {\n      var c = n.getExtension(d);\n      c && (c(e), i[d] = !0);\n    }\n    return i;\n  }, e.$services = /* @__PURE__ */ function() {\n    var l = {};\n    return { services: {}, setService: function(d, c) {\n      l[d] = c;\n    }, getService: function(d) {\n      return l[d] ? l[d]() : null;\n    }, dropService: function(d) {\n      l[d] && delete l[d];\n    }, destructor: function() {\n      for (var d in l) if (l[d]) {\n        var c = l[d];\n        c && c.destructor && c.destructor();\n      }\n      l = null;\n    } };\n  }(), e.config = { layout: { css: \"gantt_container\", rows: [{ cols: [{ view: \"grid\", scrollX: \"scrollHor\", scrollY: \"scrollVer\" }, { resizer: !0, width: 1 }, { view: \"timeline\", scrollX: \"scrollHor\", scrollY: \"scrollVer\" }, { view: \"scrollbar\", id: \"scrollVer\" }] }, { view: \"scrollbar\", id: \"scrollHor\", height: 20 }] }, links: { finish_to_start: \"0\", start_to_start: \"1\", finish_to_finish: \"2\", start_to_finish: \"3\" }, types: { task: \"task\", project: \"project\", milestone: \"milestone\" }, auto_types: !1, duration_unit: \"day\", work_time: !1, correct_work_time: !1, skip_off_time: !1, cascade_delete: !0, autosize: !1, autosize_min_width: 0, autoscroll: !0, autoscroll_speed: 30, deepcopy_on_parse: !1, show_links: !0, show_task_cells: !0, static_background: !1, static_background_cells: !0, branch_loading: !1, branch_loading_property: \"$has_child\", show_loading: !1, show_chart: !0, show_grid: !0, min_duration: 36e5, date_format: \"%d-%m-%Y %H:%i\", xml_date: void 0, start_on_monday: !0, server_utc: !1, show_progress: !0, fit_tasks: !1, select_task: !0, scroll_on_click: !0, smart_rendering: !0, preserve_scroll: !0, readonly: !1, container_resize_timeout: 20, deadlines: !0, date_grid: \"%Y-%m-%d\", drag_links: !0, drag_progress: !0, drag_resize: !0, drag_project: !1, drag_move: !0, drag_mode: { resize: \"resize\", progress: \"progress\", move: \"move\", ignore: \"ignore\" }, round_dnd_dates: !0, link_wrapper_width: 20, link_arrow_size: 12, root_id: 0, autofit: !1, columns: [{ name: \"text\", tree: !0, width: \"*\", resize: !0 }, { name: \"start_date\", align: \"center\", resize: !0 }, { name: \"duration\", align: \"center\" }, { name: \"add\", width: 44 }], scale_offset_minimal: !0, inherit_scale_class: !1, scales: [{ unit: \"day\", step: 1, date: \"%d %M\" }], time_step: 60, duration_step: 1, task_date: \"%d %F %Y\", time_picker: \"%H:%i\", task_attribute: \"data-task-id\", link_attribute: \"data-link-id\", layer_attribute: \"data-layer\", buttons_left: [\"gantt_save_btn\", \"gantt_cancel_btn\"], _migrate_buttons: { dhx_save_btn: \"gantt_save_btn\", dhx_cancel_btn: \"gantt_cancel_btn\", dhx_delete_btn: \"gantt_delete_btn\" }, buttons_right: [\"gantt_delete_btn\"], lightbox: { sections: [{ name: \"description\", height: 70, map_to: \"text\", type: \"textarea\", focus: !0 }, { name: \"time\", type: \"duration\", map_to: \"auto\" }], project_sections: [{ name: \"description\", height: 70, map_to: \"text\", type: \"textarea\", focus: !0 }, { name: \"type\", type: \"typeselect\", map_to: \"type\" }, { name: \"time\", type: \"duration\", readonly: !0, map_to: \"auto\" }], milestone_sections: [{ name: \"description\", height: 70, map_to: \"text\", type: \"textarea\", focus: !0 }, { name: \"type\", type: \"typeselect\", map_to: \"type\" }, { name: \"time\", type: \"duration\", single_date: !0, map_to: \"auto\" }] }, drag_lightbox: !0, sort: !1, details_on_create: !0, details_on_dblclick: !0, initial_scroll: !0, task_scroll_offset: 100, order_branch: !1, order_branch_free: !1, task_height: void 0, bar_height: \"full\", bar_height_padding: 9, min_column_width: 70, min_grid_column_width: 70, grid_resizer_column_attribute: \"data-column-index\", keep_grid_width: !1, grid_resize: !1, grid_elastic_columns: !1, show_tasks_outside_timescale: !1, show_unscheduled: !0, resize_rows: !1, task_grid_row_resizer_attribute: \"data-row-index\", min_task_grid_row_height: 30, row_height: 36, readonly_property: \"readonly\", editable_property: \"editable\", calendar_property: \"calendar_id\", resource_calendars: {}, dynamic_resource_calendars: !1, inherit_calendar: !1, type_renderers: {}, open_tree_initially: !1, optimize_render: !0, prevent_default_scroll: !1, show_errors: !0, wai_aria_attributes: !0, smart_scales: !0, rtl: !1, placeholder_task: !1, horizontal_scroll_key: \"shiftKey\", drag_timeline: { useKey: void 0, ignore: \".gantt_task_line, .gantt_task_link\", render: !1 }, drag_multiple: !0, csp: \"auto\" }, e.ajax = /* @__PURE__ */ function(l) {\n    return { cache: !0, method: \"get\", parse: function(d) {\n      return typeof d != \"string\" ? d : (d = d.replace(/^[\\s]+/, \"\"), typeof DOMParser > \"u\" || mt.isIE ? dt.ActiveXObject !== void 0 && ((c = new dt.ActiveXObject(\"Microsoft.XMLDOM\")).async = \"false\", c.loadXML(d)) : c = new DOMParser().parseFromString(d, \"text/xml\"), c);\n      var c;\n    }, xmltop: function(d, c, u) {\n      if (c.status === void 0 || c.status < 400) {\n        var h = c.responseXML ? c.responseXML || c : this.parse(c.responseText || c);\n        if (h && h.documentElement !== null && !h.getElementsByTagName(\"parsererror\").length) return h.getElementsByTagName(d)[0];\n      }\n      return u !== -1 && l.callEvent(\"onLoadXMLError\", [\"Incorrect XML\", arguments[1], u]), document.createElement(\"DIV\");\n    }, xpath: function(d, c) {\n      if (c.nodeName || (c = c.responseXML || c), mt.isIE) return c.selectNodes(d) || [];\n      for (var u, h = [], g = (c.ownerDocument || c).evaluate(d, c, null, XPathResult.ANY_TYPE, null); u = g.iterateNext(); ) h.push(u);\n      return h;\n    }, query: function(d) {\n      return this._call(d.method || \"GET\", d.url, d.data || \"\", d.async || !0, d.callback, d.headers);\n    }, get: function(d, c, u) {\n      var h = xt(\"GET\", arguments);\n      return this.query(h);\n    }, getSync: function(d, c) {\n      var u = xt(\"GET\", arguments);\n      return u.async = !1, this.query(u);\n    }, put: function(d, c, u, h) {\n      var g = xt(\"PUT\", arguments);\n      return this.query(g);\n    }, del: function(d, c, u) {\n      var h = xt(\"DELETE\", arguments);\n      return this.query(h);\n    }, post: function(d, c, u, h) {\n      arguments.length == 1 ? c = \"\" : arguments.length == 2 && typeof c == \"function\" && (u = c, c = \"\");\n      var g = xt(\"POST\", arguments);\n      return this.query(g);\n    }, postSync: function(d, c, u) {\n      c = c === null ? \"\" : String(c);\n      var h = xt(\"POST\", arguments);\n      return h.async = !1, this.query(h);\n    }, _call: function(d, c, u, h, g, p) {\n      return new l.Promise(function(y, v) {\n        var b = typeof XMLHttpRequest !== void 0 ? new XMLHttpRequest() : new dt.ActiveXObject(\"Microsoft.XMLHTTP\"), _ = navigator.userAgent.match(/AppleWebKit/) !== null && navigator.userAgent.match(/Qt/) !== null && navigator.userAgent.match(/Safari/) !== null;\n        h && (b.onreadystatechange = function() {\n          if (b.readyState == 4 || _ && b.readyState == 3) {\n            if ((b.status != 200 || b.responseText === \"\") && !l.callEvent(\"onAjaxError\", [b])) return;\n            setTimeout(function() {\n              typeof g == \"function\" && g.apply(dt, [{ xmlDoc: b, filePath: c }]), y(b), typeof g == \"function\" && (g = null, b = null);\n            }, 0);\n          }\n        });\n        var m = !this || !this.cache;\n        if (d == \"GET\" && m && (c += (c.indexOf(\"?\") >= 0 ? \"&\" : \"?\") + \"dhxr\" + (/* @__PURE__ */ new Date()).getTime() + \"=1\"), b.open(d, c, h), p) for (var f in p) b.setRequestHeader(f, p[f]);\n        else d.toUpperCase() == \"POST\" || d == \"PUT\" || d == \"DELETE\" ? b.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\") : d == \"GET\" && (u = null);\n        if (b.setRequestHeader(\"X-Requested-With\", \"XMLHttpRequest\"), b.send(u), !h) return { xmlDoc: b, filePath: c };\n      });\n    }, urlSeparator: function(d) {\n      return d.indexOf(\"?\") != -1 ? \"&\" : \"?\";\n    } };\n  }(e), e.date = Gn(e), e.RemoteEvents = Jn;\n  var a = function(l) {\n    function d(u) {\n      return { target: u.target || u.srcElement, pageX: u.pageX, pageY: u.pageY, clientX: u.clientX, clientY: u.clientY, metaKey: u.metaKey, shiftKey: u.shiftKey, ctrlKey: u.ctrlKey, altKey: u.altKey };\n    }\n    function c(u, h) {\n      this._obj = u, this._settings = h || {}, ot(this);\n      var g = this.getInputMethods();\n      this._drag_start_timer = null, l.attachEvent(\"onGanttScroll\", R(function(v, b) {\n        this.clearDragTimer();\n      }, this));\n      for (var p = { passive: !1 }, y = 0; y < g.length; y++) R(function(v) {\n        l.event(u, v.down, R(function(_) {\n          v.accessor(_) && (_.button !== void 0 && _.button !== 0 || (h.preventDefault && h.selector && ct(_.target, h.selector) && _.preventDefault(), l.config.touch && _.timeStamp && _.timeStamp - 0 < 300 || (this._settings.original_target = d(_), this._settings.original_element_sizes = { ...rt(_, nn(u)), width: _.target.offsetWidth, height: _.target.offsetHeight }, l.config.touch ? (this.clearDragTimer(), this._drag_start_timer = setTimeout(R(function() {\n            l.getState().lightbox || this.dragStart(u, _, v);\n          }, this), l.config.touch_drag)) : this.dragStart(u, _, v))));\n        }, this), p);\n        var b = document.body;\n        l.event(b, v.up, R(function(_) {\n          v.accessor(_) && this.clearDragTimer();\n        }, this), p);\n      }, this)(g[y]);\n    }\n    return c.prototype = { traceDragEvents: function(u, h) {\n      var g = R(function(m) {\n        return this.dragMove(u, m, h.accessor);\n      }, this);\n      R(function(m) {\n        return this.dragScroll(u, m);\n      }, this);\n      var p = R(function(m) {\n        if (!this.config.started || !W(this.config.updates_per_second) || dn(this, this.config.updates_per_second)) {\n          var f = g(m);\n          if (f) try {\n            m && m.preventDefault && m.cancelable && m.preventDefault();\n          } catch {\n          }\n          return f;\n        }\n      }, this), y = vt(l.$root), v = this.config.mousemoveContainer || vt(l.$root), b = { passive: !1 }, _ = R(function(m) {\n        return l.eventRemove(v, h.move, p), l.eventRemove(y, h.up, _, b), this.dragEnd(u);\n      }, this);\n      l.event(v, h.move, p, b), l.event(y, h.up, _, b);\n    }, checkPositionChange: function(u) {\n      var h = u.x - this.config.pos.x, g = u.y - this.config.pos.y;\n      return Math.sqrt(Math.pow(Math.abs(h), 2) + Math.pow(Math.abs(g), 2)) > this.config.sensitivity;\n    }, initDnDMarker: function() {\n      var u = this.config.marker = document.createElement(\"div\");\n      u.className = \"gantt_drag_marker\", u.innerHTML = \"\", document.body.appendChild(u);\n    }, backupEventTarget: function(u, h) {\n      if (l.config.touch) {\n        var g = h(u), p = g.target || g.srcElement, y = p.cloneNode(!0);\n        this.config.original_target = d(g), this.config.original_target.target = y, this.config.backup_element = p, p.parentNode.appendChild(y), p.style.display = \"none\", (this.config.mousemoveContainer || document.body).appendChild(p);\n      }\n    }, getInputMethods: function() {\n      var u = [];\n      if (u.push({ move: \"mousemove\", down: \"mousedown\", up: \"mouseup\", accessor: function(g) {\n        return g;\n      } }), l.config.touch) {\n        var h = !0;\n        try {\n          document.createEvent(\"TouchEvent\");\n        } catch {\n          h = !1;\n        }\n        h ? u.push({ move: \"touchmove\", down: \"touchstart\", up: \"touchend\", accessor: function(g) {\n          return g.touches && g.touches.length > 1 ? null : g.touches[0] ? { target: document.elementFromPoint(g.touches[0].clientX, g.touches[0].clientY), pageX: g.touches[0].pageX, pageY: g.touches[0].pageY, clientX: g.touches[0].clientX, clientY: g.touches[0].clientY } : g;\n        } }) : dt.navigator.pointerEnabled ? u.push({ move: \"pointermove\", down: \"pointerdown\", up: \"pointerup\", accessor: function(g) {\n          return g.pointerType == \"mouse\" ? null : g;\n        } }) : dt.navigator.msPointerEnabled && u.push({ move: \"MSPointerMove\", down: \"MSPointerDown\", up: \"MSPointerUp\", accessor: function(g) {\n          return g.pointerType == g.MSPOINTER_TYPE_MOUSE ? null : g;\n        } });\n      }\n      return u;\n    }, clearDragTimer: function() {\n      this._drag_start_timer && (clearTimeout(this._drag_start_timer), this._drag_start_timer = null);\n    }, dragStart: function(u, h, g) {\n      this.config && this.config.started || (this.config = { obj: u, marker: null, started: !1, pos: this.getPosition(h), sensitivity: 4 }, this._settings && P(this.config, this._settings, !0), this.traceDragEvents(u, g), l._prevent_touch_scroll = !0, h.target.closest(\".gantt_row\") && !l.config.order_branch && (l._prevent_touch_scroll = !1), document.body.classList.add(\"gantt_noselect\"), l.config.touch && this.dragMove(u, h, g.accessor));\n    }, dragMove: function(u, h, g) {\n      var p = g(h);\n      if (!p) return !1;\n      if (!this.config.marker && !this.config.started) {\n        var y = this.getPosition(p);\n        if (l.config.touch || this.checkPositionChange(y)) {\n          if (this.config.started = !0, this.config.ignore = !1, l._touch_drag = !0, this.callEvent(\"onBeforeDragStart\", [u, this.config.original_target]) === !1) return this.config.ignore = !0, !1;\n          this.backupEventTarget(h, g), this.initDnDMarker(), l._touch_feedback(), this.callEvent(\"onAfterDragStart\", [u, this.config.original_target]);\n        } else this.config.ignore = !0;\n      }\n      return this.config.ignore ? !1 : h.targetTouches && !p.target ? void 0 : (p.pos = this.getPosition(p), this.config.marker.style.left = p.pos.x + \"px\", this.config.marker.style.top = p.pos.y + \"px\", this.callEvent(\"onDragMove\", [u, p]), !0);\n    }, dragEnd: function(u) {\n      var h = this.config.backup_element;\n      h && h.parentNode && h.parentNode.removeChild(h), l._prevent_touch_scroll = !1, this.config.marker && (this.config.marker.parentNode.removeChild(this.config.marker), this.config.marker = null, this.callEvent(\"onDragEnd\", [])), this.config.started = !1, l._touch_drag = !1, document.body.classList.remove(\"gantt_noselect\");\n    }, getPosition: function(u) {\n      var h = 0, g = 0;\n      return u.pageX || u.pageY ? (h = u.pageX, g = u.pageY) : (u.clientX || u.clientY) && (h = u.clientX + document.body.scrollLeft + document.documentElement.scrollLeft, g = u.clientY + document.body.scrollTop + document.documentElement.scrollTop), { x: h, y: g };\n    } }, c;\n  }(e);\n  e.$services.setService(\"dnd\", function() {\n    return a;\n  });\n  var r = /* @__PURE__ */ function(l) {\n    var d = {};\n    function c(u, h, g) {\n      g = g || u;\n      var p = l.config, y = l.templates;\n      l.config[u] && d[g] != p[u] && (h && y[g] || (y[g] = l.date.date_to_str(p[u]), d[g] = p[u]));\n    }\n    return { initTemplates: function() {\n      var u = l.date, h = u.date_to_str, g = l.config, p = h(g.xml_date || g.date_format, g.server_utc), y = u.str_to_date(g.xml_date || g.date_format, g.server_utc);\n      c(\"date_scale\", !0, void 0, l.config, l.templates), c(\"date_grid\", !0, \"grid_date_format\", l.config, l.templates), c(\"task_date\", !0, void 0, l.config, l.templates), l.mixin(l.templates, { xml_format: void 0, format_date: p, xml_date: void 0, parse_date: y, progress_text: function(v, b, _) {\n        return \"\";\n      }, grid_header_class: function(v, b) {\n        return \"\";\n      }, task_text: function(v, b, _) {\n        return _.text;\n      }, task_class: function(v, b, _) {\n        return \"\";\n      }, task_end_date: function(v) {\n        return l.templates.task_date(v);\n      }, grid_row_class: function(v, b, _) {\n        return \"\";\n      }, task_row_class: function(v, b, _) {\n        return \"\";\n      }, timeline_cell_class: function(v, b) {\n        return \"\";\n      }, timeline_cell_content: function(v, b) {\n        return \"\";\n      }, scale_cell_class: function(v) {\n        return \"\";\n      }, scale_row_class: function(v) {\n        return \"\";\n      }, grid_indent: function(v) {\n        return \"<div class='gantt_tree_indent'></div>\";\n      }, grid_folder: function(v) {\n        return \"<div class='gantt_tree_icon gantt_folder_\" + (v.$open ? \"open\" : \"closed\") + \"'></div>\";\n      }, grid_file: function(v) {\n        return \"<div class='gantt_tree_icon gantt_file'></div>\";\n      }, grid_open: function(v) {\n        return \"<div class='gantt_tree_icon gantt_\" + (v.$open ? \"close\" : \"open\") + \"'></div>\";\n      }, grid_blank: function(v) {\n        return \"<div class='gantt_tree_icon gantt_blank'></div>\";\n      }, date_grid: function(v, b, _) {\n        return b && l.isUnscheduledTask(b) && l.config.show_unscheduled ? l.templates.task_unscheduled_time(b) : l.templates.grid_date_format(v, _);\n      }, task_time: function(v, b, _) {\n        return l.isUnscheduledTask(_) && l.config.show_unscheduled ? l.templates.task_unscheduled_time(_) : l.templates.task_date(v) + \" - \" + l.templates.task_end_date(b);\n      }, task_unscheduled_time: function(v) {\n        return \"\";\n      }, time_picker: h(g.time_picker), link_class: function(v) {\n        return \"\";\n      }, link_description: function(v) {\n        var b = l.getTask(v.source), _ = l.getTask(v.target);\n        return \"<b>\" + b.text + \"</b> &ndash;  <b>\" + _.text + \"</b>\";\n      }, drag_link: function(v, b, _, m) {\n        v = l.getTask(v);\n        var f = l.locale.labels, k = \"<b>\" + v.text + \"</b> \" + (b ? f.link_start : f.link_end) + \"<br/>\";\n        return _ && (k += \"<b> \" + (_ = l.getTask(_)).text + \"</b> \" + (m ? f.link_start : f.link_end) + \"<br/>\"), k;\n      }, drag_link_class: function(v, b, _, m) {\n        var f = \"\";\n        return v && _ && (f = \" \" + (l.isLinkAllowed(v, _, b, m) ? \"gantt_link_allow\" : \"gantt_link_deny\")), \"gantt_link_tooltip\" + f;\n      }, tooltip_date_format: u.date_to_str(\"%Y-%m-%d\"), tooltip_text: function(v, b, _) {\n        return `<div>Task: ${_.text}</div>\n\t\t\t\t<div>Start date: ${l.templates.tooltip_date_format(v)}</div>\n\t\t\t\t<div>End date: ${l.templates.tooltip_date_format(b)}</div>`;\n      }, baseline_text: function(v, b, _) {\n        return \"\";\n      } });\n    }, initTemplate: c };\n  }(e);\n  e.$services.setService(\"templateLoader\", function() {\n    return r;\n  }), ot(e);\n  var s = new Kn();\n  s.registerProvider(\"global\", function() {\n    var l = { min_date: e._min_date, max_date: e._max_date, selected_task: null };\n    return e.$data && e.$data.tasksStore && (l.selected_task = e.$data.tasksStore.getSelectedId()), l;\n  }), e.getState = s.getState, e.$services.setService(\"state\", function() {\n    return s;\n  }), P(e, Bn), e.Promise = Xn, e.env = mt, function(l) {\n    var d = Qn.create();\n    P(l, d);\n    var c, u = l.createDatastore({ name: \"task\", type: \"treeDatastore\", rootId: function() {\n      return l.config.root_id;\n    }, initItem: R(function(_) {\n      this.defined(_.id) || (_.id = this.uid()), _.start_date && (_.start_date = l.date.parseDate(_.start_date, \"parse_date\")), _.end_date && (_.end_date = l.date.parseDate(_.end_date, \"parse_date\"));\n      var m = null;\n      (_.duration || _.duration === 0) && (_.duration = m = 1 * _.duration), m && (_.start_date && !_.end_date ? _.end_date = this.calculateEndDate(_) : !_.start_date && _.end_date && (_.start_date = this.calculateEndDate({ start_date: _.end_date, duration: -_.duration, task: _ }))), l.config.deadlines !== !1 && _.deadline && (_.deadline = l.date.parseDate(_.deadline, \"parse_date\")), _.progress = Number(_.progress) || 0, this._isAllowedUnscheduledTask(_) && this._set_default_task_timing(_), this._init_task_timing(_), _.start_date && _.end_date && this.correctTaskWorkTime(_), _.$source = [], _.$target = [];\n      var f = this.$data.tasksStore.getItem(_.id);\n      return f && !W(_.open) && (_.$open = f.$open), _.parent === void 0 && (_.parent = this.config.root_id), _.open && (_.$open = !0), _;\n    }, l), getConfig: function() {\n      return l.config;\n    } }), h = l.createDatastore({ name: \"link\", initItem: R(function(_) {\n      return this.defined(_.id) || (_.id = this.uid()), _;\n    }, l) });\n    function g(_) {\n      var m = l.isTaskVisible(_);\n      if (!m && l.isTaskExists(_)) {\n        var f = l.getParent(_);\n        l.isTaskExists(f) && l.isTaskVisible(f) && (f = l.getTask(f), l.isSplitTask(f) && (m = !0));\n      }\n      return m;\n    }\n    function p(_) {\n      if (l.isTaskExists(_.source)) {\n        var m = l.getTask(_.source);\n        m.$source = m.$source || [], m.$source.push(_.id);\n      }\n      if (l.isTaskExists(_.target)) {\n        var f = l.getTask(_.target);\n        f.$target = f.$target || [], f.$target.push(_.id);\n      }\n    }\n    function y(_) {\n      if (l.isTaskExists(_.source)) {\n        for (var m = l.getTask(_.source), f = 0; f < m.$source.length; f++) if (m.$source[f] == _.id) {\n          m.$source.splice(f, 1);\n          break;\n        }\n      }\n      if (l.isTaskExists(_.target)) {\n        var k = l.getTask(_.target);\n        for (f = 0; f < k.$target.length; f++) if (k.$target[f] == _.id) {\n          k.$target.splice(f, 1);\n          break;\n        }\n      }\n    }\n    function v() {\n      for (var _ = null, m = l.$data.tasksStore.getItems(), f = 0, k = m.length; f < k; f++) (_ = m[f]).$source = [], _.$target = [];\n      var x = l.$data.linksStore.getItems();\n      for (f = 0, k = x.length; f < k; f++) p(x[f]);\n    }\n    function b(_) {\n      var m = _.source, f = _.target;\n      for (var k in _.events) (function(x, $) {\n        m.attachEvent(x, function() {\n          return f.callEvent($, Array.prototype.slice.call(arguments));\n        }, $);\n      })(k, _.events[k]);\n    }\n    l.attachEvent(\"onDestroy\", function() {\n      u.destructor(), h.destructor();\n    }), l.attachEvent(\"onLinkValidation\", function(_) {\n      if (l.isLinkExists(_.id) || _.id === \"predecessor_generated\") return !0;\n      for (var m = l.getTask(_.source).$source, f = 0; f < m.length; f++) {\n        var k = l.getLink(m[f]), x = _.source == k.source, $ = _.target == k.target, w = _.type == k.type;\n        if (x && $ && w) return !1;\n      }\n      return !0;\n    }), u.attachEvent(\"onBeforeRefreshAll\", function() {\n      if (!u._skipTaskRecalculation) for (var _ = u.getVisibleItems(), m = 0; m < _.length; m++) {\n        var f = _[m];\n        f.$index = m, f.$local_index = l.getTaskIndex(f.id), l.resetProjectDates(f);\n      }\n    }), u.attachEvent(\"onFilterItem\", function(_, m) {\n      if (l.config.show_tasks_outside_timescale) return !0;\n      var f = null, k = null;\n      if (l.config.start_date && l.config.end_date) {\n        if (l._isAllowedUnscheduledTask(m)) return !0;\n        if (f = l.config.start_date.valueOf(), k = l.config.end_date.valueOf(), +m.start_date > k || +m.end_date < +f) return !1;\n      }\n      return !0;\n    }), u.attachEvent(\"onIdChange\", function(_, m) {\n      l._update_flags(_, m);\n      var f = l.getTask(m);\n      u.isSilent() || (f.$split_subtask || f.rollup) && l.eachParent(function(k) {\n        l.refreshTask(k.id);\n      }, m);\n    }), u.attachEvent(\"onAfterUpdate\", function(_) {\n      if (l._update_parents(_), l.getState(\"batchUpdate\").batch_update) return !0;\n      var m = u.getItem(_);\n      m.$source || (m.$source = []);\n      for (var f = 0; f < m.$source.length; f++) h.refresh(m.$source[f]);\n      for (m.$target || (m.$target = []), f = 0; f < m.$target.length; f++) h.refresh(m.$target[f]);\n    }), u.attachEvent(\"onBeforeItemMove\", function(_, m, f) {\n      return !Rt(_, l, u) || (console.log(\"The placeholder task cannot be moved to another position.\"), !1);\n    }), u.attachEvent(\"onAfterItemMove\", function(_, m, f) {\n      var k = l.getTask(_);\n      this.getNextSibling(_) !== null ? k.$drop_target = this.getNextSibling(_) : this.getPrevSibling(_) !== null ? k.$drop_target = \"next:\" + this.getPrevSibling(_) : k.$drop_target = \"next:null\";\n    }), u.attachEvent(\"onStoreUpdated\", function(_, m, f) {\n      if (f == \"delete\" && l._update_flags(_, null), !l.$services.getService(\"state\").getState(\"batchUpdate\").batch_update) {\n        if (l.config.fit_tasks && f !== \"paint\") {\n          var k = l.getState();\n          me(l);\n          var x = l.getState();\n          if (+k.min_date != +x.min_date || +k.max_date != +x.max_date) return l.render(), l.callEvent(\"onScaleAdjusted\", []), !0;\n        }\n        f == \"add\" || f == \"move\" || f == \"delete\" ? l.$layout && (this.$config.name != \"task\" || f != \"add\" && f != \"delete\" || this._skipTaskRecalculation != \"lightbox\" && (this._skipTaskRecalculation = !0), l.$layout.resize()) : _ || h.refresh();\n      }\n    }), h.attachEvent(\"onAfterAdd\", function(_, m) {\n      p(m);\n    }), h.attachEvent(\"onAfterUpdate\", function(_, m) {\n      v();\n    }), h.attachEvent(\"onAfterDelete\", function(_, m) {\n      y(m);\n    }), h.attachEvent(\"onAfterSilentDelete\", function(_, m) {\n      y(m);\n    }), h.attachEvent(\"onBeforeIdChange\", function(_, m) {\n      y(l.mixin({ id: _ }, l.$data.linksStore.getItem(m))), p(l.$data.linksStore.getItem(m));\n    }), h.attachEvent(\"onFilterItem\", function(_, m) {\n      if (!l.config.show_links) return !1;\n      var f = g(m.source), k = g(m.target);\n      return !(!f || !k || l._isAllowedUnscheduledTask(l.getTask(m.source)) || l._isAllowedUnscheduledTask(l.getTask(m.target))) && l.callEvent(\"onBeforeLinkDisplay\", [_, m]);\n    }), c = {}, l.attachEvent(\"onBeforeTaskDelete\", function(_, m) {\n      return c[_] = ve.getSubtreeLinks(l, _), !0;\n    }), l.attachEvent(\"onAfterTaskDelete\", function(_, m) {\n      c[_] && l.$data.linksStore.silent(function() {\n        for (var f in c[_]) l.isLinkExists(f) && l.$data.linksStore.removeItem(f), y(c[_][f]);\n        c[_] = null;\n      });\n    }), l.attachEvent(\"onAfterLinkDelete\", function(_, m) {\n      l.isTaskExists(m.source) && l.refreshTask(m.source), l.isTaskExists(m.target) && l.refreshTask(m.target);\n    }), l.attachEvent(\"onParse\", v), b({ source: h, target: l, events: { onItemLoading: \"onLinkLoading\", onBeforeAdd: \"onBeforeLinkAdd\", onAfterAdd: \"onAfterLinkAdd\", onBeforeUpdate: \"onBeforeLinkUpdate\", onAfterUpdate: \"onAfterLinkUpdate\", onBeforeDelete: \"onBeforeLinkDelete\", onAfterDelete: \"onAfterLinkDelete\", onIdChange: \"onLinkIdChange\" } }), b({ source: u, target: l, events: { onItemLoading: \"onTaskLoading\", onBeforeAdd: \"onBeforeTaskAdd\", onAfterAdd: \"onAfterTaskAdd\", onBeforeUpdate: \"onBeforeTaskUpdate\", onAfterUpdate: \"onAfterTaskUpdate\", onBeforeDelete: \"onBeforeTaskDelete\", onAfterDelete: \"onAfterTaskDelete\", onIdChange: \"onTaskIdChange\", onBeforeItemMove: \"onBeforeTaskMove\", onAfterItemMove: \"onAfterTaskMove\", onFilterItem: \"onBeforeTaskDisplay\", onItemOpen: \"onTaskOpened\", onItemClose: \"onTaskClosed\", onBeforeSelect: \"onBeforeTaskSelected\", onAfterSelect: \"onTaskSelected\", onAfterUnselect: \"onTaskUnselected\" } }), l.$data = { tasksStore: u, linksStore: h };\n  }(e), e.dataProcessor = ni, e.createDataProcessor = ii, function(l) {\n    l.ext || (l.ext = {});\n    for (var d = [ri, si, li, di, ci, ui, hi, _i, gi], c = 0; c < d.length; c++) d[c] && d[c](l);\n  }(e), function(l) {\n    l.getGridColumn = function(d) {\n      for (var c = l.config.columns, u = 0; u < c.length; u++) if (c[u].name == d) return c[u];\n      return null;\n    }, l.getGridColumns = function() {\n      return l.config.columns.slice();\n    };\n  }(e), function(l) {\n    l.isReadonly = function(d) {\n      return typeof d != \"number\" && typeof d != \"string\" || !l.isTaskExists(d) || (d = l.getTask(d)), (!d || !d[this.config.editable_property]) && (d && d[this.config.readonly_property] || this.config.readonly);\n    };\n  }(e), fi(e), function(l) {\n    var d = new fn(l), c = new pn(d);\n    P(l, xi(d, c));\n  }(e), $i(e), function(l) {\n    l.getTaskType = function(d) {\n      return \"task\";\n    };\n  }(e), function(l) {\n    function d() {\n      return l._cached_functions.update_if_changed(l), l._cached_functions.active || l._cached_functions.activate(), !0;\n    }\n    l._cached_functions = { cache: {}, mode: !1, critical_path_mode: !1, wrap_methods: function(u, h) {\n      if (h._prefetch_originals) for (var g in h._prefetch_originals) h[g] = h._prefetch_originals[g];\n      for (h._prefetch_originals = {}, g = 0; g < u.length; g++) this.prefetch(u[g], h);\n    }, prefetch: function(u, h) {\n      var g = h[u];\n      if (g) {\n        var p = this;\n        h._prefetch_originals[u] = g, h[u] = function() {\n          for (var y = new Array(arguments.length), v = 0, b = arguments.length; v < b; v++) y[v] = arguments[v];\n          if (p.active) {\n            var _ = p.get_arguments_hash(Array.prototype.slice.call(y));\n            p.cache[u] || (p.cache[u] = {});\n            var m = p.cache[u];\n            if (p.has_cached_value(m, _)) return p.get_cached_value(m, _);\n            var f = g.apply(this, y);\n            return p.cache_value(m, _, f), f;\n          }\n          return g.apply(this, y);\n        };\n      }\n      return g;\n    }, cache_value: function(u, h, g) {\n      this.is_date(g) && (g = new Date(g)), u[h] = g;\n    }, has_cached_value: function(u, h) {\n      return u.hasOwnProperty(h);\n    }, get_cached_value: function(u, h) {\n      var g = u[h];\n      return this.is_date(g) && (g = new Date(g)), g;\n    }, is_date: function(u) {\n      return u && u.getUTCDate;\n    }, get_arguments_hash: function(u) {\n      for (var h = [], g = 0; g < u.length; g++) h.push(this.stringify_argument(u[g]));\n      return \"(\" + h.join(\";\") + \")\";\n    }, stringify_argument: function(u) {\n      return (u.id ? u.id : this.is_date(u) ? u.valueOf() : u) + \"\";\n    }, activate: function() {\n      this.clear(), this.active = !0;\n    }, deactivate: function() {\n      this.clear(), this.active = !1;\n    }, clear: function() {\n      this.cache = {};\n    }, setup: function(u) {\n      var h = [], g = [\"_isProjectEnd\", \"_getProjectEnd\", \"_getSlack\"];\n      this.mode == \"auto\" ? u.config.highlight_critical_path && (h = g) : this.mode === !0 && (h = g), this.wrap_methods(h, u);\n    }, update_if_changed: function(u) {\n      (this.critical_path_mode != u.config.highlight_critical_path || this.mode !== u.config.optimize_render) && (this.critical_path_mode = u.config.highlight_critical_path, this.mode = u.config.optimize_render, this.setup(u));\n    } }, l.attachEvent(\"onBeforeGanttRender\", d), l.attachEvent(\"onBeforeDataRender\", d), l.attachEvent(\"onBeforeSmartRender\", function() {\n      d();\n    }), l.attachEvent(\"onBeforeParse\", d), l.attachEvent(\"onDataRender\", function() {\n      l._cached_functions.deactivate();\n    });\n    var c = null;\n    l.attachEvent(\"onSmartRender\", function() {\n      c && clearTimeout(c), c = setTimeout(function() {\n        l._cached_functions.deactivate();\n      }, 1e3);\n    }), l.attachEvent(\"onBeforeGanttReady\", function() {\n      return l._cached_functions.update_if_changed(l), !0;\n    });\n  }(e), wi(e), function(l) {\n    l.destructor = function() {\n      for (var d in this.clearAll(), this.callEvent(\"onDestroy\", []), this._getDatastores().forEach(function(c) {\n        c.destructor();\n      }), this.$root && delete this.$root.gantt, this._eventRemoveAll && this._eventRemoveAll(), this.$layout && this.$layout.destructor(), this.resetLightbox && this.resetLightbox(), this.ext.inlineEditors && this.ext.inlineEditors.destructor && this.ext.inlineEditors.destructor(), this._dp && this._dp.destructor && this._dp.destructor(), this.$services.destructor(), this.detachAllEvents(), this) d.indexOf(\"$\") === 0 && delete this[d];\n      this.$destroyed = !0;\n    };\n  }(e);\n  var o = new Ui({ en: Ni, ar: Si, be: Ti, ca: Ei, cn: Ci, cs: Di, da: Ai, de: Ii, el: Mi, es: Li, fa: Pi, fi: Ri, fr: Hi, he: Oi, hr: Bi, hu: zi, id: Wi, it: ji, jp: Fi, kr: Vi, nb: qi, nl: Gi, no: Yi, pl: Ji, pt: Ki, ro: Xi, ru: Zi, si: Qi, sk: ta, sv: ea, tr: na, ua: ia });\n  return e.i18n = { addLocale: o.addLocale, setLocale: function(l) {\n    if (typeof l == \"string\") {\n      var d = o.getLocale(l);\n      d || (d = o.getLocale(\"en\")), e.locale = d;\n    } else if (l) if (e.locale) for (var c in l) l[c] && typeof l[c] == \"object\" ? (e.locale[c] || (e.locale[c] = {}), e.mixin(e.locale[c], l[c], !0)) : e.locale[c] = l[c];\n    else e.locale = l;\n    const u = e.locale.labels;\n    u.gantt_save_btn = u.gantt_save_btn || u.icon_save, u.gantt_cancel_btn = u.gantt_cancel_btn || u.icon_cancel, u.gantt_delete_btn = u.gantt_delete_btn || u.icon_delete;\n  }, getLocale: o.getLocale }, e.i18n.setLocale(\"en\"), e;\n}\nfunction sa(t) {\n  var e = \"data-dhxbox\", n = null;\n  function i(_, m) {\n    var f = _.callback;\n    y.hide(_.box), n = _.box = null, f && f(m);\n  }\n  function a(_) {\n    if (n) {\n      var m = _.which || _.keyCode, f = !1;\n      if (v.keyboard) {\n        if (m == 13 || m == 32) {\n          var k = _.target || _.srcElement;\n          X(k).indexOf(\"gantt_popup_button\") > -1 && k.click ? k.click() : (i(n, !0), f = !0);\n        }\n        m == 27 && (i(n, !1), f = !0);\n      }\n      return f ? (_.preventDefault && _.preventDefault(), !(_.cancelBubble = !0)) : void 0;\n    }\n  }\n  var r = vt(t.$root) || document;\n  function s(_) {\n    s.cover || (s.cover = document.createElement(\"div\"), s.cover.onkeydown = a, s.cover.className = \"dhx_modal_cover\", document.body.appendChild(s.cover)), s.cover.style.display = _ ? \"inline-block\" : \"none\";\n  }\n  function o(_, m, f) {\n    return \"<div \" + t._waiAria.messageButtonAttrString(_) + \" class='gantt_popup_button \" + (\"gantt_\" + m.toLowerCase().replace(/ /g, \"_\") + \"_button\") + \"' data-result='\" + f + \"' result='\" + f + \"' ><div>\" + _ + \"</div></div>\";\n  }\n  function l() {\n    for (var _ = [].slice.apply(arguments, [0]), m = 0; m < _.length; m++) if (_[m]) return _[m];\n  }\n  function d(_, m, f) {\n    var k = _.tagName ? _ : function(w, S, T) {\n      var E = document.createElement(\"div\"), C = st();\n      t._waiAria.messageModalAttr(E, C), E.className = \" gantt_modal_box gantt-\" + w.type, E.setAttribute(e, 1);\n      var D = \"\";\n      if (w.width && (E.style.width = w.width), w.height && (E.style.height = w.height), w.title && (D += '<div class=\"gantt_popup_title\">' + w.title + \"</div>\"), D += '<div class=\"gantt_popup_text\" id=\"' + C + '\"><span>' + (w.content ? \"\" : w.text) + '</span></div><div  class=\"gantt_popup_controls\">', S && (D += o(l(w.ok, t.locale.labels.message_ok, \"OK\"), \"ok\", !0)), T && (D += o(l(w.cancel, t.locale.labels.message_cancel, \"Cancel\"), \"cancel\", !1)), w.buttons) for (var M = 0; M < w.buttons.length; M++) {\n        var I = w.buttons[M];\n        D += typeof I == \"object\" ? o(I.label, I.css || \"gantt_\" + I.label.toLowerCase() + \"_button\", I.value || M) : o(I, I, M);\n      }\n      if (D += \"</div>\", E.innerHTML = D, w.content) {\n        var A = w.content;\n        typeof A == \"string\" && (A = document.getElementById(A)), A.style.display == \"none\" && (A.style.display = \"\"), E.childNodes[w.title ? 1 : 0].appendChild(A);\n      }\n      return E.onclick = function(N) {\n        var L = N.target || N.srcElement;\n        if (L.className || (L = L.parentNode), ct(L, \".gantt_popup_button\")) {\n          var O = L.getAttribute(\"data-result\");\n          i(w, O = O == \"true\" || O != \"false\" && O);\n        }\n      }, w.box = E, (S || T) && (n = w), E;\n    }(_, m, f);\n    _.hidden || s(!0), document.body.appendChild(k);\n    var x = Math.abs(Math.floor(((window.innerWidth || document.documentElement.offsetWidth) - k.offsetWidth) / 2)), $ = Math.abs(Math.floor(((window.innerHeight || document.documentElement.offsetHeight) - k.offsetHeight) / 2));\n    return _.position == \"top\" ? k.style.top = \"-3px\" : k.style.top = $ + \"px\", k.style.left = x + \"px\", k.onkeydown = a, y.focus(k), _.hidden && y.hide(k), t.callEvent(\"onMessagePopup\", [k]), k;\n  }\n  function c(_) {\n    return d(_, !0, !1);\n  }\n  function u(_) {\n    return d(_, !0, !0);\n  }\n  function h(_) {\n    return d(_);\n  }\n  function g(_, m, f) {\n    return typeof _ != \"object\" && (typeof m == \"function\" && (f = m, m = \"\"), _ = { text: _, type: m, callback: f }), _;\n  }\n  function p(_, m, f, k) {\n    return typeof _ != \"object\" && (_ = { text: _, type: m, expire: f, id: k }), _.id = _.id || st(), _.expire = _.expire || v.expire, _;\n  }\n  t.event(r, \"keydown\", a, !0);\n  var y = function() {\n    var _ = g.apply(this, arguments);\n    return _.type = _.type || \"alert\", h(_);\n  };\n  y.hide = function(_) {\n    for (; _ && _.getAttribute && !_.getAttribute(e); ) _ = _.parentNode;\n    _ && (_.parentNode.removeChild(_), s(!1), t.callEvent(\"onAfterMessagePopup\", [_]));\n  }, y.focus = function(_) {\n    setTimeout(function() {\n      var m = Lt(_);\n      m.length && m[0].focus && m[0].focus();\n    }, 1);\n  };\n  var v = function(_, m, f, k) {\n    switch ((_ = p.apply(this, arguments)).type = _.type || \"info\", _.type.split(\"-\")[0]) {\n      case \"alert\":\n        return c(_);\n      case \"confirm\":\n        return u(_);\n      case \"modalbox\":\n        return h(_);\n      default:\n        return function(x) {\n          v.area || (v.area = document.createElement(\"div\"), v.area.className = \"gantt_message_area\", v.area.style[v.position] = \"5px\", document.body.appendChild(v.area)), v.hide(x.id);\n          var $ = document.createElement(\"div\");\n          return $.innerHTML = \"<div>\" + x.text + \"</div>\", $.className = \"gantt-info gantt-\" + x.type, $.onclick = function() {\n            v.hide(x.id), x = null;\n          }, t._waiAria.messageInfoAttr($), v.position == \"bottom\" && v.area.firstChild ? v.area.insertBefore($, v.area.firstChild) : v.area.appendChild($), x.expire > 0 && (v.timers[x.id] = window.setTimeout(function() {\n            v && v.hide(x.id);\n          }, x.expire)), v.pull[x.id] = $, $ = null, x.id;\n        }(_);\n    }\n  };\n  v.seed = (/* @__PURE__ */ new Date()).valueOf(), v.uid = st, v.expire = 4e3, v.keyboard = !0, v.position = \"top\", v.pull = {}, v.timers = {}, v.hideAll = function() {\n    for (var _ in v.pull) v.hide(_);\n  }, v.hide = function(_) {\n    var m = v.pull[_];\n    m && m.parentNode && (window.setTimeout(function() {\n      m.parentNode.removeChild(m), m = null;\n    }, 2e3), m.className += \" hidden\", v.timers[_] && window.clearTimeout(v.timers[_]), delete v.pull[_]);\n  };\n  var b = [];\n  return t.attachEvent(\"onMessagePopup\", function(_) {\n    b.push(_);\n  }), t.attachEvent(\"onAfterMessagePopup\", function(_) {\n    for (var m = 0; m < b.length; m++) b[m] === _ && (b.splice(m, 1), m--);\n  }), t.attachEvent(\"onDestroy\", function() {\n    s.cover && s.cover.parentNode && s.cover.parentNode.removeChild(s.cover);\n    for (var _ = 0; _ < b.length; _++) b[_].parentNode && b[_].parentNode.removeChild(b[_]);\n    b = null, v.area && v.area.parentNode && v.area.parentNode.removeChild(v.area), v = null;\n  }), { alert: function() {\n    var _ = g.apply(this, arguments);\n    return _.type = _.type || \"confirm\", c(_);\n  }, confirm: function() {\n    var _ = g.apply(this, arguments);\n    return _.type = _.type || \"alert\", u(_);\n  }, message: v, modalbox: y };\n}\nfunction ze(t, e) {\n  var n = this.$config[t];\n  return n ? (n.$extendedConfig || (n.$extendedConfig = !0, Object.setPrototypeOf(n, e)), n) : e;\n}\nfunction oa(t, e) {\n  var n, i, a;\n  P(t, (n = e, { $getConfig: function() {\n    return i || (i = n ? n.$getConfig() : this.$gantt.config), this.$config.config ? ze.call(this, \"config\", i) : i;\n  }, $getTemplates: function() {\n    return a || (a = n ? n.$getTemplates() : this.$gantt.templates), this.$config.templates ? ze.call(this, \"templates\", a) : a;\n  } }));\n}\nconst la = function(t) {\n  var e = {}, n = {};\n  function i(a, r, s, o) {\n    var l = e[a];\n    if (!l || !l.create) return !1;\n    a != \"resizer\" || s.mode || (o.$config.cols ? s.mode = \"x\" : s.mode = \"y\"), a != \"viewcell\" || s.view != \"scrollbar\" || s.scroll || (o.$config.cols ? s.scroll = \"y\" : s.scroll = \"x\"), (s = q(s)).id || n[s.view] || (s.id = s.view), s.id && !s.css && (s.css = s.id + \"_cell\");\n    var d = new l.create(r, s, this, t);\n    return l.configure && l.configure(d), oa(d, o), d.$id || (d.$id = s.id || t.uid()), d.$parent || typeof r != \"object\" || (d.$parent = r), d.$config || (d.$config = s), n[d.$id] && (d.$id = t.uid()), n[d.$id] = d, d;\n  }\n  return { initUI: function(a, r) {\n    var s = \"cell\";\n    return a.view ? s = \"viewcell\" : a.resizer ? s = \"resizer\" : a.rows || a.cols ? s = \"layout\" : a.views && (s = \"multiview\"), i.call(this, s, null, a, r);\n  }, reset: function() {\n    n = {};\n  }, registerView: function(a, r, s) {\n    e[a] = { create: r, configure: s };\n  }, createView: i, getView: function(a) {\n    return n[a];\n  } };\n};\nvar da = /* @__PURE__ */ function(t) {\n  return function(e) {\n    var n = { click: {}, doubleclick: {}, contextMenu: {} };\n    function i(h, g, p, y) {\n      n[h][g] || (n[h][g] = []), n[h][g].push({ handler: p, root: y });\n    }\n    function a(h) {\n      h = h || window.event;\n      var g = e.locate(h), p = s(h, n.click), y = !0;\n      if (g !== null ? y = !e.checkEvent(\"onTaskClick\") || e.callEvent(\"onTaskClick\", [g, h]) : e.callEvent(\"onEmptyClick\", [h]), y) {\n        if (!o(p, h, g)) return;\n        switch (h.target.nodeName) {\n          case \"SELECT\":\n          case \"INPUT\":\n            return;\n        }\n        g && e.getTask(g) && !e._multiselect && e.config.select_task && e.selectTask(g);\n      }\n    }\n    function r(h) {\n      var g = (h = h || window.event).target || h.srcElement, p = e.locate(g), y = e.locate(g, e.config.link_attribute), v = !e.checkEvent(\"onContextMenu\") || e.callEvent(\"onContextMenu\", [p, y, h]);\n      return v || (h.preventDefault ? h.preventDefault() : h.returnValue = !1), v;\n    }\n    function s(h, g) {\n      for (var p = h.target || h.srcElement, y = []; p; ) {\n        var v = t.getClassName(p);\n        if (v) {\n          v = v.split(\" \");\n          for (var b = 0; b < v.length; b++) if (v[b] && g[v[b]]) for (var _ = g[v[b]], m = 0; m < _.length; m++) _[m].root && !t.isChildOf(p, _[m].root) || y.push(_[m].handler);\n        }\n        p = p.parentNode;\n      }\n      return y;\n    }\n    function o(h, g, p) {\n      for (var y = !0, v = 0; v < h.length; v++) {\n        var b = h[v].call(e, g, p, g.target || g.srcElement);\n        y = y && !(b !== void 0 && b !== !0);\n      }\n      return y;\n    }\n    function l(h) {\n      h = h || window.event;\n      var g = e.locate(h), p = s(h, n.doubleclick), y = !e.checkEvent(\"onTaskDblClick\") || g === null || e.callEvent(\"onTaskDblClick\", [g, h]);\n      if (y) {\n        if (!o(p, h, g)) return;\n        g !== null && e.getTask(g) && y && e.config.details_on_dblclick && !e.isReadonly(g) && e.showLightbox(g);\n      }\n    }\n    function d(h) {\n      if (e.checkEvent(\"onMouseMove\")) {\n        var g = e.locate(h);\n        e._last_move_event = h, e.callEvent(\"onMouseMove\", [g, h]);\n      }\n    }\n    var c = e._createDomEventScope();\n    function u(h) {\n      c.detachAll(), h && (c.attach(h, \"click\", a), c.attach(h, \"dblclick\", l), c.attach(h, \"mousemove\", d), c.attach(h, \"contextmenu\", r));\n    }\n    return { reset: u, global: function(h, g, p) {\n      i(h, g, p, null);\n    }, delegate: i, detach: function(h, g, p, y) {\n      if (n[h] && n[h][g]) {\n        for (var v = n[h], b = v[g], _ = 0; _ < b.length; _++) b[_].root == y && (b.splice(_, 1), _--);\n        b.length || delete v[g];\n      }\n    }, callHandler: function(h, g, p, y) {\n      var v = n[h][g];\n      if (v) for (var b = 0; b < v.length; b++) (p || v[b].root) && v[b].root !== p || v[b].handler.apply(this, y);\n    }, onDoubleClick: l, onMouseMove: d, onContextMenu: r, onClick: a, destructor: function() {\n      u(), n = null, c = null;\n    } };\n  };\n}(rn);\nconst ca = { init: da };\nfunction We(t, e, n) {\n  return !!e && !(e.left > t.x_end || e.left + e.width < t.x) && !(e.top > t.y_end || e.top + e.height < t.y);\n}\nfunction Nt(t) {\n  return t.config.smart_rendering && t._smart_render;\n}\nfunction Kt(t, e, n) {\n  return { top: e.getItemTop(t.id), height: e.getItemHeight(t.id), left: 0, right: 1 / 0 };\n}\nfunction ft(t, e, n, i, a) {\n  var r = e.getItemIndexByTopPosition(a.y) || 0, s = e.getItemIndexByTopPosition(a.y_end) || i.count(), o = Math.max(0, r - 1), l = Math.min(i.count(), s + 1);\n  const d = [];\n  if (t.config.keyboard_navigation && t.getSelectedId() && t.getTask(t.getSelectedId()).$expanded_branch && d.push(t.getSelectedId()), t.$ui.getView(\"grid\") && t.ext.inlineEditors && t.ext.inlineEditors.getState().id) {\n    let c = t.ext.inlineEditors.getState().id;\n    i.exists(c) && d.push(c);\n  }\n  return { start: o, end: l, ids: d };\n}\nvar ua = function(t) {\n  var e = /* @__PURE__ */ function(n) {\n    var i = {}, a = {};\n    function r(o) {\n      var l = null;\n      return typeof o.view == \"string\" ? l = n.$ui.getView(o.view) : o.view && (l = o.view), l;\n    }\n    function s(o, l, d) {\n      if (a[o]) return a[o];\n      l.renderer || n.assert(!1, \"Invalid renderer call\");\n      var c = null, u = null, h = null, g = null, p = null;\n      typeof l.renderer == \"function\" ? (c = l.renderer, h = Kt) : (c = l.renderer.render, u = l.renderer.update, g = l.renderer.onrender, l.renderer.isInViewPort ? p = l.renderer.isInViewPort : h = l.renderer.getRectangle, h || h === null || (h = Kt));\n      var y = l.filter;\n      return d && d.setAttribute(n.config.layer_attribute, !0), a[o] = { render_item: function(v, b, _, m, f) {\n        if (b = b || d, !y || y(v)) {\n          var k = m || r(l), x = f || (k ? k.$getConfig() : null), $ = _;\n          !$ && x && x.smart_rendering && ($ = k.getViewPort());\n          var w = null;\n          !Nt(n) && (h || p) && $ ? (p ? p(v, $, k, x, n) : We($, h(v, k, x, n))) && (w = c.call(n, v, k, x, $)) : w = c.call(n, v, k, x, $), this.append(v, w, b);\n          var S = b.nodeType == 11;\n          g && !S && w && g.call(n, v, w, k);\n        } else this.remove_item(v.id);\n      }, clear: function(v) {\n        this.rendered = i[o] = {}, l.append || this.clear_container(v);\n      }, clear_container: function(v) {\n        (v = v || d) && (v.innerHTML = \"\");\n      }, get_visible_range: function(v) {\n        var b, _, m = r(l), f = m ? m.$getConfig() : null;\n        return f && f.smart_rendering && (b = m.getViewPort()), m && b && (typeof l.renderer == \"function\" ? _ = ft(n, m, 0, v, b) : l.renderer && l.renderer.getVisibleRange && (_ = l.renderer.getVisibleRange(n, m, f, v, b))), _ || (_ = { start: 0, end: v.count() }), _;\n      }, prepare_data: function(v) {\n        if (l.renderer && l.renderer.prepareData) return l.renderer.prepareData(v, n, l);\n      }, render_items: function(v, b) {\n        b = b || d;\n        var _ = document.createDocumentFragment();\n        this.clear(b);\n        var m = null, f = r(l), k = f ? f.$getConfig() : null;\n        k && k.smart_rendering && (m = f.getViewPort());\n        for (var x = 0, $ = v.length; x < $; x++) this.render_item(v[x], _, m, f, k);\n        b.appendChild(_, b);\n        var w = {};\n        v.forEach(function(E) {\n          w[E.id] = E;\n        });\n        var S = {};\n        if (g) {\n          var T = {};\n          for (var x in this.rendered) S[x] || (T[x] = this.rendered[x], g.call(n, w[x], this.rendered[x], f));\n        }\n      }, update_items: function(v, b) {\n        var _ = r(l), m = _ ? _.$getConfig() : null;\n        if (_ && _.$getConfig().smart_rendering && !Nt(n) && this.rendered && (h || p)) {\n          b = b || d;\n          var f = document.createDocumentFragment(), k = null;\n          _ && (k = _.getViewPort());\n          var x = {};\n          v.forEach(function(I) {\n            x[I.id] = I;\n          });\n          var $ = {}, w = {};\n          for (var S in this.rendered) w[S] = !0, $[S] = !0;\n          for (var T = {}, E = (S = 0, v.length); S < E; S++) {\n            var C = v[S], D = this.rendered[C.id];\n            w[C.id] = !1, D && D.parentNode ? (p ? p(C, k, _, m, n) : We(k, h(C, _, m, n))) ? (u && u.call(n, C, D, _, m, k), this.restore(C, f)) : w[C.id] = !0 : (T[v[S].id] = !0, this.render_item(v[S], f, k, _, m));\n          }\n          for (var S in w) w[S] && this.hide(S);\n          if (f.childNodes.length && b.appendChild(f, b), g) {\n            var M = {};\n            for (var S in this.rendered) $[S] && !T[S] || (M[S] = this.rendered[S], g.call(n, x[S], this.rendered[S], _));\n          }\n        }\n      }, append: function(v, b, _) {\n        this.rendered && (b ? (this.rendered[v.id] && this.rendered[v.id].parentNode ? this.replace_item(v.id, b) : _.appendChild(b), this.rendered[v.id] = b) : this.rendered[v.id] && this.remove_item(v.id));\n      }, replace_item: function(v, b) {\n        var _ = this.rendered[v];\n        _ && _.parentNode && _.parentNode.replaceChild(b, _), this.rendered[v] = b;\n      }, remove_item: function(v) {\n        this.hide(v), delete this.rendered[v];\n      }, hide: function(v) {\n        var b = this.rendered[v];\n        b && b.parentNode && b.parentNode.removeChild(b), delete this.rendered[v];\n      }, restore: function(v, b) {\n        var _ = this.rendered[v.id];\n        _ ? _.parentNode || this.append(v, _, b || d) : this.render_item(v, b || d);\n      }, change_id: function(v, b) {\n        this.rendered[b] = this.rendered[v], delete this.rendered[v];\n      }, rendered: i[o], node: d, destructor: function() {\n        this.clear(), delete a[o], delete i[o];\n      } }, a[o];\n    }\n    return { getRenderer: s, clearRenderers: function() {\n      for (var o in a) s(o).destructor();\n    } };\n  }(t);\n  return { createGroup: function(n, i, a, r) {\n    var s = { tempCollection: [], renderers: {}, container: n, filters: [], getLayers: function() {\n      this._add();\n      var o = [];\n      for (var l in this.renderers) o.push(this.renderers[l]);\n      return o;\n    }, getLayer: function(o) {\n      return this.renderers[o];\n    }, _add: function(o) {\n      o && (o.id = o.id || st(), this.tempCollection.push(o));\n      for (var l = this.container(), d = this.tempCollection, c = 0; c < d.length; c++) if (o = d[c], this.container() || o && o.container && Y(o.container, document.body)) {\n        var u = o.container, h = o.id, g = o.topmost;\n        if (!u.parentNode) if (g) l.appendChild(u);\n        else {\n          var p = i ? i() : l.firstChild;\n          p && p.parentNode == l ? l.insertBefore(u, p) : l.appendChild(u);\n        }\n        this.renderers[h] = e.getRenderer(h, o, u), r && r(o, t), this.tempCollection.splice(c, 1), c--;\n      }\n    }, addLayer: function(o) {\n      if (o) {\n        typeof o == \"function\" && (o = { renderer: o }), o.filter === void 0 ? o.filter = je(a || []) : o.filter instanceof Array && (o.filter.push(a), o.filter = je(o.filter)), o.container || (o.container = document.createElement(\"div\"));\n        var l = this;\n        o.requestUpdate = function() {\n          t.config.smart_rendering && !Nt(t) && l.renderers[o.id] && l.onUpdateRequest(l.renderers[o.id]);\n        };\n      }\n      return this._add(o), o ? o.id : void 0;\n    }, onUpdateRequest: function(o) {\n    }, eachLayer: function(o) {\n      for (var l in this.renderers) o(this.renderers[l]);\n    }, removeLayer: function(o) {\n      this.renderers[o] && (this.renderers[o].destructor(), delete this.renderers[o]);\n    }, clear: function() {\n      for (var o in this.renderers) this.renderers[o].destructor();\n      this.renderers = {};\n    } };\n    return t.attachEvent(\"onDestroy\", function() {\n      s.clear(), s = null;\n    }), s;\n  } };\n};\nfunction je(t) {\n  return t instanceof Array || (t = Array.prototype.slice.call(arguments, 0)), function(e) {\n    for (var n = !0, i = 0, a = t.length; i < a; i++) {\n      var r = t[i];\n      r && (n = n && r(e.id, e) !== !1);\n    }\n    return n;\n  };\n}\nfunction Fe(t, e, n) {\n  if (!t.start_date || !t.end_date) return null;\n  var i = e.posFromDate(t.start_date), a = e.posFromDate(t.end_date), r = Math.min(i, a) - 200, s = Math.max(i, a) + 200;\n  return { top: e.getItemTop(t.id), height: e.getItemHeight(t.id), left: r, width: s - r };\n}\nfunction mn() {\n  var t = [], e = !1;\n  function n() {\n    t = [], e = !1;\n  }\n  function i(r, s, o) {\n    s.$getConfig(), r.getVisibleItems().forEach(function(l) {\n      var d = function(c, u, h, g) {\n        if (!g.isTaskExists(c.source) || !g.isTaskExists(c.target)) return null;\n        var p = Fe(g.getTask(c.source), u), y = Fe(g.getTask(c.target), u);\n        if (!p || !y) return null;\n        var v = 100, b = Math.min(p.left, y.left) - v, _ = Math.max(p.left + p.width, y.left + y.width) + v, m = Math.min(p.top, y.top) - v, f = Math.max(p.top + p.height, y.top + y.height) + v;\n        return { top: m, height: f - m, bottom: f, left: b, width: _ - b, right: _ };\n      }(l, s, 0, o);\n      d && t.push({ id: l.id, rec: d });\n    }), t.sort(function(l, d) {\n      return l.rec.right < d.rec.right ? -1 : 1;\n    }), e = !0;\n  }\n  var a = !1;\n  return function(r, s, o, l, d) {\n    (function(p) {\n      a || (a = !0, p.attachEvent(\"onPreFilter\", n), p.attachEvent(\"onStoreUpdated\", n), p.attachEvent(\"onClearAll\", n), p.attachEvent(\"onBeforeStoreUpdate\", n));\n    })(l), e || i(l, s, r);\n    for (var c = [], u = 0; u < t.length; u++) {\n      var h = t[u], g = h.rec;\n      g.right < d.x || g.left < d.x_end && g.right > d.x && g.top < d.y_end && g.bottom > d.y && c.push(h.id);\n    }\n    return { ids: c };\n  };\n}\nfunction vn(t, e, n, i, a) {\n  var r = n.$gantt.getTask(t.source), s = n.$gantt.getTask(t.target), o = n.getItemTop(r.id), l = n.getItemHeight(r.id), d = n.getItemTop(s.id), c = n.getItemHeight(s.id);\n  if (e.y > o + l && e.y > d + c || e.y_end < d && e.y_end < o) return !1;\n  var u = n.posFromDate(r.start_date), h = n.posFromDate(r.end_date), g = n.posFromDate(s.start_date), p = n.posFromDate(s.end_date);\n  if (u > h) {\n    var y = h;\n    h = u, u = y;\n  }\n  return g > p && (y = p, p = g, g = y), u += -100, h += 100, g += -100, p += 100, !(e.x > h && e.x > p) && !(e.x_end < u && e.x_end < g);\n}\nfunction ha(t, e) {\n  if (t.view) {\n    var n = t.view;\n    typeof n == \"string\" && (n = e.$ui.getView(n)), n && n.attachEvent && n.attachEvent(\"onScroll\", function() {\n      e.$services.getService(\"state\").getState(\"batchUpdate\").batch_update || n.$config.$skipSmartRenderOnScroll || t.requestUpdate && t.requestUpdate();\n    });\n  }\n}\nvar Ht = function() {\n  function t(e, n, i, a) {\n    e && (this.$container = we(e), this.$parent = e), this.$config = P(n, { headerHeight: 33 }), this.$gantt = a, this.$domEvents = a._createDomEventScope(), this.$id = n.id || \"c\" + st(), this.$name = \"cell\", this.$factory = i, this.$externalComponent = null, ot(this);\n  }\n  return t.prototype.destructor = function() {\n    this.$parent = this.$container = this.$view = null, this.$gantt.$services.getService(\"mouseEvents\").detach(\"click\", \"gantt_header_arrow\", this._headerClickHandler), this.$domEvents.detachAll(), this.callEvent(\"onDestroy\", []), this.detachAllEvents();\n  }, t.prototype.cell = function(e) {\n    return null;\n  }, t.prototype.scrollTo = function(e, n) {\n    var i = this.$view;\n    this.$config.html && (i = this.$view.firstChild), 1 * e == e && (i.scrollLeft = e), 1 * n == n && (i.scrollTop = n);\n  }, t.prototype.clear = function() {\n    this.getNode().innerHTML = \"\", this.getNode().className = \"gantt_layout_content\", this.getNode().style.padding = \"0\";\n  }, t.prototype.resize = function(e) {\n    if (this.$parent) return this.$parent.resize(e);\n    e === !1 && (this.$preResize = !0);\n    var n = this.$container, i = n.offsetWidth, a = n.offsetHeight, r = this.getSize();\n    n === document.body && (i = document.body.offsetWidth, a = document.body.offsetHeight), i < r.minWidth && (i = r.minWidth), i > r.maxWidth && (i = r.maxWidth), a < r.minHeight && (a = r.minHeight), a > r.maxHeight && (a = r.maxHeight), this.setSize(i, a), this.$preResize, this.$preResize = !1;\n  }, t.prototype.hide = function() {\n    this._hide(!0), this.resize();\n  }, t.prototype.show = function(e) {\n    this._hide(!1), e && this.$parent && this.$parent.show(), this.resize();\n  }, t.prototype._hide = function(e) {\n    if (e === !0 && this.$view.parentNode) this.$view.parentNode.removeChild(this.$view);\n    else if (e === !1 && !this.$view.parentNode) {\n      var n = this.$parent.cellIndex(this.$id);\n      this.$parent.moveView(this, n);\n    }\n    this.$config.hidden = e;\n  }, t.prototype.$toHTML = function(e, n) {\n    e === void 0 && (e = \"\"), n = [n || \"\", this.$config.css || \"\"].join(\" \");\n    var i = this.$config, a = \"\";\n    if (i.raw) e = typeof i.raw == \"string\" ? i.raw : \"\";\n    else {\n      if (!e) {\n        let r = null;\n        r = typeof i.html == \"function\" ? i.html() : i.html, this.$gantt.config.external_render && this.$gantt.config.external_render.isElement(r) && (this.$externalComponent = r, r = null), e = \"<div class='gantt_layout_content' \" + (n ? \" class='\" + n + \"' \" : \"\") + \" >\" + (r || \"\") + \"</div>\";\n      }\n      i.header && (a = \"<div class='gantt_layout_header'>\" + (i.canCollapse ? \"<div class='gantt_layout_header_arrow'></div>\" : \"\") + \"<div class='gantt_layout_header_content'>\" + i.header + \"</div></div>\");\n    }\n    return \"<div class='gantt_layout_cell \" + n + \"' data-cell-id='\" + this.$id + \"'>\" + a + e + \"</div>\";\n  }, t.prototype.$fill = function(e, n) {\n    this.$view = e, this.$parent = n, this.init();\n  }, t.prototype.getNode = function() {\n    return this.$view.querySelector(\"gantt_layout_cell\") || this.$view;\n  }, t.prototype.init = function() {\n    var e = this;\n    this._headerClickHandler = function(n) {\n      et(n, \"data-cell-id\") == e.$id && e.toggle();\n    }, this.$gantt.$services.getService(\"mouseEvents\").delegate(\"click\", \"gantt_header_arrow\", this._headerClickHandler), this.callEvent(\"onReady\", []);\n  }, t.prototype.toggle = function() {\n    this.$config.collapsed = !this.$config.collapsed, this.resize();\n  }, t.prototype.getSize = function() {\n    var e = { height: this.$config.height || 0, width: this.$config.width || 0, gravity: this.$config.gravity || 1, minHeight: this.$config.minHeight || 0, minWidth: this.$config.minWidth || 0, maxHeight: this.$config.maxHeight || 1e11, maxWidth: this.$config.maxWidth || 1e11 };\n    if (this.$config.collapsed) {\n      var n = this.$config.mode === \"x\";\n      e[n ? \"width\" : \"height\"] = e[n ? \"maxWidth\" : \"maxHeight\"] = this.$config.headerHeight;\n    }\n    return e;\n  }, t.prototype.getContentSize = function() {\n    var e = this.$lastSize.contentX;\n    e !== 1 * e && (e = this.$lastSize.width);\n    var n = this.$lastSize.contentY;\n    return n !== 1 * n && (n = this.$lastSize.height), { width: e, height: n };\n  }, t.prototype._getBorderSizes = function() {\n    var e = { top: 0, right: 0, bottom: 0, left: 0, horizontal: 0, vertical: 0 };\n    return this._currentBorders && (this._currentBorders[this._borders.left] && (e.left = 1, e.horizontal++), this._currentBorders[this._borders.right] && (e.right = 1, e.horizontal++), this._currentBorders[this._borders.top] && (e.top = 1, e.vertical++), this._currentBorders[this._borders.bottom] && (e.bottom = 1, e.vertical++)), e;\n  }, t.prototype.setSize = function(e, n) {\n    this.$view.style.width = e + \"px\", this.$view.style.height = n + \"px\";\n    var i = this._getBorderSizes(), a = n - i.vertical, r = e - i.horizontal;\n    this.$lastSize = { x: e, y: n, contentX: r, contentY: a }, this.$config.header ? this._sizeHeader() : this._sizeContent();\n  }, t.prototype._borders = { left: \"gantt_layout_cell_border_left\", right: \"gantt_layout_cell_border_right\", top: \"gantt_layout_cell_border_top\", bottom: \"gantt_layout_cell_border_bottom\" }, t.prototype._setBorders = function(e, n) {\n    n || (n = this);\n    var i = n.$view;\n    for (var a in this._borders) Gt(i, this._borders[a]);\n    typeof e == \"string\" && (e = [e]);\n    var r = {};\n    for (a = 0; a < e.length; a++) wt(i, e[a]), r[e[a]] = !0;\n    n._currentBorders = r;\n  }, t.prototype._sizeContent = function() {\n    var e = this.$view.childNodes[0];\n    e && e.className == \"gantt_layout_content\" && (e.style.height = this.$lastSize.contentY + \"px\");\n  }, t.prototype._sizeHeader = function() {\n    var e = this.$lastSize;\n    e.contentY -= this.$config.headerHeight;\n    var n = this.$view.childNodes[0], i = this.$view.childNodes[1], a = this.$config.mode === \"x\";\n    if (this.$config.collapsed) if (i.style.display = \"none\", a) {\n      n.className = \"gantt_layout_header collapsed_x\", n.style.width = e.y + \"px\";\n      var r = Math.floor(e.y / 2 - e.x / 2);\n      n.style.transform = \"rotate(90deg) translate(\" + r + \"px, \" + r + \"px)\", i.style.display = \"none\";\n    } else n.className = \"gantt_layout_header collapsed_y\";\n    else n.className = a ? \"gantt_layout_header\" : \"gantt_layout_header vertical\", n.style.width = \"auto\", n.style.transform = \"\", i.style.display = \"\", i.style.height = e.contentY + \"px\";\n    n.style.height = this.$config.headerHeight + \"px\";\n  }, t;\n}();\nfunction z(t, e) {\n  for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]);\n  function i() {\n    this.constructor = t;\n  }\n  t.prototype = e === null ? Object.create(e) : (i.prototype = e.prototype, new i());\n}\nvar kn = function(t) {\n  function e(n, i, a) {\n    var r = t.apply(this, arguments) || this;\n    return n && (r.$root = !0), r._parseConfig(i), r.$name = \"layout\", r;\n  }\n  return z(e, t), e.prototype.destructor = function() {\n    this.$container && this.$view && Qe(this.$view);\n    for (var n = 0; n < this.$cells.length; n++)\n      this.$cells[n].destructor();\n    this.$cells = [], t.prototype.destructor.call(this);\n  }, e.prototype._resizeScrollbars = function(n, i) {\n    var a = !1, r = [], s = [];\n    const o = [];\n    function l(p) {\n      p.$parent.show(), a = !0, r.push(p);\n    }\n    function d(p) {\n      p.$parent.hide(), a = !0, s.push(p);\n    }\n    for (var c, u = 0; u < i.length; u++) n[(c = i[u]).$config.scroll] ? d(c) : c.shouldHide() ? o.push(c) : c.shouldShow() ? l(c) : c.isVisible() ? r.push(c) : s.push(c);\n    var h = {};\n    for (u = 0; u < r.length; u++) r[u].$config.group && (h[r[u].$config.group] = !0);\n    for (o.forEach(function(p) {\n      p.$config.group && h[p.$config.group] || d(p);\n    }), u = 0; u < s.length; u++) if ((c = s[u]).$config.group && h[c.$config.group]) {\n      l(c);\n      for (var g = 0; g < r.length; g++) if (r[g] == c) {\n        this.$gantt.$scrollbarRepaint = !0;\n        break;\n      }\n    }\n    return a;\n  }, e.prototype.getScrollbarsInfo = function() {\n    const n = this.getCellsByType(\"scroller\"), i = [];\n    return n.forEach((a) => {\n      let r = {};\n      const { visible: s, direction: o, size: l, scrollSize: d, position: c } = a.getScrollState();\n      let u = a._getLinkedViews().map((h) => h.$config.id);\n      r.id = a.$id, r.visible = s, r.boundViews = u, o === \"x\" ? (r.x = l, r.x_inner = d, r.x_pos = c || 0) : (r.y = l, r.y_inner = d, r.y_pos = c || 0), i.push(r);\n    }), i;\n  }, e.prototype._syncCellSizes = function(n, i) {\n    if (n) {\n      var a = {};\n      return this._eachChild(function(r) {\n        r.$config.group && r.$name != \"scrollbar\" && r.$name != \"resizer\" && (a[r.$config.group] || (a[r.$config.group] = []), a[r.$config.group].push(r));\n      }), a[n] && this._syncGroupSize(a[n], i), a[n];\n    }\n  }, e.prototype._syncGroupSize = function(n, i) {\n    if (n.length) for (var a = n[0].$parent._xLayout ? \"width\" : \"height\", r = n[0].$parent.getNextSibling(n[0].$id) ? 1 : -1, s = i.value, o = i.isGravity, l = 0; l < n.length; l++) {\n      var d = n[l].getSize(), c = r > 0 ? n[l].$parent.getNextSibling(n[l].$id) : n[l].$parent.getPrevSibling(n[l].$id);\n      c.$name == \"resizer\" && (c = r > 0 ? c.$parent.getNextSibling(c.$id) : c.$parent.getPrevSibling(c.$id));\n      var u = c.getSize();\n      if (o) n[l].$config.gravity = s;\n      else if (c[a]) {\n        var h = d.gravity + u.gravity, g = d[a] + u[a], p = h / g;\n        n[l].$config.gravity = p * s, c.$config[a] = g - s, c.$config.gravity = h - p * s;\n      } else n[l].$config[a] = s;\n      var y = this.$gantt.$ui.getView(\"grid\");\n      !y || n[l].$content !== y || y.$config.scrollable || o || (this.$gantt.config.grid_width = s);\n    }\n  }, e.prototype.resize = function(n) {\n    var i = !1;\n    if (this.$root && !this._resizeInProgress && (this.callEvent(\"onBeforeResize\", []), i = !0, this._resizeInProgress = !0), t.prototype.resize.call(this, !0), t.prototype.resize.call(this, !1), i) {\n      var a = [];\n      a = (a = (a = a.concat(this.getCellsByType(\"viewCell\"))).concat(this.getCellsByType(\"viewLayout\"))).concat(this.getCellsByType(\"hostCell\"));\n      for (var r = this.getCellsByType(\"scroller\"), s = 0; s < a.length; s++) a[s].$config.hidden || a[s].setContentSize();\n      var o = this._getAutosizeMode(this.$config.autosize), l = this._resizeScrollbars(o, r);\n      if (this.$config.autosize && (this.autosize(this.$config.autosize), a.forEach(function(d) {\n        const c = d.$parent, u = c.getContentSize(o);\n        o.x && (c.$config.$originalWidthStored || (c.$config.$originalWidthStored = !0, c.$config.$originalWidth = c.$config.width), c.$config.width = u.width), o.y && (c.$config.$originalHeightStored || (c.$config.$originalHeightStored = !0, c.$config.$originalHeight = c.$config.height), c.$config.height = u.height);\n      }), l = !0), l)\n        for (this.resize(), s = 0; s < a.length; s++) a[s].$config.hidden || a[s].setContentSize();\n      this.callEvent(\"onResize\", []);\n    }\n    i && (this._resizeInProgress = !1);\n  }, e.prototype._eachChild = function(n, i) {\n    if (n(i = i || this), i.$cells) for (var a = 0; a < i.$cells.length; a++) this._eachChild(n, i.$cells[a]);\n  }, e.prototype.isChild = function(n) {\n    var i = !1;\n    return this._eachChild(function(a) {\n      a !== n && a.$content !== n || (i = !0);\n    }), i;\n  }, e.prototype.getCellsByType = function(n) {\n    var i = [];\n    if (n === this.$name && i.push(this), this.$content && this.$content.$name == n && i.push(this.$content), this.$cells) for (var a = 0; a < this.$cells.length; a++) {\n      var r = e.prototype.getCellsByType.call(this.$cells[a], n);\n      r.length && i.push.apply(i, r);\n    }\n    return i;\n  }, e.prototype.getNextSibling = function(n) {\n    var i = this.cellIndex(n);\n    return i >= 0 && this.$cells[i + 1] ? this.$cells[i + 1] : null;\n  }, e.prototype.getPrevSibling = function(n) {\n    var i = this.cellIndex(n);\n    return i >= 0 && this.$cells[i - 1] ? this.$cells[i - 1] : null;\n  }, e.prototype.cell = function(n) {\n    for (var i = 0; i < this.$cells.length; i++) {\n      var a = this.$cells[i];\n      if (a.$id === n) return a;\n      var r = a.cell(n);\n      if (r) return r;\n    }\n  }, e.prototype.cellIndex = function(n) {\n    for (var i = 0; i < this.$cells.length; i++) if (this.$cells[i].$id === n) return i;\n    return -1;\n  }, e.prototype.moveView = function(n, i) {\n    if (this.$cells[i] !== n) return window.alert(\"Not implemented\");\n    i += this.$config.header ? 1 : 0;\n    var a = this.$view;\n    i >= a.childNodes.length ? a.appendChild(n.$view) : a.insertBefore(n.$view, a.childNodes[i]);\n  }, e.prototype._parseConfig = function(n) {\n    this.$cells = [], this._xLayout = !n.rows;\n    for (var i = n.rows || n.cols || n.views, a = 0; a < i.length; a++) {\n      var r = i[a];\n      r.mode = this._xLayout ? \"x\" : \"y\";\n      var s = this.$factory.initUI(r, this);\n      s ? (s.$parent = this, this.$cells.push(s)) : (i.splice(a, 1), a--);\n    }\n  }, e.prototype.getCells = function() {\n    return this.$cells;\n  }, e.prototype.render = function() {\n    var n = Ze(this.$container, this.$toHTML());\n    this.$fill(n, null);\n    const i = this.$gantt;\n    this._eachChild((a) => {\n      a.$externalComponent && (i.config.external_render.renderElement(a.$externalComponent, a.$view.querySelector(\".gantt_layout_content\")), a.$externalComponent = null);\n    }), this.callEvent(\"onReady\", []), this.resize(), this.render = this.resize;\n  }, e.prototype.$fill = function(n, i) {\n    this.$view = n, this.$parent = i;\n    for (var a = tn(n, \"gantt_layout_cell\"), r = a.length - 1; r >= 0; r--) {\n      var s = this.$cells[r];\n      s.$fill(a[r], this), s.$config.hidden && s.$view.parentNode.removeChild(s.$view);\n    }\n  }, e.prototype.$toHTML = function() {\n    for (var n = this._xLayout ? \"x\" : \"y\", i = [], a = 0; a < this.$cells.length; a++) i.push(this.$cells[a].$toHTML());\n    return t.prototype.$toHTML.call(this, i.join(\"\"), (this.$root ? \"gantt_layout_root \" : \"\") + \"gantt_layout gantt_layout_\" + n);\n  }, e.prototype.getContentSize = function(n) {\n    for (var i, a, r, s = 0, o = 0, l = 0; l < this.$cells.length; l++) (a = this.$cells[l]).$config.hidden || (i = a.getContentSize(n), a.$config.view === \"scrollbar\" && n[a.$config.scroll] && (i.height = 0, i.width = 0), a.$config.resizer && (this._xLayout ? i.height = 0 : i.width = 0), r = a._getBorderSizes(), this._xLayout ? (s += i.width + r.horizontal, o = Math.max(o, i.height + r.vertical)) : (s = Math.max(s, i.width + r.horizontal), o += i.height + r.vertical));\n    return { width: s += (r = this._getBorderSizes()).horizontal, height: o += r.vertical };\n  }, e.prototype._cleanElSize = function(n) {\n    return 1 * (n || \"\").toString().replace(\"px\", \"\") || 0;\n  }, e.prototype._getBoxStyles = function(n) {\n    var i = null, a = [\"width\", \"height\", \"paddingTop\", \"paddingBottom\", \"paddingLeft\", \"paddingRight\", \"borderLeftWidth\", \"borderRightWidth\", \"borderTopWidth\", \"borderBottomWidth\"], r = { boxSizing: (i = window.getComputedStyle ? window.getComputedStyle(n, null) : { width: n.clientWidth, height: n.clientHeight }).boxSizing == \"border-box\" };\n    i.MozBoxSizing && (r.boxSizing = i.MozBoxSizing == \"border-box\");\n    for (var s = 0; s < a.length; s++) r[a[s]] = i[a[s]] ? this._cleanElSize(i[a[s]]) : 0;\n    var o = { horPaddings: r.paddingLeft + r.paddingRight + r.borderLeftWidth + r.borderRightWidth, vertPaddings: r.paddingTop + r.paddingBottom + r.borderTopWidth + r.borderBottomWidth, borderBox: r.boxSizing, innerWidth: r.width, innerHeight: r.height, outerWidth: r.width, outerHeight: r.height };\n    return o.borderBox ? (o.innerWidth -= o.horPaddings, o.innerHeight -= o.vertPaddings) : (o.outerWidth += o.horPaddings, o.outerHeight += o.vertPaddings), o;\n  }, e.prototype._getAutosizeMode = function(n) {\n    var i = { x: !1, y: !1 };\n    return n === \"xy\" ? i.x = i.y = !0 : n === \"y\" || n === !0 ? i.y = !0 : n === \"x\" && (i.x = !0), i;\n  }, e.prototype.autosize = function(n) {\n    var i = this._getAutosizeMode(n), a = this._getBoxStyles(this.$container), r = this.getContentSize(n), s = this.$container;\n    i.x && (a.borderBox && (r.width += a.horPaddings), s.style.width = r.width + \"px\"), i.y && (a.borderBox && (r.height += a.vertPaddings), s.style.height = r.height + \"px\");\n  }, e.prototype.getSize = function() {\n    this._sizes = [];\n    for (var n = 0, i = 0, a = 1e11, r = 0, s = 1e11, o = 0, l = 0; l < this.$cells.length; l++) {\n      var d = this._sizes[l] = this.$cells[l].getSize();\n      this.$cells[l].$config.hidden || (this._xLayout ? (!d.width && d.minWidth ? n += d.minWidth : n += d.width, a += d.maxWidth, i += d.minWidth, r = Math.max(r, d.height), s = Math.min(s, d.maxHeight), o = Math.max(o, d.minHeight)) : (!d.height && d.minHeight ? r += d.minHeight : r += d.height, s += d.maxHeight, o += d.minHeight, n = Math.max(n, d.width), a = Math.min(a, d.maxWidth), i = Math.max(i, d.minWidth)));\n    }\n    var c = t.prototype.getSize.call(this);\n    return c.maxWidth >= 1e5 && (c.maxWidth = a), c.maxHeight >= 1e5 && (c.maxHeight = s), c.minWidth = c.minWidth != c.minWidth ? 0 : c.minWidth, c.minHeight = c.minHeight != c.minHeight ? 0 : c.minHeight, this._xLayout ? (c.minWidth += this.$config.margin * this.$cells.length || 0, c.minWidth += 2 * this.$config.padding || 0, c.minHeight += 2 * this.$config.padding || 0) : (c.minHeight += this.$config.margin * this.$cells.length || 0, c.minHeight += 2 * this.$config.padding || 0), c;\n  }, e.prototype._calcFreeSpace = function(n, i, a) {\n    var r = a ? i.minWidth : i.minHeight, s = i.maxWidth, o = n;\n    return o ? (o > s && (o = s), o < r && (o = r), this._free -= o) : ((o = Math.floor(this._free / this._gravity * i.gravity)) > s && (o = s, this._free -= o, this._gravity -= i.gravity), o < r && (o = r, this._free -= o, this._gravity -= i.gravity)), o;\n  }, e.prototype._calcSize = function(n, i, a) {\n    var r = n, s = a ? i.minWidth : i.minHeight, o = a ? i.maxWidth : i.maxHeight;\n    return r || (r = Math.floor(this._free / this._gravity * i.gravity)), r > o && (r = o), r < s && (r = s), r;\n  }, e.prototype._configureBorders = function() {\n    this.$root && this._setBorders([this._borders.left, this._borders.top, this._borders.right, this._borders.bottom], this);\n    for (var n = this._xLayout ? this._borders.right : this._borders.bottom, i = this.$cells, a = i.length - 1, r = a; r >= 0; r--) if (!i[r].$config.hidden) {\n      a = r;\n      break;\n    }\n    for (r = 0; r < i.length; r++) if (!i[r].$config.hidden) {\n      var s = r >= a, o = \"\";\n      !s && i[r + 1] && i[r + 1].$config.view == \"scrollbar\" && (this._xLayout ? s = !0 : o = \"gantt_layout_cell_border_transparent\"), this._setBorders(s ? [] : [n, o], i[r]);\n    }\n  }, e.prototype._updateCellVisibility = function() {\n    for (var n = this._visibleCells || {}, i = !this._visibleCells, a = {}, r = null, s = [], o = 0; o < this._sizes.length; o++) (r = this.$cells[o]).$config.hide_empty && s.push(r), !i && r.$config.hidden && n[r.$id] ? r._hide(!0) : r.$config.hidden || n[r.$id] || r._hide(!1), r.$config.hidden || (a[r.$id] = !0);\n    for (this._visibleCells = a, o = 0; o < s.length; o++) {\n      var l = (r = s[o]).$cells, d = !0;\n      l.forEach(function(c) {\n        c.$config.hidden || c.$config.resizer || (d = !1);\n      }), r.$config.hidden = d;\n    }\n  }, e.prototype.setSize = function(n, i) {\n    this._configureBorders(), t.prototype.setSize.call(this, n, i), i = this.$lastSize.contentY, n = this.$lastSize.contentX;\n    var a, r, s = this.$config.padding || 0;\n    this.$view.style.padding = s + \"px\", this._gravity = 0, this._free = this._xLayout ? n : i, this._free -= 2 * s, this._updateCellVisibility();\n    for (var o = 0; o < this._sizes.length; o++) if (!(a = this.$cells[o]).$config.hidden) {\n      var l = this.$config.margin || 0;\n      a.$name != \"resizer\" || l || (l = -1);\n      var d = a.$view, c = this._xLayout ? \"marginRight\" : \"marginBottom\";\n      o !== this.$cells.length - 1 && (d.style[c] = l + \"px\", this._free -= l), r = this._sizes[o], this._xLayout ? r.width || (this._gravity += r.gravity) : r.height || (this._gravity += r.gravity);\n    }\n    for (o = 0; o < this._sizes.length; o++) if (!(a = this.$cells[o]).$config.hidden) {\n      var u = (r = this._sizes[o]).width, h = r.height;\n      this._xLayout ? this._calcFreeSpace(u, r, !0) : this._calcFreeSpace(h, r, !1);\n    }\n    for (o = 0; o < this.$cells.length; o++) if (!(a = this.$cells[o]).$config.hidden) {\n      r = this._sizes[o];\n      var g = void 0, p = void 0;\n      this._xLayout ? (g = this._calcSize(r.width, r, !0), p = i - 2 * s) : (g = n - 2 * s, p = this._calcSize(r.height, r, !1)), a.setSize(g, p);\n    }\n  }, e;\n}(Ht), _a = function(t) {\n  function e(n, i, a) {\n    for (var r = t.apply(this, arguments) || this, s = 0; s < r.$cells.length; s++) r.$cells[s].$config.hidden = s !== 0;\n    return r.$cell = r.$cells[0], r.$name = \"viewLayout\", r;\n  }\n  return z(e, t), e.prototype.cell = function(n) {\n    var i = t.prototype.cell.call(this, n);\n    return i.$view || this.$fill(null, this), i;\n  }, e.prototype.moveView = function(n) {\n    var i = this.$view;\n    this.$cell && (this.$cell.$config.hidden = !0, i.removeChild(this.$cell.$view)), this.$cell = n, i.appendChild(n.$view);\n  }, e.prototype.setSize = function(n, i) {\n    Ht.prototype.setSize.call(this, n, i);\n  }, e.prototype.setContentSize = function() {\n    var n = this.$lastSize;\n    this.$cell.setSize(n.contentX, n.contentY);\n  }, e.prototype.getSize = function() {\n    var n = t.prototype.getSize.call(this);\n    if (this.$cell) {\n      var i = this.$cell.getSize();\n      if (this.$config.byMaxSize) for (var a = 0; a < this.$cells.length; a++) {\n        var r = this.$cells[a].getSize();\n        for (var s in i) i[s] = Math.max(i[s], r[s]);\n      }\n      for (var o in n) n[o] = n[o] || i[o];\n      n.gravity = Math.max(n.gravity, i.gravity);\n    }\n    return n;\n  }, e;\n}(kn), ga = function(t) {\n  function e(n, i, a) {\n    var r = t.apply(this, arguments) || this;\n    if (i.view) {\n      i.id && (this.$id = st());\n      var s = q(i);\n      if (delete s.config, delete s.templates, this.$content = this.$factory.createView(i.view, this, s, this), !this.$content) return !1;\n    }\n    return r.$name = \"viewCell\", r;\n  }\n  return z(e, t), e.prototype.destructor = function() {\n    this.clear(), t.prototype.destructor.call(this);\n  }, e.prototype.clear = function() {\n    if (this.$initialized = !1, this.$content) {\n      var n = this.$content.unload || this.$content.destructor;\n      n && n.call(this.$content);\n    }\n    t.prototype.clear.call(this);\n  }, e.prototype.scrollTo = function(n, i) {\n    this.$content && this.$content.scrollTo ? this.$content.scrollTo(n, i) : t.prototype.scrollTo.call(this, n, i);\n  }, e.prototype._setContentSize = function(n, i) {\n    var a = this._getBorderSizes();\n    if (typeof n == \"number\") {\n      var r = n + a.horizontal;\n      this.$config.width = r;\n    }\n    if (typeof i == \"number\") {\n      var s = i + a.vertical;\n      this.$config.height = s;\n    }\n  }, e.prototype.setSize = function(n, i) {\n    if (t.prototype.setSize.call(this, n, i), !this.$preResize && this.$content && !this.$initialized) {\n      this.$initialized = !0;\n      var a = this.$view.childNodes[0], r = this.$view.childNodes[1];\n      r || (r = a), this.$content.init(r);\n    }\n  }, e.prototype.setContentSize = function() {\n    !this.$preResize && this.$content && this.$initialized && this.$content.setSize(this.$lastSize.contentX, this.$lastSize.contentY);\n  }, e.prototype.getContentSize = function() {\n    var n = t.prototype.getContentSize.call(this);\n    if (this.$content && this.$initialized) {\n      var i = this.$content.getSize();\n      n.width = i.contentX === void 0 ? i.width : i.contentX, n.height = i.contentY === void 0 ? i.height : i.contentY;\n    }\n    var a = this._getBorderSizes();\n    return n.width += a.horizontal, n.height += a.vertical, n;\n  }, e;\n}(Ht), fa = function(t) {\n  var e = [\"altKey\", \"shiftKey\", \"metaKey\"];\n  function n(a, r, s, o) {\n    var l = t.apply(this, arguments) || this;\n    this.$config = P(r, { scroll: \"x\" }), l._scrollHorizontalHandler = R(l._scrollHorizontalHandler, l), l._scrollVerticalHandler = R(l._scrollVerticalHandler, l), l._outerScrollVerticalHandler = R(l._outerScrollVerticalHandler, l), l._outerScrollHorizontalHandler = R(l._outerScrollHorizontalHandler, l), l._mouseWheelHandler = R(l._mouseWheelHandler, l), this.$config.hidden = !0;\n    var d = o.config.scroll_size;\n    return o.env.isIE && (d += 1), this._isHorizontal() ? (l.$config.height = d, l.$parent.$config.height = d) : (l.$config.width = d, l.$parent.$config.width = d), this.$config.scrollPosition = 0, l.$name = \"scroller\", l;\n  }\n  function i(a, r) {\n    if (r.push(a), a.$cells) for (var s = 0; s < a.$cells.length; s++) i(a.$cells[s], r);\n  }\n  return z(n, t), n.prototype.init = function(a) {\n    a.innerHTML = this.$toHTML(), this.$view = a.firstChild, this.$view || this.init(), this._isVertical() ? this._initVertical() : this._initHorizontal(), this._initMouseWheel(), this._initLinkedViews();\n  }, n.prototype.$toHTML = function() {\n    return \"<div class='gantt_layout_cell \" + (this._isHorizontal() ? \"gantt_hor_scroll\" : \"gantt_ver_scroll\") + \"'><div style='\" + (this._isHorizontal() ? \"width:2000px\" : \"height:2000px\") + \"'></div></div>\";\n  }, n.prototype._getRootParent = function() {\n    for (var a = this.$parent; a && a.$parent; ) a = a.$parent;\n    if (a) return a;\n  }, n.prototype._eachView = function() {\n    var a = [];\n    return i(this._getRootParent(), a), a;\n  }, n.prototype._getLinkedViews = function() {\n    for (var a = this._eachView(), r = [], s = 0; s < a.length; s++) a[s].$config && (this._isVertical() && a[s].$config.scrollY == this.$id || this._isHorizontal() && a[s].$config.scrollX == this.$id) && r.push(a[s]);\n    return r;\n  }, n.prototype._initHorizontal = function() {\n    this.$scroll_hor = this.$view, this.$domEvents.attach(this.$view, \"scroll\", this._scrollHorizontalHandler);\n  }, n.prototype._initLinkedViews = function() {\n    for (var a = this._getLinkedViews(), r = this._isVertical() ? \"gantt_layout_outer_scroll gantt_layout_outer_scroll_vertical\" : \"gantt_layout_outer_scroll gantt_layout_outer_scroll_horizontal\", s = 0; s < a.length; s++) wt(a[s].$view || a[s].getNode(), r);\n  }, n.prototype._initVertical = function() {\n    this.$scroll_ver = this.$view, this.$domEvents.attach(this.$view, \"scroll\", this._scrollVerticalHandler);\n  }, n.prototype._updateLinkedViews = function() {\n  }, n.prototype._initMouseWheel = function() {\n    mt.isFF ? this.$domEvents.attach(this._getRootParent().$view, \"wheel\", this._mouseWheelHandler, { passive: !1 }) : this.$domEvents.attach(this._getRootParent().$view, \"mousewheel\", this._mouseWheelHandler, { passive: !1 });\n  }, n.prototype.scrollHorizontally = function(a) {\n    if (!this._scrolling) {\n      this._scrolling = !0, this.$scroll_hor.scrollLeft = a, this.$config.codeScrollLeft = a, a = this.$scroll_hor.scrollLeft;\n      for (var r = this._getLinkedViews(), s = 0; s < r.length; s++) r[s].scrollTo && r[s].scrollTo(a, void 0);\n      var o = this.$config.scrollPosition;\n      this.$config.scrollPosition = a, this.callEvent(\"onScroll\", [o, a, this.$config.scroll]), this._scrolling = !1;\n    }\n  }, n.prototype.scrollVertically = function(a) {\n    if (!this._scrolling) {\n      this._scrolling = !0, this.$scroll_ver.scrollTop = a, a = this.$scroll_ver.scrollTop;\n      for (var r = this._getLinkedViews(), s = 0; s < r.length; s++) r[s].scrollTo && r[s].scrollTo(void 0, a);\n      var o = this.$config.scrollPosition;\n      this.$config.scrollPosition = a, this.callEvent(\"onScroll\", [o, a, this.$config.scroll]), this._scrolling = !1;\n    }\n  }, n.prototype._isVertical = function() {\n    return this.$config.scroll == \"y\";\n  }, n.prototype._isHorizontal = function() {\n    return this.$config.scroll == \"x\";\n  }, n.prototype._scrollHorizontalHandler = function(a) {\n    if (!this._isVertical() && !this._scrolling) {\n      if (/* @__PURE__ */ new Date() - (this._wheel_time || 0) < 100) return !0;\n      var r = this.$scroll_hor.scrollLeft;\n      this.scrollHorizontally(r), this._oldLeft = this.$scroll_hor.scrollLeft;\n    }\n  }, n.prototype._outerScrollHorizontalHandler = function(a) {\n    this._isVertical();\n  }, n.prototype.show = function() {\n    this.$parent.show();\n  }, n.prototype.hide = function() {\n    this.$parent.hide();\n  }, n.prototype._getScrollSize = function() {\n    for (var a, r = 0, s = 0, o = this._isHorizontal(), l = this._getLinkedViews(), d = o ? \"scrollWidth\" : \"scrollHeight\", c = o ? \"contentX\" : \"contentY\", u = o ? \"x\" : \"y\", h = this._getScrollOffset(), g = 0; g < l.length; g++) if ((a = l[g]) && a.$content && a.$content.getSize && !a.$config.hidden) {\n      var p, y = a.$content.getSize();\n      if (p = y.hasOwnProperty(d) ? y[d] : y[c], h) y[c] > y[u] && y[c] > r && p > y[u] - h + 2 && (r = p + (o ? 0 : 2), s = y[u]);\n      else {\n        var v = Math.max(y[c] - p, 0);\n        (p += v) > Math.max(y[u] - v, 0) && p > r && (r = p, s = y[u]);\n      }\n    }\n    return { outerScroll: s, innerScroll: r };\n  }, n.prototype.scroll = function(a) {\n    this._isHorizontal() ? this.scrollHorizontally(a) : this.scrollVertically(a);\n  }, n.prototype.getScrollState = function() {\n    return { visible: this.isVisible(), direction: this.$config.scroll, size: this.$config.outerSize, scrollSize: this.$config.scrollSize || 0, position: this.$config.scrollPosition || 0 };\n  }, n.prototype.setSize = function(a, r) {\n    t.prototype.setSize.apply(this, arguments);\n    var s = this._getScrollSize(), o = (this._isVertical() ? r : a) - this._getScrollOffset() + (this._isHorizontal() ? 1 : 0);\n    s.innerScroll && o > s.outerScroll && (s.innerScroll += o - s.outerScroll), this.$config.scrollSize = s.innerScroll, this.$config.width = a, this.$config.height = r, this._setScrollSize(s.innerScroll);\n  }, n.prototype.isVisible = function() {\n    return !(!this.$parent || !this.$parent.$view.parentNode);\n  }, n.prototype.shouldShow = function() {\n    var a = this._getScrollSize();\n    return !(!a.innerScroll && this.$parent && this.$parent.$view.parentNode) && !(!a.innerScroll || this.$parent && this.$parent.$view.parentNode);\n  }, n.prototype.shouldHide = function() {\n    return !(this._getScrollSize().innerScroll || !this.$parent || !this.$parent.$view.parentNode);\n  }, n.prototype.toggleVisibility = function() {\n    this.shouldHide() ? this.hide() : this.shouldShow() && this.show();\n  }, n.prototype._getScaleOffset = function(a) {\n    var r = 0;\n    return !a || a.$config.view != \"timeline\" && a.$config.view != \"grid\" || (r = a.$content.$getConfig().scale_height), r;\n  }, n.prototype._getScrollOffset = function() {\n    var a = 0;\n    if (this._isVertical()) {\n      var r = this.$parent.$parent;\n      a = Math.max(this._getScaleOffset(r.getPrevSibling(this.$parent.$id)), this._getScaleOffset(r.getNextSibling(this.$parent.$id)));\n    } else for (var s = this._getLinkedViews(), o = 0; o < s.length; o++) {\n      var l = s[o].$parent.$cells, d = l[l.length - 1];\n      if (d && d.$config.view == \"scrollbar\" && d.$config.hidden === !1) {\n        a = d.$config.width;\n        break;\n      }\n    }\n    return a || 0;\n  }, n.prototype._setScrollSize = function(a) {\n    var r = this._isHorizontal() ? \"width\" : \"height\", s = this._isHorizontal() ? this.$scroll_hor : this.$scroll_ver, o = this._getScrollOffset(), l = s.firstChild;\n    o ? this._isVertical() ? (this.$config.outerSize = this.$config.height - o + 3, s.style.height = this.$config.outerSize + \"px\", s.style.top = o - 1 + \"px\", wt(s, this.$parent._borders.top), wt(s.parentNode, \"gantt_task_vscroll\")) : (this.$config.outerSize = this.$config.width - o + 1, s.style.width = this.$config.outerSize + \"px\") : (s.style.top = \"auto\", Gt(s, this.$parent._borders.top), Gt(s.parentNode, \"gantt_task_vscroll\"), this.$config.outerSize = this.$config.height), l.style[r] = a + \"px\";\n  }, n.prototype._scrollVerticalHandler = function(a) {\n    if (!this._scrollHorizontalHandler() && !this._scrolling) {\n      var r = this.$scroll_ver.scrollTop;\n      r != this._oldTop && (this.scrollVertically(r), this._oldTop = this.$scroll_ver.scrollTop);\n    }\n  }, n.prototype._outerScrollVerticalHandler = function(a) {\n    this._scrollHorizontalHandler();\n  }, n.prototype._checkWheelTarget = function(a) {\n    for (var r = this._getLinkedViews().concat(this), s = 0; s < r.length; s++)\n      if (Y(a, r[s].$view)) return !0;\n    return !1;\n  }, n.prototype._mouseWheelHandler = function(a) {\n    var r = a.target || a.srcElement;\n    if (this._checkWheelTarget(r)) {\n      this._wheel_time = /* @__PURE__ */ new Date();\n      var s = {}, o = { x: 1, y: 1 }, l = this.$gantt.config.wheel_scroll_sensitivity;\n      typeof l == \"number\" && l ? o = { x: l, y: l } : {}.toString.apply(l) == \"[object Object]\" && (o = { x: l.x, y: l.y });\n      var d = mt.isFF, c = d ? a.deltaX : a.wheelDeltaX, u = d ? a.deltaY : a.wheelDelta, h = -20;\n      if (d) {\n        const k = parseInt(navigator.userAgent.split(\"Firefox/\")[1]);\n        h = k <= 87 ? a.deltaMode !== 0 ? -40 : -10 : k <= 90 ? -3 : k <= 96 ? -1.5 : -1;\n      }\n      var g = d ? c * h * o.x : 2 * c * o.x, p = d ? u * h * o.y : u * o.y, y = this.$gantt.config.horizontal_scroll_key;\n      if (y !== !1 && e.indexOf(y) >= 0 && (!a[y] || a.deltaX || a.wheelDeltaX || (g = 2 * p, p = 0)), g && Math.abs(g) > Math.abs(p)) {\n        if (this._isVertical()) return;\n        if (s.x || !this.$scroll_hor || !this.$scroll_hor.offsetWidth) return !0;\n        var v = g / -40, b = this._oldLeft, _ = b + 30 * v;\n        if (this.scrollHorizontally(_), this.$scroll_hor.scrollLeft = _, b == this.$scroll_hor.scrollLeft) return !0;\n        this._oldLeft = this.$scroll_hor.scrollLeft;\n      } else {\n        if (this._isHorizontal()) return;\n        if (s.y || !this.$scroll_ver || !this.$scroll_ver.offsetHeight) return !0;\n        v = p / -40, p === void 0 && (v = a.detail);\n        var m = this._oldTop, f = this.$scroll_ver.scrollTop + 30 * v;\n        if (this.scrollVertically(f), this.$scroll_ver.scrollTop = f, m == this.$scroll_ver.scrollTop) return !0;\n        this._oldTop = this.$scroll_ver.scrollTop;\n      }\n      return a.preventDefault && a.preventDefault(), a.cancelBubble = !0, !1;\n    }\n  }, n;\n}(Ht);\nfunction yn(t) {\n  var e = {}, n = {}, i = null, a = -1, r = null, s = /* @__PURE__ */ function(o) {\n    var l = -1, d = -1;\n    return { resetCache: function() {\n      l = -1, d = -1;\n    }, _getRowHeight: function() {\n      return l === -1 && (l = o.$getConfig().row_height), l;\n    }, _refreshState: function() {\n      this.resetCache(), d = !0;\n      var c = o.$config.rowStore;\n      if (c) for (var u = this._getRowHeight(), h = 0; h < c.fullOrder.length; h++) {\n        var g = c.getItem(c.fullOrder[h]);\n        if (g && g.row_height && g.row_height !== u) {\n          d = !1;\n          break;\n        }\n      }\n    }, canUseSimpleCalculation: function() {\n      return d === -1 && this._refreshState(), d;\n    }, getRowTop: function(c) {\n      return o.$config.rowStore ? c * this._getRowHeight() : 0;\n    }, getItemHeight: function(c) {\n      return this._getRowHeight();\n    }, getTotalHeight: function() {\n      return o.$config.rowStore ? o.$config.rowStore.countVisible() * this._getRowHeight() : 0;\n    }, getItemIndexByTopPosition: function(c) {\n      return o.$config.rowStore ? Math.floor(c / this._getRowHeight()) : 0;\n    } };\n  }(t);\n  return { _resetTopPositionHeight: function() {\n    e = {}, n = {}, s.resetCache();\n  }, _resetHeight: function() {\n    var o = this.$config.rowStore, l = this.getCacheStateTotalHeight(o);\n    r ? this.shouldClearHeightCache(r, l) && (r = l, i = null) : r = l, a = -1, s.resetCache();\n  }, getRowTop: function(o) {\n    if (s.canUseSimpleCalculation()) return s.getRowTop(o);\n    var l = this.$config.rowStore;\n    if (!l) return 0;\n    if (n[o] !== void 0) return n[o];\n    for (var d = l.getIndexRange(), c = 0, u = 0, h = 0; h < d.length; h++) n[h] = c, c += this.getItemHeight(d[h].id), h < o && (u = c);\n    return u;\n  }, getItemTop: function(o) {\n    if (this.$config.rowStore) {\n      if (e[o] !== void 0) return e[o];\n      var l = this.$config.rowStore;\n      if (!l) return 0;\n      var d = l.getIndexById(o);\n      if (d === -1 && l.getParent && l.exists(o)) {\n        var c = l.getParent(o);\n        if (l.exists(c)) {\n          var u = l.getItem(c);\n          if (this.$gantt.isSplitTask(u)) return this.getItemTop(c);\n        }\n      }\n      return e[o] = this.getRowTop(d), e[o];\n    }\n    return 0;\n  }, getItemHeight: function(o) {\n    if (s.canUseSimpleCalculation()) return s.getItemHeight(o);\n    if (!i && this.$config.rowStore && this._fillHeightCache(this.$config.rowStore), i[o] !== void 0) return i[o];\n    var l = this.$getConfig().row_height;\n    if (this.$config.rowStore) {\n      var d = this.$config.rowStore;\n      if (!d) return l;\n      var c = d.getItem(o);\n      return i[o] = c && c.row_height || l;\n    }\n    return l;\n  }, _fillHeightCache: function(o) {\n    if (o) {\n      i = {};\n      var l = this.$getConfig().row_height;\n      o.eachItem(function(d) {\n        return i[d.id] = d && d.row_height || l;\n      });\n    }\n  }, getCacheStateTotalHeight: function(o) {\n    var l = this.$getConfig().row_height, d = {}, c = [], u = 0;\n    return o && o.eachItem(function(h) {\n      c.push(h), d[h.id] = h.row_height, u += h.row_height || l;\n    }), { globalHeight: l, items: c, count: c.length, sumHeight: u };\n  }, shouldClearHeightCache: function(o, l) {\n    if (o.count != l.count || o.globalHeight != l.globalHeight || o.sumHeight != l.sumHeight) return !0;\n    for (var d in o.items) {\n      var c = l.items[d];\n      if (c !== void 0 && c != o.items[d]) return !0;\n    }\n    return !1;\n  }, getTotalHeight: function() {\n    if (s.canUseSimpleCalculation()) return s.getTotalHeight();\n    if (a != -1) return a;\n    if (this.$config.rowStore) {\n      var o = this.$config.rowStore;\n      this._fillHeightCache(o);\n      var l = this.getItemHeight.bind(this), d = o.getVisibleItems(), c = 0;\n      return d.forEach(function(u) {\n        c += l(u.id);\n      }), a = c, c;\n    }\n    return 0;\n  }, getItemIndexByTopPosition: function(o) {\n    if (this.$config.rowStore) {\n      if (s.canUseSimpleCalculation()) return s.getItemIndexByTopPosition(o);\n      for (var l = this.$config.rowStore, d = 0; d < l.countVisible(); d++) {\n        var c = this.getRowTop(d), u = this.getRowTop(d + 1);\n        if (!u) {\n          var h = l.getIdByIndex(d);\n          u = c + this.getItemHeight(h);\n        }\n        if (o >= c && o < u) return d;\n      }\n      return l.countVisible() + 2;\n    }\n    return 0;\n  } };\n}\nconst pa = function() {\n  return { render: function() {\n  }, destroy: function() {\n  } };\n};\nvar Ut = function(t, e, n, i) {\n  this.$config = P({}, e || {}), this.$scaleHelper = new pe(i), this.$gantt = i, this._posFromDateCache = {}, this._timelineDragScroll = null, P(this, yn(this)), ot(this);\n};\nUt.prototype = { init: function(t) {\n  t.innerHTML += \"<div class='gantt_task' style='width:inherit;height:inherit;'></div>\", this.$task = t.childNodes[0], this.$task.innerHTML = \"<div class='gantt_task_scale'></div><div class='gantt_data_area'></div>\", this.$task_scale = this.$task.childNodes[0], this.$task_data = this.$task.childNodes[1], this.$task_data.innerHTML = \"<div class='gantt_task_bg'></div><div class='gantt_task_baselines'></div><div class='gantt_links_area'></div><div class='gantt_bars_area'></div><div class='gantt_task_constraints'></div><div class='gantt_task_deadlines'></div>\", this.$task_bg = this.$task_data.childNodes[0], this.$task_baselines = this.$task_data.childNodes[1], this.$task_links = this.$task_data.childNodes[2], this.$task_bars = this.$task_data.childNodes[3], this.$task_constraints = this.$task_data.childNodes[4], this.$task_deadlines = this.$task_data.childNodes[5], this._tasks = { col_width: 0, width: [], full_width: 0, trace_x: [], rendered: {} };\n  var e = this.$getConfig(), n = e[this.$config.bind + \"_attribute\"], i = e[this.$config.bindLinks + \"_attribute\"];\n  !n && this.$config.bind && (n = \"data-\" + this.$config.bind + \"-id\"), !i && this.$config.bindLinks && (i = \"data-\" + this.$config.bindLinks + \"-id\"), this.$config.item_attribute = n || null, this.$config.link_attribute = i || null;\n  var a = this._createLayerConfig();\n  this.$config.layers || (this.$config.layers = a.tasks), this.$config.linkLayers || (this.$config.linkLayers = a.links), this._attachLayers(this.$gantt), this.callEvent(\"onReady\", []), this.$gantt.ext.dragTimeline && (this._timelineDragScroll = this.$gantt.ext.dragTimeline.create(), this._timelineDragScroll.attach(this));\n}, setSize: function(t, e) {\n  var n = this.$getConfig();\n  if (1 * t === t && (this.$config.width = t), 1 * e === e) {\n    this.$config.height = e;\n    var i = Math.max(this.$config.height - n.scale_height);\n    this.$task_data.style.height = i + \"px\";\n  }\n  this.refresh(), this.$task_bg.style.backgroundImage = \"\", n.smart_rendering && this.$config.rowStore ? this.$task_bg.style.height = this.getTotalHeight() + \"px\" : this.$task_bg.style.height = \"\";\n  for (var a = this._tasks, r = this.$task_data.childNodes, s = 0, o = r.length; s < o; s++) {\n    var l = r[s];\n    l.hasAttribute(\"data-layer\") && l.style && (l.style.width = a.full_width + \"px\");\n  }\n}, isVisible: function() {\n  return this.$parent && this.$parent.$config ? !this.$parent.$config.hidden : this.$task.offsetWidth;\n}, getSize: function() {\n  var t = this.$getConfig(), e = this.$config.rowStore ? this.getTotalHeight() : 0, n = this.isVisible() ? this._tasks.full_width : 0;\n  return { x: this.isVisible() ? this.$config.width : 0, y: this.isVisible() ? this.$config.height : 0, contentX: this.isVisible() ? n : 0, contentY: this.isVisible() ? t.scale_height + e : 0, scrollHeight: this.isVisible() ? e : 0, scrollWidth: this.isVisible() ? n : 0 };\n}, scrollTo: function(t, e) {\n  if (this.isVisible()) {\n    var n = !1;\n    this.$config.scrollTop = this.$config.scrollTop || 0, this.$config.scrollLeft = this.$config.scrollLeft || 0, 1 * e === e && (this.$config.scrollTop = e, this.$task_data.scrollTop = this.$config.scrollTop, n = !0), 1 * t === t && (this.$task.scrollLeft = t, this.$config.scrollLeft = this.$task.scrollLeft, this._refreshScales(), n = !0), n && this.callEvent(\"onScroll\", [this.$config.scrollLeft, this.$config.scrollTop]);\n  }\n}, _refreshScales: function() {\n  if (this.isVisible() && this.$getConfig().smart_scales) {\n    var t = this.getViewPort(), e = this._scales;\n    this.$task_scale.innerHTML = this._getScaleChunkHtml(e, t.x, t.x_end);\n  }\n}, getViewPort: function() {\n  var t = this.$config.scrollLeft || 0, e = this.$config.scrollTop || 0, n = this.$config.height || 0, i = this.$config.width || 0;\n  return { y: e, y_end: e + n, x: t, x_end: t + i, height: n, width: i };\n}, _createLayerConfig: function() {\n  var t = this, e = function() {\n    return t.isVisible();\n  };\n  this.$gantt;\n  var n = [{ expose: !0, renderer: this.$gantt.$ui.layers.taskBar(), container: this.$task_bars, filter: [e, function(i, a) {\n    return !a.hide_bar;\n  }] }];\n  return n.push({ renderer: this.$gantt.$ui.layers.taskBg(), container: this.$task_bg, filter: [e] }), { tasks: n, links: [{ expose: !0, renderer: this.$gantt.$ui.layers.link(), container: this.$task_links, filter: [e] }] };\n}, _attachLayers: function(t) {\n  this._taskLayers = [], this._linkLayers = [];\n  var e = this, n = this.$gantt.$services.getService(\"layers\");\n  if (this.$config.bind) {\n    this._bindStore();\n    var i = n.getDataRender(this.$config.bind);\n    i || (i = n.createDataRender({ name: this.$config.bind, defaultContainer: function() {\n      return e.$task_data;\n    } })), i.container = function() {\n      return e.$task_data;\n    };\n    for (var a = this.$config.layers, r = 0; a && r < a.length; r++) {\n      typeof (d = a[r]) == \"string\" && (d = this.$gantt.$ui.layers[d]()), (typeof d == \"function\" || d && d.render && d.update) && (d = { renderer: d }), d.view = this;\n      var s = i.addLayer(d);\n      this._taskLayers.push(s), d.expose && (this._taskRenderer = i.getLayer(s));\n    }\n    this._initStaticBackgroundRender();\n  }\n  if (this.$config.bindLinks) {\n    e.$config.linkStore = e.$gantt.getDatastore(e.$config.bindLinks);\n    var o = n.getDataRender(this.$config.bindLinks);\n    o || (o = n.createDataRender({ name: this.$config.bindLinks, defaultContainer: function() {\n      return e.$task_data;\n    } }));\n    var l = this.$config.linkLayers;\n    for (r = 0; l && r < l.length; r++) {\n      var d;\n      typeof d == \"string\" && (d = this.$gantt.$ui.layers[d]()), (d = l[r]).view = this;\n      var c = o.addLayer(d);\n      this._taskLayers.push(c), l[r].expose && (this._linkRenderer = o.getLayer(c));\n    }\n  }\n}, _initStaticBackgroundRender: function() {\n  var t = this, e = pa(), n = t.$config.rowStore;\n  n && (this._staticBgHandler = n.attachEvent(\"onStoreUpdated\", function(i, a, r) {\n    if (i === null && t.isVisible()) {\n      var s = t.$getConfig();\n      if (s.static_background || s.timeline_placeholder) {\n        var o = t.$gantt.getDatastore(t.$config.bind), l = t.$task_bg_static;\n        if (l || ((l = document.createElement(\"div\")).className = \"gantt_task_bg\", t.$task_bg_static = l, t.$task_bg.nextSibling ? t.$task_data.insertBefore(l, t.$task_bg.nextSibling) : t.$task_data.appendChild(l)), o) {\n          var d = t.getTotalHeight();\n          s.timeline_placeholder && (d = s.timeline_placeholder.height || t.$task_data.offsetHeight || 99999), e.render(l, s, t.getScale(), d, t.getItemHeight(a ? a.id : null));\n        }\n      } else s.static_background && t.$task_bg_static && t.$task_bg_static.parentNode && t.$task_bg_static.parentNode.removeChild(t.$task_bg_static);\n    }\n  }), this.attachEvent(\"onDestroy\", function() {\n  }), this._initStaticBackgroundRender = function() {\n  });\n}, _clearLayers: function(t) {\n  var e = this.$gantt.$services.getService(\"layers\"), n = e.getDataRender(this.$config.bind), i = e.getDataRender(this.$config.bindLinks);\n  if (this._taskLayers) for (var a = 0; a < this._taskLayers.length; a++) n.removeLayer(this._taskLayers[a]);\n  if (this._linkLayers) for (a = 0; a < this._linkLayers.length; a++) i.removeLayer(this._linkLayers[a]);\n  this._linkLayers = [], this._taskLayers = [];\n}, _render_tasks_scales: function() {\n  var t = this.$getConfig(), e = \"\", n = 0, i = 0, a = this.$gantt.getState();\n  if (this.isVisible()) {\n    var r = this.$scaleHelper, s = this._getScales();\n    i = t.scale_height;\n    var o = this.$config.width;\n    t.autosize != \"x\" && t.autosize != \"xy\" || (o = Math.max(t.autosize_min_width, 0));\n    var l = r.prepareConfigs(s, t.min_column_width, o, i - 1, a.min_date, a.max_date, t.rtl), d = this._tasks = l[l.length - 1];\n    this._scales = l, this._posFromDateCache = {}, e = this._getScaleChunkHtml(l, 0, this.$config.width), n = d.full_width + \"px\", i += \"px\";\n  }\n  this.$task_scale.style.height = i, this.$task_data.style.width = this.$task_scale.style.width = n, this.$task_scale.innerHTML = e;\n}, _getScaleChunkHtml: function(t, e, n) {\n  for (var i = [], a = this.$gantt.templates.scale_row_class, r = 0; r < t.length; r++) {\n    var s = \"gantt_scale_line\", o = a(t[r]);\n    o && (s += \" \" + o), i.push('<div class=\"' + s + '\" style=\"height:' + t[r].height + \"px;position:relative;line-height:\" + t[r].height + 'px\">' + this._prepareScaleHtml(t[r], e, n, r) + \"</div>\");\n  }\n  return i.join(\"\");\n}, _prepareScaleHtml: function(t, e, n, i) {\n  var a = this.$getConfig(), r = this.$gantt.templates, s = [], o = null, l = null, d = t.format || t.template || t.date;\n  typeof d == \"string\" && (d = this.$gantt.date.date_to_str(d));\n  var c = 0, u = t.count;\n  !a.smart_scales || isNaN(e) || isNaN(n) || (c = At(t.left, e), u = At(t.left, n) + 1), l = t.css || function() {\n  }, !t.css && a.inherit_scale_class && (l = r.scale_cell_class);\n  for (var h = c; h < u && t.trace_x[h]; h++) {\n    o = new Date(t.trace_x[h]);\n    var g = d.call(this, o), p = t.width[h];\n    t.height;\n    var y = t.left[h], v = \"\", b = \"\", _ = \"\";\n    if (p) {\n      v = \"width:\" + p + \"px;\" + (a.smart_scales ? \"position:absolute;left:\" + y + \"px\" : \"\");\n      const f = this.getViewPort(), k = (a.scales[i] || {}).sticky;\n      let x = \"\";\n      const $ = 70;\n      if (k !== !1 && p > $ || k === !0) {\n        if (y < f.x && y + p / 2 - $ / 2 < f.x) x = ` style='position:absolute;left: ${f.x - y + 10}px;' `;\n        else if (y + p / 2 + $ / 2 > f.x_end && p > $) {\n          let w = f.x_end - y - 10, S = \"-100%\";\n          w < $ && (w = $, S = `-${w}px`), x = ` style='position:absolute;left: ${w}px;transform: translate(${S},0);' `;\n        }\n      }\n      _ = \"gantt_scale_cell\" + (h == t.count - 1 ? \" gantt_last_cell\" : \"\"), (b = l.call(this, o)) && (_ += \" \" + b);\n      var m = `<div class='${_}' ${this.$gantt._waiAria.getTimelineCellAttr(g)} style='${v}'><span ${x}>${g}</span></div>`;\n      s.push(m);\n    }\n  }\n  return s.join(\"\");\n}, dateFromPos: function(t) {\n  var e = this._tasks;\n  if (t < 0 || t > e.full_width || !e.full_width) return null;\n  var n = At(this._tasks.left, t), i = this._tasks.left[n], a = e.width[n] || e.col_width, r = 0;\n  a && (r = (t - i) / a, e.rtl && (r = 1 - r));\n  var s = 0;\n  return r && (s = this._getColumnDuration(e, e.trace_x[n])), new Date(e.trace_x[n].valueOf() + Math.round(r * s));\n}, posFromDate: function(t) {\n  if (!this.isVisible() || !t) return 0;\n  var e = String(t.valueOf());\n  if (this._posFromDateCache[e] !== void 0) return this._posFromDateCache[e];\n  var n = this.columnIndexByDate(t);\n  this.$gantt.assert(n >= 0, \"Invalid day index\");\n  var i = Math.floor(n), a = n % 1, r = this._tasks.left[Math.min(i, this._tasks.width.length - 1)];\n  i == this._tasks.width.length && (r += this._tasks.width[this._tasks.width.length - 1]), a && (i < this._tasks.width.length ? r += this._tasks.width[i] * (a % 1) : r += 1);\n  var s = Math.round(r);\n  return this._posFromDateCache[e] = s, Math.round(s);\n}, _getNextVisibleColumn: function(t, e, n) {\n  for (var i = +e[t], a = t; n[i]; ) i = +e[++a];\n  return a;\n}, _getPrevVisibleColumn: function(t, e, n) {\n  for (var i = +e[t], a = t; n[i]; ) i = +e[--a];\n  return a;\n}, _getClosestVisibleColumn: function(t, e, n) {\n  var i = this._getNextVisibleColumn(t, e, n);\n  return e[i] || (i = this._getPrevVisibleColumn(t, e, n)), i;\n}, columnIndexByDate: function(t) {\n  var e = new Date(t).valueOf(), n = this._tasks.trace_x_ascending, i = this._tasks.ignore_x, a = this.$gantt.getState();\n  if (e <= a.min_date) return this._tasks.rtl ? n.length : 0;\n  if (e >= a.max_date) return this._tasks.rtl ? 0 : n.length;\n  var r = At(n, e), s = this._getClosestVisibleColumn(r, n, i), o = n[s], l = this._tasks.trace_index_transition;\n  if (!o) return l ? l[0] : 0;\n  var d = (t - n[s]) / this._getColumnDuration(this._tasks, n[s]);\n  return l ? l[s] + (1 - d) : s + d;\n}, getItemPosition: function(t, e, n) {\n  var i, a, r;\n  let s = e || t.start_date || t.$auto_start_date, o = n || t.end_date || t.$auto_end_date;\n  return this._tasks.rtl ? (a = this.posFromDate(s), i = this.posFromDate(o)) : (i = this.posFromDate(s), a = this.posFromDate(o)), r = Math.max(a - i, 0), { left: i, top: this.getItemTop(t.id), height: this.getBarHeight(t.id), width: r, rowHeight: this.getItemHeight(t.id) };\n}, getBarHeight: function(t, e) {\n  var n = this.$getConfig(), i = this.$config.rowStore.getItem(t), a = i.task_height || i.bar_height || n.bar_height || n.task_height, r = this.getItemHeight(t);\n  return a == \"full\" && (a = r - (n.bar_height_padding || 3)), a = Math.min(a, r), e && (a = Math.round(a / Math.sqrt(2))), Math.max(a, 0);\n}, getScale: function() {\n  return this._tasks;\n}, _getScales: function() {\n  var t = this.$getConfig(), e = this.$scaleHelper, n = [e.primaryScale(t)].concat(e.getSubScales(t));\n  return e.sortScales(n), n;\n}, _getColumnDuration: function(t, e) {\n  return this.$gantt.date.add(e, t.step, t.unit) - e;\n}, _bindStore: function() {\n  if (this.$config.bind) {\n    var t = this.$gantt.getDatastore(this.$config.bind);\n    if (this.$config.rowStore = t, t && !t._timelineCacheAttached) {\n      var e = this;\n      t._timelineCacheAttached = t.attachEvent(\"onBeforeFilter\", function() {\n        e._resetTopPositionHeight();\n      });\n    }\n  }\n}, _unbindStore: function() {\n  if (this.$config.bind) {\n    var t = this.$gantt.getDatastore(this.$config.bind);\n    t && t._timelineCacheAttached && (t.detachEvent(t._timelineCacheAttached), t._timelineCacheAttached = !1);\n  }\n}, refresh: function() {\n  this._bindStore(), this.$config.bindLinks && (this.$config.linkStore = this.$gantt.getDatastore(this.$config.bindLinks)), this._resetTopPositionHeight(), this._resetHeight(), this._initStaticBackgroundRender(), this._render_tasks_scales();\n}, destructor: function() {\n  var t = this.$gantt;\n  this._clearLayers(t), this._unbindStore(), this.$task = null, this.$task_scale = null, this.$task_data = null, this.$task_bg = null, this.$task_links = null, this.$task_bars = null, this.$gantt = null, this.$config.rowStore && (this.$config.rowStore.detachEvent(this._staticBgHandler), this.$config.rowStore = null), this.$config.linkStore && (this.$config.linkStore = null), this._timelineDragScroll && (this._timelineDragScroll.destructor(), this._timelineDragScroll = null), this.callEvent(\"onDestroy\", []), this.detachAllEvents();\n} };\nclass ma {\n  constructor(e) {\n    this._scrollOrder = 0;\n    const { gantt: n, grid: i, dnd: a, getCurrentX: r } = e;\n    this.$gantt = n, this.$grid = i, this._dnd = a, this.getCurrentX = r, this._scrollView = this.$gantt.$ui.getView(this.$grid.$config.scrollX), this.attachEvents();\n  }\n  attachEvents() {\n    this.isScrollable() && (this._dnd.attachEvent(\"onDragMove\", (e, n) => {\n      const i = this.$grid.$grid.getBoundingClientRect(), a = i.right, r = i.left, s = this.getCurrentX(n.clientX);\n      return s >= a - 20 && (this.autoscrollRight(), this.autoscrollStart()), s <= r + 20 && (this.autoscrollLeft(), this.autoscrollStart()), s < a - 20 && s > r + 20 && this.autoscrollStop(), !0;\n    }), this._dnd.attachEvent(\"onDragEnd\", () => {\n      this.autoscrollStop();\n    }));\n  }\n  autoscrollStart() {\n    if (this._scrollOrder === 0) return;\n    const e = 10 * this._scrollOrder, n = this._scrollView.getScrollState();\n    this._scrollView.scrollTo(n.position + e), setTimeout(() => {\n      this.autoscrollStart();\n    }, 50);\n  }\n  autoscrollRight() {\n    this._scrollOrder = 1;\n  }\n  autoscrollLeft() {\n    this._scrollOrder = -1;\n  }\n  autoscrollStop() {\n    this._scrollOrder = 0;\n  }\n  getCorrection() {\n    return this.isScrollable() ? this._scrollView.getScrollState().position : 0;\n  }\n  isScrollable() {\n    return !!this.$grid.$config.scrollable;\n  }\n}\nconst Ve = \"data-column-id\";\nclass va {\n  constructor(e, n) {\n    this._targetMarker = null, this.calculateCurrentPosition = (i) => {\n      const a = this.$grid.$grid.getBoundingClientRect(), r = a.right, s = a.left;\n      let o = i;\n      return o > r && (o = r), o < s && (o = s), o;\n    }, this.$gantt = e, this.$grid = n;\n  }\n  init() {\n    const e = this.$gantt.$services.getService(\"dnd\");\n    this._dnd = new e(this.$grid.$grid_scale, { updates_per_second: 60 }), this._scrollableGrid = new ma({ gantt: this.$gantt, grid: this.$grid, dnd: this._dnd, getCurrentX: this.calculateCurrentPosition }), this.attachEvents();\n  }\n  attachEvents() {\n    this._dnd.attachEvent(\"onBeforeDragStart\", (e, n) => {\n      if (this._draggedCell = this.$gantt.utils.dom.closest(n.target, \".gantt_grid_head_cell\"), !this._draggedCell) return;\n      const i = this.$grid.$getConfig().columns, a = this._draggedCell.getAttribute(Ve);\n      let r, s;\n      return i.map(function(o, l) {\n        o.name === a && (r = o, s = l);\n      }), this.$grid.callEvent(\"onBeforeColumnDragStart\", [{ draggedColumn: r, draggedIndex: s }]) !== !1 && !(!this._draggedCell || !r) && (this._gridConfig = this.$grid.$getConfig(), this._originAutoscroll = this.$gantt.config.autoscroll, this.$gantt.config.autoscroll = !1, !0);\n    }), this._dnd.attachEvent(\"onAfterDragStart\", (e, n) => {\n      this._draggedCell && (this._dnd.config.column = this._draggedCell.getAttribute(Ve), this._dnd.config.marker.innerHTML = this._draggedCell.outerHTML, this._dnd.config.marker.classList.add(\"gantt_column_drag_marker\"), this._dnd.config.marker.style.height = this._gridConfig.scale_height + \"px\", this._dnd.config.marker.style.lineHeight = this._gridConfig.scale_height + \"px\", this._draggedCell.classList.add(\"gantt_grid_head_cell_dragged\"));\n    }), this._dnd.attachEvent(\"onDragMove\", (e, n) => {\n      if (!this._draggedCell) return;\n      this._dragX = n.clientX;\n      const i = this.calculateCurrentPosition(n.clientX), a = this.findColumnsIndexes();\n      return this.setMarkerPosition(i), this.drawTargetMarker(a), !0;\n    }), this._dnd.attachEvent(\"onDragEnd\", () => {\n      if (!this._draggedCell) return;\n      const e = this.findColumnsIndexes(), n = e.targetIndex, i = e.draggedIndex, a = this.$grid.$getConfig().columns, r = a[i], s = a[n];\n      if (this.$grid.callEvent(\"onColumnDragMove\", [{ draggedColumn: r, targetColumn: s, draggedIndex: i, targetIndex: n }]) === !1) return this.cleanTargetMarker(), void this.$gantt.render();\n      this.$gantt.config.autoscroll = this._originAutoscroll, this._draggedCell.classList.remove(\"gantt_grid_head_cell_dragged\"), this.cleanTargetMarker(), this.reorderColumns();\n    });\n  }\n  reorderColumns() {\n    const { targetIndex: e, draggedIndex: n } = this.findColumnsIndexes(), i = this.$grid.$getConfig().columns, a = i[n], r = i[e];\n    this.$grid.callEvent(\"onBeforeColumnReorder\", [{ draggedColumn: a, targetColumn: r, draggedIndex: n, targetIndex: e }]) !== !1 && e !== n && (i.splice(n, 1), i.splice(e, 0, a), this.$gantt.render(), this.$grid.callEvent(\"onAfterColumnReorder\", [{ draggedColumn: a, targetColumn: r, draggedIndex: n, targetIndex: e }]));\n  }\n  findColumnsIndexes() {\n    const e = this._dnd.config.column, n = this.$grid.$getConfig().columns;\n    let i, a, r, s;\n    const o = { startX: 0, endX: 0 };\n    let l, d = 0, c = n.length - 1, u = (p, y) => p <= y, h = (p) => ++p;\n    this.$gantt.config.rtl && (d = n.length - 1, c = 0, u = (p, y) => p >= y, h = (p) => --p);\n    const g = this._dragX - this.$grid.$grid.getBoundingClientRect().left + this._scrollableGrid.getCorrection();\n    for (let p = d; u(p, c) && (i === void 0 || a === void 0); p = h(p)) n[p].hide || (o.startX = o.endX, o.endX += n[p].width, g >= o.startX && (g <= o.endX || !u(h(p), c)) && (i = p, r = o.startX, s = o.endX, l = (g - o.startX) / (o.endX - o.startX)), e === n[p].name && (a = p));\n    return { targetIndex: i, draggedIndex: a, xBefore: r, xAfter: s, columnRelativePos: l };\n  }\n  setMarkerPosition(e, n = 10) {\n    const { marker: i } = this._dnd.config, a = this._dnd._obj.getBoundingClientRect();\n    i.style.top = `${a.y + n}px`, i.style.left = `${e}px`;\n  }\n  drawTargetMarker({ targetIndex: e, draggedIndex: n, xBefore: i, xAfter: a, columnRelativePos: r }) {\n    let s;\n    this._targetMarker || (this._targetMarker = document.createElement(\"div\"), wt(this._targetMarker, \"gantt_grid_target_marker\"), this._targetMarker.style.display = \"none\", this._targetMarker.style.height = `${this._gridConfig.scale_height}px`), this._targetMarker.parentNode || this.$grid.$grid_scale.appendChild(this._targetMarker), s = e > n ? a : e < n ? i : r > 0.5 ? a : i, this._targetMarker.style.left = `${s}px`, this._targetMarker.style.display = \"block\";\n  }\n  cleanTargetMarker() {\n    this._targetMarker && this._targetMarker.parentNode && this.$grid.$grid_scale.removeChild(this._targetMarker), this._targetMarker = null;\n  }\n}\nfunction Te(t) {\n  var e = [];\n  return { delegate: function(n, i, a, r) {\n    e.push([n, i, a, r]), t.$services.getService(\"mouseEvents\").delegate(n, i, a, r);\n  }, destructor: function() {\n    for (var n = t.$services.getService(\"mouseEvents\"), i = 0; i < e.length; i++) {\n      var a = e[i];\n      n.detach(a[0], a[1], a[2], a[3]);\n    }\n    e = [];\n  } };\n}\nvar xe = function(t, e, n, i) {\n  this.$config = P({}, e || {}), this.$gantt = i, this.$parent = t, ot(this), this.$state = {}, P(this, yn(this));\n};\nxe.prototype = { init: function(t) {\n  var e = this.$gantt, n = e._waiAria.gridAttrString(), i = e._waiAria.gridDataAttrString(), a = this.$getConfig(), r = a.reorder_grid_columns || !1;\n  this.$config.reorder_grid_columns !== void 0 && (r = this.$config.reorder_grid_columns), t.innerHTML = \"<div class='gantt_grid' style='height:inherit;width:inherit;' \" + n + \"></div>\", this.$grid = t.childNodes[0], this.$grid.innerHTML = \"<div class='gantt_grid_scale' \" + e._waiAria.gridScaleRowAttrString() + \"></div><div class='gantt_grid_data' \" + i + \"></div>\", this.$grid_scale = this.$grid.childNodes[0], this.$grid_data = this.$grid.childNodes[1];\n  var s = a[this.$config.bind + \"_attribute\"];\n  if (!s && this.$config.bind && (s = \"data-\" + this.$config.bind + \"-id\"), this.$config.item_attribute = s || null, !this.$config.layers) {\n    var o = this._createLayerConfig();\n    this.$config.layers = o;\n  }\n  var l = { init: function() {\n  }, doOnRender: function() {\n  } };\n  this._renderHeaderResizers = l.doOnRender, this._mouseDelegates = Te(e);\n  var d = function(c, u) {\n    var h = { row_before_start: c.bind(function(g, p, y) {\n      var v = u.$getConfig(), b = u.$config.rowStore;\n      if (!et(y, v.task_grid_row_resizer_attribute)) return !1;\n      var _ = this.locate(y, v.task_grid_row_resizer_attribute), m = b.getItem(_);\n      return u.callEvent(\"onBeforeRowResize\", [m]) !== !1 && void 0;\n    }, c), row_after_start: c.bind(function(g, p, y) {\n      var v = u.$getConfig(), b = this.locate(y, v.task_grid_row_resizer_attribute);\n      g.config.marker.innerHTML = \"\", g.config.marker.className += \" gantt_row_grid_resize_area\", g.config.marker.style.width = u.$grid.offsetWidth + \"px\", g.config.drag_id = b;\n    }, c), row_drag_move: c.bind(function(g, p, y) {\n      var v = u.$config.rowStore, b = u.$getConfig(), _ = g.config, m = _.drag_id, f = u.getItemHeight(m), k = u.getItemTop(m) - p.scrollTop, x = V(u.$grid_data), $ = parseInt(_.marker.style.top, 10), w = k + x.y, S = 0, T = b.min_task_grid_row_height;\n      return (S = $ - w) < T && (S = T), _.marker.style.left = x.x + \"px\", _.marker.style.top = w - 1 + \"px\", _.marker.style.height = Math.abs(S) + 1 + \"px\", _.marker_height = S, u.callEvent(\"onRowResize\", [m, v.getItem(m), S + f]), !0;\n    }, c), row_drag_end: c.bind(function(g, p, y) {\n      var v = u.$config.rowStore, b = g.config, _ = b.drag_id, m = v.getItem(_), f = u.getItemHeight(_), k = b.marker_height;\n      u.callEvent(\"onBeforeRowResizeEnd\", [_, m, k]) !== !1 && m.row_height != k && (m.row_height = k, v.updateItem(_), u.callEvent(\"onAfterRowResize\", [_, m, f, k]), this.render());\n    }, c) };\n    return { init: function() {\n      var g = c.$services.getService(\"dnd\"), p = u.$getConfig(), y = new g(u.$grid_data, { updates_per_second: 60 });\n      c.defined(p.dnd_sensitivity) && (y.config.sensitivity = p.dnd_sensitivity), y.attachEvent(\"onBeforeDragStart\", function(v, b) {\n        return h.row_before_start(y, v, b);\n      }), y.attachEvent(\"onAfterDragStart\", function(v, b) {\n        return h.row_after_start(y, v, b);\n      }), y.attachEvent(\"onDragMove\", function(v, b) {\n        return h.row_drag_move(y, v, b);\n      }), y.attachEvent(\"onDragEnd\", function(v, b) {\n        return h.row_drag_end(y, v, b);\n      });\n    } };\n  }(e, this);\n  d.init(), this._addLayers(this.$gantt), this._initEvents(), r && (this._columnDND = new va(e, this), this._columnDND.init()), this.callEvent(\"onReady\", []);\n}, _validateColumnWidth: function(t, e) {\n  var n = t[e];\n  if (n && n != \"*\") {\n    var i = this.$gantt, a = 1 * n;\n    isNaN(a) ? i.assert(!1, \"Wrong \" + e + \" value of column \" + t.name) : t[e] = a;\n  }\n}, setSize: function(t, e) {\n  this.$config.width = this.$state.width = t, this.$config.height = this.$state.height = e;\n  for (var n, i = this.getGridColumns(), a = 0, r = (d = this.$getConfig()).grid_elastic_columns, s = 0, o = i.length; s < o; s++) this._validateColumnWidth(i[s], \"min_width\"), this._validateColumnWidth(i[s], \"max_width\"), this._validateColumnWidth(i[s], \"width\"), a += 1 * i[s].width;\n  if (!isNaN(a) && this.$config.scrollable || (a = n = this._setColumnsWidth(t + 1)), this.$config.scrollable && r && !isNaN(a)) {\n    let u = \"width\";\n    r == \"min_width\" && (u = \"min_width\");\n    let h = 0;\n    i.forEach(function(g) {\n      h += g[u] || d.min_grid_column_width;\n    });\n    var l = Math.max(h, t);\n    a = this._setColumnsWidth(l), n = t;\n  }\n  this.$config.scrollable ? (this.$grid_scale.style.width = a + \"px\", this.$grid_data.style.width = a + \"px\") : (this.$grid_scale.style.width = \"inherit\", this.$grid_data.style.width = \"inherit\"), this.$config.width -= 1;\n  var d = this.$getConfig();\n  n !== t && (n !== void 0 ? (d.grid_width = n, this.$config.width = n - 1) : isNaN(a) || (this._setColumnsWidth(a), d.grid_width = a, this.$config.width = a - 1));\n  var c = Math.max(this.$state.height - d.scale_height, 0);\n  this.$grid_data.style.height = c + \"px\", this.refresh();\n}, getSize: function() {\n  var t = this.$getConfig(), e = this.$config.rowStore ? this.getTotalHeight() : 0, n = this._getGridWidth();\n  return { x: this.$state.width, y: this.$state.height, contentX: this.isVisible() ? n : 0, contentY: this.isVisible() ? t.scale_height + e : 0, scrollHeight: this.isVisible() ? e : 0, scrollWidth: this.isVisible() ? n : 0 };\n}, _bindStore: function() {\n  if (this.$config.bind) {\n    var t = this.$gantt.getDatastore(this.$config.bind);\n    if (this.$config.rowStore = t, t && !t._gridCacheAttached) {\n      var e = this;\n      t._gridCacheAttached = t.attachEvent(\"onBeforeFilter\", function() {\n        e._resetTopPositionHeight();\n      });\n    }\n  }\n}, _unbindStore: function() {\n  if (this.$config.bind) {\n    var t = this.$gantt.getDatastore(this.$config.bind);\n    t && t._gridCacheAttached && (t.detachEvent(t._gridCacheAttached), t._gridCacheAttached = !1);\n  }\n}, refresh: function() {\n  this._bindStore(), this._resetTopPositionHeight(), this._resetHeight(), this._initSmartRenderingPlaceholder(), this._calculateGridWidth(), this._renderGridHeader();\n}, getViewPort: function() {\n  var t = this.$config.scrollLeft || 0, e = this.$config.scrollTop || 0, n = this.$config.height || 0, i = this.$config.width || 0;\n  return { y: e, y_end: e + n, x: t, x_end: t + i, height: n, width: i };\n}, scrollTo: function(t, e) {\n  if (this.isVisible()) {\n    var n = !1;\n    this.$config.scrollTop = this.$config.scrollTop || 0, this.$config.scrollLeft = this.$config.scrollLeft || 0, 1 * t == t && (this.$config.scrollLeft = this.$state.scrollLeft = this.$grid.scrollLeft = t, n = !0), 1 * e == e && (this.$config.scrollTop = this.$state.scrollTop = this.$grid_data.scrollTop = e, n = !0), n && this.callEvent(\"onScroll\", [this.$config.scrollLeft, this.$config.scrollTop]);\n  }\n}, getColumnIndex: function(t, e) {\n  for (var n = this.$getConfig().columns, i = 0, a = 0; a < n.length; a++) if (e && n[a].hide && i++, n[a].name == t) return a - i;\n  return null;\n}, getColumn: function(t) {\n  var e = this.getColumnIndex(t);\n  return e === null ? null : this.$getConfig().columns[e];\n}, getGridColumns: function() {\n  return this.$getConfig().columns.slice();\n}, isVisible: function() {\n  return this.$parent && this.$parent.$config ? !this.$parent.$config.hidden : this.$grid.offsetWidth;\n}, _createLayerConfig: function() {\n  var t = this.$gantt, e = this;\n  return [{ renderer: t.$ui.layers.gridLine(), container: this.$grid_data, filter: [function() {\n    return e.isVisible();\n  }] }, { renderer: t.$ui.layers.gridTaskRowResizer(), container: this.$grid_data, append: !0, filter: [function() {\n    return t.config.resize_rows;\n  }] }];\n}, _addLayers: function(t) {\n  if (this.$config.bind) {\n    this._taskLayers = [];\n    var e = this, n = this.$gantt.$services.getService(\"layers\"), i = n.getDataRender(this.$config.bind);\n    i || (i = n.createDataRender({ name: this.$config.bind, defaultContainer: function() {\n      return e.$grid_data;\n    } }));\n    for (var a = this.$config.layers, r = 0; a && r < a.length; r++) {\n      var s = a[r];\n      s.view = this;\n      var o = i.addLayer(s);\n      this._taskLayers.push(o);\n    }\n    this._bindStore(), this._initSmartRenderingPlaceholder();\n  }\n}, _refreshPlaceholderOnStoreUpdate: function(t) {\n  var e = this.$getConfig(), n = this.$config.rowStore;\n  if (n && t === null && this.isVisible() && e.smart_rendering) {\n    var i;\n    if (this.$config.scrollY) {\n      var a = this.$gantt.$ui.getView(this.$config.scrollY);\n      a && (i = a.getScrollState().scrollSize);\n    }\n    if (i || (i = n ? this.getTotalHeight() : 0), i) {\n      this.$rowsPlaceholder && this.$rowsPlaceholder.parentNode && this.$rowsPlaceholder.parentNode.removeChild(this.$rowsPlaceholder);\n      var r = this.$rowsPlaceholder = document.createElement(\"div\");\n      r.style.visibility = \"hidden\", r.style.height = i + \"px\", r.style.width = \"1px\", this.$grid_data.appendChild(r);\n    }\n  }\n}, _initSmartRenderingPlaceholder: function() {\n  var t = this.$config.rowStore;\n  t && (this._initSmartRenderingPlaceholder = function() {\n  }, this._staticBgHandler = t.attachEvent(\"onStoreUpdated\", R(this._refreshPlaceholderOnStoreUpdate, this)));\n}, _initEvents: function() {\n  var t = this.$gantt;\n  this._mouseDelegates.delegate(\"click\", \"gantt_close\", t.bind(function(e, n, i) {\n    var a = this.$config.rowStore;\n    if (!a) return !0;\n    var r = et(e, this.$config.item_attribute);\n    return r && a.close(r.getAttribute(this.$config.item_attribute)), !1;\n  }, this), this.$grid), this._mouseDelegates.delegate(\"click\", \"gantt_open\", t.bind(function(e, n, i) {\n    var a = this.$config.rowStore;\n    if (!a) return !0;\n    var r = et(e, this.$config.item_attribute);\n    return r && a.open(r.getAttribute(this.$config.item_attribute)), !1;\n  }, this), this.$grid);\n}, _clearLayers: function(t) {\n  var e = this.$gantt.$services.getService(\"layers\").getDataRender(this.$config.bind);\n  if (this._taskLayers) for (var n = 0; n < this._taskLayers.length; n++) e.removeLayer(this._taskLayers[n]);\n  this._taskLayers = [];\n}, _getColumnWidth: function(t, e, n) {\n  var i = t.min_width || e.min_grid_column_width, a = Math.max(n, i || 10);\n  return t.max_width && (a = Math.min(a, t.max_width)), a;\n}, _checkGridColumnMinWidthLimits: function(t, e) {\n  for (var n = 0, i = t.length; n < i; n++) {\n    var a = 1 * t[n].width;\n    !t[n].min_width && a < e.min_grid_column_width && (t[n].min_width = a);\n  }\n}, _getGridWidthLimits: function() {\n  for (var t = this.$getConfig(), e = this.getGridColumns(), n = 0, i = 0, a = 0; a < e.length; a++) n += e[a].min_width ? e[a].min_width : t.min_grid_column_width, i !== void 0 && (i = e[a].max_width ? i + e[a].max_width : void 0);\n  return this._checkGridColumnMinWidthLimits(e, t), [n, i];\n}, _setColumnsWidth: function(t, e) {\n  var n = this.$getConfig(), i = this.getGridColumns(), a = 0, r = t;\n  e = window.isNaN(e) ? -1 : e;\n  for (var s = 0, o = i.length; s < o; s++) a += 1 * i[s].width;\n  if (window.isNaN(a))\n    for (this._calculateGridWidth(), a = 0, s = 0, o = i.length; s < o; s++) a += 1 * i[s].width;\n  var l = r - a, d = 0;\n  for (s = 0; s < e + 1; s++) d += i[s].width;\n  for (a -= d, s = e + 1; s < i.length; s++) {\n    var c = i[s], u = Math.round(l * (c.width / a));\n    l < 0 ? c.min_width && c.width + u < c.min_width ? u = c.min_width - c.width : !c.min_width && n.min_grid_column_width && c.width + u < n.min_grid_column_width && (u = n.min_grid_column_width - c.width) : c.max_width && c.width + u > c.max_width && (u = c.max_width - c.width), a -= c.width, c.width += u, l -= u;\n  }\n  for (var h = l > 0 ? 1 : -1; l > 0 && h === 1 || l < 0 && h === -1; ) {\n    var g = l;\n    for (s = e + 1; s < i.length; s++) {\n      var p;\n      if ((p = i[s].width + h) == this._getColumnWidth(i[s], n, p) && (l -= h, i[s].width = p), !l) break;\n    }\n    if (g == l) break;\n  }\n  return l && e > -1 && (p = i[e].width + l) == this._getColumnWidth(i[e], n, p) && (i[e].width = p), this._getColsTotalWidth();\n}, _getColsTotalWidth: function() {\n  for (var t = this.getGridColumns(), e = 0, n = 0; n < t.length; n++) {\n    var i = parseFloat(t[n].width);\n    if (window.isNaN(i)) return !1;\n    e += i;\n  }\n  return e;\n}, _calculateGridWidth: function() {\n  for (var t = this.$getConfig(), e = this.getGridColumns(), n = 0, i = [], a = [], r = 0; r < e.length; r++) {\n    var s = parseFloat(e[r].width);\n    window.isNaN(s) && (s = t.min_grid_column_width || 10, i.push(r)), a[r] = s, n += s;\n  }\n  var o = this._getGridWidth() + 1;\n  if (t.autofit || i.length) {\n    var l = o - n;\n    if (t.autofit && !t.grid_elastic_columns) for (r = 0; r < a.length; r++) {\n      var d = Math.round(l / (a.length - r));\n      a[r] += d, (c = this._getColumnWidth(e[r], t, a[r])) != a[r] && (d = c - a[r], a[r] = c), l -= d;\n    }\n    else if (i.length) for (r = 0; r < i.length; r++) {\n      d = Math.round(l / (i.length - r));\n      var c, u = i[r];\n      a[u] += d, (c = this._getColumnWidth(e[u], t, a[u])) != a[u] && (d = c - a[u], a[u] = c), l -= d;\n    }\n    for (r = 0; r < a.length; r++) e[r].width = a[r];\n  } else {\n    var h = o != n;\n    this.$config.width = n - 1, t.grid_width = n, h && this.$parent._setContentSize(this.$config.width, null);\n  }\n}, _renderGridHeader: function() {\n  var t = this.$gantt, e = this.$getConfig(), n = this.$gantt.locale, i = this.$gantt.templates, a = this.getGridColumns();\n  e.rtl && (a = a.reverse());\n  var r = [], s = 0, o = n.labels, l = e.scale_height - 1;\n  const d = {};\n  for (var c = 0; c < a.length; c++) {\n    var u = c == a.length - 1, h = a[c];\n    h.name || (h.name = t.uid() + \"\");\n    var g = 1 * h.width, p = this._getGridWidth();\n    u && p > s + g && (h.width = g = p - s), s += g;\n    var y = t._sort && h.name == t._sort.name ? `<div data-column-id=\"${h.name}\" class=\"gantt_sort gantt_${t._sort.direction}\"></div>` : \"\", v = [\"gantt_grid_head_cell\", \"gantt_grid_head_\" + h.name, u ? \"gantt_last_cell\" : \"\", i.grid_header_class(h.name, h)].join(\" \"), b = \"width:\" + (g - (u ? 1 : 0)) + \"px;\", _ = h.label || o[\"column_\" + h.name] || o[h.name];\n    typeof _ == \"function\" && (_ = _.call(t, h.name, h)), _ = _ || \"\";\n    let f = !1;\n    t.config.external_render && t.config.external_render.isElement(_) && (f = !0, d[h.name] = _);\n    var m = \"<div class='\" + v + \"' style='\" + b + \"' \" + t._waiAria.gridScaleCellAttrString(h, _) + \" data-column-id='\" + h.name + \"' column_id='\" + h.name + \"' data-column-name='\" + h.name + \"' data-column-index='\" + c + \"'>\" + (f ? \"<div data-component-container></div>\" : _) + y + \"</div>\";\n    r.push(m);\n  }\n  this.$grid_scale.style.height = e.scale_height + \"px\", this.$grid_scale.style.lineHeight = l + \"px\", this.$grid_scale.innerHTML = r.join(\"\");\n  for (let f in d) t.config.external_render.renderElement(d[f], this.$grid_scale.querySelector(\"[data-column-id='\" + f + \"'] [data-component-container]\"));\n  this._renderHeaderResizers && this._renderHeaderResizers();\n}, _getGridWidth: function() {\n  return this.$config.width;\n}, destructor: function() {\n  this._clearLayers(this.$gantt), this._mouseDelegates && (this._mouseDelegates.destructor(), this._mouseDelegates = null), this._unbindStore(), this.$grid = null, this.$grid_scale = null, this.$grid_data = null, this.$gantt = null, this.$config.rowStore && (this.$config.rowStore.detachEvent(this._staticBgHandler), this.$config.rowStore = null), this.callEvent(\"onDestroy\", []), this.detachAllEvents();\n} };\nconst ka = { init: function(t, e) {\n  var n = e.$gantt;\n  n.attachEvent(\"onTaskClick\", function(i, a) {\n    if (n._is_icon_open_click(a)) return !0;\n    var r = t.getState(), s = t.locateCell(a.target);\n    return !s || !t.getEditorConfig(s.columnName) || (t.isVisible() && r.id == s.id && r.columnName == s.columnName || t.startEdit(s.id, s.columnName), !1);\n  }), n.attachEvent(\"onEmptyClick\", function() {\n    return t.isVisible() && t.isChanged() ? t.save() : t.hide(), !0;\n  }), n.attachEvent(\"onTaskDblClick\", function(i, a) {\n    var r = t.getState(), s = t.locateCell(a.target);\n    return !s || !t.isVisible() || s.columnName != r.columnName;\n  });\n}, onShow: function(t, e, n) {\n  var i = n.$gantt;\n  i.ext && i.ext.keyboardNavigation && i.ext.keyboardNavigation.attachEvent(\"onKeyDown\", function(a, r) {\n    var s = i.constants.KEY_CODES, o = !1;\n    return r.keyCode === s.SPACE && t.isVisible() && (o = !0), !o;\n  }), e.onkeydown = function(a) {\n    a = a || window.event;\n    var r = i.constants.KEY_CODES;\n    if (!(a.defaultPrevented || a.shiftKey && a.keyCode != r.TAB)) {\n      var s = !0;\n      switch (a.keyCode) {\n        case i.keys.edit_save:\n          t.save();\n          break;\n        case i.keys.edit_cancel:\n          t.hide();\n          break;\n        case r.UP:\n        case r.DOWN:\n          t.isVisible() && (t.hide(), s = !1);\n          break;\n        case r.TAB:\n          a.shiftKey ? t.editPrevCell(!0) : t.editNextCell(!0);\n          break;\n        default:\n          s = !1;\n      }\n      s && a.preventDefault();\n    }\n  };\n}, onHide: function() {\n}, destroy: function() {\n} }, ya = { init: function(t, e) {\n  var n = t, i = e.$gantt, a = null, r = i.ext.keyboardNavigation;\n  r.attachEvent(\"onBeforeFocus\", function(s) {\n    var o = t.locateCell(s);\n    if (clearTimeout(a), o) {\n      var l = o.columnName, d = o.id, c = n.getState();\n      if (n.isVisible() && c.id == d && c.columnName === l) return !1;\n    }\n    return !0;\n  }), r.attachEvent(\"onFocus\", function(s) {\n    var o = t.locateCell(s), l = t.getState();\n    return clearTimeout(a), !o || o.id == l.id && o.columnName == l.columnName || n.isVisible() && n.save(), !0;\n  }), t.attachEvent(\"onHide\", function() {\n    clearTimeout(a);\n  }), r.attachEvent(\"onBlur\", function() {\n    return a = setTimeout(function() {\n      n.save();\n    }), !0;\n  }), i.attachEvent(\"onTaskDblClick\", function(s, o) {\n    var l = t.getState(), d = t.locateCell(o.target);\n    return !d || !t.isVisible() || d.columnName != l.columnName;\n  }), i.attachEvent(\"onTaskClick\", function(s, o) {\n    if (i._is_icon_open_click(o)) return !0;\n    var l = t.getState(), d = t.locateCell(o.target);\n    return !d || !t.getEditorConfig(d.columnName) || (t.isVisible() && l.id == d.id && l.columnName == d.columnName || t.startEdit(d.id, d.columnName), !1);\n  }), i.attachEvent(\"onEmptyClick\", function() {\n    return n.save(), !0;\n  }), r.attachEvent(\"onKeyDown\", function(s, o) {\n    var l = t.locateCell(o.target), d = !!l && t.getEditorConfig(l.columnName), c = t.getState(), u = i.constants.KEY_CODES, h = o.keyCode, g = !1;\n    switch (h) {\n      case u.ENTER:\n        t.isVisible() ? (t.save(), o.preventDefault(), g = !0) : d && !(o.ctrlKey || o.metaKey || o.shiftKey) && (n.startEdit(l.id, l.columnName), o.preventDefault(), g = !0);\n        break;\n      case u.ESC:\n        t.isVisible() && (t.hide(), o.preventDefault(), g = !0);\n        break;\n      case u.UP:\n      case u.DOWN:\n        break;\n      case u.LEFT:\n      case u.RIGHT:\n        (d && t.isVisible() || c.editorType === \"date\") && (g = !0);\n        break;\n      case u.SPACE:\n        t.isVisible() && (g = !0), d && !t.isVisible() && (n.startEdit(l.id, l.columnName), o.preventDefault(), g = !0);\n        break;\n      case u.DELETE:\n        d && !t.isVisible() ? (n.startEdit(l.id, l.columnName), g = !0) : d && t.isVisible() && (g = !0);\n        break;\n      case u.TAB:\n        if (t.isVisible()) {\n          o.shiftKey ? t.editPrevCell(!0) : t.editNextCell(!0);\n          var p = t.getState();\n          p.id && r.focus({ type: \"taskCell\", id: p.id, column: p.columnName }), o.preventDefault(), g = !0;\n        }\n        break;\n      default:\n        if (t.isVisible()) g = !0;\n        else if (h >= 48 && h <= 57 || h > 95 && h < 112 || h >= 64 && h <= 91 || h > 185 && h < 193 || h > 218 && h < 223) {\n          var y = s.modifiers, v = y.alt || y.ctrl || y.meta || y.shift;\n          y.alt || v && r.getCommandHandler(s, \"taskCell\") || d && !t.isVisible() && (n.startEdit(l.id, l.columnName), g = !0);\n        }\n    }\n    return !g;\n  });\n}, onShow: function(t, e, n) {\n}, onHide: function(t, e, n) {\n  const i = n.$gantt;\n  i && i.focus();\n}, destroy: function() {\n} };\nfunction St(t) {\n  var e = function() {\n  };\n  return e.prototype = { show: function(n, i, a, r) {\n  }, hide: function() {\n  }, set_value: function(n, i, a, r) {\n    this.get_input(r).value = n;\n  }, get_value: function(n, i, a) {\n    return this.get_input(a).value || \"\";\n  }, is_changed: function(n, i, a, r) {\n    var s = this.get_value(i, a, r);\n    return s && n && s.valueOf && n.valueOf ? s.valueOf() != n.valueOf() : s != n;\n  }, is_valid: function(n, i, a, r) {\n    return !0;\n  }, save: function(n, i, a) {\n  }, get_input: function(n) {\n    return n.querySelector(\"input\");\n  }, focus: function(n) {\n    var i = this.get_input(n);\n    i && (i.focus && i.focus(), i.select && i.select());\n  } }, e;\n}\nfunction ba(t) {\n  var e = St();\n  function n() {\n    return e.apply(this, arguments) || this;\n  }\n  return z(n, e), P(n.prototype, { show: function(i, a, r, s) {\n    var o = `<div role='cell'><input type='text' name='${a.name}' title='${a.name}'></div>`;\n    s.innerHTML = o;\n  } }, !0), n;\n}\nfunction xa(t) {\n  var e = St();\n  function n() {\n    return e.apply(this, arguments) || this;\n  }\n  return z(n, e), P(n.prototype, { show: function(i, a, r, s) {\n    var o = r.min || 0, l = r.max || 100, d = `<div role='cell'><input type='number' min='${o}' max='${l}' name='${a.name}' title='${a.name}'></div>`;\n    s.innerHTML = d, s.oninput = function(c) {\n      +c.target.value < o && (c.target.value = o), +c.target.value > l && (c.target.value = l);\n    };\n  }, get_value: function(i, a, r) {\n    return this.get_input(r).value || \"\";\n  }, is_valid: function(i, a, r, s) {\n    return !isNaN(parseInt(i, 10));\n  } }, !0), n;\n}\nfunction $a(t) {\n  var e = St();\n  function n() {\n    return e.apply(this, arguments) || this;\n  }\n  return z(n, e), P(n.prototype, { show: function(i, a, r, s) {\n    for (var o = `<div role='cell'><select name='${a.name}' title='${a.name}'>`, l = [], d = r.options || [], c = 0; c < d.length; c++) l.push(\"<option value='\" + r.options[c].key + \"'>\" + d[c].label + \"</option>\");\n    o += l.join(\"\") + \"</select></div>\", s.innerHTML = o;\n  }, get_input: function(i) {\n    return i.querySelector(\"select\");\n  } }, !0), n;\n}\nfunction wa(t) {\n  var e = St(), n = \"%Y-%m-%d\", i = null, a = null;\n  function r() {\n    return e.apply(this, arguments) || this;\n  }\n  return z(r, e), P(r.prototype, { show: function(s, o, l, d) {\n    i || (i = t.date.date_to_str(n)), a || (a = t.date.str_to_date(n));\n    var c = null, u = null;\n    c = typeof l.min == \"function\" ? l.min(s, o) : l.min, u = typeof l.max == \"function\" ? l.max(s, o) : l.max;\n    var h = `<div style='width:140px' role='cell'><input type='date' ${c ? \" min='\" + i(c) + \"' \" : \"\"} ${u ? \" max='\" + i(u) + \"' \" : \"\"} name='${o.name}' title='${o.name}'></div>`;\n    d.innerHTML = h, d.oninput = function(g) {\n      g.target.value && (c || u) && (+t.date.str_to_date(\"%Y-%m-%d\")(g.target.value) < +c && (g.target.value = t.date.date_to_str(\"%Y-%m-%d\")(c)), +t.date.str_to_date(\"%Y-%m-%d\")(g.target.value) > +u && (g.target.value = t.date.date_to_str(\"%Y-%m-%d\")(u)));\n    };\n  }, set_value: function(s, o, l, d) {\n    s && s.getFullYear ? this.get_input(d).value = i(s) : this.get_input(d).value = s;\n  }, is_valid: function(s, o, l, d) {\n    return !(!s || isNaN(s.getTime()));\n  }, get_value: function(s, o, l) {\n    var d;\n    try {\n      d = a(this.get_input(l).value || \"\");\n    } catch {\n      d = null;\n    }\n    return d;\n  } }, !0), r;\n}\nfunction Sa(t) {\n  var e = St();\n  function n() {\n    return e.apply(this, arguments) || this;\n  }\n  function i(l) {\n    return l.formatter || t.ext.formatters.linkFormatter();\n  }\n  function a(l, d) {\n    for (var c = (l || \"\").split(d.delimiter || \",\"), u = 0; u < c.length; u++) {\n      var h = c[u].trim();\n      h ? c[u] = h : (c.splice(u, 1), u--);\n    }\n    return c.sort(), c;\n  }\n  function r(l, d, c) {\n    for (var u = l.$target, h = [], g = 0; g < u.length; g++) {\n      var p = c.getLink(u[g]);\n      h.push(i(d).format(p));\n    }\n    return h.join((d.delimiter || \",\") + \" \");\n  }\n  function s(l) {\n    return l.source + \"_\" + l.target + \"_\" + l.type + \"_\" + (l.lag || 0);\n  }\n  function o(l, d, c) {\n    var u = function(v, b, _) {\n      var m = [];\n      return [...new Set(b)].forEach(function(f) {\n        var k = i(_).parse(f);\n        k && (k.target = v, k.id = \"predecessor_generated\", t.isLinkAllowed(k) && (k.id = void 0, m.push(k)));\n      }), m;\n    }(l.id, d, c), h = {};\n    l.$target.forEach(function(v) {\n      var b = t.getLink(v);\n      h[s(b)] = b.id;\n    });\n    var g = [];\n    u.forEach(function(v) {\n      var b = s(v);\n      h[b] ? delete h[b] : g.push(v);\n    });\n    var p = [];\n    for (var y in h) p.push(h[y]);\n    return { add: g, remove: p };\n  }\n  return z(n, e), P(n.prototype, { show: function(l, d, c, u) {\n    var h = `<div role='cell'><input type='text' name='${d.name}' title='${d.name}'></div>`;\n    u.innerHTML = h;\n  }, hide: function() {\n  }, set_value: function(l, d, c, u) {\n    this.get_input(u).value = r(l, c.editor, t);\n  }, get_value: function(l, d, c) {\n    return a(this.get_input(c).value || \"\", d.editor);\n  }, save: function(l, d, c) {\n    var u = o(t.getTask(l), this.get_value(l, d, c), d.editor);\n    (u.add.length || u.remove.length) && t.batchUpdate(function() {\n      u.add.forEach(function(h) {\n        t.addLink(h);\n      }), u.remove.forEach(function(h) {\n        t.deleteLink(h);\n      }), t.autoSchedule && t.autoSchedule();\n    });\n  }, is_changed: function(l, d, c, u) {\n    var h = this.get_value(d, c, u), g = a(r(l, c.editor, t), c.editor);\n    return h.join() !== g.join();\n  } }, !0), n;\n}\nfunction Ta(t) {\n  var e = St();\n  function n() {\n    return e.apply(this, arguments) || this;\n  }\n  function i(a) {\n    return a.formatter || t.ext.formatters.durationFormatter();\n  }\n  return z(n, e), P(n.prototype, { show: function(a, r, s, o) {\n    var l = `<div role='cell'><input type='text' name='${r.name}' title='${r.name}'></div>`;\n    o.innerHTML = l;\n  }, set_value: function(a, r, s, o) {\n    this.get_input(o).value = i(s.editor).format(a);\n  }, get_value: function(a, r, s) {\n    return i(r.editor).parse(this.get_input(s).value || \"\");\n  } }, !0), n;\n}\nfunction Ea(t) {\n  return function(n, i, a) {\n    a == \"keepDates\" ? function(r, s) {\n      s == \"duration\" ? r.end_date = t.calculateEndDate(r) : s != \"end_date\" && s != \"start_date\" || (r.duration = t.calculateDuration(r));\n    }(n, i) : a == \"keepDuration\" ? function(r, s) {\n      s == \"end_date\" ? r.start_date = e(r) : s != \"start_date\" && s != \"duration\" || (r.end_date = t.calculateEndDate(r));\n    }(n, i) : function(r, s) {\n      t.config.schedule_from_end ? s == \"end_date\" || s == \"duration\" ? r.start_date = e(r) : s == \"start_date\" && (r.duration = t.calculateDuration(r)) : s == \"start_date\" || s == \"duration\" ? r.end_date = t.calculateEndDate(r) : s == \"end_date\" && (r.duration = t.calculateDuration(r));\n    }(n, i);\n  };\n  function e(n) {\n    return t.calculateEndDate({ start_date: n.end_date, duration: -n.duration, task: n });\n  }\n}\nfunction Ca(t) {\n  t.config.editor_types = { text: new (ba())(), number: new (xa())(), select: new ($a())(), date: new (wa(t))(), predecessor: new (Sa(t))(), duration: new (Ta(t))() };\n}\nfunction Da(t) {\n  var e = /* @__PURE__ */ function(a) {\n    var r = null;\n    return { setMapping: function(s) {\n      r = s;\n    }, getMapping: function() {\n      return r || (a.config.keyboard_navigation_cells && a.ext.keyboardNavigation ? ya : ka);\n    } };\n  }(t), n = {};\n  ot(n);\n  var i = { init: Ca, createEditors: function(a) {\n    function r(u, h) {\n      var g = a.$getConfig(), p = function(b, _) {\n        for (var m = a.$getConfig(), f = a.getItemTop(b), k = a.getItemHeight(b), x = a.getGridColumns(), $ = 0, w = 0, S = 0, T = 0; T < x.length; T++) {\n          if (x[T].name == _) {\n            S = x[T].width;\n            break;\n          }\n          m.rtl ? w += x[T].width : $ += x[T].width;\n        }\n        return m.rtl ? { top: f, right: w, height: k, width: S } : { top: f, left: $, height: k, width: S };\n      }(u, h), y = document.createElement(\"div\");\n      y.className = \"gantt_grid_editor_placeholder\", y.setAttribute(a.$config.item_attribute, u), y.setAttribute(a.$config.bind + \"_id\", u), y.setAttribute(\"data-column-name\", h);\n      var v = function(b, _) {\n        for (var m = b.getGridColumns(), f = 0; f < m.length; f++) if (m[f].name == _) return f;\n        return 0;\n      }(a, h);\n      return y.setAttribute(\"data-column-index\", v), t._waiAria.inlineEditorAttr(y), g.rtl ? y.style.cssText = [\"top:\" + p.top + \"px\", \"right:\" + p.right + \"px\", \"width:\" + p.width + \"px\", \"height:\" + p.height + \"px\"].join(\";\") : y.style.cssText = [\"top:\" + p.top + \"px\", \"left:\" + p.left + \"px\", \"width:\" + p.width + \"px\", \"height:\" + p.height + \"px\"].join(\";\"), y;\n    }\n    var s = Ea(t), o = [], l = [], d = null, c = { _itemId: null, _columnName: null, _editor: null, _editorType: null, _placeholder: null, locateCell: function(u) {\n      if (!Y(u, a.$grid)) return null;\n      var h = et(u, a.$config.item_attribute), g = et(u, \"data-column-name\");\n      if (h && g) {\n        var p = g.getAttribute(\"data-column-name\");\n        return { id: h.getAttribute(a.$config.item_attribute), columnName: p };\n      }\n      return null;\n    }, getEditorConfig: function(u) {\n      return a.getColumn(u).editor;\n    }, init: function() {\n      var u = e.getMapping();\n      u.init && u.init(this, a), d = a.$gantt.getDatastore(a.$config.bind);\n      var h = this;\n      o.push(d.attachEvent(\"onIdChange\", function(g, p) {\n        h._itemId == g && (h._itemId = p);\n      })), o.push(d.attachEvent(\"onStoreUpdated\", function() {\n        a.$gantt.getState(\"batchUpdate\").batch_update || h.isVisible() && !d.isVisible(h._itemId) && h.hide();\n      })), l.push(t.attachEvent(\"onDataRender\", function() {\n        h._editor && h._placeholder && !Y(h._placeholder, t.$root) && a.$grid_data.appendChild(h._placeholder);\n      })), this.init = function() {\n      };\n    }, getState: function() {\n      return { editor: this._editor, editorType: this._editorType, placeholder: this._placeholder, id: this._itemId, columnName: this._columnName };\n    }, startEdit: function(u, h) {\n      if (this.isVisible() && this.save(), !d.exists(u)) return;\n      var g = { id: u, columnName: h };\n      if (t.isReadonly(d.getItem(u))) return void this.callEvent(\"onEditPrevent\", [g]);\n      if (this.callEvent(\"onBeforeEditStart\", [g]) === !1) return void this.callEvent(\"onEditPrevent\", [g]);\n      const p = this.show(g.id, g.columnName);\n      p && p.then ? p.then((function() {\n        this.setValue(), this.callEvent(\"onEditStart\", [g]);\n      }).bind(this)) : (this.setValue(), this.callEvent(\"onEditStart\", [g]));\n    }, isVisible: function() {\n      return !(!this._editor || !Y(this._placeholder, t.$root));\n    }, show: function(u, h) {\n      this.isVisible() && this.save();\n      var g = { id: u, columnName: h }, p = a.getColumn(g.columnName), y = this.getEditorConfig(p.name);\n      if (!y) return;\n      var v = a.$getConfig().editor_types[y.type], b = r(g.id, g.columnName);\n      a.$grid_data.appendChild(b);\n      const _ = (function() {\n        this._editor = v, this._placeholder = b, this._itemId = g.id, this._columnName = g.columnName, this._editorType = y.type;\n        var f = e.getMapping();\n        f.onShow && f.onShow(this, b, a), b._onReMount = (function() {\n          this.setValue();\n        }).bind(this);\n      }).bind(this), m = v.show(g.id, p, y, b);\n      if (m && m.then) return m.then(() => {\n        _();\n      });\n      _();\n    }, setValue: function() {\n      var u = this.getState(), h = u.id, g = u.columnName, p = a.getColumn(g), y = d.getItem(h), v = this.getEditorConfig(g);\n      if (v) {\n        var b = y[v.map_to];\n        v.map_to == \"auto\" && (b = d.getItem(h)), this._editor.set_value(b, h, p, this._placeholder), this.focus();\n      }\n    }, focus: function() {\n      this._editor.focus(this._placeholder);\n    }, getValue: function() {\n      var u = a.getColumn(this._columnName);\n      return this._editor.get_value(this._itemId, u, this._placeholder);\n    }, _getItemValue: function() {\n      var u = this.getEditorConfig(this._columnName);\n      if (u) {\n        var h = t.getTask(this._itemId)[u.map_to];\n        return u.map_to == \"auto\" && (h = d.getItem(this._itemId)), h;\n      }\n    }, isChanged: function() {\n      var u = a.getColumn(this._columnName), h = this._getItemValue();\n      return this._editor.is_changed(h, this._itemId, u, this._placeholder);\n    }, hide: function() {\n      if (this._itemId) {\n        var u = this._itemId, h = this._columnName, g = e.getMapping();\n        g.onHide && g.onHide(this, this._placeholder, a), this._itemId = null, this._columnName = null, this._editorType = null, this._placeholder && (this._editor && this._editor.hide && this._editor.hide(this._placeholder), this._editor = null, this._placeholder.parentNode && this._placeholder.parentNode.removeChild(this._placeholder), this._placeholder = null, this.callEvent(\"onEditEnd\", [{ id: u, columnName: h }]));\n      }\n    }, save: function() {\n      if (this.isVisible() && d.exists(this._itemId) && this.isChanged()) {\n        var u = this._itemId, h = this._columnName;\n        if (d.exists(u)) {\n          var g = d.getItem(u), p = this.getEditorConfig(h), y = { id: u, columnName: h, newValue: this.getValue(), oldValue: this._getItemValue() };\n          if (this.callEvent(\"onBeforeSave\", [y]) !== !1 && (!this._editor.is_valid || this._editor.is_valid(y.newValue, y.id, a.getColumn(h), this._placeholder))) {\n            var v = p.map_to, b = y.newValue;\n            v != \"auto\" ? (g[v] = b, s(g, v, t.config.inline_editors_date_processing), d.updateItem(u)) : this._editor.save(u, a.getColumn(h), this._placeholder), this.callEvent(\"onSave\", [y]);\n          }\n          this.hide();\n        }\n      } else this.hide();\n    }, _findEditableCell: function(u, h) {\n      var g = u, p = a.getGridColumns()[g], y = p ? p.name : null;\n      if (y) {\n        for (; y && !this.getEditorConfig(y); ) y = this._findEditableCell(u + h, h);\n        return y;\n      }\n      return null;\n    }, getNextCell: function(u) {\n      return this._findEditableCell(a.getColumnIndex(this._columnName, !0) + u, u);\n    }, getFirstCell: function() {\n      return this._findEditableCell(0, 1);\n    }, getLastCell: function() {\n      return this._findEditableCell(a.getGridColumns().length - 1, -1);\n    }, editNextCell: function(u) {\n      var h = this.getNextCell(1);\n      if (h) {\n        var g = this.getNextCell(1);\n        g && this.getEditorConfig(g) && this.startEdit(this._itemId, g);\n      } else if (u && this.moveRow(1)) {\n        var p = this.moveRow(1);\n        (h = this.getFirstCell()) && this.getEditorConfig(h) && this.startEdit(p, h);\n      }\n    }, editPrevCell: function(u) {\n      var h = this.getNextCell(-1);\n      if (h) {\n        var g = this.getNextCell(-1);\n        g && this.getEditorConfig(g) && this.startEdit(this._itemId, g);\n      } else if (u && this.moveRow(-1)) {\n        var p = this.moveRow(-1);\n        (h = this.getLastCell()) && this.getEditorConfig(h) && this.startEdit(p, h);\n      }\n    }, moveRow: function(u) {\n      for (var h = u > 0 ? t.getNext : t.getPrev, g = (h = t.bind(h, t))(this._itemId); t.isTaskExists(g) && t.isReadonly(t.getTask(g)); ) g = h(g);\n      return g;\n    }, editNextRow: function(u) {\n      var h = this.getState().id;\n      if (t.isTaskExists(h)) {\n        var g = null;\n        g = u ? this.moveRow(1) : t.getNext(h), t.isTaskExists(g) && this.startEdit(g, this._columnName);\n      }\n    }, editPrevRow: function(u) {\n      var h = this.getState().id;\n      if (t.isTaskExists(h)) {\n        var g = null;\n        g = u ? this.moveRow(-1) : t.getPrev(h), t.isTaskExists(g) && this.startEdit(g, this._columnName);\n      }\n    }, detachStore: function() {\n      o.forEach(function(u) {\n        d.detachEvent(u);\n      }), l.forEach(function(u) {\n        t.detachEvent(u);\n      }), o = [], l = [], d = null, this.hide();\n    }, destructor: function() {\n      this.detachStore(), this.detachAllEvents();\n    } };\n    return P(c, e), P(c, n), c;\n  } };\n  return P(i, e), P(i, n), i;\n}\nfunction $e(t, e, n, i, a) {\n  if (!t.start_date || !t.end_date) return null;\n  var r = n.getItemTop(t.id), s = n.getItemHeight(t.id);\n  if (r > e.y_end || r + s < e.y) return !1;\n  var o = n.posFromDate(t.start_date), l = n.posFromDate(t.end_date), d = Math.min(o, l) - 200, c = Math.max(o, l) + 200;\n  return !(d > e.x_end || c < e.x);\n}\nfunction bn(t) {\n  function e(r, s, o) {\n    if (t._isAllowedUnscheduledTask(r) || !t._isTaskInTimelineLimits(r)) return;\n    var l = s.getItemPosition(r), d = o, c = s.$getTemplates(), u = t.getTaskType(r.type), h = s.getBarHeight(r.id, u == d.types.milestone), g = 0;\n    u == d.types.milestone && (g = (h - l.height) / 2);\n    var p = Math.floor((s.getItemHeight(r.id) - h) / 2);\n    const y = t.config.baselines && r.baselines && r.baselines.length, v = t.config.baselines && (t.config.baselines.render_mode == \"separateRow\" || t.config.baselines.render_mode == \"individualRow\");\n    if (y && v && r.bar_height !== \"full\" && r.bar_height < r.row_height) if (u === d.types.milestone) {\n      let T = s.getBarHeight(r.id, !0), E = Math.sqrt(2 * T * T);\n      p = Math.floor((E - h) / 2) + 2;\n    } else p = 2;\n    u == d.types.milestone && (l.left -= Math.round(h / 2), l.width = h);\n    var b = document.createElement(\"div\"), _ = Math.round(l.width);\n    s.$config.item_attribute && (b.setAttribute(s.$config.item_attribute, r.id), b.setAttribute(s.$config.bind + \"_id\", r.id)), d.show_progress && u != d.types.milestone && function(T, E, C, D, M) {\n      var I = 1 * T.progress || 0;\n      C = Math.max(C, 0);\n      var A = document.createElement(\"div\"), N = Math.round(C * I);\n      N = Math.min(C, N), A.style.width = N + \"px\", A.className = \"gantt_task_progress\", A.innerHTML = M.progress_text(T.start_date, T.end_date, T), D.rtl && (A.style.position = \"absolute\", A.style.right = \"0px\");\n      var L = document.createElement(\"div\");\n      L.className = \"gantt_task_progress_wrapper\", L.appendChild(A), E.appendChild(L);\n      const O = !t.isReadonly(T), G = t.ext.dragTimeline && t.ext.dragTimeline._isDragInProgress();\n      if (t.config.drag_progress && (O || G)) {\n        var j = document.createElement(\"div\"), H = N;\n        D.rtl && (H = C - N), j.style.left = H + \"px\", j.className = \"gantt_task_progress_drag\", j.innerHTML = `<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"12\" height=\"9\" viewBox=\"0 0 12 9\" fill=\"none\">\n<path d=\"M5.58397 1.52543C5.78189 1.22856 6.21811 1.22856 6.41602 1.52543L10.5475 7.72265C10.769 8.05493 10.5308 8.5 10.1315 8.5L1.86852 8.5C1.46917 8.5 1.23097 8.05493 1.45249 7.72265L5.58397 1.52543Z\" fill=\"var(--dhx-gantt-progress-handle-background)\" stroke=\"var(--dhx-gantt-progress-handle-border)\"/>\n</svg>`, A.appendChild(j), E.appendChild(j);\n      }\n    }(r, b, _, d, c);\n    var m = function(T, E, C) {\n      var D = document.createElement(\"div\");\n      return t.getTaskType(T.type) != t.config.types.milestone ? D.innerHTML = C.task_text(T.start_date, T.end_date, T) : t.getTaskType(T.type) == t.config.types.milestone && E && (D.style.height = D.style.width = E + \"px\"), D.className = \"gantt_task_content\", D;\n    }(r, _, c);\n    b.appendChild(m);\n    var f = function(T, E, C, D) {\n      var M = D.$getConfig(), I = [T];\n      E && I.push(E);\n      var A = t.getState(), N = t.getTask(C);\n      if (t.getTaskType(N.type) == M.types.milestone ? I.push(\"gantt_milestone\") : t.getTaskType(N.type) == M.types.project && I.push(\"gantt_project\"), I.push(\"gantt_bar_\" + t.getTaskType(N.type)), t.isSummaryTask(N) && I.push(\"gantt_dependent_task\"), t.isSplitTask(N) && (M.open_split_tasks && !N.$open || !M.open_split_tasks) && I.push(\"gantt_split_parent\"), M.select_task && t.isSelectedTask(C) && I.push(\"gantt_selected\"), C == A.drag_id && (I.push(\"gantt_drag_\" + A.drag_mode), A.touch_drag && I.push(\"gantt_touch_\" + A.drag_mode)), A.link_source_id == C && (I.push(\"gantt_link_source\"), A.link_from_start ? I.push(\"gantt_link_from_start\") : I.push(\"gantt_link_from_end\")), A.link_target_id == C && I.push(\"gantt_link_target\"), M.highlight_critical_path && t.isCriticalTask && t.isCriticalTask(N) && I.push(\"gantt_critical_task\"), A.link_landing_area && A.link_target_id && A.link_source_id && A.link_target_id != A.link_source_id && (A.link_target_id == C || A.link_source_id == C)) {\n        var L = A.link_source_id, O = A.link_from_start, G = A.link_to_start, j = \"\";\n        j = t.isLinkAllowed(L, C, O, G) ? G ? \"link_start_allow\" : \"link_finish_allow\" : G ? \"link_start_deny\" : \"link_finish_deny\", I.push(j);\n      }\n      return I.join(\" \");\n    }(\"gantt_task_line\", c.task_class(r.start_date, r.end_date, r), r.id, s);\n    (r.color || r.progressColor || r.textColor) && (f += \" gantt_task_inline_color\"), l.width < 20 && (f += \" gantt_thin_task\"), b.className = f;\n    var k = [\"left:\" + l.left + \"px\", \"top:\" + (p + l.top) + \"px\", \"height:\" + h + \"px\", \"line-height:\" + Math.max(h < 30 ? h - 2 : h, 0) + \"px\", \"width:\" + _ + \"px\"];\n    b.style.cssText = k.join(\";\"), r.color && b.style.setProperty(\"--dhx-gantt-task-background\", r.color), r.textColor && b.style.setProperty(\"--dhx-gantt-task-color\", r.textColor), r.progressColor && b.style.setProperty(\"--dhx-gantt-task-progress-color\", r.progressColor);\n    var x = function(T, E, C, D) {\n      var M = \"gantt_left \" + i(!E.rtl, T), I = null;\n      return D && (I = { type: \"marginRight\", value: D }), n(T, C.leftside_text, M, I);\n    }(r, d, c, g);\n    x && b.appendChild(x), x = function(T, E, C, D) {\n      var M = \"gantt_right \" + i(!!E.rtl, T), I = null;\n      return D && (I = { type: \"marginLeft\", value: D }), n(T, C.rightside_text, M, I);\n    }(r, d, c, g), x && b.appendChild(x), t._waiAria.setTaskBarAttr(r, b);\n    var $ = t.getState();\n    const w = !t.isReadonly(r), S = t.ext.dragTimeline && t.ext.dragTimeline._isDragInProgress();\n    return (w || S) && (d.drag_resize && !t.isSummaryTask(r) && u != d.types.milestone && a(b, \"gantt_task_drag\", r, function(T) {\n      var E = document.createElement(\"div\");\n      return E.className = T, E;\n    }, d), d.drag_links && d.show_links && a(b, \"gantt_link_control\", r, function(T) {\n      var E = document.createElement(\"div\");\n      E.className = T, E.style.cssText = [\"height:\" + h + \"px\", \"line-height:\" + h + \"px\"].join(\";\");\n      var C = document.createElement(\"div\");\n      C.className = \"gantt_link_point\";\n      var D = !1;\n      return $.link_source_id && d.touch && (D = !0), C.style.display = D ? \"block\" : \"\", E.appendChild(C), E;\n    }, d, g)), b;\n  }\n  function n(r, s, o, l) {\n    if (!s) return null;\n    var d = s(r.start_date, r.end_date, r);\n    if (!d) return null;\n    var c = document.createElement(\"div\");\n    return c.className = \"gantt_side_content \" + o, c.innerHTML = d, l && (c.style[l.type] = Math.abs(l.value) + \"px\"), c;\n  }\n  function i(r, s) {\n    var o = r ? { $source: [t.config.links.start_to_start], $target: [t.config.links.start_to_start, t.config.links.finish_to_start] } : { $source: [t.config.links.finish_to_start, t.config.links.finish_to_finish], $target: [t.config.links.finish_to_finish] };\n    for (var l in o) for (var d = s[l], c = 0; c < d.length; c++) for (var u = t.getLink(d[c]), h = 0; h < o[l].length; h++) if (u.type == o[l][h]) return \"gantt_link_crossing\";\n    return \"\";\n  }\n  function a(r, s, o, l, d, c) {\n    var u, h = t.getState();\n    +o.start_date >= +h.min_date && ((u = l([s, d.rtl ? \"task_right\" : \"task_left\", \"task_start_date\"].join(\" \"))).setAttribute(\"data-bind-property\", \"start_date\"), c && (u.style.marginLeft = c + \"px\"), r.appendChild(u)), +o.end_date <= +h.max_date && ((u = l([s, d.rtl ? \"task_left\" : \"task_right\", \"task_end_date\"].join(\" \"))).setAttribute(\"data-bind-property\", \"end_date\"), c && (u.style.marginRight = c + \"px\"), r.appendChild(u));\n  }\n  return function(r, s, o) {\n    var l = (o = s.$getConfig()).type_renderers[t.getTaskType(r.type)], d = e;\n    return l ? l.call(t, r, function(c) {\n      return d.call(t, c, s, o);\n    }, s) : d.call(t, r, s, o);\n  };\n}\nfunction Ue(t) {\n  return { render: bn(t), update: null, isInViewPort: $e, getVisibleRange: ft };\n}\nfunction Ct() {\n  return console.error(\"You are trying to use a Pro feature that is not available in the GPL version.\"), { render: function() {\n  }, isInViewPort: function() {\n  }, getVisibleRange: function() {\n  } };\n}\nfunction qe(t, e, n) {\n  return { top: e.getItemTop(t.id), height: e.getItemHeight(t.id), left: 0, right: 1 / 0 };\n}\nfunction jt(t, e) {\n  var n = 0, i = t.left.length - 1;\n  if (e) for (var a = 0; a < t.left.length; a++) {\n    var r = t.left[a];\n    if (r < e.x && (n = a), r > e.x_end) {\n      i = a;\n      break;\n    }\n  }\n  return { start: n, end: i };\n}\nfunction oe(t, e, n, i) {\n  var a = e.width[t];\n  if (a <= 0) return !1;\n  if (!i.config.smart_rendering || Nt(i)) return !0;\n  var r = e.left[t] - a, s = e.left[t] + a;\n  return r <= n.x_end && s >= n.x;\n}\nfunction Aa(t, e) {\n  var n = e.config.timeline_placeholder;\n  if (t = t || [], n && t.filter((l) => l.id === \"timeline_placeholder_task\").length === 0) {\n    var i = e.getState(), a = null, r = i.min_date, s = i.max_date;\n    t.length && (a = t[t.length - 1].id);\n    var o = { start_date: r, end_date: s, row_height: n.height || 0, id: \"timeline_placeholder_task\", unscheduled: !0, lastTaskId: a, calendar_id: n.calendar || \"global\", $source: [], $target: [] };\n    t.push(o);\n  }\n}\nfunction Ia(t) {\n  var e = { current_pos: null, dirs: { left: \"left\", right: \"right\", up: \"up\", down: \"down\" }, path: [], clear: function() {\n    this.current_pos = null, this.path = [];\n  }, point: function(a) {\n    this.current_pos = t.copy(a);\n  }, get_lines: function(a) {\n    this.clear(), this.point(a[0]);\n    for (var r = 1; r < a.length; r++) this.line_to(a[r]);\n    return this.get_path();\n  }, line_to: function(a) {\n    var r = t.copy(a), s = this.current_pos, o = this._get_line(s, r);\n    this.path.push(o), this.current_pos = r;\n  }, get_path: function() {\n    return this.path;\n  }, get_wrapper_sizes: function(a, r, s) {\n    var o, l = r.$getConfig().link_wrapper_width, d = a.y - l / 2;\n    switch (a.direction) {\n      case this.dirs.left:\n        o = { top: d, height: l, lineHeight: l, left: a.x - a.size - l / 2, width: a.size + l };\n        break;\n      case this.dirs.right:\n        o = { top: d, lineHeight: l, height: l, left: a.x - l / 2, width: a.size + l };\n        break;\n      case this.dirs.up:\n        o = { top: d - a.size, lineHeight: a.size + l, height: a.size + l, left: a.x - l / 2, width: l };\n        break;\n      case this.dirs.down:\n        o = { top: d, lineHeight: a.size + l, height: a.size + l, left: a.x - l / 2, width: l };\n    }\n    return o;\n  }, get_line_sizes: function(a, r) {\n    var s, o = r.$getConfig(), l = o.link_line_width, d = o.link_wrapper_width, c = a.size + l;\n    switch (a.direction) {\n      case this.dirs.left:\n      case this.dirs.right:\n        s = { height: l, width: c, marginTop: (d - l) / 2, marginLeft: (d - l) / 2 };\n        break;\n      case this.dirs.up:\n      case this.dirs.down:\n        s = { height: c, width: l, marginTop: (d - l) / 2, marginLeft: (d - l) / 2 };\n    }\n    return s;\n  }, render_line: function(a, r, s, o) {\n    var l = this.get_wrapper_sizes(a, s, o), d = document.createElement(\"div\");\n    d.style.cssText = [\"top:\" + l.top + \"px\", \"left:\" + l.left + \"px\", \"height:\" + l.height + \"px\", \"width:\" + l.width + \"px\"].join(\";\"), d.className = \"gantt_line_wrapper\";\n    var c = this.get_line_sizes(a, s), u = document.createElement(\"div\");\n    return u.style.cssText = [\"height:\" + c.height + \"px\", \"width:\" + c.width + \"px\", \"margin-top:\" + c.marginTop + \"px\", \"margin-left:\" + c.marginLeft + \"px\"].join(\";\"), u.className = \"gantt_link_line_\" + a.direction, d.appendChild(u), d;\n  }, render_corner: function(a, r) {\n    const s = a.radius, o = r.$getConfig(), l = o.link_line_width || 2, d = document.createElement(\"div\");\n    let c, u;\n    return d.classList.add(\"gantt_link_corner\"), d.classList.add(`gantt_link_corner_${a.direction.from}_${a.direction.to}`), d.style.width = `${s}px`, d.style.height = `${s}px`, a.direction.from === \"right\" && a.direction.to === \"down\" ? (c = \"Right\", u = \"Top\", d.style.left = a.x - o.link_line_width / 2 + \"px\", d.style.top = `${a.y}px`) : a.direction.from === \"down\" && a.direction.to === \"right\" ? (c = \"Left\", u = \"Bottom\", d.style.left = a.x - o.link_line_width / 2 + \"px\", d.style.top = `${a.y}px`) : a.direction.from === \"right\" && a.direction.to === \"up\" ? (c = \"Right\", u = \"Bottom\", d.style.left = a.x - o.link_line_width / 2 + \"px\", d.style.top = a.y - s + \"px\") : a.direction.from === \"up\" && a.direction.to === \"right\" ? (c = \"Left\", u = \"Top\", d.style.left = a.x - o.link_line_width / 2 + \"px\", d.style.top = a.y - s + \"px\") : a.direction.from === \"left\" && a.direction.to === \"down\" ? (c = \"Left\", u = \"Top\", d.style.left = a.x - s - o.link_line_width / 2 + \"px\", d.style.top = `${a.y}px`) : a.direction.from === \"down\" && a.direction.to === \"left\" ? (c = \"Right\", u = \"Bottom\", d.style.left = a.x - s - o.link_line_width / 2 + \"px\", d.style.top = `${a.y}px`) : a.direction.from === \"left\" && a.direction.to === \"up\" ? (c = \"Left\", u = \"Bottom\", d.style.left = a.x - s - o.link_line_width / 2 + \"px\", d.style.top = a.y - s + \"px\") : a.direction.from === \"up\" && a.direction.to === \"left\" && (c = \"Right\", u = \"Top\", d.style.left = a.x - s - o.link_line_width / 2 + \"px\", d.style.top = a.y - s + \"px\"), d.style[`border${u}Width`] = `${l}px`, d.style[`border${c}Width`] = `${l}px`, d.style[`border${c}Style`] = \"solid\", d.style[`border${u}Style`] = \"solid\", d.style[`border${u}${c}Radius`] = `${s}px`, d;\n  }, render_arrow(a, r) {\n    var s = document.createElement(\"div\"), o = a.y, l = a.x, d = r.link_arrow_size;\n    s.style.setProperty(\"--dhx-gantt-icon-size\", `${d}px`);\n    var c = \"gantt_link_arrow gantt_link_arrow_\" + a.direction;\n    return s.style.top = o + \"px\", s.style.left = l + \"px\", s.className = c, s;\n  }, _get_line: function(a, r) {\n    var s = this.get_direction(a, r), o = { x: a.x, y: a.y, direction: this.get_direction(a, r) };\n    return s == this.dirs.left || s == this.dirs.right ? o.size = Math.abs(a.x - r.x) : o.size = Math.abs(a.y - r.y), o;\n  }, get_direction: function(a, r) {\n    return r.x < a.x ? this.dirs.left : r.x > a.x ? this.dirs.right : r.y > a.y ? this.dirs.down : this.dirs.up;\n  } }, n = { path: [], clear: function() {\n    this.path = [];\n  }, current: function() {\n    return this.path[this.path.length - 1];\n  }, point: function(a) {\n    return a ? (this.path.push(t.copy(a)), a) : this.current();\n  }, point_to: function(a, r, s) {\n    s = s ? { x: s.x, y: s.y } : t.copy(this.point());\n    var o = e.dirs;\n    switch (a) {\n      case o.left:\n        s.x -= r;\n        break;\n      case o.right:\n        s.x += r;\n        break;\n      case o.up:\n        s.y -= r;\n        break;\n      case o.down:\n        s.y += r;\n    }\n    return this.point(s);\n  }, get_points: function(a, r, s, o) {\n    var l = this.get_endpoint(a, r, s, o), d = t.config, c = l.e_y - l.y, u = l.e_x - l.x, h = e.dirs, g = r.getItemHeight(a.source);\n    this.clear(), this.point({ x: l.x, y: l.y });\n    var p = 2 * d.link_arrow_size, y = this.get_line_type(a, r.$getConfig()), v = l.e_x > l.x;\n    if (y.from_start && y.to_start) this.point_to(h.left, p), v ? (this.point_to(h.down, c), this.point_to(h.right, u)) : (this.point_to(h.right, u), this.point_to(h.down, c)), this.point_to(h.right, p);\n    else if (!y.from_start && y.to_start) if (c !== 0 && (v = l.e_x > l.x + 2 * p), this.point_to(h.right, p), v) u -= p, this.point_to(h.down, c), this.point_to(h.right, u);\n    else {\n      u -= 2 * p;\n      var b = c > 0 ? 1 : -1;\n      this.point_to(h.down, b * (g / 2)), this.point_to(h.right, u), this.point_to(h.down, b * (Math.abs(c) - g / 2)), this.point_to(h.right, p);\n    }\n    else y.from_start || y.to_start ? y.from_start && !y.to_start && (c !== 0 && (v = l.e_x > l.x - 2 * p), this.point_to(h.left, p), v ? (u += 2 * p, b = c > 0 ? 1 : -1, this.point_to(h.down, b * (g / 2)), this.point_to(h.right, u), this.point_to(h.down, b * (Math.abs(c) - g / 2)), this.point_to(h.left, p)) : (u += p, this.point_to(h.down, c), this.point_to(h.right, u))) : (this.point_to(h.right, p), v ? (this.point_to(h.right, u), this.point_to(h.down, c)) : (this.point_to(h.down, c), this.point_to(h.right, u)), this.point_to(h.left, p));\n    return this.path;\n  }, get_line_type: function(a, r) {\n    var s = r.links, o = !1, l = !1;\n    return a.type == s.start_to_start ? o = l = !0 : a.type == s.finish_to_finish ? o = l = !1 : a.type == s.finish_to_start ? (o = !1, l = !0) : a.type == s.start_to_finish ? (o = !0, l = !1) : t.assert(!1, \"Invalid link type\"), r.rtl && (o = !o, l = !l), { from_start: o, to_start: l };\n  }, get_endpoint: function(a, r, s, o) {\n    var l = r.$getConfig(), d = this.get_line_type(a, l), c = d.from_start, u = d.to_start, h = i(s, r, l), g = i(o, r, l);\n    return { x: c ? h.left : h.left + h.width, e_x: u ? g.left : g.left + g.width, y: h.top + h.rowHeight / 2 - 1, e_y: g.top + g.rowHeight / 2 - 1 };\n  } };\n  function i(a, r, s) {\n    var o = r.getItemPosition(a);\n    let l = function(p, y, v, b) {\n      let _ = b || y.$task_data.scrollHeight, m = !1, f = !1;\n      return p.eachParent(function(k) {\n        if ($t(k)) {\n          f = !0;\n          const x = y.getItemPosition(k).rowHeight;\n          x < _ && (_ = x, m = !0);\n        }\n      }, v.id), { maxHeight: _, shrinkHeight: m, splitChild: f };\n    }(t, r, a), d = l.maxHeight, c = l.splitChild;\n    const u = t.config.baselines && (t.config.baselines.render_mode == \"separateRow\" || t.config.baselines.render_mode == \"individualRow\") && a.baselines && a.baselines.length;\n    let h;\n    l.shrinkHeight && (o.rowHeight = d);\n    let g = t.getTaskType(a.type) == s.types.milestone;\n    if (g) {\n      let p = r.getBarHeight(a.id, !0);\n      h = Math.sqrt(2 * p * p), l.shrinkHeight && d < p && (p = d, h = d), o.left -= h / 2, o.width = h;\n    }\n    if (c) if (d >= o.height) {\n      const p = function(y, v) {\n        let b = !1;\n        return y.eachTask(function(_) {\n          b || (b = hn(y, _));\n        }, v), b;\n      }(t, a.parent);\n      u || p ? g ? (o.rowHeight = o.height + 4, o.left += (o.width - o.rowHeight + 4) / 2, o.width = o.rowHeight - 3) : o.rowHeight = o.height + 6 : g && (o.left += (h - o.height) / 2);\n    } else o.rowHeight = d + 2, g && (o.left += (o.width - o.rowHeight + 4) / 2, o.width = o.rowHeight - 3);\n    else u && (o.rowHeight = o.height + 4);\n    return o;\n  }\n  return { render: function(a, r, s) {\n    var o = t.getTask(a.source);\n    if (o.hide_bar) return;\n    var l = t.getTask(a.target);\n    if (l.hide_bar) return;\n    var d = n.get_endpoint(a, r, o, l), c = d.e_y - d.y;\n    if (!(d.e_x - d.x) && !c) return null;\n    var u = n.get_points(a, r, o, l);\n    const h = function(v, b) {\n      const _ = b.link_radius || 4, m = b.link_arrow_size || 6, f = [];\n      for (let x = 0; x < v.length; x++) {\n        const $ = v[x], w = v[x + 1];\n        if (!w || b.link_radius <= 1) f.push({ type: \"line\", data: $ });\n        else if ($.direction !== w.direction) {\n          if ($.size < _ || w.size < _) {\n            f.push({ type: \"line\", data: $ });\n            continue;\n          }\n          $.size -= _, f.push({ type: \"line\", data: $ });\n          let S = $.x, T = $.y - b.link_line_width / 2;\n          switch ($.direction) {\n            case \"right\":\n              S += $.size;\n              break;\n            case \"left\":\n              S -= $.size;\n              break;\n            case \"down\":\n              T += $.size;\n              break;\n            case \"up\":\n              T -= $.size;\n          }\n          const E = { x: S, y: T, direction: { from: $.direction, to: w.direction }, radius: _ };\n          switch (f.push({ type: \"corner\", data: E }), w.direction) {\n            case \"right\":\n              w.x += _, w.size -= _;\n              break;\n            case \"left\":\n              w.x -= _, w.size -= _;\n              break;\n            case \"down\":\n              w.y += _, w.size -= _;\n              break;\n            case \"up\":\n              w.y -= _, w.size -= _;\n          }\n        } else f.push({ type: \"line\", data: $ });\n      }\n      const k = v[v.length - 1];\n      if (k.direction === \"right\" || k.direction === \"left\") {\n        k.size -= 3 * m / 4;\n        let x = k.direction === \"right\" ? k.x + k.size : k.x - k.size - m / 2, $ = k.y - b.link_line_width / 2 - m / 2 + 1;\n        k.direction === \"left\" ? ($ -= 1, x -= 2) : x -= 1;\n        const w = { x, y: $, size: m, direction: k.direction };\n        f.push({ type: \"line\", data: k }), f.push({ type: \"arrow\", data: w });\n      } else f.push({ type: \"line\", data: k });\n      return f;\n    }(e.get_lines(u, r).filter((v) => v.size > 0), s), g = function(v, b, _, m) {\n      const f = document.createElement(\"div\");\n      return v.forEach((k) => {\n        let x;\n        k.type === \"line\" ? x = e.render_line(k.data, null, b, _.source) : k.type === \"corner\" ? x = e.render_corner(k.data, b) : k.type === \"arrow\" && (x = e.render_arrow(k.data, m)), f.appendChild(x);\n      }), f;\n    }(h, r, a, s);\n    var p = \"gantt_task_link\";\n    a.color && (p += \" gantt_link_inline_color\");\n    var y = t.templates.link_class ? t.templates.link_class(a) : \"\";\n    return y && (p += \" \" + y), s.highlight_critical_path && t.isCriticalLink && t.isCriticalLink(a) && (p += \" gantt_critical_link\"), g.className = p, r.$config.link_attribute && (g.setAttribute(r.$config.link_attribute, a.id), g.setAttribute(\"link_id\", a.id)), a.color && g.style.setProperty(\"--dhx-gantt-link-background\", a.color), t._waiAria.linkAttr(a, g), g;\n  }, update: null, isInViewPort: vn, getVisibleRange: mn() };\n}\nfunction Ma(t, e, n, i, a) {\n  if (a.$ui.getView(\"grid\") && (a.config.keyboard_navigation && a.getSelectedId() || a.ext.inlineEditors && a.ext.inlineEditors.getState().id)) return !!t.$expanded_branch;\n  var r = n.getItemTop(t.id), s = n.getItemHeight(t.id);\n  return !(r > e.y_end || r + s < e.y);\n}\nfunction Na(t) {\n  let e = {};\n  return t.$data.tasksStore.attachEvent(\"onStoreUpdated\", function() {\n    e = {};\n  }), function(n, i, a, r) {\n    const s = n.id + \"_\" + i + \"_\" + a.unit + \"_\" + a.step;\n    let o;\n    return o = e[s] ? e[s] : e[s] = function(l, d, c, u) {\n      let h, g = !1, p = {};\n      t.config.process_resource_assignments && d === t.config.resource_property ? (h = l.$role == \"task\" ? t.getResourceAssignments(l.$resource_id, l.$task_id) : t.getResourceAssignments(l.id), g = !0) : h = l.$role == \"task\" ? [] : t.getTaskBy(d, l.id), p = function(w, S, T) {\n        const E = S.unit, C = S.step, D = {}, M = {};\n        for (let I = 0; I < w.length; I++) {\n          const A = w[I];\n          let N = A;\n          if (T && (N = t.getTask(A.task_id)), N.unscheduled) continue;\n          let L = A.start_date || N.start_date, O = A.end_date || N.end_date;\n          T && (A.start_date && (L = new Date(Math.max(A.start_date.valueOf(), N.start_date.valueOf()))), A.end_date && (O = new Date(Math.min(A.end_date.valueOf(), N.end_date.valueOf()))), A.mode && A.mode == \"fixedDates\" && (L = A.start_date, O = A.end_date));\n          let G = At(S.trace_x, L.valueOf()), j = new Date(S.trace_x[G] || t.date[E + \"_start\"](new Date(L))), H = new Date(Math.min(L.valueOf(), j.valueOf())), Q = t.config.work_time ? t.getTaskCalendar(N) : t;\n          for (M[Q.id] = {}; H < O; ) {\n            const J = M[Q.id], B = H.valueOf();\n            H = t.date.add(H, C, E), J[B] !== !1 && (D[B] || (D[B] = { tasks: [], assignments: [] }), D[B].tasks.push(N), T && D[B].assignments.push(A));\n          }\n        }\n        return D;\n      }(h, c, g);\n      const y = c.unit, v = c.step, b = [];\n      let _, m, f, k, x;\n      const $ = u.$getConfig();\n      for (let w = 0; w < c.trace_x.length; w++) _ = new Date(c.trace_x[w]), m = t.date.add(_, v, y), x = p[_.valueOf()] || {}, f = x.tasks || [], k = x.assignments || [], f.length || $.resource_render_empty_cells ? b.push({ start_date: _, end_date: m, tasks: f, assignments: k }) : b.push(null);\n      return b;\n    }(n, i, a, r), o;\n  };\n}\nconst La = { init: function(t, e) {\n  var n = t.$services.getService(\"dnd\");\n  if (e.$config.bind && t.getDatastore(e.$config.bind)) {\n    var i = new n(e.$grid_data, { updates_per_second: 60 });\n    t.defined(e.$getConfig().dnd_sensitivity) && (i.config.sensitivity = e.$getConfig().dnd_sensitivity), i.attachEvent(\"onBeforeDragStart\", t.bind(function(o, l) {\n      var d = a(l);\n      if (!d || (t.hideQuickInfo && t.hideQuickInfo(), ct(l.target, \".gantt_grid_editor_placeholder\"))) return !1;\n      var c = d.getAttribute(e.$config.item_attribute);\n      if (s(c)) return !1;\n      var u = r().getItem(c);\n      return !t.isReadonly(u) && (i.config.initial_open_state = u.$open, !!t.callEvent(\"onRowDragStart\", [c, l.target || l.srcElement, l]) && void 0);\n    }, t)), i.attachEvent(\"onAfterDragStart\", t.bind(function(o, l) {\n      var d = a(l);\n      i.config.marker.innerHTML = d.outerHTML;\n      var c = i.config.marker.firstChild;\n      c && (c.style.position = \"static\"), i.config.id = d.getAttribute(e.$config.item_attribute);\n      var u = r(), h = u.getItem(i.config.id);\n      i.config.index = u.getBranchIndex(i.config.id), i.config.parent = h.parent, h.$open = !1, h.$transparent = !0, this.refreshData();\n    }, t)), i.lastTaskOfLevel = function(o) {\n      for (var l = null, d = r().getItems(), c = 0, u = d.length; c < u; c++) d[c].$level == o && (l = d[c]);\n      return l ? l.id : null;\n    }, i._getGridPos = t.bind(function(o) {\n      var l = V(e.$grid_data), d = l.x + e.$grid.scrollLeft, c = o.pos.y - 10, u = e.getItemHeight(i.config.id);\n      c < l.y && (c = l.y);\n      var h = e.getTotalHeight();\n      c > l.y + h - u && (c = l.y + h - u);\n      const g = l.y + l.height;\n      return c > g - u && (c = g - u), l.x = d, l.y = c, l;\n    }, t), i._getTargetY = t.bind(function(o) {\n      var l = V(e.$grid_data), d = e.$state.scrollTop || 0, c = t.$grid_data.getBoundingClientRect().height + d, u = o.pageY - l.y + d;\n      return u > c ? u = c : u < d && (u = d), u;\n    }, t), i._getTaskByY = t.bind(function(o, l) {\n      var d = r();\n      o = o || 0;\n      var c = e.getItemIndexByTopPosition(o);\n      return (c = l < c ? c - 1 : c) > d.countVisible() - 1 ? null : d.getIdByIndex(c);\n    }, t), i.attachEvent(\"onDragMove\", t.bind(function(o, l) {\n      var d = t.$grid_data.getBoundingClientRect(), c = d.height + d.y + (e.$state.scrollTop || 0) + window.scrollY, u = i.config, h = i._getGridPos(l);\n      t._waiAria.reorderMarkerAttr(u.marker);\n      var g = e.$getConfig(), p = r();\n      h.y < c ? u.marker.style.top = h.y + \"px\" : u.marker.style.top = c + \"px\", u.marker.style.left = h.x + 10 + \"px\";\n      const y = V(t.$root);\n      h.width > y.width && (u.marker.style.width = y.width - 10 - 2 + \"px\", u.marker.style.overflow = \"hidden\");\n      var v = p.getItem(i.config.id), b = i._getTargetY(l), _ = i._getTaskByY(b, p.getIndexById(v.id));\n      function m(D, M) {\n        return !p.isChildOf(f.id, M.id) && (D.$level == M.$level || g.order_branch_free);\n      }\n      if (p.exists(_) || (_ = i.lastTaskOfLevel(g.order_branch_free ? v.$level : 0)) == i.config.id && (_ = null), p.exists(_)) {\n        var f = p.getItem(_), k = e.getItemTop(f.id), x = e.getItemHeight(f.id);\n        if (k + x / 2 < b) {\n          var $ = p.getIndexById(f.id), w = p.getNext(f.id), S = p.getItem(w);\n          if (s(w)) {\n            var T = p.getPrev(S.id);\n            S = p.getItem(T);\n          }\n          if (S) {\n            if (S.id == v.id) return g.order_branch_free && p.isChildOf(v.id, f.id) && p.getChildren(f.id).length == 1 ? void p.move(v.id, p.getBranchIndex(f.id) + 1, p.getParent(f.id)) : void 0;\n            f = S;\n          } else if (w = p.getIdByIndex($), S = p.getItem(w), s(w) && (T = p.getPrev(S.id), S = p.getItem(T)), m(S, v) && S.id != v.id) return void p.move(v.id, -1, p.getParent(S.id));\n        } else if (g.order_branch_free && f.id != v.id && m(f, v) && !s(f.id)) {\n          if (!p.hasChild(f.id)) return f.$open = !0, void p.move(v.id, -1, f.id);\n          if (p.getIndexById(f.id) || x / 3 < b) return;\n        }\n        $ = p.getIndexById(f.id), T = p.getIdByIndex($ - 1);\n        for (var E = p.getItem(T), C = 1; (!E || E.id == f.id) && $ - C >= 0; ) T = p.getIdByIndex($ - C), E = p.getItem(T), C++;\n        if (v.id == f.id || s(f.id)) return;\n        m(f, v) && v.id != f.id ? p.move(v.id, 0, 0, f.id) : f.$level != v.$level - 1 || p.getChildren(f.id).length ? E && m(E, v) && v.id != E.id && p.move(v.id, -1, p.getParent(E.id)) : p.move(v.id, 0, f.id);\n      }\n      return !0;\n    }, t)), i.attachEvent(\"onDragEnd\", t.bind(function() {\n      var o = r(), l = o.getItem(i.config.id);\n      l.$transparent = !1, l.$open = i.config.initial_open_state, this.callEvent(\"onBeforeRowDragEnd\", [i.config.id, i.config.parent, i.config.index]) === !1 ? (o.move(i.config.id, i.config.index, i.config.parent), l.$drop_target = null) : this.callEvent(\"onRowDragEnd\", [i.config.id, l.$drop_target]), t.render(), this.refreshData();\n    }, t));\n  }\n  function a(o) {\n    return et(o, e.$config.item_attribute);\n  }\n  function r() {\n    return t.getDatastore(e.$config.bind);\n  }\n  function s(o) {\n    return Rt(o, t, r());\n  }\n} }, K = { createDropTargetObject: function(t) {\n  var e = { targetParent: null, targetIndex: 0, targetId: null, child: !1, nextSibling: !1, prevSibling: !1 };\n  return t && P(e, t, !0), e;\n}, nextSiblingTarget: function(t, e, n) {\n  var i = this.createDropTargetObject();\n  return i.targetId = e, i.nextSibling = !0, i.targetParent = n.getParent(i.targetId), i.targetIndex = n.getBranchIndex(i.targetId), (n.getParent(t) != i.targetParent || i.targetIndex < n.getBranchIndex(t)) && (i.targetIndex += 1), i;\n}, prevSiblingTarget: function(t, e, n) {\n  var i = this.createDropTargetObject();\n  return i.targetId = e, i.prevSibling = !0, i.targetParent = n.getParent(i.targetId), i.targetIndex = n.getBranchIndex(i.targetId), n.getParent(t) == i.targetParent && i.targetIndex > n.getBranchIndex(t) && (i.targetIndex -= 1), i;\n}, firstChildTarget: function(t, e, n) {\n  var i = this.createDropTargetObject();\n  return i.targetId = e, i.targetParent = i.targetId, i.targetIndex = 0, i.child = !0, i;\n}, lastChildTarget: function(t, e, n) {\n  var i = n.getChildren(e), a = this.createDropTargetObject();\n  return a.targetId = i[i.length - 1], a.targetParent = e, a.targetIndex = i.length, a.nextSibling = !0, a;\n} };\nfunction xn(t, e, n, i, a) {\n  for (var r = e; i.exists(r); ) {\n    var s = i.calculateItemLevel(i.getItem(r));\n    if ((s === n || s === n - 1) && i.getBranchIndex(r) > -1) break;\n    r = a ? i.getPrev(r) : i.getNext(r);\n  }\n  return i.exists(r) ? i.calculateItemLevel(i.getItem(r)) === n ? a ? K.nextSiblingTarget(t, r, i) : K.prevSiblingTarget(t, r, i) : K.firstChildTarget(t, r, i) : null;\n}\nfunction le(t, e, n, i) {\n  return xn(t, e, n, i, !0);\n}\nfunction Ge(t, e, n, i) {\n  return xn(t, e, n, i, !1);\n}\nfunction Ye(t, e, n, i, a, r) {\n  var s;\n  if (e !== a.$getRootId()) {\n    var o = a.getItem(e), l = a.calculateItemLevel(o);\n    if (l === r) {\n      var d = a.getPrevSibling(e);\n      n < 0.5 && !d ? s = K.prevSiblingTarget(t, e, a) : (n < 0.5 && (e = d), s = K.nextSiblingTarget(t, e, a));\n    } else if (l > r) a.eachParent(function(p) {\n      a.calculateItemLevel(p) === r && (e = p.id);\n    }, o), s = le(t, e, r, a);\n    else {\n      var c = le(t, e, r, a), u = Ge(t, e, r, a);\n      s = n < 0.5 ? c : u;\n    }\n  } else {\n    var h = a.$getRootId(), g = a.getChildren(h);\n    s = K.createDropTargetObject(), s = g.length && i >= 0 ? le(t, function(p) {\n      for (var y = p.getNext(); p.exists(y); ) {\n        var v = p.getNext(y);\n        if (!p.exists(v)) return y;\n        y = v;\n      }\n      return null;\n    }(a), r, a) : Ge(t, h, r, a);\n  }\n  return s;\n}\nfunction Je(t, e) {\n  var n = V(e.$grid_data);\n  return t.x += n.x + e.$grid.scrollLeft, t.y += n.y - e.$grid_data.scrollTop, t;\n}\nfunction de(t, e, n = 0) {\n  const i = V(t.$root);\n  return e > i.width && (e = i.width - n - 2), e;\n}\nconst Ke = { removeLineHighlight: function(t) {\n  t.markerLine && t.markerLine.parentNode && t.markerLine.parentNode.removeChild(t.markerLine), t.markerLine = null;\n}, highlightPosition: function(t, e, n) {\n  var i = function(r, s) {\n    var o = V(s.$grid_data), l = rt(r, s.$grid_data), d = o.x + s.$grid.scrollLeft, c = l.y - 10, u = s.getItemHeight(r.targetId);\n    c < o.y && (c = o.y);\n    var h = s.getTotalHeight();\n    return c > o.y + h - u && (c = o.y + h - u), o.x = d, o.y = c, o.width = de(s.$gantt, o.width, 9), o;\n  }(t, n);\n  e.marker.style.left = i.x + 9 + \"px\", e.marker.style.width = i.width + \"px\", e.marker.style.overflow = \"hidden\";\n  var a = e.markerLine;\n  a || ((a = document.createElement(\"div\")).className = \"gantt_drag_marker gantt_grid_dnd_marker\", a.innerHTML = \"<div class='gantt_grid_dnd_marker_line'></div>\", a.style.pointerEvents = \"none\"), t.child ? function(r, s, o) {\n    var l = r.targetParent, d = Je({ x: 0, y: o.getItemTop(l) }, o), c = o.$grid_data.getBoundingClientRect().bottom + window.scrollY;\n    let u = de(o.$gantt, o.$grid_data.offsetWidth);\n    s.innerHTML = \"<div class='gantt_grid_dnd_marker_folder'></div>\", s.style.width = u + \"px\", s.style.top = d.y + \"px\", s.style.left = d.x + \"px\", s.style.height = o.getItemHeight(l) + \"px\", d.y > c && (s.style.top = c + \"px\");\n  }(t, a, n) : function(r, s, o) {\n    var l = function(u, h) {\n      var g = h.$config.rowStore, p = { x: 0, y: 0 }, y = h.$grid_data.querySelector(\".gantt_tree_indent\"), v = 15, b = 0;\n      y && (v = y.offsetWidth);\n      var _ = 40;\n      if (u.targetId !== g.$getRootId()) {\n        var m = h.getItemTop(u.targetId), f = h.getItemHeight(u.targetId);\n        if (b = g.exists(u.targetId) ? g.calculateItemLevel(g.getItem(u.targetId)) : 0, u.prevSibling) p.y = m;\n        else if (u.nextSibling) {\n          var k = 0;\n          g.eachItem(function(x) {\n            g.getIndexById(x.id) !== -1 && k++;\n          }, u.targetId), p.y = m + f + k * f;\n        } else p.y = m + f, b += 1;\n      }\n      return p.x = _ + b * v, p.width = de(h.$gantt, Math.max(h.$grid_data.offsetWidth - p.x, 0), p.x), Je(p, h);\n    }(r, o), d = o.$grid_data.getBoundingClientRect().bottom + window.scrollY;\n    s.innerHTML = \"<div class='gantt_grid_dnd_marker_line'></div>\", s.style.left = l.x + \"px\", s.style.height = \"4px\";\n    var c = l.y - 2;\n    s.style.top = c + \"px\", s.style.width = l.width + \"px\", c > d && (s.style.top = d + \"px\");\n  }(t, a, n), e.markerLine || (document.body.appendChild(a), e.markerLine = a);\n} }, Pa = { init: function(t, e) {\n  var n = t.$services.getService(\"dnd\");\n  if (e.$config.bind && t.getDatastore(e.$config.bind)) {\n    var i = new n(e.$grid_data, { updates_per_second: 60 });\n    t.defined(e.$getConfig().dnd_sensitivity) && (i.config.sensitivity = e.$getConfig().dnd_sensitivity), i.attachEvent(\"onBeforeDragStart\", t.bind(function(o, l) {\n      var d = a(l);\n      if (!d || (t.hideQuickInfo && t.hideQuickInfo(), ct(l.target, \".gantt_grid_editor_placeholder\"))) return !1;\n      var c = d.getAttribute(e.$config.item_attribute), u = e.$config.rowStore.getItem(c);\n      return !t.isReadonly(u) && !r(c) && (i.config.initial_open_state = u.$open, !!t.callEvent(\"onRowDragStart\", [c, l.target || l.srcElement, l]) && void 0);\n    }, t)), i.attachEvent(\"onAfterDragStart\", t.bind(function(o, l) {\n      var d = a(l);\n      i.config.marker.innerHTML = d.outerHTML;\n      var c = i.config.marker.firstChild;\n      c && (i.config.marker.style.opacity = 0.4, c.style.position = \"static\", c.style.pointerEvents = \"none\"), i.config.id = d.getAttribute(e.$config.item_attribute);\n      var u = e.$config.rowStore, h = u.getItem(i.config.id);\n      i.config.level = u.calculateItemLevel(h), i.config.drop_target = K.createDropTargetObject({ targetParent: u.getParent(h.id), targetIndex: u.getBranchIndex(h.id), targetId: h.id, nextSibling: !0 }), h.$open = !1, h.$transparent = !0, this.refreshData();\n    }, t)), i.attachEvent(\"onDragMove\", t.bind(function(o, l) {\n      var d = s(l);\n      return d && t.callEvent(\"onBeforeRowDragMove\", [i.config.id, d.targetParent, d.targetIndex]) !== !1 || (d = K.createDropTargetObject(i.config.drop_target)), Ke.highlightPosition(d, i.config, e), i.config.drop_target = d, t._waiAria.reorderMarkerAttr(i.config.marker), this.callEvent(\"onRowDragMove\", [i.config.id, d.targetParent, d.targetIndex]), !0;\n    }, t)), i.attachEvent(\"onDragEnd\", t.bind(function() {\n      var o = e.$config.rowStore, l = o.getItem(i.config.id);\n      Ke.removeLineHighlight(i.config), l.$transparent = !1, l.$open = i.config.initial_open_state;\n      var d = i.config.drop_target;\n      this.callEvent(\"onBeforeRowDragEnd\", [i.config.id, d.targetParent, d.targetIndex]) === !1 ? l.$drop_target = null : (o.move(i.config.id, d.targetIndex, d.targetParent), t.render(), this.callEvent(\"onRowDragEnd\", [i.config.id, d.targetParent, d.targetIndex])), o.refresh(l.id);\n    }, t));\n  }\n  function a(o) {\n    return et(o, e.$config.item_attribute);\n  }\n  function r(o) {\n    return Rt(o, t, t.getDatastore(e.$config.bind));\n  }\n  function s(o) {\n    var l, d = function(p) {\n      var y = rt(p, e.$grid_data).y, v = e.$config.rowStore;\n      document.doctype || (y += window.scrollY), y = y || 0;\n      var b = e.$state.scrollTop || 0, _ = t.$grid_data.getBoundingClientRect().height + b + window.scrollY, m = b, f = e.getItemIndexByTopPosition(e.$state.scrollTop);\n      if (v.exists(f) || (f = v.countVisible() - 1), f < 0) return v.$getRootId();\n      var k = v.getIdByIndex(f), x = e.$state.scrollTop / e.getItemHeight(k), $ = x - Math.floor(x);\n      $ > 0.1 && $ < 0.9 && (_ -= e.getItemHeight(k) * $, m += e.getItemHeight(k) * (1 - $));\n      const w = V(e.$grid_data), S = w.y + w.height, T = i.config.marker.offsetHeight;\n      y + T + window.scrollY >= _ && (i.config.marker.style.top = S - T + \"px\"), y >= _ ? y = _ : y <= m && (y = m, i.config.marker.style.top = w.y + \"px\");\n      var E = e.getItemIndexByTopPosition(y);\n      if (E > v.countVisible() - 1 || E < 0) return v.$getRootId();\n      var C = v.getIdByIndex(E);\n      return r(C) ? v.getPrevSibling(C) : v.getIdByIndex(E);\n    }(o), c = null, u = e.$config.rowStore, h = !e.$getConfig().order_branch_free, g = rt(o, e.$grid_data).y;\n    return document.doctype || (g += window.scrollY), d !== u.$getRootId() && (c = (g - e.getItemTop(d)) / e.getItemHeight(d)), h ? (l = Ye(i.config.id, d, c, g, u, i.config.level)) && l.targetParent && r(l.targetParent) && (d = u.getPrevSibling(l.targetParent), l = Ye(i.config.id, d, c, g, u, i.config.level)) : l = function(p, y, v, b, _) {\n      var m;\n      if (y !== _.$getRootId()) m = v < 0.25 ? K.prevSiblingTarget(p, y, _) : !(v > 0.6) || _.hasChild(y) && _.getItem(y).$open ? K.firstChildTarget(p, y, _) : K.nextSiblingTarget(p, y, _);\n      else {\n        var f = _.$getRootId();\n        m = _.hasChild(f) && b >= 0 ? K.lastChildTarget(p, f, _) : K.firstChildTarget(p, f, _);\n      }\n      return m;\n    }(i.config.id, d, c, g, u), l;\n  }\n} };\nvar Ra = function(t) {\n  return { onCreated: function(e) {\n    e.$config = P(e.$config, { bind: \"task\" }), e.$config.id == \"grid\" && (this.extendGantt(e), t.ext.inlineEditors = t.ext._inlineEditors.createEditors(e), t.ext.inlineEditors.init()), this._mouseDelegates = Te(t);\n  }, onInitialized: function(e) {\n    var n = e.$getConfig();\n    n.order_branch && (n.order_branch == \"marker\" ? Pa.init(e.$gantt, e) : La.init(e.$gantt, e)), this.initEvents(e, t), e.$config.id == \"grid\" && this.extendDom(e);\n  }, onDestroyed: function(e) {\n    e.$config.id == \"grid\" && t.ext.inlineEditors.detachStore(), this.clearEvents(e, t);\n  }, initEvents: function(e, n) {\n    this._mouseDelegates.delegate(\"click\", \"gantt_row\", n.bind(function(i, a, r) {\n      const s = e.$getConfig();\n      if (a !== null) {\n        const o = this.getTask(a);\n        if (s.scroll_on_click) {\n          const l = !n._is_icon_open_click(i), d = n.$ui.getView(\"timeline\");\n          l && d && this.showDate(o.start_date);\n        }\n        n.callEvent(\"onTaskRowClick\", [a, r]);\n      }\n    }, n), e.$grid), this._mouseDelegates.delegate(\"click\", \"gantt_grid_head_cell\", n.bind(function(i, a, r) {\n      var s = r.getAttribute(\"data-column-id\");\n      if (n.callEvent(\"onGridHeaderClick\", [s, i])) {\n        var o = e.$getConfig();\n        if (s != \"add\") {\n          if (o.sort && s) {\n            for (var l, d = s, c = 0; c < o.columns.length; c++) if (o.columns[c].name == s) {\n              l = o.columns[c];\n              break;\n            }\n            if (l && l.sort !== void 0 && l.sort !== !0 && !(d = l.sort)) return;\n            var u = this._sort && this._sort.direction && this._sort.name == s ? this._sort.direction : \"desc\";\n            u = u == \"desc\" ? \"asc\" : \"desc\", this._sort = { name: s, direction: u }, this.sort(d, u == \"desc\");\n          }\n        } else n.$services.getService(\"mouseEvents\").callHandler(\"click\", \"gantt_add\", e.$grid, [i, o.root_id]);\n      }\n    }, n), e.$grid), this._mouseDelegates.delegate(\"click\", \"gantt_add\", n.bind(function(i, a, r) {\n      if (!e.$getConfig().readonly) return this.createTask({}, a || n.config.root_id), !1;\n    }, n), e.$grid);\n  }, clearEvents: function(e, n) {\n    this._mouseDelegates.destructor(), this._mouseDelegates = null;\n  }, extendDom: function(e) {\n    t.$grid = e.$grid, t.$grid_scale = e.$grid_scale, t.$grid_data = e.$grid_data;\n  }, extendGantt: function(e) {\n    t.getGridColumns = t.bind(e.getGridColumns, e), e.attachEvent(\"onColumnResizeStart\", function() {\n      return t.callEvent(\"onColumnResizeStart\", arguments);\n    }), e.attachEvent(\"onColumnResize\", function() {\n      return t.callEvent(\"onColumnResize\", arguments);\n    }), e.attachEvent(\"onColumnResizeEnd\", function() {\n      return t.callEvent(\"onColumnResizeEnd\", arguments);\n    }), e.attachEvent(\"onColumnResizeComplete\", function(n, i) {\n      t.config.grid_width = i;\n    }), e.attachEvent(\"onBeforeRowResize\", function() {\n      return t.callEvent(\"onBeforeRowResize\", arguments);\n    }), e.attachEvent(\"onRowResize\", function() {\n      return t.callEvent(\"onRowResize\", arguments);\n    }), e.attachEvent(\"onBeforeRowResizeEnd\", function() {\n      return t.callEvent(\"onBeforeRowResizeEnd\", arguments);\n    }), e.attachEvent(\"onAfterRowResize\", function() {\n      return t.callEvent(\"onAfterRowResize\", arguments);\n    });\n  } };\n};\nconst Ha = { createTaskDND: function() {\n  var t;\n  return { extend: function(e) {\n    e.roundTaskDates = function(n) {\n      t.round_task_dates(n);\n    };\n  }, init: function(e, n) {\n    return t = function(i, a) {\n      var r = a.$services;\n      return { drag: null, dragMultiple: {}, _events: { before_start: {}, before_finish: {}, after_finish: {} }, _handlers: {}, init: function() {\n        this._domEvents = a._createDomEventScope(), this.clear_drag_state();\n        var s = a.config.drag_mode;\n        this.set_actions(), r.getService(\"state\").registerProvider(\"tasksDnd\", R(function() {\n          return { drag_id: this.drag ? this.drag.id : void 0, drag_mode: this.drag ? this.drag.mode : void 0, drag_from_start: this.drag ? this.drag.left : void 0 };\n        }, this));\n        var o = { before_start: \"onBeforeTaskDrag\", before_finish: \"onBeforeTaskChanged\", after_finish: \"onAfterTaskDrag\" };\n        for (var l in this._events) for (var d in s) this._events[l][d] = o[l];\n        this._handlers[s.move] = this._move, this._handlers[s.resize] = this._resize, this._handlers[s.progress] = this._resize_progress;\n      }, set_actions: function() {\n        var s = i.$task_data;\n        this._domEvents.attach(s, \"mousemove\", a.bind(function(o) {\n          this.on_mouse_move(o);\n        }, this)), this._domEvents.attach(s, \"mousedown\", a.bind(function(o) {\n          this.on_mouse_down(o);\n        }, this)), this._domEvents.attach(document.body, \"mouseup\", a.bind(function(o) {\n          this.on_mouse_up(o);\n        }, this));\n      }, clear_drag_state: function() {\n        this.drag = { id: null, mode: null, pos: null, start_x: null, start_y: null, obj: null, left: null }, this.dragMultiple = {};\n      }, _resize: function(s, o, l) {\n        var d = i.$getConfig(), c = this._drag_task_coords(s, l);\n        l.left ? (s.start_date = a.dateFromPos(c.start + o), s.start_date || (s.start_date = new Date(a.getState().min_date))) : (s.end_date = a.dateFromPos(c.end + o), s.end_date || (s.end_date = new Date(a.getState().max_date)));\n        var u = this._calculateMinDuration(d.min_duration, d.duration_unit);\n        s.end_date - s.start_date < d.min_duration && (l.left ? s.start_date = a.calculateEndDate(s.end_date, -u, d.duration_unit, s) : s.end_date = a.calculateEndDate(s.start_date, u, d.duration_unit, s)), a._init_task_timing(s);\n      }, _calculateMinDuration: function(s, o) {\n        return Math.ceil(s / { minute: 6e4, hour: 36e5, day: 864e5, week: 6048e5, month: 24192e5, year: 31356e6 }[o]);\n      }, _resize_progress: function(s, o, l) {\n        var d = this._drag_task_coords(s, l), c = i.$getConfig().rtl ? d.start - l.pos.x : l.pos.x - d.start, u = Math.max(0, c);\n        s.progress = Math.min(1, u / Math.abs(d.end - d.start));\n      }, _find_max_shift: function(s, o) {\n        var l;\n        for (var d in s) {\n          var c = s[d], u = a.getTask(c.id);\n          if (!u.unscheduled) {\n            var h = this._drag_task_coords(u, c), g = a.posFromDate(new Date(a.getState().min_date)), p = a.posFromDate(new Date(a.getState().max_date));\n            if (h.end + o > p) {\n              var y = p - h.end;\n              (y < l || l === void 0) && (l = y);\n            } else if (h.start + o < g) {\n              var v = g - h.start;\n              (v > l || l === void 0) && (l = v);\n            }\n          }\n        }\n        return l;\n      }, _move: function(s, o, l, d) {\n        var c = this._drag_task_coords(s, l), u = null, h = null;\n        d ? (u = new Date(+l.obj.start_date + d), h = new Date(+l.obj.end_date + d)) : (u = a.dateFromPos(c.start + o), h = a.dateFromPos(c.end + o)), u ? h ? (s.start_date = u, s.end_date = h) : (s.end_date = new Date(a.getState().max_date), s.start_date = a.dateFromPos(a.posFromDate(s.end_date) - (c.end - c.start))) : (s.start_date = new Date(a.getState().min_date), s.end_date = a.dateFromPos(a.posFromDate(s.start_date) + (c.end - c.start)));\n      }, _drag_task_coords: function(s, o) {\n        return { start: o.obj_s_x = o.obj_s_x || a.posFromDate(s.start_date), end: o.obj_e_x = o.obj_e_x || a.posFromDate(s.end_date) };\n      }, _mouse_position_change: function(s, o) {\n        var l = s.x - o.x, d = s.y - o.y;\n        return Math.sqrt(l * l + d * d);\n      }, _is_number: function(s) {\n        return !isNaN(parseFloat(s)) && isFinite(s);\n      }, on_mouse_move: function(s) {\n        if (this.drag.start_drag) {\n          var o = rt(s, a.$task_data), l = this.drag.start_drag.start_x, d = this.drag.start_drag.start_y;\n          (Date.now() - this.drag.timestamp > 50 || this._is_number(l) && this._is_number(d) && this._mouse_position_change({ x: l, y: d }, o) > 20) && this._start_dnd(s);\n        }\n        if (this.drag.mode) {\n          if (!dn(this, 40)) return;\n          this._update_on_move(s);\n        }\n      }, _update_item_on_move: function(s, o, l, d, c, u) {\n        var h = a.getTask(o), g = a.mixin({}, h), p = a.mixin({}, h);\n        this._handlers[l].apply(this, [p, s, d, u]), a.mixin(h, p, !0), a.callEvent(\"onTaskDrag\", [h.id, l, p, g, c]), a.mixin(h, p, !0), a.refreshTask(o);\n      }, _update_on_move: function(s) {\n        var o = this.drag, l = i.$getConfig();\n        if (o.mode) {\n          var d = rt(s, i.$task_data);\n          if (o.pos && o.pos.x == d.x) return;\n          o.pos = d;\n          var c = a.dateFromPos(d.x);\n          if (!c || isNaN(c.getTime())) return;\n          var u = d.x - o.start_x, h = a.getTask(o.id);\n          if (this._handlers[o.mode]) {\n            if (o.mode === l.drag_mode.move) {\n              var g = {};\n              this._isMultiselect() && a.getSelectedTasks().indexOf(o.id) >= 0 && (g = this.dragMultiple);\n              var p = !1;\n              if (a.isSummaryTask(h) && a.config.drag_project) {\n                var y = {};\n                y[o.id] = q(o), p = !0, g = P(y, this.dragMultiple);\n              }\n              var v = this._find_max_shift(g, u);\n              let m;\n              if (v !== void 0 && (u = v), this._update_item_on_move(u, o.id, o.mode, o, s), v === void 0) {\n                const f = a.posFromDate(o.obj.start_date), k = a.posFromDate(o.obj.end_date);\n                if (o.handle_offset === void 0) {\n                  const $ = k - f, w = o.start_x - f;\n                  o.handle_offset = w / $;\n                }\n                let x = f + Math.abs(k - f) * o.handle_offset;\n                m = c - a.dateFromPos(x);\n              }\n              for (var b in g) {\n                var _ = g[b];\n                p && _.id != o.id && (a._bulk_dnd = !0), this._update_item_on_move(u, _.id, _.mode, _, s, m);\n              }\n              a._bulk_dnd = !1;\n            } else this._update_item_on_move(u, o.id, o.mode, o, s);\n            a._update_parents(o.id);\n          }\n        }\n      }, on_mouse_down: function(s, o) {\n        if (s.button != 2 || s.button === void 0) {\n          var l = i.$getConfig(), d = a.locate(s), c = null;\n          if (a.isTaskExists(d) && (c = a.getTask(d)), !a.isReadonly(c) && !this.drag.mode) {\n            this.clear_drag_state();\n            var u = X(o = o || s.target || s.srcElement), h = this._get_drag_mode(u, o);\n            if (!u || !h) return o.parentNode ? this.on_mouse_down(s, o.parentNode) : void 0;\n            if (h) if (h.mode && h.mode != l.drag_mode.ignore && l[\"drag_\" + h.mode]) {\n              if (d = a.locate(o), c = a.copy(a.getTask(d) || {}), a.isReadonly(c)) return this.clear_drag_state(), !1;\n              if (a.isSummaryTask(c) && c.auto_scheduling !== !1 && !l.drag_project && h.mode != l.drag_mode.progress) return void this.clear_drag_state();\n              h.id = d;\n              var g = rt(s, a.$task_data);\n              h.start_x = g.x, h.start_y = g.y, h.obj = c, this.drag.start_drag = h, this.drag.timestamp = Date.now();\n            } else this.clear_drag_state();\n            else if (a.checkEvent(\"onMouseDown\") && a.callEvent(\"onMouseDown\", [u.split(\" \")[0]]) && o.parentNode) return this.on_mouse_down(s, o.parentNode);\n          }\n        }\n      }, _fix_dnd_scale_time: function(s, o) {\n        var l = i.$getConfig(), d = a.getScale().unit, c = a.getScale().step;\n        function u(h) {\n          if (a.config.correct_work_time) {\n            var g = i.$getConfig();\n            a.isWorkTime(h.start_date, void 0, h) || (h.start_date = a.calculateEndDate({ start_date: h.start_date, duration: -1, unit: g.duration_unit, task: h }));\n          }\n        }\n        l.round_dnd_dates || (d = \"minute\", c = l.time_step), o.mode == l.drag_mode.resize ? o.left ? (s.start_date = a.roundDate({ date: s.start_date, unit: d, step: c }), u(s)) : (s.end_date = a.roundDate({ date: s.end_date, unit: d, step: c }), function(h) {\n          if (a.config.correct_work_time) {\n            var g = i.$getConfig();\n            a.isWorkTime(new Date(h.end_date - 1), void 0, h) || (h.end_date = a.calculateEndDate({ start_date: h.end_date, duration: 1, unit: g.duration_unit, task: h }));\n          }\n        }(s)) : o.mode == l.drag_mode.move && (s.start_date = a.roundDate({ date: s.start_date, unit: d, step: c }), u(s), s.end_date = a.calculateEndDate(s));\n      }, _fix_working_times: function(s, o) {\n        var l = i.$getConfig();\n        (o = o || { mode: l.drag_mode.move }).mode == l.drag_mode.resize ? o.left ? s.start_date = a.getClosestWorkTime({ date: s.start_date, dir: \"future\", task: s }) : s.end_date = a.getClosestWorkTime({ date: s.end_date, dir: \"past\", task: s }) : o.mode == l.drag_mode.move && a.correctTaskWorkTime(s);\n      }, _finalize_mouse_up: function(s, o, l, d) {\n        var c = a.getTask(s);\n        if (o.work_time && o.correct_work_time && this._fix_working_times(c, l), this._fix_dnd_scale_time(c, l), this._fireEvent(\"before_finish\", l.mode, [s, l.mode, a.copy(l.obj), d])) {\n          var u = s;\n          a._init_task_timing(c), this.clear_drag_state(), a.updateTask(c.id), this._fireEvent(\"after_finish\", l.mode, [u, l.mode, d]);\n        } else if (this.clear_drag_state(), s == l.id && (l.obj._dhx_changed = !1, a.mixin(c, l.obj, !0)), a.refreshTask(c.id), c.$level > 100) {\n          let h = !1;\n          a.eachParent(function(g) {\n            if (!h && g.type === a.config.types.project) {\n              const p = { start_date: g.start_date, end_date: g.end_date };\n              a.resetProjectDates(g), +p.start_date == +g.start_date && +p.end_date == +g.end_date || (h = !0);\n            }\n          }, c.id), h && a.refreshData();\n        } else a.eachParent(function(h) {\n          if (h.type === a.config.types.project) {\n            const g = { start_date: h.start_date, end_date: h.end_date };\n            a.resetProjectDates(h), +g.start_date == +h.start_date && +g.end_date == +h.end_date || a.refreshTask(h.id);\n          }\n        }, c.id);\n      }, on_mouse_up: function(s) {\n        var o = this.drag;\n        if (o.mode && o.id) {\n          var l = i.$getConfig(), d = a.getTask(o.id), c = this.dragMultiple, u = !1, h = 0;\n          o.mode === l.drag_mode.move && (a.isSummaryTask(d) && l.drag_project || this._isMultiselect()) && (u = !0, h = Object.keys(c).length);\n          var g = function() {\n            if (u) for (var p in c) c[p].id != o.id && this._finalize_mouse_up(c[p].id, l, c[p], s);\n            this._finalize_mouse_up(o.id, l, o, s);\n          };\n          u && h > 10 ? a.batchUpdate((function() {\n            g.call(this);\n          }).bind(this)) : g.call(this);\n        }\n        this.clear_drag_state();\n      }, _get_drag_mode: function(s, o) {\n        var l = i.$getConfig().drag_mode, d = { mode: null, left: null };\n        switch ((s || \"\").split(\" \")[0]) {\n          case \"gantt_task_line\":\n          case \"gantt_task_content\":\n            d.mode = l.move;\n            break;\n          case \"gantt_task_drag\":\n            d.mode = l.resize;\n            var c = o.getAttribute(\"data-bind-property\");\n            d.left = c == \"start_date\";\n            break;\n          case \"gantt_task_progress_drag\":\n            d.mode = l.progress;\n            break;\n          case \"gantt_link_control\":\n          case \"gantt_link_point\":\n            d.mode = l.ignore;\n            break;\n          default:\n            d = null;\n        }\n        return d;\n      }, _start_dnd: function(s) {\n        var o = this.drag = this.drag.start_drag;\n        delete o.start_drag;\n        var l = i.$getConfig(), d = o.id;\n        if (l[\"drag_\" + o.mode] && a.callEvent(\"onBeforeDrag\", [d, o.mode, s]) && this._fireEvent(\"before_start\", o.mode, [d, o.mode, s])) {\n          delete o.start_drag;\n          var c = a.getTask(d);\n          if (a.isReadonly(c)) return void this.clear_drag_state();\n          if (this._isMultiselect()) {\n            var u = a.getSelectedTasks();\n            u.indexOf(o.id) >= 0 && kt(u, a.bind(function(h) {\n              var g = a.getTask(h);\n              a.isSummaryTask(g) && a.config.drag_project && o.mode == l.drag_mode.move && this._addSubtasksToDragMultiple(g.id), this.dragMultiple[h] = a.mixin({ id: g.id, obj: a.copy(g) }, this.drag);\n            }, this));\n          }\n          a.isSummaryTask(c) && a.config.drag_project && o.mode == l.drag_mode.move && this._addSubtasksToDragMultiple(c.id), a.callEvent(\"onTaskDragStart\", []);\n        } else this.clear_drag_state();\n      }, _fireEvent: function(s, o, l) {\n        a.assert(this._events[s], \"Invalid stage:{\" + s + \"}\");\n        var d = this._events[s][o];\n        return a.assert(d, \"Unknown after drop mode:{\" + o + \"}\"), a.assert(l, \"Invalid event arguments\"), !a.checkEvent(d) || a.callEvent(d, l);\n      }, round_task_dates: function(s) {\n        var o = this.drag, l = i.$getConfig();\n        o || (o = { mode: l.drag_mode.move }), this._fix_dnd_scale_time(s, o);\n      }, destructor: function() {\n        this._domEvents.detachAll();\n      }, _isMultiselect: function() {\n        return a.config.drag_multiple && !!(a.getSelectedTasks && a.getSelectedTasks().length > 0);\n      }, _addSubtasksToDragMultiple: function(s) {\n        a.eachTask(function(o) {\n          this.dragMultiple[o.id] = a.mixin({ id: o.id, obj: a.copy(o) }, this.drag);\n        }, s, this);\n      } };\n    }(e, n), e._tasks_dnd = t, t.init(n);\n  }, destructor: function() {\n    t && (t.destructor(), t = null);\n  } };\n} };\nvar Oa = function(t, e) {\n  var n, i, a, r, s;\n  function o() {\n    return { link_source_id: r, link_target_id: i, link_from_start: s, link_to_start: a, link_landing_area: n };\n  }\n  var l = e.$services, d = l.getService(\"state\"), c = l.getService(\"dnd\");\n  d.registerProvider(\"linksDnD\", o);\n  var u = \"gantt_link_point\", h = \"gantt_link_control\", g = new c(t.$task_bars, { sensitivity: 0, updates_per_second: 60, mousemoveContainer: e.$root, selector: \".\" + u, preventDefault: !0 });\n  function p(m, f) {\n    var k, x = g.getPosition(m), $ = function(M) {\n      var I = 0, A = 0;\n      return M && (I = M.offsetWidth || 0, A = M.offsetHeight || 0), { width: I, height: A };\n    }(f), w = { right: (k = e.$root).offsetWidth, bottom: k.offsetHeight }, S = e.config.tooltip_offset_x || 10, T = e.config.tooltip_offset_y || 10, E = e.config.scroll_size || 18, C = e.$container.getBoundingClientRect().y + window.scrollY, D = { y: x.y + T, x: x.x + S, bottom: x.y + $.height + T + E, right: x.x + $.width + S + E };\n    return D.bottom > w.bottom + C && (D.y = w.bottom + C - $.height - T), D.right > w.right && (D.x = w.right - $.width - S), D;\n  }\n  function y(m) {\n    var f = o();\n    f.link_source_id && f.link_target_id && e.isLinkAllowed(f.link_source_id, f.link_target_id, f.link_from_start, f.link_to_start);\n    var k = \"<div class='\" + e.templates.drag_link_class(f.link_source_id, f.link_from_start, f.link_target_id, f.link_to_start) + \"'>\" + e.templates.drag_link(f.link_source_id, f.link_from_start, f.link_target_id, f.link_to_start) + \"</div>\";\n    m.innerHTML = k;\n  }\n  function v() {\n    r = s = i = null, a = !0;\n  }\n  function b(m, f, k, x) {\n    var $ = function() {\n      return g._direction && g._direction.parentNode || (g._direction = document.createElement(\"div\"), t.$task_links.appendChild(g._direction)), g._direction;\n    }(), w = o(), S = [\"gantt_link_direction\"];\n    e.templates.link_direction_class && S.push(e.templates.link_direction_class(w.link_source_id, w.link_from_start, w.link_target_id, w.link_to_start));\n    var T = Math.sqrt(Math.pow(k - m, 2) + Math.pow(x - f, 2));\n    if (T = Math.max(0, T - 3)) {\n      $.className = S.join(\" \");\n      var E = (x - f) / (k - m), C = Math.atan(E);\n      _(m, k, f, x) == 2 ? C += Math.PI : _(m, k, f, x) == 3 && (C -= Math.PI);\n      var D = Math.sin(C), M = Math.cos(C), I = Math.round(f), A = Math.round(m), N = [\"-webkit-transform: rotate(\" + C + \"rad)\", \"-moz-transform: rotate(\" + C + \"rad)\", \"-ms-transform: rotate(\" + C + \"rad)\", \"-o-transform: rotate(\" + C + \"rad)\", \"transform: rotate(\" + C + \"rad)\", \"width:\" + Math.round(T) + \"px\"];\n      if (window.navigator.userAgent.indexOf(\"MSIE 8.0\") != -1) {\n        N.push('-ms-filter: \"' + function(G, j) {\n          return \"progid:DXImageTransform.Microsoft.Matrix(M11 = \" + j + \",M12 = -\" + G + \",M21 = \" + G + \",M22 = \" + j + \",SizingMethod = 'auto expand')\";\n        }(D, M) + '\"');\n        var L = Math.abs(Math.round(m - k)), O = Math.abs(Math.round(x - f));\n        switch (_(m, k, f, x)) {\n          case 1:\n            I -= O;\n            break;\n          case 2:\n            A -= L, I -= O;\n            break;\n          case 3:\n            A -= L;\n        }\n      }\n      N.push(\"top:\" + I + \"px\"), N.push(\"left:\" + A + \"px\"), $.style.cssText = N.join(\";\");\n    }\n  }\n  function _(m, f, k, x) {\n    return f >= m ? x <= k ? 1 : 4 : x <= k ? 2 : 3;\n  }\n  g.attachEvent(\"onBeforeDragStart\", e.bind(function(m, f) {\n    var k = f.target || f.srcElement;\n    if (v(), e.getState(\"tasksDnd\").drag_id) return !1;\n    if (pt(k, u)) {\n      pt(k, \"task_start_date\") && (s = !0);\n      var x = e.locate(f);\n      r = x;\n      var $ = e.getTask(x);\n      return e.isReadonly($) ? (v(), !1) : (this._dir_start = { x: g.config.original_element_sizes.x + g.config.original_element_sizes.width / 2, y: g.config.original_element_sizes.y + g.config.original_element_sizes.height / 2 }, !0);\n    }\n    return !1;\n  }, this)), g.attachEvent(\"onAfterDragStart\", e.bind(function(m, f) {\n    e.config.touch && e.refreshData(), y(g.config.marker);\n  }, this)), g.attachEvent(\"onDragMove\", e.bind(function(m, f) {\n    var k = g.config, x = p(f, k.marker);\n    (function(M, I) {\n      M.style.left = I.x + \"px\", M.style.top = I.y + \"px\";\n    })(k.marker, x);\n    var $ = !!pt(f, h), w = i, S = n, T = a, E = e.locate(f), C = !0;\n    if (Y(yt(f), e.$root) || ($ = !1, E = null), $ && (C = !pt(f, \"task_end_date\"), $ = !!E), i = E, n = $, a = C, $) {\n      const M = pt(f, h).querySelector(`.${u}`);\n      if (M) {\n        const I = en(M, t.$task_bg);\n        this._dir_end = { x: I.x + M.offsetWidth / 2, y: I.y + M.offsetHeight / 2 };\n      }\n    } else this._dir_end = rt(f, t.$task_data), e.env.isEdge && (this._dir_end.y += window.scrollY);\n    var D = !(S == $ && w == E && T == C);\n    return D && (w && e.refreshTask(w, !1), E && e.refreshTask(E, !1)), D && y(k.marker), b(this._dir_start.x, this._dir_start.y, this._dir_end.x, this._dir_end.y), !0;\n  }, this)), g.attachEvent(\"onDragEnd\", e.bind(function() {\n    var m = o();\n    if (m.link_source_id && m.link_target_id && m.link_source_id != m.link_target_id) {\n      var f = e._get_link_type(m.link_from_start, m.link_to_start), k = { source: m.link_source_id, target: m.link_target_id, type: f };\n      k.type && e.isLinkAllowed(k) && e.callEvent(\"onLinkCreated\", [k]) && e.addLink(k);\n    }\n    v(), e.config.touch ? e.refreshData() : (m.link_source_id && e.refreshTask(m.link_source_id, !1), m.link_target_id && e.refreshTask(m.link_target_id, !1)), g._direction && (g._direction.parentNode && g._direction.parentNode.removeChild(g._direction), g._direction = null);\n  }, this)), e.attachEvent(\"onGanttRender\", e.bind(function() {\n    g._direction && b(this._dir_start.x, this._dir_start.y, this._dir_end.x, this._dir_end.y);\n  }, this));\n};\nconst Ba = function() {\n  return { init: Oa };\n};\nvar za = function(t) {\n  var e = t.$services;\n  return { onCreated: function(n) {\n    var i = n.$config;\n    i.bind = W(i.bind) ? i.bind : \"task\", i.bindLinks = W(i.bindLinks) ? i.bindLinks : \"link\", n._linksDnD = Ba(), n._tasksDnD = Ha.createTaskDND(), n._tasksDnD.extend(n), this._mouseDelegates = Te(t);\n  }, onInitialized: function(n) {\n    this._attachDomEvents(t), this._attachStateProvider(t, n), n._tasksDnD.init(n, t), n._linksDnD.init(n, t), n.$config.id == \"timeline\" && this.extendDom(n);\n  }, onDestroyed: function(n) {\n    this._clearDomEvents(t), this._clearStateProvider(t), n._tasksDnD && n._tasksDnD.destructor();\n  }, extendDom: function(n) {\n    t.$task = n.$task, t.$task_scale = n.$task_scale, t.$task_data = n.$task_data, t.$task_bg = n.$task_bg, t.$task_links = n.$task_links, t.$task_bars = n.$task_bars;\n  }, _clearDomEvents: function() {\n    this._mouseDelegates.destructor(), this._mouseDelegates = null;\n  }, _attachDomEvents: function(n) {\n    function i(a, r) {\n      if (a && this.callEvent(\"onLinkDblClick\", [a, r])) {\n        var s = this.getLink(a);\n        if (this.isReadonly(s)) return;\n        var o = this.locale.labels.link + \" \" + this.templates.link_description(this.getLink(a)) + \" \" + this.locale.labels.confirm_link_deleting;\n        window.setTimeout(function() {\n          n._delete_link_confirm({ link: s, message: o, title: \"\", callback: function() {\n            n.deleteLink(a);\n          } });\n        }, this.config.touch ? 300 : 1);\n      }\n    }\n    this._mouseDelegates.delegate(\"click\", \"gantt_task_link\", n.bind(function(a, r) {\n      var s = this.locate(a, this.config.link_attribute);\n      s && this.callEvent(\"onLinkClick\", [s, a]);\n    }, n), this.$task), this._mouseDelegates.delegate(\"click\", \"gantt_scale_cell\", n.bind(function(a, r) {\n      var s = rt(a, n.$task_data), o = n.dateFromPos(s.x), l = Math.floor(n.columnIndexByDate(o)), d = n.getScale().trace_x[l];\n      n.callEvent(\"onScaleClick\", [a, d]);\n    }, n), this.$task), this._mouseDelegates.delegate(\"doubleclick\", \"gantt_task_link\", n.bind(function(a, r, s) {\n      r = this.locate(a, n.config.link_attribute), i.call(this, r, a);\n    }, n), this.$task), this._mouseDelegates.delegate(\"doubleclick\", \"gantt_link_point\", n.bind(function(a, r, s) {\n      r = this.locate(a);\n      var o = this.getTask(r), l = null;\n      return s.parentNode && X(s.parentNode) && (l = X(s.parentNode).indexOf(\"_left\") > -1 ? o.$target[0] : o.$source[0]), l && i.call(this, l, a), !1;\n    }, n), this.$task);\n  }, _attachStateProvider: function(n, i) {\n    var a = i;\n    e.getService(\"state\").registerProvider(\"tasksTimeline\", function() {\n      return { scale_unit: a._tasks ? a._tasks.unit : void 0, scale_step: a._tasks ? a._tasks.step : void 0 };\n    });\n  }, _clearStateProvider: function() {\n    e.getService(\"state\").unregisterProvider(\"tasksTimeline\");\n  } };\n}, Wa = function(t) {\n  return { getVerticalScrollbar: function() {\n    return t.$ui.getView(\"scrollVer\");\n  }, getHorizontalScrollbar: function() {\n    return t.$ui.getView(\"scrollHor\");\n  }, _legacyGridResizerClass: function(e) {\n    for (var n = e.getCellsByType(\"resizer\"), i = 0; i < n.length; i++) {\n      var a = n[i], r = !1, s = a.$parent.getPrevSibling(a.$id);\n      if (s && s.$config && s.$config.id === \"grid\") r = !0;\n      else {\n        var o = a.$parent.getNextSibling(a.$id);\n        o && o.$config && o.$config.id === \"grid\" && (r = !0);\n      }\n      r && (a.$config.css = (a.$config.css ? a.$config.css + \" \" : \"\") + \"gantt_grid_resize_wrap\");\n    }\n  }, onCreated: function(e) {\n    var n = !0;\n    this._legacyGridResizerClass(e), e.attachEvent(\"onBeforeResize\", function() {\n      var i = t.$ui.getView(\"timeline\");\n      i && (i.$config.hidden = i.$parent.$config.hidden = !t.config.show_chart);\n      var a = t.$ui.getView(\"grid\");\n      if (a) {\n        var r = a._getColsTotalWidth(), s = !t.config.show_grid || !t.config.grid_width || r === 0;\n        if (n && !s && r !== !1 && (t.config.grid_width = r), a.$config.hidden = a.$parent.$config.hidden = s, !a.$config.hidden) {\n          var o = a._getGridWidthLimits();\n          if (o[0] && t.config.grid_width < o[0] && (t.config.grid_width = o[0]), o[1] && t.config.grid_width > o[1] && (t.config.grid_width = o[1]), i && t.config.show_chart) {\n            if (a.$config.width = t.config.grid_width - 1, !a.$config.scrollable && a.$config.scrollY && t.$root.offsetWidth) {\n              var l = a.$gantt.$layout.$container.offsetWidth, d = t.$ui.getView(a.$config.scrollY).$config.width, c = l - (a.$config.width + d) - 4;\n              c < 0 && (a.$config.width += c, t.config.grid_width += c);\n            }\n            if (n) a.$parent.$config.width = t.config.grid_width, a.$parent.$config.group && t.$layout._syncCellSizes(a.$parent.$config.group, { value: a.$parent.$config.width, isGravity: !1 });\n            else if (i && !Y(i.$task, e.$view)) {\n              if (!a.$config.original_grid_width) {\n                var u = t.skins[t.skin];\n                u && u.config && u.config.grid_width ? a.$config.original_grid_width = u.config.grid_width : a.$config.original_grid_width = 0;\n              }\n              t.config.grid_width = a.$config.original_grid_width, a.$parent.$config.width = t.config.grid_width;\n            } else a.$parent._setContentSize(a.$config.width, null), t.$layout._syncCellSizes(a.$parent.$config.group, { value: t.config.grid_width, isGravity: !1 });\n          } else i && Y(i.$task, e.$view) && (a.$config.original_grid_width = t.config.grid_width), n || (a.$parent.$config.width = 0);\n        }\n        n = !1;\n      }\n    }), this._initScrollStateEvents(e);\n  }, _initScrollStateEvents: function(e) {\n    t._getVerticalScrollbar = this.getVerticalScrollbar, t._getHorizontalScrollbar = this.getHorizontalScrollbar;\n    var n = this.getVerticalScrollbar(), i = this.getHorizontalScrollbar();\n    n && n.attachEvent(\"onScroll\", function(a, r, s) {\n      var o = t.getScrollState();\n      t.callEvent(\"onGanttScroll\", [o.x, a, o.x, r]);\n    }), i && i.attachEvent(\"onScroll\", function(a, r, s) {\n      var o = t.getScrollState();\n      t.callEvent(\"onGanttScroll\", [a, o.y, r, o.y]);\n      var l = t.$ui.getView(\"grid\");\n      l && l.$grid_data && !l.$config.scrollable && (l.$grid_data.style.left = l.$grid.scrollLeft + \"px\", l.$grid_data.scrollLeft = l.$grid.scrollLeft);\n    }), e.attachEvent(\"onResize\", function() {\n      n && !t.$scroll_ver && (t.$scroll_ver = n.$scroll_ver), i && !t.$scroll_hor && (t.$scroll_hor = i.$scroll_hor);\n    });\n  }, _findGridResizer: function(e, n) {\n    for (var i, a = e.getCellsByType(\"resizer\"), r = !0, s = 0; s < a.length; s++) {\n      var o = a[s];\n      o._getSiblings();\n      var l = o._behind, d = o._front;\n      if (l && l.$content === n || l.isChild && l.isChild(n)) {\n        i = o, r = !0;\n        break;\n      }\n      if (d && d.$content === n || d.isChild && d.isChild(n)) {\n        i = o, r = !1;\n        break;\n      }\n    }\n    return { resizer: i, gridFirst: r };\n  }, onInitialized: function(e) {\n    var n = t.$ui.getView(\"grid\"), i = this._findGridResizer(e, n);\n    if (i.resizer) {\n      var a, r = i.gridFirst, s = i.resizer;\n      if (s.$config.mode !== \"x\") return;\n      s.attachEvent(\"onResizeStart\", function(o, l) {\n        var d = t.$ui.getView(\"grid\"), c = d ? d.$parent : null;\n        if (c) {\n          var u = d._getGridWidthLimits();\n          d.$config.scrollable || (c.$config.minWidth = u[0]), c.$config.maxWidth = u[1];\n        }\n        return a = r ? o : l, t.callEvent(\"onGridResizeStart\", [a]);\n      }), s.attachEvent(\"onResize\", function(o, l) {\n        var d = r ? o : l;\n        return t.callEvent(\"onGridResize\", [a, d]);\n      }), s.attachEvent(\"onResizeEnd\", function(o, l, d, c) {\n        var u = r ? o : l, h = r ? d : c, g = t.$ui.getView(\"grid\"), p = g ? g.$parent : null;\n        p && (p.$config.minWidth = void 0);\n        var y = t.callEvent(\"onGridResizeEnd\", [u, h]);\n        return y && h !== 0 && (t.config.grid_width = h), y;\n      });\n    }\n  }, onDestroyed: function(e) {\n  } };\n};\nconst ja = { init: function(t) {\n  function e(r, s) {\n    var o = s(t);\n    o.onCreated && o.onCreated(r), r.attachEvent(\"onReady\", function() {\n      o.onInitialized && o.onInitialized(r);\n    }), r.attachEvent(\"onDestroy\", function() {\n      o.onDestroyed && o.onDestroyed(r);\n    });\n  }\n  var n = la(t);\n  n.registerView(\"cell\", Ht), n.registerView(\"resizer\", null), n.registerView(\"scrollbar\", fa), n.registerView(\"layout\", kn, function(r) {\n    (r.$config ? r.$config.id : null) === \"main\" && e(r, Wa);\n  }), n.registerView(\"viewcell\", ga), n.registerView(\"multiview\", _a), n.registerView(\"timeline\", Ut, function(r) {\n    (r.$config ? r.$config.id : null) !== \"timeline\" && r.$config.bind != \"task\" || e(r, za);\n  }), n.registerView(\"grid\", xe, function(r) {\n    (r.$config ? r.$config.id : null) !== \"grid\" && r.$config.bind != \"task\" || e(r, Ra);\n  }), n.registerView(\"resourceGrid\", xe), n.registerView(\"resourceTimeline\", Ut), n.registerView(\"resourceHistogram\", Ut);\n  var i = function(r) {\n    var s = ua(r);\n    return { getDataRender: function(o) {\n      return r.$services.getService(\"layer:\" + o) || null;\n    }, createDataRender: function(o) {\n      var l = o.name, d = o.defaultContainer, c = o.defaultContainerSibling, u = s.createGroup(d, c, function(h, g) {\n        if (!u.filters) return !0;\n        for (var p = 0; p < u.filters.length; p++) if (u.filters[p](h, g) === !1) return !1;\n      }, ha);\n      return r.$services.setService(\"layer:\" + l, function() {\n        return u;\n      }), r.attachEvent(\"onGanttReady\", function() {\n        u.addLayer();\n      }), u;\n    }, init: function() {\n      var o = this.createDataRender({ name: \"task\", defaultContainer: function() {\n        return r.$task_data ? r.$task_data : r.$ui.getView(\"timeline\") ? r.$ui.getView(\"timeline\").$task_data : void 0;\n      }, defaultContainerSibling: function() {\n        return r.$task_links ? r.$task_links : r.$ui.getView(\"timeline\") ? r.$ui.getView(\"timeline\").$task_links : void 0;\n      }, filter: function(d) {\n      } }, r), l = this.createDataRender({ name: \"link\", defaultContainer: function() {\n        return r.$task_data ? r.$task_data : r.$ui.getView(\"timeline\") ? r.$ui.getView(\"timeline\").$task_data : void 0;\n      } }, r);\n      return { addTaskLayer: function(d) {\n        const c = ft;\n        return typeof d == \"function\" ? d = { renderer: { render: d, getVisibleRange: c } } : d.renderer && !d.renderer.getVisibleRange && (d.renderer.getVisibleRange = c), d.view = \"timeline\", o.addLayer(d);\n      }, _getTaskLayers: function() {\n        return o.getLayers();\n      }, removeTaskLayer: function(d) {\n        o.removeLayer(d);\n      }, _clearTaskLayers: function() {\n        o.clear();\n      }, addLinkLayer: function(d) {\n        const c = mn();\n        return typeof d == \"function\" ? d = { renderer: { render: d, getVisibleRange: c } } : d.renderer && !d.renderer.getVisibleRange && (d.renderer.getVisibleRange = c), d.view = \"timeline\", d && d.renderer && (d.renderer.getRectangle || d.renderer.isInViewPort || (d.renderer.isInViewPort = vn)), l.addLayer(d);\n      }, _getLinkLayers: function() {\n        return l.getLayers();\n      }, removeLinkLayer: function(d) {\n        l.removeLayer(d);\n      }, _clearLinkLayers: function() {\n        l.clear();\n      } };\n    } };\n  }(t), a = Da(t);\n  return t.ext.inlineEditors = a, t.ext._inlineEditors = a, a.init(t), { factory: n, mouseEvents: ca.init(t), layersApi: i.init(), render: { gridLine: function() {\n    return /* @__PURE__ */ function(r) {\n      return { render: function(s, o, l, d) {\n        for (var c = o.getGridColumns(), u = o.$getTemplates(), h = o.$config.rowStore, g = [], p = 0; p < c.length; p++) {\n          var y, v, b, _ = p == c.length - 1, m = c[p];\n          m.name == \"add\" ? (v = \"<div \" + (S = r._waiAria.gridAddButtonAttrString(m)) + \" class='gantt_add'></div>\", b = \"\") : (Z(v = m.template ? m.template(s) : s[m.name]) && (v = u.date_grid(v, s, m.name)), v == null && (v = \"\"), b = v, v = \"<div class='gantt_tree_content'>\" + v + \"</div>\");\n          var f = \"gantt_cell\" + (_ ? \" gantt_last_cell\" : \"\"), k = [];\n          if (m.tree) {\n            f += \" gantt_cell_tree\";\n            for (var x = 0; x < s.$level; x++) k.push(u.grid_indent(s));\n            !h.hasChild(s.id) || r.isSplitTask(s) && !r.config.open_split_tasks ? (k.push(u.grid_blank(s)), k.push(u.grid_file(s))) : (k.push(u.grid_open(s)), k.push(u.grid_folder(s)));\n          }\n          var $ = \"width:\" + (m.width - (_ ? 1 : 0)) + \"px;\";\n          if (this.defined(m.align)) {\n            var w = { right: \"flex-end\", left: \"flex-start\", center: \"center\" }[m.align];\n            $ += \"text-align:\" + m.align + \";justify-content:\" + w + \";\";\n          }\n          var S = r._waiAria.gridCellAttrString(m, b, s);\n          k.push(v), y = \"<div class='\" + f + \"' data-column-index='\" + p + \"' data-column-name='\" + m.name + \"' style='\" + $ + \"' \" + S + \">\" + k.join(\"\") + \"</div>\", g.push(y);\n        }\n        switch (f = \"\", h.$config.name) {\n          case \"task\":\n            f = r.getGlobalTaskIndex(s.id) % 2 == 0 ? \"\" : \" odd\";\n            break;\n          case \"resource\":\n            f = h.visibleOrder.indexOf(s.id) % 2 == 0 ? \"\" : \" odd\";\n        }\n        if (f += s.$transparent ? \" gantt_transparent\" : \"\", f += s.$dataprocessor_class ? \" \" + s.$dataprocessor_class : \"\", u.grid_row_class) {\n          var T = u.grid_row_class.call(r, s.start_date, s.end_date, s);\n          T && (f += \" \" + T);\n        }\n        h.isSelected(s.id) && (f += \" gantt_selected\");\n        var E = document.createElement(\"div\");\n        E.className = \"gantt_row\" + f + \" gantt_row_\" + r.getTaskType(s.type);\n        var C = o.getItemHeight(s.id);\n        return E.style.height = C + \"px\", E.style.lineHeight = C + \"px\", l.smart_rendering && (E.style.position = \"absolute\", E.style.left = \"0px\", E.style.top = o.getItemTop(s.id) + \"px\"), o.$config.item_attribute && (E.setAttribute(o.$config.item_attribute, s.id), E.setAttribute(o.$config.bind + \"_id\", s.id)), r._waiAria.taskRowAttr(s, E), E.innerHTML = g.join(\"\"), E;\n      }, update: null, getRectangle: Kt, isInViewPort: Ma, getVisibleRange: ft, onrender: function(s, o, l) {\n        for (var d = l.getGridColumns(), c = 0; c < d.length; c++) {\n          var u = d[c];\n          if (u.onrender) {\n            var h = o.querySelector(\"[data-column-name=\" + u.name + \"]\");\n            if (h) {\n              var g = u.onrender(s, h);\n              if (g && typeof g == \"string\") h.innerHTML = g;\n              else if (g && typeof g == \"object\" && r.config.external_render) {\n                var p = r.config.external_render;\n                p.isElement(g) && p.renderElement(g, h);\n              }\n            }\n          }\n        }\n      } };\n    }(t);\n  }, taskBg: function() {\n    return /* @__PURE__ */ function(r) {\n      var s = {}, o = {};\n      function l(g, p) {\n        return !(!s[g.id][p] || !s[g.id][p].parentNode);\n      }\n      function d(g, p) {\n        s[g] && s[g][p] && s[g][p].parentNode && s[g][p].parentNode.removeChild(s[g][p]);\n      }\n      function c(g) {\n        var p, y = g.$getTemplates();\n        return y.task_cell_class !== void 0 ? (p = y.task_cell_class, (console.warn || console.log)(\"gantt.templates.task_cell_class template is deprecated and will be removed soon. Please use gantt.templates.timeline_cell_class instead.\")) : p = y.timeline_cell_class, p;\n      }\n      function u(g) {\n        return g.$getTemplates().timeline_cell_content;\n      }\n      function h(g, p, y, v, b, _, m, f) {\n        var k = g.width[p], x = \"\";\n        if (oe(p, g, v, r)) {\n          var $ = _(y, g.trace_x[p]), w = \"\";\n          if (m && (w = m(y, g.trace_x[p])), f.static_background) {\n            var S = !(!$ && !w);\n            if (!f.static_background_cells || !S) return null;\n          }\n          if (s[y.id][p]) return o[y.id][p] = p, s[y.id][p];\n          var T = document.createElement(\"div\");\n          return T.style.width = k + \"px\", x = \"gantt_task_cell\" + (p == b - 1 ? \" gantt_last_cell\" : \"\"), $ && (x += \" \" + $), T.className = x, w && (T.innerHTML = w), T.style.position = \"absolute\", T.style.left = g.left[p] + \"px\", s[y.id][p] = T, o[y.id][p] = p, T;\n        }\n        return null;\n      }\n      return { render: function(g, p, y, v) {\n        var b = p.$getTemplates(), _ = p.getScale(), m = _.count;\n        if (y.static_background && !y.static_background_cells) return null;\n        var f, k = document.createElement(\"div\"), x = c(p), $ = u(p);\n        if (f = v && y.smart_rendering && !Nt(r) ? jt(_, v.x) : { start: 0, end: m - 1 }, y.show_task_cells) {\n          s[g.id] = {}, o[g.id] = {};\n          for (var w = f.start; w <= f.end; w++) {\n            var S = h(_, w, g, v, m, x, $, y);\n            S && k.appendChild(S);\n          }\n        }\n        const T = p.$config.rowStore, E = T.getIndexById(g.id) % 2 != 0;\n        var C = b.task_row_class(g.start_date, g.end_date, g), D = \"gantt_task_row\" + (E ? \" odd\" : \"\") + (C ? \" \" + C : \"\");\n        if (T.isSelected(g.id) && (D += \" gantt_selected\"), k.className = D, y.smart_rendering ? (k.style.position = \"absolute\", k.style.top = p.getItemTop(g.id) + \"px\", k.style.width = \"100%\") : k.style.position = \"relative\", k.style.height = p.getItemHeight(g.id) + \"px\", g.id == \"timeline_placeholder_task\") {\n          var M = 0;\n          g.lastTaskId && (M = p.getItemTop(g.lastTaskId) + p.getItemHeight(g.lastTaskId));\n          var I = (g.row_height || p.$task_data.offsetHeight) - M;\n          I < 0 && (I = 0), y.smart_rendering && (k.style.top = M + \"px\"), k.style.height = I + \"px\";\n        }\n        return p.$config.item_attribute && (k.setAttribute(p.$config.item_attribute, g.id), k.setAttribute(p.$config.bind + \"_id\", g.id)), k;\n      }, update: function(g, p, y, v, b) {\n        var _ = y.getScale(), m = _.count, f = c(y), k = u(y);\n        if (v.show_task_cells) {\n          s[g.id] || (s[g.id] = {}), o[g.id] || (o[g.id] = {});\n          var x = jt(_, b);\n          for (var $ in o[g.id]) {\n            var w = o[g.id][$];\n            (Number(w) < x.start || Number(w) > x.end) && d(g.id, w);\n          }\n          o[g.id] = {};\n          for (var S = x.start; S <= x.end; S++) {\n            var T = h(_, S, g, b, m, f, k, v);\n            !T && l(g, S) ? d(g.id, S) : T && !T.parentNode && p.appendChild(T);\n          }\n        }\n      }, getRectangle: qe, getVisibleRange: ft, prepareData: Aa };\n    }(t);\n  }, taskBar: function() {\n    return Ue(t);\n  }, timedProjectBar: function() {\n    return Ue(t);\n  }, taskRollupBar: function() {\n    return function(r) {\n      const s = bn(r), o = {};\n      function l(u, h, g, p, y) {\n        let v = !0;\n        return p.smart_rendering && (v = $e(u, h, g)), v;\n      }\n      function d(u, h, g, p) {\n        const y = r.copy(r.getTask(h.id));\n        if (y.$rendered_at = u.id, r.callEvent(\"onBeforeRollupTaskDisplay\", [y.id, y, u.id]) === !1) return;\n        const v = s(y, g);\n        if (!v) return;\n        const b = g.getBarHeight(u.id, h.type == r.config.types.milestone), _ = Math.floor((g.getItemHeight(u.id) - b) / 2);\n        return v.style.top = p.top + _ + \"px\", v.classList.add(\"gantt_rollup_child\"), v.setAttribute(\"data-rollup-parent-id\", u.id), v;\n      }\n      function c(u, h) {\n        return u + \"_\" + h;\n      }\n      return { render: function(u, h, g, p) {\n        if (u.rollup !== !1 && u.$rollup && u.$rollup.length) {\n          const y = document.createElement(\"div\"), v = r.getTaskPosition(u);\n          return p && (p.y = 0, p.y_end = r.$task_bg.scrollHeight), u.$rollup.forEach(function(b) {\n            if (!r.isTaskExists(b)) return;\n            const _ = r.getTask(b);\n            if (!l(_, p, h, g)) return;\n            const m = d(u, _, h, v);\n            m ? (o[c(_.id, u.id)] = m, y.appendChild(m)) : o[c(_.id, u.id)] = !1;\n          }), y;\n        }\n        return !1;\n      }, update: function(u, h, g, p, y) {\n        const v = document.createElement(\"div\"), b = r.getTaskPosition(u);\n        y.y = 0, y.y_end = r.$task_bg.scrollHeight, u.$rollup.forEach(function(_) {\n          const m = r.getTask(_), f = c(m.id, u.id);\n          let k = l(m, y, g, p);\n          if (k !== !!o[f]) if (k) {\n            const x = d(u, m, g, b);\n            o[f] = x || !1;\n          } else o[f] = !1;\n          o[f] && v.appendChild(o[f]), h.innerHTML = \"\", h.appendChild(v);\n        });\n      }, isInViewPort: $e, getVisibleRange: ft };\n    }(t);\n  }, taskSplitBar: function() {\n    return Ct();\n  }, taskConstraints: function() {\n    return Ct();\n  }, taskDeadline: function() {\n    return Ct();\n  }, taskBaselines: function() {\n    return Ct();\n  }, link: function() {\n    return Ia(t);\n  }, resourceRow: function() {\n    return function(r) {\n      var s = Na(r), o = {};\n      function l(c, u, h, g, p) {\n        var y = h.resource_cell_class(u.start_date, u.end_date, c, u.tasks, u.assignments), v = h.resource_cell_value(u.start_date, u.end_date, c, u.tasks, u.assignments), b = p.getItemHeight(c.id) - 1;\n        if (y || v) {\n          var _ = p.getItemPosition(c, u.start_date, u.end_date), m = document.createElement(\"div\");\n          return m.setAttribute(p.$config.item_attribute, c.id), m.className = [\"gantt_resource_marker\", y].join(\" \"), m.style.cssText = [\"left:\" + _.left + \"px\", \"width:\" + _.width + \"px\", \"height:\" + b + \"px\", \"line-height:\" + b + \"px\", \"top:\" + _.top + \"px\"].join(\";\"), v && (m.innerHTML = v), m;\n        }\n        return null;\n      }\n      function d(c, u) {\n        o[c] && o[c][u] && o[c][u].parentNode && o[c][u].parentNode.removeChild(o[c][u]);\n      }\n      return { render: function(c, u, h, g) {\n        var p = u.$getTemplates(), y = u.getScale(), v = s(c, h.resource_property, u.getScale(), u), b = !!g, _ = [];\n        o[c.id] = {};\n        for (var m = jt(y, g), f = m.start; f <= m.end; f++) {\n          var k = v[f];\n          if (k && (!b || oe(f, y, g, r))) {\n            var x = l(c, k, p, 0, u);\n            x && (_.push(x), o[c.id][f] = x);\n          }\n        }\n        var $ = null;\n        if (_.length) {\n          $ = document.createElement(\"div\");\n          for (var w = 0; w < _.length; w++) $.appendChild(_[w]);\n        }\n        return $;\n      }, update: function(c, u, h, g, p) {\n        var y = h.$getTemplates(), v = h.getScale(), b = s(c, g.resource_property, h.getScale(), h), _ = jt(v, p), m = {};\n        if (o && o[c.id]) for (var f in o[c.id]) m[f] = f;\n        for (var k = _.start; k <= _.end; k++) {\n          var x = b[k];\n          if (m[k] = !1, x) if (oe(k, v, p, r)) if (o[c.id] && o[c.id][k]) o[c.id] && o[c.id][k] && !o[c.id][k].parentNode && u.appendChild(o[c.id][k]);\n          else {\n            var $ = l(c, x, y, 0, h);\n            $ && (u.appendChild($), o[c.id][k] = $);\n          }\n          else d(c.id, k);\n        }\n        for (var f in m) m[f] !== !1 && d(c.id, f);\n      }, getRectangle: qe, getVisibleRange: ft };\n    }(t);\n  }, resourceHistogram: function() {\n    return Ct();\n  }, gridTaskRowResizer: function() {\n    return /* @__PURE__ */ function(r) {\n      return { render: function(s, o, l) {\n        var d = o.$getConfig(), c = document.createElement(\"div\");\n        return c.className = \"gantt_task_grid_row_resize_wrap\", c.style.top = o.getItemTop(s.id) + o.getItemHeight(s.id) + \"px\", c.innerHTML = \"<div class='gantt_task_grid_row_resize' role='cell'></div>\", c.setAttribute(d.task_grid_row_resizer_attribute, s.id), r._waiAria.rowResizerAttr(c), c;\n      }, update: null, getRectangle: Kt, getVisibleRange: ft };\n    }(t);\n  } }, layersService: { getDataRender: function(r) {\n    return i.getDataRender(r, t);\n  }, createDataRender: function(r) {\n    return i.createDataRender(r, t);\n  } } };\n} };\nfunction ce(t, e) {\n  const n = getComputedStyle(e.$root).getPropertyValue(\"--dhx-gantt-theme\");\n  let i, a = !!n;\n  if (a) i = n;\n  else {\n    var r = e.skin;\n    if (i = r, !r || t) for (var s = document.getElementsByTagName(\"link\"), o = 0; o < s.length; o++) {\n      var l = s[o].href.match(\"dhtmlxgantt_([a-z_]+).css\");\n      if (l && (e.skins[l[1]] || !r)) {\n        i = l[1];\n        break;\n      }\n    }\n  }\n  e._theme_info = { theme: i, cssVarTheme: a }, e.skin = i || \"terrace\";\n  var d = e.skins[e.skin] || e.skins.terrace;\n  (function(h, g, p) {\n    for (var y in g) (h[y] === void 0 || p) && (h[y] = g[y]);\n  })(e.config, d.config, t), a || (e.config.link_radius = 1);\n  var c = e.getGridColumns();\n  for (c[1] && !e.defined(c[1].width) && (c[1].width = d._second_column_width), c[2] && !e.defined(c[2].width) && (c[2].width = d._third_column_width), o = 0; o < c.length; o++) {\n    var u = c[o];\n    u.name == \"add\" && (u.width || (u.width = 44), e.defined(u.min_width) && e.defined(u.max_width) || (u.min_width = u.min_width || u.width, u.max_width = u.max_width || u.width), u.min_width && (u.min_width = +u.min_width), u.max_width && (u.max_width = +u.max_width), u.width && (u.width = +u.width, u.width = u.min_width && u.min_width > u.width ? u.min_width : u.width, u.width = u.max_width && u.max_width < u.width ? u.max_width : u.width));\n  }\n  d.config.task_height && (e.config.task_height = d.config.task_height || \"full\"), d.config.bar_height && (e.config.bar_height = d.config.bar_height || \"full\"), d._lightbox_template && (e._lightbox_template = d._lightbox_template), d._redefine_lightbox_buttons && (e.config.buttons_right = d._redefine_lightbox_buttons.buttons_right, e.config.buttons_left = d._redefine_lightbox_buttons.buttons_left), e.resetLightbox();\n}\nfunction Fa(t) {\n  var e = null, n = !1, i = null, a = { started: !1 }, r = {};\n  function s(g) {\n    return g && Y(g, t.$root) && g.offsetHeight;\n  }\n  function o() {\n    var g = !!document.querySelector(\".gantt_drag_marker\"), p = !!document.querySelector(\".gantt_drag_marker.gantt_grid_resize_area\") || !!document.querySelector(\".gantt_drag_marker.gantt_row_grid_resize_area\"), y = !!document.querySelector(\".gantt_link_direction\"), v = t.getState(), b = v.autoscroll;\n    return n = g && !p && !y, !(!v.drag_mode && !g || p) || b;\n  }\n  function l(g) {\n    if (i && (clearTimeout(i), i = null), g) {\n      var p = t.config.autoscroll_speed;\n      p && p < 10 && (p = 10), i = setTimeout(function() {\n        e = setInterval(u, p || 50);\n      }, t.config.autoscroll_delay || 10);\n    }\n  }\n  function d(g) {\n    g ? (l(!0), a.started || (a.x = r.x, a.y = r.y, a.started = !0)) : (e && (clearInterval(e), e = null), l(!1), a.started = !1);\n  }\n  function c(g) {\n    var p = o();\n    if (!e && !i || p || d(!1), !t.config.autoscroll || !p) return !1;\n    r = { x: g.clientX, y: g.clientY }, g.type == \"touchmove\" && (r.x = g.targetTouches[0].clientX, r.y = g.targetTouches[0].clientY), !e && p && d(!0);\n  }\n  function u() {\n    if (!o()) return d(!1), !1;\n    var g = s(t.$task) ? t.$task : s(t.$grid) ? t.$grid : t.$root;\n    if (g) {\n      var p = !1;\n      [\".gantt_drag_marker.gantt_grid_resize_area\", \".gantt_drag_marker .gantt_row.gantt_row_task\", \".gantt_drag_marker.gantt_grid_dnd_marker\"].forEach(function(C) {\n        p = p || !!document.querySelector(C);\n      }), p && (g = t.$grid);\n      var y = V(g), v = r.x - y.x, b = r.y - y.y + window.scrollY, _ = n ? 0 : h(v, y.width, a.x - y.x), m = h(b, y.height, a.y - y.y + window.scrollY), f = t.getScrollState(), k = f.y, x = f.inner_height, $ = f.height, w = f.x, S = f.inner_width, T = f.width;\n      (m && !x || m < 0 && !k || m > 0 && k + x >= $ + 2) && (m = 0), (_ && !S || _ < 0 && !w || _ > 0 && w + S >= T) && (_ = 0);\n      var E = t.config.autoscroll_step;\n      E && E < 2 && (E = 2), m *= E || 30, ((_ *= E || 30) || m) && function(C, D) {\n        var M = t.getScrollState(), I = null, A = null;\n        C && (I = M.x + C, I = Math.min(M.width, I), I = Math.max(0, I)), D && (A = M.y + D, A = Math.min(M.height, A), A = Math.max(0, A)), t.scrollTo(I, A);\n      }(_, m);\n    }\n  }\n  function h(g, p, y) {\n    return g - 50 < 0 && g < y ? -1 : g > p - 50 && g > y ? 1 : 0;\n  }\n  t.attachEvent(\"onGanttReady\", function() {\n    if (!F(t)) {\n      var g = vt(t.$root) || document.body;\n      t.eventRemove(g, \"mousemove\", c), t.event(g, \"mousemove\", c), t.eventRemove(g, \"touchmove\", c), t.event(g, \"touchmove\", c), t.eventRemove(g, \"pointermove\", c), t.event(g, \"pointermove\", c);\n    }\n  }), t.attachEvent(\"onDestroy\", function() {\n    d(!1);\n  });\n}\nvar ue, he;\nwindow.jQuery && (ue = window.jQuery, he = [], ue.fn.dhx_gantt = function(t) {\n  if (typeof (t = t || {}) != \"string\") {\n    var e = [];\n    return this.each(function() {\n      if (this && this.getAttribute) if (this.gantt || window.gantt.$root == this) e.push(typeof this.gantt == \"object\" ? this.gantt : window.gantt);\n      else {\n        var n = window.gantt.$container && window.Gantt ? window.Gantt.getGanttInstance() : window.gantt;\n        for (var i in t) i != \"data\" && (n.config[i] = t[i]);\n        n.init(this), t.data && n.parse(t.data), e.push(n);\n      }\n    }), e.length === 1 ? e[0] : e;\n  }\n  if (he[t]) return he[t].apply(this, []);\n  ue.error(\"Method \" + t + \" does not exist on jQuery.dhx_gantt\");\n});\nwindow.dhtmlx && (window.dhtmlx.attaches || (window.dhtmlx.attaches = {}), window.dhtmlx.attaches.attachGantt = function(t, e, n) {\n  var i = document.createElement(\"DIV\");\n  n = n || window.gantt, i.id = \"gantt_\" + n.uid(), i.style.width = \"100%\", i.style.height = \"100%\", i.cmp = \"grid\", document.body.appendChild(i), this.attachObject(i.id), this.dataType = \"gantt\", this.dataObj = n;\n  var a = this.vs[this.av];\n  return a.grid = n, n.init(i.id, t, e), i.firstChild.style.border = \"none\", a.gridId = i.id, a.gridObj = i, this.vs[this._viewRestore()].grid;\n}), window.dhtmlXCellObject !== void 0 && (window.dhtmlXCellObject.prototype.attachGantt = function(t, e, n) {\n  n = n || window.gantt;\n  var i = document.createElement(\"DIV\");\n  return i.id = \"gantt_\" + n.uid(), i.style.width = \"100%\", i.style.height = \"100%\", i.cmp = \"grid\", document.body.appendChild(i), this.attachObject(i.id), this.dataType = \"gantt\", this.dataObj = n, n.init(i.id, t, e), i.firstChild.style.border = \"none\", i = null, this.callEvent(\"_onContentAttach\", []), this.dataObj;\n});\nconst Va = [\"ctrlKey\", \"altKey\", \"shiftKey\", \"metaKey\"], Ua = [[{ unit: \"month\", date: \"%M\", step: 1 }, { unit: \"day\", date: \"%d\", step: 1 }], [{ unit: \"day\", date: \"%d %M\", step: 1 }], [{ unit: \"day\", date: \"%d %M\", step: 1 }, { unit: \"hour\", date: \"%H:00\", step: 8 }], [{ unit: \"day\", date: \"%d %M\", step: 1 }, { unit: \"hour\", date: \"%H:00\", step: 1 }]];\nclass qa {\n  constructor(e) {\n    this.zoomIn = () => {\n      const n = this.getCurrentLevel() - 1;\n      n < 0 || this.setLevel(n);\n    }, this.zoomOut = () => {\n      const n = this.getCurrentLevel() + 1;\n      n > this._levels.length - 1 || this.setLevel(n);\n    }, this.getCurrentLevel = () => this._activeLevelIndex, this.getLevels = () => this._levels, this.setLevel = (n) => {\n      const i = this._getZoomIndexByName(n);\n      i === -1 && this.$gantt.assert(i !== -1, \"Invalid zoom level for gantt.ext.zoom.setLevel. \" + n + \" is not an expected value.\"), this._setLevel(i, 0);\n    }, this._getZoomIndexByName = (n) => {\n      let i = -1;\n      if (typeof n == \"string\") {\n        if (!isNaN(Number(n)) && this._levels[Number(n)]) i = Number(n);\n        else for (let a = 0; a < this._levels.length; a++) if (this._levels[a].name === n) {\n          i = a;\n          break;\n        }\n      } else i = n;\n      return i;\n    }, this._getVisibleDate = () => {\n      if (!this.$gantt.$task) return null;\n      const n = this.$gantt.getScrollState().x, i = this.$gantt.$task.offsetWidth;\n      this._visibleDate = this.$gantt.dateFromPos(n + i / 2);\n    }, this._setLevel = (n, i) => {\n      this._activeLevelIndex = n;\n      const a = this.$gantt, r = a.copy(this._levels[this._activeLevelIndex]), s = a.copy(r);\n      if (delete s.name, a.mixin(a.config, s, !0), [\"resourceTimeline\", \"resourceHistogram\"].forEach(function(o) {\n        const l = a.$ui.getView(o);\n        if (l) {\n          const d = l.$getConfig();\n          d.fixed_scales || a.mixin(d, s, !0);\n        }\n      }), a.$root && a.$task) {\n        if (i) {\n          const o = this.$gantt.dateFromPos(i + this.$gantt.getScrollState().x);\n          this.$gantt.render();\n          const l = this.$gantt.posFromDate(o);\n          this.$gantt.scrollTo(l - i);\n        } else {\n          const o = this.$gantt.$task.offsetWidth;\n          this._visibleDate || this._getVisibleDate();\n          const l = this._visibleDate;\n          this.$gantt.render();\n          const d = this.$gantt.posFromDate(l);\n          this.$gantt.scrollTo(d - o / 2);\n        }\n        this.callEvent(\"onAfterZoom\", [this._activeLevelIndex, r]);\n      }\n    }, this._attachWheelEvent = (n) => {\n      const i = mt.isFF ? \"wheel\" : \"mousewheel\";\n      let a;\n      a = typeof n.element == \"function\" ? n.element() : n.element, a && this._domEvents.attach(a, i, this.$gantt.bind(function(r) {\n        if (this._useKey && (Va.indexOf(this._useKey) < 0 || !r[this._useKey]))\n          return !1;\n        if (typeof this._handler == \"function\") return this._handler.apply(this, [r]), !0;\n      }, this), { passive: !1 });\n    }, this._defaultHandler = (n) => {\n      const i = this.$gantt.$task.getBoundingClientRect().x, a = n.clientX - i;\n      let r = !1;\n      (this.$gantt.env.isFF ? -40 * n.deltaY : n.wheelDelta) > 0 && (r = !0), n.preventDefault(), n.stopPropagation(), this._setScaleSettings(r, a);\n    }, this._setScaleDates = () => {\n      this._initialStartDate && this._initialEndDate && (this.$gantt.config.start_date = this._initialStartDate, this.$gantt.config.end_date = this._initialEndDate);\n    }, this.$gantt = e, this._domEvents = this.$gantt._createDomEventScope();\n  }\n  init(e) {\n    this.$gantt.env.isNode || (this._initialStartDate = e.startDate, this._initialEndDate = e.endDate, this._activeLevelIndex = e.activeLevelIndex ? e.activeLevelIndex : 0, this._levels = this._mapScales(e.levels || Ua), this._handler = e.handler || this._defaultHandler, this._minColumnWidth = e.minColumnWidth || 60, this._maxColumnWidth = e.maxColumnWidth || 240, this._widthStep = e.widthStep || 3 / 8 * e.minColumnWidth, this._useKey = e.useKey, this._initialized || (ot(this), this.$gantt.attachEvent(\"onGanttScroll\", () => {\n      this._getVisibleDate();\n    })), this._domEvents.detachAll(), e.trigger === \"wheel\" && (this.$gantt.$root ? this._attachWheelEvent(e) : this.$gantt.attachEvent(\"onGanttLayoutReady\", () => {\n      this.$gantt.attachEvent(\"onGanttRender\", () => {\n        this._attachWheelEvent(e);\n      }, { once: !0 });\n    })), this._initialized = !0, this.setLevel(this._activeLevelIndex));\n  }\n  _mapScales(e) {\n    return e.map((n) => Array.isArray(n) ? { scales: n } : n);\n  }\n  _setScaleSettings(e, n) {\n    e ? this._stepUp(n) : this._stepDown(n);\n  }\n  _stepUp(e) {\n    if (this._activeLevelIndex >= this._levels.length - 1) return;\n    let n = this._activeLevelIndex;\n    if (this._setScaleDates(), this._widthStep) {\n      let i = this.$gantt.config.min_column_width + this._widthStep;\n      i > this._maxColumnWidth && (i = this._minColumnWidth, n++), this.$gantt.config.min_column_width = i;\n    } else n++;\n    this._setLevel(n, e);\n  }\n  _stepDown(e) {\n    if (this._activeLevelIndex < 1) return;\n    let n = this._activeLevelIndex;\n    if (this._setScaleDates(), this._widthStep) {\n      let i = this.$gantt.config.min_column_width - this._widthStep;\n      i < this._minColumnWidth && (i = this._maxColumnWidth, n--), this.$gantt.config.min_column_width = i;\n    } else n--;\n    this._setLevel(n, e);\n  }\n}\nfunction Ga(t) {\n  function e() {\n    if (t.config.touch != \"force\" && (t.config.touch = t.config.touch && (navigator.userAgent.indexOf(\"Mobile\") != -1 || navigator.userAgent.indexOf(\"iPad\") != -1 || navigator.userAgent.indexOf(\"Android\") != -1 || navigator.userAgent.indexOf(\"Touch\") != -1) || navigator.platform === \"MacIntel\" && navigator.maxTouchPoints > 1), t.config.touch) {\n      var r = !0;\n      try {\n        document.createEvent(\"TouchEvent\");\n      } catch {\n        r = !1;\n      }\n      r ? t._touch_events([\"touchmove\", \"touchstart\", \"touchend\"], function(s) {\n        return s.touches && s.touches.length > 1 ? null : s.touches[0] ? { target: s.target, pageX: s.touches[0].pageX, pageY: s.touches[0].pageY, clientX: s.touches[0].clientX, clientY: s.touches[0].clientY } : s;\n      }, function(s) {\n        return s.defaultPrevented;\n      }) : window.navigator.pointerEnabled ? t._touch_events([\"pointermove\", \"pointerdown\", \"pointerup\"], function(s) {\n        return s.pointerType == \"mouse\" ? null : s;\n      }, function(s) {\n        return !s || s.pointerType == \"mouse\";\n      }) : window.navigator.msPointerEnabled && t._touch_events([\"MSPointerMove\", \"MSPointerDown\", \"MSPointerUp\"], function(s) {\n        return s.pointerType == s.MSPOINTER_TYPE_MOUSE ? null : s;\n      }, function(s) {\n        return !s || s.pointerType == s.MSPOINTER_TYPE_MOUSE;\n      });\n    }\n  }\n  function n(r) {\n    var s = r.$config.scrollX ? t.$ui.getView(r.$config.scrollX) : null, o = r.$config.scrollY ? t.$ui.getView(r.$config.scrollY) : null, l = { x: null, y: null };\n    return s && s.getScrollState().visible && (l.x = s.$view.scrollLeft), o && o.getScrollState().visible && (l.y = o.$view.scrollTop), l;\n  }\n  function i() {\n    var r;\n    return t.$ui.getView(\"timeline\") && (r = t.$ui.getView(\"timeline\")._tasks_dnd), r;\n  }\n  t.config.touch_drag = 75, t.config.touch = !0, t.config.touch_feedback = !0, t.config.touch_feedback_duration = 1, t._prevent_touch_scroll = !1, t._touch_feedback = function() {\n    t.config.touch_feedback && navigator.vibrate && navigator.vibrate(t.config.touch_feedback_duration);\n  }, t.attachEvent(\"onGanttReady\", function() {\n    t.$container && e();\n  }), t.attachEvent(\"onGanttLayoutReady\", function() {\n    t.$container && t.attachEvent(\"onGanttRender\", e, { once: !0 });\n  });\n  var a = [];\n  t._touch_events = function(r, s, o) {\n    var l, d = 0, c = !1, u = !1, h = null, g = null, p = null, y = [], v = null;\n    let b = {};\n    for (var _ = 0; _ < a.length; _++) t.eventRemove(a[_][0], a[_][1], a[_][2]);\n    (a = []).push([t.$container, r[0], function(f) {\n      var k = i();\n      if (!o(f) && c) {\n        g && clearTimeout(g);\n        var x = s(f);\n        if (k && (k.drag.id || k.drag.start_drag)) return k.on_mouse_move(x), f.preventDefault && f.preventDefault(), f.cancelBubble = !0, !1;\n        if (!t._prevent_touch_scroll) {\n          if (x && h) {\n            var $ = h.pageX - x.pageX, w = h.pageY - x.pageY;\n            if (!u && (Math.abs($) > 5 || Math.abs(w) > 5) && (u = !0, d = 0, l = v ? n(v) : t.getScrollState()), u) {\n              var S, T = l.x + $, E = l.y + w;\n              if (v ? (function(C, D, M) {\n                var I = C.$config.scrollX ? t.$ui.getView(C.$config.scrollX) : null, A = C.$config.scrollY ? t.$ui.getView(C.$config.scrollY) : null;\n                I && I.scrollTo(D, null), A && A.scrollTo(null, M);\n              }(v, T, E), S = n(v)) : (t.scrollTo(T, E), S = t.getScrollState()), l.x != S.x && w > 2 * $ || l.y != S.y && $ > 2 * w) return m(f);\n            }\n          }\n          return m(f);\n        }\n        return !0;\n      }\n    }]);\n    try {\n      document.addEventListener(\"touchmove\", function(f) {\n        t._touch_drag && m(f);\n      }, { passive: !1 });\n    } catch {\n      console.warn(\"Cannot prevent touch event for the page drag\");\n    }\n    for (a.push([this.$container, \"contextmenu\", function(f) {\n      if (c) return m(f);\n    }]), a.push([this.$container, r[1], function(f) {\n      if (b = f.touches.length, document && document.body && document.body.classList.add(\"gantt_touch_active\"), !o(f)) if (f.touches && f.touches.length > 1) c = !1;\n      else {\n        h = s(f), v = function(x) {\n          for (var $ = t.$layout.getCellsByType(\"viewCell\"), w = 0; w < $.length; w++) {\n            var S = $[w].$view.getBoundingClientRect();\n            if (x.clientX >= S.left && x.clientX <= S.right && x.clientY <= S.bottom && x.clientY >= S.top) return $[w];\n          }\n        }(h), t._locate_css(h, \"gantt_hor_scroll\") || t._locate_css(h, \"gantt_ver_scroll\") || (c = !0);\n        var k = i();\n        g = setTimeout(function() {\n          var x = t.locate(h);\n          k && x && !t._locate_css(h, \"gantt_link_control\") && !t._locate_css(h, \"gantt_grid_data\") && (k.on_mouse_down(h), k.drag && k.drag.start_drag && (function($) {\n            const w = t._getTaskLayers();\n            let S = t.getTask($);\n            if (S) {\n              let T = t.isTaskVisible($);\n              if (T) {\n                p = $;\n                for (let E = 0; E < w.length; E++) if (S = w[E].rendered[$], S && S.getAttribute(t.config.task_attribute) && S.getAttribute(t.config.task_attribute) == $) {\n                  const C = S.cloneNode(!0);\n                  y.push(S), w[E].rendered[$] = C, S.style.display = \"none\", C.className += \" gantt_drag_move \", S.parentNode.appendChild(C);\n                }\n              } else if (S.$split_subtask) {\n                let E = S.$rendered_parent;\n                if (T = t.isTaskVisible(E), !T) return;\n                p = $;\n                for (let C = 0; C < w.length; C++) {\n                  const D = w[C].rendered[E];\n                  let M;\n                  if (D && D.childNodes && (M = D.querySelector(`[${t.config.task_attribute}=\"${S.id}\"]`)), M) {\n                    const I = M.cloneNode(!0);\n                    M.parentNode.appendChild(I), t.$task_bars.appendChild(M), M.style.display = \"none\", y.push(M), M = null;\n                  }\n                }\n              }\n            }\n          }(x), k._start_dnd(h), t._touch_drag = !0, t.refreshTask(x), t._touch_feedback())), g = null;\n        }, t.config.touch_drag);\n      }\n    }]), a.push([this.$container, r[2], function(f) {\n      if (document && document.body && document.body.classList.remove(\"gantt_touch_active\"), !o(f)) {\n        g && clearTimeout(g), t._touch_drag = !1, c = !1;\n        var k = s(f), x = i();\n        if (x && x.on_mouse_up(k), p && t.isTaskExists(p) && (t.refreshTask(p), y.length && (y.forEach(function(w) {\n          w.parentNode && w.parentNode.removeChild(w);\n        }), t._touch_feedback())), c = u = !1, y = [], p = null, h && d) {\n          var $ = /* @__PURE__ */ new Date();\n          $ - d < 500 && b <= 1 ? (t.$services.getService(\"mouseEvents\").onDoubleClick(h), m(f)) : d = $;\n        } else d = /* @__PURE__ */ new Date();\n      }\n    }]), _ = 0; _ < a.length; _++) t.event(a[_][0], a[_][1], a[_][2]);\n    function m(f) {\n      return f && f.preventDefault && f.cancelable && f.preventDefault(), f.cancelBubble = !0, !1;\n    }\n  };\n}\nfunction Ft() {\n  console.log(\"Method is not implemented.\");\n}\nfunction Mt() {\n}\nfunction ht(t) {\n  return Mt;\n}\nMt.prototype.render = Ft, Mt.prototype.set_value = Ft, Mt.prototype.get_value = Ft, Mt.prototype.focus = Ft;\nvar $n = { getHtmlSelect: function(t, e, n) {\n  var i = \"\", a = this;\n  return kt(t = t || [], function(r) {\n    var s = [{ key: \"value\", value: r.key }];\n    n == r.key && (s[s.length] = { key: \"selected\", value: \"selected\" }), r.attributes && (s = s.concat(r.attributes)), i += a.getHtmlOption({ innerHTML: r.label }, s);\n  }), Dt(\"select\", { innerHTML: i }, e);\n}, getHtmlOption: function(t, e) {\n  return Dt(\"option\", t, e);\n}, getHtmlButton: function(t, e) {\n  return Dt(\"button\", t, e);\n}, getHtmlDiv: function(t, e) {\n  return Dt(\"div\", t, e);\n}, getHtmlLabel: function(t, e) {\n  return Dt(\"label\", t, e);\n}, getHtmlInput: function(t) {\n  return \"<input\" + wn(t || []) + \">\";\n} };\nfunction Dt(t, e, n) {\n  return e = e || [], \"<\" + t + wn(n || []) + \">\" + (e.innerHTML || \"\") + \"</\" + t + \">\";\n}\nfunction wn(t) {\n  var e = \"\";\n  return kt(t, function(n) {\n    e += \" \" + n.key + \"='\" + n.value + \"'\";\n  }), e;\n}\nfunction qt(t) {\n  const e = ht();\n  function n() {\n    return e.apply(this, arguments) || this;\n  }\n  return z(n, e), n.prototype.render = function(i) {\n    const a = i.height ? `height:${i.height}px;` : \"\";\n    let r = `<div class='gantt_cal_ltext gantt_section_${i.name}' ${a ? `style='${a}'` : \"\"}>`;\n    return r += $n.getHtmlSelect(i.options, [{ key: \"style\", value: \"width:100%;\" }, { key: \"title\", value: i.name }]), r += \"</div>\", r;\n  }, n.prototype.set_value = function(i, a, r, s) {\n    var o = i.firstChild;\n    !o._dhx_onchange && s.onchange && (o.onchange = s.onchange, o._dhx_onchange = !0), a === void 0 && (a = (o.options[0] || {}).value), o.value = a || \"\";\n  }, n.prototype.get_value = function(i) {\n    return i.firstChild.value;\n  }, n.prototype.focus = function(i) {\n    var a = i.firstChild;\n    t._focus(a, !0);\n  }, n;\n}\nfunction Ya(t) {\n  var e = qt(t);\n  function n() {\n    return e.apply(this, arguments) || this;\n  }\n  function i(a, r) {\n    var s = [], o = [];\n    r && (s = t.getTaskByTime(), a.allow_root && s.unshift({ id: t.config.root_id, text: a.root_label || \"\" }), s = function(u, h, g) {\n      var p = h.filter || function() {\n        return !0;\n      };\n      u = u.slice(0);\n      for (var y = 0; y < u.length; y++) {\n        var v = u[y];\n        (v.id == g || t.isChildOf(v.id, g) || p(v.id, v) === !1) && (u.splice(y, 1), y--);\n      }\n      return u;\n    }(s, a, r), a.sort && s.sort(a.sort));\n    for (var l = a.template || t.templates.task_text, d = 0; d < s.length; d++) {\n      var c = l.apply(t, [s[d].start_date, s[d].end_date, s[d]]);\n      c === void 0 && (c = \"\"), o.push({ key: s[d].id, label: c });\n    }\n    return a.options = o, a.map_to = a.map_to || \"parent\", t.form_blocks.select.render.apply(this, arguments);\n  }\n  return z(n, e), n.prototype.render = function(a) {\n    return i(a, !1);\n  }, n.prototype.set_value = function(a, r, s, o) {\n    r === 0 && (r = \"0\"), !s.id && t.getState().lightbox && (s.id = t.getLightboxValues().id);\n    var l = document.createElement(\"div\");\n    l.innerHTML = i(o, s.id);\n    var d = l.removeChild(l.firstChild);\n    return a.onselect = null, a.parentNode.replaceChild(d, a), t.form_blocks.select.set_value.apply(t, [d, r, s, o]);\n  }, n;\n}\nfunction Ja(t) {\n  var e = function() {\n    const _ = ht();\n    function m() {\n      return _.apply(this, arguments) || this;\n    }\n    return z(m, _), m.prototype.render = function(f) {\n      let k = f.height ? `${f.height}px` : \"\";\n      return `<div class='gantt_cal_ltext gantt_cal_template gantt_section_${f.name}' ${k ? `style='height:${k};'` : \"\"}></div>`;\n    }, m.prototype.set_value = function(f, k) {\n      f.innerHTML = k || \"\";\n    }, m.prototype.get_value = function(f) {\n      return f.innerHTML || \"\";\n    }, m.prototype.focus = function() {\n    }, m;\n  }(), n = function(_) {\n    const m = ht();\n    function f() {\n      return m.apply(this, arguments) || this;\n    }\n    return z(f, m), f.prototype.render = function(k) {\n      const x = (k.height || \"130\") + \"px\", $ = k.placeholder ? `placeholder='${k.placeholder}'` : \"\";\n      return `<div class='gantt_cal_ltext gantt_section_${k.name}' style='height:${x};' ${$}><textarea></textarea></div>`;\n    }, f.prototype.set_value = function(k, x) {\n      _.form_blocks.textarea._get_input(k).value = x || \"\";\n    }, f.prototype.get_value = function(k) {\n      return _.form_blocks.textarea._get_input(k).value;\n    }, f.prototype.focus = function(k) {\n      var x = _.form_blocks.textarea._get_input(k);\n      _._focus(x, !0);\n    }, f.prototype._get_input = function(k) {\n      return k.querySelector(\"textarea\");\n    }, f;\n  }(t), i = function(_) {\n    const m = ht();\n    function f() {\n      return m.apply(this, arguments) || this;\n    }\n    return z(f, m), f.prototype.render = function(k) {\n      var x = _.form_blocks.getTimePicker.call(this, k);\n      let $ = \"gantt_section_time\";\n      k.name !== \"time\" && ($ += \" gantt_section_\" + k.name);\n      var w = \"<div style='padding-top:0px;font-size:inherit;text-align:center;' class='\" + $ + \"'>\";\n      return w += x, k.single_date ? (x = _.form_blocks.getTimePicker.call(this, k, !0), w += \"<span></span>\") : w += \"<span class='gantt_section_time_spacer'> &nbsp;&ndash;&nbsp; </span>\", (w += x) + \"</div>\";\n    }, f.prototype.set_value = function(k, x, $, w) {\n      var S = w, T = k.getElementsByTagName(\"select\"), E = w._time_format_order;\n      if (S.auto_end_date) for (var C = function() {\n        I = new Date(T[E[2]].value, T[E[1]].value, T[E[0]].value, 0, 0), A = _.calculateEndDate({ start_date: I, duration: 1, task: $ }), _.form_blocks._fill_lightbox_select(T, E.size, A, E, S);\n      }, D = 0; D < 4; D++) T[D].onchange = C;\n      var M = _._resolve_default_mapping(w);\n      typeof M == \"string\" && (M = { start_date: M });\n      var I = $[M.start_date] || /* @__PURE__ */ new Date(), A = $[M.end_date] || _.calculateEndDate({ start_date: I, duration: 1, task: $ });\n      _.form_blocks._fill_lightbox_select(T, 0, I, E, S), _.form_blocks._fill_lightbox_select(T, E.size, A, E, S);\n    }, f.prototype.get_value = function(k, x, $) {\n      var w, S = k.getElementsByTagName(\"select\"), T = $._time_format_order;\n      return w = _.form_blocks.getTimePickerValue(S, $), typeof _._resolve_default_mapping($) == \"string\" ? w : { start_date: w, end_date: function(E, C, D) {\n        var M = _.form_blocks.getTimePickerValue(E, $, C.size);\n        return M <= D && ($.autofix_end !== !1 || $.single_date) ? _.date.add(D, _._get_timepicker_step(), \"minute\") : M;\n      }(S, T, w) };\n    }, f.prototype.focus = function(k) {\n      _._focus(k.getElementsByTagName(\"select\")[0]);\n    }, f;\n  }(t), a = qt(t), r = function(_) {\n    var m = ht();\n    function f() {\n      return m.apply(this, arguments) || this;\n    }\n    return z(f, m), f.prototype.render = function(k) {\n      const x = k.height ? `height:${k.height}px;` : \"\";\n      let $ = `<div class='gantt_cal_ltext gantt_cal_lcheckbox gantt_section_${k.name}' ${x ? `style='${x}'` : \"\"}>`;\n      if (k.options && k.options.length) for (var w = 0; w < k.options.length; w++) $ += \"<label><input type='checkbox' value='\" + k.options[w].key + \"' name='\" + k.name + \"'>\" + k.options[w].label + \"</label>\";\n      else k.single_value = !0, $ += \"<label><input type='checkbox' name='\" + k.name + \"'></label>\";\n      return $ += \"</div>\", $;\n    }, f.prototype.set_value = function(k, x, $, w) {\n      var S = Array.prototype.slice.call(k.querySelectorAll(\"input[type=checkbox]\"));\n      !k._dhx_onchange && w.onchange && (k.onchange = w.onchange, k._dhx_onchange = !0), w.single_value ? S[0].checked = !!x : kt(S, function(T) {\n        T.checked = !!x && x.indexOf(T.value) >= 0;\n      });\n    }, f.prototype.get_value = function(k, x, $) {\n      return $.single_value ? k.querySelector(\"input[type=checkbox]\").checked : function(w, S) {\n        if (w.map) return w.map(S);\n        for (var T = w.slice(), E = [], C = 0; C < T.length; C++) E.push(S(T[C], C));\n        return E;\n      }(Array.prototype.slice.call(k.querySelectorAll(\"input[type=checkbox]:checked\")), function(w) {\n        return w.value;\n      });\n    }, f.prototype.focus = function(k) {\n      _._focus(k.querySelector(\"input[type=checkbox]\"));\n    }, f;\n  }(t), s = function(_) {\n    const m = ht();\n    function f() {\n      return m.apply(this, arguments) || this;\n    }\n    return z(f, m), f.prototype.render = function(k) {\n      const x = k.height ? `${k.height}px` : \"\";\n      let $ = `<div class='gantt_cal_ltext gantt_cal_lradio gantt_section_${k.name}' ${x ? `style='height:${x};'` : \"\"}>`;\n      if (k.options && k.options.length) for (var w = 0; w < k.options.length; w++) $ += \"<label><input type='radio' value='\" + k.options[w].key + \"' name='\" + k.name + \"'>\" + k.options[w].label + \"</label>\";\n      return $ += \"</div>\", $;\n    }, f.prototype.set_value = function(k, x, $, w) {\n      var S;\n      w.options && w.options.length && (S = k.querySelector(\"input[type=radio][value='\" + x + \"']\") || k.querySelector(\"input[type=radio][value='\" + w.default_value + \"']\")) && (!k._dhx_onchange && w.onchange && (k.onchange = w.onchange, k._dhx_onchange = !0), S.checked = !0);\n    }, f.prototype.get_value = function(k, x) {\n      var $ = k.querySelector(\"input[type=radio]:checked\");\n      return $ ? $.value : \"\";\n    }, f.prototype.focus = function(k) {\n      _._focus(k.querySelector(\"input[type=radio]\"));\n    }, f;\n  }(t), o = function(_) {\n    var m = ht();\n    function f() {\n      return m.apply(this, arguments) || this;\n    }\n    function k(w) {\n      return w.formatter || new Pt();\n    }\n    function x(w, S) {\n      var T = w.getElementsByTagName(\"select\"), E = S._time_format_order, C = 0, D = 0;\n      if (_.defined(E[3])) {\n        var M = T[E[3]], I = parseInt(M.value, 10);\n        isNaN(I) && M.hasAttribute(\"data-value\") && (I = parseInt(M.getAttribute(\"data-value\"), 10)), C = Math.floor(I / 60), D = I % 60;\n      }\n      return new Date(T[E[2]].value, T[E[1]].value, T[E[0]].value, C, D);\n    }\n    function $(w, S) {\n      var T = w.getElementsByTagName(\"input\")[1];\n      return (T = k(S).parse(T.value)) && !window.isNaN(T) || (T = 1), T < 0 && (T *= -1), T;\n    }\n    return z(f, m), f.prototype.render = function(w) {\n      var S = \"<div class='gantt_time_selects'>\" + _.form_blocks.getTimePicker.call(this, w) + \"</div>\", T = \" \" + _.locale.labels[_.config.duration_unit + \"s\"] + \" \", E = w.single_date ? \" style='display:none'\" : \"\", C = w.readonly ? \" disabled='disabled'\" : \"\", D = _._waiAria.lightboxDurationInputAttrString(w), M = \"gantt_duration_value\";\n      w.formatter && (T = \"\", M += \" gantt_duration_value_formatted\");\n      var I = \"<div class='gantt_duration' \" + E + \"><div class='gantt_duration_inputs'><input type='button' class='gantt_duration_dec' value=''\" + C + \"><input type='text' value='5days' class='\" + M + \"'\" + C + \" \" + D + \"><input type='button' class='gantt_duration_inc' value='+'\" + C + \"></div><div class='gantt_duration_end_date'>\" + T + \"<span></span></div></div></div>\";\n      let A = \"gantt_section_time gantt_section_duration\";\n      return w.name !== \"time\" && (A += \" gantt_section_\" + w.name), \"<div style='padding-top:0px;font-size:inherit;' class='\" + A + \"'>\" + S + \" \" + I + \"</div>\";\n    }, f.prototype.set_value = function(w, S, T, E) {\n      var C, D, M, I, A = w.getElementsByTagName(\"select\"), N = w.getElementsByTagName(\"input\"), L = N[1], O = [N[0], N[2]], G = w.getElementsByTagName(\"span\")[0], j = E._time_format_order;\n      function H() {\n        var J = x.call(_, w, E), B = $.call(_, w, E), _t = _.calculateEndDate({ start_date: J, duration: B, task: T }), Tt = _.templates.task_end_date || _.templates.task_date;\n        G.innerHTML = Tt(_t);\n      }\n      function Q(J) {\n        var B = L.value;\n        B = k(E).parse(B), window.isNaN(B) && (B = 0), (B += J) < 1 && (B = 1), L.value = k(E).format(B), H();\n      }\n      O[0].onclick = _.bind(function() {\n        Q(-1 * _.config.duration_step);\n      }, this), O[1].onclick = _.bind(function() {\n        Q(1 * _.config.duration_step);\n      }, this), A[0].onchange = H, A[1].onchange = H, A[2].onchange = H, A[3] && (A[3].onchange = H), L.onkeydown = _.bind(function(J) {\n        var B;\n        return (B = (J = J || window.event).charCode || J.keyCode || J.which) == _.constants.KEY_CODES.DOWN ? (Q(-1 * _.config.duration_step), !1) : B == _.constants.KEY_CODES.UP ? (Q(1 * _.config.duration_step), !1) : void window.setTimeout(H, 1);\n      }, this), L.onchange = _.bind(H, this), typeof (C = _._resolve_default_mapping(E)) == \"string\" && (C = { start_date: C }), D = T[C.start_date] || /* @__PURE__ */ new Date(), M = T[C.end_date] || _.calculateEndDate({ start_date: D, duration: 1, task: T }), I = Math.round(T[C.duration]) || _.calculateDuration({ start_date: D, end_date: M, task: T }), I = k(E).format(I), _.form_blocks._fill_lightbox_select(A, 0, D, j, E), L.value = I, H();\n    }, f.prototype.get_value = function(w, S, T) {\n      var E = x(w, T), C = $(w, T), D = _.calculateEndDate({ start_date: E, duration: C, task: S });\n      return typeof _._resolve_default_mapping(T) == \"string\" ? E : { start_date: E, end_date: D, duration: C };\n    }, f.prototype.focus = function(w) {\n      _._focus(w.getElementsByTagName(\"select\")[0]);\n    }, f;\n  }(t), l = Ya(t), d = qt(t), c = function(_) {\n    var m = ht();\n    function f() {\n      return m.apply(this, arguments) || this;\n    }\n    function k($) {\n      return !$ || $ === _.config.constraint_types.ASAP || $ === _.config.constraint_types.ALAP;\n    }\n    function x($, w) {\n      for (var S = k(w), T = 0; T < $.length; T++) $[T].disabled = S;\n    }\n    return z(f, m), f.prototype.render = function($) {\n      const w = $.height ? `height:${$.height}px;` : \"\";\n      let S = `<div class='gantt_cal_ltext gantt_section_${$.name}' ${w ? `style='${w}'` : \"\"}>`;\n      var T = [];\n      for (var E in _.config.constraint_types) T.push({ key: _.config.constraint_types[E], label: _.locale.labels[_.config.constraint_types[E]] });\n      return $.options = $.options || T, S += \"<span data-constraint-type-select>\" + $n.getHtmlSelect($.options, [{ key: \"data-type\", value: \"constraint-type\" }]) + \"</span>\", S += \"<label data-constraint-time-select>\" + (_.locale.labels.constraint_date || \"Constraint date\") + \": \" + _.form_blocks.getTimePicker.call(this, $) + \"</label>\", S += \"</div>\", S;\n    }, f.prototype.set_value = function($, w, S, T) {\n      var E = $.querySelector(\"[data-constraint-type-select] select\"), C = $.querySelectorAll(\"[data-constraint-time-select] select\"), D = T._time_format_order, M = _._resolve_default_mapping(T);\n      E._eventsInitialized || (E.addEventListener(\"change\", function(N) {\n        x(C, N.target.value);\n      }), E._eventsInitialized = !0);\n      var I = S[M.constraint_date] || /* @__PURE__ */ new Date();\n      _.form_blocks._fill_lightbox_select(C, 0, I, D, T);\n      var A = S[M.constraint_type] || _.getConstraintType(S);\n      E.value = A, x(C, A);\n    }, f.prototype.get_value = function($, w, S) {\n      var T = $.querySelector(\"[data-constraint-type-select] select\"), E = $.querySelectorAll(\"[data-constraint-time-select] select\"), C = T.value, D = null;\n      return k(C) || (D = _.form_blocks.getTimePickerValue(E, S)), { constraint_type: C, constraint_date: D };\n    }, f.prototype.focus = function($) {\n      _._focus($.querySelector(\"select\"));\n    }, f;\n  }(t), u = function(_) {\n    const m = qt(_);\n    function f() {\n      return m.apply(this, arguments) || this;\n    }\n    return z(f, m), f.prototype.render = function(k) {\n      var x = _.config.types, $ = _.locale.labels, w = [], S = k.filter || function(C, D) {\n        return !x.placeholder || D !== x.placeholder;\n      };\n      for (var T in x) !S(T, x[T]) == 0 && w.push({ key: x[T], label: $[\"type_\" + T] });\n      k.options = w;\n      var E = k.onchange;\n      return k.onchange = function() {\n        _._lightbox_current_type = this.value, _.changeLightboxType(this.value), typeof E == \"function\" && E.apply(this, arguments);\n      }, m.prototype.render.apply(this, arguments);\n    }, f;\n  }(t), h = function(_) {\n    var m = ht();\n    function f() {\n      return m.apply(this, arguments) || this;\n    }\n    function k(S) {\n      return S.formatter || new Pt();\n    }\n    function x(S, T, E, C) {\n      const D = \"<div class='gantt_time_selects'>\" + _.form_blocks.getTimePicker.call(_, C) + \"</div>\";\n      let M = \" \" + _.locale.labels[_.config.duration_unit + \"s\"] + \" \";\n      const I = C.single_date ? \" style='display:none'\" : \"\", A = C.readonly ? \" disabled='disabled'\" : \"\", N = _._waiAria.lightboxDurationInputAttrString(C), L = _.locale.labels.baselines_remove_button;\n      let O = \"gantt_duration_value\";\n      C.formatter && (M = \"\", O += \" gantt_duration_value_formatted\");\n      const G = \"<div class='gantt_duration' \" + I + \"><div class='gantt_duration_inputs'><input type='button' class='gantt_duration_dec' value=''\" + A + \"><input type='text' value='5days' class='\" + O + \"'\" + A + \" \" + N + \"><input type='button' class='gantt_duration_inc' value='+'\" + A + \"></div><div class='gantt_duration_end_date'>\" + M + \"<span></span></div></div></div>\", j = `<div><div class='baseline_delete_button gantt_custom_button'>${L}</div></div>`, H = document.createElement(\"div\");\n      H.className = \"gantt_section_time gantt_section_duration\", H.setAttribute(\"data-baseline-id\", T.id), H.innerHTML = D + G + j + \"<br>\", S.appendChild(H);\n      var Q, J, B, _t = H.getElementsByTagName(\"select\"), Tt = H.getElementsByTagName(\"input\"), Et = Tt[1], Ee = [Tt[0], Tt[2]], Sn = H.getElementsByTagName(\"span\")[0], Tn = C._time_format_order;\n      function gt() {\n        var ut = $.call(_, H, C), U = w.call(_, H, C), En = _.calculateEndDate({ start_date: ut, duration: U, task: E }), Cn = _.templates.task_end_date || _.templates.task_date;\n        Sn.innerHTML = Cn(En);\n      }\n      function Ot(ut) {\n        var U = Et.value;\n        U = k(C).parse(U), window.isNaN(U) && (U = 0), (U += ut) < 1 && (U = 1), Et.value = k(C).format(U), gt();\n      }\n      H.querySelector(\".baseline_delete_button\").onclick = function(ut) {\n        const U = H.parentNode;\n        H.innerHTML = \"\", H.remove(), U.innerHTML === \"\" && (U.innerHTML = _.locale.labels.baselines_section_placeholder);\n      }, Ee[0].onclick = _.bind(function() {\n        Ot(-1 * _.config.duration_step);\n      }, _), Ee[1].onclick = _.bind(function() {\n        Ot(1 * _.config.duration_step);\n      }, _), _t[0].onchange = gt, _t[1].onchange = gt, _t[2].onchange = gt, _t[3] && (_t[3].onchange = gt), Et.onkeydown = _.bind(function(ut) {\n        var U;\n        return (U = (ut = ut || window.event).charCode || ut.keyCode || ut.which) == _.constants.KEY_CODES.DOWN ? (Ot(-1 * _.config.duration_step), !1) : U == _.constants.KEY_CODES.UP ? (Ot(1 * _.config.duration_step), !1) : void window.setTimeout(gt, 1);\n      }, _), Et.onchange = _.bind(gt, _), _._resolve_default_mapping(C), Q = T.start_date || /* @__PURE__ */ new Date(), J = T.end_date || _.calculateEndDate({ start_date: Q, duration: 1, task: E }), B = _.calculateDuration({ start_date: Q, end_date: J, task: E }), B = k(C).format(B), _.form_blocks._fill_lightbox_select(_t, 0, Q, Tn, C), Et.value = B, gt();\n    }\n    function $(S, T) {\n      var E = S.getElementsByTagName(\"select\"), C = T._time_format_order, D = 0, M = 0;\n      if (_.defined(C[3])) {\n        var I = E[C[3]], A = parseInt(I.value, 10);\n        isNaN(A) && I.hasAttribute(\"data-value\") && (A = parseInt(I.getAttribute(\"data-value\"), 10)), D = Math.floor(A / 60), M = A % 60;\n      }\n      return new Date(E[C[2]].value, E[C[1]].value, E[C[0]].value, D, M);\n    }\n    function w(S, T) {\n      var E = S.getElementsByTagName(\"input\")[1];\n      return (E = k(T).parse(E.value)) && !window.isNaN(E) || (E = 1), E < 0 && (E *= -1), E;\n    }\n    return z(f, m), f.prototype.render = function(S) {\n      return `<div style='height: ${S.height || 100}px; padding-top:0px; font-size:inherit;' class='gantt_section_baselines'></div>`;\n    }, f.prototype.set_value = function(S, T, E, C) {\n      E.baselines ? (S.innerHTML = \"\", E.baselines.forEach((D) => {\n        x(S, D, E, C);\n      })) : S.innerHTML = _.locale.labels.baselines_section_placeholder;\n    }, f.prototype.get_value = function(S, T, E) {\n      const C = [];\n      return S.querySelectorAll(\"[data-baseline-id]\").forEach((D) => {\n        const M = D.dataset.baselineId;\n        let I, A = _.getDatastore(\"baselines\").getItem(M);\n        I = A ? _.copy(A) : { id: _.uid(), task_id: T.id, text: \"Baseline 1\" }, I.start_date = $(D, E), I.duration = w(D, E), I.end_date = _.calculateEndDate({ start_date: I.start_date, duration: I.duration, task: T }), C.push(I);\n      }), C;\n    }, f.prototype.button_click = function(S, T, E, C) {\n      if (_.callEvent(\"onSectionButton\", [_._lightbox_id, E]) !== !1 && (T.closest(\".gantt_custom_button.gantt_remove_baselines\") && (C.innerHTML = _.locale.labels.baselines_section_placeholder), T.closest(\".gantt_custom_button.gantt_add_baselines\"))) {\n        C.innerHTML == _.locale.labels.baselines_section_placeholder && (C.innerHTML = \"\");\n        const D = _.getTask(_._lightbox_id);\n        x(C, { id: _.uid(), task_id: D.id, start_date: D.start_date, end_date: D.end_date }, D, _._get_typed_lightbox_config()[S]);\n      }\n    }, f.prototype.focus = function(S) {\n      _._focus(S.getElementsByTagName(\"select\")[0]);\n    }, f;\n  }(t);\n  t._lightbox_methods = {}, t._lightbox_template = \"<div class='gantt_cal_ltitle'><span class='gantt_mark'>&nbsp;</span><span class='gantt_time'></span><span class='gantt_title'></span></div><div class='gantt_cal_larea'></div>\", t._lightbox_template = `<div class='gantt_cal_ltitle'><div class=\"dhx_cal_ltitle_descr\"><span class='gantt_mark'>&nbsp;</span><span class='gantt_time'></span><span class='dhx_title'></span>\n</div>\n<div class=\"gantt_cal_ltitle_controls\">\n\t<a class=\"gantt_cal_ltitle_close_btn dhx_gantt_icon dhx_gantt_icon_close\"></a>\n\n</div></div><div class='gantt_cal_larea'></div>`, t._lightbox_root = t.$root, t.$services.getService(\"state\").registerProvider(\"lightbox\", function() {\n    return { lightbox: t._lightbox_id };\n  }), t.showLightbox = function(_) {\n    var m = this.getTask(_);\n    if (this.callEvent(\"onBeforeLightbox\", [_])) {\n      var f = this.getLightbox(this.getTaskType(m.type));\n      this.showCover(f), this._fill_lightbox(_, f), this._setLbPosition(f), this._waiAria.lightboxVisibleAttr(f), this.callEvent(\"onLightbox\", [_]);\n    } else t.isTaskExists(_) && t.getTask(_).$new && this.$data.tasksStore._updateOrder();\n  }, t._get_timepicker_step = function() {\n    if (this.config.round_dnd_dates) {\n      var _;\n      if (function(f) {\n        var k = f.$ui.getView(\"timeline\");\n        return !(!k || !k.isVisible());\n      }(this)) {\n        var m = t.getScale();\n        _ = Vt(m.unit) * m.step / 60;\n      }\n      return (!_ || _ >= 1440) && (_ = this.config.time_step), _;\n    }\n    return this.config.time_step;\n  }, t.getLabel = function(_, m) {\n    for (var f = this._get_typed_lightbox_config(), k = 0; k < f.length; k++) if (f[k].map_to == _) {\n      for (var x = f[k].options, $ = 0; $ < x.length; $++) if (x[$].key == m) return x[$].label;\n    }\n    return \"\";\n  }, t.updateCollection = function(_, m) {\n    m = m.slice(0);\n    var f = t.serverList(_);\n    if (!f) return !1;\n    f.splice(0, f.length), f.push.apply(f, m || []), t.resetLightbox();\n  }, t.getLightboxType = function() {\n    return this.getTaskType(this._lightbox_type);\n  }, t.getLightbox = function(_) {\n    var m, f, k, x, $, w = \"\";\n    if (function() {\n      const T = t.config.csp === !0, E = !!window.Sfdc || !!window.$A || window.Aura || \"$shadowResolver$\" in document.body;\n      t._lightbox_root = T || E ? t.$root : document.body;\n    }(), _ === void 0 && (_ = this.getLightboxType()), !this._lightbox || this.getLightboxType() != this.getTaskType(_)) {\n      this._lightbox_type = this.getTaskType(_), m = document.createElement(\"div\"), w = \"gantt_cal_light\", f = this._is_lightbox_timepicker(), t.config.wide_form && (w += \" gantt_cal_light_wide\"), f && (w += \" gantt_cal_light_full\"), m.className = w, m.style.visibility = \"hidden\", k = this._lightbox_template, k += \"<div class='gantt_cal_lcontrols'>\", k += y(this.config.buttons_left), k += \"<div class='gantt_cal_lcontrols_push_right'></div>\", k += y(this.config.buttons_right), k += \"</div>\", m.innerHTML = k, t._waiAria.lightboxAttr(m), t.config.drag_lightbox && (m.firstChild.onmousedown = t._ready_to_dnd, m.firstChild.ontouchstart = function(T) {\n        t._ready_to_dnd(T.touches[0]);\n      }, m.firstChild.onselectstart = function() {\n        return !1;\n      }, m.firstChild.style.cursor = \"pointer\", t._init_dnd_events()), this._lightbox && this.resetLightbox(), g(), this._cover.insertBefore(m, this._cover.firstChild), this._lightbox = m, x = this._get_typed_lightbox_config(_), k = this._render_sections(x);\n      var S = ($ = m.querySelector(\"div.gantt_cal_larea\")).style.overflow;\n      $.style.overflow = \"hidden\", $.innerHTML = k, function(T) {\n        var E, C, D, M, I, A;\n        for (A = 0; A < T.length; A++) E = T[A], D = t._lightbox_root.querySelector(\"#\" + E.id), E.id && D && (C = D.querySelector(\"label\"), (M = D.nextSibling) && (I = M.querySelector(\"input, select, textarea\")) && (I.id = I.id || \"input_\" + t.uid(), E.inputId = I.id, C.setAttribute(\"for\", E.inputId)));\n      }(x), $.style.overflow = S, this._init_lightbox_events(this), m.style.display = \"none\", m.style.visibility = \"visible\";\n    }\n    return this._lightbox;\n  }, t._render_sections = function(_) {\n    for (var m = \"\", f = 0; f < _.length; f++) {\n      var k = this.form_blocks[_[f].type];\n      if (k) {\n        _[f].id = \"area_\" + this.uid();\n        var x = _[f].hidden ? \" style='display:none'\" : \"\", $ = \"\";\n        _[f].button && ($ = \"<div class='gantt_custom_button' data-index='\" + f + \"'><div class='gantt_custom_button_\" + _[f].button + \"'></div><div class='gantt_custom_button_label'>\" + this.locale.labels[\"button_\" + _[f].button] + \"</div></div>\"), _[f].type == \"baselines\" && ($ = \"<div class='gantt_custom_button gantt_remove_baselines' data-index='\" + f + \"'><div class='gantt_custom_button_delete_baselines'></div><div class='gantt_custom_button_label'>\" + this.locale.labels.baselines_remove_all_button + \"</div></div><div class='gantt_custom_button gantt_add_baselines' data-index='\" + f + \"'><div class='gantt_custom_button_add_baseline'></div><div class='gantt_custom_button_label'>\" + this.locale.labels.baselines_add_button + \"</div></div>\"), this.config.wide_form && (m += \"<div class='gantt_wrap_section' \" + x + \">\"), m += \"<div id='\" + _[f].id + \"' class='gantt_cal_lsection'><label>\" + $ + (_[f].label || this.locale.labels[\"section_\" + _[f].name] || _[f].name) + \"</label></div>\" + k.render.call(this, _[f]), m += \"</div>\";\n      }\n    }\n    return m;\n  }, t._center_lightbox = function(_) {\n    t._setLbPosition(_);\n  }, t._setLbPosition = function(_) {\n    if (!_) return;\n    const m = t._lightbox_root || t.$root;\n    _.style.top = Math.max(m.offsetHeight / 2 - _.offsetHeight / 2, 0) + \"px\", _.style.left = Math.max(m.offsetWidth / 2 - _.offsetWidth / 2, 0) + \"px\";\n  }, t.showCover = function(_) {\n    _ && (_.style.display = \"block\", this._setLbPosition(_)), g(), this._cover.style.display = \"\";\n  };\n  const g = function() {\n    t._cover || (t._cover = document.createElement(\"div\"), t._cover.className = \"gantt_cal_cover\", t._cover.style.display = \"none\", t.event(t._cover, \"mousemove\", t._move_while_dnd), t.event(t._cover, \"mouseup\", t._finish_dnd), (t._lightbox_root || t.$root).appendChild(t._cover));\n  };\n  function p(_) {\n    for (var m in this.config.types) if (this.config.types[m] == _) return m;\n    return \"task\";\n  }\n  function y(_, m) {\n    var f, k, x = \"\";\n    for (k = 0; k < _.length; k++) f = t.config._migrate_buttons[_[k]] ? t.config._migrate_buttons[_[k]] : _[k], x += \"<div \" + t._waiAria.lightboxButtonAttrString(f) + \" class='gantt_btn_set gantt_left_btn_set \" + f + \"_set'><div dhx_button='1' data-dhx-button='1' class='\" + f + \"'></div><div>\" + t.locale.labels[f] + \"</div></div>\";\n    return x;\n  }\n  function v(_) {\n    var m, f;\n    return _.time_format ? _.time_format : (f = [\"%d\", \"%m\", \"%Y\"], Vt((m = t.getScale()) ? m.unit : t.config.duration_unit) < Vt(\"day\") && f.push(\"%H:%i\"), f);\n  }\n  function b(_, m, f) {\n    var k, x, $, w, S, T, E = \"\";\n    switch (f.timeFormat[m]) {\n      case \"%Y\":\n        for (_._time_format_order[2] = m, _._time_format_order.size++, _.year_range && (isNaN(_.year_range) ? _.year_range.push && ($ = _.year_range[0], w = _.year_range[1]) : k = _.year_range), k = k || 10, x = x || Math.floor(k / 2), $ = $ || f.date.getFullYear() - x, w = w || t.getState().max_date.getFullYear() + x, S = $; S <= w; S++) E += \"<option value='\" + S + \"'>\" + S + \"</option>\";\n        break;\n      case \"%m\":\n        for (_._time_format_order[1] = m, _._time_format_order.size++, S = 0; S < 12; S++) E += \"<option value='\" + S + \"'>\" + t.locale.date.month_full[S] + \"</option>\";\n        break;\n      case \"%d\":\n        for (_._time_format_order[0] = m, _._time_format_order.size++, S = 1; S < 32; S++) E += \"<option value='\" + S + \"'>\" + S + \"</option>\";\n        break;\n      case \"%H:%i\":\n        for (_._time_format_order[3] = m, _._time_format_order.size++, S = f.first, T = f.date.getDate(), _._time_values = []; S < f.last; ) E += \"<option value='\" + S + \"'>\" + t.templates.time_picker(f.date) + \"</option>\", _._time_values.push(S), f.date.setTime(f.date.valueOf() + 60 * t._get_timepicker_step() * 1e3), S = 24 * (f.date.getDate() != T ? 1 : 0) * 60 + 60 * f.date.getHours() + f.date.getMinutes();\n    }\n    return E;\n  }\n  t._init_lightbox_events = function() {\n    t.lightbox_events = {}, t.lightbox_events.gantt_save_btn = function() {\n      t._save_lightbox();\n    }, t.lightbox_events.gantt_delete_btn = function() {\n      t._lightbox_current_type = null, t.callEvent(\"onLightboxDelete\", [t._lightbox_id]) && (t.isTaskExists(t._lightbox_id) ? t.$click.buttons.delete(t._lightbox_id) : t.hideLightbox());\n    }, t.lightbox_events.gantt_cancel_btn = function() {\n      t._cancel_lightbox();\n    }, t.lightbox_events.default = function(_, m) {\n      if (m.getAttribute(\"data-dhx-button\")) t.callEvent(\"onLightboxButton\", [m.className, m, _]);\n      else {\n        var f, k, x = X(m);\n        if (x.indexOf(\"gantt_custom_button\") != -1) if (x.indexOf(\"gantt_custom_button_\") != -1) for (f = m.parentNode.getAttribute(\"data-index\"), k = m; k && X(k).indexOf(\"gantt_cal_lsection\") == -1; ) k = k.parentNode;\n        else f = m.getAttribute(\"data-index\"), k = m.closest(\".gantt_cal_lsection\"), m = m.firstChild;\n        var $ = t._get_typed_lightbox_config();\n        f && (f *= 1, t.form_blocks[$[1 * f].type].button_click(f, m, k, k.nextSibling));\n      }\n    }, this.event(t.getLightbox(), \"click\", function(_) {\n      _.target.closest(\".gantt_cal_ltitle_close_btn\") && t._cancel_lightbox();\n      var m = yt(_), f = X(m);\n      return f || (f = X(m = m.previousSibling)), m && f && f.indexOf(\"gantt_btn_set\") === 0 && (f = X(m = m.firstChild)), !(!m || !f) && (t.defined(t.lightbox_events[m.className]) ? t.lightbox_events[m.className] : t.lightbox_events.default)(_, m);\n    }), t.getLightbox().onkeydown = function(_) {\n      var m = _ || window.event, f = _.target || _.srcElement, k = X(f).indexOf(\"gantt_btn_set\") > -1;\n      switch ((_ || m).keyCode) {\n        case t.constants.KEY_CODES.SPACE:\n          if ((_ || m).shiftKey) return;\n          k && f.click && f.click();\n          break;\n        case t.keys.edit_save:\n          if ((_ || m).shiftKey) return;\n          k && f.click ? f.click() : t._save_lightbox();\n          break;\n        case t.keys.edit_cancel:\n          t._cancel_lightbox();\n      }\n    };\n  }, t._cancel_lightbox = function() {\n    var _ = this.getLightboxValues();\n    t._lightbox_current_type = null, this.callEvent(\"onLightboxCancel\", [this._lightbox_id, _.$new]), t.isTaskExists(_.id) && _.$new && (this.silent(function() {\n      t.$data.tasksStore.removeItem(_.id), t._update_flags(_.id, null);\n    }), this.refreshData()), this.hideLightbox();\n  }, t._save_lightbox = function() {\n    var _ = this.getLightboxValues();\n    t._lightbox_current_type = null, this.callEvent(\"onLightboxSave\", [this._lightbox_id, _, !!_.$new]) && (t.$data.tasksStore._skipTaskRecalculation = \"lightbox\", _.$new ? (delete _.$new, this.addTask(_, _.parent, this.getTaskIndex(_.id))) : this.isTaskExists(_.id) && (this.mixin(this.getTask(_.id), _, !0), this.refreshTask(_.id), this.updateTask(_.id)), t.$data.tasksStore._skipTaskRecalculation = !1, this.refreshData(), this.hideLightbox());\n  }, t._resolve_default_mapping = function(_) {\n    var m = _.map_to;\n    return { time: !0, time_optional: !0, duration: !0, duration_optional: !0 }[_.type] ? _.map_to == \"auto\" ? m = { start_date: \"start_date\", end_date: \"end_date\", duration: \"duration\" } : typeof _.map_to == \"string\" && (m = { start_date: _.map_to }) : _.type === \"constraint\" && (_.map_to && typeof _.map_to != \"string\" || (m = { constraint_type: \"constraint_type\", constraint_date: \"constraint_date\" })), m;\n  }, t.getLightboxValues = function() {\n    var _ = {};\n    t.isTaskExists(this._lightbox_id) && (_ = this.mixin({}, this.getTask(this._lightbox_id)));\n    for (var m = this._get_typed_lightbox_config(), f = 0; f < m.length; f++) {\n      var k = t._lightbox_root.querySelector(\"#\" + m[f].id);\n      k = k && k.nextSibling;\n      var x = this.form_blocks[m[f].type];\n      if (x) {\n        var $ = x.get_value.call(this, k, _, m[f]), w = t._resolve_default_mapping(m[f]);\n        if (typeof w == \"string\" && w != \"auto\") _[w] = $;\n        else if (typeof w == \"object\") for (var S in w) w[S] && (_[w[S]] = $[S]);\n      }\n    }\n    return t._lightbox_current_type && (_.type = t._lightbox_current_type), _;\n  }, t.hideLightbox = function() {\n    var _ = this.getLightbox();\n    _ && (_.style.display = \"none\"), this._waiAria.lightboxHiddenAttr(_), this._lightbox_id = null, this.hideCover(_), this.resetLightbox(), this.callEvent(\"onAfterLightbox\", []);\n  }, t.hideCover = function(_) {\n    _ && (_.style.display = \"none\"), this._cover && this._cover.parentNode.removeChild(this._cover), this._cover = null;\n  }, t.resetLightbox = function() {\n    t._lightbox && !t._custom_lightbox && t._lightbox.remove(), t._lightbox = null;\n  }, t._set_lightbox_values = function(_, m) {\n    var f = _, k = m.getElementsByTagName(\"span\"), x = [];\n    t.templates.lightbox_header ? (x.push(\"\"), x.push(t.templates.lightbox_header(f.start_date, f.end_date, f)), k[1].innerHTML = \"\", k[2].innerHTML = t.templates.lightbox_header(f.start_date, f.end_date, f)) : (x.push(this.templates.task_time(f.start_date, f.end_date, f)), x.push(String(this.templates.task_text(f.start_date, f.end_date, f) || \"\").substr(0, 70)), k[1].innerHTML = this.templates.task_time(f.start_date, f.end_date, f), k[2].innerHTML = String(this.templates.task_text(f.start_date, f.end_date, f) || \"\").substr(0, 70)), k[1].innerHTML = x[0], k[2].innerHTML = x[1], t._waiAria.lightboxHeader(m, x.join(\" \"));\n    for (var $ = this._get_typed_lightbox_config(this.getLightboxType()), w = 0; w < $.length; w++) {\n      var S = $[w];\n      if (this.form_blocks[S.type]) {\n        var T = t._lightbox_root.querySelector(\"#\" + S.id).nextSibling, E = this.form_blocks[S.type], C = t._resolve_default_mapping($[w]), D = this.defined(f[C]) ? f[C] : S.default_value;\n        E.set_value.call(t, T, D, f, S), S.focus && E.focus.call(t, T);\n      }\n    }\n    t.isTaskExists(_.id) && (t._lightbox_id = _.id);\n  }, t._fill_lightbox = function(_, m) {\n    var f = this.getTask(_);\n    this._set_lightbox_values(f, m);\n  }, t.getLightboxSection = function(_) {\n    for (var m = this._get_typed_lightbox_config(), f = 0; f < m.length && m[f].name != _; f++) ;\n    var k = m[f];\n    if (!k) return null;\n    this._lightbox || this.getLightbox();\n    var x = t._lightbox_root.querySelector(\"#\" + k.id), $ = x.nextSibling, w = { section: k, header: x, node: $, getValue: function(T) {\n      return t.form_blocks[k.type].get_value.call(t, $, T || {}, k);\n    }, setValue: function(T, E) {\n      return t.form_blocks[k.type].set_value.call(t, $, T, E || {}, k);\n    } }, S = this._lightbox_methods[\"get_\" + k.type + \"_control\"];\n    return S ? S(w) : w;\n  }, t._lightbox_methods.get_template_control = function(_) {\n    return _.control = _.node, _;\n  }, t._lightbox_methods.get_select_control = function(_) {\n    return _.control = _.node.getElementsByTagName(\"select\")[0], _;\n  }, t._lightbox_methods.get_textarea_control = function(_) {\n    return _.control = _.node.getElementsByTagName(\"textarea\")[0], _;\n  }, t._lightbox_methods.get_time_control = function(_) {\n    return _.control = _.node.getElementsByTagName(\"select\"), _;\n  }, t._init_dnd_events = function() {\n    var _ = t._lightbox_root;\n    this.event(_, \"mousemove\", t._move_while_dnd), this.event(_, \"mouseup\", t._finish_dnd), this.event(_, \"touchmove\", function(m) {\n      t._move_while_dnd(m.touches[0]);\n    }), this.event(_, \"touchend\", function(m) {\n      t._finish_dnd(m.touches[0]);\n    });\n  }, t._move_while_dnd = function(_) {\n    if (t._dnd_start_lb) {\n      document.gantt_unselectable || (t._lightbox_root.className += \" gantt_unselectable\", document.gantt_unselectable = !0);\n      var m = t.getLightbox(), f = [_.pageX, _.pageY];\n      m.style.top = t._lb_start[1] + f[1] - t._dnd_start_lb[1] + \"px\", m.style.left = t._lb_start[0] + f[0] - t._dnd_start_lb[0] + \"px\";\n    }\n  }, t._ready_to_dnd = function(_) {\n    var m = t.getLightbox();\n    t._lb_start = [m.offsetLeft, m.offsetTop], t._dnd_start_lb = [_.pageX, _.pageY];\n  }, t._finish_dnd = function() {\n    t._lb_start && (t._lb_start = t._dnd_start_lb = !1, t._lightbox_root.className = t._lightbox_root.className.replace(\" gantt_unselectable\", \"\"), document.gantt_unselectable = !1);\n  }, t._focus = function(_, m) {\n    if (_ && _.focus && !t.config.touch) try {\n      m && _.select && _.select(), _.focus();\n    } catch {\n    }\n  }, t.form_blocks = { getTimePicker: function(_, m) {\n    var f, k, x, $ = \"\", w = this.config, S = { first: 0, last: 1440, date: this.date.date_part(new Date(t._min_date.valueOf())), timeFormat: v(_) };\n    for (_._time_format_order = { size: 0 }, t.config.limit_time_select && (S.first = 60 * w.first_hour, S.last = 60 * w.last_hour + 1, S.date.setHours(w.first_hour)), f = 0; f < S.timeFormat.length; f++) f > 0 && ($ += \" \"), (k = b(_, f, S)) && (x = t._waiAria.lightboxSelectAttrString(S.timeFormat[f]), $ += \"<select \" + (_.readonly ? \"disabled='disabled'\" : \"\") + (m ? \" style='display:none' \" : \"\") + x + \">\" + k + \"</select>\");\n    return $;\n  }, getTimePickerValue: function(_, m, f) {\n    var k, x = m._time_format_order, $ = 0, w = 0, S = f || 0;\n    return t.defined(x[3]) && (k = parseInt(_[x[3] + S].value, 10), $ = Math.floor(k / 60), w = k % 60), new Date(_[x[2] + S].value, _[x[1] + S].value, _[x[0] + S].value, $, w);\n  }, _fill_lightbox_select: function(_, m, f, k) {\n    if (_[m + k[0]].value = f.getDate(), _[m + k[1]].value = f.getMonth(), _[m + k[2]].value = f.getFullYear(), t.defined(k[3])) {\n      var x = 60 * f.getHours() + f.getMinutes();\n      x = Math.round(x / t._get_timepicker_step()) * t._get_timepicker_step();\n      var $ = _[m + k[3]];\n      $.value = x, $.setAttribute(\"data-value\", x);\n    }\n  }, template: new e(), textarea: new n(), select: new a(), time: new i(), duration: new o(), parent: new l(), radio: new s(), checkbox: new r(), resources: new d(), constraint: new c(), baselines: new h(), typeselect: new u() }, t._is_lightbox_timepicker = function() {\n    for (var _ = this._get_typed_lightbox_config(), m = 0; m < _.length; m++) if (_[m].name == \"time\" && _[m].type == \"time\") return !0;\n    return !1;\n  }, t._delete_task_confirm = function({ task: _, message: m, title: f, callback: k, ok: x }) {\n    t._simple_confirm(m, f, k, x);\n  }, t._delete_link_confirm = function({ link: _, message: m, title: f, callback: k, ok: x }) {\n    t._simple_confirm(m, f, k, x);\n  }, t._simple_confirm = function(_, m, f, k) {\n    if (!_) return f();\n    var x = { text: _ };\n    m && (x.title = m), k && (x.ok = k), f && (x.callback = function($) {\n      $ && f();\n    }), t.confirm(x);\n  }, t._get_typed_lightbox_config = function(_) {\n    _ === void 0 && (_ = this.getLightboxType());\n    var m = p.call(this, _);\n    return t.config.lightbox[m + \"_sections\"] ? t.config.lightbox[m + \"_sections\"] : t.config.lightbox.sections;\n  }, t._silent_redraw_lightbox = function(_) {\n    var m = this.getLightboxType();\n    if (this.getState().lightbox) {\n      var f = this.getState().lightbox, k = this.getLightboxValues(), x = this.copy(this.getTask(f));\n      this.resetLightbox();\n      var $ = this.mixin(x, k, !0), w = this.getLightbox(_ || void 0);\n      this._set_lightbox_values($, w), this.showCover(w);\n    } else this.resetLightbox(), this.getLightbox(_ || void 0);\n    this.callEvent(\"onLightboxChange\", [m, this.getLightboxType()]);\n  };\n}\nfunction Ka(t) {\n  if (!mt.isNode) {\n    t.utils = { arrayFind: Ln, dom: rn };\n    var e = Se();\n    t.event = e.attach, t.eventRemove = e.detach, t._eventRemoveAll = e.detachAll, t._createDomEventScope = e.extend, P(t, sa(t));\n    var n = ja.init(t);\n    t.$ui = n.factory, t.$ui.layers = n.render, t.$mouseEvents = n.mouseEvents, t.$services.setService(\"mouseEvents\", function() {\n      return t.$mouseEvents;\n    }), t.mixin(t, n.layersApi), function(i) {\n      delete i.addTaskLayer, delete i.addLinkLayer;\n    }(t), t.$services.setService(\"layers\", function() {\n      return n.layersService;\n    }), t.mixin(t, /* @__PURE__ */ function() {\n      function i(u) {\n        return u.$ui.getView(\"timeline\");\n      }\n      function a(u) {\n        return u.$ui.getView(\"grid\");\n      }\n      function r(u) {\n        var h = i(u);\n        if (h && !h.$config.hidden) return h;\n        var g = a(u);\n        return g && !g.$config.hidden ? g : null;\n      }\n      function s(u) {\n        var h = null, g = !1;\n        return [\".gantt_drag_marker.gantt_grid_resize_area\", \".gantt_drag_marker .gantt_row.gantt_row_task\", \".gantt_drag_marker.gantt_grid_dnd_marker\"].forEach(function(p) {\n          g = g || !!document.querySelector(p);\n        }), (h = g ? a(u) : r(u)) ? l(u, h, \"scrollY\") : null;\n      }\n      function o(u) {\n        var h = r(u);\n        return h && h.id != \"grid\" ? l(u, h, \"scrollX\") : null;\n      }\n      function l(u, h, g) {\n        var p = h.$config[g];\n        return u.$ui.getView(p);\n      }\n      var d = \"DEFAULT_VALUE\";\n      function c(u, h, g, p) {\n        var y = u(this);\n        return y && y.isVisible() ? y[h].apply(y, g) : p ? p() : d;\n      }\n      return { getColumnIndex: function(u) {\n        var h = c.call(this, a, \"getColumnIndex\", [u]);\n        return h === d ? 0 : h;\n      }, dateFromPos: function(u) {\n        var h = c.call(this, i, \"dateFromPos\", Array.prototype.slice.call(arguments));\n        return h === d ? this.getState().min_date : h;\n      }, posFromDate: function(u) {\n        var h = c.call(this, i, \"posFromDate\", [u]);\n        return h === d ? 0 : h;\n      }, getRowTop: function(u) {\n        var h = this, g = c.call(h, i, \"getRowTop\", [u], function() {\n          return c.call(h, a, \"getRowTop\", [u]);\n        });\n        return g === d ? 0 : g;\n      }, getTaskTop: function(u) {\n        var h = this, g = c.call(h, i, \"getItemTop\", [u], function() {\n          return c.call(h, a, \"getItemTop\", [u]);\n        });\n        return g === d ? 0 : g;\n      }, getTaskPosition: function(u, h, g) {\n        var p = c.call(this, i, \"getItemPosition\", [u, h, g]);\n        return p === d ? { left: 0, top: this.getTaskTop(u.id), height: this.getTaskBarHeight(u.id), width: 0 } : p;\n      }, getTaskBarHeight: function(u, h) {\n        var g = this, p = c.call(g, i, \"getBarHeight\", [u, h], function() {\n          return c.call(g, a, \"getItemHeight\", [u]);\n        });\n        return p === d ? 0 : p;\n      }, getTaskHeight: function(u) {\n        var h = this, g = c.call(h, i, \"getItemHeight\", [u], function() {\n          return c.call(h, a, \"getItemHeight\", [u]);\n        });\n        return g === d ? 0 : g;\n      }, columnIndexByDate: function(u) {\n        var h = c.call(this, i, \"columnIndexByDate\", [u]);\n        return h === d ? 0 : h;\n      }, roundTaskDates: function() {\n        c.call(this, i, \"roundTaskDates\", []);\n      }, getScale: function() {\n        var u = c.call(this, i, \"getScale\", []);\n        return u === d ? null : u;\n      }, getTaskNode: function(u) {\n        var h = i(this);\n        if (h && h.isVisible()) {\n          var g = h._taskRenderer.rendered[u];\n          if (!g) {\n            var p = h.$config.item_attribute;\n            g = h.$task_bars.querySelector(\"[\" + p + \"='\" + u + \"']\");\n          }\n          return g || null;\n        }\n        return null;\n      }, getLinkNode: function(u) {\n        var h = i(this);\n        return h.isVisible() ? h._linkRenderer.rendered[u] : null;\n      }, scrollTo: function(u, h) {\n        var g = s(this), p = o(this), y = { position: 0 }, v = { position: 0 };\n        g && (v = g.getScrollState()), p && (y = p.getScrollState());\n        var b = p && 1 * u == u, _ = g && 1 * h == h;\n        if (b && _) for (var m = g._getLinkedViews(), f = p._getLinkedViews(), k = [], x = 0; x < m.length; x++) for (var $ = 0; $ < f.length; $++) m[x].$config.id && f[$].$config.id && m[x].$config.id === f[$].$config.id && k.push(m[x].$config.id);\n        b && (k && k.forEach((function(T) {\n          this.$ui.getView(T).$config.$skipSmartRenderOnScroll = !0;\n        }).bind(this)), p.scroll(u), k && k.forEach((function(T) {\n          this.$ui.getView(T).$config.$skipSmartRenderOnScroll = !1;\n        }).bind(this))), _ && g.scroll(h);\n        var w = { position: 0 }, S = { position: 0 };\n        g && (w = g.getScrollState()), p && (S = p.getScrollState()), this.callEvent(\"onGanttScroll\", [y.position, v.position, S.position, w.position]);\n      }, showDate: function(u) {\n        var h = this.posFromDate(u), g = Math.max(h - this.config.task_scroll_offset, 0);\n        this.scrollTo(g);\n      }, showTask: function(u) {\n        var h = this.getTaskPosition(this.getTask(u)), g = h.left;\n        this.config.rtl && (g = h.left + h.width);\n        var p, y = Math.max(g - this.config.task_scroll_offset, 0), v = this._scroll_state().y;\n        p = v ? h.top - (v - this.getTaskBarHeight(u)) / 2 : h.top, this.scrollTo(y, p);\n        var b = a(this), _ = i(this);\n        b && _ && b.$config.scrollY != _.$config.scrollY && l(this, b, \"scrollY\").scrollTo(null, p);\n      }, _scroll_state: function() {\n        var u = { x: !1, y: !1, x_pos: 0, y_pos: 0, scroll_size: this.config.scroll_size + 1, x_inner: 0, y_inner: 0 }, h = s(this), g = o(this);\n        if (g) {\n          var p = g.getScrollState();\n          p.visible && (u.x = p.size, u.x_inner = p.scrollSize), u.x_pos = p.position || 0;\n        }\n        if (h) {\n          var y = h.getScrollState();\n          y.visible && (u.y = y.size, u.y_inner = y.scrollSize), u.y_pos = y.position || 0;\n        }\n        return u;\n      }, getScrollState: function() {\n        var u = this._scroll_state();\n        return { x: u.x_pos, y: u.y_pos, inner_width: u.x, inner_height: u.y, width: u.x_inner, height: u.y_inner };\n      }, getLayoutView: function(u) {\n        return this.$ui.getView(u);\n      }, scrollLayoutCell: function(u, h, g) {\n        const p = this.$ui.getView(u);\n        if (!p) return !1;\n        if (h !== null) {\n          const y = this.$ui.getView(p.$config.scrollX);\n          y && y.scrollTo(h, null);\n        }\n        if (g !== null) {\n          const y = this.$ui.getView(p.$config.scrollY);\n          y && y.scrollTo(null, g);\n        }\n      } };\n    }()), function(i) {\n      i.resetSkin || (i.resetSkin = function() {\n        this.skin = \"\", ce(!0, this);\n      }, i.skins = {}, i.attachEvent(\"onGanttLayoutReady\", function() {\n        ce(!1, this), r();\n      })), i._addThemeClass = function() {\n        document.documentElement.setAttribute(\"data-gantt-theme\", i.skin);\n      }, i.setSkin = function(s) {\n        const o = this.skin !== s;\n        this.skin = s, i._addThemeClass(), r(), i.$root && (ce(!o, i), this.render());\n      };\n      let a = null;\n      function r() {\n        const s = i.$root;\n        a && clearInterval(a), s && (a = setInterval(() => {\n          const o = getComputedStyle(s).getPropertyValue(\"--dhx-gantt-theme\");\n          o && o !== i.skin && i.setSkin(o);\n        }, 100));\n      }\n      i.attachEvent(\"onDestroy\", function() {\n        clearInterval(a);\n      });\n    }(t), function(i) {\n      i.skins.skyblue = { config: { grid_width: 370, row_height: 27, bar_height_padding: 4, scale_height: 27, link_line_width: 1, link_arrow_size: 8, link_radius: 2, lightbox_additional_height: 75 }, _second_column_width: 95, _third_column_width: 80 };\n    }(t), function(i) {\n      i.skins.dark = { config: { grid_width: 390, row_height: 36, scale_height: 36, link_line_width: 2, link_arrow_size: 12, bar_height_padding: 9, lightbox_additional_height: 75 }, _second_column_width: 100, _third_column_width: 70 };\n    }(t), function(i) {\n      i.skins.meadow = { config: { grid_width: 380, row_height: 27, scale_height: 30, link_line_width: 2, link_arrow_size: 10, bar_height_padding: 4, lightbox_additional_height: 72 }, _second_column_width: 95, _third_column_width: 80 };\n    }(t), function(i) {\n      i.skins.terrace = { config: { grid_width: 390, row_height: 36, scale_height: 36, link_line_width: 2, link_arrow_size: 12, bar_height_padding: 9, lightbox_additional_height: 75 }, _second_column_width: 100, _third_column_width: 70 };\n    }(t), function(i) {\n      i.skins.broadway = { config: { grid_width: 390, row_height: 35, scale_height: 35, link_line_width: 1, link_arrow_size: 9, bar_height_padding: 4, lightbox_additional_height: 86 }, _second_column_width: 100, _third_column_width: 80, _lightbox_template: \"<div class='gantt_cal_ltitle'><span class='gantt_mark'>&nbsp;</span><span class='gantt_time'></span><span class='gantt_title'></span><div class='gantt_cancel_btn'></div></div><div class='gantt_cal_larea'></div>\", _config_buttons_left: {}, _config_buttons_right: { gantt_delete_btn: \"icon_delete\", gantt_save_btn: \"icon_save\" } };\n    }(t), function(i) {\n      i.skins.material = { config: { grid_width: 411, row_height: 34, scale_height: 36, link_line_width: 2, link_arrow_size: 12, bar_height_padding: 9, lightbox_additional_height: 80 }, _second_column_width: 110, _third_column_width: 75, _redefine_lightbox_buttons: { buttons_left: [\"dhx_delete_btn\"], buttons_right: [\"dhx_cancel_btn\", \"dhx_save_btn\"] } }, i.attachEvent(\"onAfterTaskDrag\", function(a) {\n        var r = i.getTaskNode(a);\n        r && (r.className += \" gantt_drag_animation\", setTimeout(function() {\n          var s = r.className.indexOf(\" gantt_drag_animation\");\n          s > -1 && (r.className = r.className.slice(0, s));\n        }, 200));\n      });\n    }(t), function(i) {\n      i.skins.contrast_black = { config: { grid_width: 390, row_height: 35, scale_height: 35, link_line_width: 2, link_arrow_size: 12, lightbox_additional_height: 75 }, _second_column_width: 100, _third_column_width: 80 };\n    }(t), function(i) {\n      i.skins.contrast_white = { config: { grid_width: 390, row_height: 35, scale_height: 35, link_line_width: 2, link_arrow_size: 12, lightbox_additional_height: 75 }, _second_column_width: 100, _third_column_width: 80 };\n    }(t), function(i) {\n      i.ext || (i.ext = {});\n      for (var a = [Fa, null, null], r = 0; r < a.length; r++) a[r] && a[r](i);\n      i.ext.zoom = new qa(i);\n    }(t), Ga(t), Ja(t), function(i) {\n      i._extend_to_optional = function(a) {\n        var r = a, s = { render: r.render, focus: r.focus, set_value: function(o, l, d, c) {\n          var u = i._resolve_default_mapping(c);\n          if (!d[u.start_date] || u.start_date == \"start_date\" && this._isAllowedUnscheduledTask(d)) {\n            s.disable(o, c);\n            var h = {};\n            for (var g in u) h[u[g]] = d[g];\n            return r.set_value.call(i, o, l, h, c);\n          }\n          return s.enable(o, c), r.set_value.call(i, o, l, d, c);\n        }, get_value: function(o, l, d) {\n          return d.disabled ? { start_date: null } : r.get_value.call(i, o, l, d);\n        }, update_block: function(o, l) {\n          if (i.callEvent(\"onSectionToggle\", [i._lightbox_id, l]), o.style.display = l.disabled ? \"none\" : \"\", l.button) {\n            var d = o.previousSibling.querySelector(\".gantt_custom_button_label\"), c = i.locale.labels, u = l.disabled ? c[l.name + \"_enable_button\"] : c[l.name + \"_disable_button\"];\n            d.innerHTML = u;\n          }\n        }, disable: function(o, l) {\n          l.disabled = !0, s.update_block(o, l);\n        }, enable: function(o, l) {\n          l.disabled = !1, s.update_block(o, l);\n        }, button_click: function(o, l, d, c) {\n          if (i.callEvent(\"onSectionButton\", [i._lightbox_id, d]) !== !1) {\n            var u = i._get_typed_lightbox_config()[o];\n            u.disabled ? s.enable(c, u) : s.disable(c, u);\n          }\n        } };\n        return s;\n      }, i.form_blocks.duration_optional = i._extend_to_optional(i.form_blocks.duration), i.form_blocks.time_optional = i._extend_to_optional(i.form_blocks.time);\n    }(t), function(i) {\n      var a = new RegExp(`<(?:.|\n)*?>`, \"gm\"), r = new RegExp(\" +\", \"gm\");\n      function s(c) {\n        return (c + \"\").replace(a, \" \").replace(r, \" \");\n      }\n      var o = new RegExp(\"'\", \"gm\");\n      function l(c) {\n        return (c + \"\").replace(o, \"&#39;\");\n      }\n      for (var d in i._waiAria = { getAttributeString: function(c) {\n        var u = [\" \"];\n        for (var h in c) {\n          var g = l(s(c[h]));\n          u.push(h + \"='\" + g + \"'\");\n        }\n        return u.push(\" \"), u.join(\" \");\n      }, getTimelineCellAttr: function(c) {\n        return i._waiAria.getAttributeString({ \"aria-label\": c });\n      }, _taskCommonAttr: function(c, u) {\n        c.start_date && c.end_date && (u.setAttribute(\"aria-label\", s(i.templates.tooltip_text(c.start_date, c.end_date, c))), c.$dataprocessor_class && u.setAttribute(\"aria-busy\", !0));\n      }, setTaskBarAttr: function(c, u) {\n        this._taskCommonAttr(c, u), u.setAttribute(\"role\", \"img\"), !i.isReadonly(c) && i.config.drag_move && (c.id != i.getState(\"tasksDnd\").drag_id ? u.setAttribute(\"aria-grabbed\", !1) : u.setAttribute(\"aria-grabbed\", !0));\n      }, taskRowAttr: function(c, u) {\n        this._taskCommonAttr(c, u), !i.isReadonly(c) && i.config.order_branch && u.setAttribute(\"aria-grabbed\", !1), u.setAttribute(\"role\", \"row\"), u.setAttribute(\"aria-selected\", i.isSelectedTask(c.id) ? \"true\" : \"false\"), u.setAttribute(\"aria-level\", c.$level + 1 || 1), i.hasChild(c.id) && u.setAttribute(\"aria-expanded\", c.$open ? \"true\" : \"false\");\n      }, linkAttr: function(c, u) {\n        var h = i.config.links, g = c.type == h.finish_to_start || c.type == h.start_to_start, p = c.type == h.start_to_start || c.type == h.start_to_finish, y = i.locale.labels.link + \" \" + i.templates.drag_link(c.source, p, c.target, g);\n        u.setAttribute(\"role\", \"img\"), u.setAttribute(\"aria-label\", s(y));\n      }, gridSeparatorAttr: function(c) {\n        c.setAttribute(\"role\", \"columnheader\");\n      }, rowResizerAttr: function(c) {\n        c.setAttribute(\"role\", \"row\");\n      }, lightboxHiddenAttr: function(c) {\n        c.setAttribute(\"aria-hidden\", \"true\");\n      }, lightboxVisibleAttr: function(c) {\n        c.setAttribute(\"aria-hidden\", \"false\");\n      }, lightboxAttr: function(c) {\n        c.setAttribute(\"role\", \"dialog\"), c.setAttribute(\"aria-hidden\", \"true\"), c.firstChild.setAttribute(\"role\", \"heading\"), c.firstChild.setAttribute(\"aria-level\", \"1\");\n      }, lightboxButtonAttrString: function(c) {\n        return this.getAttributeString({ role: \"button\", \"aria-label\": i.locale.labels[c], tabindex: \"0\" });\n      }, lightboxHeader: function(c, u) {\n        c.setAttribute(\"aria-label\", u);\n      }, lightboxSelectAttrString: function(c) {\n        var u = \"\";\n        switch (c) {\n          case \"%Y\":\n            u = i.locale.labels.years;\n            break;\n          case \"%m\":\n            u = i.locale.labels.months;\n            break;\n          case \"%d\":\n            u = i.locale.labels.days;\n            break;\n          case \"%H:%i\":\n            u = i.locale.labels.hours + i.locale.labels.minutes;\n        }\n        return i._waiAria.getAttributeString({ \"aria-label\": u });\n      }, lightboxDurationInputAttrString: function(c) {\n        return this.getAttributeString({ \"aria-label\": i.locale.labels.column_duration, \"aria-valuemin\": \"0\", role: \"spinbutton\" });\n      }, inlineEditorAttr: function(c) {\n        c.setAttribute(\"role\", \"row\");\n      }, gridAttrString: function() {\n        return [\" role='treegrid'\", i.config.multiselect ? \"aria-multiselectable='true'\" : \"aria-multiselectable='false'\", \" \"].join(\" \");\n      }, gridScaleRowAttrString: function() {\n        return \"role='row'\";\n      }, gridScaleCellAttrString: function(c, u) {\n        var h = \"\";\n        if (c.name == \"add\") h = this.getAttributeString({ role: \"columnheader\", \"aria-label\": i.locale.labels.new_task });\n        else {\n          var g = { role: \"columnheader\", \"aria-label\": i.config.external_render && i.config.external_render.isElement(u) ? \"\" : u };\n          i._sort && i._sort.name == c.name && (i._sort.direction == \"asc\" ? g[\"aria-sort\"] = \"ascending\" : g[\"aria-sort\"] = \"descending\"), h = this.getAttributeString(g);\n        }\n        return h;\n      }, gridDataAttrString: function() {\n        return \"role='rowgroup'\";\n      }, reorderMarkerAttr: function(c) {\n        c.setAttribute(\"role\", \"grid\"), c.firstChild.removeAttribute(\"aria-level\"), c.firstChild.setAttribute(\"aria-grabbed\", \"true\");\n      }, gridCellAttrString: function(c, u, h) {\n        var g = { role: \"gridcell\", \"aria-label\": u };\n        return c.editor && !i.isReadonly(h) || (g[\"aria-readonly\"] = !0), this.getAttributeString(g);\n      }, gridAddButtonAttrString: function(c) {\n        return this.getAttributeString({ role: \"button\", \"aria-label\": i.locale.labels.new_task });\n      }, messageButtonAttrString: function(c) {\n        return \"tabindex='0' role='button' aria-label='\" + c + \"'\";\n      }, messageInfoAttr: function(c) {\n        c.setAttribute(\"role\", \"alert\");\n      }, messageModalAttr: function(c, u) {\n        c.setAttribute(\"role\", \"dialog\"), u && c.setAttribute(\"aria-labelledby\", u);\n      }, quickInfoAttr: function(c) {\n        c.setAttribute(\"role\", \"dialog\");\n      }, quickInfoHeaderAttrString: function() {\n        return \" role='heading' aria-level='1' \";\n      }, quickInfoHeader: function(c, u) {\n        c.setAttribute(\"aria-label\", u);\n      }, quickInfoButtonAttrString: function(c) {\n        return i._waiAria.getAttributeString({ role: \"button\", \"aria-label\": c, tabindex: \"0\" });\n      }, tooltipAttr: function(c) {\n        c.setAttribute(\"role\", \"tooltip\");\n      }, tooltipVisibleAttr: function(c) {\n        c.setAttribute(\"aria-hidden\", \"false\");\n      }, tooltipHiddenAttr: function(c) {\n        c.setAttribute(\"aria-hidden\", \"true\");\n      } }, i._waiAria) i._waiAria[d] = /* @__PURE__ */ function(c) {\n        return function() {\n          return i.config.wai_aria_attributes ? c.apply(this, arguments) : \"\";\n        };\n      }(i._waiAria[d]);\n    }(t), t.locate = function(i) {\n      var a = yt(i);\n      if (ct(a, \".gantt_task_row\")) return null;\n      var r = arguments[1] || this.config.task_attribute, s = et(a, r);\n      return s ? s.getAttribute(r) : null;\n    }, t._locate_css = function(i, a, r) {\n      return pt(i, a, r);\n    }, t._locateHTML = function(i, a) {\n      return et(i, a || this.config.task_attribute);\n    };\n  }\n  t.attachEvent(\"onParse\", function() {\n    F(t) || t.attachEvent(\"onGanttRender\", function() {\n      if (t.config.initial_scroll) {\n        var i = t.getTaskByIndex(0), a = i ? i.id : t.config.root_id;\n        t.isTaskExists(a) && t.$task && t.utils.dom.isChildOf(t.$task, t.$container) && t.showTask(a);\n      }\n    }, { once: !0 });\n  }), t.attachEvent(\"onBeforeGanttReady\", function() {\n    this.config.scroll_size || (this.config.scroll_size = Xe() || 15), F(t) || (this._eventRemoveAll(), this.$mouseEvents.reset(), this.resetLightbox());\n  }), t.attachEvent(\"onGanttReady\", function() {\n    !F(t) && t.config.rtl && t.$layout.getCellsByType(\"viewCell\").forEach(function(i) {\n      var a = i.$config.scrollX;\n      if (a) {\n        var r = t.$ui.getView(a);\n        r && r.scrollTo(r.$config.scrollSize, 0);\n      }\n    });\n  }), t.attachEvent(\"onGanttReady\", function() {\n    if (!F(t)) {\n      var i = t.plugins(), a = { auto_scheduling: t.autoSchedule, click_drag: t.ext.clickDrag, critical_path: t.isCriticalTask, drag_timeline: t.ext.dragTimeline, export_api: t.exportToPDF, fullscreen: t.ext.fullscreen, grouping: t.groupBy, keyboard_navigation: t.ext.keyboardNavigation, marker: t.addMarker, multiselect: t.eachSelectedTask, overlay: t.ext.overlay, quick_info: t.templates.quick_info_content, tooltip: t.ext.tooltips, undo: t.undo };\n      for (let r in a) a[r] && !i[r] && console.warn(`You connected the '${r}' extension via an obsolete file. \nTo fix it, you need to remove the obsolete file and connect the extension via the plugins method: https://docs.dhtmlx.com/gantt/api__gantt_plugins.html`);\n    }\n  });\n}\nconst Xa = dt.gantt = function(t) {\n  var e = ra(t);\n  return e.env.isNode || (Ka(e), function(n) {\n    n.load = function(i, a, r) {\n      this._load_url = i, this.assert(arguments.length, \"Invalid load arguments\");\n      var s = \"json\", o = null;\n      return arguments.length >= 3 ? (s = a, o = r) : typeof arguments[1] == \"string\" ? s = arguments[1] : typeof arguments[1] == \"function\" && (o = arguments[1]), this._load_type = s, this.callEvent(\"onLoadStart\", [i, s]), this.ajax.get(i, n.bind(function(l) {\n        this.on_load(l, s), this.callEvent(\"onLoadEnd\", [i, s]), typeof o == \"function\" && o.call(this);\n      }, this));\n    };\n  }(e)), e;\n}(Vn);\n\n//# sourceMappingURL=dhtmlxgantt.es.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9kaHRtbHgtZ2FudHQvY29kZWJhc2UvZGh0bWx4Z2FudHQuZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osV0FBVyxHQUFHO0FBQ2Q7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxpQkFBaUI7QUFDN0I7QUFDQTtBQUNBLFlBQVksNkRBQTZEO0FBQ3pFO0FBQ0E7QUFDQSwrTkFBK04sY0FBYztBQUM3TztBQUNBO0FBQ0EsR0FBRyxVQUFVLGNBQWM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsa0JBQWtCLGFBQWEsWUFBWSxZQUFZLFdBQVcsYUFBYSxpQkFBaUIsa0JBQWtCO0FBQ3pKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxPQUFPO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsR0FBRztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLEdBQUc7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QU87QUFDUCx5Q0FBeUMsd0RBQXdEO0FBQ2pHLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUCwrQ0FBK0MsZ0RBQWdEO0FBQy9GLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssSUFBSSxVQUFVO0FBQ25CLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0EsaUNBQWlDO0FBQ2pDLDJFQUEyRSxFQUFFO0FBQzdFO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNILENBQUM7QUFJQztBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9kaHRtbHgtZ2FudHQvY29kZWJhc2UvZGh0bWx4Z2FudHQuZXMuanM/NTcyNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiogQGxpY2Vuc2VcblxuZGh0bWx4R2FudHQgdi45LjAuMTAgU3RhbmRhcmRcblxuVGhpcyB2ZXJzaW9uIG9mIGRodG1seEdhbnR0IGlzIGRpc3RyaWJ1dGVkIHVuZGVyIEdQTCAyLjAgbGljZW5zZSBhbmQgY2FuIGJlIGxlZ2FsbHkgdXNlZCBpbiBHUEwgcHJvamVjdHMuXG5cblRvIHVzZSBkaHRtbHhHYW50dCBpbiBub24tR1BMIHByb2plY3RzIChhbmQgZ2V0IFBybyB2ZXJzaW9uIG9mIHRoZSBwcm9kdWN0KSwgcGxlYXNlIG9idGFpbiBJbmRpdmlkdWFsLCBDb21tZXJjaWFsLCBFbnRlcnByaXNlIG9yIFVsdGltYXRlIGxpY2Vuc2Ugb24gb3VyIHNpdGUgaHR0cHM6Ly9kaHRtbHguY29tL2RvY3MvcHJvZHVjdHMvZGh0bWx4R2FudHQvI2xpY2Vuc2luZyBvciBjb250YWN0IHVzIGF0IGluZm9AZGh0bWx4LmNvbVxuXG4oYykgWEIgU29mdHdhcmVcblxuKi9cbmZ1bmN0aW9uIFYodCkge1xuICB2YXIgZSA9IDAsIG4gPSAwLCBpID0gMCwgYSA9IDA7XG4gIGlmICh0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCkge1xuICAgIHZhciByID0gdC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgcyA9IGRvY3VtZW50LmJvZHksIG8gPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgfHwgZG9jdW1lbnQuYm9keS5wYXJlbnROb2RlIHx8IGRvY3VtZW50LmJvZHksIGwgPSB3aW5kb3cucGFnZVlPZmZzZXQgfHwgby5zY3JvbGxUb3AgfHwgcy5zY3JvbGxUb3AsIGQgPSB3aW5kb3cucGFnZVhPZmZzZXQgfHwgby5zY3JvbGxMZWZ0IHx8IHMuc2Nyb2xsTGVmdCwgYyA9IG8uY2xpZW50VG9wIHx8IHMuY2xpZW50VG9wIHx8IDAsIHUgPSBvLmNsaWVudExlZnQgfHwgcy5jbGllbnRMZWZ0IHx8IDA7XG4gICAgZSA9IHIudG9wICsgbCAtIGMsIG4gPSByLmxlZnQgKyBkIC0gdSwgaSA9IGRvY3VtZW50LmJvZHkub2Zmc2V0V2lkdGggLSByLnJpZ2h0LCBhID0gZG9jdW1lbnQuYm9keS5vZmZzZXRIZWlnaHQgLSByLmJvdHRvbTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKDsgdDsgKSBlICs9IHBhcnNlSW50KHQub2Zmc2V0VG9wLCAxMCksIG4gKz0gcGFyc2VJbnQodC5vZmZzZXRMZWZ0LCAxMCksIHQgPSB0Lm9mZnNldFBhcmVudDtcbiAgICBpID0gZG9jdW1lbnQuYm9keS5vZmZzZXRXaWR0aCAtIHQub2Zmc2V0V2lkdGggLSBuLCBhID0gZG9jdW1lbnQuYm9keS5vZmZzZXRIZWlnaHQgLSB0Lm9mZnNldEhlaWdodCAtIGU7XG4gIH1cbiAgcmV0dXJuIHsgeTogTWF0aC5yb3VuZChlKSwgeDogTWF0aC5yb3VuZChuKSwgd2lkdGg6IHQub2Zmc2V0V2lkdGgsIGhlaWdodDogdC5vZmZzZXRIZWlnaHQsIHJpZ2h0OiBNYXRoLnJvdW5kKGkpLCBib3R0b206IE1hdGgucm91bmQoYSkgfTtcbn1cbmZ1bmN0aW9uIERuKHQpIHtcbiAgdmFyIGUgPSAhMSwgbiA9ICExO1xuICBpZiAod2luZG93LmdldENvbXB1dGVkU3R5bGUpIHtcbiAgICB2YXIgaSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHQsIG51bGwpO1xuICAgIGUgPSBpLmRpc3BsYXksIG4gPSBpLnZpc2liaWxpdHk7XG4gIH0gZWxzZSB0LmN1cnJlbnRTdHlsZSAmJiAoZSA9IHQuY3VycmVudFN0eWxlLmRpc3BsYXksIG4gPSB0LmN1cnJlbnRTdHlsZS52aXNpYmlsaXR5KTtcbiAgcmV0dXJuIGUgIT0gXCJub25lXCIgJiYgbiAhPSBcImhpZGRlblwiO1xufVxuZnVuY3Rpb24gQW4odCkge1xuICByZXR1cm4gIWlzTmFOKHQuZ2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIikpICYmIDEgKiB0LmdldEF0dHJpYnV0ZShcInRhYmluZGV4XCIpID49IDA7XG59XG5mdW5jdGlvbiBJbih0KSB7XG4gIHJldHVybiAheyBhOiAhMCwgYXJlYTogITAgfVt0Lm5vZGVOYW1lLmxvTG93ZXJDYXNlKCldIHx8ICEhdC5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpO1xufVxuZnVuY3Rpb24gTW4odCkge1xuICByZXR1cm4gIXsgaW5wdXQ6ICEwLCBzZWxlY3Q6ICEwLCB0ZXh0YXJlYTogITAsIGJ1dHRvbjogITAsIG9iamVjdDogITAgfVt0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCldIHx8ICF0Lmhhc0F0dHJpYnV0ZShcImRpc2FibGVkXCIpO1xufVxuZnVuY3Rpb24gTHQodCkge1xuICBmb3IgKHZhciBlID0gdC5xdWVyeVNlbGVjdG9yQWxsKFtcImFbaHJlZl1cIiwgXCJhcmVhW2hyZWZdXCIsIFwiaW5wdXRcIiwgXCJzZWxlY3RcIiwgXCJ0ZXh0YXJlYVwiLCBcImJ1dHRvblwiLCBcImlmcmFtZVwiLCBcIm9iamVjdFwiLCBcImVtYmVkXCIsIFwiW3RhYmluZGV4XVwiLCBcIltjb250ZW50ZWRpdGFibGVdXCJdLmpvaW4oXCIsIFwiKSksIG4gPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChlLCAwKSwgaSA9IDA7IGkgPCBuLmxlbmd0aDsgaSsrKSBuW2ldLiRwb3NpdGlvbiA9IGk7XG4gIGZvciAobi5zb3J0KGZ1bmN0aW9uKHIsIHMpIHtcbiAgICByZXR1cm4gci50YWJJbmRleCA9PT0gMCAmJiBzLnRhYkluZGV4ICE9PSAwID8gMSA6IHIudGFiSW5kZXggIT09IDAgJiYgcy50YWJJbmRleCA9PT0gMCA/IC0xIDogci50YWJJbmRleCA9PT0gcy50YWJJbmRleCA/IHIuJHBvc2l0aW9uIC0gcy4kcG9zaXRpb24gOiByLnRhYkluZGV4IDwgcy50YWJJbmRleCA/IC0xIDogMTtcbiAgfSksIGkgPSAwOyBpIDwgbi5sZW5ndGg7IGkrKykge1xuICAgIHZhciBhID0gbltpXTtcbiAgICAoQW4oYSkgfHwgTW4oYSkgfHwgSW4oYSkpICYmIERuKGEpIHx8IChuLnNwbGljZShpLCAxKSwgaS0tKTtcbiAgfVxuICByZXR1cm4gbjtcbn1cbmZ1bmN0aW9uIFhlKCkge1xuICB2YXIgdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gIHQuc3R5bGUuY3NzVGV4dCA9IFwidmlzaWJpbGl0eTpoaWRkZW47cG9zaXRpb246YWJzb2x1dGU7bGVmdDotMTAwMHB4O3dpZHRoOjEwMHB4O3BhZGRpbmc6MHB4O21hcmdpbjowcHg7aGVpZ2h0OjExMHB4O21pbi1oZWlnaHQ6MTAwcHg7b3ZlcmZsb3cteTpzY3JvbGw7XCIsIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodCk7XG4gIHZhciBlID0gdC5vZmZzZXRXaWR0aCAtIHQuY2xpZW50V2lkdGg7XG4gIHJldHVybiBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHQpLCBNYXRoLm1heChlLCAxNSk7XG59XG5mdW5jdGlvbiBYKHQpIHtcbiAgaWYgKCF0KSByZXR1cm4gXCJcIjtcbiAgdmFyIGUgPSB0LmNsYXNzTmFtZSB8fCBcIlwiO1xuICByZXR1cm4gZS5iYXNlVmFsICYmIChlID0gZS5iYXNlVmFsKSwgZS5pbmRleE9mIHx8IChlID0gXCJcIiksIF9lKGUpO1xufVxuZnVuY3Rpb24gd3QodCwgZSkge1xuICBlICYmIHQuY2xhc3NOYW1lLmluZGV4T2YoZSkgPT09IC0xICYmICh0LmNsYXNzTmFtZSArPSBcIiBcIiArIGUpO1xufVxuZnVuY3Rpb24gR3QodCwgZSkge1xuICBlID0gZS5zcGxpdChcIiBcIik7XG4gIGZvciAodmFyIG4gPSAwOyBuIDwgZS5sZW5ndGg7IG4rKykge1xuICAgIHZhciBpID0gbmV3IFJlZ0V4cChcIlxcXFxzP1xcXFxiXCIgKyBlW25dICsgXCJcXFxcYig/IVstXy5dKVwiLCBcIlwiKTtcbiAgICB0LmNsYXNzTmFtZSA9IHQuY2xhc3NOYW1lLnJlcGxhY2UoaSwgXCJcIik7XG4gIH1cbn1cbmZ1bmN0aW9uIHdlKHQpIHtcbiAgcmV0dXJuIHR5cGVvZiB0ID09IFwic3RyaW5nXCIgPyBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0KSB8fCBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHQpIHx8IGRvY3VtZW50LmJvZHkgOiB0IHx8IGRvY3VtZW50LmJvZHk7XG59XG52YXIgQnQ7XG5mdW5jdGlvbiBaZSh0LCBlKSB7XG4gIEJ0IHx8IChCdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpLCBCdC5pbm5lckhUTUwgPSBlO1xuICB2YXIgbiA9IEJ0LmZpcnN0Q2hpbGQ7XG4gIHJldHVybiB0LmFwcGVuZENoaWxkKG4pLCBuO1xufVxuZnVuY3Rpb24gUWUodCkge1xuICB0ICYmIHQucGFyZW50Tm9kZSAmJiB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodCk7XG59XG5mdW5jdGlvbiB0bih0LCBlKSB7XG4gIGZvciAodmFyIG4gPSB0LmNoaWxkTm9kZXMsIGkgPSBuLmxlbmd0aCwgYSA9IFtdLCByID0gMDsgciA8IGk7IHIrKykge1xuICAgIHZhciBzID0gbltyXTtcbiAgICBzLmNsYXNzTmFtZSAmJiBzLmNsYXNzTmFtZS5pbmRleE9mKGUpICE9PSAtMSAmJiBhLnB1c2gocyk7XG4gIH1cbiAgcmV0dXJuIGE7XG59XG5mdW5jdGlvbiB5dCh0KSB7XG4gIHZhciBlO1xuICByZXR1cm4gdC50YWdOYW1lID8gZSA9IHQgOiAoZSA9ICh0ID0gdCB8fCB3aW5kb3cuZXZlbnQpLnRhcmdldCB8fCB0LnNyY0VsZW1lbnQpLnNoYWRvd1Jvb3QgJiYgdC5jb21wb3NlZFBhdGggJiYgKGUgPSB0LmNvbXBvc2VkUGF0aCgpWzBdKSwgZTtcbn1cbmZ1bmN0aW9uIGV0KHQsIGUpIHtcbiAgaWYgKGUpIHtcbiAgICBmb3IgKHZhciBuID0geXQodCk7IG47ICkge1xuICAgICAgaWYgKG4uZ2V0QXR0cmlidXRlICYmIG4uZ2V0QXR0cmlidXRlKGUpKSByZXR1cm4gbjtcbiAgICAgIG4gPSBuLnBhcmVudE5vZGU7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5mdW5jdGlvbiBfZSh0KSB7XG4gIHJldHVybiAoU3RyaW5nLnByb3RvdHlwZS50cmltIHx8IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnJlcGxhY2UoL15cXHMrfFxccyskL2csIFwiXCIpO1xuICB9KS5hcHBseSh0KTtcbn1cbmZ1bmN0aW9uIHB0KHQsIGUsIG4pIHtcbiAgdmFyIGkgPSB5dCh0KSwgYSA9IFwiXCI7XG4gIGZvciAobiA9PT0gdm9pZCAwICYmIChuID0gITApOyBpOyApIHtcbiAgICBpZiAoYSA9IFgoaSkpIHtcbiAgICAgIHZhciByID0gYS5pbmRleE9mKGUpO1xuICAgICAgaWYgKHIgPj0gMCkge1xuICAgICAgICBpZiAoIW4pIHJldHVybiBpO1xuICAgICAgICB2YXIgcyA9IHIgPT09IDAgfHwgIV9lKGEuY2hhckF0KHIgLSAxKSksIG8gPSByICsgZS5sZW5ndGggPj0gYS5sZW5ndGggfHwgIV9lKGEuY2hhckF0KHIgKyBlLmxlbmd0aCkpO1xuICAgICAgICBpZiAocyAmJiBvKSByZXR1cm4gaTtcbiAgICAgIH1cbiAgICB9XG4gICAgaSA9IGkucGFyZW50Tm9kZTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHJ0KHQsIGUpIHtcbiAgdmFyIG4gPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIGkgPSBWKGUpO1xuICByZXR1cm4geyB4OiB0LmNsaWVudFggKyBuLnNjcm9sbExlZnQgLSBuLmNsaWVudExlZnQgLSBpLnggKyBlLnNjcm9sbExlZnQsIHk6IHQuY2xpZW50WSArIG4uc2Nyb2xsVG9wIC0gbi5jbGllbnRUb3AgLSBpLnkgKyBlLnNjcm9sbFRvcCB9O1xufVxuZnVuY3Rpb24gZW4odCwgZSkge1xuICBjb25zdCBuID0gVih0KSwgaSA9IFYoZSk7XG4gIHJldHVybiB7IHg6IG4ueCAtIGkueCwgeTogbi55IC0gaS55IH07XG59XG5mdW5jdGlvbiBZKHQsIGUpIHtcbiAgaWYgKCF0IHx8ICFlKSByZXR1cm4gITE7XG4gIGZvciAoOyB0ICYmIHQgIT0gZTsgKSB0ID0gdC5wYXJlbnROb2RlO1xuICByZXR1cm4gdCA9PT0gZTtcbn1cbmZ1bmN0aW9uIGN0KHQsIGUpIHtcbiAgaWYgKHQuY2xvc2VzdCkgcmV0dXJuIHQuY2xvc2VzdChlKTtcbiAgaWYgKHQubWF0Y2hlcyB8fCB0Lm1zTWF0Y2hlc1NlbGVjdG9yIHx8IHQud2Via2l0TWF0Y2hlc1NlbGVjdG9yKSB7XG4gICAgdmFyIG4gPSB0O1xuICAgIGlmICghZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNvbnRhaW5zKG4pKSByZXR1cm4gbnVsbDtcbiAgICBkbyB7XG4gICAgICBpZiAoKG4ubWF0Y2hlcyB8fCBuLm1zTWF0Y2hlc1NlbGVjdG9yIHx8IG4ud2Via2l0TWF0Y2hlc1NlbGVjdG9yKS5jYWxsKG4sIGUpKSByZXR1cm4gbjtcbiAgICAgIG4gPSBuLnBhcmVudEVsZW1lbnQgfHwgbi5wYXJlbnROb2RlO1xuICAgIH0gd2hpbGUgKG4gIT09IG51bGwgJiYgbi5ub2RlVHlwZSA9PT0gMSk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGNvbnNvbGUuZXJyb3IoXCJZb3VyIGJyb3dzZXIgaXMgbm90IHN1cHBvcnRlZFwiKSwgbnVsbDtcbn1cbmZ1bmN0aW9uIG5uKHQpIHtcbiAgZm9yICg7IHQ7ICkge1xuICAgIGlmICh0Lm9mZnNldFdpZHRoID4gMCAmJiB0Lm9mZnNldEhlaWdodCA+IDApIHJldHVybiB0O1xuICAgIHQgPSB0LnBhcmVudEVsZW1lbnQ7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBhbigpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmhlYWQuY3JlYXRlU2hhZG93Um9vdCB8fCBkb2N1bWVudC5oZWFkLmF0dGFjaFNoYWRvdztcbn1cbmZ1bmN0aW9uIGdlKCkge1xuICB2YXIgdCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gIHJldHVybiB0LnNoYWRvd1Jvb3QgJiYgKHQgPSB0LnNoYWRvd1Jvb3QuYWN0aXZlRWxlbWVudCksIHQgPT09IGRvY3VtZW50LmJvZHkgJiYgZG9jdW1lbnQuZ2V0U2VsZWN0aW9uICYmICh0ID0gZG9jdW1lbnQuZ2V0U2VsZWN0aW9uKCkuZm9jdXNOb2RlIHx8IGRvY3VtZW50LmJvZHkpLCB0O1xufVxuZnVuY3Rpb24gdnQodCkge1xuICBpZiAoIXQgfHwgIWFuKCkpIHJldHVybiBkb2N1bWVudC5ib2R5O1xuICBmb3IgKDsgdC5wYXJlbnROb2RlICYmICh0ID0gdC5wYXJlbnROb2RlKTsgKSBpZiAodCBpbnN0YW5jZW9mIFNoYWRvd1Jvb3QpIHJldHVybiB0Lmhvc3Q7XG4gIHJldHVybiBkb2N1bWVudC5ib2R5O1xufVxuY29uc3Qgcm4gPSBPYmplY3QuZnJlZXplKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7IF9fcHJvdG9fXzogbnVsbCwgYWRkQ2xhc3NOYW1lOiB3dCwgY2xvc2VzdDogY3QsIGdldEFjdGl2ZUVsZW1lbnQ6IGdlLCBnZXRDaGlsZE5vZGVzOiB0biwgZ2V0Q2xhc3NOYW1lOiBYLCBnZXRDbG9zZXN0U2l6ZWRFbGVtZW50OiBubiwgZ2V0Rm9jdXNhYmxlTm9kZXM6IEx0LCBnZXROb2RlUG9zaXRpb246IFYsIGdldFJlbGF0aXZlRXZlbnRQb3NpdGlvbjogcnQsIGdldFJlbGF0aXZlTm9kZVBvc2l0aW9uOiBlbiwgZ2V0Um9vdE5vZGU6IHZ0LCBnZXRTY3JvbGxTaXplOiBYZSwgZ2V0VGFyZ2V0Tm9kZTogeXQsIGhhc0NsYXNzOiBmdW5jdGlvbih0LCBlKSB7XG4gIHJldHVybiBcImNsYXNzTGlzdFwiIGluIHQgPyB0LmNsYXNzTGlzdC5jb250YWlucyhlKSA6IG5ldyBSZWdFeHAoXCJcXFxcYlwiICsgZSArIFwiXFxcXGJcIikudGVzdCh0LmNsYXNzTmFtZSk7XG59LCBoYXNTaGFkb3dQYXJlbnQ6IGZ1bmN0aW9uKHQpIHtcbiAgcmV0dXJuICEhdnQodCk7XG59LCBpbnNlcnROb2RlOiBaZSwgaXNDaGlsZE9mOiBZLCBpc1NoYWRvd0RvbVN1cHBvcnRlZDogYW4sIGxvY2F0ZUF0dHJpYnV0ZTogZXQsIGxvY2F0ZUNsYXNzTmFtZTogcHQsIHJlbW92ZUNsYXNzTmFtZTogR3QsIHJlbW92ZU5vZGU6IFFlLCB0b05vZGU6IHdlIH0sIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogXCJNb2R1bGVcIiB9KSksIGR0ID0gdHlwZW9mIHdpbmRvdyA8IFwidVwiID8gd2luZG93IDogZ2xvYmFsO1xubGV0IE5uID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih0KSB7XG4gICAgdGhpcy5fbW91c2VEb3duID0gITEsIHRoaXMuX3RvdWNoU3RhcnRzID0gITEsIHRoaXMuX3RvdWNoQWN0aXZlID0gITEsIHRoaXMuX2xvbmdUYXBUaW1lciA9ICExLCB0aGlzLl9nYW50dCA9IHQsIHRoaXMuX2RvbUV2ZW50cyA9IHQuX2NyZWF0ZURvbUV2ZW50U2NvcGUoKTtcbiAgfVxuICBhdHRhY2godCwgZSwgbikge1xuICAgIGNvbnN0IGkgPSB0aGlzLl9nYW50dCwgYSA9IHQuZ2V0Vmlld1BvcnQoKTtcbiAgICB0aGlzLl9vcmlnaW5Qb3NpdGlvbiA9IGR0LmdldENvbXB1dGVkU3R5bGUoYSkuZGlzcGxheSwgdGhpcy5fcmVzdG9yZU9yaWdpblBvc2l0aW9uID0gKCkgPT4ge1xuICAgICAgYS5zdHlsZS5wb3NpdGlvbiA9IHRoaXMuX29yaWdpblBvc2l0aW9uO1xuICAgIH0sIHRoaXMuX29yaWdpblBvc2l0aW9uID09PSBcInN0YXRpY1wiICYmIChhLnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiKTtcbiAgICBjb25zdCByID0gaS4kc2VydmljZXMuZ2V0U2VydmljZShcInN0YXRlXCIpO1xuICAgIHIucmVnaXN0ZXJQcm92aWRlcihcImNsaWNrRHJhZ1wiLCAoKSA9PiAoeyBhdXRvc2Nyb2xsOiAhMSB9KSk7XG4gICAgbGV0IHMgPSBudWxsO1xuICAgIGNvbnN0IG8gPSAoKSA9PiB7XG4gICAgICBzICYmICh0aGlzLl9tb3VzZURvd24gPSAhMCwgdC5zZXRTdGFydChpLmNvcHkocykpLCB0LnNldFBvc2l0aW9uKGkuY29weShzKSksIHQuc2V0RW5kKGkuY29weShzKSksIHMgPSBudWxsKTtcbiAgICB9O1xuICAgIHRoaXMuX2RvbUV2ZW50cy5hdHRhY2goYSwgXCJtb3VzZWRvd25cIiwgKHApID0+IHtcbiAgICAgIHUocCk7XG4gICAgfSk7XG4gICAgY29uc3QgbCA9IHZ0KGkuJHJvb3QpIHx8IGRvY3VtZW50LmJvZHk7XG4gICAgZnVuY3Rpb24gZChwKSB7XG4gICAgICByZXR1cm4gcC5jaGFuZ2VkVG91Y2hlcyAmJiBwLmNoYW5nZWRUb3VjaGVzWzBdIHx8IHA7XG4gICAgfVxuICAgIHRoaXMuX2RvbUV2ZW50cy5hdHRhY2gobCwgXCJtb3VzZXVwXCIsIChwKSA9PiB7XG4gICAgICBoKHApO1xuICAgIH0pLCB0aGlzLl9kb21FdmVudHMuYXR0YWNoKGEsIFwibW91c2Vtb3ZlXCIsIChwKSA9PiB7XG4gICAgICBnKHApO1xuICAgIH0pLCB0aGlzLl9kb21FdmVudHMuYXR0YWNoKGEsIFwidG91Y2hzdGFydFwiLCAocCkgPT4ge1xuICAgICAgdGhpcy5fdG91Y2hTdGFydHMgPSAhMCwgdGhpcy5fbG9uZ1RhcFRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMuX3RvdWNoU3RhcnRzICYmICh1KGQocCkpLCB0aGlzLl90b3VjaFN0YXJ0cyA9ICExLCB0aGlzLl90b3VjaEFjdGl2ZSA9ICEwKTtcbiAgICAgIH0sIHRoaXMuX2dhbnR0LmNvbmZpZy50b3VjaF9kcmFnKTtcbiAgICB9KSwgdGhpcy5fZG9tRXZlbnRzLmF0dGFjaChsLCBcInRvdWNoZW5kXCIsIChwKSA9PiB7XG4gICAgICB0aGlzLl90b3VjaFN0YXJ0cyA9ICExLCB0aGlzLl90b3VjaEFjdGl2ZSA9ICExLCBjbGVhclRpbWVvdXQodGhpcy5fbG9uZ1RhcFRpbWVyKSwgaChkKHApKTtcbiAgICB9KSwgdGhpcy5fZG9tRXZlbnRzLmF0dGFjaChhLCBcInRvdWNobW92ZVwiLCAocCkgPT4ge1xuICAgICAgaWYgKHRoaXMuX3RvdWNoQWN0aXZlKSB7XG4gICAgICAgIGxldCB5ID0gYygpO1xuICAgICAgICBpZiAoeSAmJiBpLnV0aWxzLmRvbS5jbG9zZXN0KHAudGFyZ2V0LCB5KSkgcmV0dXJuO1xuICAgICAgICBnKGQocCkpLCBwLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9IGVsc2UgdGhpcy5fdG91Y2hTdGFydHMgPSAhMSwgY2xlYXJUaW1lb3V0KHRoaXMuX2xvbmdUYXBUaW1lcik7XG4gICAgfSk7XG4gICAgY29uc3QgYyA9ICgpID0+IHtcbiAgICAgIGxldCBwID0gXCIuZ2FudHRfdGFza19saW5lLCAuZ2FudHRfdGFza19saW5rXCI7XG4gICAgICByZXR1cm4gbiAhPT0gdm9pZCAwICYmIChwID0gbiBpbnN0YW5jZW9mIEFycmF5ID8gbi5qb2luKFwiLCBcIikgOiBuKSwgcDtcbiAgICB9LCB1ID0gKHApID0+IHtcbiAgICAgIHMgPSBudWxsO1xuICAgICAgbGV0IHkgPSBjKCk7XG4gICAgICB5ICYmIGkudXRpbHMuZG9tLmNsb3Nlc3QocC50YXJnZXQsIHkpIHx8IChyLnJlZ2lzdGVyUHJvdmlkZXIoXCJjbGlja0RyYWdcIiwgKCkgPT4gKHsgYXV0b3Njcm9sbDogdGhpcy5fbW91c2VEb3duIH0pKSwgZSAmJiBwW2VdICE9PSAhMCB8fCAocyA9IHRoaXMuX2dldENvb3JkaW5hdGVzKHAsIHQpKSk7XG4gICAgfSwgaCA9IChwKSA9PiB7XG4gICAgICBpZiAocyA9IG51bGwsICghZSB8fCBwW2VdID09PSAhMCkgJiYgdGhpcy5fbW91c2VEb3duID09PSAhMCkge1xuICAgICAgICB0aGlzLl9tb3VzZURvd24gPSAhMTtcbiAgICAgICAgY29uc3QgeSA9IHRoaXMuX2dldENvb3JkaW5hdGVzKHAsIHQpO1xuICAgICAgICB0LmRyYWdFbmQoeSk7XG4gICAgICB9XG4gICAgfSwgZyA9IChwKSA9PiB7XG4gICAgICBpZiAoZSAmJiBwW2VdICE9PSAhMCkgcmV0dXJuO1xuICAgICAgY29uc3QgeSA9IHRoaXMuX2dhbnR0LmV4dC5jbGlja0RyYWcsIHYgPSAodGhpcy5fZ2FudHQuY29uZmlnLmRyYWdfdGltZWxpbmUgfHwge30pLnVzZUtleTtcbiAgICAgIGlmICh5ICYmIHYgJiYgIWUgJiYgcFt2XSkgcmV0dXJuO1xuICAgICAgbGV0IGIgPSBudWxsO1xuICAgICAgaWYgKCF0aGlzLl9tb3VzZURvd24gJiYgcykgcmV0dXJuIGIgPSB0aGlzLl9nZXRDb29yZGluYXRlcyhwLCB0KSwgdm9pZCAoTWF0aC5hYnMocy5yZWxhdGl2ZS5sZWZ0IC0gYi5yZWxhdGl2ZS5sZWZ0KSA+IDUgJiYgbygpKTtcbiAgICAgIHRoaXMuX21vdXNlRG93biA9PT0gITAgJiYgKGIgPSB0aGlzLl9nZXRDb29yZGluYXRlcyhwLCB0KSwgdC5zZXRFbmQoYiksIHQucmVuZGVyKCkpO1xuICAgIH07XG4gIH1cbiAgZGV0YWNoKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9nYW50dDtcbiAgICB0aGlzLl9kb21FdmVudHMuZGV0YWNoQWxsKCksIHRoaXMuX3Jlc3RvcmVPcmlnaW5Qb3NpdGlvbiAmJiB0aGlzLl9yZXN0b3JlT3JpZ2luUG9zaXRpb24oKSwgdC4kc2VydmljZXMuZ2V0U2VydmljZShcInN0YXRlXCIpLnVucmVnaXN0ZXJQcm92aWRlcihcImNsaWNrRHJhZ1wiKTtcbiAgfVxuICBkZXN0cnVjdG9yKCkge1xuICAgIHRoaXMuZGV0YWNoKCk7XG4gIH1cbiAgX2dldENvb3JkaW5hdGVzKHQsIGUpIHtcbiAgICBjb25zdCBuID0gZS5nZXRWaWV3UG9ydCgpLCBpID0gbi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgeyBjbGllbnRYOiBhLCBjbGllbnRZOiByIH0gPSB0O1xuICAgIHJldHVybiB7IGFic29sdXRlOiB7IGxlZnQ6IGEsIHRvcDogciB9LCByZWxhdGl2ZTogeyBsZWZ0OiBhIC0gaS5sZWZ0ICsgbi5zY3JvbGxMZWZ0LCB0b3A6IHIgLSBpLnRvcCArIG4uc2Nyb2xsVG9wIH0gfTtcbiAgfVxufTtcbnZhciBzbiA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9zaWxlbnRfbW9kZSA9ICExLCB0aGlzLmxpc3RlbmVycyA9IHt9O1xufTtcbnNuLnByb3RvdHlwZSA9IHsgX3NpbGVudFN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgdGhpcy5fc2lsZW50X21vZGUgPSAhMDtcbn0sIF9zaWxlbnRFbmQ6IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9zaWxlbnRfbW9kZSA9ICExO1xufSB9O1xuZnVuY3Rpb24gb3QodCkge1xuICB2YXIgZSA9IG5ldyBzbigpO1xuICB0LmF0dGFjaEV2ZW50ID0gZnVuY3Rpb24obiwgaSwgYSkge1xuICAgIG4gPSBcImV2X1wiICsgbi50b0xvd2VyQ2FzZSgpLCBlLmxpc3RlbmVyc1tuXSB8fCAoZS5saXN0ZW5lcnNbbl0gPSBmdW5jdGlvbihzKSB7XG4gICAgICB2YXIgbyA9IHt9LCBsID0gMCwgZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYyA9ICEwO1xuICAgICAgICBmb3IgKHZhciB1IGluIG8pIHtcbiAgICAgICAgICB2YXIgaCA9IG9bdV0uYXBwbHkocywgYXJndW1lbnRzKTtcbiAgICAgICAgICBjID0gYyAmJiBoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBkLmFkZEV2ZW50ID0gZnVuY3Rpb24oYywgdSkge1xuICAgICAgICBpZiAodHlwZW9mIGMgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgdmFyIGg7XG4gICAgICAgICAgaWYgKHUgJiYgdS5pZCA/IGggPSB1LmlkIDogKGggPSBsLCBsKyspLCB1ICYmIHUub25jZSkge1xuICAgICAgICAgICAgdmFyIGcgPSBjO1xuICAgICAgICAgICAgYyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBnKCksIGQucmVtb3ZlRXZlbnQoaCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gb1toXSA9IGMsIGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgfSwgZC5yZW1vdmVFdmVudCA9IGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgZGVsZXRlIG9bY107XG4gICAgICB9LCBkLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIG8gPSB7fTtcbiAgICAgIH0sIGQ7XG4gICAgfSh0aGlzKSksIGEgJiYgYS50aGlzT2JqZWN0ICYmIChpID0gaS5iaW5kKGEudGhpc09iamVjdCkpO1xuICAgIHZhciByID0gbiArIFwiOlwiICsgZS5saXN0ZW5lcnNbbl0uYWRkRXZlbnQoaSwgYSk7XG4gICAgcmV0dXJuIGEgJiYgYS5pZCAmJiAociA9IGEuaWQpLCByO1xuICB9LCB0LmF0dGFjaEFsbCA9IGZ1bmN0aW9uKG4pIHtcbiAgICB0aGlzLmF0dGFjaEV2ZW50KFwibGlzdGVuX2FsbFwiLCBuKTtcbiAgfSwgdC5jYWxsRXZlbnQgPSBmdW5jdGlvbihuLCBpKSB7XG4gICAgaWYgKGUuX3NpbGVudF9tb2RlKSByZXR1cm4gITA7XG4gICAgdmFyIGEgPSBcImV2X1wiICsgbi50b0xvd2VyQ2FzZSgpLCByID0gZS5saXN0ZW5lcnM7XG4gICAgcmV0dXJuIHIuZXZfbGlzdGVuX2FsbCAmJiByLmV2X2xpc3Rlbl9hbGwuYXBwbHkodGhpcywgW25dLmNvbmNhdChpKSksICFyW2FdIHx8IHJbYV0uYXBwbHkodGhpcywgaSk7XG4gIH0sIHQuY2hlY2tFdmVudCA9IGZ1bmN0aW9uKG4pIHtcbiAgICByZXR1cm4gISFlLmxpc3RlbmVyc1tcImV2X1wiICsgbi50b0xvd2VyQ2FzZSgpXTtcbiAgfSwgdC5kZXRhY2hFdmVudCA9IGZ1bmN0aW9uKG4pIHtcbiAgICBpZiAobikge1xuICAgICAgdmFyIGkgPSBlLmxpc3RlbmVycztcbiAgICAgIGZvciAodmFyIGEgaW4gaSkgaVthXS5yZW1vdmVFdmVudChuKTtcbiAgICAgIHZhciByID0gbi5zcGxpdChcIjpcIik7XG4gICAgICBpZiAoaSA9IGUubGlzdGVuZXJzLCByLmxlbmd0aCA9PT0gMikge1xuICAgICAgICB2YXIgcyA9IHJbMF0sIG8gPSByWzFdO1xuICAgICAgICBpW3NdICYmIGlbc10ucmVtb3ZlRXZlbnQobyk7XG4gICAgICB9XG4gICAgfVxuICB9LCB0LmRldGFjaEFsbEV2ZW50cyA9IGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIG4gaW4gZS5saXN0ZW5lcnMpIGUubGlzdGVuZXJzW25dLmNsZWFyKCk7XG4gIH07XG59XG52YXIgQ2UgPSB7IHNlY29uZDogMSwgbWludXRlOiA2MCwgaG91cjogMzYwMCwgZGF5OiA4NjQwMCwgd2VlazogNjA0ODAwLCBtb250aDogMjU5MmUzLCBxdWFydGVyOiA3Nzc2ZTMsIHllYXI6IDMxNTM2ZTMgfTtcbmZ1bmN0aW9uIFZ0KHQpIHtcbiAgcmV0dXJuIENlW3RdIHx8IENlLmhvdXI7XG59XG5mdW5jdGlvbiBrdCh0LCBlKSB7XG4gIGlmICh0LmZvckVhY2gpIHQuZm9yRWFjaChlKTtcbiAgZWxzZSBmb3IgKHZhciBuID0gdC5zbGljZSgpLCBpID0gMDsgaSA8IG4ubGVuZ3RoOyBpKyspIGUobltpXSwgaSk7XG59XG5mdW5jdGlvbiBMbih0LCBlKSB7XG4gIGlmICh0LmZpbmQpIHJldHVybiB0LmZpbmQoZSk7XG4gIGZvciAodmFyIG4gPSAwOyBuIDwgdC5sZW5ndGg7IG4rKykgaWYgKGUodFtuXSwgbikpIHJldHVybiB0W25dO1xufVxuZnVuY3Rpb24genQodCwgZSkge1xuICBpZiAodC5pbmNsdWRlcykgcmV0dXJuIHQuaW5jbHVkZXMoZSk7XG4gIGZvciAodmFyIG4gPSAwOyBuIDwgdC5sZW5ndGg7IG4rKykgaWYgKHRbbl0gPT09IGUpIHJldHVybiAhMDtcbiAgcmV0dXJuICExO1xufVxuZnVuY3Rpb24gZmUodCkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheSA/IEFycmF5LmlzQXJyYXkodCkgOiB0ICYmIHQubGVuZ3RoICE9PSB2b2lkIDAgJiYgdC5wb3AgJiYgdC5wdXNoO1xufVxuZnVuY3Rpb24gWih0KSB7XG4gIHJldHVybiAhKCF0IHx8IHR5cGVvZiB0ICE9IFwib2JqZWN0XCIpICYmICEhKHQuZ2V0RnVsbFllYXIgJiYgdC5nZXRNb250aCAmJiB0LmdldERhdGUpO1xufVxuZnVuY3Rpb24gYnQodCkge1xuICByZXR1cm4gWih0KSAmJiAhaXNOYU4odC5nZXRUaW1lKCkpO1xufVxuZnVuY3Rpb24gRGUodCwgZSkge1xuICB2YXIgbiwgaSA9IGZ1bmN0aW9uKCkge1xuICAgIGkuJGNhbmNlbFRpbWVvdXQoKSwgaS4kcGVuZGluZyA9ICEwO1xuICAgIHZhciBhID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICBuID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIHQuYXBwbHkodGhpcywgYSksIGkuJHBlbmRpbmcgPSAhMTtcbiAgICB9LCBlKTtcbiAgfTtcbiAgcmV0dXJuIGkuJHBlbmRpbmcgPSAhMSwgaS4kY2FuY2VsVGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICAgIGNsZWFyVGltZW91dChuKSwgaS4kcGVuZGluZyA9ICExO1xuICB9LCBpLiRleGVjdXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGEgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgIHQuYXBwbHkodGhpcywgYSksIGkuJGNhbmNlbFRpbWVvdXQoKTtcbiAgfSwgaTtcbn1cbmZ1bmN0aW9uIGF0KHQsIGUpIHtcbiAgcmV0dXJuIEFlKHQpICYmICFBZShlKSAmJiAodCA9IFwiMFwiKSwgdDtcbn1cbmZ1bmN0aW9uIEFlKHQpIHtcbiAgcmV0dXJuIHQgPT09IDA7XG59XG5mdW5jdGlvbiBBdCh0LCBlKSB7XG4gIGZvciAodmFyIG4sIGksIGEsIHIgPSAwLCBzID0gdC5sZW5ndGggLSAxOyByIDw9IHM7ICkgaWYgKGkgPSArdFtuID0gTWF0aC5mbG9vcigociArIHMpIC8gMildLCBhID0gK3RbbiAtIDFdLCBpIDwgZSkgciA9IG4gKyAxO1xuICBlbHNlIHtcbiAgICBpZiAoIShpID4gZSkpIHtcbiAgICAgIGZvciAoOyArdFtuXSA9PSArdFtuICsgMV07ICkgbisrO1xuICAgICAgcmV0dXJuIG47XG4gICAgfVxuICAgIGlmICghaXNOYU4oYSkgJiYgYSA8IGUpIHJldHVybiBuIC0gMTtcbiAgICBzID0gbiAtIDE7XG4gIH1cbiAgcmV0dXJuIHQubGVuZ3RoIC0gMTtcbn1cbmNsYXNzIFBuIHtcbiAgY29uc3RydWN0b3IoZSwgbiwgaSkge1xuICAgIHZhciBhO1xuICAgIHRoaXMuX2VsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSwgdGhpcy5kZWZhdWx0UmVuZGVyID0gKHIsIHMpID0+IHtcbiAgICAgIHRoaXMuX2VsIHx8ICh0aGlzLl9lbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpO1xuICAgICAgY29uc3QgbyA9IHRoaXMuX2VsLCBsID0gTWF0aC5taW4oci5yZWxhdGl2ZS50b3AsIHMucmVsYXRpdmUudG9wKSwgZCA9IE1hdGgubWF4KHIucmVsYXRpdmUudG9wLCBzLnJlbGF0aXZlLnRvcCksIGMgPSBNYXRoLm1pbihyLnJlbGF0aXZlLmxlZnQsIHMucmVsYXRpdmUubGVmdCksIHUgPSBNYXRoLm1heChyLnJlbGF0aXZlLmxlZnQsIHMucmVsYXRpdmUubGVmdCk7XG4gICAgICBpZiAodGhpcy5fc2luZ2xlUm93KSB7XG4gICAgICAgIGNvbnN0IGggPSB0aGlzLl9nZXRUYXNrUG9zaXRpb25CeVRvcCh0aGlzLl9zdGFydFBvaW50LnJlbGF0aXZlLnRvcCk7XG4gICAgICAgIG8uc3R5bGUuaGVpZ2h0ID0gaC5oZWlnaHQgKyBcInB4XCIsIG8uc3R5bGUudG9wID0gaC50b3AgKyBcInB4XCI7XG4gICAgICB9IGVsc2Ugby5zdHlsZS5oZWlnaHQgPSBNYXRoLmFicyhkIC0gbCkgKyBcInB4XCIsIG8uc3R5bGUudG9wID0gbCArIFwicHhcIjtcbiAgICAgIHJldHVybiBvLnN0eWxlLndpZHRoID0gTWF0aC5hYnModSAtIGMpICsgXCJweFwiLCBvLnN0eWxlLmxlZnQgPSBjICsgXCJweFwiLCBvO1xuICAgIH0sIHRoaXMuX2dhbnR0ID0gbiwgdGhpcy5fdmlldyA9IGksIHRoaXMuX3ZpZXdQb3J0ID0gZS52aWV3UG9ydCwgdGhpcy5fZWwuY2xhc3NMaXN0LmFkZChlLmNsYXNzTmFtZSksIHR5cGVvZiBlLmNhbGxiYWNrID09IFwiZnVuY3Rpb25cIiAmJiAodGhpcy5fY2FsbGJhY2sgPSBlLmNhbGxiYWNrKSwgdGhpcy5yZW5kZXIgPSAoKSA9PiB7XG4gICAgICBsZXQgcjtcbiAgICAgIHIgPSBlLnJlbmRlciA/IGUucmVuZGVyKHRoaXMuX3N0YXJ0UG9pbnQsIHRoaXMuX2VuZFBvaW50KSA6IHRoaXMuZGVmYXVsdFJlbmRlcih0aGlzLl9zdGFydFBvaW50LCB0aGlzLl9lbmRQb2ludCksIHIgIT09IHRoaXMuX2VsICYmICh0aGlzLl9lbCAmJiB0aGlzLl9lbC5wYXJlbnROb2RlICYmIHRoaXMuX2VsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5fZWwpLCB0aGlzLl9lbCA9IHIpLCBlLmNsYXNzTmFtZSAhPT0gXCJcIiAmJiB0aGlzLl9lbC5jbGFzc0xpc3QuYWRkKGUuY2xhc3NOYW1lKSwgdGhpcy5kcmF3KCk7XG4gICAgfSwgKGEgPSB0aGlzLl92aWV3UG9ydCkuYXR0YWNoRXZlbnQgJiYgYS5kZXRhY2hFdmVudCB8fCBvdCh0aGlzLl92aWV3UG9ydCksIHRoaXMuX3NpbmdsZVJvdyA9IGUuc2luZ2xlUm93LCB0aGlzLl91c2VSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBlLnVzZVJlcXVlc3RBbmltYXRpb25GcmFtZTtcbiAgfVxuICBkcmF3KCkge1xuICAgIGlmICh0aGlzLl91c2VSZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHJldHVybiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgdGhpcy5fdmlld1BvcnQuYXBwZW5kQ2hpbGQodGhpcy5nZXRFbGVtZW50KCkpO1xuICAgIH0pO1xuICAgIHRoaXMuX3ZpZXdQb3J0LmFwcGVuZENoaWxkKHRoaXMuZ2V0RWxlbWVudCgpKTtcbiAgfVxuICBjbGVhcigpIHtcbiAgICBpZiAodGhpcy5fdXNlUmVxdWVzdEFuaW1hdGlvbkZyYW1lKSByZXR1cm4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIHRoaXMuX2VsLnBhcmVudE5vZGUgJiYgdGhpcy5fdmlld1BvcnQucmVtb3ZlQ2hpbGQodGhpcy5fZWwpO1xuICAgIH0pO1xuICAgIHRoaXMuX2VsLnBhcmVudE5vZGUgJiYgdGhpcy5fdmlld1BvcnQucmVtb3ZlQ2hpbGQodGhpcy5fZWwpO1xuICB9XG4gIGdldEVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VsO1xuICB9XG4gIGdldFZpZXdQb3J0KCkge1xuICAgIHJldHVybiB0aGlzLl92aWV3UG9ydDtcbiAgfVxuICBzZXRTdGFydChlKSB7XG4gICAgY29uc3QgbiA9IHRoaXMuX2dhbnR0O1xuICAgIHRoaXMuX3N0YXJ0UG9pbnQgPSBlLCB0aGlzLl9zdGFydERhdGUgPSBuLmRhdGVGcm9tUG9zKHRoaXMuX3N0YXJ0UG9pbnQucmVsYXRpdmUubGVmdCksIHRoaXMuX3ZpZXdQb3J0LmNhbGxFdmVudChcIm9uQmVmb3JlRHJhZ1wiLCBbdGhpcy5fc3RhcnRQb2ludF0pO1xuICB9XG4gIHNldEVuZChlKSB7XG4gICAgY29uc3QgbiA9IHRoaXMuX2dhbnR0O1xuICAgIGlmICh0aGlzLl9lbmRQb2ludCA9IGUsIHRoaXMuX3NpbmdsZVJvdykge1xuICAgICAgY29uc3QgaSA9IHRoaXMuX2dldFRhc2tQb3NpdGlvbkJ5VG9wKHRoaXMuX3N0YXJ0UG9pbnQucmVsYXRpdmUudG9wKTtcbiAgICAgIHRoaXMuX2VuZFBvaW50LnJlbGF0aXZlLnRvcCA9IGkudG9wO1xuICAgIH1cbiAgICB0aGlzLl9lbmREYXRlID0gbi5kYXRlRnJvbVBvcyh0aGlzLl9lbmRQb2ludC5yZWxhdGl2ZS5sZWZ0KSwgdGhpcy5fc3RhcnRQb2ludC5yZWxhdGl2ZS5sZWZ0ID4gdGhpcy5fZW5kUG9pbnQucmVsYXRpdmUubGVmdCAmJiAodGhpcy5fcG9zaXRpb25Qb2ludCA9IHsgcmVsYXRpdmU6IHsgbGVmdDogdGhpcy5fZW5kUG9pbnQucmVsYXRpdmUubGVmdCwgdG9wOiB0aGlzLl9wb3NpdGlvblBvaW50LnJlbGF0aXZlLnRvcCB9LCBhYnNvbHV0ZTogeyBsZWZ0OiB0aGlzLl9lbmRQb2ludC5hYnNvbHV0ZS5sZWZ0LCB0b3A6IHRoaXMuX3Bvc2l0aW9uUG9pbnQuYWJzb2x1dGUudG9wIH0gfSksIHRoaXMuX3N0YXJ0UG9pbnQucmVsYXRpdmUudG9wID4gdGhpcy5fZW5kUG9pbnQucmVsYXRpdmUudG9wICYmICh0aGlzLl9wb3NpdGlvblBvaW50ID0geyByZWxhdGl2ZTogeyBsZWZ0OiB0aGlzLl9wb3NpdGlvblBvaW50LnJlbGF0aXZlLmxlZnQsIHRvcDogdGhpcy5fZW5kUG9pbnQucmVsYXRpdmUudG9wIH0sIGFic29sdXRlOiB7IGxlZnQ6IHRoaXMuX3Bvc2l0aW9uUG9pbnQuYWJzb2x1dGUubGVmdCwgdG9wOiB0aGlzLl9lbmRQb2ludC5hYnNvbHV0ZS50b3AgfSB9KSwgdGhpcy5fdmlld1BvcnQuY2FsbEV2ZW50KFwib25EcmFnXCIsIFt0aGlzLl9zdGFydFBvaW50LCB0aGlzLl9lbmRQb2ludF0pO1xuICB9XG4gIHNldFBvc2l0aW9uKGUpIHtcbiAgICB0aGlzLl9wb3NpdGlvblBvaW50ID0gZTtcbiAgfVxuICBkcmFnRW5kKGUpIHtcbiAgICBjb25zdCBuID0gdGhpcy5fZ2FudHQ7XG4gICAgZS5yZWxhdGl2ZS5sZWZ0IDwgMCAmJiAoZS5yZWxhdGl2ZS5sZWZ0ID0gMCksIHRoaXMuX3ZpZXdQb3J0LmNhbGxFdmVudChcIm9uQmVmb3JlRHJhZ0VuZFwiLCBbdGhpcy5fc3RhcnRQb2ludCwgZV0pLCB0aGlzLnNldEVuZChlKSwgdGhpcy5fZW5kRGF0ZSA9IHRoaXMuX2VuZERhdGUgfHwgbi5nZXRTdGF0ZSgpLm1heF9kYXRlLCB0aGlzLl9zdGFydERhdGUudmFsdWVPZigpID4gdGhpcy5fZW5kRGF0ZS52YWx1ZU9mKCkgJiYgKFt0aGlzLl9zdGFydERhdGUsIHRoaXMuX2VuZERhdGVdID0gW3RoaXMuX2VuZERhdGUsIHRoaXMuX3N0YXJ0RGF0ZV0pLCB0aGlzLmNsZWFyKCk7XG4gICAgY29uc3QgaSA9IG4uZ2V0VGFza0J5VGltZSh0aGlzLl9zdGFydERhdGUsIHRoaXMuX2VuZERhdGUpLCBhID0gdGhpcy5fZ2V0VGFza3NCeVRvcCh0aGlzLl9zdGFydFBvaW50LnJlbGF0aXZlLnRvcCwgdGhpcy5fZW5kUG9pbnQucmVsYXRpdmUudG9wKTtcbiAgICB0aGlzLl92aWV3UG9ydC5jYWxsRXZlbnQoXCJvbkRyYWdFbmRcIiwgW3RoaXMuX3N0YXJ0UG9pbnQsIHRoaXMuX2VuZFBvaW50XSksIHRoaXMuX2NhbGxiYWNrICYmIHRoaXMuX2NhbGxiYWNrKHRoaXMuX3N0YXJ0UG9pbnQsIHRoaXMuX2VuZFBvaW50LCB0aGlzLl9zdGFydERhdGUsIHRoaXMuX2VuZERhdGUsIGksIGEpO1xuICB9XG4gIGdldEluQm91bmRzKCkge1xuICAgIHJldHVybiB0aGlzLl9zaW5nbGVSb3c7XG4gIH1cbiAgX2dldFRhc2tzQnlUb3AoZSwgbikge1xuICAgIGNvbnN0IGkgPSB0aGlzLl9nYW50dDtcbiAgICBsZXQgYSA9IGUsIHIgPSBuO1xuICAgIGUgPiBuICYmIChhID0gbiwgciA9IGUpO1xuICAgIGNvbnN0IHMgPSB0aGlzLl9nZXRUYXNrUG9zaXRpb25CeVRvcChhKS5pbmRleCwgbyA9IHRoaXMuX2dldFRhc2tQb3NpdGlvbkJ5VG9wKHIpLmluZGV4LCBsID0gW107XG4gICAgZm9yIChsZXQgZCA9IHM7IGQgPD0gbzsgZCsrKVxuICAgICAgaS5nZXRUYXNrQnlJbmRleChkKSAmJiBsLnB1c2goaS5nZXRUYXNrQnlJbmRleChkKSk7XG4gICAgcmV0dXJuIGw7XG4gIH1cbiAgX2dldFRhc2tQb3NpdGlvbkJ5VG9wKGUpIHtcbiAgICBjb25zdCBuID0gdGhpcy5fZ2FudHQsIGkgPSB0aGlzLl92aWV3LCBhID0gaS5nZXRJdGVtSW5kZXhCeVRvcFBvc2l0aW9uKGUpLCByID0gbi5nZXRUYXNrQnlJbmRleChhKTtcbiAgICBpZiAocikge1xuICAgICAgY29uc3QgcyA9IGkuZ2V0SXRlbUhlaWdodChyLmlkKTtcbiAgICAgIHJldHVybiB7IHRvcDogaS5nZXRJdGVtVG9wKHIuaWQpIHx8IDAsIGhlaWdodDogcyB8fCAwLCBpbmRleDogYSB9O1xuICAgIH1cbiAgICB7XG4gICAgICBjb25zdCBzID0gaS5nZXRUb3RhbEhlaWdodCgpO1xuICAgICAgcmV0dXJuIHsgdG9wOiBlID4gcyA/IHMgOiAwLCBoZWlnaHQ6IG4uY29uZmlnLnJvd19oZWlnaHQsIGluZGV4OiBlID4gcyA/IG4uZ2V0VGFza0NvdW50KCkgOiAwIH07XG4gICAgfVxuICB9XG59XG5sZXQgdGUgPSAhMTtcbmNsYXNzIFl0IHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHRoaXMuX21vdXNlRG93biA9ICExLCB0aGlzLl9jYWxjdWxhdGVEaXJlY3Rpb25WZWN0b3IgPSAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5fdHJhY2UubGVuZ3RoID49IDEwKSB7XG4gICAgICAgIGNvbnN0IG4gPSB0aGlzLl90cmFjZS5zbGljZSh0aGlzLl90cmFjZS5sZW5ndGggLSAxMCksIGkgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgciA9IDE7IHIgPCBuLmxlbmd0aDsgcisrKSBpLnB1c2goeyB4OiBuW3JdLnggLSBuW3IgLSAxXS54LCB5OiBuW3JdLnkgLSBuW3IgLSAxXS55IH0pO1xuICAgICAgICBjb25zdCBhID0geyB4OiAwLCB5OiAwIH07XG4gICAgICAgIHJldHVybiBpLmZvckVhY2goKHIpID0+IHtcbiAgICAgICAgICBhLnggKz0gci54LCBhLnkgKz0gci55O1xuICAgICAgICB9KSwgeyBtYWduaXR1ZGU6IE1hdGguc3FydChhLnggKiBhLnggKyBhLnkgKiBhLnkpLCBhbmdsZURlZ3JlZXM6IDE4MCAqIE1hdGguYXRhbjIoTWF0aC5hYnMoYS55KSwgTWF0aC5hYnMoYS54KSkgLyBNYXRoLlBJIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LCB0aGlzLl9hcHBseURuZFJlYWR5U3R5bGVzID0gKCkgPT4ge1xuICAgICAgdGhpcy5fdGltZWxpbmUuJHRhc2suY2xhc3NMaXN0LmFkZChcImdhbnR0X3RpbWVsaW5lX21vdmVfYXZhaWxhYmxlXCIpO1xuICAgIH0sIHRoaXMuX2NsZWFyRG5kUmVhZHlTdHlsZXMgPSAoKSA9PiB7XG4gICAgICB0aGlzLl90aW1lbGluZS4kdGFzay5jbGFzc0xpc3QucmVtb3ZlKFwiZ2FudHRfdGltZWxpbmVfbW92ZV9hdmFpbGFibGVcIik7XG4gICAgfSwgdGhpcy5fZ2V0U2Nyb2xsUG9zaXRpb24gPSAobikgPT4ge1xuICAgICAgY29uc3QgaSA9IHRoaXMuX2dhbnR0O1xuICAgICAgcmV0dXJuIHsgeDogaS4kdWkuZ2V0VmlldyhuLiRjb25maWcuc2Nyb2xsWCkuZ2V0U2Nyb2xsU3RhdGUoKS5wb3NpdGlvbiwgeTogaS4kdWkuZ2V0VmlldyhuLiRjb25maWcuc2Nyb2xsWSkuZ2V0U2Nyb2xsU3RhdGUoKS5wb3NpdGlvbiB9O1xuICAgIH0sIHRoaXMuX2NvdW50TmV3U2Nyb2xsUG9zaXRpb24gPSAobikgPT4ge1xuICAgICAgY29uc3QgaSA9IHRoaXMuX2NhbGN1bGF0ZURpcmVjdGlvblZlY3RvcigpO1xuICAgICAgbGV0IGEgPSB0aGlzLl9zdGFydFBvaW50LnggLSBuLngsIHIgPSB0aGlzLl9zdGFydFBvaW50LnkgLSBuLnk7XG4gICAgICByZXR1cm4gaSAmJiAoaS5hbmdsZURlZ3JlZXMgPCAxNSA/IHIgPSAwIDogaS5hbmdsZURlZ3JlZXMgPiA3NSAmJiAoYSA9IDApKSwgeyB4OiB0aGlzLl9zY3JvbGxTdGF0ZS54ICsgYSwgeTogdGhpcy5fc2Nyb2xsU3RhdGUueSArIHIgfTtcbiAgICB9LCB0aGlzLl9zZXRTY3JvbGxQb3NpdGlvbiA9IChuLCBpKSA9PiB7XG4gICAgICBjb25zdCBhID0gdGhpcy5fZ2FudHQ7XG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICBhLnNjcm9sbExheW91dENlbGwobi4kaWQsIGkueCwgaS55KTtcbiAgICAgIH0pO1xuICAgIH0sIHRoaXMuX3N0b3BEcmFnID0gKG4pID0+IHtcbiAgICAgIGNvbnN0IGkgPSB0aGlzLl9nYW50dDtcbiAgICAgIGlmICh0aGlzLl90cmFjZSA9IFtdLCBpLiRyb290LmNsYXNzTGlzdC5yZW1vdmUoXCJnYW50dF9ub3NlbGVjdFwiKSwgdGhpcy5fb3JpZ2luYWxSZWFkb25seSAhPT0gdm9pZCAwICYmIChpLmNvbmZpZy5yZWFkb25seSA9IHRoaXMuX29yaWdpbmFsUmVhZG9ubHksIHRoaXMuX21vdXNlRG93biAmJiBpLmNvbmZpZy5kcmFnX3RpbWVsaW5lICYmIGkuY29uZmlnLmRyYWdfdGltZWxpbmUucmVuZGVyICYmIGkucmVuZGVyKCkpLCB0aGlzLl9vcmlnaW5BdXRvc2Nyb2xsICE9PSB2b2lkIDAgJiYgKGkuY29uZmlnLmF1dG9zY3JvbGwgPSB0aGlzLl9vcmlnaW5BdXRvc2Nyb2xsKSwgaS5jb25maWcuZHJhZ190aW1lbGluZSkge1xuICAgICAgICBjb25zdCB7IHVzZUtleTogYSB9ID0gaS5jb25maWcuZHJhZ190aW1lbGluZTtcbiAgICAgICAgaWYgKGEgJiYgblthXSAhPT0gITApIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX21vdXNlRG93biA9ICExLCB0ZSA9ICExO1xuICAgIH0sIHRoaXMuX3N0YXJ0RHJhZyA9IChuKSA9PiB7XG4gICAgICBjb25zdCBpID0gdGhpcy5fZ2FudHQ7XG4gICAgICB0aGlzLl9vcmlnaW5BdXRvc2Nyb2xsID0gaS5jb25maWcuYXV0b3Njcm9sbCwgaS5jb25maWcuYXV0b3Njcm9sbCA9ICExLCB0ZSA9ICEwLCBpLiRyb290LmNsYXNzTGlzdC5hZGQoXCJnYW50dF9ub3NlbGVjdFwiKSwgdGhpcy5fb3JpZ2luYWxSZWFkb25seSA9IGkuY29uZmlnLnJlYWRvbmx5LCBpLmNvbmZpZy5yZWFkb25seSA9ICEwLCBpLmNvbmZpZy5kcmFnX3RpbWVsaW5lICYmIGkuY29uZmlnLmRyYWdfdGltZWxpbmUucmVuZGVyICYmIGkucmVuZGVyKCksIHRoaXMuX3RyYWNlID0gW10sIHRoaXMuX21vdXNlRG93biA9ICEwO1xuICAgICAgY29uc3QgeyB4OiBhLCB5OiByIH0gPSB0aGlzLl9nZXRTY3JvbGxQb3NpdGlvbih0aGlzLl90aW1lbGluZSk7XG4gICAgICB0aGlzLl9zY3JvbGxTdGF0ZSA9IHsgeDogYSwgeTogciB9LCB0aGlzLl9zdGFydFBvaW50ID0geyB4OiBuLmNsaWVudFgsIHk6IG4uY2xpZW50WSB9LCB0aGlzLl90cmFjZS5wdXNoKHRoaXMuX3N0YXJ0UG9pbnQpO1xuICAgIH0sIHRoaXMuX2dhbnR0ID0gZSwgdGhpcy5fZG9tRXZlbnRzID0gZS5fY3JlYXRlRG9tRXZlbnRTY29wZSgpLCB0aGlzLl90cmFjZSA9IFtdO1xuICB9XG4gIHN0YXRpYyBjcmVhdGUoZSkge1xuICAgIHJldHVybiBuZXcgWXQoZSk7XG4gIH1cbiAgc3RhdGljIF9pc0RyYWdJblByb2dyZXNzKCkge1xuICAgIHJldHVybiB0ZTtcbiAgfVxuICBkZXN0cnVjdG9yKCkge1xuICAgIHRoaXMuX2RvbUV2ZW50cy5kZXRhY2hBbGwoKTtcbiAgfVxuICBhdHRhY2goZSkge1xuICAgIHRoaXMuX3RpbWVsaW5lID0gZTtcbiAgICBjb25zdCBuID0gdGhpcy5fZ2FudHQ7XG4gICAgdGhpcy5fZG9tRXZlbnRzLmF0dGFjaChlLiR0YXNrLCBcIm1vdXNlZG93blwiLCAoaSkgPT4ge1xuICAgICAgaWYgKCFuLmNvbmZpZy5kcmFnX3RpbWVsaW5lKSByZXR1cm47XG4gICAgICBjb25zdCB7IHVzZUtleTogYSwgaWdub3JlOiByLCBlbmFibGVkOiBzIH0gPSBuLmNvbmZpZy5kcmFnX3RpbWVsaW5lO1xuICAgICAgaWYgKHMgPT09ICExKSByZXR1cm47XG4gICAgICBsZXQgbyA9IFwiLmdhbnR0X3Rhc2tfbGluZSwgLmdhbnR0X3Rhc2tfbGlua1wiO1xuICAgICAgciAhPT0gdm9pZCAwICYmIChvID0gciBpbnN0YW5jZW9mIEFycmF5ID8gci5qb2luKFwiLCBcIikgOiByKSwgbyAmJiBuLnV0aWxzLmRvbS5jbG9zZXN0KGkudGFyZ2V0LCBvKSB8fCBhICYmIGlbYV0gIT09ICEwIHx8IHRoaXMuX3N0YXJ0RHJhZyhpKTtcbiAgICB9KSwgdGhpcy5fZG9tRXZlbnRzLmF0dGFjaChkb2N1bWVudCwgXCJrZXlkb3duXCIsIChpKSA9PiB7XG4gICAgICBpZiAoIW4uY29uZmlnLmRyYWdfdGltZWxpbmUpIHJldHVybjtcbiAgICAgIGNvbnN0IHsgdXNlS2V5OiBhIH0gPSBuLmNvbmZpZy5kcmFnX3RpbWVsaW5lO1xuICAgICAgYSAmJiBpW2FdID09PSAhMCAmJiB0aGlzLl9hcHBseURuZFJlYWR5U3R5bGVzKCk7XG4gICAgfSksIHRoaXMuX2RvbUV2ZW50cy5hdHRhY2goZG9jdW1lbnQsIFwia2V5dXBcIiwgKGkpID0+IHtcbiAgICAgIGlmICghbi5jb25maWcuZHJhZ190aW1lbGluZSkgcmV0dXJuO1xuICAgICAgY29uc3QgeyB1c2VLZXk6IGEgfSA9IG4uY29uZmlnLmRyYWdfdGltZWxpbmU7XG4gICAgICBhICYmIGlbYV0gPT09ICExICYmICh0aGlzLl9jbGVhckRuZFJlYWR5U3R5bGVzKCksIHRoaXMuX3N0b3BEcmFnKGkpKTtcbiAgICB9KSwgdGhpcy5fZG9tRXZlbnRzLmF0dGFjaChkb2N1bWVudCwgXCJtb3VzZXVwXCIsIChpKSA9PiB7XG4gICAgICB0aGlzLl9zdG9wRHJhZyhpKTtcbiAgICB9KSwgdGhpcy5fZG9tRXZlbnRzLmF0dGFjaChuLiRyb290LCBcIm1vdXNldXBcIiwgKGkpID0+IHtcbiAgICAgIHRoaXMuX3N0b3BEcmFnKGkpO1xuICAgIH0pLCB0aGlzLl9kb21FdmVudHMuYXR0YWNoKGRvY3VtZW50LCBcIm1vdXNlbGVhdmVcIiwgKGkpID0+IHtcbiAgICAgIHRoaXMuX3N0b3BEcmFnKGkpO1xuICAgIH0pLCB0aGlzLl9kb21FdmVudHMuYXR0YWNoKG4uJHJvb3QsIFwibW91c2VsZWF2ZVwiLCAoaSkgPT4ge1xuICAgICAgdGhpcy5fc3RvcERyYWcoaSk7XG4gICAgfSksIHRoaXMuX2RvbUV2ZW50cy5hdHRhY2gobi4kcm9vdCwgXCJtb3VzZW1vdmVcIiwgKGkpID0+IHtcbiAgICAgIGlmICghbi5jb25maWcuZHJhZ190aW1lbGluZSkgcmV0dXJuO1xuICAgICAgY29uc3QgeyB1c2VLZXk6IGEgfSA9IG4uY29uZmlnLmRyYWdfdGltZWxpbmU7XG4gICAgICBpZiAoYSAmJiBpW2FdICE9PSAhMCkgcmV0dXJuO1xuICAgICAgY29uc3QgciA9IHRoaXMuX2dhbnR0LmV4dC5jbGlja0RyYWcsIHMgPSAodGhpcy5fZ2FudHQuY29uZmlnLmNsaWNrX2RyYWcgfHwge30pLnVzZUtleTtcbiAgICAgIGlmICgoIXIgfHwgIXMgfHwgYSB8fCAhaVtzXSkgJiYgdGhpcy5fbW91c2VEb3duID09PSAhMCkge1xuICAgICAgICB0aGlzLl90cmFjZS5wdXNoKHsgeDogaS5jbGllbnRYLCB5OiBpLmNsaWVudFkgfSk7XG4gICAgICAgIGNvbnN0IG8gPSB0aGlzLl9jb3VudE5ld1Njcm9sbFBvc2l0aW9uKHsgeDogaS5jbGllbnRYLCB5OiBpLmNsaWVudFkgfSk7XG4gICAgICAgIHRoaXMuX3NldFNjcm9sbFBvc2l0aW9uKGUsIG8pLCB0aGlzLl9zY3JvbGxTdGF0ZSA9IG8sIHRoaXMuX3N0YXJ0UG9pbnQgPSB7IHg6IGkuY2xpZW50WCwgeTogaS5jbGllbnRZIH07XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIFJuKHQpIHtcbiAgKGZ1bmN0aW9uKCkge1xuICAgIHZhciBlID0gW107XG4gICAgZnVuY3Rpb24gbigpIHtcbiAgICAgIHJldHVybiAhIWUubGVuZ3RoO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpKGQpIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIG4oKSB8fCB0LiRkZXN0cm95ZWQgfHwgdC5mb2N1cygpO1xuICAgICAgfSwgMSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGEoZCkge1xuICAgICAgdC5ldmVudFJlbW92ZShkLCBcImtleWRvd25cIiwgcyksIHQuZXZlbnQoZCwgXCJrZXlkb3duXCIsIHMpLCBlLnB1c2goZCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHIoKSB7XG4gICAgICB2YXIgZCA9IGUucG9wKCk7XG4gICAgICBkICYmIHQuZXZlbnRSZW1vdmUoZCwgXCJrZXlkb3duXCIsIHMpLCBpKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHMoZCkge1xuICAgICAgdmFyIGMgPSBkLmN1cnJlbnRUYXJnZXQ7XG4gICAgICBjID09IGVbZS5sZW5ndGggLSAxXSAmJiB0LiRrZXlib2FyZE5hdmlnYXRpb24udHJhcEZvY3VzKGMsIGQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvKCkge1xuICAgICAgYSh0LmdldExpZ2h0Ym94KCkpO1xuICAgIH1cbiAgICB0LmF0dGFjaEV2ZW50KFwib25MaWdodGJveFwiLCBvKSwgdC5hdHRhY2hFdmVudChcIm9uQWZ0ZXJMaWdodGJveFwiLCByKSwgdC5hdHRhY2hFdmVudChcIm9uTGlnaHRib3hDaGFuZ2VcIiwgZnVuY3Rpb24oKSB7XG4gICAgICByKCksIG8oKTtcbiAgICB9KSwgdC5hdHRhY2hFdmVudChcIm9uQWZ0ZXJRdWlja0luZm9cIiwgZnVuY3Rpb24oKSB7XG4gICAgICBpKCk7XG4gICAgfSksIHQuYXR0YWNoRXZlbnQoXCJvbk1lc3NhZ2VQb3B1cFwiLCBmdW5jdGlvbihkKSB7XG4gICAgICBsID0gdC51dGlscy5kb20uZ2V0QWN0aXZlRWxlbWVudCgpLCBhKGQpO1xuICAgIH0pLCB0LmF0dGFjaEV2ZW50KFwib25BZnRlck1lc3NhZ2VQb3B1cFwiLCBmdW5jdGlvbigpIHtcbiAgICAgIHIoKSwgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgbCAmJiAobC5mb2N1cygpLCBsID0gbnVsbCk7XG4gICAgICB9LCAxKTtcbiAgICB9KTtcbiAgICB2YXIgbCA9IG51bGw7XG4gICAgdC4ka2V5Ym9hcmROYXZpZ2F0aW9uLmlzTW9kYWwgPSBuO1xuICB9KSgpO1xufVxuY2xhc3MgSG4ge1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgdGhpcy5zaG93ID0gKG4sIGkpID0+IHtcbiAgICAgIGkgPT09IHZvaWQgMCA/IHRoaXMuX3Nob3dGb3JUYXNrKG4pIDogdGhpcy5fc2hvd0F0Q29vcmRpbmF0ZXMobiwgaSk7XG4gICAgfSwgdGhpcy5oaWRlID0gKG4pID0+IHtcbiAgICAgIGNvbnN0IGkgPSB0aGlzLl9nYW50dCwgYSA9IHRoaXMuX3F1aWNrSW5mb0JveDtcbiAgICAgIHRoaXMuX3F1aWNrSW5mb0JveElkID0gMDtcbiAgICAgIGNvbnN0IHIgPSB0aGlzLl9xdWlja0luZm9UYXNrO1xuICAgICAgaWYgKHRoaXMuX3F1aWNrSW5mb1Rhc2sgPSBudWxsLCBhICYmIGEucGFyZW50Tm9kZSkge1xuICAgICAgICBpZiAoaS5jb25maWcucXVpY2tfaW5mb19kZXRhY2hlZCkgcmV0dXJuIGkuY2FsbEV2ZW50KFwib25BZnRlclF1aWNrSW5mb1wiLCBbcl0pLCBhLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYSk7XG4gICAgICAgIGEuY2xhc3NOYW1lICs9IFwiIGdhbnR0X3FpX2hpZGRlblwiLCBhLnN0eWxlLnJpZ2h0ID09PSBcImF1dG9cIiA/IGEuc3R5bGUubGVmdCA9IFwiLTM1MHB4XCIgOiBhLnN0eWxlLnJpZ2h0ID0gXCItMzUwcHhcIiwgbiAmJiAoYS5zdHlsZS5sZWZ0ID0gYS5zdHlsZS5yaWdodCA9IFwiXCIsIGEucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChhKSksIGkuY2FsbEV2ZW50KFwib25BZnRlclF1aWNrSW5mb1wiLCBbcl0pO1xuICAgICAgfVxuICAgIH0sIHRoaXMuZ2V0Tm9kZSA9ICgpID0+IHRoaXMuX3F1aWNrSW5mb0JveCA/IHRoaXMuX3F1aWNrSW5mb0JveCA6IG51bGwsIHRoaXMuc2V0Q29udGFpbmVyID0gKG4pID0+IHtcbiAgICAgIG4gJiYgKHRoaXMuX2NvbnRhaW5lciA9IHR5cGVvZiBuID09IFwic3RyaW5nXCIgPyBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChuKSA6IG4pO1xuICAgIH0sIHRoaXMuc2V0Q29udGVudCA9IChuKSA9PiB7XG4gICAgICBjb25zdCBpID0gdGhpcy5fZ2FudHQsIGEgPSB7IHRhc2tJZDogbnVsbCwgaGVhZGVyOiB7IHRpdGxlOiBcIlwiLCBkYXRlOiBcIlwiIH0sIGNvbnRlbnQ6IFwiXCIsIGJ1dHRvbnM6IGkuY29uZmlnLnF1aWNraW5mb19idXR0b25zIH07XG4gICAgICBuIHx8IChuID0gYSksIG4udGFza0lkIHx8IChuLnRhc2tJZCA9IGEudGFza0lkKSwgbi5oZWFkZXIgfHwgKG4uaGVhZGVyID0gYS5oZWFkZXIpLCBuLmhlYWRlci50aXRsZSB8fCAobi5oZWFkZXIudGl0bGUgPSBhLmhlYWRlci50aXRsZSksIG4uaGVhZGVyLmRhdGUgfHwgKG4uaGVhZGVyLmRhdGUgPSBhLmhlYWRlci5kYXRlKSwgbi5jb250ZW50IHx8IChuLmNvbnRlbnQgPSBhLmNvbnRlbnQpLCBuLmJ1dHRvbnMgfHwgKG4uYnV0dG9ucyA9IGEuYnV0dG9ucyk7XG4gICAgICBsZXQgciA9IHRoaXMuZ2V0Tm9kZSgpO1xuICAgICAgciB8fCAociA9IHRoaXMuX2NyZWF0ZVF1aWNrSW5mb0VsZW1lbnQoKSksIG4udGFza0lkICYmICh0aGlzLl9xdWlja0luZm9Cb3hJZCA9IG4udGFza0lkKTtcbiAgICAgIGNvbnN0IHMgPSByLnF1ZXJ5U2VsZWN0b3IoXCIuZ2FudHRfY2FsX3FpX3RpdGxlXCIpLCBvID0gcy5xdWVyeVNlbGVjdG9yKFwiLmdhbnR0X2NhbF9xaV90Y29udGVudFwiKSwgbCA9IHMucXVlcnlTZWxlY3RvcihcIi5nYW50dF9jYWxfcWlfdGRhdGVcIiksIGQgPSByLnF1ZXJ5U2VsZWN0b3IoXCIuZ2FudHRfY2FsX3FpX2NvbnRlbnRcIiksIGMgPSByLnF1ZXJ5U2VsZWN0b3IoXCIuZ2FudHRfY2FsX3FpX2NvbnRyb2xzXCIpO1xuICAgICAgaS5fd2FpQXJpYS5xdWlja0luZm9IZWFkZXIociwgW24uaGVhZGVyLnRpdGxlLCBuLmhlYWRlci5kYXRlXS5qb2luKFwiIFwiKSksIG8uaW5uZXJIVE1MID0gbi5oZWFkZXIudGl0bGUsIGwuaW5uZXJIVE1MID0gbi5oZWFkZXIuZGF0ZSwgbi5oZWFkZXIudGl0bGUgfHwgbi5oZWFkZXIuZGF0ZSA/IHMuc3R5bGUuZGlzcGxheSA9IFwiXCIgOiBzLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIiwgZC5pbm5lckhUTUwgPSBuLmNvbnRlbnQ7XG4gICAgICBjb25zdCB1ID0gbi5idXR0b25zO1xuICAgICAgdS5sZW5ndGggPyBjLnN0eWxlLmRpc3BsYXkgPSBcIlwiIDogYy5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICBsZXQgaCA9IFwiXCI7XG4gICAgICBmb3IgKGxldCBnID0gMDsgZyA8IHUubGVuZ3RoOyBnKyspIHtcbiAgICAgICAgY29uc3QgcCA9IGkuX3dhaUFyaWEucXVpY2tJbmZvQnV0dG9uQXR0clN0cmluZyhpLmxvY2FsZS5sYWJlbHNbdVtnXV0pO1xuICAgICAgICBoICs9IGA8ZGl2IGNsYXNzPVwiZ2FudHRfcWlfYmlnX2ljb24gJHt1W2ddfSBkaHhfZ2FudHRfJHt1W2ddfVwiIHRpdGxlPVwiJHtpLmxvY2FsZS5sYWJlbHNbdVtnXV19XCIgJHtwfT5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9J2RoeF9tZW51X2ljb24gZGh4X2dhbnR0X2ljb24gJHt1W2ddfSBnYW50dF9tZW51X2ljb24gZGh4X2dhbnR0XyR7dVtnXX0nPjwvZGl2PlxuICAgICAgICAgICAgPGRpdj4ke2kubG9jYWxlLmxhYmVsc1t1W2ddXX08L2Rpdj5cbiAgICAgICAgIDwvZGl2PmA7XG4gICAgICB9XG4gICAgICBjLmlubmVySFRNTCA9IGgsIGkuZXZlbnRSZW1vdmUociwgXCJjbGlja1wiLCB0aGlzLl9xaUJ1dHRvbkNsaWNrSGFuZGxlciksIGkuZXZlbnRSZW1vdmUociwgXCJrZXlwcmVzc1wiLCB0aGlzLl9xaUtleVByZXNzSGFuZGxlciksIGkuZXZlbnQociwgXCJjbGlja1wiLCB0aGlzLl9xaUJ1dHRvbkNsaWNrSGFuZGxlciksIGkuZXZlbnQociwgXCJrZXlwcmVzc1wiLCB0aGlzLl9xaUtleVByZXNzSGFuZGxlcik7XG4gICAgfSwgdGhpcy5fcWlCdXR0b25DbGlja0hhbmRsZXIgPSAobikgPT4ge1xuICAgICAgdGhpcy5fcWlfYnV0dG9uX2NsaWNrKG4udGFyZ2V0KTtcbiAgICB9LCB0aGlzLl9xaUtleVByZXNzSGFuZGxlciA9IChuKSA9PiB7XG4gICAgICBjb25zdCBpID0gbi53aGljaDtcbiAgICAgIGkgIT09IDEzICYmIGkgIT09IDMyIHx8IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLl9xaV9idXR0b25fY2xpY2sobi50YXJnZXQpO1xuICAgICAgfSwgMSk7XG4gICAgfSwgdGhpcy5fZ2FudHQgPSBlO1xuICB9XG4gIF9zaG93QXRDb29yZGluYXRlcyhlLCBuKSB7XG4gICAgdGhpcy5oaWRlKCEwKSwgdGhpcy5fcXVpY2tJbmZvQm94SWQgPSAwLCB0aGlzLl9xdWlja0luZm9UYXNrID0gbnVsbCwgdGhpcy5fcXVpY2tJbmZvQm94IHx8ICh0aGlzLl9jcmVhdGVRdWlja0luZm9FbGVtZW50KCksIHRoaXMuc2V0Q29udGVudCgpKSwgdGhpcy5fYXBwZW5kQXRDb29yZGluYXRlcyhlLCBuKSwgdGhpcy5fZ2FudHQuY2FsbEV2ZW50KFwib25RdWlja0luZm9cIiwgW251bGxdKTtcbiAgfVxuICBfc2hvd0ZvclRhc2soZSkge1xuICAgIGNvbnN0IG4gPSB0aGlzLl9nYW50dDtcbiAgICBpZiAoZSA9PT0gdGhpcy5fcXVpY2tJbmZvQm94SWQgJiYgbi51dGlscy5kb20uaXNDaGlsZE9mKHRoaXMuX3F1aWNrSW5mb0JveCwgZG9jdW1lbnQuYm9keSkgfHwgIW4uY29uZmlnLnNob3dfcXVpY2tfaW5mbykgcmV0dXJuO1xuICAgIHRoaXMuaGlkZSghMCk7XG4gICAgY29uc3QgaSA9IHRoaXMuX2dldENvbnRhaW5lcigpLCBhID0gdGhpcy5fZ2V0X2V2ZW50X2NvdW50ZXJfcGFydChlLCA2LCBpLnhWaWV3cG9ydCwgaS55Vmlld3BvcnQpO1xuICAgIGEgJiYgKHRoaXMuX3F1aWNrSW5mb0JveCA9IHRoaXMuX2luaXRfcXVpY2tfaW5mbyhlKSwgdGhpcy5fcXVpY2tJbmZvVGFzayA9IGUsIHRoaXMuX3F1aWNrSW5mb0JveC5jbGFzc05hbWUgPSB0aGlzLl9wcmVwYXJlX3F1aWNrX2luZm9fY2xhc3NuYW1lKGUpLCB0aGlzLl9maWxsX3F1aWNrX2RhdGEoZSksIHRoaXMuX3Nob3dfcXVpY2tfaW5mbyhhLCA2KSwgbi5jYWxsRXZlbnQoXCJvblF1aWNrSW5mb1wiLCBbZV0pKTtcbiAgfVxuICBfZ2V0X2V2ZW50X2NvdW50ZXJfcGFydChlLCBuLCBpLCBhKSB7XG4gICAgY29uc3QgciA9IHRoaXMuX2dhbnR0O1xuICAgIGxldCBzID0gci5nZXRUYXNrTm9kZShlKTtcbiAgICBpZiAoIXMgJiYgKHMgPSByLmdldFRhc2tSb3dOb2RlKGUpLCAhcykpIHJldHVybiBudWxsO1xuICAgIGxldCBvID0gMDtcbiAgICBjb25zdCBsID0gbiArIHMub2Zmc2V0VG9wICsgcy5vZmZzZXRIZWlnaHQ7XG4gICAgbGV0IGQgPSBzO1xuICAgIGlmIChyLnV0aWxzLmRvbS5pc0NoaWxkT2YoZCwgaSkpIGZvciAoOyBkICYmIGQgIT09IGk7ICkgbyArPSBkLm9mZnNldExlZnQsIGQgPSBkLm9mZnNldFBhcmVudDtcbiAgICBjb25zdCBjID0gci5nZXRTY3JvbGxTdGF0ZSgpO1xuICAgIHJldHVybiBkID8geyBsZWZ0OiBvLCB0b3A6IGwsIGR4OiBvICsgcy5vZmZzZXRXaWR0aCAvIDIgLSBjLnggPiBpLm9mZnNldFdpZHRoIC8gMiA/IDEgOiAwLCBkeTogbCArIHMub2Zmc2V0SGVpZ2h0IC8gMiAtIGMueSA+IGEub2Zmc2V0SGVpZ2h0IC8gMiA/IDEgOiAwLCB3aWR0aDogcy5vZmZzZXRXaWR0aCwgaGVpZ2h0OiBzLm9mZnNldEhlaWdodCB9IDogbnVsbDtcbiAgfVxuICBfY3JlYXRlUXVpY2tJbmZvRWxlbWVudCgpIHtcbiAgICBjb25zdCBlID0gdGhpcy5fZ2FudHQsIG4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIG4uY2xhc3NOYW1lICs9IFwiZ2FudHRfY2FsX3F1aWNrX2luZm9cIiwgZS5fd2FpQXJpYS5xdWlja0luZm9BdHRyKG4pO1xuICAgIHZhciBpID0gYFxuXHRcdDxkaXYgY2xhc3M9XCJnYW50dF9jYWxfcWlfdGNvbnRyb2xzXCI+XG5cdFx0XHQ8YSBjbGFzcz1cImdhbnR0X2NhbF9xaV9jbG9zZV9idG4gZGh4X2dhbnR0X2ljb24gZGh4X2dhbnR0X2ljb25fY2xvc2VcIj48L2E+XG5cdFx0PC9kaXY+XG5cdFx0PGRpdiBjbGFzcz1cImdhbnR0X2NhbF9xaV90aXRsZVwiICR7ZS5fd2FpQXJpYS5xdWlja0luZm9IZWFkZXJBdHRyU3RyaW5nKCl9PlxuXHRcdFx0XHRcblx0XHRcdFx0PGRpdiBjbGFzcz1cImdhbnR0X2NhbF9xaV90Y29udGVudFwiPjwvZGl2PlxuXHRcdFx0XHQ8ZGl2IGNsYXNzPVwiZ2FudHRfY2FsX3FpX3RkYXRlXCI+PC9kaXY+XG5cdFx0XHQ8L2Rpdj5cblx0XHRcdDxkaXYgY2xhc3M9XCJnYW50dF9jYWxfcWlfY29udGVudFwiPjwvZGl2PmA7XG4gICAgaWYgKGkgKz0gJzxkaXYgY2xhc3M9XCJnYW50dF9jYWxfcWlfY29udHJvbHNcIj4nLCBpICs9IFwiPC9kaXY+XCIsIG4uaW5uZXJIVE1MID0gaSwgZS5jb25maWcucXVpY2tfaW5mb19kZXRhY2hlZCkge1xuICAgICAgY29uc3QgYSA9IHRoaXMuX2dldENvbnRhaW5lcigpO1xuICAgICAgZS5ldmVudChhLnBhcmVudCwgXCJzY3JvbGxcIiwgKCkgPT4ge1xuICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcXVpY2tJbmZvQm94ID0gbiwgbjtcbiAgfVxuICBfaW5pdF9xdWlja19pbmZvKGUpIHtcbiAgICBjb25zdCBuID0gdGhpcy5fZ2FudHQsIGkgPSBuLmdldFRhc2soZSk7XG4gICAgcmV0dXJuIHR5cGVvZiB0aGlzLl9xdWlja0luZm9SZWFkb25seSA9PSBcImJvb2xlYW5cIiAmJiBuLmlzUmVhZG9ubHkoaSkgIT09IHRoaXMuX3F1aWNrSW5mb1JlYWRvbmx5ICYmICh0aGlzLmhpZGUoITApLCB0aGlzLl9xdWlja0luZm9Cb3ggPSBudWxsKSwgdGhpcy5fcXVpY2tJbmZvUmVhZG9ubHkgPSBuLmlzUmVhZG9ubHkoaSksIHRoaXMuX3F1aWNrSW5mb0JveCB8fCAodGhpcy5fcXVpY2tJbmZvQm94ID0gdGhpcy5fY3JlYXRlUXVpY2tJbmZvRWxlbWVudCgpKSwgdGhpcy5fcXVpY2tJbmZvQm94O1xuICB9XG4gIF9wcmVwYXJlX3F1aWNrX2luZm9fY2xhc3NuYW1lKGUpIHtcbiAgICBjb25zdCBuID0gdGhpcy5fZ2FudHQsIGkgPSBuLmdldFRhc2soZSk7XG4gICAgbGV0IGEgPSBgZ2FudHRfY2FsX3F1aWNrX2luZm8gZ2FudHRfJHtuLmdldFRhc2tUeXBlKGkpfWA7XG4gICAgY29uc3QgciA9IG4udGVtcGxhdGVzLnF1aWNrX2luZm9fY2xhc3MoaS5zdGFydF9kYXRlLCBpLmVuZF9kYXRlLCBpKTtcbiAgICByZXR1cm4gciAmJiAoYSArPSBcIiBcIiArIHIpLCBhO1xuICB9XG4gIF9maWxsX3F1aWNrX2RhdGEoZSkge1xuICAgIGNvbnN0IG4gPSB0aGlzLl9nYW50dCwgaSA9IG4uZ2V0VGFzayhlKTtcbiAgICB0aGlzLl9xdWlja0luZm9Cb3hJZCA9IGU7XG4gICAgbGV0IGEgPSBbXTtcbiAgICBpZiAodGhpcy5fcXVpY2tJbmZvUmVhZG9ubHkpIHtcbiAgICAgIGNvbnN0IHIgPSBuLmNvbmZpZy5xdWlja2luZm9fYnV0dG9ucywgcyA9IHsgaWNvbl9kZWxldGU6ICEwLCBpY29uX2VkaXQ6ICEwIH07XG4gICAgICBmb3IgKGxldCBvID0gMDsgbyA8IHIubGVuZ3RoOyBvKyspIHRoaXMuX3F1aWNrSW5mb1JlYWRvbmx5ICYmIHNbcltvXV0gfHwgYS5wdXNoKHJbb10pO1xuICAgIH0gZWxzZSBhID0gbi5jb25maWcucXVpY2tpbmZvX2J1dHRvbnM7XG4gICAgdGhpcy5zZXRDb250ZW50KHsgaGVhZGVyOiB7IHRpdGxlOiBuLnRlbXBsYXRlcy5xdWlja19pbmZvX3RpdGxlKGkuc3RhcnRfZGF0ZSwgaS5lbmRfZGF0ZSwgaSksIGRhdGU6IG4udGVtcGxhdGVzLnF1aWNrX2luZm9fZGF0ZShpLnN0YXJ0X2RhdGUsIGkuZW5kX2RhdGUsIGkpIH0sIGNvbnRlbnQ6IG4udGVtcGxhdGVzLnF1aWNrX2luZm9fY29udGVudChpLnN0YXJ0X2RhdGUsIGkuZW5kX2RhdGUsIGkpLCBidXR0b25zOiBhIH0pO1xuICB9XG4gIF9hcHBlbmRBdENvb3JkaW5hdGVzKGUsIG4pIHtcbiAgICBjb25zdCBpID0gdGhpcy5fcXVpY2tJbmZvQm94LCBhID0gdGhpcy5fZ2V0Q29udGFpbmVyKCk7XG4gICAgaS5wYXJlbnROb2RlICYmIGkucGFyZW50Tm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcIiNkb2N1bWVudC1mcmFnbWVudFwiIHx8IGEucGFyZW50LmFwcGVuZENoaWxkKGkpLCBpLnN0eWxlLmxlZnQgPSBlICsgXCJweFwiLCBpLnN0eWxlLnRvcCA9IG4gKyBcInB4XCI7XG4gIH1cbiAgX3Nob3dfcXVpY2tfaW5mbyhlLCBuKSB7XG4gICAgY29uc3QgaSA9IHRoaXMuX2dhbnR0LCBhID0gdGhpcy5fcXVpY2tJbmZvQm94O1xuICAgIGlmIChpLmNvbmZpZy5xdWlja19pbmZvX2RldGFjaGVkKSB7XG4gICAgICBjb25zdCByID0gdGhpcy5fZ2V0Q29udGFpbmVyKCk7XG4gICAgICBhLnBhcmVudE5vZGUgJiYgYS5wYXJlbnROb2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09IFwiI2RvY3VtZW50LWZyYWdtZW50XCIgfHwgci5wYXJlbnQuYXBwZW5kQ2hpbGQoYSk7XG4gICAgICBjb25zdCBzID0gYS5vZmZzZXRXaWR0aCwgbyA9IGEub2Zmc2V0SGVpZ2h0LCBsID0gaS5nZXRTY3JvbGxTdGF0ZSgpLCBkID0gci54Vmlld3BvcnQsIGMgPSByLnlWaWV3cG9ydCwgdSA9IGQub2Zmc2V0V2lkdGggKyBsLnggLSBzLCBoID0gZS50b3AgLSBsLnkgKyBvO1xuICAgICAgbGV0IGcgPSBlLnRvcDtcbiAgICAgIGggPiBjLm9mZnNldEhlaWdodCAvIDIgJiYgKGcgPSBlLnRvcCAtIChvICsgZS5oZWlnaHQgKyAyICogbiksIGcgPCBsLnkgJiYgaCA8PSBjLm9mZnNldEhlaWdodCAmJiAoZyA9IGUudG9wKSksIGcgPCBsLnkgJiYgKGcgPSBsLnkpO1xuICAgICAgY29uc3QgcCA9IE1hdGgubWluKE1hdGgubWF4KGwueCwgZS5sZWZ0IC0gZS5keCAqIChzIC0gZS53aWR0aCkpLCB1KSwgeSA9IGc7XG4gICAgICB0aGlzLl9hcHBlbmRBdENvb3JkaW5hdGVzKHAsIHkpO1xuICAgIH0gZWxzZSBhLnN0eWxlLnRvcCA9IFwiMjBweFwiLCBlLmR4ID09PSAxID8gKGEuc3R5bGUucmlnaHQgPSBcImF1dG9cIiwgYS5zdHlsZS5sZWZ0ID0gXCItMzAwcHhcIiwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBhLnN0eWxlLmxlZnQgPSBcIjEwcHhcIjtcbiAgICB9LCAxKSkgOiAoYS5zdHlsZS5sZWZ0ID0gXCJhdXRvXCIsIGEuc3R5bGUucmlnaHQgPSBcIi0zMDBweFwiLCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGEuc3R5bGUucmlnaHQgPSBcIjEwcHhcIjtcbiAgICB9LCAxKSksIGEuY2xhc3NOYW1lICs9IFwiIGdhbnR0X3FpX1wiICsgKGUuZHggPT09IDEgPyBcImxlZnRcIiA6IFwicmlnaHRcIiksIGkuJHJvb3QuYXBwZW5kQ2hpbGQoYSk7XG4gIH1cbiAgX3FpX2J1dHRvbl9jbGljayhlKSB7XG4gICAgY29uc3QgbiA9IHRoaXMuX2dhbnR0LCBpID0gdGhpcy5fcXVpY2tJbmZvQm94O1xuICAgIGlmICghZSB8fCBlID09PSBpKSByZXR1cm47XG4gICAgaWYgKGUuY2xvc2VzdChcIi5nYW50dF9jYWxfcWlfY2xvc2VfYnRuXCIpKSByZXR1cm4gdm9pZCB0aGlzLmhpZGUoKTtcbiAgICBjb25zdCBhID0gZS5jbGFzc05hbWU7XG4gICAgaWYgKGEuaW5kZXhPZihcIl9pY29uXCIpICE9PSAtMSkge1xuICAgICAgY29uc3QgciA9IHRoaXMuX3F1aWNrSW5mb0JveElkO1xuICAgICAgbi4kY2xpY2suYnV0dG9uc1thLnNwbGl0KFwiIFwiKVsxXS5yZXBsYWNlKFwiaWNvbl9cIiwgXCJcIildKHIpO1xuICAgIH0gZWxzZSB0aGlzLl9xaV9idXR0b25fY2xpY2soZS5wYXJlbnROb2RlKTtcbiAgfVxuICBfZ2V0Q29udGFpbmVyKCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLl9nYW50dDtcbiAgICBsZXQgbiA9IHRoaXMuX2NvbnRhaW5lciA/IHRoaXMuX2NvbnRhaW5lciA6IGUuJHRhc2tfZGF0YTtcbiAgICByZXR1cm4gbiAmJiBuLm9mZnNldEhlaWdodCAmJiBuLm9mZnNldFdpZHRoID8geyBwYXJlbnQ6IG4sIHhWaWV3cG9ydDogZS4kdGFzaywgeVZpZXdwb3J0OiBlLiR0YXNrX2RhdGEgfSA6IChuID0gdGhpcy5fY29udGFpbmVyID8gdGhpcy5fY29udGFpbmVyIDogZS4kZ3JpZF9kYXRhLCBuICYmIG4ub2Zmc2V0SGVpZ2h0ICYmIG4ub2Zmc2V0V2lkdGggPyB7IHBhcmVudDogbiwgeFZpZXdwb3J0OiBlLiRncmlkLCB5Vmlld3BvcnQ6IGUuJGdyaWRfZGF0YSB9IDogeyBwYXJlbnQ6IHRoaXMuX2NvbnRhaW5lciA/IHRoaXMuX2NvbnRhaW5lciA6IGUuJGxheW91dCwgeFZpZXdwb3J0OiBlLiRsYXlvdXQsIHlWaWV3cG9ydDogZS4kbGF5b3V0IH0pO1xuICB9XG59XG52YXIgZWUsIE9uID0ge30uY29uc3RydWN0b3IudG9TdHJpbmcoKTtcbmZ1bmN0aW9uIHEodCkge1xuICB2YXIgZSwgbjtcbiAgaWYgKHQgJiYgdHlwZW9mIHQgPT0gXCJvYmplY3RcIikgc3dpdGNoICghMCkge1xuICAgIGNhc2UgWih0KTpcbiAgICAgIG4gPSBuZXcgRGF0ZSh0KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgZmUodCk6XG4gICAgICBmb3IgKG4gPSBuZXcgQXJyYXkodC5sZW5ndGgpLCBlID0gMDsgZSA8IHQubGVuZ3RoOyBlKyspIG5bZV0gPSBxKHRbZV0pO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGlmIChmdW5jdGlvbihpKSB7XG4gICAgICAgIHJldHVybiBpLmNvbnN0cnVjdG9yLnRvU3RyaW5nKCkgIT09IE9uO1xuICAgICAgfSh0KSkgbiA9IE9iamVjdC5jcmVhdGUodCk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgICByZXR1cm4gaS4kJHR5cGVvZiAmJiBpLiQkdHlwZW9mLnRvU3RyaW5nKCkuaW5jbHVkZXMoXCJyZWFjdC5cIik7XG4gICAgICAgIH0odCkpIHJldHVybiBuID0gdDtcbiAgICAgICAgbiA9IHt9O1xuICAgICAgfVxuICAgICAgZm9yIChlIGluIHQpIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuYXBwbHkodCwgW2VdKSAmJiAobltlXSA9IHEodFtlXSkpO1xuICB9XG4gIHJldHVybiBuIHx8IHQ7XG59XG5mdW5jdGlvbiBQKHQsIGUsIG4pIHtcbiAgZm9yICh2YXIgaSBpbiBlKSAodFtpXSA9PT0gdm9pZCAwIHx8IG4pICYmICh0W2ldID0gZVtpXSk7XG4gIHJldHVybiB0O1xufVxuZnVuY3Rpb24gVyh0KSB7XG4gIHJldHVybiB0ICE9PSB2b2lkIDA7XG59XG5mdW5jdGlvbiBzdCgpIHtcbiAgcmV0dXJuIGVlIHx8IChlZSA9ICgvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSkudmFsdWVPZigpKSwgKytlZTtcbn1cbmZ1bmN0aW9uIFIodCwgZSkge1xuICByZXR1cm4gdC5iaW5kID8gdC5iaW5kKGUpIDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHQuYXBwbHkoZSwgYXJndW1lbnRzKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIG9uKHQsIGUsIG4sIGkpIHtcbiAgdC5hZGRFdmVudExpc3RlbmVyID8gdC5hZGRFdmVudExpc3RlbmVyKGUsIG4sIGkgIT09IHZvaWQgMCAmJiBpKSA6IHQuYXR0YWNoRXZlbnQgJiYgdC5hdHRhY2hFdmVudChcIm9uXCIgKyBlLCBuKTtcbn1cbmZ1bmN0aW9uIGxuKHQsIGUsIG4sIGkpIHtcbiAgdC5yZW1vdmVFdmVudExpc3RlbmVyID8gdC5yZW1vdmVFdmVudExpc3RlbmVyKGUsIG4sIGkgIT09IHZvaWQgMCAmJiBpKSA6IHQuZGV0YWNoRXZlbnQgJiYgdC5kZXRhY2hFdmVudChcIm9uXCIgKyBlLCBuKTtcbn1cbmNvbnN0IEJuID0gT2JqZWN0LmZyZWV6ZShPYmplY3QuZGVmaW5lUHJvcGVydHkoeyBfX3Byb3RvX186IG51bGwsIGJpbmQ6IFIsIGNvcHk6IHEsIGRlZmluZWQ6IFcsIGV2ZW50OiBvbiwgZXZlbnRSZW1vdmU6IGxuLCBtaXhpbjogUCwgdWlkOiBzdCB9LCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6IFwiTW9kdWxlXCIgfSkpO1xuZnVuY3Rpb24gU2UodCwgZSkge1xuICB0ID0gdCB8fCBvbiwgZSA9IGUgfHwgbG47XG4gIHZhciBuID0gW10sIGkgPSB7IGF0dGFjaDogZnVuY3Rpb24oYSwgciwgcywgbykge1xuICAgIG4ucHVzaCh7IGVsZW1lbnQ6IGEsIGV2ZW50OiByLCBjYWxsYmFjazogcywgY2FwdHVyZTogbyB9KSwgdChhLCByLCBzLCBvKTtcbiAgfSwgZGV0YWNoOiBmdW5jdGlvbihhLCByLCBzLCBvKSB7XG4gICAgZShhLCByLCBzLCBvKTtcbiAgICBmb3IgKHZhciBsID0gMDsgbCA8IG4ubGVuZ3RoOyBsKyspIHtcbiAgICAgIHZhciBkID0gbltsXTtcbiAgICAgIGQuZWxlbWVudCA9PT0gYSAmJiBkLmV2ZW50ID09PSByICYmIGQuY2FsbGJhY2sgPT09IHMgJiYgZC5jYXB0dXJlID09PSBvICYmIChuLnNwbGljZShsLCAxKSwgbC0tKTtcbiAgICB9XG4gIH0sIGRldGFjaEFsbDogZnVuY3Rpb24oKSB7XG4gICAgZm9yICh2YXIgYSA9IG4uc2xpY2UoKSwgciA9IDA7IHIgPCBhLmxlbmd0aDsgcisrKSB7XG4gICAgICB2YXIgcyA9IGFbcl07XG4gICAgICBpLmRldGFjaChzLmVsZW1lbnQsIHMuZXZlbnQsIHMuY2FsbGJhY2ssIHMuY2FwdHVyZSksIGkuZGV0YWNoKHMuZWxlbWVudCwgcy5ldmVudCwgcy5jYWxsYmFjaywgdm9pZCAwKSwgaS5kZXRhY2gocy5lbGVtZW50LCBzLmV2ZW50LCBzLmNhbGxiYWNrLCAhMSksIGkuZGV0YWNoKHMuZWxlbWVudCwgcy5ldmVudCwgcy5jYWxsYmFjaywgITApO1xuICAgIH1cbiAgICBuLnNwbGljZSgwLCBuLmxlbmd0aCk7XG4gIH0sIGV4dGVuZDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFNlKHRoaXMuZXZlbnQsIHRoaXMuZXZlbnRSZW1vdmUpO1xuICB9IH07XG4gIHJldHVybiBpO1xufVxuY2xhc3Mgem4ge1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgdGhpcy5fZ2FudHQgPSBlO1xuICB9XG4gIGdldE5vZGUoKSB7XG4gICAgY29uc3QgZSA9IHRoaXMuX2dhbnR0O1xuICAgIHJldHVybiB0aGlzLl90b29sdGlwTm9kZSB8fCAodGhpcy5fdG9vbHRpcE5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLCB0aGlzLl90b29sdGlwTm9kZS5jbGFzc05hbWUgPSBcImdhbnR0X3Rvb2x0aXBcIiwgZS5fd2FpQXJpYS50b29sdGlwQXR0cih0aGlzLl90b29sdGlwTm9kZSkpLCB0aGlzLl90b29sdGlwTm9kZTtcbiAgfVxuICBzZXRWaWV3cG9ydChlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jvb3QgPSBlLCB0aGlzO1xuICB9XG4gIHNob3coZSwgbikge1xuICAgIGNvbnN0IGkgPSB0aGlzLl9nYW50dCwgYSA9IGRvY3VtZW50LmJvZHksIHIgPSB0aGlzLmdldE5vZGUoKTtcbiAgICBpZiAoWShyLCBhKSB8fCAodGhpcy5oaWRlKCksIHIuc3R5bGUudG9wID0gci5zdHlsZS50b3AgfHwgXCIwcHhcIiwgci5zdHlsZS5sZWZ0ID0gci5zdHlsZS5sZWZ0IHx8IFwiMHB4XCIsIGEuYXBwZW5kQ2hpbGQocikpLCB0aGlzLl9pc0xpa2VNb3VzZUV2ZW50KGUpKSB7XG4gICAgICBjb25zdCBzID0gdGhpcy5fY2FsY3VsYXRlVG9vbHRpcFBvc2l0aW9uKGUpO1xuICAgICAgbiA9IHMudG9wLCBlID0gcy5sZWZ0O1xuICAgIH1cbiAgICByZXR1cm4gci5zdHlsZS50b3AgPSBuICsgXCJweFwiLCByLnN0eWxlLmxlZnQgPSBlICsgXCJweFwiLCBpLl93YWlBcmlhLnRvb2x0aXBWaXNpYmxlQXR0cihyKSwgdGhpcztcbiAgfVxuICBoaWRlKCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLl9nYW50dCwgbiA9IHRoaXMuZ2V0Tm9kZSgpO1xuICAgIHJldHVybiBuICYmIG4ucGFyZW50Tm9kZSAmJiBuLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobiksIGUuX3dhaUFyaWEudG9vbHRpcEhpZGRlbkF0dHIobiksIHRoaXM7XG4gIH1cbiAgc2V0Q29udGVudChlKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Tm9kZSgpLmlubmVySFRNTCA9IGUsIHRoaXM7XG4gIH1cbiAgX2lzTGlrZU1vdXNlRXZlbnQoZSkge1xuICAgIHJldHVybiAhKCFlIHx8IHR5cGVvZiBlICE9IFwib2JqZWN0XCIpICYmIFwiY2xpZW50WFwiIGluIGUgJiYgXCJjbGllbnRZXCIgaW4gZTtcbiAgfVxuICBfZ2V0Vmlld1BvcnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jvb3QgfHwgZG9jdW1lbnQuYm9keTtcbiAgfVxuICBfY2FsY3VsYXRlVG9vbHRpcFBvc2l0aW9uKGUpIHtcbiAgICBjb25zdCBuID0gdGhpcy5fZ2FudHQsIGkgPSB0aGlzLl9nZXRWaWV3UG9ydFNpemUoKSwgYSA9IHRoaXMuZ2V0Tm9kZSgpLCByID0geyB0b3A6IDAsIGxlZnQ6IDAsIHdpZHRoOiBhLm9mZnNldFdpZHRoLCBoZWlnaHQ6IGEub2Zmc2V0SGVpZ2h0LCBib3R0b206IDAsIHJpZ2h0OiAwIH0sIHMgPSBuLmNvbmZpZy50b29sdGlwX29mZnNldF94LCBvID0gbi5jb25maWcudG9vbHRpcF9vZmZzZXRfeSwgbCA9IGRvY3VtZW50LmJvZHksIGQgPSBydChlLCBsKSwgYyA9IFYobCk7XG4gICAgZC55ICs9IGMueSwgci50b3AgPSBkLnksIHIubGVmdCA9IGQueCwgci50b3AgKz0gbywgci5sZWZ0ICs9IHMsIHIuYm90dG9tID0gci50b3AgKyByLmhlaWdodCwgci5yaWdodCA9IHIubGVmdCArIHIud2lkdGg7XG4gICAgY29uc3QgdSA9IHdpbmRvdy5zY3JvbGxZICsgbC5zY3JvbGxUb3A7XG4gICAgcmV0dXJuIHIudG9wIDwgaS50b3AgLSB1ID8gKHIudG9wID0gaS50b3AsIHIuYm90dG9tID0gci50b3AgKyByLmhlaWdodCkgOiByLmJvdHRvbSA+IGkuYm90dG9tICYmIChyLmJvdHRvbSA9IGkuYm90dG9tLCByLnRvcCA9IHIuYm90dG9tIC0gci5oZWlnaHQpLCByLmxlZnQgPCBpLmxlZnQgPyAoci5sZWZ0ID0gaS5sZWZ0LCByLnJpZ2h0ID0gaS5sZWZ0ICsgci53aWR0aCkgOiByLnJpZ2h0ID4gaS5yaWdodCAmJiAoci5yaWdodCA9IGkucmlnaHQsIHIubGVmdCA9IHIucmlnaHQgLSByLndpZHRoKSwgZC54ID49IHIubGVmdCAmJiBkLnggPD0gci5yaWdodCAmJiAoci5sZWZ0ID0gZC54IC0gci53aWR0aCAtIHMsIHIucmlnaHQgPSByLmxlZnQgKyByLndpZHRoKSwgZC55ID49IHIudG9wICYmIGQueSA8PSByLmJvdHRvbSAmJiAoci50b3AgPSBkLnkgLSByLmhlaWdodCAtIG8sIHIuYm90dG9tID0gci50b3AgKyByLmhlaWdodCksIHI7XG4gIH1cbiAgX2dldFZpZXdQb3J0U2l6ZSgpIHtcbiAgICBjb25zdCBlID0gdGhpcy5fZ2FudHQsIG4gPSB0aGlzLl9nZXRWaWV3UG9ydCgpO1xuICAgIGxldCBpLCBhID0gbiwgciA9IHdpbmRvdy5zY3JvbGxZICsgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3AsIHMgPSB3aW5kb3cuc2Nyb2xsWCArIGRvY3VtZW50LmJvZHkuc2Nyb2xsTGVmdDtcbiAgICByZXR1cm4gbiA9PT0gZS4kdGFza19kYXRhID8gKGEgPSBlLiR0YXNrLCByID0gMCwgcyA9IDAsIGkgPSBWKGUuJHRhc2spKSA6IGkgPSBWKGEpLCB7IGxlZnQ6IGkueCArIHMsIHRvcDogaS55ICsgciwgd2lkdGg6IGkud2lkdGgsIGhlaWdodDogaS5oZWlnaHQsIGJvdHRvbTogaS55ICsgaS5oZWlnaHQgKyByLCByaWdodDogaS54ICsgaS53aWR0aCArIHMgfTtcbiAgfVxufVxuY2xhc3MgV24ge1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgdGhpcy5fbGlzdGVuZXJzID0ge30sIHRoaXMudG9vbHRpcCA9IG5ldyB6bihlKSwgdGhpcy5fZ2FudHQgPSBlLCB0aGlzLl9kb21FdmVudHMgPSBTZSgpLCB0aGlzLl9pbml0RGVsYXllZEZ1bmN0aW9ucygpO1xuICB9XG4gIGRlc3RydWN0b3IoKSB7XG4gICAgdGhpcy50b29sdGlwLmhpZGUoKSwgdGhpcy5fZG9tRXZlbnRzLmRldGFjaEFsbCgpO1xuICB9XG4gIGhpZGVUb29sdGlwKCkge1xuICAgIHRoaXMuZGVsYXlIaWRlKCk7XG4gIH1cbiAgYXR0YWNoKGUpIHtcbiAgICBsZXQgbiA9IGRvY3VtZW50LmJvZHk7XG4gICAgY29uc3QgaSA9IHRoaXMuX2dhbnR0O1xuICAgIGUuZ2xvYmFsIHx8IChuID0gaS4kcm9vdCk7XG4gICAgbGV0IGEgPSBudWxsO1xuICAgIGNvbnN0IHIgPSAocykgPT4ge1xuICAgICAgY29uc3QgbyA9IHl0KHMpLCBsID0gY3QobywgZS5zZWxlY3Rvcik7XG4gICAgICBpZiAoWShvLCB0aGlzLnRvb2x0aXAuZ2V0Tm9kZSgpKSkgcmV0dXJuO1xuICAgICAgY29uc3QgZCA9ICgpID0+IHtcbiAgICAgICAgYSA9IGwsIGUub25tb3VzZWVudGVyKHMsIGwpO1xuICAgICAgfTtcbiAgICAgIGEgPyBsICYmIGwgPT09IGEgPyBlLm9ubW91c2Vtb3ZlKHMsIGwpIDogKGUub25tb3VzZWxlYXZlKHMsIGEpLCBhID0gbnVsbCwgbCAmJiBsICE9PSBhICYmIGQoKSkgOiBsICYmIGQoKTtcbiAgICB9O1xuICAgIHRoaXMuZGV0YWNoKGUuc2VsZWN0b3IpLCB0aGlzLl9kb21FdmVudHMuYXR0YWNoKG4sIFwibW91c2Vtb3ZlXCIsIHIpLCB0aGlzLl9saXN0ZW5lcnNbZS5zZWxlY3Rvcl0gPSB7IG5vZGU6IG4sIGhhbmRsZXI6IHIgfTtcbiAgfVxuICBkZXRhY2goZSkge1xuICAgIGNvbnN0IG4gPSB0aGlzLl9saXN0ZW5lcnNbZV07XG4gICAgbiAmJiB0aGlzLl9kb21FdmVudHMuZGV0YWNoKG4ubm9kZSwgXCJtb3VzZW1vdmVcIiwgbi5oYW5kbGVyKTtcbiAgfVxuICB0b29sdGlwRm9yKGUpIHtcbiAgICBjb25zdCBuID0gKGkpID0+IHtcbiAgICAgIGxldCBhID0gaTtcbiAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFdmVudE9iamVjdCAmJiAhZG9jdW1lbnQuY3JlYXRlRXZlbnQgJiYgKGEgPSBkb2N1bWVudC5jcmVhdGVFdmVudE9iamVjdChpKSksIGE7XG4gICAgfTtcbiAgICB0aGlzLl9pbml0RGVsYXllZEZ1bmN0aW9ucygpLCB0aGlzLmF0dGFjaCh7IHNlbGVjdG9yOiBlLnNlbGVjdG9yLCBnbG9iYWw6IGUuZ2xvYmFsLCBvbm1vdXNlZW50ZXI6IChpLCBhKSA9PiB7XG4gICAgICBjb25zdCByID0gZS5odG1sKGksIGEpO1xuICAgICAgciAmJiB0aGlzLmRlbGF5U2hvdyhuKGkpLCByKTtcbiAgICB9LCBvbm1vdXNlbW92ZTogKGksIGEpID0+IHtcbiAgICAgIGNvbnN0IHIgPSBlLmh0bWwoaSwgYSk7XG4gICAgICByID8gdGhpcy5kZWxheVNob3cobihpKSwgcikgOiAodGhpcy5kZWxheVNob3cuJGNhbmNlbFRpbWVvdXQoKSwgdGhpcy5kZWxheUhpZGUoKSk7XG4gICAgfSwgb25tb3VzZWxlYXZlOiAoKSA9PiB7XG4gICAgICB0aGlzLmRlbGF5U2hvdy4kY2FuY2VsVGltZW91dCgpLCB0aGlzLmRlbGF5SGlkZSgpO1xuICAgIH0gfSk7XG4gIH1cbiAgX2luaXREZWxheWVkRnVuY3Rpb25zKCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLl9nYW50dDtcbiAgICB0aGlzLmRlbGF5U2hvdyAmJiB0aGlzLmRlbGF5U2hvdy4kY2FuY2VsVGltZW91dCgpLCB0aGlzLmRlbGF5SGlkZSAmJiB0aGlzLmRlbGF5SGlkZS4kY2FuY2VsVGltZW91dCgpLCB0aGlzLnRvb2x0aXAuaGlkZSgpLCB0aGlzLmRlbGF5U2hvdyA9IERlKChuLCBpKSA9PiB7XG4gICAgICBlLmNhbGxFdmVudChcIm9uQmVmb3JlVG9vbHRpcFwiLCBbbl0pID09PSAhMSA/IHRoaXMudG9vbHRpcC5oaWRlKCkgOiAodGhpcy50b29sdGlwLnNldENvbnRlbnQoaSksIHRoaXMudG9vbHRpcC5zaG93KG4pKTtcbiAgICB9LCBlLmNvbmZpZy50b29sdGlwX3RpbWVvdXQgfHwgMSksIHRoaXMuZGVsYXlIaWRlID0gRGUoKCkgPT4ge1xuICAgICAgdGhpcy5kZWxheVNob3cuJGNhbmNlbFRpbWVvdXQoKSwgdGhpcy50b29sdGlwLmhpZGUoKTtcbiAgICB9LCBlLmNvbmZpZy50b29sdGlwX2hpZGVfdGltZW91dCB8fCAxKTtcbiAgfVxufVxuY29uc3QgSWUgPSB7IG9uQmVmb3JlVW5kbzogXCJvbkFmdGVyVW5kb1wiLCBvbkJlZm9yZVJlZG86IFwib25BZnRlclJlZG9cIiB9LCBNZSA9IFtcIm9uVGFza0RyYWdTdGFydFwiLCBcIm9uQWZ0ZXJUYXNrVXBkYXRlXCIsIFwib25BZnRlclBhcmVudEV4cGFuZFwiLCBcIm9uQWZ0ZXJUYXNrRGVsZXRlXCIsIFwib25CZWZvcmVCYXRjaFVwZGF0ZVwiXTtcbmNsYXNzIGpuIHtcbiAgY29uc3RydWN0b3IoZSwgbikge1xuICAgIHRoaXMuX2JhdGNoQWN0aW9uID0gbnVsbCwgdGhpcy5fYmF0Y2hNb2RlID0gITEsIHRoaXMuX2lnbm9yZSA9ICExLCB0aGlzLl9pZ25vcmVNb3ZlRXZlbnRzID0gITEsIHRoaXMuX2luaXRpYWxUYXNrcyA9IHt9LCB0aGlzLl9pbml0aWFsTGlua3MgPSB7fSwgdGhpcy5fbmVzdGVkVGFza3MgPSB7fSwgdGhpcy5fbmVzdGVkTGlua3MgPSB7fSwgdGhpcy5fdW5kbyA9IGUsIHRoaXMuX2dhbnR0ID0gbiwgdGhpcy5fYXR0YWNoRXZlbnRzKCk7XG4gIH1cbiAgc3RvcmUoZSwgbiwgaSA9ICExKSB7XG4gICAgcmV0dXJuIG4gPT09IHRoaXMuX2dhbnR0LmNvbmZpZy51bmRvX3R5cGVzLnRhc2sgPyB0aGlzLl9zdG9yZVRhc2soZSwgaSkgOiBuID09PSB0aGlzLl9nYW50dC5jb25maWcudW5kb190eXBlcy5saW5rICYmIHRoaXMuX3N0b3JlTGluayhlLCBpKTtcbiAgfVxuICBpc01vdmVFdmVudHNJZ25vcmVkKCkge1xuICAgIHJldHVybiB0aGlzLl9pZ25vcmVNb3ZlRXZlbnRzO1xuICB9XG4gIHRvZ2dsZUlnbm9yZU1vdmVFdmVudHMoZSkge1xuICAgIHRoaXMuX2lnbm9yZU1vdmVFdmVudHMgPSBlIHx8ICExO1xuICB9XG4gIHN0YXJ0SWdub3JlKCkge1xuICAgIHRoaXMuX2lnbm9yZSA9ICEwO1xuICB9XG4gIHN0b3BJZ25vcmUoKSB7XG4gICAgdGhpcy5faWdub3JlID0gITE7XG4gIH1cbiAgc3RhcnRCYXRjaEFjdGlvbigpIHtcbiAgICB0aGlzLl90aW1lb3V0IHx8ICh0aGlzLl90aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLnN0b3BCYXRjaEFjdGlvbigpLCB0aGlzLl90aW1lb3V0ID0gbnVsbDtcbiAgICB9LCAxMCkpLCB0aGlzLl9pZ25vcmUgfHwgdGhpcy5fYmF0Y2hNb2RlIHx8ICh0aGlzLl9iYXRjaE1vZGUgPSAhMCwgdGhpcy5fYmF0Y2hBY3Rpb24gPSB0aGlzLl91bmRvLmFjdGlvbi5jcmVhdGUoKSk7XG4gIH1cbiAgc3RvcEJhdGNoQWN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9pZ25vcmUpIHJldHVybjtcbiAgICBjb25zdCBlID0gdGhpcy5fdW5kbztcbiAgICB0aGlzLl9iYXRjaEFjdGlvbiAmJiBlLmxvZ0FjdGlvbih0aGlzLl9iYXRjaEFjdGlvbiksIHRoaXMuX2JhdGNoTW9kZSA9ICExLCB0aGlzLl9iYXRjaEFjdGlvbiA9IG51bGw7XG4gIH1cbiAgb25UYXNrQWRkZWQoZSkge1xuICAgIHRoaXMuX2lnbm9yZSB8fCB0aGlzLl9zdG9yZVRhc2tDb21tYW5kKGUsIHRoaXMuX3VuZG8uY29tbWFuZC50eXBlLmFkZCk7XG4gIH1cbiAgb25UYXNrVXBkYXRlZChlKSB7XG4gICAgdGhpcy5faWdub3JlIHx8IHRoaXMuX3N0b3JlVGFza0NvbW1hbmQoZSwgdGhpcy5fdW5kby5jb21tYW5kLnR5cGUudXBkYXRlKTtcbiAgfVxuICBvblRhc2tNb3ZlZChlKSB7XG4gICAgdGhpcy5faWdub3JlIHx8IChlLiRsb2NhbF9pbmRleCA9IHRoaXMuX2dhbnR0LmdldFRhc2tJbmRleChlLmlkKSwgdGhpcy5fc3RvcmVFbnRpdHlDb21tYW5kKGUsIHRoaXMuZ2V0SW5pdGlhbFRhc2soZS5pZCksIHRoaXMuX3VuZG8uY29tbWFuZC50eXBlLm1vdmUsIHRoaXMuX3VuZG8uY29tbWFuZC5lbnRpdHkudGFzaykpO1xuICB9XG4gIG9uVGFza0RlbGV0ZWQoZSkge1xuICAgIGlmICghdGhpcy5faWdub3JlKSB7XG4gICAgICBpZiAodGhpcy5fc3RvcmVUYXNrQ29tbWFuZChlLCB0aGlzLl91bmRvLmNvbW1hbmQudHlwZS5yZW1vdmUpLCB0aGlzLl9uZXN0ZWRUYXNrc1tlLmlkXSkge1xuICAgICAgICBjb25zdCBuID0gdGhpcy5fbmVzdGVkVGFza3NbZS5pZF07XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbi5sZW5ndGg7IGkrKykgdGhpcy5fc3RvcmVUYXNrQ29tbWFuZChuW2ldLCB0aGlzLl91bmRvLmNvbW1hbmQudHlwZS5yZW1vdmUpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX25lc3RlZExpbmtzW2UuaWRdKSB7XG4gICAgICAgIGNvbnN0IG4gPSB0aGlzLl9uZXN0ZWRMaW5rc1tlLmlkXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuLmxlbmd0aDsgaSsrKSB0aGlzLl9zdG9yZUxpbmtDb21tYW5kKG5baV0sIHRoaXMuX3VuZG8uY29tbWFuZC50eXBlLnJlbW92ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIG9uTGlua0FkZGVkKGUpIHtcbiAgICB0aGlzLl9pZ25vcmUgfHwgdGhpcy5fc3RvcmVMaW5rQ29tbWFuZChlLCB0aGlzLl91bmRvLmNvbW1hbmQudHlwZS5hZGQpO1xuICB9XG4gIG9uTGlua1VwZGF0ZWQoZSkge1xuICAgIHRoaXMuX2lnbm9yZSB8fCB0aGlzLl9zdG9yZUxpbmtDb21tYW5kKGUsIHRoaXMuX3VuZG8uY29tbWFuZC50eXBlLnVwZGF0ZSk7XG4gIH1cbiAgb25MaW5rRGVsZXRlZChlKSB7XG4gICAgdGhpcy5faWdub3JlIHx8IHRoaXMuX3N0b3JlTGlua0NvbW1hbmQoZSwgdGhpcy5fdW5kby5jb21tYW5kLnR5cGUucmVtb3ZlKTtcbiAgfVxuICBzZXROZXN0ZWRUYXNrcyhlLCBuKSB7XG4gICAgY29uc3QgaSA9IHRoaXMuX2dhbnR0O1xuICAgIGxldCBhID0gbnVsbDtcbiAgICBjb25zdCByID0gW107XG4gICAgbGV0IHMgPSB0aGlzLl9nZXRMaW5rcyhpLmdldFRhc2soZSkpO1xuICAgIGZvciAobGV0IGQgPSAwOyBkIDwgbi5sZW5ndGg7IGQrKykgYSA9IHRoaXMuc2V0SW5pdGlhbFRhc2sobltkXSksIHMgPSBzLmNvbmNhdCh0aGlzLl9nZXRMaW5rcyhhKSksIHIucHVzaChhKTtcbiAgICBjb25zdCBvID0ge307XG4gICAgZm9yIChsZXQgZCA9IDA7IGQgPCBzLmxlbmd0aDsgZCsrKSBvW3NbZF1dID0gITA7XG4gICAgY29uc3QgbCA9IFtdO1xuICAgIGZvciAoY29uc3QgZCBpbiBvKSBsLnB1c2godGhpcy5zZXRJbml0aWFsTGluayhkKSk7XG4gICAgdGhpcy5fbmVzdGVkVGFza3NbZV0gPSByLCB0aGlzLl9uZXN0ZWRMaW5rc1tlXSA9IGw7XG4gIH1cbiAgc2V0SW5pdGlhbFRhc2soZSwgbikge1xuICAgIGNvbnN0IGkgPSB0aGlzLl9nYW50dDtcbiAgICBpZiAobiB8fCAhdGhpcy5faW5pdGlhbFRhc2tzW2VdIHx8ICF0aGlzLl9iYXRjaE1vZGUpIHtcbiAgICAgIGNvbnN0IGEgPSBpLmNvcHkoaS5nZXRUYXNrKGUpKTtcbiAgICAgIGEuJGluZGV4ID0gaS5nZXRHbG9iYWxUYXNrSW5kZXgoZSksIGEuJGxvY2FsX2luZGV4ID0gaS5nZXRUYXNrSW5kZXgoZSksIHRoaXMuc2V0SW5pdGlhbFRhc2tPYmplY3QoZSwgYSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9pbml0aWFsVGFza3NbZV07XG4gIH1cbiAgZ2V0SW5pdGlhbFRhc2soZSkge1xuICAgIHJldHVybiB0aGlzLl9pbml0aWFsVGFza3NbZV07XG4gIH1cbiAgY2xlYXJJbml0aWFsVGFza3MoKSB7XG4gICAgdGhpcy5faW5pdGlhbFRhc2tzID0ge307XG4gIH1cbiAgc2V0SW5pdGlhbFRhc2tPYmplY3QoZSwgbikge1xuICAgIHRoaXMuX2luaXRpYWxUYXNrc1tlXSA9IG47XG4gIH1cbiAgc2V0SW5pdGlhbExpbmsoZSwgbikge1xuICAgIHJldHVybiB0aGlzLl9pbml0aWFsTGlua3NbZV0gJiYgdGhpcy5fYmF0Y2hNb2RlIHx8ICh0aGlzLl9pbml0aWFsTGlua3NbZV0gPSB0aGlzLl9nYW50dC5jb3B5KHRoaXMuX2dhbnR0LmdldExpbmsoZSkpKSwgdGhpcy5faW5pdGlhbExpbmtzW2VdO1xuICB9XG4gIGdldEluaXRpYWxMaW5rKGUpIHtcbiAgICByZXR1cm4gdGhpcy5faW5pdGlhbExpbmtzW2VdO1xuICB9XG4gIGNsZWFySW5pdGlhbExpbmtzKCkge1xuICAgIHRoaXMuX2luaXRpYWxMaW5rcyA9IHt9O1xuICB9XG4gIF9hdHRhY2hFdmVudHMoKSB7XG4gICAgbGV0IGUgPSBudWxsO1xuICAgIGNvbnN0IG4gPSB0aGlzLl9nYW50dCwgaSA9ICgpID0+IHtcbiAgICAgIGUgfHwgKGUgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgZSA9IG51bGw7XG4gICAgICB9KSwgdGhpcy5jbGVhckluaXRpYWxUYXNrcygpLCBuLmVhY2hUYXNrKChsKSA9PiB7XG4gICAgICAgIHRoaXMuc2V0SW5pdGlhbFRhc2sobC5pZCk7XG4gICAgICB9KSwgdGhpcy5jbGVhckluaXRpYWxMaW5rcygpLCBuLmdldExpbmtzKCkuZm9yRWFjaCgobCkgPT4ge1xuICAgICAgICB0aGlzLnNldEluaXRpYWxMaW5rKGwuaWQpO1xuICAgICAgfSkpO1xuICAgIH0sIGEgPSAobCkgPT4gbi5jb3B5KG4uZ2V0VGFzayhsKSk7XG4gICAgZm9yIChjb25zdCBsIGluIEllKSBuLmF0dGFjaEV2ZW50KGwsICgpID0+ICh0aGlzLnN0YXJ0SWdub3JlKCksICEwKSksIG4uYXR0YWNoRXZlbnQoSWVbbF0sICgpID0+ICh0aGlzLnN0b3BJZ25vcmUoKSwgITApKTtcbiAgICBmb3IgKGxldCBsID0gMDsgbCA8IE1lLmxlbmd0aDsgbCsrKSBuLmF0dGFjaEV2ZW50KE1lW2xdLCAoKSA9PiAodGhpcy5zdGFydEJhdGNoQWN0aW9uKCksICEwKSk7XG4gICAgbi5hdHRhY2hFdmVudChcIm9uUGFyc2VcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5fdW5kby5jbGVhclVuZG9TdGFjaygpLCB0aGlzLl91bmRvLmNsZWFyUmVkb1N0YWNrKCksIGkoKTtcbiAgICB9KSwgbi5hdHRhY2hFdmVudChcIm9uQWZ0ZXJUYXNrQWRkXCIsIChsLCBkKSA9PiB7XG4gICAgICB0aGlzLnNldEluaXRpYWxUYXNrKGwsICEwKSwgdGhpcy5vblRhc2tBZGRlZChkKTtcbiAgICB9KSwgbi5hdHRhY2hFdmVudChcIm9uQWZ0ZXJUYXNrVXBkYXRlXCIsIChsLCBkKSA9PiB7XG4gICAgICB0aGlzLm9uVGFza1VwZGF0ZWQoZCk7XG4gICAgfSksIG4uYXR0YWNoRXZlbnQoXCJvbkFmdGVyUGFyZW50RXhwYW5kXCIsIChsLCBkKSA9PiB7XG4gICAgICB0aGlzLm9uVGFza1VwZGF0ZWQoZCk7XG4gICAgfSksIG4uYXR0YWNoRXZlbnQoXCJvbkFmdGVyVGFza0RlbGV0ZVwiLCAobCwgZCkgPT4ge1xuICAgICAgdGhpcy5vblRhc2tEZWxldGVkKGQpO1xuICAgIH0pLCBuLmF0dGFjaEV2ZW50KFwib25BZnRlckxpbmtBZGRcIiwgKGwsIGQpID0+IHtcbiAgICAgIHRoaXMuc2V0SW5pdGlhbExpbmsobCwgITApLCB0aGlzLm9uTGlua0FkZGVkKGQpO1xuICAgIH0pLCBuLmF0dGFjaEV2ZW50KFwib25BZnRlckxpbmtVcGRhdGVcIiwgKGwsIGQpID0+IHtcbiAgICAgIHRoaXMub25MaW5rVXBkYXRlZChkKTtcbiAgICB9KSwgbi5hdHRhY2hFdmVudChcIm9uQWZ0ZXJMaW5rRGVsZXRlXCIsIChsLCBkKSA9PiB7XG4gICAgICB0aGlzLm9uTGlua0RlbGV0ZWQoZCk7XG4gICAgfSksIG4uYXR0YWNoRXZlbnQoXCJvblJvd0RyYWdFbmRcIiwgKGwsIGQpID0+ICh0aGlzLm9uVGFza01vdmVkKGEobCkpLCB0aGlzLnRvZ2dsZUlnbm9yZU1vdmVFdmVudHMoKSwgITApKSwgbi5hdHRhY2hFdmVudChcIm9uQmVmb3JlVGFza0RlbGV0ZVwiLCAobCkgPT4ge1xuICAgICAgdGhpcy5zdG9yZShsLCBuLmNvbmZpZy51bmRvX3R5cGVzLnRhc2spO1xuICAgICAgY29uc3QgZCA9IFtdO1xuICAgICAgcmV0dXJuIGkoKSwgbi5lYWNoVGFzaygoYykgPT4ge1xuICAgICAgICBkLnB1c2goYy5pZCk7XG4gICAgICB9LCBsKSwgdGhpcy5zZXROZXN0ZWRUYXNrcyhsLCBkKSwgITA7XG4gICAgfSk7XG4gICAgY29uc3QgciA9IG4uZ2V0RGF0YXN0b3JlKFwidGFza1wiKTtcbiAgICByLmF0dGFjaEV2ZW50KFwib25CZWZvcmVJdGVtTW92ZVwiLCAobCwgZCwgYykgPT4gKHRoaXMuaXNNb3ZlRXZlbnRzSWdub3JlZCgpIHx8IGkoKSwgITApKSwgci5hdHRhY2hFdmVudChcIm9uQWZ0ZXJJdGVtTW92ZVwiLCAobCwgZCwgYykgPT4gKHRoaXMuaXNNb3ZlRXZlbnRzSWdub3JlZCgpIHx8IHRoaXMub25UYXNrTW92ZWQoYShsKSksICEwKSksIG4uYXR0YWNoRXZlbnQoXCJvblJvd0RyYWdTdGFydFwiLCAobCwgZCwgYykgPT4gKHRoaXMudG9nZ2xlSWdub3JlTW92ZUV2ZW50cyghMCksIGkoKSwgITApKTtcbiAgICBsZXQgcyA9IG51bGwsIG8gPSAhMTtcbiAgICBpZiAobi5hdHRhY2hFdmVudChcIm9uQmVmb3JlVGFza0RyYWdcIiwgKGwpID0+IHtcbiAgICAgIGlmIChzID0gbi5nZXRTdGF0ZSgpLmRyYWdfaWQsIHMgPT09IGwpIHtcbiAgICAgICAgY29uc3QgZCA9IG4uZ2V0VGFzayhsKTtcbiAgICAgICAgbi5pc1N1bW1hcnlUYXNrKGQpICYmIG4uY29uZmlnLmRyYWdfcHJvamVjdCAmJiAobyA9ICEwKTtcbiAgICAgIH1cbiAgICAgIGlmIChuLnBsdWdpbnMoKS5tdWx0aXNlbGVjdCkge1xuICAgICAgICBjb25zdCBkID0gbi5nZXRTZWxlY3RlZFRhc2tzKCk7XG4gICAgICAgIGQubGVuZ3RoID4gMSAmJiBkLmZvckVhY2goKGMpID0+IHtcbiAgICAgICAgICB0aGlzLnN0b3JlKGMsIG4uY29uZmlnLnVuZG9fdHlwZXMudGFzaywgITApO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnN0b3JlKGwsIG4uY29uZmlnLnVuZG9fdHlwZXMudGFzayk7XG4gICAgfSksIG4uYXR0YWNoRXZlbnQoXCJvbkFmdGVyVGFza0RyYWdcIiwgKGwpID0+IHtcbiAgICAgIChvIHx8IG4ucGx1Z2lucygpLm11bHRpc2VsZWN0ICYmIG4uZ2V0U2VsZWN0ZWRUYXNrcygpLmxlbmd0aCA+IDEpICYmIHMgPT09IGwgJiYgKG8gPSAhMSwgcyA9IG51bGwsIHRoaXMuc3RvcEJhdGNoQWN0aW9uKCkpLCB0aGlzLnN0b3JlKGwsIG4uY29uZmlnLnVuZG9fdHlwZXMudGFzaywgITApO1xuICAgIH0pLCBuLmF0dGFjaEV2ZW50KFwib25MaWdodGJveFwiLCAobCkgPT4gdGhpcy5zdG9yZShsLCBuLmNvbmZpZy51bmRvX3R5cGVzLnRhc2spKSwgbi5hdHRhY2hFdmVudChcIm9uQmVmb3JlVGFza0F1dG9TY2hlZHVsZVwiLCAobCkgPT4gKHRoaXMuc3RvcmUobC5pZCwgbi5jb25maWcudW5kb190eXBlcy50YXNrLCAhMCksICEwKSksIG4uZXh0LmlubGluZUVkaXRvcnMpIHtcbiAgICAgIGxldCBsID0gbnVsbCwgZCA9IG51bGw7XG4gICAgICBuLmF0dGFjaEV2ZW50KFwib25HYW50dExheW91dFJlYWR5XCIsICgpID0+IHtcbiAgICAgICAgbCAmJiBuLmV4dC5pbmxpbmVFZGl0b3JzLmRldGFjaEV2ZW50KGwpLCBkICYmIG4uZXh0LmlubGluZUVkaXRvcnMuZGV0YWNoRXZlbnQoZCksIGQgPSBuLmV4dC5pbmxpbmVFZGl0b3JzLmF0dGFjaEV2ZW50KFwib25FZGl0U3RhcnRcIiwgKGMpID0+IHtcbiAgICAgICAgICB0aGlzLnN0b3JlKGMuaWQsIG4uY29uZmlnLnVuZG9fdHlwZXMudGFzayk7XG4gICAgICAgIH0pLCBsID0gbi5leHQuaW5saW5lRWRpdG9ycy5hdHRhY2hFdmVudChcIm9uQmVmb3JlRWRpdFN0YXJ0XCIsIChjKSA9PiAodGhpcy5zdG9wQmF0Y2hBY3Rpb24oKSwgITApKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBfc3RvcmVDb21tYW5kKGUpIHtcbiAgICBjb25zdCBuID0gdGhpcy5fdW5kbztcbiAgICBpZiAobi51cGRhdGVDb25maWdzKCksIG4udW5kb0VuYWJsZWQpIGlmICh0aGlzLl9iYXRjaE1vZGUpIHRoaXMuX2JhdGNoQWN0aW9uLmNvbW1hbmRzLnB1c2goZSk7XG4gICAgZWxzZSB7XG4gICAgICBjb25zdCBpID0gbi5hY3Rpb24uY3JlYXRlKFtlXSk7XG4gICAgICBuLmxvZ0FjdGlvbihpKTtcbiAgICB9XG4gIH1cbiAgX3N0b3JlRW50aXR5Q29tbWFuZChlLCBuLCBpLCBhKSB7XG4gICAgY29uc3QgciA9IHRoaXMuX3VuZG8uY29tbWFuZC5jcmVhdGUoZSwgbiwgaSwgYSk7XG4gICAgdGhpcy5fc3RvcmVDb21tYW5kKHIpO1xuICB9XG4gIF9zdG9yZVRhc2tDb21tYW5kKGUsIG4pIHtcbiAgICB0aGlzLl9nYW50dC5pc1Rhc2tFeGlzdHMoZS5pZCkgJiYgKGUuJGxvY2FsX2luZGV4ID0gdGhpcy5fZ2FudHQuZ2V0VGFza0luZGV4KGUuaWQpKSwgdGhpcy5fc3RvcmVFbnRpdHlDb21tYW5kKGUsIHRoaXMuZ2V0SW5pdGlhbFRhc2soZS5pZCksIG4sIHRoaXMuX3VuZG8uY29tbWFuZC5lbnRpdHkudGFzayk7XG4gIH1cbiAgX3N0b3JlTGlua0NvbW1hbmQoZSwgbikge1xuICAgIHRoaXMuX3N0b3JlRW50aXR5Q29tbWFuZChlLCB0aGlzLmdldEluaXRpYWxMaW5rKGUuaWQpLCBuLCB0aGlzLl91bmRvLmNvbW1hbmQuZW50aXR5LmxpbmspO1xuICB9XG4gIF9nZXRMaW5rcyhlKSB7XG4gICAgcmV0dXJuIGUuJHNvdXJjZS5jb25jYXQoZS4kdGFyZ2V0KTtcbiAgfVxuICBfc3RvcmVUYXNrKGUsIG4gPSAhMSkge1xuICAgIGNvbnN0IGkgPSB0aGlzLl9nYW50dDtcbiAgICByZXR1cm4gdGhpcy5zZXRJbml0aWFsVGFzayhlLCBuKSwgaS5lYWNoVGFzaygoYSkgPT4ge1xuICAgICAgdGhpcy5zZXRJbml0aWFsVGFzayhhLmlkKTtcbiAgICB9LCBlKSwgITA7XG4gIH1cbiAgX3N0b3JlTGluayhlLCBuID0gITEpIHtcbiAgICByZXR1cm4gdGhpcy5zZXRJbml0aWFsTGluayhlLCBuKSwgITA7XG4gIH1cbn1cbmNsYXNzIEZuIHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHRoaXMubWF4U3RlcHMgPSAxMDAsIHRoaXMudW5kb0VuYWJsZWQgPSAhMCwgdGhpcy5yZWRvRW5hYmxlZCA9ICEwLCB0aGlzLmFjdGlvbiA9IHsgY3JlYXRlOiAobikgPT4gKHsgY29tbWFuZHM6IG4gPyBuLnNsaWNlKCkgOiBbXSB9KSwgaW52ZXJ0OiAobikgPT4ge1xuICAgICAgY29uc3QgaSA9IHRoaXMuX2dhbnR0LmNvcHkobiksIGEgPSB0aGlzLmNvbW1hbmQ7XG4gICAgICBmb3IgKGxldCByID0gMDsgciA8IG4uY29tbWFuZHMubGVuZ3RoOyByKyspIHtcbiAgICAgICAgY29uc3QgcyA9IGkuY29tbWFuZHNbcl0gPSBhLmludmVydChpLmNvbW1hbmRzW3JdKTtcbiAgICAgICAgcy50eXBlICE9PSBhLnR5cGUudXBkYXRlICYmIHMudHlwZSAhPT0gYS50eXBlLm1vdmUgfHwgKFtzLnZhbHVlLCBzLm9sZFZhbHVlXSA9IFtzLm9sZFZhbHVlLCBzLnZhbHVlXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaTtcbiAgICB9IH0sIHRoaXMuY29tbWFuZCA9IHsgZW50aXR5OiBudWxsLCB0eXBlOiBudWxsLCBjcmVhdGU6IChuLCBpLCBhLCByKSA9PiB7XG4gICAgICBjb25zdCBzID0gdGhpcy5fZ2FudHQ7XG4gICAgICByZXR1cm4geyBlbnRpdHk6IHIsIHR5cGU6IGEsIHZhbHVlOiBzLmNvcHkobiksIG9sZFZhbHVlOiBzLmNvcHkoaSB8fCBuKSB9O1xuICAgIH0sIGludmVydDogKG4pID0+IHtcbiAgICAgIGNvbnN0IGkgPSB0aGlzLl9nYW50dC5jb3B5KG4pO1xuICAgICAgcmV0dXJuIGkudHlwZSA9IHRoaXMuY29tbWFuZC5pbnZlcnNlQ29tbWFuZHMobi50eXBlKSwgaTtcbiAgICB9LCBpbnZlcnNlQ29tbWFuZHM6IChuKSA9PiB7XG4gICAgICBjb25zdCBpID0gdGhpcy5fZ2FudHQsIGEgPSB0aGlzLmNvbW1hbmQudHlwZTtcbiAgICAgIHN3aXRjaCAobikge1xuICAgICAgICBjYXNlIGEudXBkYXRlOlxuICAgICAgICAgIHJldHVybiBhLnVwZGF0ZTtcbiAgICAgICAgY2FzZSBhLnJlbW92ZTpcbiAgICAgICAgICByZXR1cm4gYS5hZGQ7XG4gICAgICAgIGNhc2UgYS5hZGQ6XG4gICAgICAgICAgcmV0dXJuIGEucmVtb3ZlO1xuICAgICAgICBjYXNlIGEubW92ZTpcbiAgICAgICAgICByZXR1cm4gYS5tb3ZlO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBpLmFzc2VydCghMSwgXCJJbnZhbGlkIGNvbW1hbmQgXCIgKyBuKSwgbnVsbDtcbiAgICAgIH1cbiAgICB9IH0sIHRoaXMuX3VuZG9TdGFjayA9IFtdLCB0aGlzLl9yZWRvU3RhY2sgPSBbXSwgdGhpcy5fZ2FudHQgPSBlO1xuICB9XG4gIGdldFVuZG9TdGFjaygpIHtcbiAgICByZXR1cm4gdGhpcy5fdW5kb1N0YWNrO1xuICB9XG4gIHNldFVuZG9TdGFjayhlKSB7XG4gICAgdGhpcy5fdW5kb1N0YWNrID0gZTtcbiAgfVxuICBnZXRSZWRvU3RhY2soKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlZG9TdGFjaztcbiAgfVxuICBzZXRSZWRvU3RhY2soZSkge1xuICAgIHRoaXMuX3JlZG9TdGFjayA9IGU7XG4gIH1cbiAgY2xlYXJVbmRvU3RhY2soKSB7XG4gICAgdGhpcy5fdW5kb1N0YWNrID0gW107XG4gIH1cbiAgY2xlYXJSZWRvU3RhY2soKSB7XG4gICAgdGhpcy5fcmVkb1N0YWNrID0gW107XG4gIH1cbiAgdXBkYXRlQ29uZmlncygpIHtcbiAgICBjb25zdCBlID0gdGhpcy5fZ2FudHQ7XG4gICAgdGhpcy5tYXhTdGVwcyA9IGUuY29uZmlnLnVuZG9fc3RlcHMgfHwgMTAwLCB0aGlzLmNvbW1hbmQuZW50aXR5ID0gZS5jb25maWcudW5kb190eXBlcywgdGhpcy5jb21tYW5kLnR5cGUgPSBlLmNvbmZpZy51bmRvX2FjdGlvbnMsIHRoaXMudW5kb0VuYWJsZWQgPSAhIWUuY29uZmlnLnVuZG8sIHRoaXMucmVkb0VuYWJsZWQgPSAhIWUuY29uZmlnLnJlZG87XG4gIH1cbiAgdW5kbygpIHtcbiAgICBjb25zdCBlID0gdGhpcy5fZ2FudHQ7XG4gICAgaWYgKHRoaXMudXBkYXRlQ29uZmlncygpLCAhdGhpcy51bmRvRW5hYmxlZCkgcmV0dXJuO1xuICAgIGNvbnN0IG4gPSB0aGlzLl9wb3AodGhpcy5fdW5kb1N0YWNrKTtcbiAgICBpZiAobiAmJiB0aGlzLl9yZW9yZGVyQ29tbWFuZHMobiksIGUuY2FsbEV2ZW50KFwib25CZWZvcmVVbmRvXCIsIFtuXSkgIT09ICExICYmIG4pIHJldHVybiB0aGlzLl9hcHBseUFjdGlvbih0aGlzLmFjdGlvbi5pbnZlcnQobikpLCB0aGlzLl9wdXNoKHRoaXMuX3JlZG9TdGFjaywgZS5jb3B5KG4pKSwgdm9pZCBlLmNhbGxFdmVudChcIm9uQWZ0ZXJVbmRvXCIsIFtuXSk7XG4gICAgZS5jYWxsRXZlbnQoXCJvbkFmdGVyVW5kb1wiLCBbbnVsbF0pO1xuICB9XG4gIHJlZG8oKSB7XG4gICAgY29uc3QgZSA9IHRoaXMuX2dhbnR0O1xuICAgIGlmICh0aGlzLnVwZGF0ZUNvbmZpZ3MoKSwgIXRoaXMucmVkb0VuYWJsZWQpIHJldHVybjtcbiAgICBjb25zdCBuID0gdGhpcy5fcG9wKHRoaXMuX3JlZG9TdGFjayk7XG4gICAgaWYgKG4gJiYgdGhpcy5fcmVvcmRlckNvbW1hbmRzKG4pLCBlLmNhbGxFdmVudChcIm9uQmVmb3JlUmVkb1wiLCBbbl0pICE9PSAhMSAmJiBuKSByZXR1cm4gdGhpcy5fYXBwbHlBY3Rpb24obiksIHRoaXMuX3B1c2godGhpcy5fdW5kb1N0YWNrLCBlLmNvcHkobikpLCB2b2lkIGUuY2FsbEV2ZW50KFwib25BZnRlclJlZG9cIiwgW25dKTtcbiAgICBlLmNhbGxFdmVudChcIm9uQWZ0ZXJSZWRvXCIsIFtudWxsXSk7XG4gIH1cbiAgbG9nQWN0aW9uKGUpIHtcbiAgICB0aGlzLl9wdXNoKHRoaXMuX3VuZG9TdGFjaywgZSksIHRoaXMuX3JlZG9TdGFjayA9IFtdO1xuICB9XG4gIF9wdXNoKGUsIG4pIHtcbiAgICBjb25zdCBpID0gdGhpcy5fZ2FudHQ7XG4gICAgaWYgKCFuLmNvbW1hbmRzLmxlbmd0aCkgcmV0dXJuO1xuICAgIGNvbnN0IGEgPSBlID09PSB0aGlzLl91bmRvU3RhY2sgPyBcIm9uQmVmb3JlVW5kb1N0YWNrXCIgOiBcIm9uQmVmb3JlUmVkb1N0YWNrXCI7XG4gICAgaWYgKGkuY2FsbEV2ZW50KGEsIFtuXSkgIT09ICExICYmIG4uY29tbWFuZHMubGVuZ3RoKSB7XG4gICAgICBmb3IgKGUucHVzaChuKTsgZS5sZW5ndGggPiB0aGlzLm1heFN0ZXBzOyApIGUuc2hpZnQoKTtcbiAgICAgIHJldHVybiBuO1xuICAgIH1cbiAgfVxuICBfcG9wKGUpIHtcbiAgICByZXR1cm4gZS5wb3AoKTtcbiAgfVxuICBfcmVvcmRlckNvbW1hbmRzKGUpIHtcbiAgICBjb25zdCBuID0geyBhbnk6IDAsIGxpbms6IDEsIHRhc2s6IDIgfSwgaSA9IHsgbW92ZTogMSwgYW55OiAwIH07XG4gICAgZS5jb21tYW5kcy5zb3J0KGZ1bmN0aW9uKGEsIHIpIHtcbiAgICAgIGlmIChhLmVudGl0eSA9PT0gXCJ0YXNrXCIgJiYgci5lbnRpdHkgPT09IFwidGFza1wiKSByZXR1cm4gYS50eXBlICE9PSByLnR5cGUgPyAoaVtyLnR5cGVdIHx8IDApIC0gKGlbYS50eXBlXSB8fCAwKSA6IGEudHlwZSA9PT0gXCJtb3ZlXCIgJiYgYS5vbGRWYWx1ZSAmJiByLm9sZFZhbHVlICYmIHIub2xkVmFsdWUucGFyZW50ID09PSBhLm9sZFZhbHVlLnBhcmVudCA/IGEub2xkVmFsdWUuJGluZGV4IC0gci5vbGRWYWx1ZS4kaW5kZXggOiAwO1xuICAgICAge1xuICAgICAgICBjb25zdCBzID0gblthLmVudGl0eV0gfHwgbi5hbnk7XG4gICAgICAgIHJldHVybiAobltyLmVudGl0eV0gfHwgbi5hbnkpIC0gcztcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBfYXBwbHlBY3Rpb24oZSkge1xuICAgIGxldCBuID0gbnVsbDtcbiAgICBjb25zdCBpID0gdGhpcy5jb21tYW5kLmVudGl0eSwgYSA9IHRoaXMuY29tbWFuZC50eXBlLCByID0gdGhpcy5fZ2FudHQsIHMgPSB7fTtcbiAgICBzW2kudGFza10gPSB7IGFkZDogXCJhZGRUYXNrXCIsIGdldDogXCJnZXRUYXNrXCIsIHVwZGF0ZTogXCJ1cGRhdGVUYXNrXCIsIHJlbW92ZTogXCJkZWxldGVUYXNrXCIsIG1vdmU6IFwibW92ZVRhc2tcIiwgaXNFeGlzdHM6IFwiaXNUYXNrRXhpc3RzXCIgfSwgc1tpLmxpbmtdID0geyBhZGQ6IFwiYWRkTGlua1wiLCBnZXQ6IFwiZ2V0TGlua1wiLCB1cGRhdGU6IFwidXBkYXRlTGlua1wiLCByZW1vdmU6IFwiZGVsZXRlTGlua1wiLCBpc0V4aXN0czogXCJpc0xpbmtFeGlzdHNcIiB9LCByLmJhdGNoVXBkYXRlKGZ1bmN0aW9uKCkge1xuICAgICAgZm9yIChsZXQgbyA9IDA7IG8gPCBlLmNvbW1hbmRzLmxlbmd0aDsgbysrKSB7XG4gICAgICAgIG4gPSBlLmNvbW1hbmRzW29dO1xuICAgICAgICBjb25zdCBsID0gc1tuLmVudGl0eV1bbi50eXBlXSwgZCA9IHNbbi5lbnRpdHldLmdldCwgYyA9IHNbbi5lbnRpdHldLmlzRXhpc3RzO1xuICAgICAgICBpZiAobi50eXBlID09PSBhLmFkZCkgcltsXShuLm9sZFZhbHVlLCBuLm9sZFZhbHVlLnBhcmVudCwgbi5vbGRWYWx1ZS4kbG9jYWxfaW5kZXgpO1xuICAgICAgICBlbHNlIGlmIChuLnR5cGUgPT09IGEucmVtb3ZlKSByW2NdKG4udmFsdWUuaWQpICYmIHJbbF0obi52YWx1ZS5pZCk7XG4gICAgICAgIGVsc2UgaWYgKG4udHlwZSA9PT0gYS51cGRhdGUpIHtcbiAgICAgICAgICBjb25zdCB1ID0gcltkXShuLnZhbHVlLmlkKTtcbiAgICAgICAgICBmb3IgKGNvbnN0IGggaW4gbi52YWx1ZSkge1xuICAgICAgICAgICAgbGV0IGcgPSAhKGguc3RhcnRzV2l0aChcIiRcIikgfHwgaC5zdGFydHNXaXRoKFwiX1wiKSk7XG4gICAgICAgICAgICBbXCIkb3BlblwiXS5pbmRleE9mKGgpID4gLTEgJiYgKGcgPSAhMCksIGcgJiYgKHVbaF0gPSBuLnZhbHVlW2hdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcltsXShuLnZhbHVlLmlkKTtcbiAgICAgICAgfSBlbHNlIG4udHlwZSA9PT0gYS5tb3ZlICYmIChyW2xdKG4udmFsdWUuaWQsIG4udmFsdWUuJGxvY2FsX2luZGV4LCBuLnZhbHVlLnBhcmVudCksIHIuY2FsbEV2ZW50KFwib25Sb3dEcmFnRW5kXCIsIFtuLnZhbHVlLmlkXSkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5jb25zdCBWbiA9IHsgY2xpY2tfZHJhZzogZnVuY3Rpb24odCkge1xuICB0LmV4dCB8fCAodC5leHQgPSB7fSk7XG4gIGNvbnN0IGUgPSB7IGNsYXNzTmFtZTogXCJnYW50dF9jbGlja19kcmFnX3JlY3RcIiwgdXNlUmVxdWVzdEFuaW1hdGlvbkZyYW1lOiAhMCwgY2FsbGJhY2s6IHZvaWQgMCwgc2luZ2xlUm93OiAhMSB9O1xuICBmdW5jdGlvbiBuKCkge1xuICAgIGNvbnN0IGkgPSB7IHZpZXdQb3J0OiB0LiR0YXNrX2RhdGEsIC4uLmUgfTtcbiAgICB0LmV4dC5jbGlja0RyYWcgJiYgdC5leHQuY2xpY2tEcmFnLmRlc3RydWN0b3IoKSwgdC5leHQuY2xpY2tEcmFnID0gbmV3IE5uKHQpO1xuICAgIGNvbnN0IGEgPSB0LmNvbmZpZy5jbGlja19kcmFnO1xuICAgIGkucmVuZGVyID0gYS5yZW5kZXIgfHwgZS5yZW5kZXIsIGkuY2xhc3NOYW1lID0gYS5jbGFzc05hbWUgfHwgZS5jbGFzc05hbWUsIGkuY2FsbGJhY2sgPSBhLmNhbGxiYWNrIHx8IGUuY2FsbGJhY2ssIGkudmlld1BvcnQgPSBhLnZpZXdQb3J0IHx8IHQuJHRhc2tfZGF0YSwgaS51c2VSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBhLnVzZVJlcXVlc3RBbmltYXRpb25GcmFtZSA9PT0gdm9pZCAwID8gZS51c2VSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgOiBhLnVzZVJlcXVlc3RBbmltYXRpb25GcmFtZSwgaS5zaW5nbGVSb3cgPSBhLnNpbmdsZVJvdyA9PT0gdm9pZCAwID8gZS5zaW5nbGVSb3cgOiBhLnNpbmdsZVJvdztcbiAgICBjb25zdCByID0gdC4kdWkuZ2V0VmlldyhcInRpbWVsaW5lXCIpLCBzID0gbmV3IFBuKGksIHQsIHIpO1xuICAgIHQuZXh0LmNsaWNrRHJhZy5hdHRhY2gocywgYS51c2VLZXksIGEuaWdub3JlKTtcbiAgfVxuICB0LmF0dGFjaEV2ZW50KFwib25HYW50dFJlYWR5XCIsICgpID0+IHtcbiAgICB0LmNvbmZpZy5jbGlja19kcmFnICYmIG4oKTtcbiAgfSksIHQuYXR0YWNoRXZlbnQoXCJvbkdhbnR0TGF5b3V0UmVhZHlcIiwgZnVuY3Rpb24oKSB7XG4gICAgdC4kY29udGFpbmVyICYmIHQuY29uZmlnLmNsaWNrX2RyYWcgJiYgdC5hdHRhY2hFdmVudChcIm9uR2FudHRSZW5kZXJcIiwgZnVuY3Rpb24oKSB7XG4gICAgICBuKCk7XG4gICAgfSwgeyBvbmNlOiAhMCB9KTtcbiAgfSksIHQuYXR0YWNoRXZlbnQoXCJvbkRlc3Ryb3lcIiwgKCkgPT4ge1xuICAgIHQuZXh0LmNsaWNrRHJhZyAmJiB0LmV4dC5jbGlja0RyYWcuZGVzdHJ1Y3RvcigpO1xuICB9KTtcbn0sIGRyYWdfdGltZWxpbmU6IGZ1bmN0aW9uKHQpIHtcbiAgdC5leHQgfHwgKHQuZXh0ID0ge30pLCB0LmV4dC5kcmFnVGltZWxpbmUgPSB7IGNyZWF0ZTogKCkgPT4gWXQuY3JlYXRlKHQpLCBfaXNEcmFnSW5Qcm9ncmVzczogKCkgPT4gWXQuX2lzRHJhZ0luUHJvZ3Jlc3MgfSwgdC5jb25maWcuZHJhZ190aW1lbGluZSA9IHsgZW5hYmxlZDogITAsIHJlbmRlcjogITEgfTtcbn0sIGZ1bGxzY3JlZW46IGZ1bmN0aW9uKHQpIHtcbiAgZnVuY3Rpb24gZSgpIHtcbiAgICBjb25zdCBjID0gZG9jdW1lbnQuZnVsbHNjcmVlbkVsZW1lbnQgfHwgZG9jdW1lbnQubW96RnVsbFNjcmVlbkVsZW1lbnQgfHwgZG9jdW1lbnQud2Via2l0RnVsbHNjcmVlbkVsZW1lbnQgfHwgZG9jdW1lbnQubXNGdWxsc2NyZWVuRWxlbWVudDtcbiAgICByZXR1cm4gISghYyB8fCBjICE9PSBkb2N1bWVudC5ib2R5KTtcbiAgfVxuICBmdW5jdGlvbiBuKCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZG9jdW1lbnQuZnVsbHNjcmVlbkVuYWJsZWQgfHwgZG9jdW1lbnQud2Via2l0RnVsbHNjcmVlbkVuYWJsZWQgfHwgZG9jdW1lbnQubW96RnVsbFNjcmVlbkVuYWJsZWQgfHwgZG9jdW1lbnQubXNGdWxsc2NyZWVuRW5hYmxlZDtcbiAgICB9IGNhdGNoIChjKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRnVsbHNjcmVlbiBpcyBub3QgYXZhaWxhYmxlOlwiLCBjKTtcbiAgICB9XG4gIH1cbiAgdC4kc2VydmljZXMuZ2V0U2VydmljZShcInN0YXRlXCIpLnJlZ2lzdGVyUHJvdmlkZXIoXCJmdWxsc2NyZWVuXCIsICgpID0+IG4oKSA/IHsgZnVsbHNjcmVlbjogZSgpIH0gOiB2b2lkIDApO1xuICBsZXQgaSA9IHsgb3ZlcmZsb3c6IG51bGwsIHBhZGRpbmc6IG51bGwsIHBhZGRpbmdUb3A6IG51bGwsIHBhZGRpbmdSaWdodDogbnVsbCwgcGFkZGluZ0JvdHRvbTogbnVsbCwgcGFkZGluZ0xlZnQ6IG51bGwgfTtcbiAgY29uc3QgYSA9IHsgd2lkdGg6IG51bGwsIGhlaWdodDogbnVsbCwgdG9wOiBudWxsLCBsZWZ0OiBudWxsLCBwb3NpdGlvbjogbnVsbCwgekluZGV4OiBudWxsLCBtb2RpZmllZDogITEgfTtcbiAgbGV0IHIgPSBudWxsO1xuICBmdW5jdGlvbiBzKGMsIHUpIHtcbiAgICB1LndpZHRoID0gYy53aWR0aCwgdS5oZWlnaHQgPSBjLmhlaWdodCwgdS50b3AgPSBjLnRvcCwgdS5sZWZ0ID0gYy5sZWZ0LCB1LnBvc2l0aW9uID0gYy5wb3NpdGlvbiwgdS56SW5kZXggPSBjLnpJbmRleDtcbiAgfVxuICBsZXQgbyA9ICExO1xuICBmdW5jdGlvbiBsKCkge1xuICAgIGlmICghdC4kY29udGFpbmVyKSByZXR1cm47XG4gICAgbGV0IGM7XG4gICAgZSgpID8gbyAmJiAoYyA9IFwib25FeHBhbmRcIiwgZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCB1ID0gdC5leHQuZnVsbHNjcmVlbi5nZXRGdWxsc2NyZWVuRWxlbWVudCgpLCBoID0gZG9jdW1lbnQuYm9keTtcbiAgICAgIHModS5zdHlsZSwgYSksIGkgPSB7IG92ZXJmbG93OiBoLnN0eWxlLm92ZXJmbG93LCBwYWRkaW5nOiBoLnN0eWxlLnBhZGRpbmcgPyBoLnN0eWxlLnBhZGRpbmcgOiBudWxsLCBwYWRkaW5nVG9wOiBoLnN0eWxlLnBhZGRpbmdUb3AgPyBoLnN0eWxlLnBhZGRpbmdUb3AgOiBudWxsLCBwYWRkaW5nUmlnaHQ6IGguc3R5bGUucGFkZGluZ1JpZ2h0ID8gaC5zdHlsZS5wYWRkaW5nUmlnaHQgOiBudWxsLCBwYWRkaW5nQm90dG9tOiBoLnN0eWxlLnBhZGRpbmdCb3R0b20gPyBoLnN0eWxlLnBhZGRpbmdCb3R0b20gOiBudWxsLCBwYWRkaW5nTGVmdDogaC5zdHlsZS5wYWRkaW5nTGVmdCA/IGguc3R5bGUucGFkZGluZ0xlZnQgOiBudWxsIH0sIGguc3R5bGUucGFkZGluZyAmJiAoaC5zdHlsZS5wYWRkaW5nID0gXCIwXCIpLCBoLnN0eWxlLnBhZGRpbmdUb3AgJiYgKGguc3R5bGUucGFkZGluZ1RvcCA9IFwiMFwiKSwgaC5zdHlsZS5wYWRkaW5nUmlnaHQgJiYgKGguc3R5bGUucGFkZGluZ1JpZ2h0ID0gXCIwXCIpLCBoLnN0eWxlLnBhZGRpbmdCb3R0b20gJiYgKGguc3R5bGUucGFkZGluZ0JvdHRvbSA9IFwiMFwiKSwgaC5zdHlsZS5wYWRkaW5nTGVmdCAmJiAoaC5zdHlsZS5wYWRkaW5nTGVmdCA9IFwiMFwiKSwgaC5zdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCIsIHUuc3R5bGUud2lkdGggPSBcIjEwMHZ3XCIsIHUuc3R5bGUuaGVpZ2h0ID0gXCIxMDB2aFwiLCB1LnN0eWxlLnRvcCA9IFwiMHB4XCIsIHUuc3R5bGUubGVmdCA9IFwiMHB4XCIsIHUuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCIsIHUuc3R5bGUuekluZGV4ID0gMSwgYS5tb2RpZmllZCA9ICEwLCByID0gZnVuY3Rpb24oZykge1xuICAgICAgICBsZXQgcCA9IGcucGFyZW50Tm9kZTtcbiAgICAgICAgY29uc3QgeSA9IFtdO1xuICAgICAgICBmb3IgKDsgcCAmJiBwLnN0eWxlOyApIHkucHVzaCh7IGVsZW1lbnQ6IHAsIG9yaWdpbmFsUG9zaXRpb25pbmc6IHAuc3R5bGUucG9zaXRpb24gfSksIHAuc3R5bGUucG9zaXRpb24gPSBcInN0YXRpY1wiLCBwID0gcC5wYXJlbnROb2RlO1xuICAgICAgICByZXR1cm4geTtcbiAgICAgIH0odSk7XG4gICAgfSgpKSA6IG8gJiYgKG8gPSAhMSwgYyA9IFwib25Db2xsYXBzZVwiLCBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IHUgPSB0LmV4dC5mdWxsc2NyZWVuLmdldEZ1bGxzY3JlZW5FbGVtZW50KCksIGggPSBkb2N1bWVudC5ib2R5O1xuICAgICAgYS5tb2RpZmllZCAmJiAoaS5wYWRkaW5nICYmIChoLnN0eWxlLnBhZGRpbmcgPSBpLnBhZGRpbmcpLCBpLnBhZGRpbmdUb3AgJiYgKGguc3R5bGUucGFkZGluZ1RvcCA9IGkucGFkZGluZ1RvcCksIGkucGFkZGluZ1JpZ2h0ICYmIChoLnN0eWxlLnBhZGRpbmdSaWdodCA9IGkucGFkZGluZ1JpZ2h0KSwgaS5wYWRkaW5nQm90dG9tICYmIChoLnN0eWxlLnBhZGRpbmdCb3R0b20gPSBpLnBhZGRpbmdCb3R0b20pLCBpLnBhZGRpbmdMZWZ0ICYmIChoLnN0eWxlLnBhZGRpbmdMZWZ0ID0gaS5wYWRkaW5nTGVmdCksIGguc3R5bGUub3ZlcmZsb3cgPSBpLm92ZXJmbG93LCBpID0geyBvdmVyZmxvdzogbnVsbCwgcGFkZGluZzogbnVsbCwgcGFkZGluZ1RvcDogbnVsbCwgcGFkZGluZ1JpZ2h0OiBudWxsLCBwYWRkaW5nQm90dG9tOiBudWxsLCBwYWRkaW5nTGVmdDogbnVsbCB9LCBzKGEsIHUuc3R5bGUpLCBhLm1vZGlmaWVkID0gITEpLCByLmZvckVhY2goKGcpID0+IHtcbiAgICAgICAgZy5lbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gZy5vcmlnaW5hbFBvc2l0aW9uaW5nO1xuICAgICAgfSksIHIgPSBudWxsO1xuICAgIH0oKSksIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdC5yZW5kZXIoKTtcbiAgICB9KSwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0LmNhbGxFdmVudChjLCBbdC5leHQuZnVsbHNjcmVlbi5nZXRGdWxsc2NyZWVuRWxlbWVudCgpXSk7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gZCgpIHtcbiAgICByZXR1cm4gIXQuJGNvbnRhaW5lciB8fCAhdC5leHQuZnVsbHNjcmVlbi5nZXRGdWxsc2NyZWVuRWxlbWVudCgpID8gITAgOiBuKCkgPyAhMSA6ICgoY29uc29sZS53YXJuaW5nIHx8IGNvbnNvbGUubG9nKShcIlRoZSBgZnVsbHNjcmVlbmAgZmVhdHVyZSBub3QgYmVpbmcgYWxsb3dlZCwgb3IgZnVsbC1zY3JlZW4gbW9kZSBub3QgYmVpbmcgc3VwcG9ydGVkXCIpLCAhMCk7XG4gIH1cbiAgdC5leHQuZnVsbHNjcmVlbiA9IHsgZXhwYW5kKCkge1xuICAgIGlmIChkKCkgfHwgZSgpIHx8ICF0LmNhbGxFdmVudChcIm9uQmVmb3JlRXhwYW5kXCIsIFt0aGlzLmdldEZ1bGxzY3JlZW5FbGVtZW50KCldKSkgcmV0dXJuO1xuICAgIG8gPSAhMDtcbiAgICBjb25zdCBjID0gZG9jdW1lbnQuYm9keSwgdSA9IGMud2Via2l0UmVxdWVzdEZ1bGxzY3JlZW4gPyBbRWxlbWVudC5BTExPV19LRVlCT0FSRF9JTlBVVF0gOiBbXSwgaCA9IGMubXNSZXF1ZXN0RnVsbHNjcmVlbiB8fCBjLm1velJlcXVlc3RGdWxsU2NyZWVuIHx8IGMud2Via2l0UmVxdWVzdEZ1bGxzY3JlZW4gfHwgYy5yZXF1ZXN0RnVsbHNjcmVlbjtcbiAgICBoICYmIGguYXBwbHkoYywgdSk7XG4gIH0sIGNvbGxhcHNlKCkge1xuICAgIGlmIChkKCkgfHwgIWUoKSB8fCAhdC5jYWxsRXZlbnQoXCJvbkJlZm9yZUNvbGxhcHNlXCIsIFt0aGlzLmdldEZ1bGxzY3JlZW5FbGVtZW50KCldKSkgcmV0dXJuO1xuICAgIGNvbnN0IGMgPSBkb2N1bWVudC5tc0V4aXRGdWxsc2NyZWVuIHx8IGRvY3VtZW50Lm1vekNhbmNlbEZ1bGxTY3JlZW4gfHwgZG9jdW1lbnQud2Via2l0RXhpdEZ1bGxzY3JlZW4gfHwgZG9jdW1lbnQuZXhpdEZ1bGxzY3JlZW47XG4gICAgYyAmJiBjLmFwcGx5KGRvY3VtZW50KTtcbiAgfSwgdG9nZ2xlKCkge1xuICAgIGQoKSB8fCAoZSgpID8gdGhpcy5jb2xsYXBzZSgpIDogdGhpcy5leHBhbmQoKSk7XG4gIH0sIGdldEZ1bGxzY3JlZW5FbGVtZW50OiAoKSA9PiB0LiRyb290IH0sIHQuZXhwYW5kID0gZnVuY3Rpb24oKSB7XG4gICAgdC5leHQuZnVsbHNjcmVlbi5leHBhbmQoKTtcbiAgfSwgdC5jb2xsYXBzZSA9IGZ1bmN0aW9uKCkge1xuICAgIHQuZXh0LmZ1bGxzY3JlZW4uY29sbGFwc2UoKTtcbiAgfSwgdC5hdHRhY2hFdmVudChcIm9uR2FudHRSZWFkeVwiLCBmdW5jdGlvbigpIHtcbiAgICB0LmV2ZW50KGRvY3VtZW50LCBcIndlYmtpdGZ1bGxzY3JlZW5jaGFuZ2VcIiwgbCksIHQuZXZlbnQoZG9jdW1lbnQsIFwibW96ZnVsbHNjcmVlbmNoYW5nZVwiLCBsKSwgdC5ldmVudChkb2N1bWVudCwgXCJNU0Z1bGxzY3JlZW5DaGFuZ2VcIiwgbCksIHQuZXZlbnQoZG9jdW1lbnQsIFwiZnVsbHNjcmVlbkNoYW5nZVwiLCBsKSwgdC5ldmVudChkb2N1bWVudCwgXCJmdWxsc2NyZWVuY2hhbmdlXCIsIGwpO1xuICB9KTtcbn0sIGtleWJvYXJkX25hdmlnYXRpb246IGZ1bmN0aW9uKHQpIHtcbiAgKGZ1bmN0aW9uKGUpIHtcbiAgICBlLmNvbmZpZy5rZXlib2FyZF9uYXZpZ2F0aW9uID0gITAsIGUuY29uZmlnLmtleWJvYXJkX25hdmlnYXRpb25fY2VsbHMgPSAhMSwgZS4ka2V5Ym9hcmROYXZpZ2F0aW9uID0ge30sIGUuX2NvbXBvc2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIGZvciAodmFyIG4gPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApLCBpID0ge30sIGEgPSAwOyBhIDwgbi5sZW5ndGg7IGErKykge1xuICAgICAgICB2YXIgciA9IG5bYV07XG4gICAgICAgIGZvciAodmFyIHMgaW4gdHlwZW9mIHIgPT0gXCJmdW5jdGlvblwiICYmIChyID0gbmV3IHIoKSksIHIpIGlbc10gPSByW3NdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGk7XG4gICAgfSwgZnVuY3Rpb24obikge1xuICAgICAgbi4ka2V5Ym9hcmROYXZpZ2F0aW9uLnNob3J0Y3V0cyA9IHsgY3JlYXRlQ29tbWFuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7IG1vZGlmaWVyczogeyBzaGlmdDogITEsIGFsdDogITEsIGN0cmw6ICExLCBtZXRhOiAhMSB9LCBrZXlDb2RlOiBudWxsIH07XG4gICAgICB9LCBwYXJzZTogZnVuY3Rpb24oaSkge1xuICAgICAgICBmb3IgKHZhciBhID0gW10sIHIgPSB0aGlzLmdldEV4cHJlc3Npb25zKHRoaXMudHJpbShpKSksIHMgPSAwOyBzIDwgci5sZW5ndGg7IHMrKykge1xuICAgICAgICAgIGZvciAodmFyIG8gPSB0aGlzLmdldFdvcmRzKHJbc10pLCBsID0gdGhpcy5jcmVhdGVDb21tYW5kKCksIGQgPSAwOyBkIDwgby5sZW5ndGg7IGQrKykgdGhpcy5jb21tYW5kS2V5c1tvW2RdXSA/IGwubW9kaWZpZXJzW29bZF1dID0gITAgOiB0aGlzLnNwZWNpYWxLZXlzW29bZF1dID8gbC5rZXlDb2RlID0gdGhpcy5zcGVjaWFsS2V5c1tvW2RdXSA6IGwua2V5Q29kZSA9IG9bZF0uY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICBhLnB1c2gobCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGE7XG4gICAgICB9LCBnZXRDb21tYW5kRnJvbUV2ZW50OiBmdW5jdGlvbihpKSB7XG4gICAgICAgIHZhciBhID0gdGhpcy5jcmVhdGVDb21tYW5kKCk7XG4gICAgICAgIGEubW9kaWZpZXJzLnNoaWZ0ID0gISFpLnNoaWZ0S2V5LCBhLm1vZGlmaWVycy5hbHQgPSAhIWkuYWx0S2V5LCBhLm1vZGlmaWVycy5jdHJsID0gISFpLmN0cmxLZXksIGEubW9kaWZpZXJzLm1ldGEgPSAhIWkubWV0YUtleSwgYS5rZXlDb2RlID0gaS53aGljaCB8fCBpLmtleUNvZGUsIGEua2V5Q29kZSA+PSA5NiAmJiBhLmtleUNvZGUgPD0gMTA1ICYmIChhLmtleUNvZGUgLT0gNDgpO1xuICAgICAgICB2YXIgciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoYS5rZXlDb2RlKTtcbiAgICAgICAgcmV0dXJuIHIgJiYgKGEua2V5Q29kZSA9IHIudG9Mb3dlckNhc2UoKS5jaGFyQ29kZUF0KDApKSwgYTtcbiAgICAgIH0sIGdldEhhc2hGcm9tRXZlbnQ6IGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SGFzaCh0aGlzLmdldENvbW1hbmRGcm9tRXZlbnQoaSkpO1xuICAgICAgfSwgZ2V0SGFzaDogZnVuY3Rpb24oaSkge1xuICAgICAgICB2YXIgYSA9IFtdO1xuICAgICAgICBmb3IgKHZhciByIGluIGkubW9kaWZpZXJzKSBpLm1vZGlmaWVyc1tyXSAmJiBhLnB1c2gocik7XG4gICAgICAgIHJldHVybiBhLnB1c2goaS5rZXlDb2RlKSwgYS5qb2luKHRoaXMuanVuY3Rpb25DaGFyKTtcbiAgICAgIH0sIGdldEV4cHJlc3Npb25zOiBmdW5jdGlvbihpKSB7XG4gICAgICAgIHJldHVybiBpLnNwbGl0KHRoaXMuanVuY3Rpb25DaGFyKTtcbiAgICAgIH0sIGdldFdvcmRzOiBmdW5jdGlvbihpKSB7XG4gICAgICAgIHJldHVybiBpLnNwbGl0KHRoaXMuY29tYmluYXRpb25DaGFyKTtcbiAgICAgIH0sIHRyaW06IGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgcmV0dXJuIGkucmVwbGFjZSgvXFxzL2csIFwiXCIpO1xuICAgICAgfSwganVuY3Rpb25DaGFyOiBcIixcIiwgY29tYmluYXRpb25DaGFyOiBcIitcIiwgY29tbWFuZEtleXM6IHsgc2hpZnQ6IDE2LCBhbHQ6IDE4LCBjdHJsOiAxNywgbWV0YTogITAgfSwgc3BlY2lhbEtleXM6IHsgYmFja3NwYWNlOiA4LCB0YWI6IDksIGVudGVyOiAxMywgZXNjOiAyNywgc3BhY2U6IDMyLCB1cDogMzgsIGRvd246IDQwLCBsZWZ0OiAzNywgcmlnaHQ6IDM5LCBob21lOiAzNiwgZW5kOiAzNSwgcGFnZXVwOiAzMywgcGFnZWRvd246IDM0LCBkZWxldGU6IDQ2LCBpbnNlcnQ6IDQ1LCBwbHVzOiAxMDcsIGYxOiAxMTIsIGYyOiAxMTMsIGYzOiAxMTQsIGY0OiAxMTUsIGY1OiAxMTYsIGY2OiAxMTcsIGY3OiAxMTgsIGY4OiAxMTksIGY5OiAxMjAsIGYxMDogMTIxLCBmMTE6IDEyMiwgZjEyOiAxMjMgfSB9O1xuICAgIH0oZSksIGZ1bmN0aW9uKG4pIHtcbiAgICAgIG4uJGtleWJvYXJkTmF2aWdhdGlvbi5FdmVudEhhbmRsZXIgPSB7IF9oYW5kbGVyczogbnVsbCwgZmluZEhhbmRsZXI6IGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgdGhpcy5faGFuZGxlcnMgfHwgKHRoaXMuX2hhbmRsZXJzID0ge30pO1xuICAgICAgICB2YXIgYSA9IG4uJGtleWJvYXJkTmF2aWdhdGlvbi5zaG9ydGN1dHMuZ2V0SGFzaChpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZXJzW2FdO1xuICAgICAgfSwgZG9BY3Rpb246IGZ1bmN0aW9uKGksIGEpIHtcbiAgICAgICAgdmFyIHIgPSB0aGlzLmZpbmRIYW5kbGVyKGkpO1xuICAgICAgICBpZiAocikge1xuICAgICAgICAgIGlmIChuLiRrZXlib2FyZE5hdmlnYXRpb24uZmFjYWRlLmNhbGxFdmVudChcIm9uQmVmb3JlQWN0aW9uXCIsIFtpLCBhXSkgPT09ICExKSByZXR1cm47XG4gICAgICAgICAgci5jYWxsKHRoaXMsIGEpLCBhLnByZXZlbnREZWZhdWx0ID8gYS5wcmV2ZW50RGVmYXVsdCgpIDogYS5yZXR1cm5WYWx1ZSA9ICExO1xuICAgICAgICB9XG4gICAgICB9LCBiaW5kOiBmdW5jdGlvbihpLCBhKSB7XG4gICAgICAgIHRoaXMuX2hhbmRsZXJzIHx8ICh0aGlzLl9oYW5kbGVycyA9IHt9KTtcbiAgICAgICAgZm9yICh2YXIgciA9IG4uJGtleWJvYXJkTmF2aWdhdGlvbi5zaG9ydGN1dHMsIHMgPSByLnBhcnNlKGkpLCBvID0gMDsgbyA8IHMubGVuZ3RoOyBvKyspIHRoaXMuX2hhbmRsZXJzW3IuZ2V0SGFzaChzW29dKV0gPSBhO1xuICAgICAgfSwgdW5iaW5kOiBmdW5jdGlvbihpKSB7XG4gICAgICAgIGZvciAodmFyIGEgPSBuLiRrZXlib2FyZE5hdmlnYXRpb24uc2hvcnRjdXRzLCByID0gYS5wYXJzZShpKSwgcyA9IDA7IHMgPCByLmxlbmd0aDsgcysrKSB0aGlzLl9oYW5kbGVyc1thLmdldEhhc2gocltzXSldICYmIGRlbGV0ZSB0aGlzLl9oYW5kbGVyc1thLmdldEhhc2gocltzXSldO1xuICAgICAgfSwgYmluZEFsbDogZnVuY3Rpb24oaSkge1xuICAgICAgICBmb3IgKHZhciBhIGluIGkpIHRoaXMuYmluZChhLCBpW2FdKTtcbiAgICAgIH0sIGluaXRLZXlzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5faGFuZGxlcnMgfHwgKHRoaXMuX2hhbmRsZXJzID0ge30pLCB0aGlzLmtleXMgJiYgdGhpcy5iaW5kQWxsKHRoaXMua2V5cyk7XG4gICAgICB9IH07XG4gICAgfShlKSwgZnVuY3Rpb24obikge1xuICAgICAgbi4ka2V5Ym9hcmROYXZpZ2F0aW9uLmdldEZvY3VzYWJsZU5vZGVzID0gTHQsIG4uJGtleWJvYXJkTmF2aWdhdGlvbi50cmFwRm9jdXMgPSBmdW5jdGlvbihpLCBhKSB7XG4gICAgICAgIGlmIChhLmtleUNvZGUgIT0gOSkgcmV0dXJuICExO1xuICAgICAgICBmb3IgKHZhciByID0gbi4ka2V5Ym9hcmROYXZpZ2F0aW9uLmdldEZvY3VzYWJsZU5vZGVzKGkpLCBzID0gZ2UoKSwgbyA9IC0xLCBsID0gMDsgbCA8IHIubGVuZ3RoOyBsKyspIGlmIChyW2xdID09IHMpIHtcbiAgICAgICAgICBvID0gbDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoYS5zaGlmdEtleSkge1xuICAgICAgICAgIGlmIChvIDw9IDApIHtcbiAgICAgICAgICAgIHZhciBkID0gcltyLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgaWYgKGQpIHJldHVybiBkLmZvY3VzKCksIGEucHJldmVudERlZmF1bHQoKSwgITA7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG8gPj0gci5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgdmFyIGMgPSByWzBdO1xuICAgICAgICAgIGlmIChjKSByZXR1cm4gYy5mb2N1cygpLCBhLnByZXZlbnREZWZhdWx0KCksICEwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIH07XG4gICAgfShlKSwgZnVuY3Rpb24obikge1xuICAgICAgbi4ka2V5Ym9hcmROYXZpZ2F0aW9uLkdhbnR0Tm9kZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgfSwgbi4ka2V5Ym9hcmROYXZpZ2F0aW9uLkdhbnR0Tm9kZS5wcm90b3R5cGUgPSBuLl9jb21wb3NlKG4uJGtleWJvYXJkTmF2aWdhdGlvbi5FdmVudEhhbmRsZXIsIHsgZm9jdXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICBuLmZvY3VzKCk7XG4gICAgICB9LCBibHVyOiBmdW5jdGlvbigpIHtcbiAgICAgIH0sIGlzRW5hYmxlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuLiRjb250YWluZXIuaGFzQXR0cmlidXRlKFwidGFiaW5kZXhcIik7XG4gICAgICB9LCBzY3JvbGxIb3Jpem9udGFsOiBmdW5jdGlvbihpKSB7XG4gICAgICAgIHZhciBhID0gbi5kYXRlRnJvbVBvcyhuLmdldFNjcm9sbFN0YXRlKCkueCksIHIgPSBuLmdldFNjYWxlKCksIHMgPSBpIDwgMCA/IC1yLnN0ZXAgOiByLnN0ZXA7XG4gICAgICAgIGEgPSBuLmRhdGUuYWRkKGEsIHMsIHIudW5pdCksIG4uc2Nyb2xsVG8obi5wb3NGcm9tRGF0ZShhKSk7XG4gICAgICB9LCBzY3JvbGxWZXJ0aWNhbDogZnVuY3Rpb24oaSkge1xuICAgICAgICB2YXIgYSA9IG4uZ2V0U2Nyb2xsU3RhdGUoKS55LCByID0gbi5jb25maWcucm93X2hlaWdodDtcbiAgICAgICAgbi5zY3JvbGxUbyhudWxsLCBhICsgKGkgPCAwID8gLTEgOiAxKSAqIHIpO1xuICAgICAgfSwga2V5czogeyBcImFsdCtsZWZ0XCI6IGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxIb3Jpem9udGFsKC0xKTtcbiAgICAgIH0sIFwiYWx0K3JpZ2h0XCI6IGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxIb3Jpem9udGFsKDEpO1xuICAgICAgfSwgXCJhbHQrdXBcIjogZnVuY3Rpb24oaSkge1xuICAgICAgICB0aGlzLnNjcm9sbFZlcnRpY2FsKC0xKTtcbiAgICAgIH0sIFwiYWx0K2Rvd25cIjogZnVuY3Rpb24oaSkge1xuICAgICAgICB0aGlzLnNjcm9sbFZlcnRpY2FsKDEpO1xuICAgICAgfSwgXCJjdHJsK3pcIjogZnVuY3Rpb24oKSB7XG4gICAgICAgIG4udW5kbyAmJiBuLnVuZG8oKTtcbiAgICAgIH0sIFwiY3RybCtyXCI6IGZ1bmN0aW9uKCkge1xuICAgICAgICBuLnJlZG8gJiYgbi5yZWRvKCk7XG4gICAgICB9IH0gfSksIG4uJGtleWJvYXJkTmF2aWdhdGlvbi5HYW50dE5vZGUucHJvdG90eXBlLmJpbmRBbGwobi4ka2V5Ym9hcmROYXZpZ2F0aW9uLkdhbnR0Tm9kZS5wcm90b3R5cGUua2V5cyk7XG4gICAgfShlKSwgZnVuY3Rpb24obikge1xuICAgICAgbi4ka2V5Ym9hcmROYXZpZ2F0aW9uLktleU5hdk5vZGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIH0sIG4uJGtleWJvYXJkTmF2aWdhdGlvbi5LZXlOYXZOb2RlLnByb3RvdHlwZSA9IG4uX2NvbXBvc2Uobi4ka2V5Ym9hcmROYXZpZ2F0aW9uLkV2ZW50SGFuZGxlciwgeyBpc1ZhbGlkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICEwO1xuICAgICAgfSwgZmFsbGJhY2s6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0sIG1vdmVUbzogZnVuY3Rpb24oaSkge1xuICAgICAgICBuLiRrZXlib2FyZE5hdmlnYXRpb24uZGlzcGF0Y2hlci5zZXRBY3RpdmVOb2RlKGkpO1xuICAgICAgfSwgY29tcGFyZVRvOiBmdW5jdGlvbihpKSB7XG4gICAgICAgIGlmICghaSkgcmV0dXJuICExO1xuICAgICAgICBmb3IgKHZhciBhIGluIHRoaXMpIHtcbiAgICAgICAgICBpZiAoISF0aGlzW2FdICE9ICEhaVthXSkgcmV0dXJuICExO1xuICAgICAgICAgIHZhciByID0gISghdGhpc1thXSB8fCAhdGhpc1thXS50b1N0cmluZyksIHMgPSAhKCFpW2FdIHx8ICFpW2FdLnRvU3RyaW5nKTtcbiAgICAgICAgICBpZiAocyAhPSByKSByZXR1cm4gITE7XG4gICAgICAgICAgaWYgKHMgJiYgcikge1xuICAgICAgICAgICAgaWYgKGlbYV0udG9TdHJpbmcoKSAhPSB0aGlzW2FdLnRvU3RyaW5nKCkpIHJldHVybiAhMTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlbYV0gIT0gdGhpc1thXSkgcmV0dXJuICExO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhMDtcbiAgICAgIH0sIGdldE5vZGU6IGZ1bmN0aW9uKCkge1xuICAgICAgfSwgZm9jdXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaSA9IHRoaXMuZ2V0Tm9kZSgpO1xuICAgICAgICBpZiAoaSkge1xuICAgICAgICAgIHZhciBhID0gbi4ka2V5Ym9hcmROYXZpZ2F0aW9uLmZhY2FkZTtcbiAgICAgICAgICBhLmNhbGxFdmVudChcIm9uQmVmb3JlRm9jdXNcIiwgW2ldKSAhPT0gITEgJiYgaSAmJiAoaS5zZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiLCBcIi0xXCIpLCBpLiRldmVudEF0dGFjaGVkIHx8IChpLiRldmVudEF0dGFjaGVkID0gITAsIG4uZXZlbnQoaSwgXCJmb2N1c1wiLCBmdW5jdGlvbihyKSB7XG4gICAgICAgICAgICByZXR1cm4gci5wcmV2ZW50RGVmYXVsdCgpLCAhMTtcbiAgICAgICAgICB9LCAhMSkpLCBuLnV0aWxzLmRvbS5pc0NoaWxkT2YoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCwgaSkgJiYgKGkgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50KSwgaS5mb2N1cyAmJiBpLmZvY3VzKCksIGEuY2FsbEV2ZW50KFwib25Gb2N1c1wiLCBbdGhpcy5nZXROb2RlKCldKSk7XG4gICAgICAgIH1cbiAgICAgIH0sIGJsdXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaSA9IHRoaXMuZ2V0Tm9kZSgpO1xuICAgICAgICBpICYmIChuLiRrZXlib2FyZE5hdmlnYXRpb24uZmFjYWRlLmNhbGxFdmVudChcIm9uQmx1clwiLCBbaV0pLCBpLnNldEF0dHJpYnV0ZShcInRhYmluZGV4XCIsIFwiLTFcIikpO1xuICAgICAgfSB9KTtcbiAgICB9KGUpLCBmdW5jdGlvbihuKSB7XG4gICAgICBuLiRrZXlib2FyZE5hdmlnYXRpb24uSGVhZGVyQ2VsbCA9IGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgdGhpcy5pbmRleCA9IGkgfHwgMDtcbiAgICAgIH0sIG4uJGtleWJvYXJkTmF2aWdhdGlvbi5IZWFkZXJDZWxsLnByb3RvdHlwZSA9IG4uX2NvbXBvc2Uobi4ka2V5Ym9hcmROYXZpZ2F0aW9uLktleU5hdk5vZGUsIHsgX2hhbmRsZXJzOiBudWxsLCBpc1ZhbGlkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICEoIW4uY29uZmlnLnNob3dfZ3JpZCAmJiBuLmdldFZpc2libGVUYXNrQ291bnQoKSB8fCAhbi5nZXRHcmlkQ29sdW1ucygpW3RoaXMuaW5kZXhdICYmIG4uZ2V0VmlzaWJsZVRhc2tDb3VudCgpKTtcbiAgICAgIH0sIGZhbGxiYWNrOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCFuLmNvbmZpZy5zaG93X2dyaWQpIHJldHVybiBuLmdldFZpc2libGVUYXNrQ291bnQoKSA/IG5ldyBuLiRrZXlib2FyZE5hdmlnYXRpb24uVGFza1JvdygpIDogbnVsbDtcbiAgICAgICAgZm9yICh2YXIgaSA9IG4uZ2V0R3JpZENvbHVtbnMoKSwgYSA9IHRoaXMuaW5kZXg7IGEgPj0gMCAmJiAhaVthXTsgKSBhLS07XG4gICAgICAgIHJldHVybiBpW2FdID8gbmV3IG4uJGtleWJvYXJkTmF2aWdhdGlvbi5IZWFkZXJDZWxsKGEpIDogbnVsbDtcbiAgICAgIH0sIGZyb21Eb21FbGVtZW50OiBmdW5jdGlvbihpKSB7XG4gICAgICAgIHZhciBhID0gcHQoaSwgXCJnYW50dF9ncmlkX2hlYWRfY2VsbFwiKTtcbiAgICAgICAgaWYgKGEpIHtcbiAgICAgICAgICBmb3IgKHZhciByID0gMDsgYSAmJiBhLnByZXZpb3VzU2libGluZzsgKSBhID0gYS5wcmV2aW91c1NpYmxpbmcsIHIgKz0gMTtcbiAgICAgICAgICByZXR1cm4gbmV3IG4uJGtleWJvYXJkTmF2aWdhdGlvbi5IZWFkZXJDZWxsKHIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSwgZ2V0Tm9kZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IGkgPSBuLiRncmlkX3NjYWxlO1xuICAgICAgICByZXR1cm4gaSA/IGkuY2hpbGROb2Rlc1t0aGlzLmluZGV4XSA6IG51bGw7XG4gICAgICB9LCBrZXlzOiB7IGxlZnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmluZGV4ID4gMCAmJiB0aGlzLm1vdmVUbyhuZXcgbi4ka2V5Ym9hcmROYXZpZ2F0aW9uLkhlYWRlckNlbGwodGhpcy5pbmRleCAtIDEpKTtcbiAgICAgIH0sIHJpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGkgPSBuLmdldEdyaWRDb2x1bW5zKCk7XG4gICAgICAgIHRoaXMuaW5kZXggPCBpLmxlbmd0aCAtIDEgJiYgdGhpcy5tb3ZlVG8obmV3IG4uJGtleWJvYXJkTmF2aWdhdGlvbi5IZWFkZXJDZWxsKHRoaXMuaW5kZXggKyAxKSk7XG4gICAgICB9LCBkb3duOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGksIGEgPSBuLmdldENoaWxkcmVuKG4uY29uZmlnLnJvb3RfaWQpO1xuICAgICAgICBuLmlzVGFza0V4aXN0cyhhWzBdKSAmJiAoaSA9IGFbMF0pLCBpICYmIChuLmNvbmZpZy5rZXlib2FyZF9uYXZpZ2F0aW9uX2NlbGxzID8gdGhpcy5tb3ZlVG8obmV3IG4uJGtleWJvYXJkTmF2aWdhdGlvbi5UYXNrQ2VsbChpLCB0aGlzLmluZGV4KSkgOiB0aGlzLm1vdmVUbyhuZXcgbi4ka2V5Ym9hcmROYXZpZ2F0aW9uLlRhc2tSb3coaSkpKTtcbiAgICAgIH0sIGVuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpID0gbi5nZXRHcmlkQ29sdW1ucygpO1xuICAgICAgICB0aGlzLm1vdmVUbyhuZXcgbi4ka2V5Ym9hcmROYXZpZ2F0aW9uLkhlYWRlckNlbGwoaS5sZW5ndGggLSAxKSk7XG4gICAgICB9LCBob21lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5tb3ZlVG8obmV3IG4uJGtleWJvYXJkTmF2aWdhdGlvbi5IZWFkZXJDZWxsKDApKTtcbiAgICAgIH0sIFwiZW50ZXIsIHNwYWNlXCI6IGZ1bmN0aW9uKCkge1xuICAgICAgICBnZSgpLmNsaWNrKCk7XG4gICAgICB9LCBcImN0cmwrZW50ZXJcIjogZnVuY3Rpb24oKSB7XG4gICAgICAgIG4uaXNSZWFkb25seSh0aGlzKSB8fCBuLmNyZWF0ZVRhc2soe30sIHRoaXMudGFza0lkKTtcbiAgICAgIH0gfSB9KSwgbi4ka2V5Ym9hcmROYXZpZ2F0aW9uLkhlYWRlckNlbGwucHJvdG90eXBlLmJpbmRBbGwobi4ka2V5Ym9hcmROYXZpZ2F0aW9uLkhlYWRlckNlbGwucHJvdG90eXBlLmtleXMpO1xuICAgIH0oZSksIGZ1bmN0aW9uKG4pIHtcbiAgICAgIG4uJGtleWJvYXJkTmF2aWdhdGlvbi5UYXNrUm93ID0gZnVuY3Rpb24oaSkge1xuICAgICAgICBpZiAoIWkpIHtcbiAgICAgICAgICB2YXIgYSA9IG4uZ2V0Q2hpbGRyZW4obi5jb25maWcucm9vdF9pZCk7XG4gICAgICAgICAgYVswXSAmJiAoaSA9IGFbMF0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGFza0lkID0gaSwgbi5pc1Rhc2tFeGlzdHModGhpcy50YXNrSWQpICYmICh0aGlzLmluZGV4ID0gbi5nZXRUYXNrSW5kZXgodGhpcy50YXNrSWQpLCB0aGlzLmdsb2JhbEluZGV4ID0gbi5nZXRHbG9iYWxUYXNrSW5kZXgodGhpcy50YXNrSWQpLCB0aGlzLnNwbGl0SXRlbSA9ICEhbi5nZXRUYXNrKHRoaXMudGFza0lkKS4kc3BsaXRfc3VidGFzaywgdGhpcy5wYXJlbnRJZCA9IG4uZ2V0UGFyZW50KHRoaXMudGFza0lkKSk7XG4gICAgICB9LCBuLiRrZXlib2FyZE5hdmlnYXRpb24uVGFza1Jvdy5wcm90b3R5cGUgPSBuLl9jb21wb3NlKG4uJGtleWJvYXJkTmF2aWdhdGlvbi5LZXlOYXZOb2RlLCB7IF9oYW5kbGVyczogbnVsbCwgaXNWYWxpZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuLmlzVGFza0V4aXN0cyh0aGlzLnRhc2tJZCkgJiYgbi5nZXRUYXNrSW5kZXgodGhpcy50YXNrSWQpID4gLTE7XG4gICAgICB9LCBmYWxsYmFjazogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghbi5nZXRWaXNpYmxlVGFza0NvdW50KCkpIHtcbiAgICAgICAgICB2YXIgaSA9IG5ldyBuLiRrZXlib2FyZE5hdmlnYXRpb24uSGVhZGVyQ2VsbCgpO1xuICAgICAgICAgIHJldHVybiBpLmlzVmFsaWQoKSA/IGkgOiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNwbGl0SXRlbSkgcmV0dXJuIG5ldyBuLiRrZXlib2FyZE5hdmlnYXRpb24uVGFza1Jvdyh0aGlzLnBhcmVudElkKTtcbiAgICAgICAgdmFyIGEgPSAtMTtcbiAgICAgICAgaWYgKG4uZ2V0VGFza0J5SW5kZXgodGhpcy5nbG9iYWxJbmRleCAtIDEpKSBhID0gdGhpcy5nbG9iYWxJbmRleCAtIDE7XG4gICAgICAgIGVsc2UgaWYgKG4uZ2V0VGFza0J5SW5kZXgodGhpcy5nbG9iYWxJbmRleCArIDEpKSBhID0gdGhpcy5nbG9iYWxJbmRleCArIDE7XG4gICAgICAgIGVsc2UgZm9yICh2YXIgciA9IHRoaXMuZ2xvYmFsSW5kZXg7IHIgPj0gMDsgKSB7XG4gICAgICAgICAgaWYgKG4uZ2V0VGFza0J5SW5kZXgocikpIHtcbiAgICAgICAgICAgIGEgPSByO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHItLTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYSA+IC0xID8gbmV3IG4uJGtleWJvYXJkTmF2aWdhdGlvbi5UYXNrUm93KG4uZ2V0VGFza0J5SW5kZXgoYSkuaWQpIDogdm9pZCAwO1xuICAgICAgfSwgZnJvbURvbUVsZW1lbnQ6IGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgaWYgKG4uY29uZmlnLmtleWJvYXJkX25hdmlnYXRpb25fY2VsbHMpIHJldHVybiBudWxsO1xuICAgICAgICB2YXIgYSA9IG4ubG9jYXRlKGkpO1xuICAgICAgICByZXR1cm4gbi5pc1Rhc2tFeGlzdHMoYSkgPyBuZXcgbi4ka2V5Ym9hcmROYXZpZ2F0aW9uLlRhc2tSb3coYSkgOiBudWxsO1xuICAgICAgfSwgZ2V0Tm9kZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChuLmlzVGFza0V4aXN0cyh0aGlzLnRhc2tJZCkgJiYgbi5pc1Rhc2tWaXNpYmxlKHRoaXMudGFza0lkKSkgcmV0dXJuIG4uY29uZmlnLnNob3dfZ3JpZCA/IG4uJGdyaWQucXVlcnlTZWxlY3RvcihgLmdhbnR0X3Jvd1ske24uY29uZmlnLnRhc2tfYXR0cmlidXRlfT1cIiR7U3RyaW5nKHRoaXMudGFza0lkKS5yZXBsYWNlQWxsKCdcIicsICdcXFxcXCInKX1cIl1gKSA6IG4uZ2V0VGFza05vZGUodGhpcy50YXNrSWQpO1xuICAgICAgfSwgZm9jdXM6IGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgaWYgKCFpKSB7XG4gICAgICAgICAgY29uc3QgYSA9IG4uZ2V0VGFza1Bvc2l0aW9uKG4uZ2V0VGFzayh0aGlzLnRhc2tJZCkpLCByID0gbi5nZXRUYXNrSGVpZ2h0KHRoaXMudGFza0lkKSwgcyA9IG4uZ2V0U2Nyb2xsU3RhdGUoKTtcbiAgICAgICAgICBsZXQgbywgbDtcbiAgICAgICAgICBvID0gbi4kdGFzayA/IG4uJHRhc2sub2Zmc2V0V2lkdGggOiBzLmlubmVyX3dpZHRoLCBsID0gbi4kZ3JpZF9kYXRhIHx8IG4uJHRhc2tfZGF0YSA/IChuLiRncmlkX2RhdGEgfHwgbi4kdGFza19kYXRhKS5vZmZzZXRIZWlnaHQgOiBzLmlubmVyX2hlaWdodDtcbiAgICAgICAgICBjb25zdCBkID0gbi5jb25maWcuc2hvd19jaGFydCAmJiBuLiR1aS5nZXRWaWV3KFwidGltZWxpbmVcIik7XG4gICAgICAgICAgYS50b3AgPCBzLnkgfHwgYS50b3AgKyByID4gcy55ICsgbCA/IG4uc2Nyb2xsVG8obnVsbCwgYS50b3AgLSAyMCkgOiBuLmNvbmZpZy5zY3JvbGxfb25fY2xpY2sgJiYgZCAmJiAoYS5sZWZ0ID4gcy54ICsgbyA/IG4uc2Nyb2xsVG8oYS5sZWZ0IC0gbi5jb25maWcudGFza19zY3JvbGxfb2Zmc2V0KSA6IGEubGVmdCArIGEud2lkdGggPCBzLnggJiYgbi5zY3JvbGxUbyhhLmxlZnQgKyBhLndpZHRoIC0gbi5jb25maWcudGFza19zY3JvbGxfb2Zmc2V0KSk7XG4gICAgICAgIH1cbiAgICAgICAgbi4ka2V5Ym9hcmROYXZpZ2F0aW9uLktleU5hdk5vZGUucHJvdG90eXBlLmZvY3VzLmFwcGx5KHRoaXMsIFtpXSksIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBhID0gbi4kdWkuZ2V0VmlldyhcImdyaWRcIik7XG4gICAgICAgICAgaWYgKGEgJiYgYS4kZ3JpZF9kYXRhKSB7XG4gICAgICAgICAgICB2YXIgciA9IHBhcnNlSW50KGEuJGdyaWQuc2Nyb2xsTGVmdCksIHMgPSBwYXJzZUludChhLiRncmlkX2RhdGEuc2Nyb2xsVG9wKSwgbyA9IGEuJGNvbmZpZy5zY3JvbGxYO1xuICAgICAgICAgICAgaWYgKG8gJiYgYS4kY29uZmlnLnNjcm9sbGFibGUpIHtcbiAgICAgICAgICAgICAgdmFyIGwgPSBuLiR1aS5nZXRWaWV3KG8pO1xuICAgICAgICAgICAgICBsICYmIGwuc2Nyb2xsVG8ociwgcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZCA9IGEuJGNvbmZpZy5zY3JvbGxZO1xuICAgICAgICAgICAgaWYgKGQpIHtcbiAgICAgICAgICAgICAgdmFyIGMgPSBuLiR1aS5nZXRWaWV3KGQpO1xuICAgICAgICAgICAgICBjICYmIGMuc2Nyb2xsVG8ociwgcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KCk7XG4gICAgICB9LCBrZXlzOiB7IHBhZ2Vkb3duOiBmdW5jdGlvbigpIHtcbiAgICAgICAgbi5nZXRWaXNpYmxlVGFza0NvdW50KCkgJiYgdGhpcy5tb3ZlVG8obmV3IG4uJGtleWJvYXJkTmF2aWdhdGlvbi5UYXNrUm93KG4uZ2V0VGFza0J5SW5kZXgobi5nZXRWaXNpYmxlVGFza0NvdW50KCkgLSAxKS5pZCkpO1xuICAgICAgfSwgcGFnZXVwOiBmdW5jdGlvbigpIHtcbiAgICAgICAgbi5nZXRWaXNpYmxlVGFza0NvdW50KCkgJiYgdGhpcy5tb3ZlVG8obmV3IG4uJGtleWJvYXJkTmF2aWdhdGlvbi5UYXNrUm93KG4uZ2V0VGFza0J5SW5kZXgoMCkuaWQpKTtcbiAgICAgIH0sIHVwOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGkgPSBudWxsLCBhID0gbi5nZXRQcmV2KHRoaXMudGFza0lkKTtcbiAgICAgICAgaSA9IG4uaXNUYXNrRXhpc3RzKGEpID8gbmV3IG4uJGtleWJvYXJkTmF2aWdhdGlvbi5UYXNrUm93KGEpIDogbmV3IG4uJGtleWJvYXJkTmF2aWdhdGlvbi5IZWFkZXJDZWxsKCksIHRoaXMubW92ZVRvKGkpO1xuICAgICAgfSwgZG93bjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpID0gbi5nZXROZXh0KHRoaXMudGFza0lkKTtcbiAgICAgICAgbi5pc1Rhc2tFeGlzdHMoaSkgJiYgdGhpcy5tb3ZlVG8obmV3IG4uJGtleWJvYXJkTmF2aWdhdGlvbi5UYXNrUm93KGkpKTtcbiAgICAgIH0sIFwic2hpZnQrZG93blwiOiBmdW5jdGlvbigpIHtcbiAgICAgICAgbi5oYXNDaGlsZCh0aGlzLnRhc2tJZCkgJiYgIW4uZ2V0VGFzayh0aGlzLnRhc2tJZCkuJG9wZW4gJiYgbi5vcGVuKHRoaXMudGFza0lkKTtcbiAgICAgIH0sIFwic2hpZnQrdXBcIjogZnVuY3Rpb24oKSB7XG4gICAgICAgIG4uaGFzQ2hpbGQodGhpcy50YXNrSWQpICYmIG4uZ2V0VGFzayh0aGlzLnRhc2tJZCkuJG9wZW4gJiYgbi5jbG9zZSh0aGlzLnRhc2tJZCk7XG4gICAgICB9LCBcInNoaWZ0K3JpZ2h0XCI6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIW4uaXNSZWFkb25seSh0aGlzKSkge1xuICAgICAgICAgIHZhciBpID0gbi5nZXRQcmV2U2libGluZyh0aGlzLnRhc2tJZCk7XG4gICAgICAgICAgbi5pc1Rhc2tFeGlzdHMoaSkgJiYgIW4uaXNDaGlsZE9mKHRoaXMudGFza0lkLCBpKSAmJiAobi5nZXRUYXNrKGkpLiRvcGVuID0gITAsIG4ubW92ZVRhc2sodGhpcy50YXNrSWQsIC0xLCBpKSAhPT0gITEgJiYgbi51cGRhdGVUYXNrKHRoaXMudGFza0lkKSk7XG4gICAgICAgIH1cbiAgICAgIH0sIFwic2hpZnQrbGVmdFwiOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCFuLmlzUmVhZG9ubHkodGhpcykpIHtcbiAgICAgICAgICB2YXIgaSA9IG4uZ2V0UGFyZW50KHRoaXMudGFza0lkKTtcbiAgICAgICAgICBuLmlzVGFza0V4aXN0cyhpKSAmJiBuLm1vdmVUYXNrKHRoaXMudGFza0lkLCBuLmdldFRhc2tJbmRleChpKSArIDEsIG4uZ2V0UGFyZW50KGkpKSAhPT0gITEgJiYgbi51cGRhdGVUYXNrKHRoaXMudGFza0lkKTtcbiAgICAgICAgfVxuICAgICAgfSwgc3BhY2U6IGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgbi5pc1NlbGVjdGVkVGFzayh0aGlzLnRhc2tJZCkgPyBuLnVuc2VsZWN0VGFzayh0aGlzLnRhc2tJZCkgOiBuLnNlbGVjdFRhc2sodGhpcy50YXNrSWQpO1xuICAgICAgfSwgXCJjdHJsK2xlZnRcIjogZnVuY3Rpb24oaSkge1xuICAgICAgICBuLmNsb3NlKHRoaXMudGFza0lkKTtcbiAgICAgIH0sIFwiY3RybCtyaWdodFwiOiBmdW5jdGlvbihpKSB7XG4gICAgICAgIG4ub3Blbih0aGlzLnRhc2tJZCk7XG4gICAgICB9LCBkZWxldGU6IGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgbi5pc1JlYWRvbmx5KHRoaXMpIHx8IG4uJGNsaWNrLmJ1dHRvbnMuZGVsZXRlKHRoaXMudGFza0lkKTtcbiAgICAgIH0sIGVudGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgbi5pc1JlYWRvbmx5KHRoaXMpIHx8IG4uc2hvd0xpZ2h0Ym94KHRoaXMudGFza0lkKTtcbiAgICAgIH0sIFwiY3RybCtlbnRlclwiOiBmdW5jdGlvbigpIHtcbiAgICAgICAgbi5pc1JlYWRvbmx5KHRoaXMpIHx8IG4uY3JlYXRlVGFzayh7fSwgdGhpcy50YXNrSWQpO1xuICAgICAgfSB9IH0pLCBuLiRrZXlib2FyZE5hdmlnYXRpb24uVGFza1Jvdy5wcm90b3R5cGUuYmluZEFsbChuLiRrZXlib2FyZE5hdmlnYXRpb24uVGFza1Jvdy5wcm90b3R5cGUua2V5cyk7XG4gICAgfShlKSwgZnVuY3Rpb24obikge1xuICAgICAgbi4ka2V5Ym9hcmROYXZpZ2F0aW9uLlRhc2tDZWxsID0gZnVuY3Rpb24oaSwgYSkge1xuICAgICAgICBpZiAoIShpID0gYXQoaSwgbi5jb25maWcucm9vdF9pZCkpKSB7XG4gICAgICAgICAgdmFyIHIgPSBuLmdldENoaWxkcmVuKG4uY29uZmlnLnJvb3RfaWQpO1xuICAgICAgICAgIHJbMF0gJiYgKGkgPSByWzBdKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRhc2tJZCA9IGksIHRoaXMuY29sdW1uSW5kZXggPSBhIHx8IDAsIG4uaXNUYXNrRXhpc3RzKHRoaXMudGFza0lkKSAmJiAodGhpcy5pbmRleCA9IG4uZ2V0VGFza0luZGV4KHRoaXMudGFza0lkKSwgdGhpcy5nbG9iYWxJbmRleCA9IG4uZ2V0R2xvYmFsVGFza0luZGV4KHRoaXMudGFza0lkKSk7XG4gICAgICB9LCBuLiRrZXlib2FyZE5hdmlnYXRpb24uVGFza0NlbGwucHJvdG90eXBlID0gbi5fY29tcG9zZShuLiRrZXlib2FyZE5hdmlnYXRpb24uVGFza1JvdywgeyBfaGFuZGxlcnM6IG51bGwsIGlzVmFsaWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbi4ka2V5Ym9hcmROYXZpZ2F0aW9uLlRhc2tSb3cucHJvdG90eXBlLmlzVmFsaWQuY2FsbCh0aGlzKSAmJiAhIW4uZ2V0R3JpZENvbHVtbnMoKVt0aGlzLmNvbHVtbkluZGV4XTtcbiAgICAgIH0sIGZhbGxiYWNrOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGkgPSBuLiRrZXlib2FyZE5hdmlnYXRpb24uVGFza1Jvdy5wcm90b3R5cGUuZmFsbGJhY2suY2FsbCh0aGlzKSwgYSA9IGk7XG4gICAgICAgIGlmIChpIGluc3RhbmNlb2Ygbi4ka2V5Ym9hcmROYXZpZ2F0aW9uLlRhc2tSb3cpIHtcbiAgICAgICAgICBmb3IgKHZhciByID0gbi5nZXRHcmlkQ29sdW1ucygpLCBzID0gdGhpcy5jb2x1bW5JbmRleDsgcyA+PSAwICYmICFyW3NdOyApIHMtLTtcbiAgICAgICAgICByW3NdICYmIChhID0gbmV3IG4uJGtleWJvYXJkTmF2aWdhdGlvbi5UYXNrQ2VsbChpLnRhc2tJZCwgcykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhO1xuICAgICAgfSwgZnJvbURvbUVsZW1lbnQ6IGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgaWYgKCFuLmNvbmZpZy5rZXlib2FyZF9uYXZpZ2F0aW9uX2NlbGxzKSByZXR1cm4gbnVsbDtcbiAgICAgICAgdmFyIGEgPSBuLmxvY2F0ZShpKTtcbiAgICAgICAgaWYgKG4uaXNUYXNrRXhpc3RzKGEpKSB7XG4gICAgICAgICAgdmFyIHIgPSAwLCBzID0gZXQoaSwgXCJkYXRhLWNvbHVtbi1pbmRleFwiKTtcbiAgICAgICAgICByZXR1cm4gcyAmJiAociA9IDEgKiBzLmdldEF0dHJpYnV0ZShcImRhdGEtY29sdW1uLWluZGV4XCIpKSwgbmV3IG4uJGtleWJvYXJkTmF2aWdhdGlvbi5UYXNrQ2VsbChhLCByKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0sIGdldE5vZGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAobi5pc1Rhc2tFeGlzdHModGhpcy50YXNrSWQpICYmIChuLmlzVGFza1Zpc2libGUodGhpcy50YXNrSWQpIHx8IG4uY29uZmlnLnNob3dfdGFza3Nfb3V0c2lkZV90aW1lc2NhbGUpKSB7XG4gICAgICAgICAgaWYgKG4uY29uZmlnLnNob3dfZ3JpZCAmJiBuLiRncmlkKSB7XG4gICAgICAgICAgICB2YXIgaSA9IG4uJGdyaWQucXVlcnlTZWxlY3RvcihcIi5nYW50dF9yb3dbXCIgKyBuLmNvbmZpZy50YXNrX2F0dHJpYnV0ZSArIFwiPSdcIiArIHRoaXMudGFza0lkICsgXCInXVwiKTtcbiAgICAgICAgICAgIHJldHVybiBpID8gaS5xdWVyeVNlbGVjdG9yKFwiW2RhdGEtY29sdW1uLWluZGV4PSdcIiArIHRoaXMuY29sdW1uSW5kZXggKyBcIiddXCIpIDogbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG4uZ2V0VGFza05vZGUodGhpcy50YXNrSWQpO1xuICAgICAgICB9XG4gICAgICB9LCBrZXlzOiB7IHVwOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGkgPSBudWxsLCBhID0gbi5nZXRQcmV2KHRoaXMudGFza0lkKTtcbiAgICAgICAgaSA9IG4uaXNUYXNrRXhpc3RzKGEpID8gbmV3IG4uJGtleWJvYXJkTmF2aWdhdGlvbi5UYXNrQ2VsbChhLCB0aGlzLmNvbHVtbkluZGV4KSA6IG5ldyBuLiRrZXlib2FyZE5hdmlnYXRpb24uSGVhZGVyQ2VsbCh0aGlzLmNvbHVtbkluZGV4KSwgdGhpcy5tb3ZlVG8oaSk7XG4gICAgICB9LCBkb3duOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGkgPSBuLmdldE5leHQodGhpcy50YXNrSWQpO1xuICAgICAgICBuLmlzVGFza0V4aXN0cyhpKSAmJiB0aGlzLm1vdmVUbyhuZXcgbi4ka2V5Ym9hcmROYXZpZ2F0aW9uLlRhc2tDZWxsKGksIHRoaXMuY29sdW1uSW5kZXgpKTtcbiAgICAgIH0sIGxlZnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmNvbHVtbkluZGV4ID4gMCAmJiB0aGlzLm1vdmVUbyhuZXcgbi4ka2V5Ym9hcmROYXZpZ2F0aW9uLlRhc2tDZWxsKHRoaXMudGFza0lkLCB0aGlzLmNvbHVtbkluZGV4IC0gMSkpO1xuICAgICAgfSwgcmlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaSA9IG4uZ2V0R3JpZENvbHVtbnMoKTtcbiAgICAgICAgdGhpcy5jb2x1bW5JbmRleCA8IGkubGVuZ3RoIC0gMSAmJiB0aGlzLm1vdmVUbyhuZXcgbi4ka2V5Ym9hcmROYXZpZ2F0aW9uLlRhc2tDZWxsKHRoaXMudGFza0lkLCB0aGlzLmNvbHVtbkluZGV4ICsgMSkpO1xuICAgICAgfSwgZW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGkgPSBuLmdldEdyaWRDb2x1bW5zKCk7XG4gICAgICAgIHRoaXMubW92ZVRvKG5ldyBuLiRrZXlib2FyZE5hdmlnYXRpb24uVGFza0NlbGwodGhpcy50YXNrSWQsIGkubGVuZ3RoIC0gMSkpO1xuICAgICAgfSwgaG9tZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMubW92ZVRvKG5ldyBuLiRrZXlib2FyZE5hdmlnYXRpb24uVGFza0NlbGwodGhpcy50YXNrSWQsIDApKTtcbiAgICAgIH0sIHBhZ2Vkb3duOiBmdW5jdGlvbigpIHtcbiAgICAgICAgbi5nZXRWaXNpYmxlVGFza0NvdW50KCkgJiYgdGhpcy5tb3ZlVG8obmV3IG4uJGtleWJvYXJkTmF2aWdhdGlvbi5UYXNrQ2VsbChuLmdldFRhc2tCeUluZGV4KG4uZ2V0VmlzaWJsZVRhc2tDb3VudCgpIC0gMSkuaWQsIHRoaXMuY29sdW1uSW5kZXgpKTtcbiAgICAgIH0sIHBhZ2V1cDogZnVuY3Rpb24oKSB7XG4gICAgICAgIG4uZ2V0VmlzaWJsZVRhc2tDb3VudCgpICYmIHRoaXMubW92ZVRvKG5ldyBuLiRrZXlib2FyZE5hdmlnYXRpb24uVGFza0NlbGwobi5nZXRUYXNrQnlJbmRleCgwKS5pZCwgdGhpcy5jb2x1bW5JbmRleCkpO1xuICAgICAgfSB9IH0pLCBuLiRrZXlib2FyZE5hdmlnYXRpb24uVGFza0NlbGwucHJvdG90eXBlLmJpbmRBbGwobi4ka2V5Ym9hcmROYXZpZ2F0aW9uLlRhc2tSb3cucHJvdG90eXBlLmtleXMpLCBuLiRrZXlib2FyZE5hdmlnYXRpb24uVGFza0NlbGwucHJvdG90eXBlLmJpbmRBbGwobi4ka2V5Ym9hcmROYXZpZ2F0aW9uLlRhc2tDZWxsLnByb3RvdHlwZS5rZXlzKTtcbiAgICB9KGUpLCBSbihlKSwgZnVuY3Rpb24obikge1xuICAgICAgbi4ka2V5Ym9hcmROYXZpZ2F0aW9uLmRpc3BhdGNoZXIgPSB7IGlzQWN0aXZlOiAhMSwgYWN0aXZlTm9kZTogbnVsbCwgZ2xvYmFsTm9kZTogbmV3IG4uJGtleWJvYXJkTmF2aWdhdGlvbi5HYW50dE5vZGUoKSwgZW5hYmxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5pc0FjdGl2ZSA9ICEwLCB0aGlzLnNldEFjdGl2ZU5vZGUodGhpcy5nZXRBY3RpdmVOb2RlKCkpO1xuICAgICAgfSwgZGlzYWJsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuaXNBY3RpdmUgPSAhMTtcbiAgICAgIH0sIGlzRW5hYmxlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuaXNBY3RpdmU7XG4gICAgICB9LCBnZXREZWZhdWx0Tm9kZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpO1xuICAgICAgICByZXR1cm4gKGkgPSBuLmNvbmZpZy5rZXlib2FyZF9uYXZpZ2F0aW9uX2NlbGxzID8gbmV3IG4uJGtleWJvYXJkTmF2aWdhdGlvbi5UYXNrQ2VsbCgpIDogbmV3IG4uJGtleWJvYXJkTmF2aWdhdGlvbi5UYXNrUm93KCkpLmlzVmFsaWQoKSB8fCAoaSA9IGkuZmFsbGJhY2soKSksIGk7XG4gICAgICB9LCBzZXREZWZhdWx0Tm9kZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc2V0QWN0aXZlTm9kZSh0aGlzLmdldERlZmF1bHROb2RlKCkpO1xuICAgICAgfSwgZ2V0QWN0aXZlTm9kZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpID0gdGhpcy5hY3RpdmVOb2RlO1xuICAgICAgICByZXR1cm4gaSAmJiAhaS5pc1ZhbGlkKCkgJiYgKGkgPSBpLmZhbGxiYWNrKCkpLCBpO1xuICAgICAgfSwgZnJvbURvbUVsZW1lbnQ6IGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgZm9yICh2YXIgYSA9IFtuLiRrZXlib2FyZE5hdmlnYXRpb24uVGFza1Jvdywgbi4ka2V5Ym9hcmROYXZpZ2F0aW9uLlRhc2tDZWxsLCBuLiRrZXlib2FyZE5hdmlnYXRpb24uSGVhZGVyQ2VsbF0sIHIgPSAwOyByIDwgYS5sZW5ndGg7IHIrKykgaWYgKGFbcl0ucHJvdG90eXBlLmZyb21Eb21FbGVtZW50KSB7XG4gICAgICAgICAgdmFyIHMgPSBhW3JdLnByb3RvdHlwZS5mcm9tRG9tRWxlbWVudChpKTtcbiAgICAgICAgICBpZiAocykgcmV0dXJuIHM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9LCBmb2N1c0dsb2JhbE5vZGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmJsdXJOb2RlKHRoaXMuZ2xvYmFsTm9kZSksIHRoaXMuZm9jdXNOb2RlKHRoaXMuZ2xvYmFsTm9kZSk7XG4gICAgICB9LCBzZXRBY3RpdmVOb2RlOiBmdW5jdGlvbihpKSB7XG4gICAgICAgIHZhciBhID0gITA7XG4gICAgICAgIHRoaXMuYWN0aXZlTm9kZSAmJiB0aGlzLmFjdGl2ZU5vZGUuY29tcGFyZVRvKGkpICYmIChhID0gITEpLCB0aGlzLmlzRW5hYmxlZCgpICYmIChhICYmIHRoaXMuYmx1ck5vZGUodGhpcy5hY3RpdmVOb2RlKSwgdGhpcy5hY3RpdmVOb2RlID0gaSwgdGhpcy5mb2N1c05vZGUodGhpcy5hY3RpdmVOb2RlLCAhYSkpO1xuICAgICAgfSwgZm9jdXNOb2RlOiBmdW5jdGlvbihpLCBhKSB7XG4gICAgICAgIGkgJiYgaS5mb2N1cyAmJiBpLmZvY3VzKGEpO1xuICAgICAgfSwgYmx1ck5vZGU6IGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgaSAmJiBpLmJsdXIgJiYgaS5ibHVyKCk7XG4gICAgICB9LCBrZXlEb3duSGFuZGxlcjogZnVuY3Rpb24oaSkge1xuICAgICAgICBpZiAoIW4uJGtleWJvYXJkTmF2aWdhdGlvbi5pc01vZGFsKCkgJiYgdGhpcy5pc0VuYWJsZWQoKSAmJiAhaS5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgdmFyIGEgPSB0aGlzLmdsb2JhbE5vZGUsIHIgPSBuLiRrZXlib2FyZE5hdmlnYXRpb24uc2hvcnRjdXRzLmdldENvbW1hbmRGcm9tRXZlbnQoaSksIHMgPSB0aGlzLmdldEFjdGl2ZU5vZGUoKTtcbiAgICAgICAgICBuLiRrZXlib2FyZE5hdmlnYXRpb24uZmFjYWRlLmNhbGxFdmVudChcIm9uS2V5RG93blwiLCBbciwgaV0pICE9PSAhMSAmJiAocyA/IHMuZmluZEhhbmRsZXIocikgPyBzLmRvQWN0aW9uKHIsIGkpIDogYS5maW5kSGFuZGxlcihyKSAmJiBhLmRvQWN0aW9uKHIsIGkpIDogdGhpcy5zZXREZWZhdWx0Tm9kZSgpKTtcbiAgICAgICAgfVxuICAgICAgfSwgX3RpbWVvdXQ6IG51bGwsIGF3YWl0c0ZvY3VzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RpbWVvdXQgIT09IG51bGw7XG4gICAgICB9LCBkZWxheTogZnVuY3Rpb24oaSwgYSkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZW91dCksIHRoaXMuX3RpbWVvdXQgPSBzZXRUaW1lb3V0KG4uYmluZChmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aGlzLl90aW1lb3V0ID0gbnVsbCwgaSgpO1xuICAgICAgICB9LCB0aGlzKSwgYSB8fCAxKTtcbiAgICAgIH0sIGNsZWFyRGVsYXk6IGZ1bmN0aW9uKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZW91dCk7XG4gICAgICB9IH07XG4gICAgfShlKSwgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbiA9IGUuJGtleWJvYXJkTmF2aWdhdGlvbi5kaXNwYXRjaGVyO1xuICAgICAgbi5pc1Rhc2tGb2N1c2VkID0gZnVuY3Rpb24odikge1xuICAgICAgICB2YXIgYiA9IG4uYWN0aXZlTm9kZTtcbiAgICAgICAgcmV0dXJuIChiIGluc3RhbmNlb2YgZS4ka2V5Ym9hcmROYXZpZ2F0aW9uLlRhc2tSb3cgfHwgYiBpbnN0YW5jZW9mIGUuJGtleWJvYXJkTmF2aWdhdGlvbi5UYXNrQ2VsbCkgJiYgYi50YXNrSWQgPT0gdjtcbiAgICAgIH07XG4gICAgICB2YXIgaSA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgaWYgKGUuY29uZmlnLmtleWJvYXJkX25hdmlnYXRpb24gJiYgKGUuY29uZmlnLmtleWJvYXJkX25hdmlnYXRpb25fY2VsbHMgfHwgIXModikpICYmICFvKHYpICYmICFmdW5jdGlvbihiKSB7XG4gICAgICAgICAgcmV0dXJuICEhY3QoYi50YXJnZXQsIFwiLmdhbnR0X2NhbF9saWdodFwiKTtcbiAgICAgICAgfSh2KSkgcmV0dXJuIG4ua2V5RG93bkhhbmRsZXIodik7XG4gICAgICB9LCBhID0gZnVuY3Rpb24odikge1xuICAgICAgICBpZiAobi4kcHJldmVudERlZmF1bHQpIHJldHVybiB2LnByZXZlbnREZWZhdWx0KCksIGUuJGNvbnRhaW5lci5ibHVyKCksICExO1xuICAgICAgICBuLmF3YWl0c0ZvY3VzKCkgfHwgbi5mb2N1c0dsb2JhbE5vZGUoKTtcbiAgICAgIH0sIHIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCFuLmlzRW5hYmxlZCgpKSByZXR1cm47XG4gICAgICAgIGNvbnN0IHYgPSAhWShkb2N1bWVudC5hY3RpdmVFbGVtZW50LCBlLiRjb250YWluZXIpICYmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQubG9jYWxOYW1lICE9IFwiYm9keVwiO1xuICAgICAgICB2YXIgYiA9IG4uZ2V0QWN0aXZlTm9kZSgpO1xuICAgICAgICBpZiAoYiAmJiAhdikge1xuICAgICAgICAgIHZhciBfLCBtLCBmID0gYi5nZXROb2RlKCk7XG4gICAgICAgICAgZiAmJiBmLnBhcmVudE5vZGUgJiYgKF8gPSBmLnBhcmVudE5vZGUuc2Nyb2xsVG9wLCBtID0gZi5wYXJlbnROb2RlLnNjcm9sbExlZnQpLCBiLmZvY3VzKCEwKSwgZiAmJiBmLnBhcmVudE5vZGUgJiYgKGYucGFyZW50Tm9kZS5zY3JvbGxUb3AgPSBfLCBmLnBhcmVudE5vZGUuc2Nyb2xsTGVmdCA9IG0pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgZnVuY3Rpb24gcyh2KSB7XG4gICAgICAgIHJldHVybiAhIWN0KHYudGFyZ2V0LCBcIi5nYW50dF9ncmlkX2VkaXRvcl9wbGFjZWhvbGRlclwiKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIG8odikge1xuICAgICAgICByZXR1cm4gISFjdCh2LnRhcmdldCwgXCIubm9fa2V5Ym9hcmRfbmF2aWdhdGlvblwiKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGwodikge1xuICAgICAgICBpZiAoIWUuY29uZmlnLmtleWJvYXJkX25hdmlnYXRpb24gfHwgIWUuY29uZmlnLmtleWJvYXJkX25hdmlnYXRpb25fY2VsbHMgJiYgcyh2KSkgcmV0dXJuICEwO1xuICAgICAgICBpZiAoIW8odikpIHtcbiAgICAgICAgICB2YXIgYiwgXyA9IG4uZnJvbURvbUVsZW1lbnQodik7XG4gICAgICAgICAgaWYgKF8gJiYgKG4uYWN0aXZlTm9kZSBpbnN0YW5jZW9mIGUuJGtleWJvYXJkTmF2aWdhdGlvbi5UYXNrQ2VsbCAmJiBZKHYudGFyZ2V0LCBlLiR0YXNrKSAmJiAoXyA9IG5ldyBlLiRrZXlib2FyZE5hdmlnYXRpb24uVGFza0NlbGwoXy50YXNrSWQsIG4uYWN0aXZlTm9kZS5jb2x1bW5JbmRleCkpLCBiID0gXywgZS5jb25maWcuc2hvd19ncmlkICYmIGUuJHVpLmdldFZpZXcoXCJncmlkXCIpICYmIGUuY29uZmlnLmtleWJvYXJkX25hdmlnYXRpb25fY2VsbHMpKSB7XG4gICAgICAgICAgICBjb25zdCBtID0gdi50YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKFwiZ2FudHRfcm93XCIpLCBmID0gdi50YXJnZXQuY2xvc2VzdChcIi5nYW50dF90YXNrX2xpbmVcIiksIGsgPSBlLnV0aWxzLmRvbS5nZXROb2RlUG9zaXRpb24oZS4kZ3JpZCkueCwgeCA9IGsgKyBlLiRncmlkLm9mZnNldFdpZHRoLCAkID0gZS51dGlscy5kb20uZ2V0Tm9kZVBvc2l0aW9uKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpLng7XG4gICAgICAgICAgICBpZiAobSB8fCBmICYmICgkIDwgayB8fCB4IDwgJCkpIHtcbiAgICAgICAgICAgICAgbGV0IHcgPSBlLiRncmlkLnNjcm9sbExlZnQ7XG4gICAgICAgICAgICAgIGNvbnN0IFMgPSB3ICsgZS4kZ3JpZC5vZmZzZXRXaWR0aDtcbiAgICAgICAgICAgICAgbGV0IFQgPSAwO1xuICAgICAgICAgICAgICBtICYmICh3ID0gZS51dGlscy5kb20uZ2V0UmVsYXRpdmVFdmVudFBvc2l0aW9uKHYsIGUuJGdyaWQpLngpO1xuICAgICAgICAgICAgICBmb3IgKGxldCBFID0gMDsgRSA8IGUuY29uZmlnLmNvbHVtbnMubGVuZ3RoOyBFKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBDID0gZS5jb25maWcuY29sdW1uc1tFXTtcbiAgICAgICAgICAgICAgICBpZiAoIUMuaGlkZSAmJiAoVCArPSBDLndpZHRoLCB3IDwgVCkpIHtcbiAgICAgICAgICAgICAgICAgIFMgPCBUICYmIChUIC09IEMud2lkdGgpLCBiLmNvbHVtbkluZGV4ID0gRTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBiID8gbi5pc0VuYWJsZWQoKSA/IG4uZGVsYXkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBuLnNldEFjdGl2ZU5vZGUoYik7XG4gICAgICAgICAgfSkgOiBuLmFjdGl2ZU5vZGUgPSBiIDogKG4uJHByZXZlbnREZWZhdWx0ID0gITAsIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBuLiRwcmV2ZW50RGVmYXVsdCA9ICExO1xuICAgICAgICAgIH0sIDMwMCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlLmF0dGFjaEV2ZW50KFwib25EYXRhUmVuZGVyXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICBlLmNvbmZpZy5rZXlib2FyZF9uYXZpZ2F0aW9uICYmIHIoKTtcbiAgICAgIH0pLCBlLmF0dGFjaEV2ZW50KFwib25HYW50dFJlbmRlclwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgZS4kcm9vdCAmJiAoZS5ldmVudFJlbW92ZShlLiRyb290LCBcImtleWRvd25cIiwgaSksIGUuZXZlbnRSZW1vdmUoZS4kY29udGFpbmVyLCBcImZvY3VzXCIsIGEpLCBlLmV2ZW50UmVtb3ZlKGUuJGNvbnRhaW5lciwgXCJtb3VzZWRvd25cIiwgbCksIGUuY29uZmlnLmtleWJvYXJkX25hdmlnYXRpb24gPyAoZS5ldmVudChlLiRyb290LCBcImtleWRvd25cIiwgaSksIGUuZXZlbnQoZS4kY29udGFpbmVyLCBcImZvY3VzXCIsIGEpLCBlLmV2ZW50KGUuJGNvbnRhaW5lciwgXCJtb3VzZWRvd25cIiwgbCksIGUuJGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiLCBcIjBcIikpIDogZS4kY29udGFpbmVyLnJlbW92ZUF0dHJpYnV0ZShcInRhYmluZGV4XCIpKTtcbiAgICAgIH0pO1xuICAgICAgdmFyIGQgPSBlLmF0dGFjaEV2ZW50KFwib25HYW50dFJlYWR5XCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoZS5kZXRhY2hFdmVudChkKSwgZS4kZGF0YS50YXNrc1N0b3JlLmF0dGFjaEV2ZW50KFwib25TdG9yZVVwZGF0ZWRcIiwgZnVuY3Rpb24oYikge1xuICAgICAgICAgIGlmIChlLmNvbmZpZy5rZXlib2FyZF9uYXZpZ2F0aW9uICYmIG4uaXNFbmFibGVkKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IF8gPSBuLmdldEFjdGl2ZU5vZGUoKSwgbSA9IGUuJHVpLmdldFZpZXcoXCJncmlkXCIpO1xuICAgICAgICAgICAgaWYgKCFtIHx8ICFtLiRncmlkX2RhdGEpIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IGYgPSBtLmdldEl0ZW1Ub3AoYiksIGsgPSBtLiRncmlkX2RhdGEuc2Nyb2xsVG9wLCB4ID0gayArIG0uJGdyaWRfZGF0YS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ7XG4gICAgICAgICAgICBfICYmIF8udGFza0lkID09IGIgJiYgayA8PSBmICYmIHggPj0gZiAmJiByKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KSwgZS5fc21hcnRfcmVuZGVyKSB7XG4gICAgICAgICAgdmFyIHYgPSBlLl9zbWFydF9yZW5kZXIuX3JlZHJhd1Rhc2tzO1xuICAgICAgICAgIGUuX3NtYXJ0X3JlbmRlci5fcmVkcmF3VGFza3MgPSBmdW5jdGlvbihiLCBfKSB7XG4gICAgICAgICAgICBpZiAoZS5jb25maWcua2V5Ym9hcmRfbmF2aWdhdGlvbiAmJiBuLmlzRW5hYmxlZCgpKSB7XG4gICAgICAgICAgICAgIHZhciBtID0gbi5nZXRBY3RpdmVOb2RlKCk7XG4gICAgICAgICAgICAgIGlmIChtICYmIG0udGFza0lkICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBmID0gITEsIGsgPSAwOyBrIDwgXy5sZW5ndGg7IGsrKykgaWYgKF9ba10uaWQgPT0gbS50YXNrSWQgJiYgX1trXS5zdGFydF9kYXRlKSB7XG4gICAgICAgICAgICAgICAgICBmID0gITA7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZiB8fCBfLnB1c2goZS5nZXRUYXNrKG0udGFza0lkKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBsZXQgYyA9IG51bGwsIHUgPSAhMTtcbiAgICAgIGUuYXR0YWNoRXZlbnQoXCJvblRhc2tDcmVhdGVkXCIsIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgcmV0dXJuIGMgPSB2LmlkLCAhMDtcbiAgICAgIH0pLCBlLmF0dGFjaEV2ZW50KFwib25BZnRlclRhc2tBZGRcIiwgZnVuY3Rpb24odiwgYikge1xuICAgICAgICBpZiAoIWUuY29uZmlnLmtleWJvYXJkX25hdmlnYXRpb24pIHJldHVybiAhMDtcbiAgICAgICAgaWYgKG4uaXNFbmFibGVkKCkpIHtcbiAgICAgICAgICBpZiAodiA9PSBjICYmICh1ID0gITAsIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdSA9ICExLCBjID0gbnVsbDtcbiAgICAgICAgICB9KSksIHUgJiYgYi50eXBlID09IGUuY29uZmlnLnR5cGVzLnBsYWNlaG9sZGVyKSByZXR1cm47XG4gICAgICAgICAgdmFyIF8gPSAwLCBtID0gbi5hY3RpdmVOb2RlO1xuICAgICAgICAgIG0gaW5zdGFuY2VvZiBlLiRrZXlib2FyZE5hdmlnYXRpb24uVGFza0NlbGwgJiYgKF8gPSBtLmNvbHVtbkluZGV4KTtcbiAgICAgICAgICB2YXIgZiA9IGUuY29uZmlnLmtleWJvYXJkX25hdmlnYXRpb25fY2VsbHMgPyBlLiRrZXlib2FyZE5hdmlnYXRpb24uVGFza0NlbGwgOiBlLiRrZXlib2FyZE5hdmlnYXRpb24uVGFza1JvdztcbiAgICAgICAgICBiLnR5cGUgPT0gZS5jb25maWcudHlwZXMucGxhY2Vob2xkZXIgJiYgZS5jb25maWcucGxhY2Vob2xkZXJfdGFzay5mb2N1c09uQ3JlYXRlID09PSAhMSB8fCBuLnNldEFjdGl2ZU5vZGUobmV3IGYodiwgXykpO1xuICAgICAgICB9XG4gICAgICB9KSwgZS5hdHRhY2hFdmVudChcIm9uVGFza0lkQ2hhbmdlXCIsIGZ1bmN0aW9uKHYsIGIpIHtcbiAgICAgICAgaWYgKCFlLmNvbmZpZy5rZXlib2FyZF9uYXZpZ2F0aW9uKSByZXR1cm4gITA7XG4gICAgICAgIHZhciBfID0gbi5hY3RpdmVOb2RlO1xuICAgICAgICByZXR1cm4gbi5pc1Rhc2tGb2N1c2VkKHYpICYmIChfLnRhc2tJZCA9IGIpLCAhMDtcbiAgICAgIH0pO1xuICAgICAgdmFyIGggPSBzZXRJbnRlcnZhbChmdW5jdGlvbigpIHtcbiAgICAgICAgZS5jb25maWcua2V5Ym9hcmRfbmF2aWdhdGlvbiAmJiAobi5pc0VuYWJsZWQoKSB8fCBuLmVuYWJsZSgpKTtcbiAgICAgIH0sIDUwMCk7XG4gICAgICBmdW5jdGlvbiBnKHYpIHtcbiAgICAgICAgdmFyIGIgPSB7IGdhbnR0OiBlLiRrZXlib2FyZE5hdmlnYXRpb24uR2FudHROb2RlLCBoZWFkZXJDZWxsOiBlLiRrZXlib2FyZE5hdmlnYXRpb24uSGVhZGVyQ2VsbCwgdGFza1JvdzogZS4ka2V5Ym9hcmROYXZpZ2F0aW9uLlRhc2tSb3csIHRhc2tDZWxsOiBlLiRrZXlib2FyZE5hdmlnYXRpb24uVGFza0NlbGwgfTtcbiAgICAgICAgcmV0dXJuIGJbdl0gfHwgYi5nYW50dDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHAodikge1xuICAgICAgICBmb3IgKHZhciBiID0gZS5nZXRHcmlkQ29sdW1ucygpLCBfID0gMDsgXyA8IGIubGVuZ3RoOyBfKyspIGlmIChiW19dLm5hbWUgPT0gdikgcmV0dXJuIF87XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgICAgZS5hdHRhY2hFdmVudChcIm9uRGVzdHJveVwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbChoKTtcbiAgICAgIH0pO1xuICAgICAgdmFyIHkgPSB7fTtcbiAgICAgIG90KHkpLCBlLm1peGluKHksIHsgYWRkU2hvcnRjdXQ6IGZ1bmN0aW9uKHYsIGIsIF8pIHtcbiAgICAgICAgdmFyIG0gPSBnKF8pO1xuICAgICAgICBtICYmIG0ucHJvdG90eXBlLmJpbmQodiwgYik7XG4gICAgICB9LCBnZXRTaG9ydGN1dEhhbmRsZXI6IGZ1bmN0aW9uKHYsIGIpIHtcbiAgICAgICAgdmFyIF8gPSBlLiRrZXlib2FyZE5hdmlnYXRpb24uc2hvcnRjdXRzLnBhcnNlKHYpO1xuICAgICAgICBpZiAoXy5sZW5ndGgpIHJldHVybiB5LmdldENvbW1hbmRIYW5kbGVyKF9bMF0sIGIpO1xuICAgICAgfSwgZ2V0Q29tbWFuZEhhbmRsZXI6IGZ1bmN0aW9uKHYsIGIpIHtcbiAgICAgICAgdmFyIF8gPSBnKGIpO1xuICAgICAgICBpZiAoXyAmJiB2KSByZXR1cm4gXy5wcm90b3R5cGUuZmluZEhhbmRsZXIodik7XG4gICAgICB9LCByZW1vdmVTaG9ydGN1dDogZnVuY3Rpb24odiwgYikge1xuICAgICAgICB2YXIgXyA9IGcoYik7XG4gICAgICAgIF8gJiYgXy5wcm90b3R5cGUudW5iaW5kKHYpO1xuICAgICAgfSwgZm9jdXM6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgdmFyIGIsIF8gPSB2ID8gdi50eXBlIDogbnVsbCwgbSA9IGcoXyk7XG4gICAgICAgIHN3aXRjaCAoXykge1xuICAgICAgICAgIGNhc2UgXCJ0YXNrQ2VsbFwiOlxuICAgICAgICAgICAgYiA9IG5ldyBtKHYuaWQsIHAodi5jb2x1bW4pKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJ0YXNrUm93XCI6XG4gICAgICAgICAgICBiID0gbmV3IG0odi5pZCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiaGVhZGVyQ2VsbFwiOlxuICAgICAgICAgICAgYiA9IG5ldyBtKHAodi5jb2x1bW4pKTtcbiAgICAgICAgfVxuICAgICAgICBuLmRlbGF5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGIgPyBuLnNldEFjdGl2ZU5vZGUoYikgOiAobi5lbmFibGUoKSwgbi5nZXRBY3RpdmVOb2RlKCkgPyBuLmF3YWl0c0ZvY3VzKCkgfHwgbi5lbmFibGUoKSA6IG4uc2V0RGVmYXVsdE5vZGUoKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSwgZ2V0QWN0aXZlTm9kZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChuLmlzRW5hYmxlZCgpKSB7XG4gICAgICAgICAgdmFyIHYgPSBuLmdldEFjdGl2ZU5vZGUoKSwgYiA9IChtID0gdikgaW5zdGFuY2VvZiBlLiRrZXlib2FyZE5hdmlnYXRpb24uR2FudHROb2RlID8gXCJnYW50dFwiIDogbSBpbnN0YW5jZW9mIGUuJGtleWJvYXJkTmF2aWdhdGlvbi5IZWFkZXJDZWxsID8gXCJoZWFkZXJDZWxsXCIgOiBtIGluc3RhbmNlb2YgZS4ka2V5Ym9hcmROYXZpZ2F0aW9uLlRhc2tSb3cgPyBcInRhc2tSb3dcIiA6IG0gaW5zdGFuY2VvZiBlLiRrZXlib2FyZE5hdmlnYXRpb24uVGFza0NlbGwgPyBcInRhc2tDZWxsXCIgOiBudWxsLCBfID0gZS5nZXRHcmlkQ29sdW1ucygpO1xuICAgICAgICAgIHN3aXRjaCAoYikge1xuICAgICAgICAgICAgY2FzZSBcInRhc2tDZWxsXCI6XG4gICAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwidGFza0NlbGxcIiwgaWQ6IHYudGFza0lkLCBjb2x1bW46IF9bdi5jb2x1bW5JbmRleF0ubmFtZSB9O1xuICAgICAgICAgICAgY2FzZSBcInRhc2tSb3dcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJ0YXNrUm93XCIsIGlkOiB2LnRhc2tJZCB9O1xuICAgICAgICAgICAgY2FzZSBcImhlYWRlckNlbGxcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJoZWFkZXJDZWxsXCIsIGNvbHVtbjogX1t2LmluZGV4XS5uYW1lIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBtO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gfSksIGUuJGtleWJvYXJkTmF2aWdhdGlvbi5mYWNhZGUgPSB5LCBlLmV4dC5rZXlib2FyZE5hdmlnYXRpb24gPSB5LCBlLmZvY3VzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHkuZm9jdXMoKTtcbiAgICAgIH0sIGUuYWRkU2hvcnRjdXQgPSB5LmFkZFNob3J0Y3V0LCBlLmdldFNob3J0Y3V0SGFuZGxlciA9IHkuZ2V0U2hvcnRjdXRIYW5kbGVyLCBlLnJlbW92ZVNob3J0Y3V0ID0geS5yZW1vdmVTaG9ydGN1dDtcbiAgICB9KCk7XG4gIH0pKHQpO1xufSwgcXVpY2tfaW5mbzogZnVuY3Rpb24odCkge1xuICB0LmV4dCB8fCAodC5leHQgPSB7fSksIHQuZXh0LnF1aWNrSW5mbyA9IG5ldyBIbih0KSwgdC5jb25maWcucXVpY2tpbmZvX2J1dHRvbnMgPSBbXCJpY29uX2VkaXRcIiwgXCJpY29uX2RlbGV0ZVwiXSwgdC5jb25maWcucXVpY2tfaW5mb19kZXRhY2hlZCA9ICEwLCB0LmNvbmZpZy5zaG93X3F1aWNrX2luZm8gPSAhMCwgdC50ZW1wbGF0ZXMucXVpY2tfaW5mb190aXRsZSA9IGZ1bmN0aW9uKGEsIHIsIHMpIHtcbiAgICByZXR1cm4gcy50ZXh0LnN1YnN0cigwLCA1MCk7XG4gIH0sIHQudGVtcGxhdGVzLnF1aWNrX2luZm9fY29udGVudCA9IGZ1bmN0aW9uKGEsIHIsIHMpIHtcbiAgICByZXR1cm4gcy5kZXRhaWxzIHx8IHMudGV4dDtcbiAgfSwgdC50ZW1wbGF0ZXMucXVpY2tfaW5mb19kYXRlID0gZnVuY3Rpb24oYSwgciwgcykge1xuICAgIHJldHVybiB0LnRlbXBsYXRlcy50YXNrX3RpbWUoYSwgciwgcyk7XG4gIH0sIHQudGVtcGxhdGVzLnF1aWNrX2luZm9fY2xhc3MgPSBmdW5jdGlvbihhLCByLCBzKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH0sIHQuYXR0YWNoRXZlbnQoXCJvblRhc2tDbGlja1wiLCBmdW5jdGlvbihhLCByKSB7XG4gICAgY29uc3QgcyA9IHQudXRpbHMuZG9tLmNsb3Nlc3Qoci50YXJnZXQsIFwiLmdhbnR0X2FkZFwiKSwgbyA9IHQudXRpbHMuZG9tLmNsb3Nlc3Qoci50YXJnZXQsIFwiLmdhbnR0X2Nsb3NlXCIpLCBsID0gdC51dGlscy5kb20uY2xvc2VzdChyLnRhcmdldCwgXCIuZ2FudHRfb3BlblwiKTtcbiAgICByZXR1cm4gIXMgJiYgIW8gJiYgIWwgJiYgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIHQuZXh0LnF1aWNrSW5mby5zaG93KGEpO1xuICAgIH0sIDApLCAhMDtcbiAgfSk7XG4gIGNvbnN0IGUgPSBbXCJvblZpZXdDaGFuZ2VcIiwgXCJvbkxpZ2h0Ym94XCIsIFwib25CZWZvcmVUYXNrRGVsZXRlXCIsIFwib25CZWZvcmVEcmFnXCJdLCBuID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHQuZXh0LnF1aWNrSW5mby5oaWRlKCksICEwO1xuICB9O1xuICBmb3IgKGxldCBhID0gMDsgYSA8IGUubGVuZ3RoOyBhKyspIHQuYXR0YWNoRXZlbnQoZVthXSwgbik7XG4gIGZ1bmN0aW9uIGkoKSB7XG4gICAgcmV0dXJuIHQuZXh0LnF1aWNrSW5mby5oaWRlKCksIHQuZXh0LnF1aWNrSW5mby5fcXVpY2tJbmZvQm94ID0gbnVsbCwgITA7XG4gIH1cbiAgdC5hdHRhY2hFdmVudChcIm9uRW1wdHlDbGlja1wiLCBmdW5jdGlvbihhKSB7XG4gICAgbGV0IHIgPSAhMDtcbiAgICBjb25zdCBzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi5nYW50dF9jYWxfcXVpY2tfaW5mb1wiKTtcbiAgICBzICYmIHQudXRpbHMuZG9tLmlzQ2hpbGRPZihhLnRhcmdldCwgcykgJiYgKHIgPSAhMSksIHIgJiYgbigpO1xuICB9KSwgdC5hdHRhY2hFdmVudChcIm9uR2FudHRSZWFkeVwiLCBpKSwgdC5hdHRhY2hFdmVudChcIm9uRGVzdHJveVwiLCBpKSwgdC5ldmVudCh3aW5kb3csIFwia2V5ZG93blwiLCBmdW5jdGlvbihhKSB7XG4gICAgYS5rZXlDb2RlID09PSAyNyAmJiB0LmV4dC5xdWlja0luZm8uaGlkZSgpO1xuICB9KSwgdC5zaG93UXVpY2tJbmZvID0gZnVuY3Rpb24oKSB7XG4gICAgdC5leHQucXVpY2tJbmZvLnNob3cuYXBwbHkodC5leHQucXVpY2tJbmZvLCBhcmd1bWVudHMpO1xuICB9LCB0LmhpZGVRdWlja0luZm8gPSBmdW5jdGlvbigpIHtcbiAgICB0LmV4dC5xdWlja0luZm8uaGlkZS5hcHBseSh0LmV4dC5xdWlja0luZm8sIGFyZ3VtZW50cyk7XG4gIH07XG59LCB0b29sdGlwOiBmdW5jdGlvbih0KSB7XG4gIHQuY29uZmlnLnRvb2x0aXBfdGltZW91dCA9IDMwLCB0LmNvbmZpZy50b29sdGlwX29mZnNldF95ID0gMjAsIHQuY29uZmlnLnRvb2x0aXBfb2Zmc2V0X3ggPSAxMCwgdC5jb25maWcudG9vbHRpcF9oaWRlX3RpbWVvdXQgPSAzMDtcbiAgY29uc3QgZSA9IG5ldyBXbih0KTtcbiAgdC5leHQudG9vbHRpcHMgPSBlLCB0LmF0dGFjaEV2ZW50KFwib25HYW50dFJlYWR5XCIsIGZ1bmN0aW9uKCkge1xuICAgIHQuJHJvb3QgJiYgZS50b29sdGlwRm9yKHsgc2VsZWN0b3I6IFwiW1wiICsgdC5jb25maWcudGFza19hdHRyaWJ1dGUgKyBcIl06bm90KC5nYW50dF90YXNrX3JvdylcIiwgaHRtbDogKG4pID0+IHtcbiAgICAgIGlmICh0LmNvbmZpZy50b3VjaCAmJiAhdC5jb25maWcudG91Y2hfdG9vbHRpcCkgcmV0dXJuO1xuICAgICAgY29uc3QgaSA9IHQubG9jYXRlKG4pO1xuICAgICAgaWYgKHQuaXNUYXNrRXhpc3RzKGkpKSB7XG4gICAgICAgIGNvbnN0IGEgPSB0LmdldFRhc2soaSk7XG4gICAgICAgIHJldHVybiB0LnRlbXBsYXRlcy50b29sdGlwX3RleHQoYS5zdGFydF9kYXRlLCBhLmVuZF9kYXRlLCBhKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sIGdsb2JhbDogITEgfSk7XG4gIH0pLCB0LmF0dGFjaEV2ZW50KFwib25EZXN0cm95XCIsIGZ1bmN0aW9uKCkge1xuICAgIGUuZGVzdHJ1Y3RvcigpO1xuICB9KSwgdC5hdHRhY2hFdmVudChcIm9uTGlnaHRib3hcIiwgZnVuY3Rpb24oKSB7XG4gICAgZS5oaWRlVG9vbHRpcCgpO1xuICB9KSwgdC5hdHRhY2hFdmVudChcIm9uQmVmb3JlVG9vbHRpcFwiLCBmdW5jdGlvbigpIHtcbiAgICBpZiAodC5nZXRTdGF0ZSgpLmxpbmtfc291cmNlX2lkKSByZXR1cm4gITE7XG4gIH0pLCB0LmF0dGFjaEV2ZW50KFwib25HYW50dFNjcm9sbFwiLCBmdW5jdGlvbigpIHtcbiAgICBlLmhpZGVUb29sdGlwKCk7XG4gIH0pO1xufSwgdW5kbzogZnVuY3Rpb24odCkge1xuICBjb25zdCBlID0gbmV3IEZuKHQpLCBuID0gbmV3IGpuKGUsIHQpO1xuICBmdW5jdGlvbiBpKGMsIHUpIHtcbiAgICByZXR1cm4gU3RyaW5nKGMpID09PSBTdHJpbmcodSk7XG4gIH1cbiAgZnVuY3Rpb24gYShjLCB1LCBoKSB7XG4gICAgYyAmJiAoaShjLmlkLCB1KSAmJiAoYy5pZCA9IGgpLCBpKGMucGFyZW50LCB1KSAmJiAoYy5wYXJlbnQgPSBoKSk7XG4gIH1cbiAgZnVuY3Rpb24gcihjLCB1LCBoKSB7XG4gICAgYShjLnZhbHVlLCB1LCBoKSwgYShjLm9sZFZhbHVlLCB1LCBoKTtcbiAgfVxuICBmdW5jdGlvbiBzKGMsIHUsIGgpIHtcbiAgICBjICYmIChpKGMuc291cmNlLCB1KSAmJiAoYy5zb3VyY2UgPSBoKSwgaShjLnRhcmdldCwgdSkgJiYgKGMudGFyZ2V0ID0gaCkpO1xuICB9XG4gIGZ1bmN0aW9uIG8oYywgdSwgaCkge1xuICAgIHMoYy52YWx1ZSwgdSwgaCksIHMoYy5vbGRWYWx1ZSwgdSwgaCk7XG4gIH1cbiAgZnVuY3Rpb24gbChjLCB1LCBoKSB7XG4gICAgY29uc3QgZyA9IGU7XG4gICAgZm9yIChsZXQgcCA9IDA7IHAgPCBjLmxlbmd0aDsgcCsrKSB7XG4gICAgICBjb25zdCB5ID0gY1twXTtcbiAgICAgIGZvciAobGV0IHYgPSAwOyB2IDwgeS5jb21tYW5kcy5sZW5ndGg7IHYrKykgeS5jb21tYW5kc1t2XS5lbnRpdHkgPT09IGcuY29tbWFuZC5lbnRpdHkudGFzayA/IHIoeS5jb21tYW5kc1t2XSwgdSwgaCkgOiB5LmNvbW1hbmRzW3ZdLmVudGl0eSA9PT0gZy5jb21tYW5kLmVudGl0eS5saW5rICYmIG8oeS5jb21tYW5kc1t2XSwgdSwgaCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGQoYywgdSwgaCkge1xuICAgIGNvbnN0IGcgPSBlO1xuICAgIGZvciAobGV0IHAgPSAwOyBwIDwgYy5sZW5ndGg7IHArKykge1xuICAgICAgY29uc3QgeSA9IGNbcF07XG4gICAgICBmb3IgKGxldCB2ID0gMDsgdiA8IHkuY29tbWFuZHMubGVuZ3RoOyB2KyspIHtcbiAgICAgICAgY29uc3QgYiA9IHkuY29tbWFuZHNbdl07XG4gICAgICAgIGIuZW50aXR5ID09PSBnLmNvbW1hbmQuZW50aXR5LmxpbmsgJiYgKGIudmFsdWUgJiYgYi52YWx1ZS5pZCA9PT0gdSAmJiAoYi52YWx1ZS5pZCA9IGgpLCBiLm9sZFZhbHVlICYmIGIub2xkVmFsdWUuaWQgPT09IHUgJiYgKGIub2xkVmFsdWUuaWQgPSBoKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHQuY29uZmlnLnVuZG8gPSAhMCwgdC5jb25maWcucmVkbyA9ICEwLCB0LmNvbmZpZy51bmRvX3R5cGVzID0geyBsaW5rOiBcImxpbmtcIiwgdGFzazogXCJ0YXNrXCIgfSwgdC5jb25maWcudW5kb19hY3Rpb25zID0geyB1cGRhdGU6IFwidXBkYXRlXCIsIHJlbW92ZTogXCJyZW1vdmVcIiwgYWRkOiBcImFkZFwiLCBtb3ZlOiBcIm1vdmVcIiB9LCB0LmV4dCB8fCAodC5leHQgPSB7fSksIHQuZXh0LnVuZG8gPSB7IHVuZG86ICgpID0+IGUudW5kbygpLCByZWRvOiAoKSA9PiBlLnJlZG8oKSwgZ2V0VW5kb1N0YWNrOiAoKSA9PiBlLmdldFVuZG9TdGFjaygpLCBzZXRVbmRvU3RhY2s6IChjKSA9PiBlLnNldFVuZG9TdGFjayhjKSwgZ2V0UmVkb1N0YWNrOiAoKSA9PiBlLmdldFJlZG9TdGFjaygpLCBzZXRSZWRvU3RhY2s6IChjKSA9PiBlLnNldFJlZG9TdGFjayhjKSwgY2xlYXJVbmRvU3RhY2s6ICgpID0+IGUuY2xlYXJVbmRvU3RhY2soKSwgY2xlYXJSZWRvU3RhY2s6ICgpID0+IGUuY2xlYXJSZWRvU3RhY2soKSwgc2F2ZVN0YXRlOiAoYywgdSkgPT4gbi5zdG9yZShjLCB1LCAhMCksIGdldEluaXRpYWxTdGF0ZTogKGMsIHUpID0+IHUgPT09IHQuY29uZmlnLnVuZG9fdHlwZXMubGluayA/IG4uZ2V0SW5pdGlhbExpbmsoYykgOiBuLmdldEluaXRpYWxUYXNrKGMpIH0sIHQudW5kbyA9IHQuZXh0LnVuZG8udW5kbywgdC5yZWRvID0gdC5leHQudW5kby5yZWRvLCB0LmdldFVuZG9TdGFjayA9IHQuZXh0LnVuZG8uZ2V0VW5kb1N0YWNrLCB0LmdldFJlZG9TdGFjayA9IHQuZXh0LnVuZG8uZ2V0UmVkb1N0YWNrLCB0LmNsZWFyVW5kb1N0YWNrID0gdC5leHQudW5kby5jbGVhclVuZG9TdGFjaywgdC5jbGVhclJlZG9TdGFjayA9IHQuZXh0LnVuZG8uY2xlYXJSZWRvU3RhY2ssIHQuYXR0YWNoRXZlbnQoXCJvblRhc2tJZENoYW5nZVwiLCAoYywgdSkgPT4ge1xuICAgIGNvbnN0IGggPSBlO1xuICAgIGwoaC5nZXRVbmRvU3RhY2soKSwgYywgdSksIGwoaC5nZXRSZWRvU3RhY2soKSwgYywgdSk7XG4gIH0pLCB0LmF0dGFjaEV2ZW50KFwib25MaW5rSWRDaGFuZ2VcIiwgKGMsIHUpID0+IHtcbiAgICBjb25zdCBoID0gZTtcbiAgICBkKGguZ2V0VW5kb1N0YWNrKCksIGMsIHUpLCBkKGguZ2V0UmVkb1N0YWNrKCksIGMsIHUpO1xuICB9KSwgdC5hdHRhY2hFdmVudChcIm9uR2FudHRSZWFkeVwiLCAoKSA9PiB7XG4gICAgZS51cGRhdGVDb25maWdzKCk7XG4gIH0pO1xufSwgbWFya2VyOiBmdW5jdGlvbih0KSB7XG4gIGZ1bmN0aW9uIGUoaSkge1xuICAgIGlmICghdC5jb25maWcuc2hvd19tYXJrZXJzIHx8ICFpLnN0YXJ0X2RhdGUpIHJldHVybiAhMTtcbiAgICB2YXIgYSA9IHQuZ2V0U3RhdGUoKTtcbiAgICBpZiAoK2kuc3RhcnRfZGF0ZSA+ICthLm1heF9kYXRlIHx8ICghaS5lbmRfZGF0ZSB8fCAraS5lbmRfZGF0ZSA8ICthLm1pbl9kYXRlKSAmJiAraS5zdGFydF9kYXRlIDwgK2EubWluX2RhdGUpIHJldHVybjtcbiAgICB2YXIgciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgci5zZXRBdHRyaWJ1dGUoXCJkYXRhLW1hcmtlci1pZFwiLCBpLmlkKTtcbiAgICB2YXIgcyA9IFwiZ2FudHRfbWFya2VyXCI7XG4gICAgdC50ZW1wbGF0ZXMubWFya2VyX2NsYXNzICYmIChzICs9IFwiIFwiICsgdC50ZW1wbGF0ZXMubWFya2VyX2NsYXNzKGkpKSwgaS5jc3MgJiYgKHMgKz0gXCIgXCIgKyBpLmNzcyksIHQudGVtcGxhdGVzLm1hcmtlcl9jbGFzcyAmJiAocyArPSBcIiBcIiArIHQudGVtcGxhdGVzLm1hcmtlcl9jbGFzcyhpKSksIGkudGl0bGUgJiYgKHIudGl0bGUgPSBpLnRpdGxlKSwgci5jbGFzc05hbWUgPSBzO1xuICAgIHZhciBvID0gdC5wb3NGcm9tRGF0ZShpLnN0YXJ0X2RhdGUpO1xuICAgIHIuc3R5bGUubGVmdCA9IG8gKyBcInB4XCI7XG4gICAgbGV0IGwgPSBNYXRoLm1heCh0LmdldFJvd1RvcCh0LmdldFZpc2libGVUYXNrQ291bnQoKSksIDApICsgXCJweFwiO1xuICAgIGlmICh0LmNvbmZpZy50aW1lbGluZV9wbGFjZWhvbGRlciAmJiB0LiR0YXNrX2RhdGEgJiYgKGwgPSB0LiR0YXNrX2RhdGEuc2Nyb2xsSGVpZ2h0ICsgXCJweFwiKSwgci5zdHlsZS5oZWlnaHQgPSBsLCBpLmVuZF9kYXRlKSB7XG4gICAgICB2YXIgZCA9IHQucG9zRnJvbURhdGUoaS5lbmRfZGF0ZSk7XG4gICAgICByLnN0eWxlLndpZHRoID0gTWF0aC5tYXgoZCAtIG8sIDApICsgXCJweFwiO1xuICAgIH1cbiAgICBpZiAoaS50ZXh0KSB7XG4gICAgICBsZXQgYyA9IG51bGw7XG4gICAgICBjID0gdHlwZW9mIGkudGV4dCA9PSBcImZ1bmN0aW9uXCIgPyBpLnRleHQoaSkgOiBpLnRleHQsIGMgJiYgKHQuY29uZmlnLmV4dGVybmFsX3JlbmRlciAmJiB0LmNvbmZpZy5leHRlcm5hbF9yZW5kZXIuaXNFbGVtZW50KGMpID8gKHIuaW5uZXJIVE1MID0gXCI8ZGl2IGNsYXNzPSdnYW50dF9tYXJrZXJfY29udGVudCcgPjwvZGl2PlwiLCB0LmNvbmZpZy5leHRlcm5hbF9yZW5kZXIucmVuZGVyRWxlbWVudChjLCByLnF1ZXJ5U2VsZWN0b3IoXCIuZ2FudHRfbWFya2VyX2NvbnRlbnRcIikpKSA6IHIuaW5uZXJIVE1MID0gXCI8ZGl2IGNsYXNzPSdnYW50dF9tYXJrZXJfY29udGVudCcgPlwiICsgaS50ZXh0ICsgXCI8L2Rpdj5cIik7XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9XG4gIGZ1bmN0aW9uIG4oKSB7XG4gICAgaWYgKHQuJHRhc2tfZGF0YSAmJiB0LiRyb290LmNvbnRhaW5zKHQuJHRhc2tfZGF0YSkpIHtcbiAgICAgIGlmICghdC4kbWFya2VyX2FyZWEgfHwgIXQuJHRhc2tfZGF0YS5jb250YWlucyh0LiRtYXJrZXJfYXJlYSkpIHtcbiAgICAgICAgdmFyIGkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBpLmNsYXNzTmFtZSA9IFwiZ2FudHRfbWFya2VyX2FyZWFcIiwgdC4kdGFza19kYXRhLmFwcGVuZENoaWxkKGkpLCB0LiRtYXJrZXJfYXJlYSA9IGk7XG4gICAgICB9XG4gICAgfSBlbHNlIHQuJG1hcmtlcl9hcmVhID0gbnVsbDtcbiAgfVxuICB0Ll9tYXJrZXJzIHx8ICh0Ll9tYXJrZXJzID0gdC5jcmVhdGVEYXRhc3RvcmUoeyBuYW1lOiBcIm1hcmtlclwiLCBpbml0SXRlbTogZnVuY3Rpb24oaSkge1xuICAgIHJldHVybiBpLmlkID0gaS5pZCB8fCB0LnVpZCgpLCBpO1xuICB9IH0pKSwgdC5jb25maWcuc2hvd19tYXJrZXJzID0gITAsIHQuYXR0YWNoRXZlbnQoXCJvbkJlZm9yZUdhbnR0UmVuZGVyXCIsIGZ1bmN0aW9uKCkge1xuICAgIHQuJG1hcmtlcl9hcmVhIHx8IG4oKTtcbiAgfSksIHQuYXR0YWNoRXZlbnQoXCJvbkRhdGFSZW5kZXJcIiwgZnVuY3Rpb24oKSB7XG4gICAgdC4kbWFya2VyX2FyZWEgfHwgKG4oKSwgdC5yZW5kZXJNYXJrZXJzKCkpO1xuICB9KSwgdC5hdHRhY2hFdmVudChcIm9uR2FudHRMYXlvdXRSZWFkeVwiLCBmdW5jdGlvbigpIHtcbiAgICB0LmF0dGFjaEV2ZW50KFwib25CZWZvcmVHYW50dFJlbmRlclwiLCBmdW5jdGlvbigpIHtcbiAgICAgIHQuJG1hcmtlcl9hcmVhICYmICh0LiRtYXJrZXJfYXJlYS5pbm5lckhUTUwgPSBcIlwiKSwgbigpLCB0LiRzZXJ2aWNlcy5nZXRTZXJ2aWNlKFwibGF5ZXJzXCIpLmNyZWF0ZURhdGFSZW5kZXIoeyBuYW1lOiBcIm1hcmtlclwiLCBkZWZhdWx0Q29udGFpbmVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHQuJG1hcmtlcl9hcmVhO1xuICAgICAgfSB9KS5hZGRMYXllcihlKTtcbiAgICB9LCB7IG9uY2U6ICEwIH0pO1xuICB9KSwgdC5nZXRNYXJrZXIgPSBmdW5jdGlvbihpKSB7XG4gICAgcmV0dXJuIHRoaXMuX21hcmtlcnMgPyB0aGlzLl9tYXJrZXJzLmdldEl0ZW0oaSkgOiBudWxsO1xuICB9LCB0LmFkZE1hcmtlciA9IGZ1bmN0aW9uKGkpIHtcbiAgICByZXR1cm4gdGhpcy5fbWFya2Vycy5hZGRJdGVtKGkpO1xuICB9LCB0LmRlbGV0ZU1hcmtlciA9IGZ1bmN0aW9uKGkpIHtcbiAgICByZXR1cm4gISF0aGlzLl9tYXJrZXJzLmV4aXN0cyhpKSAmJiAodGhpcy5fbWFya2Vycy5yZW1vdmVJdGVtKGkpLCAhMCk7XG4gIH0sIHQudXBkYXRlTWFya2VyID0gZnVuY3Rpb24oaSkge1xuICAgIHRoaXMuX21hcmtlcnMucmVmcmVzaChpKTtcbiAgfSwgdC5fZ2V0TWFya2VycyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9tYXJrZXJzLmdldEl0ZW1zKCk7XG4gIH0sIHQucmVuZGVyTWFya2VycyA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX21hcmtlcnMucmVmcmVzaCgpO1xuICB9O1xufSwgbXVsdGlzZWxlY3Q6IGZ1bmN0aW9uKHQpIHtcbiAgdC5jb25maWcubXVsdGlzZWxlY3QgPSAhMCwgdC5jb25maWcubXVsdGlzZWxlY3Rfb25lX2xldmVsID0gITEsIHQuX211bHRpc2VsZWN0ID0geyBfc2VsZWN0ZWQ6IHt9LCBfb25lX2xldmVsOiAhMSwgX2FjdGl2ZTogITAsIF9maXJzdF9zZWxlY3RlZF93aGVuX3NoaWZ0OiBudWxsLCBnZXREZWZhdWx0U2VsZWN0ZWQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBlID0gdGhpcy5nZXRTZWxlY3RlZCgpO1xuICAgIHJldHVybiBlLmxlbmd0aCA/IGVbZS5sZW5ndGggLSAxXSA6IG51bGw7XG4gIH0sIHNldEZpcnN0U2VsZWN0ZWQ6IGZ1bmN0aW9uKGUpIHtcbiAgICB0aGlzLl9maXJzdF9zZWxlY3RlZF93aGVuX3NoaWZ0ID0gZTtcbiAgfSwgZ2V0Rmlyc3RTZWxlY3RlZDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpcnN0X3NlbGVjdGVkX3doZW5fc2hpZnQ7XG4gIH0sIGlzQWN0aXZlOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy51cGRhdGVTdGF0ZSgpLCB0aGlzLl9hY3RpdmU7XG4gIH0sIHVwZGF0ZVN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9vbmVfbGV2ZWwgPSB0LmNvbmZpZy5tdWx0aXNlbGVjdF9vbmVfbGV2ZWw7XG4gICAgdmFyIGUgPSB0aGlzLl9hY3RpdmU7XG4gICAgdGhpcy5fYWN0aXZlID0gdC5jb25maWcuc2VsZWN0X3Rhc2ssIHRoaXMuX2FjdGl2ZSAhPSBlICYmIHRoaXMucmVzZXQoKTtcbiAgfSwgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3NlbGVjdGVkID0ge307XG4gIH0sIHNldExhc3RTZWxlY3RlZDogZnVuY3Rpb24oZSkge1xuICAgIHQuJGRhdGEudGFza3NTdG9yZS5zaWxlbnQoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbiA9IHQuJGRhdGEudGFza3NTdG9yZTtcbiAgICAgIGUgPyBuLnNlbGVjdChlICsgXCJcIikgOiBuLnVuc2VsZWN0KG51bGwpO1xuICAgIH0pO1xuICB9LCBnZXRMYXN0U2VsZWN0ZWQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBlID0gdC4kZGF0YS50YXNrc1N0b3JlLmdldFNlbGVjdGVkSWQoKTtcbiAgICByZXR1cm4gZSAmJiB0LmlzVGFza0V4aXN0cyhlKSA/IGUgOiBudWxsO1xuICB9LCBzZWxlY3Q6IGZ1bmN0aW9uKGUsIG4pIHtcbiAgICByZXR1cm4gISEoZSAmJiB0LmNhbGxFdmVudChcIm9uQmVmb3JlVGFza011bHRpU2VsZWN0XCIsIFtlLCAhMCwgbl0pICYmIHQuY2FsbEV2ZW50KFwib25CZWZvcmVUYXNrU2VsZWN0ZWRcIiwgW2VdKSkgJiYgKHRoaXMuX3NlbGVjdGVkW2VdID0gITAsIHRoaXMuc2V0TGFzdFNlbGVjdGVkKGUpLCB0aGlzLmFmdGVyU2VsZWN0KGUpLCB0LmNhbGxFdmVudChcIm9uVGFza011bHRpU2VsZWN0XCIsIFtlLCAhMCwgbl0pLCB0LmNhbGxFdmVudChcIm9uVGFza1NlbGVjdGVkXCIsIFtlXSksICEwKTtcbiAgfSwgdG9nZ2xlOiBmdW5jdGlvbihlLCBuKSB7XG4gICAgdGhpcy5fc2VsZWN0ZWRbZV0gPyB0aGlzLnVuc2VsZWN0KGUsIG4pIDogdGhpcy5zZWxlY3QoZSwgbik7XG4gIH0sIHVuc2VsZWN0OiBmdW5jdGlvbihlLCBuKSB7XG4gICAgZSAmJiB0LmNhbGxFdmVudChcIm9uQmVmb3JlVGFza011bHRpU2VsZWN0XCIsIFtlLCAhMSwgbl0pICYmICh0aGlzLl9zZWxlY3RlZFtlXSA9ICExLCB0aGlzLmdldExhc3RTZWxlY3RlZCgpID09IGUgJiYgdGhpcy5zZXRMYXN0U2VsZWN0ZWQodGhpcy5nZXREZWZhdWx0U2VsZWN0ZWQoKSksIHRoaXMuYWZ0ZXJTZWxlY3QoZSksIHQuY2FsbEV2ZW50KFwib25UYXNrTXVsdGlTZWxlY3RcIiwgW2UsICExLCBuXSksIHQuY2FsbEV2ZW50KFwib25UYXNrVW5zZWxlY3RlZFwiLCBbZV0pKTtcbiAgfSwgaXNTZWxlY3RlZDogZnVuY3Rpb24oZSkge1xuICAgIHJldHVybiAhKCF0LmlzVGFza0V4aXN0cyhlKSB8fCAhdGhpcy5fc2VsZWN0ZWRbZV0pO1xuICB9LCBnZXRTZWxlY3RlZDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGUgPSBbXTtcbiAgICBmb3IgKHZhciBuIGluIHRoaXMuX3NlbGVjdGVkKSB0aGlzLl9zZWxlY3RlZFtuXSAmJiB0LmlzVGFza0V4aXN0cyhuKSA/IGUucHVzaChuKSA6IHRoaXMuX3NlbGVjdGVkW25dID0gITE7XG4gICAgcmV0dXJuIGUuc29ydChmdW5jdGlvbihpLCBhKSB7XG4gICAgICByZXR1cm4gdC5nZXRHbG9iYWxUYXNrSW5kZXgoaSkgPiB0LmdldEdsb2JhbFRhc2tJbmRleChhKSA/IDEgOiAtMTtcbiAgICB9KSwgZTtcbiAgfSwgZm9yU2VsZWN0ZWQ6IGZ1bmN0aW9uKGUpIHtcbiAgICBmb3IgKHZhciBuID0gdGhpcy5nZXRTZWxlY3RlZCgpLCBpID0gMDsgaSA8IG4ubGVuZ3RoOyBpKyspIGUobltpXSk7XG4gIH0sIGlzU2FtZUxldmVsOiBmdW5jdGlvbihlKSB7XG4gICAgaWYgKCF0aGlzLl9vbmVfbGV2ZWwpIHJldHVybiAhMDtcbiAgICB2YXIgbiA9IHRoaXMuZ2V0TGFzdFNlbGVjdGVkKCk7XG4gICAgcmV0dXJuICFuIHx8ICF0LmlzVGFza0V4aXN0cyhuKSB8fCAhdC5pc1Rhc2tFeGlzdHMoZSkgfHwgdC5jYWxjdWxhdGVUYXNrTGV2ZWwodC5nZXRUYXNrKG4pKSA9PSB0LmNhbGN1bGF0ZVRhc2tMZXZlbCh0LmdldFRhc2soZSkpO1xuICB9LCBhZnRlclNlbGVjdDogZnVuY3Rpb24oZSkge1xuICAgIHQuaXNUYXNrRXhpc3RzKGUpICYmIHQuX3F1aWNrUmVmcmVzaChmdW5jdGlvbigpIHtcbiAgICAgIHQucmVmcmVzaFRhc2soZSk7XG4gICAgfSk7XG4gIH0sIGRvU2VsZWN0aW9uOiBmdW5jdGlvbihlKSB7XG4gICAgaWYgKCF0aGlzLmlzQWN0aXZlKCkgfHwgdC5faXNfaWNvbl9vcGVuX2NsaWNrKGUpKSByZXR1cm4gITE7XG4gICAgdmFyIG4gPSB0LmxvY2F0ZShlKTtcbiAgICBpZiAoIW4gfHwgIXQuY2FsbEV2ZW50KFwib25CZWZvcmVNdWx0aVNlbGVjdFwiLCBbZV0pKSByZXR1cm4gITE7XG4gICAgdmFyIGkgPSB0aGlzLmdldFNlbGVjdGVkKCksIGEgPSB0aGlzLmdldEZpcnN0U2VsZWN0ZWQoKSwgciA9ICExLCBzID0gdGhpcy5nZXRMYXN0U2VsZWN0ZWQoKSwgbyA9IHQuY29uZmlnLm11bHRpc2VsZWN0LCBsID0gKGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgYyA9IHQuZXh0LmlubGluZUVkaXRvcnM7XG4gICAgICBpZiAoYyAmJiBjLmdldFN0YXRlKSB7XG4gICAgICAgIGNvbnN0IGggPSBjLmdldFN0YXRlKCksIGcgPSBjLmxvY2F0ZUNlbGwoZS50YXJnZXQpO1xuICAgICAgICB0LmNvbmZpZy5pbmxpbmVfZWRpdG9yc19tdWx0aXNlbGVjdF9vcGVuICYmIGcgJiYgYy5nZXRFZGl0b3JDb25maWcoZy5jb2x1bW5OYW1lKSAmJiAoYy5pc1Zpc2libGUoKSAmJiBoLmlkID09IGcuaWQgJiYgaC5jb2x1bW5OYW1lID09IGcuY29sdW1uTmFtZSB8fCBjLnN0YXJ0RWRpdChnLmlkLCBnLmNvbHVtbk5hbWUpKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0Rmlyc3RTZWxlY3RlZChuKSwgdGhpcy5pc1NlbGVjdGVkKG4pIHx8IHRoaXMuc2VsZWN0KG4sIGUpLCBpID0gdGhpcy5nZXRTZWxlY3RlZCgpO1xuICAgICAgZm9yICh2YXIgdSA9IDA7IHUgPCBpLmxlbmd0aDsgdSsrKSBpW3VdICE9PSBuICYmIHRoaXMudW5zZWxlY3QoaVt1XSwgZSk7XG4gICAgfSkuYmluZCh0aGlzKSwgZCA9IChmdW5jdGlvbigpIHtcbiAgICAgIGlmIChzKSB7XG4gICAgICAgIGlmIChuKSB7XG4gICAgICAgICAgdmFyIGMgPSB0LmdldEdsb2JhbFRhc2tJbmRleCh0aGlzLmdldEZpcnN0U2VsZWN0ZWQoKSksIHUgPSB0LmdldEdsb2JhbFRhc2tJbmRleChuKSwgaCA9IHQuZ2V0R2xvYmFsVGFza0luZGV4KHMpO1xuICAgICAgICAgIGMgIT0gLTEgJiYgaCAhPSAtMSB8fCAoYyA9IHUsIHRoaXMucmVzZXQoKSk7XG4gICAgICAgICAgZm9yICh2YXIgZyA9IHM7IHQuZ2V0R2xvYmFsVGFza0luZGV4KGcpICE9PSBjOyApIHRoaXMudW5zZWxlY3QoZywgZSksIGcgPSBjID4gaCA/IHQuZ2V0TmV4dChnKSA6IHQuZ2V0UHJldihnKTtcbiAgICAgICAgICBmb3IgKGcgPSBuOyB0LmdldEdsb2JhbFRhc2tJbmRleChnKSAhPT0gYzsgKSB0aGlzLnNlbGVjdChnLCBlKSAmJiAhciAmJiAociA9ICEwLCBhID0gZyksIGcgPSBjID4gdSA/IHQuZ2V0TmV4dChnKSA6IHQuZ2V0UHJldihnKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHMgPSBuO1xuICAgIH0pLmJpbmQodGhpcyk7XG4gICAgcmV0dXJuIG8gJiYgKGUuY3RybEtleSB8fCBlLm1ldGFLZXkpID8gKHRoaXMuaXNTZWxlY3RlZChuKSB8fCB0aGlzLnNldEZpcnN0U2VsZWN0ZWQobiksIG4gJiYgdGhpcy50b2dnbGUobiwgZSkpIDogbyAmJiBlLnNoaWZ0S2V5ID8gKHQuaXNUYXNrRXhpc3RzKHRoaXMuZ2V0Rmlyc3RTZWxlY3RlZCgpKSAmJiB0aGlzLmdldEZpcnN0U2VsZWN0ZWQoKSAhPT0gbnVsbCB8fCB0aGlzLnNldEZpcnN0U2VsZWN0ZWQobiksIGkubGVuZ3RoID8gZCgpIDogbCgpKSA6IGwoKSwgdGhpcy5pc1NlbGVjdGVkKG4pID8gdGhpcy5zZXRMYXN0U2VsZWN0ZWQobikgOiBhID8gbiA9PSBzICYmIHRoaXMuc2V0TGFzdFNlbGVjdGVkKGUuc2hpZnRLZXkgPyBhIDogdGhpcy5nZXREZWZhdWx0U2VsZWN0ZWQoKSkgOiB0aGlzLnNldExhc3RTZWxlY3RlZChudWxsKSwgdGhpcy5nZXRTZWxlY3RlZCgpLmxlbmd0aCB8fCB0aGlzLnNldExhc3RTZWxlY3RlZChudWxsKSwgdGhpcy5nZXRMYXN0U2VsZWN0ZWQoKSAmJiB0aGlzLmlzU2VsZWN0ZWQodGhpcy5nZXRGaXJzdFNlbGVjdGVkKCkpIHx8IHRoaXMuc2V0Rmlyc3RTZWxlY3RlZCh0aGlzLmdldExhc3RTZWxlY3RlZCgpKSwgITA7XG4gIH0gfSwgZnVuY3Rpb24oKSB7XG4gICAgdmFyIGUgPSB0LnNlbGVjdFRhc2s7XG4gICAgdC5zZWxlY3RUYXNrID0gZnVuY3Rpb24oaSkge1xuICAgICAgaWYgKCEoaSA9IGF0KGksIHRoaXMuY29uZmlnLnJvb3RfaWQpKSkgcmV0dXJuICExO1xuICAgICAgdmFyIGEgPSB0Ll9tdWx0aXNlbGVjdCwgciA9IGk7XG4gICAgICByZXR1cm4gYS5pc0FjdGl2ZSgpID8gKGEuc2VsZWN0KGksIG51bGwpICYmIGEuc2V0TGFzdFNlbGVjdGVkKGkpLCBhLnNldEZpcnN0U2VsZWN0ZWQoYS5nZXRMYXN0U2VsZWN0ZWQoKSkpIDogciA9IGUuY2FsbCh0aGlzLCBpKSwgcjtcbiAgICB9O1xuICAgIHZhciBuID0gdC51bnNlbGVjdFRhc2s7XG4gICAgdC51bnNlbGVjdFRhc2sgPSBmdW5jdGlvbihpKSB7XG4gICAgICB2YXIgYSA9IHQuX211bHRpc2VsZWN0LCByID0gYS5pc0FjdGl2ZSgpO1xuICAgICAgKGkgPSBpIHx8IGEuZ2V0TGFzdFNlbGVjdGVkKCkpICYmIHIgJiYgKGEudW5zZWxlY3QoaSwgbnVsbCksIGkgPT0gYS5nZXRMYXN0U2VsZWN0ZWQoKSAmJiBhLnNldExhc3RTZWxlY3RlZChudWxsKSwgdC5yZWZyZXNoVGFzayhpKSwgYS5zZXRGaXJzdFNlbGVjdGVkKGEuZ2V0TGFzdFNlbGVjdGVkKCkpKTtcbiAgICAgIHZhciBzID0gaTtcbiAgICAgIHJldHVybiByIHx8IChzID0gbi5jYWxsKHRoaXMsIGkpKSwgcztcbiAgICB9LCB0LnRvZ2dsZVRhc2tTZWxlY3Rpb24gPSBmdW5jdGlvbihpKSB7XG4gICAgICB2YXIgYSA9IHQuX211bHRpc2VsZWN0O1xuICAgICAgaSAmJiBhLmlzQWN0aXZlKCkgJiYgKGEudG9nZ2xlKGkpLCBhLnNldEZpcnN0U2VsZWN0ZWQoYS5nZXRMYXN0U2VsZWN0ZWQoKSkpO1xuICAgIH0sIHQuZ2V0U2VsZWN0ZWRUYXNrcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGkgPSB0Ll9tdWx0aXNlbGVjdDtcbiAgICAgIHJldHVybiBpLmlzQWN0aXZlKCksIGkuZ2V0U2VsZWN0ZWQoKTtcbiAgICB9LCB0LmVhY2hTZWxlY3RlZFRhc2sgPSBmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbXVsdGlzZWxlY3QuZm9yU2VsZWN0ZWQoaSk7XG4gICAgfSwgdC5pc1NlbGVjdGVkVGFzayA9IGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9tdWx0aXNlbGVjdC5pc1NlbGVjdGVkKGkpO1xuICAgIH0sIHQuZ2V0TGFzdFNlbGVjdGVkVGFzayA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX211bHRpc2VsZWN0LmdldExhc3RTZWxlY3RlZCgpO1xuICAgIH0sIHQuYXR0YWNoRXZlbnQoXCJvbkdhbnR0UmVhZHlcIiwgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaSA9IHQuJGRhdGEudGFza3NTdG9yZS5pc1NlbGVjdGVkO1xuICAgICAgdC4kZGF0YS50YXNrc1N0b3JlLmlzU2VsZWN0ZWQgPSBmdW5jdGlvbihhKSB7XG4gICAgICAgIHJldHVybiB0Ll9tdWx0aXNlbGVjdC5pc0FjdGl2ZSgpID8gdC5fbXVsdGlzZWxlY3QuaXNTZWxlY3RlZChhKSA6IGkuY2FsbCh0aGlzLCBhKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH0oKSwgdC5hdHRhY2hFdmVudChcIm9uVGFza0lkQ2hhbmdlXCIsIGZ1bmN0aW9uKGUsIG4pIHtcbiAgICB2YXIgaSA9IHQuX211bHRpc2VsZWN0O1xuICAgIGlmICghaS5pc0FjdGl2ZSgpKSByZXR1cm4gITA7XG4gICAgdC5pc1NlbGVjdGVkVGFzayhlKSAmJiAoaS51bnNlbGVjdChlLCBudWxsKSwgaS5zZWxlY3QobiwgbnVsbCkpO1xuICB9KSwgdC5hdHRhY2hFdmVudChcIm9uQWZ0ZXJUYXNrRGVsZXRlXCIsIGZ1bmN0aW9uKGUsIG4pIHtcbiAgICB2YXIgaSA9IHQuX211bHRpc2VsZWN0O1xuICAgIGlmICghaS5pc0FjdGl2ZSgpKSByZXR1cm4gITA7XG4gICAgaS5fc2VsZWN0ZWRbZV0gJiYgKGkuX3NlbGVjdGVkW2VdID0gITEsIGkuc2V0TGFzdFNlbGVjdGVkKGkuZ2V0RGVmYXVsdFNlbGVjdGVkKCkpKSwgaS5mb3JTZWxlY3RlZChmdW5jdGlvbihhKSB7XG4gICAgICB0LmlzVGFza0V4aXN0cyhhKSB8fCBpLnVuc2VsZWN0KGEsIG51bGwpO1xuICAgIH0pO1xuICB9KSwgdC5hdHRhY2hFdmVudChcIm9uQmVmb3JlVGFza011bHRpU2VsZWN0XCIsIGZ1bmN0aW9uKGUsIG4sIGkpIHtcbiAgICBjb25zdCBhID0gdC5fbXVsdGlzZWxlY3Q7XG4gICAgaWYgKG4gJiYgYS5pc0FjdGl2ZSgpKSB7XG4gICAgICBsZXQgciA9IHQuZ2V0U2VsZWN0ZWRJZCgpLCBzID0gbnVsbDtcbiAgICAgIHIgJiYgKHMgPSB0LmdldFRhc2socikpO1xuICAgICAgbGV0IG8gPSB0LmdldFRhc2soZSksIGwgPSAhMTtcbiAgICAgIGlmIChzICYmIHMuJGxldmVsICE9IG8uJGxldmVsICYmIChsID0gITApLCB0LmNvbmZpZy5tdWx0aXNlbGVjdF9vbmVfbGV2ZWwgJiYgbCAmJiAhaS5jdHJsS2V5ICYmICFpLnNoaWZ0S2V5KSByZXR1cm4gITA7XG4gICAgICBpZiAoYS5fb25lX2xldmVsKSByZXR1cm4gYS5pc1NhbWVMZXZlbChlKTtcbiAgICB9XG4gICAgcmV0dXJuICEwO1xuICB9KSwgdC5hdHRhY2hFdmVudChcIm9uVGFza0NsaWNrXCIsIGZ1bmN0aW9uKGUsIG4pIHtcbiAgICByZXR1cm4gdC5fbXVsdGlzZWxlY3QuZG9TZWxlY3Rpb24obikgJiYgdC5jYWxsRXZlbnQoXCJvbk11bHRpU2VsZWN0XCIsIFtuXSksICEwO1xuICB9KTtcbn0sIGV4cG9ydF9hcGk6IGZ1bmN0aW9uKHQpIHtcbiAgcmV0dXJuIHQuZXh0ID0gdC5leHQgfHwge30sIHQuZXh0LmV4cG9ydF9hcGkgPSB0LmV4dC5leHBvcnRfYXBpIHx8IHsgX2FwaVVybDogXCJodHRwczovL2V4cG9ydC5kaHRtbHguY29tL2dhbnR0XCIsIF9wcmVwYXJlUERGQ29uZmlnUmF3KGUsIG4pIHtcbiAgICBsZXQgaSA9IG51bGw7XG4gICAgZS5zdGFydCAmJiBlLmVuZCAmJiAoaSA9IHsgc3RhcnRfZGF0ZTogdC5jb25maWcuc3RhcnRfZGF0ZSwgZW5kX2RhdGU6IHQuY29uZmlnLmVuZF9kYXRlIH0sIHQuY29uZmlnLnN0YXJ0X2RhdGUgPSB0LmRhdGUuc3RyX3RvX2RhdGUodC5jb25maWcuZGF0ZV9mb3JtYXQpKGUuc3RhcnQpLCB0LmNvbmZpZy5lbmRfZGF0ZSA9IHQuZGF0ZS5zdHJfdG9fZGF0ZSh0LmNvbmZpZy5kYXRlX2Zvcm1hdCkoZS5lbmQpKSwgZSA9IHQubWl4aW4oZSwgeyBuYW1lOiBcImdhbnR0LlwiICsgbiwgZGF0YTogdC5leHQuZXhwb3J0X2FwaS5fc2VyaWFsaXplSHRtbCgpIH0pLCBpICYmICh0LmNvbmZpZy5zdGFydF9kYXRlID0gaS5zdGFydF9kYXRlLCB0LmNvbmZpZy5lbmRfZGF0ZSA9IGkuZW5kX2RhdGUpO1xuICB9LCBfcHJlcGFyZUNvbmZpZ1BERjogKGUsIG4pID0+IChlID0gdC5taXhpbihlIHx8IHt9LCB7IG5hbWU6IFwiZ2FudHQuXCIgKyBuLCBkYXRhOiB0LmV4dC5leHBvcnRfYXBpLl9zZXJpYWxpemVBbGwoKSwgY29uZmlnOiB0LmNvbmZpZyB9KSwgdC5leHQuZXhwb3J0X2FwaS5fZml4Q29sdW1ucyhlLmNvbmZpZy5jb2x1bW5zKSwgZSksIF9wZGZFeHBvcnRSb3V0ZXIoZSwgbikge1xuICAgIGUgJiYgZS5yYXcgPyB0LmV4dC5leHBvcnRfYXBpLl9wcmVwYXJlUERGQ29uZmlnUmF3KGUsIG4pIDogZSA9IHQuZXh0LmV4cG9ydF9hcGkuX3ByZXBhcmVDb25maWdQREYoZSwgbiksIGUudmVyc2lvbiA9IHQudmVyc2lvbiwgdC5leHQuZXhwb3J0X2FwaS5fc2VuZFRvRXhwb3J0KGUsIG4pO1xuICB9LCBleHBvcnRUb1BERihlKSB7XG4gICAgdC5leHQuZXhwb3J0X2FwaS5fcGRmRXhwb3J0Um91dGVyKGUsIFwicGRmXCIpO1xuICB9LCBleHBvcnRUb1BORyhlKSB7XG4gICAgdC5leHQuZXhwb3J0X2FwaS5fcGRmRXhwb3J0Um91dGVyKGUsIFwicG5nXCIpO1xuICB9LCBleHBvcnRUb0lDYWwoZSkge1xuICAgIGUgPSB0Lm1peGluKGUgfHwge30sIHsgbmFtZTogXCJnYW50dC5pY2FsXCIsIGRhdGE6IHQuZXh0LmV4cG9ydF9hcGkuX3NlcmlhbGl6ZVBsYWluKCkuZGF0YSwgdmVyc2lvbjogdC52ZXJzaW9uIH0pLCB0LmV4dC5leHBvcnRfYXBpLl9zZW5kVG9FeHBvcnQoZSwgXCJpY2FsXCIpO1xuICB9LCBleHBvcnRUb0V4Y2VsKGUpIHtcbiAgICBsZXQgbiwgaSwgYSwgcjtcbiAgICBlID0gZSB8fCB7fTtcbiAgICBjb25zdCBzID0gdC5jb25maWcuc21hcnRfcmVuZGVyaW5nO1xuICAgIGlmIChlLnZpc3VhbCA9PT0gXCJiYXNlLWNvbG9yc1wiICYmICh0LmNvbmZpZy5zbWFydF9yZW5kZXJpbmcgPSAhMSksIGUuc3RhcnQgfHwgZS5lbmQpIHtcbiAgICAgIGEgPSB0LmdldFN0YXRlKCksIGkgPSBbdC5jb25maWcuc3RhcnRfZGF0ZSwgdC5jb25maWcuZW5kX2RhdGVdLCByID0gdC5nZXRTY3JvbGxTdGF0ZSgpO1xuICAgICAgY29uc3QgbyA9IHQuZGF0ZS5zdHJfdG9fZGF0ZSh0LmNvbmZpZy5kYXRlX2Zvcm1hdCk7XG4gICAgICBuID0gdC5lYWNoVGFzaywgZS5zdGFydCAmJiAodC5jb25maWcuc3RhcnRfZGF0ZSA9IG8oZS5zdGFydCkpLCBlLmVuZCAmJiAodC5jb25maWcuZW5kX2RhdGUgPSBvKGUuZW5kKSksIHQucmVuZGVyKCksIHQuY29uZmlnLnNtYXJ0X3JlbmRlcmluZyA9IHMsIHQuZWFjaFRhc2sgPSB0LmV4dC5leHBvcnRfYXBpLl9lYWNoVGFza1RpbWVkKHQuY29uZmlnLnN0YXJ0X2RhdGUsIHQuY29uZmlnLmVuZF9kYXRlKTtcbiAgICB9IGVsc2UgZS52aXN1YWwgPT09IFwiYmFzZS1jb2xvcnNcIiAmJiAodC5yZW5kZXIoKSwgdC5jb25maWcuc21hcnRfcmVuZGVyaW5nID0gcyk7XG4gICAgdC5fbm9fcHJvZ3Jlc3NfY29sb3JzID0gZS52aXN1YWwgPT09IFwiYmFzZS1jb2xvcnNcIiwgKGUgPSB0Lm1peGluKGUsIHsgbmFtZTogXCJnYW50dC54bHN4XCIsIHRpdGxlOiBcIlRhc2tzXCIsIGRhdGE6IHQuZXh0LmV4cG9ydF9hcGkuX3NlcmlhbGl6ZVRpbWVsaW5lKGUpLmRhdGEsIGNvbHVtbnM6IHQuZXh0LmV4cG9ydF9hcGkuX3NlcmlhbGl6ZUdyaWQoeyByYXdEYXRlczogITAgfSksIHZlcnNpb246IHQudmVyc2lvbiB9KSkudmlzdWFsICYmIChlLnNjYWxlcyA9IHQuZXh0LmV4cG9ydF9hcGkuX3NlcmlhbGl6ZVNjYWxlcyhlKSksIHQuZXh0LmV4cG9ydF9hcGkuX3NlbmRUb0V4cG9ydChlLCBcImV4Y2VsXCIpLCAoZS5zdGFydCB8fCBlLmVuZCkgJiYgKHQuY29uZmlnLnN0YXJ0X2RhdGUgPSBhLm1pbl9kYXRlLCB0LmNvbmZpZy5lbmRfZGF0ZSA9IGEubWF4X2RhdGUsIHQuZWFjaFRhc2sgPSBuLCB0LnJlbmRlcigpLCB0LnNjcm9sbFRvKHIueCwgci55KSwgdC5jb25maWcuc3RhcnRfZGF0ZSA9IGlbMF0sIHQuY29uZmlnLmVuZF9kYXRlID0gaVsxXSk7XG4gIH0sIGV4cG9ydFRvSlNPTihlKSB7XG4gICAgZSA9IHQubWl4aW4oZSB8fCB7fSwgeyBuYW1lOiBcImdhbnR0Lmpzb25cIiwgZGF0YTogdC5leHQuZXhwb3J0X2FwaS5fc2VyaWFsaXplQWxsKCksIGNvbmZpZzogdC5jb25maWcsIGNvbHVtbnM6IHQuZXh0LmV4cG9ydF9hcGkuX3NlcmlhbGl6ZUdyaWQoKSwgd29ya3RpbWU6IHQuZXh0LmV4cG9ydF9hcGkuX2dldFdvcmt0aW1lU2V0dGluZ3MoKSwgdmVyc2lvbjogdC52ZXJzaW9uIH0pLCB0LmV4dC5leHBvcnRfYXBpLl9zZW5kVG9FeHBvcnQoZSwgXCJqc29uXCIpO1xuICB9LCBpbXBvcnRGcm9tRXhjZWwoZSkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBuID0gZS5kYXRhO1xuICAgICAgaWYgKG4gaW5zdGFuY2VvZiBGaWxlKSB7XG4gICAgICAgIGNvbnN0IGkgPSBuZXcgRm9ybURhdGEoKTtcbiAgICAgICAgaS5hcHBlbmQoXCJmaWxlXCIsIG4pLCBlLmRhdGEgPSBpO1xuICAgICAgfVxuICAgIH0gY2F0Y2gge1xuICAgIH1cbiAgICB0LmV4dC5leHBvcnRfYXBpLl9zZW5kSW1wb3J0QWpheEV4Y2VsKGUpO1xuICB9LCBpbXBvcnRGcm9tTVNQcm9qZWN0KGUpIHtcbiAgICBjb25zdCBuID0gZS5kYXRhO1xuICAgIHRyeSB7XG4gICAgICBpZiAobiBpbnN0YW5jZW9mIEZpbGUpIHtcbiAgICAgICAgY29uc3QgaSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgICAgICBpLmFwcGVuZChcImZpbGVcIiwgbiksIGUuZGF0YSA9IGk7XG4gICAgICB9XG4gICAgfSBjYXRjaCB7XG4gICAgfVxuICAgIHQuZXh0LmV4cG9ydF9hcGkuX3NlbmRJbXBvcnRBamF4TVNQKGUpO1xuICB9LCBpbXBvcnRGcm9tUHJpbWF2ZXJhUDY6IChlKSA9PiAoZS50eXBlID0gXCJwcmltYXZlcmFQNi1wYXJzZVwiLCB0LmltcG9ydEZyb21NU1Byb2plY3QoZSkpLCBleHBvcnRUb01TUHJvamVjdChlKSB7XG4gICAgKGUgPSBlIHx8IHt9KS5za2lwX2NpcmN1bGFyX2xpbmtzID0gZS5za2lwX2NpcmN1bGFyX2xpbmtzID09PSB2b2lkIDAgfHwgISFlLnNraXBfY2lyY3VsYXJfbGlua3M7XG4gICAgY29uc3QgbiA9IHQudGVtcGxhdGVzLnhtbF9mb3JtYXQsIGkgPSB0LnRlbXBsYXRlcy5mb3JtYXRfZGF0ZSwgYSA9IHQuY29uZmlnLnhtbF9kYXRlLCByID0gdC5jb25maWcuZGF0ZV9mb3JtYXQsIHMgPSBcIiVkLSVtLSVZICVIOiVpOiVzXCI7XG4gICAgdC5jb25maWcueG1sX2RhdGUgPSBzLCB0LmNvbmZpZy5kYXRlX2Zvcm1hdCA9IHMsIHQudGVtcGxhdGVzLnhtbF9mb3JtYXQgPSB0LmRhdGUuZGF0ZV90b19zdHIocyksIHQudGVtcGxhdGVzLmZvcm1hdF9kYXRlID0gdC5kYXRlLmRhdGVfdG9fc3RyKHMpO1xuICAgIGNvbnN0IG8gPSB0LmV4dC5leHBvcnRfYXBpLl9zZXJpYWxpemVBbGwoKTtcbiAgICB0LmV4dC5leHBvcnRfYXBpLl9jdXN0b21Qcm9qZWN0UHJvcGVydGllcyhvLCBlKSwgdC5leHQuZXhwb3J0X2FwaS5fY3VzdG9tVGFza1Byb3BlcnRpZXMobywgZSksIGUuc2tpcF9jaXJjdWxhcl9saW5rcyAmJiB0LmV4dC5leHBvcnRfYXBpLl9jbGVhclJlY0xpbmtzKG8pLCBlID0gdC5leHQuZXhwb3J0X2FwaS5fZXhwb3J0Q29uZmlnKG8sIGUpLCB0LmV4dC5leHBvcnRfYXBpLl9zZW5kVG9FeHBvcnQoZSwgZS50eXBlIHx8IFwibXNwcm9qZWN0XCIpLCB0LmNvbmZpZy54bWxfZGF0ZSA9IGEsIHQuY29uZmlnLmRhdGVfZm9ybWF0ID0gciwgdC50ZW1wbGF0ZXMueG1sX2Zvcm1hdCA9IG4sIHQudGVtcGxhdGVzLmZvcm1hdF9kYXRlID0gaSwgdC5jb25maWcuJGN1c3RvbV9kYXRhID0gbnVsbCwgdC5jb25maWcuY3VzdG9tID0gbnVsbDtcbiAgfSwgZXhwb3J0VG9QcmltYXZlcmFQNjogKGUpID0+ICgoZSA9IGUgfHwge30pLnR5cGUgPSBcInByaW1hdmVyYVA2XCIsIHQuZXhwb3J0VG9NU1Byb2plY3QoZSkpLCBfZml4Q29sdW1ucyhlKSB7XG4gICAgZm9yIChsZXQgbiA9IDA7IG4gPCBlLmxlbmd0aDsgbisrKSBlW25dLmxhYmVsID0gZVtuXS5sYWJlbCB8fCB0LmxvY2FsZS5sYWJlbHNbXCJjb2x1bW5fXCIgKyBlW25dLm5hbWVdLCB0eXBlb2YgZVtuXS53aWR0aCA9PSBcInN0cmluZ1wiICYmIChlW25dLndpZHRoID0gMSAqIGVbbl0ud2lkdGgpO1xuICB9LCBfeGRyKGUsIG4sIGkpIHtcbiAgICB0LmFqYXgucG9zdChlLCBuLCBpKTtcbiAgfSwgX21hcmtDb2x1bW5zKGUpIHtcbiAgICBjb25zdCBuID0gZS5jb25maWcuY29sdW1ucztcbiAgICBpZiAobikgZm9yIChsZXQgaSA9IDA7IGkgPCBuLmxlbmd0aDsgaSsrKSBuW2ldLnRlbXBsYXRlICYmIChuW2ldLiR0ZW1wbGF0ZSA9ICEwKTtcbiAgfSwgX3NlbmRJbXBvcnRBamF4RXhjZWwoZSkge1xuICAgIGNvbnN0IG4gPSBlLnNlcnZlciB8fCB0LmV4dC5leHBvcnRfYXBpLl9hcGlVcmwsIGkgPSBlLnN0b3JlIHx8IDAsIGEgPSBlLmRhdGEsIHIgPSBlLmNhbGxiYWNrO1xuICAgIGEuYXBwZW5kKFwidHlwZVwiLCBcImV4Y2VsLXBhcnNlXCIpLCBhLmFwcGVuZChcImRhdGFcIiwgSlNPTi5zdHJpbmdpZnkoeyBzaGVldDogZS5zaGVldCB8fCAwIH0pKSwgaSAmJiBhLmFwcGVuZChcInN0b3JlXCIsIGkpO1xuICAgIGNvbnN0IHMgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICBzLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgIHMucmVhZHlTdGF0ZSA9PT0gNCAmJiBzLnN0YXR1cyA9PT0gMCAmJiByICYmIHIobnVsbCk7XG4gICAgfSwgcy5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIGxldCBvID0gbnVsbDtcbiAgICAgIGlmICghKHMuc3RhdHVzID4gNDAwKSkgdHJ5IHtcbiAgICAgICAgbyA9IEpTT04ucGFyc2Uocy5yZXNwb25zZVRleHQpO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICB9XG4gICAgICByICYmIHIobyk7XG4gICAgfSwgcy5vcGVuKFwiUE9TVFwiLCBuLCAhMCksIHMuc2V0UmVxdWVzdEhlYWRlcihcIlgtUmVxdWVzdGVkLVdpdGhcIiwgXCJYTUxIdHRwUmVxdWVzdFwiKSwgcy5zZW5kKGEpO1xuICB9LCBfYWpheFRvRXhwb3J0KGUsIG4sIGkpIHtcbiAgICBkZWxldGUgZS5jYWxsYmFjaztcbiAgICBjb25zdCBhID0gZS5zZXJ2ZXIgfHwgdC5leHQuZXhwb3J0X2FwaS5fYXBpVXJsLCByID0gXCJ0eXBlPVwiICsgbiArIFwiJnN0b3JlPTEmZGF0YT1cIiArIGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShlKSk7XG4gICAgdC5leHQuZXhwb3J0X2FwaS5feGRyKGEsIHIsIGZ1bmN0aW9uKHMpIHtcbiAgICAgIGNvbnN0IG8gPSBzLnhtbERvYyB8fCBzO1xuICAgICAgbGV0IGwgPSBudWxsO1xuICAgICAgaWYgKCEoby5zdGF0dXMgPiA0MDApKSB0cnkge1xuICAgICAgICBsID0gSlNPTi5wYXJzZShvLnJlc3BvbnNlVGV4dCk7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgIH1cbiAgICAgIGkobCk7XG4gICAgfSk7XG4gIH0sIF9zZXJpYWxpemFibGVHYW50dENvbmZpZyhlKSB7XG4gICAgY29uc3QgbiA9IHQubWl4aW4oe30sIGUpO1xuICAgIHJldHVybiBuLmNvbHVtbnMgJiYgKG4uY29sdW1ucyA9IG4uY29sdW1ucy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgY29uc3QgYSA9IHQubWl4aW4oe30sIGkpO1xuICAgICAgcmV0dXJuIGRlbGV0ZSBhLmVkaXRvciwgYTtcbiAgICB9KSksIGRlbGV0ZSBuLmVkaXRvcl90eXBlcywgbjtcbiAgfSwgX3NlbmRUb0V4cG9ydChlLCBuKSB7XG4gICAgY29uc3QgaSA9IHQuZGF0ZS5kYXRlX3RvX3N0cih0LmNvbmZpZy5kYXRlX2Zvcm1hdCB8fCB0LmNvbmZpZy54bWxfZGF0ZSk7XG4gICAgaWYgKGUuc2tpbiB8fCAoZS5za2luID0gdC5za2luKSwgZS5jb25maWcgJiYgKGUuY29uZmlnID0gdC5jb3B5KHQuZXh0LmV4cG9ydF9hcGkuX3NlcmlhbGl6YWJsZUdhbnR0Q29uZmlnKGUuY29uZmlnKSksIHQuZXh0LmV4cG9ydF9hcGkuX21hcmtDb2x1bW5zKGUsIG4pLCBlLmNvbmZpZy5zdGFydF9kYXRlICYmIGUuY29uZmlnLmVuZF9kYXRlICYmIChlLmNvbmZpZy5zdGFydF9kYXRlIGluc3RhbmNlb2YgRGF0ZSAmJiAoZS5jb25maWcuc3RhcnRfZGF0ZSA9IGkoZS5jb25maWcuc3RhcnRfZGF0ZSkpLCBlLmNvbmZpZy5lbmRfZGF0ZSBpbnN0YW5jZW9mIERhdGUgJiYgKGUuY29uZmlnLmVuZF9kYXRlID0gaShlLmNvbmZpZy5lbmRfZGF0ZSkpKSksIGUuY2FsbGJhY2spIHJldHVybiB0LmV4dC5leHBvcnRfYXBpLl9hamF4VG9FeHBvcnQoZSwgbiwgZS5jYWxsYmFjayk7XG4gICAgY29uc3QgYSA9IHQuZXh0LmV4cG9ydF9hcGkuX2NyZWF0ZUhpZGRlbkZvcm0oKTtcbiAgICBhLmZpcnN0Q2hpbGQuYWN0aW9uID0gZS5zZXJ2ZXIgfHwgdC5leHQuZXhwb3J0X2FwaS5fYXBpVXJsLCBhLmZpcnN0Q2hpbGQuY2hpbGROb2Rlc1swXS52YWx1ZSA9IEpTT04uc3RyaW5naWZ5KGUpLCBhLmZpcnN0Q2hpbGQuY2hpbGROb2Rlc1sxXS52YWx1ZSA9IG4sIGEuZmlyc3RDaGlsZC5zdWJtaXQoKTtcbiAgfSwgX2NyZWF0ZUhpZGRlbkZvcm0oKSB7XG4gICAgaWYgKCF0LmV4dC5leHBvcnRfYXBpLl9oaWRkZW5fZXhwb3J0X2Zvcm0pIHtcbiAgICAgIGNvbnN0IGUgPSB0LmV4dC5leHBvcnRfYXBpLl9oaWRkZW5fZXhwb3J0X2Zvcm0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgZS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCIsIGUuaW5uZXJIVE1MID0gXCI8Zm9ybSBtZXRob2Q9J1BPU1QnIHRhcmdldD0nX2JsYW5rJz48dGV4dGFyZWEgbmFtZT0nZGF0YScgc3R5bGU9J3dpZHRoOjBweDsgaGVpZ2h0OjBweDsnIHJlYWRvbmx5PSd0cnVlJz48L3RleHRhcmVhPjxpbnB1dCB0eXBlPSdoaWRkZW4nIG5hbWU9J3R5cGUnIHZhbHVlPScnPjwvZm9ybT5cIiwgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChlKTtcbiAgICB9XG4gICAgcmV0dXJuIHQuZXh0LmV4cG9ydF9hcGkuX2hpZGRlbl9leHBvcnRfZm9ybTtcbiAgfSwgX2NvcHlPYmplY3RCYXNlKGUpIHtcbiAgICBjb25zdCBuID0geyBzdGFydF9kYXRlOiB2b2lkIDAsIGVuZF9kYXRlOiB2b2lkIDAsIGNvbnN0cmFpbnRfZGF0ZTogdm9pZCAwLCBkZWFkbGluZTogdm9pZCAwIH07XG4gICAgZm9yIChjb25zdCBhIGluIGUpIGEuY2hhckF0KDApICE9PSBcIiRcIiAmJiBhICE9PSBcImJhc2VsaW5lc1wiICYmIChuW2FdID0gZVthXSk7XG4gICAgY29uc3QgaSA9IHQudGVtcGxhdGVzLnhtbF9mb3JtYXQgfHwgdC50ZW1wbGF0ZXMuZm9ybWF0X2RhdGU7XG4gICAgcmV0dXJuIG4uc3RhcnRfZGF0ZSA9IGkobi5zdGFydF9kYXRlKSwgbi5lbmRfZGF0ZSAmJiAobi5lbmRfZGF0ZSA9IGkobi5lbmRfZGF0ZSkpLCBuLmNvbnN0cmFpbnRfZGF0ZSAmJiAobi5jb25zdHJhaW50X2RhdGUgPSBpKG4uY29uc3RyYWludF9kYXRlKSksIG4uZGVhZGxpbmUgJiYgKG4uZGVhZGxpbmUgPSBpKG4uZGVhZGxpbmUpKSwgbjtcbiAgfSwgX2NvbG9yX2JveDogbnVsbCwgX2NvbG9yX2hhc2g6IHt9LCBfZ2V0U3R5bGVzKGUpIHtcbiAgICBpZiAodC5leHQuZXhwb3J0X2FwaS5fY29sb3JfYm94IHx8ICh0LmV4dC5leHBvcnRfYXBpLl9jb2xvcl9ib3ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiRElWXCIpLCB0LmV4dC5leHBvcnRfYXBpLl9jb2xvcl9ib3guc3R5bGUuY3NzVGV4dCA9IFwicG9zaXRpb246YWJzb2x1dGU7IGRpc3BsYXk6bm9uZTtcIiwgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0LmV4dC5leHBvcnRfYXBpLl9jb2xvcl9ib3gpKSwgdC5leHQuZXhwb3J0X2FwaS5fY29sb3JfaGFzaFtlXSkgcmV0dXJuIHQuZXh0LmV4cG9ydF9hcGkuX2NvbG9yX2hhc2hbZV07XG4gICAgdC5leHQuZXhwb3J0X2FwaS5fY29sb3JfYm94LmNsYXNzTmFtZSA9IGU7XG4gICAgY29uc3QgbiA9IHQuZXh0LmV4cG9ydF9hcGkuX2dldENvbG9yKHQuZXh0LmV4cG9ydF9hcGkuX2NvbG9yX2JveCwgXCJjb2xvclwiKSwgaSA9IHQuZXh0LmV4cG9ydF9hcGkuX2dldENvbG9yKHQuZXh0LmV4cG9ydF9hcGkuX2NvbG9yX2JveCwgXCJiYWNrZ3JvdW5kQ29sb3JcIik7XG4gICAgcmV0dXJuIHQuZXh0LmV4cG9ydF9hcGkuX2NvbG9yX2hhc2hbZV0gPSBuICsgXCI7XCIgKyBpO1xuICB9LCBfZ2V0TWludXRlc1dvcmt0aW1lU2V0dGluZ3MoZSkge1xuICAgIGNvbnN0IG4gPSBbXTtcbiAgICByZXR1cm4gZS5mb3JFYWNoKGZ1bmN0aW9uKGkpIHtcbiAgICAgIG4ucHVzaChpLnN0YXJ0TWludXRlKSwgbi5wdXNoKGkuZW5kTWludXRlKTtcbiAgICB9KSwgbjtcbiAgfSwgX2dldFdvcmt0aW1lU2V0dGluZ3MoKSB7XG4gICAgY29uc3QgZSA9IHsgaG91cnM6IFswLCAyNF0sIG1pbnV0ZXM6IG51bGwsIGRhdGVzOiB7IDA6ICEwLCAxOiAhMCwgMjogITAsIDM6ICEwLCA0OiAhMCwgNTogITAsIDY6ICEwIH0gfTtcbiAgICBsZXQgbjtcbiAgICBpZiAodC5jb25maWcud29ya190aW1lKSB7XG4gICAgICBjb25zdCBpID0gdC5fd29ya2luZ190aW1lX2hlbHBlcjtcbiAgICAgIGlmIChpICYmIGkuZ2V0X2NhbGVuZGFyKSBuID0gaS5nZXRfY2FsZW5kYXIoKTtcbiAgICAgIGVsc2UgaWYgKGkpIG4gPSB7IGhvdXJzOiBpLmhvdXJzLCBtaW51dGVzOiBudWxsLCBkYXRlczogaS5kYXRlcyB9O1xuICAgICAgZWxzZSBpZiAodC5jb25maWcud29ya3RpbWVzICYmIHQuY29uZmlnLndvcmt0aW1lcy5nbG9iYWwpIHtcbiAgICAgICAgY29uc3QgYSA9IHQuY29uZmlnLndvcmt0aW1lcy5nbG9iYWw7XG4gICAgICAgIGlmIChhLnBhcnNlZCkge1xuICAgICAgICAgIG4gPSB7IGhvdXJzOiBudWxsLCBtaW51dGVzOiB0LmV4dC5leHBvcnRfYXBpLl9nZXRNaW51dGVzV29ya3RpbWVTZXR0aW5ncyhhLnBhcnNlZC5ob3VycyksIGRhdGVzOiB7fSB9O1xuICAgICAgICAgIGZvciAoY29uc3QgciBpbiBhLnBhcnNlZC5kYXRlcykgQXJyYXkuaXNBcnJheShhLnBhcnNlZC5kYXRlc1tyXSkgPyBuLmRhdGVzW3JdID0gdC5leHQuZXhwb3J0X2FwaS5fZ2V0TWludXRlc1dvcmt0aW1lU2V0dGluZ3MoYS5wYXJzZWQuZGF0ZXNbcl0pIDogbi5kYXRlc1tyXSA9IGEucGFyc2VkLmRhdGVzW3JdO1xuICAgICAgICB9IGVsc2UgbiA9IHsgaG91cnM6IGEuaG91cnMsIG1pbnV0ZXM6IG51bGwsIGRhdGVzOiBhLmRhdGVzIH07XG4gICAgICB9IGVsc2UgbiA9IGU7XG4gICAgfSBlbHNlIG4gPSBlO1xuICAgIHJldHVybiBuO1xuICB9LCBfZWFjaFRhc2tUaW1lZDogKGUsIG4pID0+IGZ1bmN0aW9uKGksIGEsIHIpIHtcbiAgICBhID0gYSB8fCB0LmNvbmZpZy5yb290X2lkLCByID0gciB8fCB0O1xuICAgIGNvbnN0IHMgPSB0LmdldENoaWxkcmVuKGEpO1xuICAgIGlmIChzKSBmb3IgKGxldCBvID0gMDsgbyA8IHMubGVuZ3RoOyBvKyspIHtcbiAgICAgIGNvbnN0IGwgPSB0Ll9wdWxsW3Nbb11dO1xuICAgICAgKCFlIHx8IGwuZW5kX2RhdGUgPiBlKSAmJiAoIW4gfHwgbC5zdGFydF9kYXRlIDwgbikgJiYgaS5jYWxsKHIsIGwpLCB0Lmhhc0NoaWxkKGwuaWQpICYmIHQuZWFjaFRhc2soaSwgbC5pZCwgcik7XG4gICAgfVxuICB9LCBfb3JpZ2luYWxDb3B5T2JqZWN0OiB0Lmpzb24uX2NvcHlPYmplY3QsIF9jb3B5T2JqZWN0UGxhaW4oZSkge1xuICAgIGNvbnN0IG4gPSB0LnRlbXBsYXRlcy50YXNrX3RleHQoZS5zdGFydF9kYXRlLCBlLmVuZF9kYXRlLCBlKSwgaSA9IHQuZXh0LmV4cG9ydF9hcGkuX2NvcHlPYmplY3RCYXNlKGUpO1xuICAgIHJldHVybiBpLnRleHQgPSBuIHx8IGkudGV4dCwgaTtcbiAgfSwgX2dldENvbG9yKGUsIG4pIHtcbiAgICBjb25zdCBpID0gZS5jdXJyZW50U3R5bGUgPyBlLmN1cnJlbnRTdHlsZVtuXSA6IGdldENvbXB1dGVkU3R5bGUoZSwgbnVsbClbbl0sIGEgPSBpLnJlcGxhY2UoL1xccy9nLCBcIlwiKS5tYXRjaCgvXnJnYmE/XFwoKFxcZCspLChcXGQrKSwoXFxkKykvaSk7XG4gICAgcmV0dXJuIChhICYmIGEubGVuZ3RoID09PSA0ID8gKFwiMFwiICsgcGFyc2VJbnQoYVsxXSwgMTApLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTIpICsgKFwiMFwiICsgcGFyc2VJbnQoYVsyXSwgMTApLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTIpICsgKFwiMFwiICsgcGFyc2VJbnQoYVszXSwgMTApLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTIpIDogaSkucmVwbGFjZShcIiNcIiwgXCJcIik7XG4gIH0sIF9jb3B5T2JqZWN0VGFibGUoZSkge1xuICAgIGNvbnN0IG4gPSB0LmRhdGUuZGF0ZV90b19zdHIoXCIlWS0lbS0lZFQlSDolaTolcy4wMDBaXCIpLCBpID0gdC5leHQuZXhwb3J0X2FwaS5fY29weU9iamVjdENvbHVtbnMoZSwgdC5leHQuZXhwb3J0X2FwaS5fY29weU9iamVjdFBsYWluKGUpKTtcbiAgICBpLnN0YXJ0X2RhdGUgJiYgKGkuc3RhcnRfZGF0ZSA9IG4oZS5zdGFydF9kYXRlKSksIGkuZW5kX2RhdGUgJiYgKGkuZW5kX2RhdGUgPSBuKGUuZW5kX2RhdGUpKTtcbiAgICBjb25zdCBhID0gdC5fZGF5X2luZGV4X2J5X2RhdGUgPyB0Ll9kYXlfaW5kZXhfYnlfZGF0ZSA6IHQuY29sdW1uSW5kZXhCeURhdGU7XG4gICAgaS4kc3RhcnQgPSBhLmNhbGwodCwgZS5zdGFydF9kYXRlKSwgaS4kZW5kID0gYS5jYWxsKHQsIGUuZW5kX2RhdGUpO1xuICAgIGxldCByID0gMDtcbiAgICBjb25zdCBzID0gdC5nZXRTY2FsZSgpLndpZHRoO1xuICAgIGlmIChzLmluZGV4T2YoMCkgPiAtMSkge1xuICAgICAgbGV0IGwgPSAwO1xuICAgICAgZm9yICg7IGwgPCBpLiRzdGFydDsgbCsrKSBzW2xdIHx8IHIrKztcbiAgICAgIGZvciAoaS4kc3RhcnQgLT0gcjsgbCA8IGkuJGVuZDsgbCsrKSBzW2xdIHx8IHIrKztcbiAgICAgIGkuJGVuZCAtPSByO1xuICAgIH1cbiAgICBpLiRsZXZlbCA9IGUuJGxldmVsLCBpLiR0eXBlID0gZS4kcmVuZGVyZWRfdHlwZTtcbiAgICBjb25zdCBvID0gdC50ZW1wbGF0ZXM7XG4gICAgcmV0dXJuIGkuJHRleHQgPSBvLnRhc2tfdGV4dChlLnN0YXJ0LCBlLmVuZF9kYXRlLCBlKSwgaS4kbGVmdCA9IG8ubGVmdHNpZGVfdGV4dCA/IG8ubGVmdHNpZGVfdGV4dChlLnN0YXJ0LCBlLmVuZF9kYXRlLCBlKSA6IFwiXCIsIGkuJHJpZ2h0ID0gby5yaWdodHNpZGVfdGV4dCA/IG8ucmlnaHRzaWRlX3RleHQoZS5zdGFydCwgZS5lbmRfZGF0ZSwgZSkgOiBcIlwiLCBpO1xuICB9LCBfY29weU9iamVjdENvbG9ycyhlKSB7XG4gICAgY29uc3QgbiA9IHQuZXh0LmV4cG9ydF9hcGkuX2NvcHlPYmplY3RUYWJsZShlKSwgaSA9IHQuZ2V0VGFza05vZGUoZS5pZCk7XG4gICAgaWYgKGkgJiYgaS5maXJzdENoaWxkKSB7XG4gICAgICBsZXQgYSA9IHQuZXh0LmV4cG9ydF9hcGkuX2dldENvbG9yKHQuX25vX3Byb2dyZXNzX2NvbG9ycyA/IGkgOiBpLmZpcnN0Q2hpbGQsIFwiYmFja2dyb3VuZENvbG9yXCIpO1xuICAgICAgYSA9PT0gXCIzNjM2MzZcIiAmJiAoYSA9IHQuZXh0LmV4cG9ydF9hcGkuX2dldENvbG9yKGksIFwiYmFja2dyb3VuZENvbG9yXCIpKSwgbi4kY29sb3IgPSBhO1xuICAgIH0gZWxzZSBlLmNvbG9yICYmIChuLiRjb2xvciA9IGUuY29sb3IpO1xuICAgIHJldHVybiBuO1xuICB9LCBfY29weU9iamVjdENvbHVtbnMoZSwgbikge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdC5jb25maWcuY29sdW1ucy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgYSA9IHQuY29uZmlnLmNvbHVtbnNbaV0udGVtcGxhdGU7XG4gICAgICBpZiAoYSkge1xuICAgICAgICBsZXQgciA9IGEoZSk7XG4gICAgICAgIHIgaW5zdGFuY2VvZiBEYXRlICYmIChyID0gdC50ZW1wbGF0ZXMuZGF0ZV9ncmlkKHIsIGUpKSwgbltcIl9cIiArIGldID0gcjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG47XG4gIH0sIF9jb3B5T2JqZWN0QWxsKGUpIHtcbiAgICBjb25zdCBuID0gdC5leHQuZXhwb3J0X2FwaS5fY29weU9iamVjdEJhc2UoZSksIGkgPSBbXCJsZWZ0c2lkZV90ZXh0XCIsIFwicmlnaHRzaWRlX3RleHRcIiwgXCJ0YXNrX3RleHRcIiwgXCJwcm9ncmVzc190ZXh0XCIsIFwidGFza19jbGFzc1wiXTtcbiAgICBmb3IgKGxldCBhID0gMDsgYSA8IGkubGVuZ3RoOyBhKyspIHtcbiAgICAgIGNvbnN0IHIgPSB0LnRlbXBsYXRlc1tpW2FdXTtcbiAgICAgIHIgJiYgKG5bXCIkXCIgKyBhXSA9IHIoZS5zdGFydF9kYXRlLCBlLmVuZF9kYXRlLCBlKSk7XG4gICAgfVxuICAgIHJldHVybiB0LmV4dC5leHBvcnRfYXBpLl9jb3B5T2JqZWN0Q29sdW1ucyhlLCBuKSwgbi5vcGVuID0gZS4kb3BlbiwgbjtcbiAgfSwgX3NlcmlhbGl6ZUh0bWwoKSB7XG4gICAgY29uc3QgZSA9IHQuY29uZmlnLnNtYXJ0X3NjYWxlcywgbiA9IHQuY29uZmlnLnNtYXJ0X3JlbmRlcmluZztcbiAgICAoZSB8fCBuKSAmJiAodC5jb25maWcuc21hcnRfcmVuZGVyaW5nID0gITEsIHQuY29uZmlnLnNtYXJ0X3NjYWxlcyA9ICExLCB0LnJlbmRlcigpKTtcbiAgICBjb25zdCBpID0gdC4kY29udGFpbmVyLnBhcmVudE5vZGUuaW5uZXJIVE1MO1xuICAgIHJldHVybiAoZSB8fCBuKSAmJiAodC5jb25maWcuc21hcnRfc2NhbGVzID0gZSwgdC5jb25maWcuc21hcnRfcmVuZGVyaW5nID0gbiwgdC5yZW5kZXIoKSksIGk7XG4gIH0sIF9zZXJpYWxpemVBbGwoKSB7XG4gICAgdC5qc29uLl9jb3B5T2JqZWN0ID0gdC5leHQuZXhwb3J0X2FwaS5fY29weU9iamVjdEFsbDtcbiAgICBjb25zdCBlID0gdC5leHQuZXhwb3J0X2FwaS5fZXhwb3J0U2VyaWFsaXplKCk7XG4gICAgcmV0dXJuIHQuanNvbi5fY29weU9iamVjdCA9IHQuZXh0LmV4cG9ydF9hcGkuX29yaWdpbmFsQ29weU9iamVjdCwgZTtcbiAgfSwgX3NlcmlhbGl6ZVBsYWluKCkge1xuICAgIGNvbnN0IGUgPSB0LnRlbXBsYXRlcy54bWxfZm9ybWF0LCBuID0gdC50ZW1wbGF0ZXMuZm9ybWF0X2RhdGU7XG4gICAgdC50ZW1wbGF0ZXMueG1sX2Zvcm1hdCA9IHQuZGF0ZS5kYXRlX3RvX3N0cihcIiVZJW0lZFQlSCVpJXNcIiwgITApLCB0LnRlbXBsYXRlcy5mb3JtYXRfZGF0ZSA9IHQuZGF0ZS5kYXRlX3RvX3N0cihcIiVZJW0lZFQlSCVpJXNcIiwgITApLCB0Lmpzb24uX2NvcHlPYmplY3QgPSB0LmV4dC5leHBvcnRfYXBpLl9jb3B5T2JqZWN0UGxhaW47XG4gICAgY29uc3QgaSA9IHQuZXh0LmV4cG9ydF9hcGkuX2V4cG9ydFNlcmlhbGl6ZSgpO1xuICAgIHJldHVybiB0LnRlbXBsYXRlcy54bWxfZm9ybWF0ID0gZSwgdC50ZW1wbGF0ZXMuZm9ybWF0X2RhdGUgPSBuLCB0Lmpzb24uX2NvcHlPYmplY3QgPSB0LmV4dC5leHBvcnRfYXBpLl9vcmlnaW5hbENvcHlPYmplY3QsIGRlbGV0ZSBpLmxpbmtzLCBpO1xuICB9LCBfZ2V0UmF3KCkge1xuICAgIGlmICh0Ll9zY2FsZV9oZWxwZXJzKSB7XG4gICAgICBjb25zdCBlID0gdC5fZ2V0X3NjYWxlcygpLCBuID0gdC5jb25maWcubWluX2NvbHVtbl93aWR0aCwgaSA9IHQuX2dldF9yZXNpemVfb3B0aW9ucygpLnggPyBNYXRoLm1heCh0LmNvbmZpZy5hdXRvc2l6ZV9taW5fd2lkdGgsIDApIDogdC5jb25maWcuJHRhc2sub2Zmc2V0V2lkdGgsIGEgPSB0LmNvbmZpZy5jb25maWcuc2NhbGVfaGVpZ2h0IC0gMTtcbiAgICAgIHJldHVybiB0Ll9zY2FsZV9oZWxwZXJzLnByZXBhcmVDb25maWdzKGUsIG4sIGksIGEpO1xuICAgIH1cbiAgICB7XG4gICAgICBjb25zdCBlID0gdC4kdWkuZ2V0VmlldyhcInRpbWVsaW5lXCIpO1xuICAgICAgaWYgKGUpIHtcbiAgICAgICAgbGV0IG4gPSBlLiRjb25maWcud2lkdGg7XG4gICAgICAgIHQuY29uZmlnLmF1dG9zaXplICE9PSBcInhcIiAmJiB0LmNvbmZpZy5hdXRvc2l6ZSAhPT0gXCJ4eVwiIHx8IChuID0gTWF0aC5tYXgodC5jb25maWcuYXV0b3NpemVfbWluX3dpZHRoLCAwKSk7XG4gICAgICAgIGNvbnN0IGkgPSB0LmdldFN0YXRlKCksIGEgPSBlLl9nZXRTY2FsZXMoKSwgciA9IHQuY29uZmlnLm1pbl9jb2x1bW5fd2lkdGgsIHMgPSB0LmNvbmZpZy5zY2FsZV9oZWlnaHQgLSAxLCBvID0gdC5jb25maWcucnRsO1xuICAgICAgICByZXR1cm4gZS4kc2NhbGVIZWxwZXIucHJlcGFyZUNvbmZpZ3MoYSwgciwgbiwgcywgaS5taW5fZGF0ZSwgaS5tYXhfZGF0ZSwgbyk7XG4gICAgICB9XG4gICAgfVxuICB9LCBfc2VyaWFsaXplVGltZWxpbmUoZSkge1xuICAgIHQuanNvbi5fY29weU9iamVjdCA9IGUudmlzdWFsID8gdC5leHQuZXhwb3J0X2FwaS5fY29weU9iamVjdENvbG9ycyA6IHQuZXh0LmV4cG9ydF9hcGkuX2NvcHlPYmplY3RUYWJsZTtcbiAgICBjb25zdCBuID0gdC5leHQuZXhwb3J0X2FwaS5fZXhwb3J0U2VyaWFsaXplKCk7XG4gICAgaWYgKHQuanNvbi5fY29weU9iamVjdCA9IHQuZXh0LmV4cG9ydF9hcGkuX29yaWdpbmFsQ29weU9iamVjdCwgZGVsZXRlIG4ubGlua3MsIGUuY2VsbENvbG9ycykge1xuICAgICAgY29uc3QgaSA9IHQudGVtcGxhdGVzLnRpbWVsaW5lX2NlbGxfY2xhc3MgfHwgdC50ZW1wbGF0ZXMudGFza19jZWxsX2NsYXNzO1xuICAgICAgaWYgKGkpIHtcbiAgICAgICAgY29uc3QgYSA9IHQuZXh0LmV4cG9ydF9hcGkuX2dldFJhdygpO1xuICAgICAgICBsZXQgciA9IGFbMF0udHJhY2VfeDtcbiAgICAgICAgZm9yIChsZXQgcyA9IDE7IHMgPCBhLmxlbmd0aDsgcysrKSBhW3NdLnRyYWNlX3gubGVuZ3RoID4gci5sZW5ndGggJiYgKHIgPSBhW3NdLnRyYWNlX3gpO1xuICAgICAgICBmb3IgKGxldCBzID0gMDsgcyA8IG4uZGF0YS5sZW5ndGg7IHMrKykge1xuICAgICAgICAgIG4uZGF0YVtzXS5zdHlsZXMgPSBbXTtcbiAgICAgICAgICBjb25zdCBvID0gdC5nZXRUYXNrKG4uZGF0YVtzXS5pZCk7XG4gICAgICAgICAgZm9yIChsZXQgbCA9IDA7IGwgPCByLmxlbmd0aDsgbCsrKSB7XG4gICAgICAgICAgICBjb25zdCBkID0gaShvLCByW2xdKTtcbiAgICAgICAgICAgIGQgJiYgbi5kYXRhW3NdLnN0eWxlcy5wdXNoKHsgaW5kZXg6IGwsIHN0eWxlczogdC5leHQuZXhwb3J0X2FwaS5fZ2V0U3R5bGVzKGQpIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbjtcbiAgfSwgX3NlcmlhbGl6ZVNjYWxlcyhlKSB7XG4gICAgY29uc3QgbiA9IFtdLCBpID0gdC5leHQuZXhwb3J0X2FwaS5fZ2V0UmF3KCk7XG4gICAgbGV0IGEgPSAxIC8gMCwgciA9IDA7XG4gICAgZm9yIChsZXQgcyA9IDA7IHMgPCBpLmxlbmd0aDsgcysrKSBhID0gTWF0aC5taW4oYSwgaVtzXS5jb2xfd2lkdGgpO1xuICAgIGZvciAobGV0IHMgPSAwOyBzIDwgaS5sZW5ndGg7IHMrKykge1xuICAgICAgbGV0IG8gPSAwLCBsID0gMDtcbiAgICAgIGNvbnN0IGQgPSBbXTtcbiAgICAgIG4ucHVzaChkKTtcbiAgICAgIGNvbnN0IGMgPSBpW3NdO1xuICAgICAgciA9IE1hdGgubWF4KHIsIGMudHJhY2VfeC5sZW5ndGgpO1xuICAgICAgY29uc3QgdSA9IGMuZm9ybWF0IHx8IGMudGVtcGxhdGUgfHwgKGMuZGF0ZSA/IHQuZGF0ZS5kYXRlX3RvX3N0cihjLmRhdGUpIDogdC5jb25maWcuZGF0ZV9zY2FsZSk7XG4gICAgICBmb3IgKGxldCBoID0gMDsgaCA8IGMudHJhY2VfeC5sZW5ndGg7IGgrKykge1xuICAgICAgICBjb25zdCBnID0gYy50cmFjZV94W2hdO1xuICAgICAgICBsID0gbyArIE1hdGgucm91bmQoYy53aWR0aFtoXSAvIGEpO1xuICAgICAgICBjb25zdCBwID0geyB0ZXh0OiB1KGcpLCBzdGFydDogbywgZW5kOiBsLCBzdHlsZXM6IFwiXCIgfTtcbiAgICAgICAgaWYgKGUuY2VsbENvbG9ycykge1xuICAgICAgICAgIGNvbnN0IHkgPSBjLmNzcyB8fCB0LnRlbXBsYXRlcy5zY2FsZUNlbGxfY2xhc3M7XG4gICAgICAgICAgaWYgKHkpIHtcbiAgICAgICAgICAgIGNvbnN0IHYgPSB5KGcpO1xuICAgICAgICAgICAgdiAmJiAocC5zdHlsZXMgPSB0LmV4dC5leHBvcnRfYXBpLl9nZXRTdHlsZXModikpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkLnB1c2gocCksIG8gPSBsO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyB3aWR0aDogciwgaGVpZ2h0OiBuLmxlbmd0aCwgZGF0YTogbiB9O1xuICB9LCBfc2VyaWFsaXplR3JpZChlKSB7XG4gICAgdC5leHBvcnRNb2RlID0gITA7XG4gICAgY29uc3QgbiA9IFtdLCBpID0gdC5jb25maWcuY29sdW1ucztcbiAgICBsZXQgYSA9IDA7XG4gICAgZm9yIChsZXQgciA9IDA7IHIgPCBpLmxlbmd0aDsgcisrKSBpW3JdLm5hbWUgIT09IFwiYWRkXCIgJiYgaVtyXS5uYW1lICE9PSBcImJ1dHRvbnNcIiAmJiAoblthXSA9IHsgaWQ6IGlbcl0udGVtcGxhdGUgPyBcIl9cIiArIHIgOiBpW3JdLm5hbWUsIGhlYWRlcjogaVtyXS5sYWJlbCB8fCB0LmxvY2FsZS5sYWJlbHNbXCJjb2x1bW5fXCIgKyBpW3JdLm5hbWVdLCB3aWR0aDogaVtyXS53aWR0aCA/IE1hdGguZmxvb3IoaVtyXS53aWR0aCAvIDQpIDogXCJcIiwgdHJlZTogaVtyXS50cmVlIHx8ICExIH0sIGlbcl0ubmFtZSA9PT0gXCJkdXJhdGlvblwiICYmIChuW2FdLnR5cGUgPSBcIm51bWJlclwiKSwgaVtyXS5uYW1lICE9PSBcInN0YXJ0X2RhdGVcIiAmJiBpW3JdLm5hbWUgIT09IFwiZW5kX2RhdGVcIiB8fCAoblthXS50eXBlID0gXCJkYXRlXCIsIGUgJiYgZS5yYXdEYXRlcyAmJiAoblthXS5pZCA9IGlbcl0ubmFtZSkpLCBhKyspO1xuICAgIHJldHVybiB0LmV4cG9ydE1vZGUgPSAhMSwgbjtcbiAgfSwgX2V4cG9ydFNlcmlhbGl6ZSgpIHtcbiAgICB0LmV4cG9ydE1vZGUgPSAhMDtcbiAgICBjb25zdCBlID0gdC50ZW1wbGF0ZXMueG1sX2Zvcm1hdCwgbiA9IHQudGVtcGxhdGVzLmZvcm1hdF9kYXRlO1xuICAgIHQudGVtcGxhdGVzLnhtbF9mb3JtYXQgPSB0LnRlbXBsYXRlcy5mb3JtYXRfZGF0ZSA9IHQuZGF0ZS5kYXRlX3RvX3N0cih0LmNvbmZpZy5kYXRlX2Zvcm1hdCB8fCB0LmNvbmZpZy54bWxfZGF0ZSk7XG4gICAgY29uc3QgaSA9IHQuc2VyaWFsaXplKCk7XG4gICAgcmV0dXJuIHQudGVtcGxhdGVzLnhtbF9mb3JtYXQgPSBlLCB0LnRlbXBsYXRlcy5mb3JtYXRfZGF0ZSA9IG4sIHQuZXhwb3J0TW9kZSA9ICExLCBpO1xuICB9LCBfc2V0TGV2ZWwoZSkge1xuICAgIGZvciAobGV0IG4gPSAwOyBuIDwgZS5sZW5ndGg7IG4rKykge1xuICAgICAgZVtuXS5wYXJlbnQgPT0gMCAmJiAoZVtuXS5fbHZsID0gMSk7XG4gICAgICBmb3IgKGxldCBpID0gbiArIDE7IGkgPCBlLmxlbmd0aDsgaSsrKSBlW25dLmlkID09IGVbaV0ucGFyZW50ICYmIChlW2ldLl9sdmwgPSBlW25dLl9sdmwgKyAxKTtcbiAgICB9XG4gIH0sIF9jbGVhckxldmVsKGUpIHtcbiAgICBmb3IgKGxldCBuID0gMDsgbiA8IGUubGVuZ3RoOyBuKyspIGRlbGV0ZSBlW25dLl9sdmw7XG4gIH0sIF9jbGVhclJlY0xpbmtzKGUpIHtcbiAgICB0LmV4dC5leHBvcnRfYXBpLl9zZXRMZXZlbChlLmRhdGEpO1xuICAgIGNvbnN0IG4gPSB7fTtcbiAgICBmb3IgKGxldCByID0gMDsgciA8IGUuZGF0YS5sZW5ndGg7IHIrKykgbltlLmRhdGFbcl0uaWRdID0gZS5kYXRhW3JdO1xuICAgIGNvbnN0IGkgPSB7fTtcbiAgICBmb3IgKGxldCByID0gMDsgciA8IGUubGlua3MubGVuZ3RoOyByKyspIHtcbiAgICAgIGNvbnN0IHMgPSBlLmxpbmtzW3JdO1xuICAgICAgdC5pc1Rhc2tFeGlzdHMocy5zb3VyY2UpICYmIHQuaXNUYXNrRXhpc3RzKHMudGFyZ2V0KSAmJiBuW3Muc291cmNlXSAmJiBuW3MudGFyZ2V0XSAmJiAoaVtzLmlkXSA9IHMpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHIgaW4gaSkgdC5leHQuZXhwb3J0X2FwaS5fbWFrZUxpbmtzU2FtZUxldmVsKGlbcl0sIG4pO1xuICAgIGNvbnN0IGEgPSB7fTtcbiAgICBmb3IgKGNvbnN0IHIgaW4gbikgdC5leHQuZXhwb3J0X2FwaS5fY2xlYXJDaXJjRGVwZW5kZW5jaWVzKG5bcl0sIGksIG4sIHt9LCBhLCBudWxsKTtcbiAgICBPYmplY3Qua2V5cyhpKSAmJiB0LmV4dC5leHBvcnRfYXBpLl9jbGVhckxpbmtzU2FtZUxldmVsKGksIG4pO1xuICAgIGZvciAobGV0IHIgPSAwOyByIDwgZS5saW5rcy5sZW5ndGg7IHIrKykgaVtlLmxpbmtzW3JdLmlkXSB8fCAoZS5saW5rcy5zcGxpY2UociwgMSksIHItLSk7XG4gICAgdC5leHQuZXhwb3J0X2FwaS5fY2xlYXJMZXZlbChlLmRhdGEpO1xuICB9LCBfY2xlYXJDaXJjRGVwZW5kZW5jaWVzKGUsIG4sIGksIGEsIHIsIHMpIHtcbiAgICBjb25zdCBvID0gZS4kX3NvdXJjZTtcbiAgICBpZiAoIW8pIHJldHVybjtcbiAgICBhW2UuaWRdICYmIHQuZXh0LmV4cG9ydF9hcGkuX29uQ2lyY0RlcGVuZGVuY3lGaW5kKHMsIG4sIGEsIHIpLCBhW2UuaWRdID0gITA7XG4gICAgY29uc3QgbCA9IHt9O1xuICAgIGZvciAobGV0IGQgPSAwOyBkIDwgby5sZW5ndGg7IGQrKykge1xuICAgICAgaWYgKHJbb1tkXV0pIGNvbnRpbnVlO1xuICAgICAgY29uc3QgYyA9IG5bb1tkXV0sIHUgPSBpW2MuX3RhcmdldF07XG4gICAgICBsW3UuaWRdICYmIHQuZXh0LmV4cG9ydF9hcGkuX29uQ2lyY0RlcGVuZGVuY3lGaW5kKGMsIG4sIGEsIHIpLCBsW3UuaWRdID0gITAsIHQuZXh0LmV4cG9ydF9hcGkuX2NsZWFyQ2lyY0RlcGVuZGVuY2llcyh1LCBuLCBpLCBhLCByLCBjKTtcbiAgICB9XG4gICAgYVtlLmlkXSA9ICExO1xuICB9LCBfb25DaXJjRGVwZW5kZW5jeUZpbmQoZSwgbiwgaSwgYSkge1xuICAgIGUgJiYgKHQuY2FsbEV2ZW50KFwib25FeHBvcnRDaXJjdWxhckRlcGVuZGVuY3lcIiwgW2UuaWQsIGVdKSAmJiBkZWxldGUgbltlLmlkXSwgZGVsZXRlIGlbZS5fc291cmNlXSwgZGVsZXRlIGlbZS5fdGFyZ2V0XSwgYVtlLmlkXSA9ICEwKTtcbiAgfSwgX21ha2VMaW5rc1NhbWVMZXZlbChlLCBuKSB7XG4gICAgbGV0IGksIGE7XG4gICAgY29uc3QgciA9IHsgdGFyZ2V0OiBuW2UudGFyZ2V0XSwgc291cmNlOiBuW2Uuc291cmNlXSB9O1xuICAgIGlmIChyLnRhcmdldC5fbHZsICE9IHIuc291cmNlLl9sdmwpIHtcbiAgICAgIHIudGFyZ2V0Ll9sdmwgPCByLnNvdXJjZS5fbHZsID8gKGkgPSBcInNvdXJjZVwiLCBhID0gci50YXJnZXQuX2x2bCkgOiAoaSA9IFwidGFyZ2V0XCIsIGEgPSByLnNvdXJjZS5fbHZsKTtcbiAgICAgIGRvIHtcbiAgICAgICAgY29uc3QgbCA9IG5bcltpXS5wYXJlbnRdO1xuICAgICAgICBpZiAoIWwpIGJyZWFrO1xuICAgICAgICByW2ldID0gbDtcbiAgICAgIH0gd2hpbGUgKHJbaV0uX2x2bCA8IGEpO1xuICAgICAgbGV0IHMgPSBuW3Iuc291cmNlLnBhcmVudF0sIG8gPSBuW3IudGFyZ2V0LnBhcmVudF07XG4gICAgICBmb3IgKDsgcyAmJiBvICYmIHMuaWQgIT0gby5pZDsgKSByLnNvdXJjZSA9IHMsIHIudGFyZ2V0ID0gbywgcyA9IG5bci5zb3VyY2UucGFyZW50XSwgbyA9IG5bci50YXJnZXQucGFyZW50XTtcbiAgICB9XG4gICAgZS5fdGFyZ2V0ID0gci50YXJnZXQuaWQsIGUuX3NvdXJjZSA9IHIuc291cmNlLmlkLCByLnRhcmdldC4kX3RhcmdldCB8fCAoci50YXJnZXQuJF90YXJnZXQgPSBbXSksIHIudGFyZ2V0LiRfdGFyZ2V0LnB1c2goZS5pZCksIHIuc291cmNlLiRfc291cmNlIHx8IChyLnNvdXJjZS4kX3NvdXJjZSA9IFtdKSwgci5zb3VyY2UuJF9zb3VyY2UucHVzaChlLmlkKTtcbiAgfSwgX2NsZWFyTGlua3NTYW1lTGV2ZWwoZSwgbikge1xuICAgIGZvciAoY29uc3QgaSBpbiBlKSBkZWxldGUgZVtpXS5fdGFyZ2V0LCBkZWxldGUgZVtpXS5fc291cmNlO1xuICAgIGZvciAoY29uc3QgaSBpbiBuKSBkZWxldGUgbltpXS4kX3NvdXJjZSwgZGVsZXRlIG5baV0uJF90YXJnZXQ7XG4gIH0sIF9jdXN0b21Qcm9qZWN0UHJvcGVydGllcyhlLCBuKSB7XG4gICAgaWYgKG4gJiYgbi5wcm9qZWN0KSB7XG4gICAgICBmb3IgKGNvbnN0IGkgaW4gbi5wcm9qZWN0KSB0LmNvbmZpZy4kY3VzdG9tX2RhdGEgfHwgKHQuY29uZmlnLiRjdXN0b21fZGF0YSA9IHt9KSwgdC5jb25maWcuJGN1c3RvbV9kYXRhW2ldID0gdHlwZW9mIG4ucHJvamVjdFtpXSA9PSBcImZ1bmN0aW9uXCIgPyBuLnByb2plY3RbaV0odC5jb25maWcpIDogbi5wcm9qZWN0W2ldO1xuICAgICAgZGVsZXRlIG4ucHJvamVjdDtcbiAgICB9XG4gIH0sIF9jdXN0b21UYXNrUHJvcGVydGllcyhlLCBuKSB7XG4gICAgbiAmJiBuLnRhc2tzICYmIChlLmRhdGEuZm9yRWFjaChmdW5jdGlvbihpKSB7XG4gICAgICBmb3IgKGNvbnN0IGEgaW4gbi50YXNrcykgaS4kY3VzdG9tX2RhdGEgfHwgKGkuJGN1c3RvbV9kYXRhID0ge30pLCBpLiRjdXN0b21fZGF0YVthXSA9IHR5cGVvZiBuLnRhc2tzW2FdID09IFwiZnVuY3Rpb25cIiA/IG4udGFza3NbYV0oaSwgdC5jb25maWcpIDogbi50YXNrc1thXTtcbiAgICB9KSwgZGVsZXRlIG4udGFza3MpO1xuICB9LCBfZXhwb3J0Q29uZmlnKGUsIG4pIHtcbiAgICBjb25zdCBpID0gbi5uYW1lIHx8IFwiZ2FudHQueG1sXCI7XG4gICAgZGVsZXRlIG4ubmFtZSwgdC5jb25maWcuY3VzdG9tID0gbjtcbiAgICBjb25zdCBhID0gdC5leHQuZXhwb3J0X2FwaS5fZ2V0V29ya3RpbWVTZXR0aW5ncygpLCByID0gdC5nZXRTdWJ0YXNrRGF0ZXMoKTtcbiAgICBpZiAoci5zdGFydF9kYXRlICYmIHIuZW5kX2RhdGUpIHtcbiAgICAgIGNvbnN0IGwgPSB0LnRlbXBsYXRlcy5mb3JtYXRfZGF0ZSB8fCB0LnRlbXBsYXRlcy54bWxfZm9ybWF0O1xuICAgICAgdC5jb25maWcuc3RhcnRfZW5kID0geyBzdGFydF9kYXRlOiBsKHIuc3RhcnRfZGF0ZSksIGVuZF9kYXRlOiBsKHIuZW5kX2RhdGUpIH07XG4gICAgfVxuICAgIGNvbnN0IHMgPSBuLmF1dG9fc2NoZWR1bGluZyAhPT0gdm9pZCAwICYmICEhbi5hdXRvX3NjaGVkdWxpbmcsIG8gPSB7IGNhbGxiYWNrOiBuLmNhbGxiYWNrIHx8IG51bGwsIGNvbmZpZzogdC5jb25maWcsIGRhdGE6IGUsIG1hbnVhbDogcywgbmFtZTogaSwgd29ya3RpbWU6IGEgfTtcbiAgICBmb3IgKGNvbnN0IGwgaW4gbikgb1tsXSA9IG5bbF07XG4gICAgcmV0dXJuIG87XG4gIH0sIF9zZW5kSW1wb3J0QWpheE1TUChlKSB7XG4gICAgY29uc3QgbiA9IGUuc2VydmVyIHx8IHQuZXh0LmV4cG9ydF9hcGkuX2FwaVVybCwgaSA9IGUuc3RvcmUgfHwgMCwgYSA9IGUuZGF0YSwgciA9IGUuY2FsbGJhY2ssIHMgPSB7IGR1cmF0aW9uVW5pdDogZS5kdXJhdGlvblVuaXQgfHwgdm9pZCAwLCBwcm9qZWN0UHJvcGVydGllczogZS5wcm9qZWN0UHJvcGVydGllcyB8fCB2b2lkIDAsIHRhc2tQcm9wZXJ0aWVzOiBlLnRhc2tQcm9wZXJ0aWVzIHx8IHZvaWQgMCB9O1xuICAgIGEuYXBwZW5kKFwidHlwZVwiLCBlLnR5cGUgfHwgXCJtc3Byb2plY3QtcGFyc2VcIiksIGEuYXBwZW5kKFwiZGF0YVwiLCBKU09OLnN0cmluZ2lmeShzKSksIGkgJiYgYS5hcHBlbmQoXCJzdG9yZVwiLCBpKTtcbiAgICBjb25zdCBvID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgby5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbihsKSB7XG4gICAgICBvLnJlYWR5U3RhdGUgPT09IDQgJiYgby5zdGF0dXMgPT09IDAgJiYgciAmJiByKG51bGwpO1xuICAgIH0sIG8ub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICBsZXQgbCA9IG51bGw7XG4gICAgICBpZiAoIShvLnN0YXR1cyA+IDQwMCkpIHRyeSB7XG4gICAgICAgIGwgPSBKU09OLnBhcnNlKG8ucmVzcG9uc2VUZXh0KTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgfVxuICAgICAgciAmJiByKGwpO1xuICAgIH0sIG8ub3BlbihcIlBPU1RcIiwgbiwgITApLCBvLnNldFJlcXVlc3RIZWFkZXIoXCJYLVJlcXVlc3RlZC1XaXRoXCIsIFwiWE1MSHR0cFJlcXVlc3RcIiksIG8uc2VuZChhKTtcbiAgfSB9LCB0LmV4cG9ydFRvUERGID0gdC5leHQuZXhwb3J0X2FwaS5leHBvcnRUb1BERiwgdC5leHBvcnRUb1BORyA9IHQuZXh0LmV4cG9ydF9hcGkuZXhwb3J0VG9QTkcsIHQuZXhwb3J0VG9JQ2FsID0gdC5leHQuZXhwb3J0X2FwaS5leHBvcnRUb0lDYWwsIHQuZXhwb3J0VG9FeGNlbCA9IHQuZXh0LmV4cG9ydF9hcGkuZXhwb3J0VG9FeGNlbCwgdC5leHBvcnRUb0pTT04gPSB0LmV4dC5leHBvcnRfYXBpLmV4cG9ydFRvSlNPTiwgdC5pbXBvcnRGcm9tRXhjZWwgPSB0LmV4dC5leHBvcnRfYXBpLmltcG9ydEZyb21FeGNlbCwgdC5pbXBvcnRGcm9tTVNQcm9qZWN0ID0gdC5leHQuZXhwb3J0X2FwaS5pbXBvcnRGcm9tTVNQcm9qZWN0LCB0LmV4cG9ydFRvTVNQcm9qZWN0ID0gdC5leHQuZXhwb3J0X2FwaS5leHBvcnRUb01TUHJvamVjdCwgdC5pbXBvcnRGcm9tUHJpbWF2ZXJhUDYgPSB0LmV4dC5leHBvcnRfYXBpLmltcG9ydEZyb21QcmltYXZlcmFQNiwgdC5leHBvcnRUb1ByaW1hdmVyYVA2ID0gdC5leHQuZXhwb3J0X2FwaS5leHBvcnRUb1ByaW1hdmVyYVA2LCB0LmV4dC5leHBvcnRfYXBpO1xufSB9LCBVbiA9IHsgS0VZX0NPREVTOiB7IFVQOiAzOCwgRE9XTjogNDAsIExFRlQ6IDM3LCBSSUdIVDogMzksIFNQQUNFOiAzMiwgRU5URVI6IDEzLCBERUxFVEU6IDQ2LCBFU0M6IDI3LCBUQUI6IDkgfSB9O1xuY2xhc3MgcW4ge1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgdGhpcy5hZGRFeHRlbnNpb24gPSAobiwgaSkgPT4ge1xuICAgICAgdGhpcy5fZXh0ZW5zaW9uc1tuXSA9IGk7XG4gICAgfSwgdGhpcy5nZXRFeHRlbnNpb24gPSAobikgPT4gdGhpcy5fZXh0ZW5zaW9uc1tuXSwgdGhpcy5fZXh0ZW5zaW9ucyA9IHt9O1xuICAgIGZvciAoY29uc3QgbiBpbiBlKSB0aGlzLl9leHRlbnNpb25zW25dID0gZVtuXTtcbiAgfVxufVxudmFyIG50ID0gdHlwZW9mIHdpbmRvdyA8IFwidVwiO1xuY29uc3QgbXQgPSB7IGlzSUU6IG50ICYmIChuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoXCJNU0lFXCIpID49IDAgfHwgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKFwiVHJpZGVudFwiKSA+PSAwKSwgaXNJRTY6IG50ICYmICFYTUxIdHRwUmVxdWVzdCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoXCJNU0lFXCIpID49IDAsIGlzSUU3OiBudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoXCJNU0lFIDcuMFwiKSA+PSAwICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihcIlRyaWRlbnRcIikgPCAwLCBpc0lFODogbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKFwiTVNJRSA4LjBcIikgPj0gMCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoXCJUcmlkZW50XCIpID49IDAsIGlzT3BlcmE6IG50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihcIk9wZXJhXCIpID49IDAsIGlzQ2hyb21lOiBudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoXCJDaHJvbWVcIikgPj0gMCwgaXNLSFRNTDogbnQgJiYgKG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihcIlNhZmFyaVwiKSA+PSAwIHx8IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihcIktvbnF1ZXJvclwiKSA+PSAwKSwgaXNGRjogbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKFwiRmlyZWZveFwiKSA+PSAwLCBpc0lQYWQ6IG50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQuc2VhcmNoKC9pUGFkL2dpKSA+PSAwLCBpc0VkZ2U6IG50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihcIkVkZ2VcIikgIT0gLTEsIGlzTm9kZTogIW50IHx8IHR5cGVvZiBuYXZpZ2F0b3IgPiBcInVcIiB8fCAhMSB9O1xuZnVuY3Rpb24gTmUodCkge1xuICBpZiAodHlwZW9mIHQgPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdCA9PSBcIm51bWJlclwiKSByZXR1cm4gdDtcbiAgbGV0IGUgPSBcIlwiO1xuICBmb3IgKGNvbnN0IG4gaW4gdCkge1xuICAgIGxldCBpID0gXCJcIjtcbiAgICB0Lmhhc093blByb3BlcnR5KG4pICYmIChpID0gdHlwZW9mIHRbbl0gPT0gXCJzdHJpbmdcIiA/IGVuY29kZVVSSUNvbXBvbmVudCh0W25dKSA6IHR5cGVvZiB0W25dID09IFwibnVtYmVyXCIgPyBTdHJpbmcodFtuXSkgOiBlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkodFtuXSkpLCBpID0gbiArIFwiPVwiICsgaSwgZS5sZW5ndGggJiYgKGkgPSBcIiZcIiArIGkpLCBlICs9IGkpO1xuICB9XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24geHQodCwgZSkge1xuICB2YXIgbiA9IHsgbWV0aG9kOiB0IH07XG4gIGlmIChlLmxlbmd0aCA9PT0gMCkgdGhyb3cgbmV3IEVycm9yKFwiQXJndW1lbnRzIGxpc3Qgb2YgcXVlcnkgaXMgd3JvbmcuXCIpO1xuICBpZiAoZS5sZW5ndGggPT09IDEpIHJldHVybiB0eXBlb2YgZVswXSA9PSBcInN0cmluZ1wiID8gKG4udXJsID0gZVswXSwgbi5hc3luYyA9ICEwKSA6IChuLnVybCA9IGVbMF0udXJsLCBuLmFzeW5jID0gZVswXS5hc3luYyB8fCAhMCwgbi5jYWxsYmFjayA9IGVbMF0uY2FsbGJhY2ssIG4uaGVhZGVycyA9IGVbMF0uaGVhZGVycyksIGVbMF0uZGF0YSA/IHR5cGVvZiBlWzBdLmRhdGEgIT0gXCJzdHJpbmdcIiA/IG4uZGF0YSA9IE5lKGVbMF0uZGF0YSkgOiBuLmRhdGEgPSBlWzBdLmRhdGEgOiBuLmRhdGEgPSBcIlwiLCBuO1xuICBzd2l0Y2ggKG4udXJsID0gZVswXSwgdCkge1xuICAgIGNhc2UgXCJHRVRcIjpcbiAgICBjYXNlIFwiREVMRVRFXCI6XG4gICAgICBuLmNhbGxiYWNrID0gZVsxXSwgbi5oZWFkZXJzID0gZVsyXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJQT1NUXCI6XG4gICAgY2FzZSBcIlBVVFwiOlxuICAgICAgZVsxXSA/IHR5cGVvZiBlWzFdICE9IFwic3RyaW5nXCIgPyBuLmRhdGEgPSBOZShlWzFdKSA6IG4uZGF0YSA9IGVbMV0gOiBuLmRhdGEgPSBcIlwiLCBuLmNhbGxiYWNrID0gZVsyXSwgbi5oZWFkZXJzID0gZVszXTtcbiAgfVxuICByZXR1cm4gbjtcbn1cbmNvbnN0IExlID0geyBkYXRlX3RvX3N0cjogKHQsIGUsIG4pID0+IHtcbiAgdCA9IHQucmVwbGFjZSgvJVthLXpBLVpdL2csIChhKSA9PiB7XG4gICAgc3dpdGNoIChhKSB7XG4gICAgICBjYXNlIFwiJWRcIjpcbiAgICAgICAgcmV0dXJuIGBcIit0b19maXhlZChkYXRlLmdldCR7ZSA/IFwiVVRDXCIgOiBcIlwifURhdGUoKSkrXCJgO1xuICAgICAgY2FzZSBcIiVtXCI6XG4gICAgICAgIHJldHVybiBgXCIrdG9fZml4ZWQoKGRhdGUuZ2V0JHtlID8gXCJVVENcIiA6IFwiXCJ9TW9udGgoKSsxKSkrXCJgO1xuICAgICAgY2FzZSBcIiVqXCI6XG4gICAgICAgIHJldHVybiBgXCIrZGF0ZS5nZXQke2UgPyBcIlVUQ1wiIDogXCJcIn1EYXRlKCkrXCJgO1xuICAgICAgY2FzZSBcIiVuXCI6XG4gICAgICAgIHJldHVybiBgXCIrKGRhdGUuZ2V0JHtlID8gXCJVVENcIiA6IFwiXCJ9TW9udGgoKSsxKStcImA7XG4gICAgICBjYXNlIFwiJXlcIjpcbiAgICAgICAgcmV0dXJuIGBcIit0b19maXhlZChkYXRlLmdldCR7ZSA/IFwiVVRDXCIgOiBcIlwifUZ1bGxZZWFyKCklMTAwKStcImA7XG4gICAgICBjYXNlIFwiJVlcIjpcbiAgICAgICAgcmV0dXJuIGBcIitkYXRlLmdldCR7ZSA/IFwiVVRDXCIgOiBcIlwifUZ1bGxZZWFyKCkrXCJgO1xuICAgICAgY2FzZSBcIiVEXCI6XG4gICAgICAgIHJldHVybiBgXCIrbG9jYWxlLmRhdGUuZGF5X3Nob3J0W2RhdGUuZ2V0JHtlID8gXCJVVENcIiA6IFwiXCJ9RGF5KCldK1wiYDtcbiAgICAgIGNhc2UgXCIlbFwiOlxuICAgICAgICByZXR1cm4gYFwiK2xvY2FsZS5kYXRlLmRheV9mdWxsW2RhdGUuZ2V0JHtlID8gXCJVVENcIiA6IFwiXCJ9RGF5KCldK1wiYDtcbiAgICAgIGNhc2UgXCIlTVwiOlxuICAgICAgICByZXR1cm4gYFwiK2xvY2FsZS5kYXRlLm1vbnRoX3Nob3J0W2RhdGUuZ2V0JHtlID8gXCJVVENcIiA6IFwiXCJ9TW9udGgoKV0rXCJgO1xuICAgICAgY2FzZSBcIiVGXCI6XG4gICAgICAgIHJldHVybiBgXCIrbG9jYWxlLmRhdGUubW9udGhfZnVsbFtkYXRlLmdldCR7ZSA/IFwiVVRDXCIgOiBcIlwifU1vbnRoKCldK1wiYDtcbiAgICAgIGNhc2UgXCIlaFwiOlxuICAgICAgICByZXR1cm4gYFwiK3RvX2ZpeGVkKChkYXRlLmdldCR7ZSA/IFwiVVRDXCIgOiBcIlwifUhvdXJzKCkrMTEpJTEyKzEpK1wiYDtcbiAgICAgIGNhc2UgXCIlZ1wiOlxuICAgICAgICByZXR1cm4gYFwiKygoZGF0ZS5nZXQke2UgPyBcIlVUQ1wiIDogXCJcIn1Ib3VycygpKzExKSUxMisxKStcImA7XG4gICAgICBjYXNlIFwiJUdcIjpcbiAgICAgICAgcmV0dXJuIGBcIitkYXRlLmdldCR7ZSA/IFwiVVRDXCIgOiBcIlwifUhvdXJzKCkrXCJgO1xuICAgICAgY2FzZSBcIiVIXCI6XG4gICAgICAgIHJldHVybiBgXCIrdG9fZml4ZWQoZGF0ZS5nZXQke2UgPyBcIlVUQ1wiIDogXCJcIn1Ib3VycygpKStcImA7XG4gICAgICBjYXNlIFwiJWlcIjpcbiAgICAgICAgcmV0dXJuIGBcIit0b19maXhlZChkYXRlLmdldCR7ZSA/IFwiVVRDXCIgOiBcIlwifU1pbnV0ZXMoKSkrXCJgO1xuICAgICAgY2FzZSBcIiVhXCI6XG4gICAgICAgIHJldHVybiBgXCIrKGRhdGUuZ2V0JHtlID8gXCJVVENcIiA6IFwiXCJ9SG91cnMoKT4xMT9cInBtXCI6XCJhbVwiKStcImA7XG4gICAgICBjYXNlIFwiJUFcIjpcbiAgICAgICAgcmV0dXJuIGBcIisoZGF0ZS5nZXQke2UgPyBcIlVUQ1wiIDogXCJcIn1Ib3VycygpPjExP1wiUE1cIjpcIkFNXCIpK1wiYDtcbiAgICAgIGNhc2UgXCIlc1wiOlxuICAgICAgICByZXR1cm4gYFwiK3RvX2ZpeGVkKGRhdGUuZ2V0JHtlID8gXCJVVENcIiA6IFwiXCJ9U2Vjb25kcygpKStcImA7XG4gICAgICBjYXNlIFwiJVdcIjpcbiAgICAgICAgcmV0dXJuICdcIit0b19maXhlZChnZXRJU09XZWVrKGRhdGUpKStcIic7XG4gICAgICBjYXNlIFwiJXdcIjpcbiAgICAgICAgcmV0dXJuICdcIit0b19maXhlZChnZXRXZWVrKGRhdGUpKStcIic7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gYTtcbiAgICB9XG4gIH0pO1xuICBjb25zdCBpID0gbmV3IEZ1bmN0aW9uKFwiZGF0ZVwiLCBcInRvX2ZpeGVkXCIsIFwibG9jYWxlXCIsIFwiZ2V0SVNPV2Vla1wiLCBcImdldFdlZWtcIiwgYHJldHVybiBcIiR7dH1cIjtgKTtcbiAgcmV0dXJuIChhKSA9PiBpKGEsIG4uZGF0ZS50b19maXhlZCwgbi5sb2NhbGUsIG4uZGF0ZS5nZXRJU09XZWVrLCBuLmRhdGUuZ2V0V2Vlayk7XG59LCBzdHJfdG9fZGF0ZTogKHQsIGUsIG4pID0+IHtcbiAgbGV0IGkgPSBcInZhciB0ZW1wPWRhdGUubWF0Y2goL1thLXpBLVpdK3xbMC05XSsvZyk7XCI7XG4gIGNvbnN0IGEgPSB0Lm1hdGNoKC8lW2EtekEtWl0vZyk7XG4gIGZvciAobGV0IG8gPSAwOyBvIDwgYS5sZW5ndGg7IG8rKykgc3dpdGNoIChhW29dKSB7XG4gICAgY2FzZSBcIiVqXCI6XG4gICAgY2FzZSBcIiVkXCI6XG4gICAgICBpICs9IGBzZXRbMl09dGVtcFske299XXx8MTtgO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIiVuXCI6XG4gICAgY2FzZSBcIiVtXCI6XG4gICAgICBpICs9IGBzZXRbMV09KHRlbXBbJHtvfV18fDEpLTE7YDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCIleVwiOlxuICAgICAgaSArPSBgc2V0WzBdPXRlbXBbJHtvfV0qMSsodGVtcFske299XT41MD8xOTAwOjIwMDApO2A7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiJWdcIjpcbiAgICBjYXNlIFwiJUdcIjpcbiAgICBjYXNlIFwiJWhcIjpcbiAgICBjYXNlIFwiJUhcIjpcbiAgICAgIGkgKz0gYHNldFszXT10ZW1wWyR7b31dfHwwO2A7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiJWlcIjpcbiAgICAgIGkgKz0gYHNldFs0XT10ZW1wWyR7b31dfHwwO2A7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiJVlcIjpcbiAgICAgIGkgKz0gYHNldFswXT10ZW1wWyR7b31dfHwwO2A7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiJWFcIjpcbiAgICBjYXNlIFwiJUFcIjpcbiAgICAgIGkgKz0gYHNldFszXT1zZXRbM10lMTIrKCh0ZW1wWyR7b31dfHwnJykudG9Mb3dlckNhc2UoKT09J2FtJz8wOjEyKTtgO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIiVzXCI6XG4gICAgICBpICs9IGBzZXRbNV09dGVtcFske299XXx8MDtgO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIiVNXCI6XG4gICAgICBpICs9IGBzZXRbMV09bG9jYWxlLmRhdGUubW9udGhfc2hvcnRfaGFzaFt0ZW1wWyR7b31dXXx8MDtgO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIiVGXCI6XG4gICAgICBpICs9IGBzZXRbMV09bG9jYWxlLmRhdGUubW9udGhfZnVsbF9oYXNoW3RlbXBbJHtvfV1dfHwwO2A7XG4gIH1cbiAgbGV0IHIgPSBcInNldFswXSxzZXRbMV0sc2V0WzJdLHNldFszXSxzZXRbNF0sc2V0WzVdXCI7XG4gIGUgJiYgKHIgPSBgIERhdGUuVVRDKCR7cn0pYCk7XG4gIGNvbnN0IHMgPSBuZXcgRnVuY3Rpb24oXCJkYXRlXCIsIFwibG9jYWxlXCIsIGB2YXIgc2V0PVswLDAsMSwwLDAsMF07ICR7aX0gcmV0dXJuIG5ldyBEYXRlKCR7cn0pO2ApO1xuICByZXR1cm4gKG8pID0+IHMobywgbi5sb2NhbGUpO1xufSB9LCBQZSA9IHsgZGF0ZV90b19zdHI6ICh0LCBlLCBuKSA9PiAoaSkgPT4gdC5yZXBsYWNlKC8lW2EtekEtWl0vZywgKGEpID0+IHtcbiAgc3dpdGNoIChhKSB7XG4gICAgY2FzZSBcIiVkXCI6XG4gICAgICByZXR1cm4gZSA/IG4uZGF0ZS50b19maXhlZChpLmdldFVUQ0RhdGUoKSkgOiBuLmRhdGUudG9fZml4ZWQoaS5nZXREYXRlKCkpO1xuICAgIGNhc2UgXCIlbVwiOlxuICAgICAgcmV0dXJuIGUgPyBuLmRhdGUudG9fZml4ZWQoaS5nZXRVVENNb250aCgpICsgMSkgOiBuLmRhdGUudG9fZml4ZWQoaS5nZXRNb250aCgpICsgMSk7XG4gICAgY2FzZSBcIiVqXCI6XG4gICAgICByZXR1cm4gZSA/IGkuZ2V0VVRDRGF0ZSgpIDogaS5nZXREYXRlKCk7XG4gICAgY2FzZSBcIiVuXCI6XG4gICAgICByZXR1cm4gZSA/IGkuZ2V0VVRDTW9udGgoKSArIDEgOiBpLmdldE1vbnRoKCkgKyAxO1xuICAgIGNhc2UgXCIleVwiOlxuICAgICAgcmV0dXJuIGUgPyBuLmRhdGUudG9fZml4ZWQoaS5nZXRVVENGdWxsWWVhcigpICUgMTAwKSA6IG4uZGF0ZS50b19maXhlZChpLmdldEZ1bGxZZWFyKCkgJSAxMDApO1xuICAgIGNhc2UgXCIlWVwiOlxuICAgICAgcmV0dXJuIGUgPyBpLmdldFVUQ0Z1bGxZZWFyKCkgOiBpLmdldEZ1bGxZZWFyKCk7XG4gICAgY2FzZSBcIiVEXCI6XG4gICAgICByZXR1cm4gZSA/IG4ubG9jYWxlLmRhdGUuZGF5X3Nob3J0W2kuZ2V0VVRDRGF5KCldIDogbi5sb2NhbGUuZGF0ZS5kYXlfc2hvcnRbaS5nZXREYXkoKV07XG4gICAgY2FzZSBcIiVsXCI6XG4gICAgICByZXR1cm4gZSA/IG4ubG9jYWxlLmRhdGUuZGF5X2Z1bGxbaS5nZXRVVENEYXkoKV0gOiBuLmxvY2FsZS5kYXRlLmRheV9mdWxsW2kuZ2V0RGF5KCldO1xuICAgIGNhc2UgXCIlTVwiOlxuICAgICAgcmV0dXJuIGUgPyBuLmxvY2FsZS5kYXRlLm1vbnRoX3Nob3J0W2kuZ2V0VVRDTW9udGgoKV0gOiBuLmxvY2FsZS5kYXRlLm1vbnRoX3Nob3J0W2kuZ2V0TW9udGgoKV07XG4gICAgY2FzZSBcIiVGXCI6XG4gICAgICByZXR1cm4gZSA/IG4ubG9jYWxlLmRhdGUubW9udGhfZnVsbFtpLmdldFVUQ01vbnRoKCldIDogbi5sb2NhbGUuZGF0ZS5tb250aF9mdWxsW2kuZ2V0TW9udGgoKV07XG4gICAgY2FzZSBcIiVoXCI6XG4gICAgICByZXR1cm4gZSA/IG4uZGF0ZS50b19maXhlZCgoaS5nZXRVVENIb3VycygpICsgMTEpICUgMTIgKyAxKSA6IG4uZGF0ZS50b19maXhlZCgoaS5nZXRIb3VycygpICsgMTEpICUgMTIgKyAxKTtcbiAgICBjYXNlIFwiJWdcIjpcbiAgICAgIHJldHVybiBlID8gKGkuZ2V0VVRDSG91cnMoKSArIDExKSAlIDEyICsgMSA6IChpLmdldEhvdXJzKCkgKyAxMSkgJSAxMiArIDE7XG4gICAgY2FzZSBcIiVHXCI6XG4gICAgICByZXR1cm4gZSA/IGkuZ2V0VVRDSG91cnMoKSA6IGkuZ2V0SG91cnMoKTtcbiAgICBjYXNlIFwiJUhcIjpcbiAgICAgIHJldHVybiBlID8gbi5kYXRlLnRvX2ZpeGVkKGkuZ2V0VVRDSG91cnMoKSkgOiBuLmRhdGUudG9fZml4ZWQoaS5nZXRIb3VycygpKTtcbiAgICBjYXNlIFwiJWlcIjpcbiAgICAgIHJldHVybiBlID8gbi5kYXRlLnRvX2ZpeGVkKGkuZ2V0VVRDTWludXRlcygpKSA6IG4uZGF0ZS50b19maXhlZChpLmdldE1pbnV0ZXMoKSk7XG4gICAgY2FzZSBcIiVhXCI6XG4gICAgICByZXR1cm4gZSA/IGkuZ2V0VVRDSG91cnMoKSA+IDExID8gXCJwbVwiIDogXCJhbVwiIDogaS5nZXRIb3VycygpID4gMTEgPyBcInBtXCIgOiBcImFtXCI7XG4gICAgY2FzZSBcIiVBXCI6XG4gICAgICByZXR1cm4gZSA/IGkuZ2V0VVRDSG91cnMoKSA+IDExID8gXCJQTVwiIDogXCJBTVwiIDogaS5nZXRIb3VycygpID4gMTEgPyBcIlBNXCIgOiBcIkFNXCI7XG4gICAgY2FzZSBcIiVzXCI6XG4gICAgICByZXR1cm4gZSA/IG4uZGF0ZS50b19maXhlZChpLmdldFVUQ1NlY29uZHMoKSkgOiBuLmRhdGUudG9fZml4ZWQoaS5nZXRTZWNvbmRzKCkpO1xuICAgIGNhc2UgXCIlV1wiOlxuICAgICAgcmV0dXJuIGUgPyBuLmRhdGUudG9fZml4ZWQobi5kYXRlLmdldFVUQ0lTT1dlZWsoaSkpIDogbi5kYXRlLnRvX2ZpeGVkKG4uZGF0ZS5nZXRJU09XZWVrKGkpKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGE7XG4gIH1cbn0pLCBzdHJfdG9fZGF0ZTogKHQsIGUsIG4pID0+IChpKSA9PiB7XG4gIGNvbnN0IGEgPSBbMCwgMCwgMSwgMCwgMCwgMF0sIHIgPSBpLm1hdGNoKC9bYS16QS1aXSt8WzAtOV0rL2cpLCBzID0gdC5tYXRjaCgvJVthLXpBLVpdL2cpO1xuICBmb3IgKGxldCBvID0gMDsgbyA8IHMubGVuZ3RoOyBvKyspIHN3aXRjaCAoc1tvXSkge1xuICAgIGNhc2UgXCIlalwiOlxuICAgIGNhc2UgXCIlZFwiOlxuICAgICAgYVsyXSA9IHJbb10gfHwgMTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCIlblwiOlxuICAgIGNhc2UgXCIlbVwiOlxuICAgICAgYVsxXSA9IChyW29dIHx8IDEpIC0gMTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCIleVwiOlxuICAgICAgYVswXSA9IDEgKiByW29dICsgKHJbb10gPiA1MCA/IDE5MDAgOiAyZTMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIiVnXCI6XG4gICAgY2FzZSBcIiVHXCI6XG4gICAgY2FzZSBcIiVoXCI6XG4gICAgY2FzZSBcIiVIXCI6XG4gICAgICBhWzNdID0gcltvXSB8fCAwO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIiVpXCI6XG4gICAgICBhWzRdID0gcltvXSB8fCAwO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIiVZXCI6XG4gICAgICBhWzBdID0gcltvXSB8fCAwO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIiVhXCI6XG4gICAgY2FzZSBcIiVBXCI6XG4gICAgICBhWzNdID0gYVszXSAlIDEyICsgKChyW29dIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCkgPT09IFwiYW1cIiA/IDAgOiAxMik7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiJXNcIjpcbiAgICAgIGFbNV0gPSByW29dIHx8IDA7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiJU1cIjpcbiAgICAgIGFbMV0gPSBuLmxvY2FsZS5kYXRlLm1vbnRoX3Nob3J0X2hhc2hbcltvXV0gfHwgMDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCIlRlwiOlxuICAgICAgYVsxXSA9IG4ubG9jYWxlLmRhdGUubW9udGhfZnVsbF9oYXNoW3Jbb11dIHx8IDA7XG4gIH1cbiAgcmV0dXJuIGUgPyBuZXcgRGF0ZShEYXRlLlVUQyhhWzBdLCBhWzFdLCBhWzJdLCBhWzNdLCBhWzRdLCBhWzVdKSkgOiBuZXcgRGF0ZShhWzBdLCBhWzFdLCBhWzJdLCBhWzNdLCBhWzRdLCBhWzVdKTtcbn0gfTtcbmZ1bmN0aW9uIEduKHQpIHtcbiAgdmFyIGUgPSBudWxsO1xuICBmdW5jdGlvbiBuKCkge1xuICAgIHZhciBhID0gITE7XG4gICAgcmV0dXJuIHQuY29uZmlnLmNzcCA9PT0gXCJhdXRvXCIgPyAoZSA9PT0gbnVsbCAmJiBmdW5jdGlvbigpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIG5ldyBGdW5jdGlvbihcImNhblVzZUNzcCA9IGZhbHNlO1wiKTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICBlID0gITA7XG4gICAgICB9XG4gICAgfSgpLCBhID0gZSkgOiBhID0gdC5jb25maWcuY3NwLCBhO1xuICB9XG4gIHZhciBpID0geyBpbml0OiBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciBhID0gdC5sb2NhbGUsIHIgPSBhLmRhdGUubW9udGhfc2hvcnQsIHMgPSBhLmRhdGUubW9udGhfc2hvcnRfaGFzaCA9IHt9LCBvID0gMDsgbyA8IHIubGVuZ3RoOyBvKyspIHNbcltvXV0gPSBvO1xuICAgIGZvciAociA9IGEuZGF0ZS5tb250aF9mdWxsLCBzID0gYS5kYXRlLm1vbnRoX2Z1bGxfaGFzaCA9IHt9LCBvID0gMDsgbyA8IHIubGVuZ3RoOyBvKyspIHNbcltvXV0gPSBvO1xuICB9LCBkYXRlX3BhcnQ6IGZ1bmN0aW9uKGEpIHtcbiAgICB2YXIgciA9IG5ldyBEYXRlKGEpO1xuICAgIHJldHVybiBhLnNldEhvdXJzKDApLCB0aGlzLmhvdXJfc3RhcnQoYSksIGEuZ2V0SG91cnMoKSAmJiAoYS5nZXREYXRlKCkgPCByLmdldERhdGUoKSB8fCBhLmdldE1vbnRoKCkgPCByLmdldE1vbnRoKCkgfHwgYS5nZXRGdWxsWWVhcigpIDwgci5nZXRGdWxsWWVhcigpKSAmJiBhLnNldFRpbWUoYS5nZXRUaW1lKCkgKyAzNmU1ICogKDI0IC0gYS5nZXRIb3VycygpKSksIGE7XG4gIH0sIHRpbWVfcGFydDogZnVuY3Rpb24oYSkge1xuICAgIHJldHVybiAoYS52YWx1ZU9mKCkgLyAxZTMgLSA2MCAqIGEuZ2V0VGltZXpvbmVPZmZzZXQoKSkgJSA4NjQwMDtcbiAgfSwgd2Vla19zdGFydDogZnVuY3Rpb24oYSkge1xuICAgIHZhciByID0gYS5nZXREYXkoKTtcbiAgICByZXR1cm4gdC5jb25maWcuc3RhcnRfb25fbW9uZGF5ICYmIChyID09PSAwID8gciA9IDYgOiByLS0pLCB0aGlzLmRhdGVfcGFydCh0aGlzLmFkZChhLCAtMSAqIHIsIFwiZGF5XCIpKTtcbiAgfSwgbW9udGhfc3RhcnQ6IGZ1bmN0aW9uKGEpIHtcbiAgICByZXR1cm4gYS5zZXREYXRlKDEpLCB0aGlzLmRhdGVfcGFydChhKTtcbiAgfSwgcXVhcnRlcl9zdGFydDogZnVuY3Rpb24oYSkge1xuICAgIHRoaXMubW9udGhfc3RhcnQoYSk7XG4gICAgdmFyIHIsIHMgPSBhLmdldE1vbnRoKCk7XG4gICAgcmV0dXJuIHIgPSBzID49IDkgPyA5IDogcyA+PSA2ID8gNiA6IHMgPj0gMyA/IDMgOiAwLCBhLnNldE1vbnRoKHIpLCBhO1xuICB9LCB5ZWFyX3N0YXJ0OiBmdW5jdGlvbihhKSB7XG4gICAgcmV0dXJuIGEuc2V0TW9udGgoMCksIHRoaXMubW9udGhfc3RhcnQoYSk7XG4gIH0sIGRheV9zdGFydDogZnVuY3Rpb24oYSkge1xuICAgIHJldHVybiB0aGlzLmRhdGVfcGFydChhKTtcbiAgfSwgaG91cl9zdGFydDogZnVuY3Rpb24oYSkge1xuICAgIHJldHVybiBhLmdldE1pbnV0ZXMoKSAmJiBhLnNldE1pbnV0ZXMoMCksIHRoaXMubWludXRlX3N0YXJ0KGEpLCBhO1xuICB9LCBtaW51dGVfc3RhcnQ6IGZ1bmN0aW9uKGEpIHtcbiAgICByZXR1cm4gYS5nZXRTZWNvbmRzKCkgJiYgYS5zZXRTZWNvbmRzKDApLCBhLmdldE1pbGxpc2Vjb25kcygpICYmIGEuc2V0TWlsbGlzZWNvbmRzKDApLCBhO1xuICB9LCBfYWRkX2RheXM6IGZ1bmN0aW9uKGEsIHIsIHMpIHtcbiAgICBhLnNldERhdGUoYS5nZXREYXRlKCkgKyByKTtcbiAgICB2YXIgbyA9IHIgPj0gMCwgbCA9ICFzLmdldEhvdXJzKCkgJiYgYS5nZXRIb3VycygpLCBkID0gYS5nZXREYXRlKCkgPD0gcy5nZXREYXRlKCkgfHwgYS5nZXRNb250aCgpIDwgcy5nZXRNb250aCgpIHx8IGEuZ2V0RnVsbFllYXIoKSA8IHMuZ2V0RnVsbFllYXIoKTtcbiAgICByZXR1cm4gbyAmJiBsICYmIGQgJiYgYS5zZXRUaW1lKGEuZ2V0VGltZSgpICsgMzZlNSAqICgyNCAtIGEuZ2V0SG91cnMoKSkpLCByID4gMSAmJiBsICYmIGEuc2V0SG91cnMoMCksIGE7XG4gIH0sIGFkZDogZnVuY3Rpb24oYSwgciwgcykge1xuICAgIHZhciBvID0gbmV3IERhdGUoYS52YWx1ZU9mKCkpO1xuICAgIHN3aXRjaCAocykge1xuICAgICAgY2FzZSBcImRheVwiOlxuICAgICAgICBvID0gdGhpcy5fYWRkX2RheXMobywgciwgYSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIndlZWtcIjpcbiAgICAgICAgbyA9IHRoaXMuX2FkZF9kYXlzKG8sIDcgKiByLCBhKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwibW9udGhcIjpcbiAgICAgICAgby5zZXRNb250aChvLmdldE1vbnRoKCkgKyByKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwieWVhclwiOlxuICAgICAgICBvLnNldFllYXIoby5nZXRGdWxsWWVhcigpICsgcik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImhvdXJcIjpcbiAgICAgICAgby5zZXRUaW1lKG8uZ2V0VGltZSgpICsgNjAgKiByICogNjAgKiAxZTMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJtaW51dGVcIjpcbiAgICAgICAgby5zZXRUaW1lKG8uZ2V0VGltZSgpICsgNjAgKiByICogMWUzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdGhpc1tcImFkZF9cIiArIHNdKGEsIHIsIHMpO1xuICAgIH1cbiAgICByZXR1cm4gbztcbiAgfSwgYWRkX3F1YXJ0ZXI6IGZ1bmN0aW9uKGEsIHIpIHtcbiAgICByZXR1cm4gdGhpcy5hZGQoYSwgMyAqIHIsIFwibW9udGhcIik7XG4gIH0sIHRvX2ZpeGVkOiBmdW5jdGlvbihhKSB7XG4gICAgcmV0dXJuIGEgPCAxMCA/IFwiMFwiICsgYSA6IGE7XG4gIH0sIGNvcHk6IGZ1bmN0aW9uKGEpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoYS52YWx1ZU9mKCkpO1xuICB9LCBkYXRlX3RvX3N0cjogZnVuY3Rpb24oYSwgcikge1xuICAgIHZhciBzID0gTGU7XG4gICAgcmV0dXJuIG4oKSAmJiAocyA9IFBlKSwgcy5kYXRlX3RvX3N0cihhLCByLCB0KTtcbiAgfSwgc3RyX3RvX2RhdGU6IGZ1bmN0aW9uKGEsIHIpIHtcbiAgICB2YXIgcyA9IExlO1xuICAgIHJldHVybiBuKCkgJiYgKHMgPSBQZSksIHMuc3RyX3RvX2RhdGUoYSwgciwgdCk7XG4gIH0sIGdldElTT1dlZWs6IGZ1bmN0aW9uKGEpIHtcbiAgICByZXR1cm4gdC5kYXRlLl9nZXRXZWVrTnVtYmVyKGEsICEwKTtcbiAgfSwgX2dldFdlZWtOdW1iZXI6IGZ1bmN0aW9uKGEsIHIpIHtcbiAgICBpZiAoIWEpIHJldHVybiAhMTtcbiAgICB2YXIgcyA9IGEuZ2V0RGF5KCk7XG4gICAgciAmJiBzID09PSAwICYmIChzID0gNyk7XG4gICAgdmFyIG8gPSBuZXcgRGF0ZShhLnZhbHVlT2YoKSk7XG4gICAgby5zZXREYXRlKGEuZ2V0RGF0ZSgpICsgKDQgLSBzKSk7XG4gICAgdmFyIGwgPSBvLmdldEZ1bGxZZWFyKCksIGQgPSBNYXRoLnJvdW5kKChvLmdldFRpbWUoKSAtIG5ldyBEYXRlKGwsIDAsIDEpLmdldFRpbWUoKSkgLyA4NjRlNSk7XG4gICAgcmV0dXJuIDEgKyBNYXRoLmZsb29yKGQgLyA3KTtcbiAgfSwgZ2V0V2VlazogZnVuY3Rpb24oYSkge1xuICAgIHJldHVybiB0LmRhdGUuX2dldFdlZWtOdW1iZXIoYSwgdC5jb25maWcuc3RhcnRfb25fbW9uZGF5KTtcbiAgfSwgZ2V0VVRDSVNPV2VlazogZnVuY3Rpb24oYSkge1xuICAgIHJldHVybiB0LmRhdGUuZ2V0SVNPV2VlayhhKTtcbiAgfSwgY29udmVydF90b191dGM6IGZ1bmN0aW9uKGEpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoYS5nZXRVVENGdWxsWWVhcigpLCBhLmdldFVUQ01vbnRoKCksIGEuZ2V0VVRDRGF0ZSgpLCBhLmdldFVUQ0hvdXJzKCksIGEuZ2V0VVRDTWludXRlcygpLCBhLmdldFVUQ1NlY29uZHMoKSk7XG4gIH0sIHBhcnNlRGF0ZTogZnVuY3Rpb24oYSwgcikge1xuICAgIHJldHVybiBhICYmICFhLmdldEZ1bGxZZWFyICYmICh0eXBlb2YgciAhPSBcImZ1bmN0aW9uXCIgJiYgKHIgPSB0eXBlb2YgciA9PSBcInN0cmluZ1wiID8gciA9PT0gXCJwYXJzZV9kYXRlXCIgfHwgciA9PT0gXCJ4bWxfZGF0ZVwiID8gdC5kZWZpbmVkKHQudGVtcGxhdGVzLnhtbF9kYXRlKSA/IHQudGVtcGxhdGVzLnhtbF9kYXRlIDogdC50ZW1wbGF0ZXMucGFyc2VfZGF0ZSA6IHQuZGVmaW5lZCh0LnRlbXBsYXRlc1tyXSkgPyB0LnRlbXBsYXRlc1tyXSA6IHQuZGF0ZS5zdHJfdG9fZGF0ZShyKSA6IHQuZGVmaW5lZCh0LnRlbXBsYXRlcy54bWxfZGF0ZSkgPyB0LnRlbXBsYXRlcy54bWxfZGF0ZSA6IHQudGVtcGxhdGVzLnBhcnNlX2RhdGUpLCBhID0gYSA/IHIoYSkgOiBudWxsKSwgYTtcbiAgfSB9O1xuICByZXR1cm4gaTtcbn1cbmNsYXNzIFluIHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIGNvbnN0IHsgdXJsOiBuLCB0b2tlbjogaSB9ID0gZTtcbiAgICB0aGlzLl91cmwgPSBuLCB0aGlzLl90b2tlbiA9IGksIHRoaXMuX21vZGUgPSAxLCB0aGlzLl9zZWVkID0gMSwgdGhpcy5fcXVldWUgPSBbXSwgdGhpcy5kYXRhID0ge30sIHRoaXMuYXBpID0ge30sIHRoaXMuX2V2ZW50cyA9IHt9O1xuICB9XG4gIGhlYWRlcnMoKSB7XG4gICAgcmV0dXJuIHsgQWNjZXB0OiBcImFwcGxpY2F0aW9uL2pzb25cIiwgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsIFwiUmVtb3RlLVRva2VuXCI6IHRoaXMuX3Rva2VuIH07XG4gIH1cbiAgZmV0Y2goZSwgbikge1xuICAgIGNvbnN0IGkgPSB7IGNyZWRlbnRpYWxzOiBcImluY2x1ZGVcIiwgaGVhZGVyczogdGhpcy5oZWFkZXJzKCkgfTtcbiAgICByZXR1cm4gbiAmJiAoaS5tZXRob2QgPSBcIlBPU1RcIiwgaS5ib2R5ID0gbiksIGZldGNoKGUsIGkpLnRoZW4oKGEpID0+IGEuanNvbigpKTtcbiAgfVxuICBsb2FkKGUpIHtcbiAgICByZXR1cm4gZSAmJiAodGhpcy5fdXJsID0gZSksIHRoaXMuZmV0Y2godGhpcy5fdXJsKS50aGVuKChuKSA9PiB0aGlzLnBhcnNlKG4pKTtcbiAgfVxuICBwYXJzZShlKSB7XG4gICAgY29uc3QgeyBrZXk6IG4sIHdlYnNvY2tldDogaSB9ID0gZTtcbiAgICBuICYmICh0aGlzLl90b2tlbiA9IGUua2V5KTtcbiAgICBmb3IgKGNvbnN0IGEgaW4gZS5kYXRhKSB0aGlzLmRhdGFbYV0gPSBlLmRhdGFbYV07XG4gICAgZm9yIChjb25zdCBhIGluIGUuYXBpKSB7XG4gICAgICBjb25zdCByID0gdGhpcy5hcGlbYV0gPSB7fSwgcyA9IGUuYXBpW2FdO1xuICAgICAgZm9yIChjb25zdCBvIGluIHMpIHJbb10gPSB0aGlzLl93cmFwcGVyKGEgKyBcIi5cIiArIG8pO1xuICAgIH1cbiAgICByZXR1cm4gaSAmJiB0aGlzLmNvbm5lY3QoKSwgdGhpcztcbiAgfVxuICBjb25uZWN0KCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLl9zb2NrZXQ7XG4gICAgZSAmJiAodGhpcy5fc29ja2V0ID0gbnVsbCwgZS5vbmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gICAgfSwgZS5jbG9zZSgpKSwgdGhpcy5fbW9kZSA9IDIsIHRoaXMuX3NvY2tldCA9IGZ1bmN0aW9uKG4sIGksIGEsIHIpIHtcbiAgICAgIGxldCBzID0gaTtcbiAgICAgIHNbMF0gPT09IFwiL1wiICYmIChzID0gZG9jdW1lbnQubG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKyBkb2N1bWVudC5sb2NhdGlvbi5ob3N0ICsgaSksIHMgPSBzLnJlcGxhY2UoL15odHRwKHN8KTovLCBcIndzJDE6XCIpO1xuICAgICAgY29uc3QgbyA9IHMuaW5kZXhPZihcIj9cIikgIT0gLTEgPyBcIiZcIiA6IFwiP1wiO1xuICAgICAgcyA9IGAke3N9JHtvfXRva2VuPSR7YX0md3M9MWA7XG4gICAgICBjb25zdCBsID0gbmV3IFdlYlNvY2tldChzKTtcbiAgICAgIHJldHVybiBsLm9uY2xvc2UgPSAoKSA9PiBzZXRUaW1lb3V0KCgpID0+IG4uY29ubmVjdCgpLCAyZTMpLCBsLm9ubWVzc2FnZSA9IChkKSA9PiB7XG4gICAgICAgIGNvbnN0IGMgPSBKU09OLnBhcnNlKGQuZGF0YSk7XG4gICAgICAgIHN3aXRjaCAoYy5hY3Rpb24pIHtcbiAgICAgICAgICBjYXNlIFwicmVzdWx0XCI6XG4gICAgICAgICAgICBuLnJlc3VsdChjLmJvZHksIFtdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJldmVudFwiOlxuICAgICAgICAgICAgbi5maXJlKGMuYm9keS5uYW1lLCBjLmJvZHkudmFsdWUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcInN0YXJ0XCI6XG4gICAgICAgICAgICByKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgbi5vbkVycm9yKGMuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH0sIGw7XG4gICAgfSh0aGlzLCB0aGlzLl91cmwsIHRoaXMuX3Rva2VuLCAoKSA9PiAodGhpcy5fbW9kZSA9IDMsIHRoaXMuX3NlbmQoKSwgdGhpcy5fcmVzdWJzY3JpYmUoKSwgdGhpcykpO1xuICB9XG4gIF93cmFwcGVyKGUpIHtcbiAgICByZXR1cm4gKGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgbiA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgIGxldCBpID0gbnVsbDtcbiAgICAgIGNvbnN0IGEgPSBuZXcgUHJvbWlzZSgociwgcykgPT4ge1xuICAgICAgICBpID0geyBkYXRhOiB7IGlkOiB0aGlzLl91aWQoKSwgbmFtZTogZSwgYXJnczogbiB9LCBzdGF0dXM6IDEsIHJlc29sdmU6IHIsIHJlamVjdDogcyB9LCB0aGlzLl9xdWV1ZS5wdXNoKGkpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcy5vbkNhbGwoaSwgYSksIHRoaXMuX21vZGUgPT09IDMgPyB0aGlzLl9zZW5kKGkpIDogc2V0VGltZW91dCgoKSA9PiB0aGlzLl9zZW5kKCksIDEpLCBhO1xuICAgIH0pLmJpbmQodGhpcyk7XG4gIH1cbiAgX3VpZCgpIHtcbiAgICByZXR1cm4gKHRoaXMuX3NlZWQrKykudG9TdHJpbmcoKTtcbiAgfVxuICBfc2VuZChlKSB7XG4gICAgaWYgKHRoaXMuX21vZGUgPT0gMikgcmV0dXJuIHZvaWQgc2V0VGltZW91dCgoKSA9PiB0aGlzLl9zZW5kKCksIDEwMCk7XG4gICAgY29uc3QgbiA9IGUgPyBbZV0gOiB0aGlzLl9xdWV1ZS5maWx0ZXIoKGEpID0+IGEuc3RhdHVzID09PSAxKTtcbiAgICBpZiAoIW4ubGVuZ3RoKSByZXR1cm47XG4gICAgY29uc3QgaSA9IG4ubWFwKChhKSA9PiAoYS5zdGF0dXMgPSAyLCBhLmRhdGEpKTtcbiAgICB0aGlzLl9tb2RlICE9PSAzID8gdGhpcy5mZXRjaCh0aGlzLl91cmwsIEpTT04uc3RyaW5naWZ5KGkpKS5jYXRjaCgoYSkgPT4gdGhpcy5vbkVycm9yKGEpKS50aGVuKChhKSA9PiB0aGlzLnJlc3VsdChhLCBpKSkgOiB0aGlzLl9zb2NrZXQuc2VuZChKU09OLnN0cmluZ2lmeSh7IGFjdGlvbjogXCJjYWxsXCIsIGJvZHk6IGkgfSkpO1xuICB9XG4gIHJlc3VsdChlLCBuKSB7XG4gICAgY29uc3QgaSA9IHt9O1xuICAgIGlmIChlKSBmb3IgKGxldCBhID0gMDsgYSA8IGUubGVuZ3RoOyBhKyspIGlbZVthXS5pZF0gPSBlW2FdO1xuICAgIGVsc2UgZm9yIChsZXQgYSA9IDA7IGEgPCBuLmxlbmd0aDsgYSsrKSBpW25bYV0uaWRdID0geyBpZDogblthXS5pZCwgZXJyb3I6IFwiTmV0d29yayBFcnJvclwiLCBkYXRhOiBudWxsIH07XG4gICAgZm9yIChsZXQgYSA9IHRoaXMuX3F1ZXVlLmxlbmd0aCAtIDE7IGEgPj0gMDsgYS0tKSB7XG4gICAgICBjb25zdCByID0gdGhpcy5fcXVldWVbYV0sIHMgPSBpW3IuZGF0YS5pZF07XG4gICAgICBzICYmICh0aGlzLm9uUmVzcG9uc2UociwgcyksIHMuZXJyb3IgPyByLnJlamVjdChzLmVycm9yKSA6IHIucmVzb2x2ZShzLmRhdGEpLCB0aGlzLl9xdWV1ZS5zcGxpY2UoYSwgMSkpO1xuICAgIH1cbiAgfVxuICBvbihlLCBuKSB7XG4gICAgY29uc3QgaSA9IHRoaXMuX3VpZCgpO1xuICAgIGxldCBhID0gdGhpcy5fZXZlbnRzW2VdO1xuICAgIGNvbnN0IHIgPSAhIWE7XG4gICAgcmV0dXJuIHIgfHwgKGEgPSB0aGlzLl9ldmVudHNbZV0gPSBbXSksIGEucHVzaCh7IGlkOiBpLCBoYW5kbGVyOiBuIH0pLCByIHx8IHRoaXMuX21vZGUgIT0gMyB8fCB0aGlzLl9zb2NrZXQuc2VuZChKU09OLnN0cmluZ2lmeSh7IGFjdGlvbjogXCJzdWJzY3JpYmVcIiwgbmFtZTogZSB9KSksIHsgbmFtZTogZSwgaWQ6IGkgfTtcbiAgfVxuICBfcmVzdWJzY3JpYmUoKSB7XG4gICAgaWYgKHRoaXMuX21vZGUgPT0gMykgZm9yIChjb25zdCBlIGluIHRoaXMuX2V2ZW50cykgdGhpcy5fc29ja2V0LnNlbmQoSlNPTi5zdHJpbmdpZnkoeyBhY3Rpb246IFwic3Vic2NyaWJlXCIsIG5hbWU6IGUgfSkpO1xuICB9XG4gIGRldGFjaChlKSB7XG4gICAgaWYgKCFlKSB7XG4gICAgICBpZiAodGhpcy5fbW9kZSA9PSAzKSBmb3IgKGNvbnN0IHIgaW4gdGhpcy5fZXZlbnRzKSB0aGlzLl9zb2NrZXQuc2VuZChKU09OLnN0cmluZ2lmeSh7IGFjdGlvbjogXCJ1bnN1YnNjcmliZVwiLCBrZXk6IHIgfSkpO1xuICAgICAgcmV0dXJuIHZvaWQgKHRoaXMuX2V2ZW50cyA9IHt9KTtcbiAgICB9XG4gICAgY29uc3QgeyBpZDogbiwgbmFtZTogaSB9ID0gZSwgYSA9IHRoaXMuX2V2ZW50c1tpXTtcbiAgICBpZiAoYSkge1xuICAgICAgY29uc3QgciA9IGEuZmlsdGVyKChzKSA9PiBzLmlkICE9IG4pO1xuICAgICAgci5sZW5ndGggPyB0aGlzLl9ldmVudHNbaV0gPSByIDogKGRlbGV0ZSB0aGlzLl9ldmVudHNbaV0sIHRoaXMuX21vZGUgPT0gMyAmJiB0aGlzLl9zb2NrZXQuc2VuZChKU09OLnN0cmluZ2lmeSh7IGFjdGlvbjogXCJ1bnN1YnNjcmliZVwiLCBuYW1lOiBpIH0pKSk7XG4gICAgfVxuICB9XG4gIGZpcmUoZSwgbikge1xuICAgIGNvbnN0IGkgPSB0aGlzLl9ldmVudHNbZV07XG4gICAgaWYgKGkpIGZvciAobGV0IGEgPSAwOyBhIDwgaS5sZW5ndGg7IGErKykgaVthXS5oYW5kbGVyKG4pO1xuICB9XG4gIG9uRXJyb3IoZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIG9uQ2FsbChlLCBuKSB7XG4gIH1cbiAgb25SZXNwb25zZShlLCBuKSB7XG4gIH1cbn1cbmNvbnN0IEpuID0gZnVuY3Rpb24odCwgZSkge1xuICBjb25zdCBuID0gbmV3IFluKHsgdXJsOiB0LCB0b2tlbjogZSB9KTtcbiAgbi5mZXRjaCA9IGZ1bmN0aW9uKGksIGEpIHtcbiAgICBjb25zdCByID0geyBoZWFkZXJzOiB0aGlzLmhlYWRlcnMoKSB9O1xuICAgIHJldHVybiBhICYmIChyLm1ldGhvZCA9IFwiUE9TVFwiLCByLmJvZHkgPSBhKSwgZmV0Y2goaSwgcikudGhlbigocykgPT4gcy5qc29uKCkpO1xuICB9LCB0aGlzLl9yZWFkeSA9IG4ubG9hZCgpLnRoZW4oKGkpID0+IHRoaXMuX3JlbW90ZSA9IGkpLCB0aGlzLnJlYWR5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWR5O1xuICB9LCB0aGlzLm9uID0gZnVuY3Rpb24oaSwgYSkge1xuICAgIHRoaXMucmVhZHkoKS50aGVuKChyKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIGkgPT0gXCJzdHJpbmdcIikgci5vbihpLCBhKTtcbiAgICAgIGVsc2UgZm9yIChjb25zdCBzIGluIGkpIHIub24ocywgaVtzXSk7XG4gICAgfSk7XG4gIH07XG59O1xuZnVuY3Rpb24gZG4odCwgZSkge1xuICBpZiAoIWUpIHJldHVybiAhMDtcbiAgaWYgKHQuX29uX3RpbWVvdXQpIHJldHVybiAhMTtcbiAgdmFyIG4gPSBNYXRoLmNlaWwoMWUzIC8gZSk7XG4gIHJldHVybiBuIDwgMiB8fCAoc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICBkZWxldGUgdC5fb25fdGltZW91dDtcbiAgfSwgbiksIHQuX29uX3RpbWVvdXQgPSAhMCksICEwO1xufVxudmFyIEtuID0gZnVuY3Rpb24oKSB7XG4gIHZhciB0ID0ge307XG4gIHJldHVybiB7IGdldFN0YXRlOiBmdW5jdGlvbihlKSB7XG4gICAgaWYgKHRbZV0pIHJldHVybiB0W2VdLm1ldGhvZCgpO1xuICAgIHZhciBuID0ge307XG4gICAgZm9yICh2YXIgaSBpbiB0KSB0W2ldLmludGVybmFsIHx8IFAobiwgdFtpXS5tZXRob2QoKSwgITApO1xuICAgIHJldHVybiBuO1xuICB9LCByZWdpc3RlclByb3ZpZGVyOiBmdW5jdGlvbihlLCBuLCBpKSB7XG4gICAgdFtlXSA9IHsgbWV0aG9kOiBuLCBpbnRlcm5hbDogaSB9O1xuICB9LCB1bnJlZ2lzdGVyUHJvdmlkZXI6IGZ1bmN0aW9uKGUpIHtcbiAgICBkZWxldGUgdFtlXTtcbiAgfSB9O1xufTtcbmNvbnN0IFhuID0gUHJvbWlzZTtcbnZhciB0dCA9IHsgJGNyZWF0ZTogZnVuY3Rpb24odCkge1xuICByZXR1cm4gUCh0IHx8IFtdLCB0aGlzKTtcbn0sICRyZW1vdmVBdDogZnVuY3Rpb24odCwgZSkge1xuICB0ID49IDAgJiYgdGhpcy5zcGxpY2UodCwgZSB8fCAxKTtcbn0sICRyZW1vdmU6IGZ1bmN0aW9uKHQpIHtcbiAgdGhpcy4kcmVtb3ZlQXQodGhpcy4kZmluZCh0KSk7XG59LCAkaW5zZXJ0QXQ6IGZ1bmN0aW9uKHQsIGUpIHtcbiAgaWYgKGUgfHwgZSA9PT0gMCkge1xuICAgIHZhciBuID0gdGhpcy5zcGxpY2UoZSwgdGhpcy5sZW5ndGggLSBlKTtcbiAgICB0aGlzW2VdID0gdCwgdGhpcy5wdXNoLmFwcGx5KHRoaXMsIG4pO1xuICB9IGVsc2UgdGhpcy5wdXNoKHQpO1xufSwgJGZpbmQ6IGZ1bmN0aW9uKHQpIHtcbiAgZm9yICh2YXIgZSA9IDA7IGUgPCB0aGlzLmxlbmd0aDsgZSsrKSBpZiAodCA9PSB0aGlzW2VdKSByZXR1cm4gZTtcbiAgcmV0dXJuIC0xO1xufSwgJGVhY2g6IGZ1bmN0aW9uKHQsIGUpIHtcbiAgZm9yICh2YXIgbiA9IDA7IG4gPCB0aGlzLmxlbmd0aDsgbisrKSB0LmNhbGwoZSB8fCB0aGlzLCB0aGlzW25dKTtcbn0sICRtYXA6IGZ1bmN0aW9uKHQsIGUpIHtcbiAgZm9yICh2YXIgbiA9IDA7IG4gPCB0aGlzLmxlbmd0aDsgbisrKSB0aGlzW25dID0gdC5jYWxsKGUgfHwgdGhpcywgdGhpc1tuXSk7XG4gIHJldHVybiB0aGlzO1xufSwgJGZpbHRlcjogZnVuY3Rpb24odCwgZSkge1xuICBmb3IgKHZhciBuID0gMDsgbiA8IHRoaXMubGVuZ3RoOyBuKyspIHQuY2FsbChlIHx8IHRoaXMsIHRoaXNbbl0pIHx8ICh0aGlzLnNwbGljZShuLCAxKSwgbi0tKTtcbiAgcmV0dXJuIHRoaXM7XG59IH07XG5mdW5jdGlvbiBSdCh0LCBlLCBuLCBpKSB7XG4gIHJldHVybiAoaSA9IGUgPyBlLmNvbmZpZyA6IGkpICYmIGkucGxhY2Vob2xkZXJfdGFzayAmJiBuLmV4aXN0cyh0KSA/IG4uZ2V0SXRlbSh0KS50eXBlID09PSBpLnR5cGVzLnBsYWNlaG9sZGVyIDogITE7XG59XG52YXIgaXQgPSBmdW5jdGlvbih0KSB7XG4gIHJldHVybiB0aGlzLnB1bGwgPSB7fSwgdGhpcy4kaW5pdEl0ZW0gPSB0LmluaXRJdGVtLCB0aGlzLnZpc2libGVPcmRlciA9IHR0LiRjcmVhdGUoKSwgdGhpcy5mdWxsT3JkZXIgPSB0dC4kY3JlYXRlKCksIHRoaXMuX3NraXBfcmVmcmVzaCA9ICExLCB0aGlzLl9maWx0ZXJSdWxlID0gbnVsbCwgdGhpcy5fc2VhcmNoVmlzaWJsZU9yZGVyID0ge30sIHRoaXMuX2luZGV4UmFuZ2VDYWNoZSA9IHt9LCB0aGlzLl9nZXRJdGVtc0NhY2hlID0gbnVsbCwgdGhpcy4kY29uZmlnID0gdCwgb3QodGhpcyksIHRoaXMuX2F0dGFjaERhdGFDaGFuZ2UoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2luZGV4UmFuZ2VDYWNoZSA9IHt9LCB0aGlzLl9nZXRJdGVtc0NhY2hlID0gbnVsbCwgITA7XG4gIH0pLCB0aGlzO1xufTtcbml0LnByb3RvdHlwZSA9IHsgX2F0dGFjaERhdGFDaGFuZ2U6IGZ1bmN0aW9uKHQpIHtcbiAgdGhpcy5hdHRhY2hFdmVudChcIm9uQ2xlYXJBbGxcIiwgdCksIHRoaXMuYXR0YWNoRXZlbnQoXCJvbkJlZm9yZVBhcnNlXCIsIHQpLCB0aGlzLmF0dGFjaEV2ZW50KFwib25CZWZvcmVVcGRhdGVcIiwgdCksIHRoaXMuYXR0YWNoRXZlbnQoXCJvbkJlZm9yZURlbGV0ZVwiLCB0KSwgdGhpcy5hdHRhY2hFdmVudChcIm9uQmVmb3JlQWRkXCIsIHQpLCB0aGlzLmF0dGFjaEV2ZW50KFwib25QYXJzZVwiLCB0KSwgdGhpcy5hdHRhY2hFdmVudChcIm9uQmVmb3JlRmlsdGVyXCIsIHQpO1xufSwgX3BhcnNlSW5uZXI6IGZ1bmN0aW9uKHQpIHtcbiAgZm9yICh2YXIgZSA9IG51bGwsIG4gPSBbXSwgaSA9IDAsIGEgPSB0Lmxlbmd0aDsgaSA8IGE7IGkrKykgZSA9IHRbaV0sIHRoaXMuJGluaXRJdGVtICYmICh0aGlzLiRjb25maWcuY29weU9uUGFyc2UoKSAmJiAoZSA9IHEoZSkpLCBlID0gdGhpcy4kaW5pdEl0ZW0oZSkpLCB0aGlzLmNhbGxFdmVudChcIm9uSXRlbUxvYWRpbmdcIiwgW2VdKSAmJiAodGhpcy5wdWxsLmhhc093blByb3BlcnR5KGUuaWQpIHx8IHRoaXMuZnVsbE9yZGVyLnB1c2goZS5pZCksIG4ucHVzaChlKSwgdGhpcy5wdWxsW2UuaWRdID0gZSk7XG4gIHJldHVybiBuO1xufSwgcGFyc2U6IGZ1bmN0aW9uKHQpIHtcbiAgdGhpcy5pc1NpbGVudCgpIHx8IHRoaXMuY2FsbEV2ZW50KFwib25CZWZvcmVQYXJzZVwiLCBbdF0pO1xuICB2YXIgZSA9IHRoaXMuX3BhcnNlSW5uZXIodCk7XG4gIHRoaXMuaXNTaWxlbnQoKSB8fCAodGhpcy5yZWZyZXNoKCksIHRoaXMuY2FsbEV2ZW50KFwib25QYXJzZVwiLCBbZV0pKTtcbn0sIGdldEl0ZW06IGZ1bmN0aW9uKHQpIHtcbiAgcmV0dXJuIHRoaXMucHVsbFt0XTtcbn0sIF91cGRhdGVPcmRlcjogZnVuY3Rpb24odCkge1xuICB0LmNhbGwodGhpcy52aXNpYmxlT3JkZXIpLCB0LmNhbGwodGhpcy5mdWxsT3JkZXIpO1xufSwgdXBkYXRlSXRlbTogZnVuY3Rpb24odCwgZSkge1xuICBpZiAoVyhlKSB8fCAoZSA9IHRoaXMuZ2V0SXRlbSh0KSksICF0aGlzLmlzU2lsZW50KCkgJiYgdGhpcy5jYWxsRXZlbnQoXCJvbkJlZm9yZVVwZGF0ZVwiLCBbZS5pZCwgZV0pID09PSAhMSkgcmV0dXJuICExO1xuICBQKHRoaXMucHVsbFt0XSwgZSwgITApLCB0aGlzLmlzU2lsZW50KCkgfHwgKHRoaXMuY2FsbEV2ZW50KFwib25BZnRlclVwZGF0ZVwiLCBbZS5pZCwgZV0pLCB0aGlzLmNhbGxFdmVudChcIm9uU3RvcmVVcGRhdGVkXCIsIFtlLmlkLCBlLCBcInVwZGF0ZVwiXSkpO1xufSwgX3JlbW92ZUl0ZW1Jbm5lcjogZnVuY3Rpb24odCkge1xuICB0aGlzLl91cGRhdGVPcmRlcihmdW5jdGlvbigpIHtcbiAgICB0aGlzLiRyZW1vdmUodCk7XG4gIH0pLCBkZWxldGUgdGhpcy5wdWxsW3RdO1xufSwgcmVtb3ZlSXRlbTogZnVuY3Rpb24odCkge1xuICB2YXIgZSA9IHRoaXMuZ2V0SXRlbSh0KTtcbiAgaWYgKCF0aGlzLmlzU2lsZW50KCkgJiYgdGhpcy5jYWxsRXZlbnQoXCJvbkJlZm9yZURlbGV0ZVwiLCBbZS5pZCwgZV0pID09PSAhMSkgcmV0dXJuICExO1xuICB0aGlzLmNhbGxFdmVudChcIm9uQWZ0ZXJEZWxldGVDb25maXJtZWRcIiwgW2UuaWQsIGVdKSwgdGhpcy5fcmVtb3ZlSXRlbUlubmVyKHQpLCB0aGlzLmlzU2lsZW50KCkgJiYgdGhpcy5jYWxsRXZlbnQoXCJvbkFmdGVyU2lsZW50RGVsZXRlXCIsIFtlLmlkLCBlXSksIHRoaXMuaXNTaWxlbnQoKSB8fCAodGhpcy5maWx0ZXIoKSwgdGhpcy5jYWxsRXZlbnQoXCJvbkFmdGVyRGVsZXRlXCIsIFtlLmlkLCBlXSksIHRoaXMuY2FsbEV2ZW50KFwib25TdG9yZVVwZGF0ZWRcIiwgW2UuaWQsIGUsIFwiZGVsZXRlXCJdKSk7XG59LCBfYWRkSXRlbUlubmVyOiBmdW5jdGlvbih0LCBlKSB7XG4gIGlmICh0aGlzLmV4aXN0cyh0LmlkKSkgdGhpcy5zaWxlbnQoZnVuY3Rpb24oKSB7XG4gICAgdGhpcy51cGRhdGVJdGVtKHQuaWQsIHQpO1xuICB9KTtcbiAgZWxzZSB7XG4gICAgdmFyIG4gPSB0aGlzLnZpc2libGVPcmRlciwgaSA9IG4ubGVuZ3RoO1xuICAgICghVyhlKSB8fCBlIDwgMCkgJiYgKGUgPSBpKSwgZSA+IGkgJiYgKGUgPSBNYXRoLm1pbihuLmxlbmd0aCwgZSkpO1xuICB9XG4gIHRoaXMucHVsbFt0LmlkXSA9IHQsIHRoaXMuX3VwZGF0ZU9yZGVyKGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuJGZpbmQodC5pZCkgPT09IC0xICYmIHRoaXMuJGluc2VydEF0KHQuaWQsIGUpO1xuICB9KSwgdGhpcy5maWx0ZXIoKTtcbn0sIGlzVmlzaWJsZTogZnVuY3Rpb24odCkge1xuICByZXR1cm4gdGhpcy52aXNpYmxlT3JkZXIuJGZpbmQodCkgPiAtMTtcbn0sIGdldFZpc2libGVJdGVtczogZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmdldEluZGV4UmFuZ2UoKTtcbn0sIGFkZEl0ZW06IGZ1bmN0aW9uKHQsIGUpIHtcbiAgcmV0dXJuIFcodC5pZCkgfHwgKHQuaWQgPSBzdCgpKSwgdGhpcy4kaW5pdEl0ZW0gJiYgKHQgPSB0aGlzLiRpbml0SXRlbSh0KSksICEoIXRoaXMuaXNTaWxlbnQoKSAmJiB0aGlzLmNhbGxFdmVudChcIm9uQmVmb3JlQWRkXCIsIFt0LmlkLCB0XSkgPT09ICExKSAmJiAodGhpcy5fYWRkSXRlbUlubmVyKHQsIGUpLCB0aGlzLmlzU2lsZW50KCkgfHwgKHRoaXMuY2FsbEV2ZW50KFwib25BZnRlckFkZFwiLCBbdC5pZCwgdF0pLCB0aGlzLmNhbGxFdmVudChcIm9uU3RvcmVVcGRhdGVkXCIsIFt0LmlkLCB0LCBcImFkZFwiXSkpLCB0LmlkKTtcbn0sIF9jaGFuZ2VJZElubmVyOiBmdW5jdGlvbih0LCBlKSB7XG4gIHRoaXMucHVsbFt0XSAmJiAodGhpcy5wdWxsW2VdID0gdGhpcy5wdWxsW3RdKTtcbiAgdmFyIG4gPSB0aGlzLl9zZWFyY2hWaXNpYmxlT3JkZXJbdF07XG4gIHRoaXMucHVsbFtlXS5pZCA9IGUsIHRoaXMuX3VwZGF0ZU9yZGVyKGZ1bmN0aW9uKCkge1xuICAgIHRoaXNbdGhpcy4kZmluZCh0KV0gPSBlO1xuICB9KSwgdGhpcy5fc2VhcmNoVmlzaWJsZU9yZGVyW2VdID0gbiwgZGVsZXRlIHRoaXMuX3NlYXJjaFZpc2libGVPcmRlclt0XSwgZGVsZXRlIHRoaXMucHVsbFt0XTtcbn0sIGNoYW5nZUlkOiBmdW5jdGlvbih0LCBlKSB7XG4gIHRoaXMuX2NoYW5nZUlkSW5uZXIodCwgZSksIHRoaXMuY2FsbEV2ZW50KFwib25JZENoYW5nZVwiLCBbdCwgZV0pO1xufSwgZXhpc3RzOiBmdW5jdGlvbih0KSB7XG4gIHJldHVybiAhIXRoaXMucHVsbFt0XTtcbn0sIF9tb3ZlSW5uZXI6IGZ1bmN0aW9uKHQsIGUpIHtcbiAgdmFyIG4gPSB0aGlzLmdldElkQnlJbmRleCh0KTtcbiAgdGhpcy5fdXBkYXRlT3JkZXIoZnVuY3Rpb24oKSB7XG4gICAgdGhpcy4kcmVtb3ZlQXQodCksIHRoaXMuJGluc2VydEF0KG4sIE1hdGgubWluKHRoaXMubGVuZ3RoLCBlKSk7XG4gIH0pO1xufSwgbW92ZTogZnVuY3Rpb24odCwgZSkge1xuICB2YXIgbiA9IHRoaXMuZ2V0SWRCeUluZGV4KHQpLCBpID0gdGhpcy5nZXRJdGVtKG4pO1xuICB0aGlzLl9tb3ZlSW5uZXIodCwgZSksIHRoaXMuaXNTaWxlbnQoKSB8fCB0aGlzLmNhbGxFdmVudChcIm9uU3RvcmVVcGRhdGVkXCIsIFtpLmlkLCBpLCBcIm1vdmVcIl0pO1xufSwgY2xlYXJBbGw6IGZ1bmN0aW9uKCkge1xuICB0aGlzLiRkZXN0cm95ZWQgfHwgKHRoaXMuc2lsZW50KGZ1bmN0aW9uKCkge1xuICAgIHRoaXMudW5zZWxlY3QoKTtcbiAgfSksIHRoaXMucHVsbCA9IHt9LCB0aGlzLnZpc2libGVPcmRlciA9IHR0LiRjcmVhdGUoKSwgdGhpcy5mdWxsT3JkZXIgPSB0dC4kY3JlYXRlKCksIHRoaXMuaXNTaWxlbnQoKSB8fCAodGhpcy5jYWxsRXZlbnQoXCJvbkNsZWFyQWxsXCIsIFtdKSwgdGhpcy5yZWZyZXNoKCkpKTtcbn0sIHNpbGVudDogZnVuY3Rpb24odCwgZSkge1xuICB2YXIgbiA9ICExO1xuICB0aGlzLmlzU2lsZW50KCkgJiYgKG4gPSAhMCksIHRoaXMuX3NraXBfcmVmcmVzaCA9ICEwLCB0LmNhbGwoZSB8fCB0aGlzKSwgbiB8fCAodGhpcy5fc2tpcF9yZWZyZXNoID0gITEpO1xufSwgaXNTaWxlbnQ6IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gISF0aGlzLl9za2lwX3JlZnJlc2g7XG59LCBhcnJheXNFcXVhbDogZnVuY3Rpb24odCwgZSkge1xuICBpZiAodC5sZW5ndGggIT09IGUubGVuZ3RoKSByZXR1cm4gITE7XG4gIGZvciAodmFyIG4gPSAwOyBuIDwgdC5sZW5ndGg7IG4rKykgaWYgKHRbbl0gIT09IGVbbl0pIHJldHVybiAhMTtcbiAgcmV0dXJuICEwO1xufSwgcmVmcmVzaDogZnVuY3Rpb24odCwgZSkge1xuICB2YXIgbiwgaTtcbiAgaWYgKCF0aGlzLiRkZXN0cm95ZWQgJiYgIXRoaXMuaXNTaWxlbnQoKSAmJiAodCAmJiAobiA9IHRoaXMuZ2V0SXRlbSh0KSksIGkgPSB0ID8gW3QsIG4sIFwicGFpbnRcIl0gOiBbbnVsbCwgbnVsbCwgbnVsbF0sIHRoaXMuY2FsbEV2ZW50KFwib25CZWZvcmVTdG9yZVVwZGF0ZVwiLCBpKSAhPT0gITEpKSB7XG4gICAgdmFyIGEgPSB0aGlzLl9xdWlja19yZWZyZXNoICYmICF0aGlzLl9tYXJrX3JlY29tcHV0ZTtcbiAgICBpZiAodGhpcy5fbWFya19yZWNvbXB1dGUgPSAhMSwgdCkge1xuICAgICAgaWYgKCFlICYmICFhKSB7XG4gICAgICAgIHZhciByID0gdGhpcy52aXNpYmxlT3JkZXI7XG4gICAgICAgIHRoaXMuZmlsdGVyKCksIHRoaXMuYXJyYXlzRXF1YWwociwgdGhpcy52aXNpYmxlT3JkZXIpIHx8ICh0ID0gdm9pZCAwKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgYSB8fCB0aGlzLmZpbHRlcigpO1xuICAgIGkgPSB0ID8gW3QsIG4sIFwicGFpbnRcIl0gOiBbbnVsbCwgbnVsbCwgbnVsbF0sIHRoaXMuY2FsbEV2ZW50KFwib25TdG9yZVVwZGF0ZWRcIiwgaSk7XG4gIH1cbn0sIGNvdW50OiBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuZnVsbE9yZGVyLmxlbmd0aDtcbn0sIGNvdW50VmlzaWJsZTogZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnZpc2libGVPcmRlci5sZW5ndGg7XG59LCBzb3J0OiBmdW5jdGlvbih0KSB7XG59LCBzZXJpYWxpemU6IGZ1bmN0aW9uKCkge1xufSwgZWFjaEl0ZW06IGZ1bmN0aW9uKHQpIHtcbiAgZm9yICh2YXIgZSA9IDA7IGUgPCB0aGlzLmZ1bGxPcmRlci5sZW5ndGg7IGUrKykge1xuICAgIHZhciBuID0gdGhpcy5nZXRJdGVtKHRoaXMuZnVsbE9yZGVyW2VdKTtcbiAgICB0LmNhbGwodGhpcywgbik7XG4gIH1cbn0sIGZpbmQ6IGZ1bmN0aW9uKHQpIHtcbiAgdmFyIGUgPSBbXTtcbiAgcmV0dXJuIHRoaXMuZWFjaEl0ZW0oZnVuY3Rpb24obikge1xuICAgIHQobikgJiYgZS5wdXNoKG4pO1xuICB9KSwgZTtcbn0sIGZpbHRlcjogZnVuY3Rpb24odCkge1xuICB0aGlzLmlzU2lsZW50KCkgfHwgdGhpcy5jYWxsRXZlbnQoXCJvbkJlZm9yZUZpbHRlclwiLCBbXSksIHRoaXMuY2FsbEV2ZW50KFwib25QcmVGaWx0ZXJcIiwgW10pO1xuICB2YXIgZSA9IHR0LiRjcmVhdGUoKSwgbiA9IFtdO1xuICB0aGlzLmVhY2hJdGVtKGZ1bmN0aW9uKGEpIHtcbiAgICB0aGlzLmNhbGxFdmVudChcIm9uRmlsdGVySXRlbVwiLCBbYS5pZCwgYV0pICYmIChSdChhLmlkLCBudWxsLCB0aGlzLCB0aGlzLl9nYW50dENvbmZpZykgPyBuLnB1c2goYS5pZCkgOiBlLnB1c2goYS5pZCkpO1xuICB9KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuLmxlbmd0aDsgaSsrKSBlLnB1c2gobltpXSk7XG4gIGZvciAodGhpcy52aXNpYmxlT3JkZXIgPSBlLCB0aGlzLl9zZWFyY2hWaXNpYmxlT3JkZXIgPSB7fSwgaSA9IDA7IGkgPCB0aGlzLnZpc2libGVPcmRlci5sZW5ndGg7IGkrKykgdGhpcy5fc2VhcmNoVmlzaWJsZU9yZGVyW3RoaXMudmlzaWJsZU9yZGVyW2ldXSA9IGk7XG4gIHRoaXMuaXNTaWxlbnQoKSB8fCB0aGlzLmNhbGxFdmVudChcIm9uRmlsdGVyXCIsIFtdKTtcbn0sIGdldEluZGV4UmFuZ2U6IGZ1bmN0aW9uKHQsIGUpIHtcbiAgdmFyIG4gPSBNYXRoLm1pbihlIHx8IDEgLyAwLCB0aGlzLmNvdW50VmlzaWJsZSgpIC0gMSksIGkgPSB0IHx8IDAsIGEgPSBpICsgXCItXCIgKyBuO1xuICBpZiAodGhpcy5faW5kZXhSYW5nZUNhY2hlW2FdKSByZXR1cm4gdGhpcy5faW5kZXhSYW5nZUNhY2hlW2FdLnNsaWNlKCk7XG4gIGZvciAodmFyIHIgPSBbXSwgcyA9IGk7IHMgPD0gbjsgcysrKSByLnB1c2godGhpcy5nZXRJdGVtKHRoaXMudmlzaWJsZU9yZGVyW3NdKSk7XG4gIHJldHVybiB0aGlzLl9pbmRleFJhbmdlQ2FjaGVbYV0gPSByLnNsaWNlKCksIHI7XG59LCBnZXRJdGVtczogZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9nZXRJdGVtc0NhY2hlKSByZXR1cm4gdGhpcy5fZ2V0SXRlbXNDYWNoZS5zbGljZSgpO1xuICB2YXIgdCA9IFtdO1xuICBmb3IgKHZhciBlIGluIHRoaXMucHVsbCkgdC5wdXNoKHRoaXMucHVsbFtlXSk7XG4gIHJldHVybiB0aGlzLl9nZXRJdGVtc0NhY2hlID0gdC5zbGljZSgpLCB0O1xufSwgZ2V0SWRCeUluZGV4OiBmdW5jdGlvbih0KSB7XG4gIHJldHVybiB0aGlzLnZpc2libGVPcmRlclt0XTtcbn0sIGdldEluZGV4QnlJZDogZnVuY3Rpb24odCkge1xuICB2YXIgZSA9IHRoaXMuX3NlYXJjaFZpc2libGVPcmRlclt0XTtcbiAgcmV0dXJuIGUgPT09IHZvaWQgMCAmJiAoZSA9IC0xKSwgZTtcbn0sIF9nZXROdWxsSWZVbmRlZmluZWQ6IGZ1bmN0aW9uKHQpIHtcbiAgcmV0dXJuIHQgPT09IHZvaWQgMCA/IG51bGwgOiB0O1xufSwgZ2V0Rmlyc3Q6IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fZ2V0TnVsbElmVW5kZWZpbmVkKHRoaXMudmlzaWJsZU9yZGVyWzBdKTtcbn0sIGdldExhc3Q6IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fZ2V0TnVsbElmVW5kZWZpbmVkKHRoaXMudmlzaWJsZU9yZGVyW3RoaXMudmlzaWJsZU9yZGVyLmxlbmd0aCAtIDFdKTtcbn0sIGdldE5leHQ6IGZ1bmN0aW9uKHQpIHtcbiAgcmV0dXJuIHRoaXMuX2dldE51bGxJZlVuZGVmaW5lZCh0aGlzLnZpc2libGVPcmRlclt0aGlzLmdldEluZGV4QnlJZCh0KSArIDFdKTtcbn0sIGdldFByZXY6IGZ1bmN0aW9uKHQpIHtcbiAgcmV0dXJuIHRoaXMuX2dldE51bGxJZlVuZGVmaW5lZCh0aGlzLnZpc2libGVPcmRlclt0aGlzLmdldEluZGV4QnlJZCh0KSAtIDFdKTtcbn0sIGRlc3RydWN0b3I6IGZ1bmN0aW9uKCkge1xuICB0aGlzLmNhbGxFdmVudChcIm9uRGVzdHJveVwiLCBbXSksIHRoaXMuZGV0YWNoQWxsRXZlbnRzKCksIHRoaXMuJGRlc3Ryb3llZCA9ICEwLCB0aGlzLnB1bGwgPSBudWxsLCB0aGlzLiRpbml0SXRlbSA9IG51bGwsIHRoaXMudmlzaWJsZU9yZGVyID0gbnVsbCwgdGhpcy5mdWxsT3JkZXIgPSBudWxsLCB0aGlzLl9za2lwX3JlZnJlc2ggPSBudWxsLCB0aGlzLl9maWx0ZXJSdWxlID0gbnVsbCwgdGhpcy5fc2VhcmNoVmlzaWJsZU9yZGVyID0gbnVsbCwgdGhpcy5faW5kZXhSYW5nZUNhY2hlID0ge307XG59IH07XG52YXIgY24gPSBmdW5jdGlvbih0KSB7XG4gIHZhciBlO1xuICBpdC5hcHBseSh0aGlzLCBbdF0pLCB0aGlzLl9icmFuY2hlcyA9IHt9LCB0aGlzLnB1bGwgPSB7fSwgdGhpcy4kaW5pdEl0ZW0gPSBmdW5jdGlvbihvKSB7XG4gICAgdmFyIGwgPSBvO1xuICAgIHQuaW5pdEl0ZW0gJiYgKGwgPSB0LmluaXRJdGVtKGwpKTtcbiAgICB2YXIgZCA9IHRoaXMuZ2V0SXRlbShvLmlkKTtcbiAgICByZXR1cm4gZCAmJiAhbHQoZC5wYXJlbnQsIGwucGFyZW50KSAmJiB0aGlzLm1vdmUobC5pZCwgbC4kaW5kZXggfHwgLTEsIGwucGFyZW50IHx8IHRoaXMuX2dhbnR0Q29uZmlnLnJvb3RfaWQpLCBsO1xuICB9LCB0aGlzLiRwYXJlbnRQcm9wZXJ0eSA9IHQucGFyZW50UHJvcGVydHkgfHwgXCJwYXJlbnRcIiwgdHlwZW9mIHQucm9vdElkICE9IFwiZnVuY3Rpb25cIiA/IHRoaXMuJGdldFJvb3RJZCA9IChlID0gdC5yb290SWQgfHwgMCwgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGU7XG4gIH0pIDogdGhpcy4kZ2V0Um9vdElkID0gdC5yb290SWQsIHRoaXMuJG9wZW5Jbml0aWFsbHkgPSB0Lm9wZW5Jbml0aWFsbHksIHRoaXMudmlzaWJsZU9yZGVyID0gdHQuJGNyZWF0ZSgpLCB0aGlzLmZ1bGxPcmRlciA9IHR0LiRjcmVhdGUoKSwgdGhpcy5fc2VhcmNoVmlzaWJsZU9yZGVyID0ge30sIHRoaXMuX2luZGV4UmFuZ2VDYWNoZSA9IHt9LCB0aGlzLl9lYWNoSXRlbU1haW5SYW5nZUNhY2hlID0gbnVsbCwgdGhpcy5fZ2V0SXRlbXNDYWNoZSA9IG51bGwsIHRoaXMuX3NraXBfcmVmcmVzaCA9ICExLCB0aGlzLl9nYW50dENvbmZpZyA9IG51bGwsIHQuZ2V0Q29uZmlnICYmICh0aGlzLl9nYW50dENvbmZpZyA9IHQuZ2V0Q29uZmlnKCkpO1xuICB2YXIgbiA9IHt9LCBpID0ge30sIGEgPSB7fSwgciA9IHt9LCBzID0gITE7XG4gIHJldHVybiB0aGlzLl9hdHRhY2hEYXRhQ2hhbmdlKGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9pbmRleFJhbmdlQ2FjaGUgPSB7fSwgdGhpcy5fZWFjaEl0ZW1NYWluUmFuZ2VDYWNoZSA9IG51bGwsIHRoaXMuX2dldEl0ZW1zQ2FjaGUgPSBudWxsLCAhMDtcbiAgfSksIHRoaXMuYXR0YWNoRXZlbnQoXCJvblByZUZpbHRlclwiLCBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9pbmRleFJhbmdlQ2FjaGUgPSB7fSwgdGhpcy5fZWFjaEl0ZW1NYWluUmFuZ2VDYWNoZSA9IG51bGwsIG4gPSB7fSwgaSA9IHt9LCBhID0ge30sIHIgPSB7fSwgcyA9ICExLCB0aGlzLmVhY2hJdGVtKGZ1bmN0aW9uKG8pIHtcbiAgICAgIHZhciBsID0gdGhpcy5nZXRQYXJlbnQoby5pZCk7XG4gICAgICBvLiRvcGVuICYmIGFbbF0gIT09ICExID8gYVtvLmlkXSA9ICEwIDogYVtvLmlkXSA9ICExLCB0aGlzLl9pc1NwbGl0SXRlbShvKSAmJiAocyA9ICEwLCBuW28uaWRdID0gITAsIGlbby5pZF0gPSAhMCksIHMgJiYgaVtsXSAmJiAoaVtvLmlkXSA9ICEwKSwgYVtsXSB8fCBhW2xdID09PSB2b2lkIDAgPyByW28uaWRdID0gITAgOiByW28uaWRdID0gITE7XG4gICAgfSk7XG4gIH0pLCB0aGlzLmF0dGFjaEV2ZW50KFwib25GaWx0ZXJJdGVtXCIsIGZ1bmN0aW9uKG8sIGwpIHtcbiAgICB2YXIgZCA9ICExO1xuICAgIHRoaXMuX2dhbnR0Q29uZmlnICYmIChkID0gdGhpcy5fZ2FudHRDb25maWcub3Blbl9zcGxpdF90YXNrcyk7XG4gICAgdmFyIGMgPSByW2wuaWRdO1xuICAgIHJldHVybiBzICYmIChjICYmIGlbbC5pZF0gJiYgIW5bbC5pZF0gJiYgKGMgPSAhIWQpLCBpW2wuaWRdICYmICFuW2wuaWRdICYmIChsLiRzcGxpdF9zdWJ0YXNrID0gITApKSwgbC4kZXhwYW5kZWRfYnJhbmNoID0gISFyW2wuaWRdLCAhIWM7XG4gIH0pLCB0aGlzLmF0dGFjaEV2ZW50KFwib25GaWx0ZXJcIiwgZnVuY3Rpb24oKSB7XG4gICAgbiA9IHt9LCBpID0ge30sIGEgPSB7fSwgciA9IHt9O1xuICB9KSwgdGhpcztcbn07XG5mdW5jdGlvbiBsdCh0LCBlKSB7XG4gIHJldHVybiBTdHJpbmcodCkgPT09IFN0cmluZyhlKTtcbn1cbmZ1bmN0aW9uIEYodCkge1xuICByZXR1cm4gbXQuaXNOb2RlIHx8ICF0LiRyb290O1xufVxuY24ucHJvdG90eXBlID0gUCh7IF9idWlsZFRyZWU6IGZ1bmN0aW9uKHQpIHtcbiAgZm9yICh2YXIgZSA9IG51bGwsIG4gPSB0aGlzLiRnZXRSb290SWQoKSwgaSA9IDAsIGEgPSB0Lmxlbmd0aDsgaSA8IGE7IGkrKykgZSA9IHRbaV0sIHRoaXMuc2V0UGFyZW50KGUsIGF0KHRoaXMuZ2V0UGFyZW50KGUpLCBuKSB8fCBuKTtcbiAgZm9yIChpID0gMCwgYSA9IHQubGVuZ3RoOyBpIDwgYTsgaSsrKSBlID0gdFtpXSwgdGhpcy5fYWRkX2JyYW5jaChlKSwgZS4kbGV2ZWwgPSB0aGlzLmNhbGN1bGF0ZUl0ZW1MZXZlbChlKSwgZS4kbG9jYWxfaW5kZXggPSB0aGlzLmdldEJyYW5jaEluZGV4KGUuaWQpLCBXKGUuJG9wZW4pIHx8IChlLiRvcGVuID0gVyhlLm9wZW4pID8gZS5vcGVuIDogdGhpcy4kb3BlbkluaXRpYWxseSgpKTtcbiAgdGhpcy5fdXBkYXRlT3JkZXIoKTtcbn0sIF9pc1NwbGl0SXRlbTogZnVuY3Rpb24odCkge1xuICByZXR1cm4gdC5yZW5kZXIgPT0gXCJzcGxpdFwiICYmIHRoaXMuaGFzQ2hpbGQodC5pZCk7XG59LCBwYXJzZTogZnVuY3Rpb24odCkge1xuICB0aGlzLl9za2lwX3JlZnJlc2ggfHwgdGhpcy5jYWxsRXZlbnQoXCJvbkJlZm9yZVBhcnNlXCIsIFt0XSk7XG4gIHZhciBlID0gdGhpcy5fcGFyc2VJbm5lcih0KTtcbiAgdGhpcy5fYnVpbGRUcmVlKGUpLCB0aGlzLmZpbHRlcigpLCB0aGlzLl9za2lwX3JlZnJlc2ggfHwgdGhpcy5jYWxsRXZlbnQoXCJvblBhcnNlXCIsIFtlXSk7XG59LCBfYWRkSXRlbUlubmVyOiBmdW5jdGlvbih0LCBlKSB7XG4gIHZhciBuID0gdGhpcy5nZXRQYXJlbnQodCk7XG4gIFcobikgfHwgKG4gPSB0aGlzLiRnZXRSb290SWQoKSwgdGhpcy5zZXRQYXJlbnQodCwgbikpO1xuICB2YXIgaSA9IHRoaXMuZ2V0SW5kZXhCeUlkKG4pICsgTWF0aC5taW4oTWF0aC5tYXgoZSwgMCksIHRoaXMudmlzaWJsZU9yZGVyLmxlbmd0aCk7XG4gIDEgKiBpICE9PSBpICYmIChpID0gdm9pZCAwKSwgaXQucHJvdG90eXBlLl9hZGRJdGVtSW5uZXIuY2FsbCh0aGlzLCB0LCBpKSwgdGhpcy5zZXRQYXJlbnQodCwgbiksIHQuaGFzT3duUHJvcGVydHkoXCIkcmVuZGVyZWRfcGFyZW50XCIpICYmIHRoaXMuX21vdmVfYnJhbmNoKHQsIHQuJHJlbmRlcmVkX3BhcmVudCksIHRoaXMuX2FkZF9icmFuY2godCwgZSk7XG59LCBfY2hhbmdlSWRJbm5lcjogZnVuY3Rpb24odCwgZSkge1xuICB2YXIgbiA9IHRoaXMuZ2V0Q2hpbGRyZW4odCksIGkgPSB0aGlzLl9zZWFyY2hWaXNpYmxlT3JkZXJbdF07XG4gIGl0LnByb3RvdHlwZS5fY2hhbmdlSWRJbm5lci5jYWxsKHRoaXMsIHQsIGUpO1xuICB2YXIgYSA9IHRoaXMuZ2V0UGFyZW50KGUpO1xuICB0aGlzLl9yZXBsYWNlX2JyYW5jaF9jaGlsZChhLCB0LCBlKSwgdGhpcy5fYnJhbmNoZXNbdF0gJiYgKHRoaXMuX2JyYW5jaGVzW2VdID0gdGhpcy5fYnJhbmNoZXNbdF0pO1xuICBmb3IgKHZhciByID0gMDsgciA8IG4ubGVuZ3RoOyByKyspIHtcbiAgICB2YXIgcyA9IHRoaXMuZ2V0SXRlbShuW3JdKTtcbiAgICBzW3RoaXMuJHBhcmVudFByb3BlcnR5XSA9IGUsIHMuJHJlbmRlcmVkX3BhcmVudCA9IGU7XG4gIH1cbiAgdGhpcy5fc2VhcmNoVmlzaWJsZU9yZGVyW2VdID0gaSwgZGVsZXRlIHRoaXMuX2JyYW5jaGVzW3RdO1xufSwgX3RyYXZlcnNlQnJhbmNoZXM6IGZ1bmN0aW9uKHQsIGUpIHtcbiAgVyhlKSB8fCAoZSA9IHRoaXMuJGdldFJvb3RJZCgpKTtcbiAgdmFyIG4gPSB0aGlzLl9icmFuY2hlc1tlXTtcbiAgaWYgKG4pIGZvciAodmFyIGkgPSAwOyBpIDwgbi5sZW5ndGg7IGkrKykge1xuICAgIHZhciBhID0gbltpXTtcbiAgICB0LmNhbGwodGhpcywgYSksIHRoaXMuX2JyYW5jaGVzW2FdICYmIHRoaXMuX3RyYXZlcnNlQnJhbmNoZXModCwgYSk7XG4gIH1cbn0sIF91cGRhdGVPcmRlcjogZnVuY3Rpb24odCkge1xuICB0aGlzLmZ1bGxPcmRlciA9IHR0LiRjcmVhdGUoKSwgdGhpcy5fdHJhdmVyc2VCcmFuY2hlcyhmdW5jdGlvbihlKSB7XG4gICAgdGhpcy5mdWxsT3JkZXIucHVzaChlKTtcbiAgfSksIHQgJiYgaXQucHJvdG90eXBlLl91cGRhdGVPcmRlci5jYWxsKHRoaXMsIHQpO1xufSwgX3JlbW92ZUl0ZW1Jbm5lcjogZnVuY3Rpb24odCkge1xuICB2YXIgZSA9IFtdO1xuICB0aGlzLmVhY2hJdGVtKGZ1bmN0aW9uKGkpIHtcbiAgICBlLnB1c2goaSk7XG4gIH0sIHQpLCBlLnB1c2godGhpcy5nZXRJdGVtKHQpKTtcbiAgZm9yICh2YXIgbiA9IDA7IG4gPCBlLmxlbmd0aDsgbisrKSB0aGlzLl9tb3ZlX2JyYW5jaChlW25dLCB0aGlzLmdldFBhcmVudChlW25dKSwgbnVsbCksIGl0LnByb3RvdHlwZS5fcmVtb3ZlSXRlbUlubmVyLmNhbGwodGhpcywgZVtuXS5pZCksIHRoaXMuX21vdmVfYnJhbmNoKGVbbl0sIHRoaXMuZ2V0UGFyZW50KGVbbl0pLCBudWxsKTtcbn0sIG1vdmU6IGZ1bmN0aW9uKHQsIGUsIG4pIHtcbiAgdmFyIGkgPSBhcmd1bWVudHNbM10sIGEgPSAodGhpcy5fZ2FudHRDb25maWcgfHwge30pLnJvb3RfaWQgfHwgMDtcbiAgaWYgKGkgPSBhdChpLCBhKSkge1xuICAgIGlmIChpID09PSB0KSByZXR1cm47XG4gICAgbiA9IHRoaXMuZ2V0UGFyZW50KGkpLCBlID0gdGhpcy5nZXRCcmFuY2hJbmRleChpKTtcbiAgfVxuICBpZiAoIWx0KHQsIG4pKSB7XG4gICAgVyhuKSB8fCAobiA9IHRoaXMuJGdldFJvb3RJZCgpKTtcbiAgICB2YXIgciA9IHRoaXMuZ2V0SXRlbSh0KSwgcyA9IHRoaXMuZ2V0UGFyZW50KHIuaWQpLCBvID0gdGhpcy5nZXRDaGlsZHJlbihuKTtcbiAgICBpZiAoZSA9PSAtMSAmJiAoZSA9IG8ubGVuZ3RoICsgMSksIGx0KHMsIG4pICYmIHRoaXMuZ2V0QnJhbmNoSW5kZXgodCkgPT0gZSkgcmV0dXJuO1xuICAgIGlmICh0aGlzLmNhbGxFdmVudChcIm9uQmVmb3JlSXRlbU1vdmVcIiwgW3QsIG4sIGVdKSA9PT0gITEpIHJldHVybiAhMTtcbiAgICBmb3IgKHZhciBsID0gW10sIGQgPSAwOyBkIDwgby5sZW5ndGg7IGQrKykgUnQob1tkXSwgbnVsbCwgdGhpcywgdGhpcy5fZ2FudHRDb25maWcpICYmIChsLnB1c2gob1tkXSksIG8uc3BsaWNlKGQsIDEpLCBkLS0pO1xuICAgIHRoaXMuX3JlcGxhY2VfYnJhbmNoX2NoaWxkKHMsIHQpO1xuICAgIHZhciBjID0gKG8gPSB0aGlzLmdldENoaWxkcmVuKG4pKVtlXTtcbiAgICAoYyA9IGF0KGMsIGEpKSA/IG8gPSBvLnNsaWNlKDAsIGUpLmNvbmNhdChbdF0pLmNvbmNhdChvLnNsaWNlKGUpKSA6IG8ucHVzaCh0KSwgbC5sZW5ndGggJiYgKG8gPSBvLmNvbmNhdChsKSksIGx0KHIuJHJlbmRlcmVkX3BhcmVudCwgcykgfHwgbHQocywgbikgfHwgKHIuJHJlbmRlcmVkX3BhcmVudCA9IHMpLCB0aGlzLnNldFBhcmVudChyLCBuKSwgdGhpcy5fYnJhbmNoZXNbbl0gPSBvO1xuICAgIHZhciB1ID0gdGhpcy5jYWxjdWxhdGVJdGVtTGV2ZWwocikgLSByLiRsZXZlbDtcbiAgICByLiRsZXZlbCArPSB1LCB0aGlzLmVhY2hJdGVtKGZ1bmN0aW9uKGgpIHtcbiAgICAgIGguJGxldmVsICs9IHU7XG4gICAgfSwgci5pZCwgdGhpcyksIHRoaXMuX21vdmVJbm5lcih0aGlzLmdldEluZGV4QnlJZCh0KSwgdGhpcy5nZXRJbmRleEJ5SWQobikgKyBlKSwgdGhpcy5jYWxsRXZlbnQoXCJvbkFmdGVySXRlbU1vdmVcIiwgW3QsIG4sIGVdKSwgdGhpcy5yZWZyZXNoKCk7XG4gIH1cbn0sIGdldEJyYW5jaEluZGV4OiBmdW5jdGlvbih0KSB7XG4gIHZhciBlID0gdGhpcy5nZXRDaGlsZHJlbih0aGlzLmdldFBhcmVudCh0KSk7XG4gIGxldCBuID0gZS5pbmRleE9mKHQgKyBcIlwiKTtcbiAgcmV0dXJuIG4gPT0gLTEgJiYgKG4gPSBlLmluZGV4T2YoK3QpKSwgbjtcbn0sIGhhc0NoaWxkOiBmdW5jdGlvbih0KSB7XG4gIHZhciBlID0gdGhpcy5fYnJhbmNoZXNbdF07XG4gIHJldHVybiBlICYmIGUubGVuZ3RoO1xufSwgZ2V0Q2hpbGRyZW46IGZ1bmN0aW9uKHQpIHtcbiAgdmFyIGUgPSB0aGlzLl9icmFuY2hlc1t0XTtcbiAgcmV0dXJuIGUgfHwgdHQuJGNyZWF0ZSgpO1xufSwgaXNDaGlsZE9mOiBmdW5jdGlvbih0LCBlKSB7XG4gIGlmICghdGhpcy5leGlzdHModCkpIHJldHVybiAhMTtcbiAgaWYgKGUgPT09IHRoaXMuJGdldFJvb3RJZCgpKSByZXR1cm4gITA7XG4gIGlmICghdGhpcy5oYXNDaGlsZChlKSkgcmV0dXJuICExO1xuICB2YXIgbiA9IHRoaXMuZ2V0SXRlbSh0KSwgaSA9IHRoaXMuZ2V0UGFyZW50KHQpO1xuICBpZiAodGhpcy5nZXRJdGVtKGUpLiRsZXZlbCA+PSBuLiRsZXZlbCkgcmV0dXJuICExO1xuICBmb3IgKDsgbiAmJiB0aGlzLmV4aXN0cyhpKTsgKSB7XG4gICAgaWYgKChuID0gdGhpcy5nZXRJdGVtKGkpKSAmJiBsdChuLmlkLCBlKSkgcmV0dXJuICEwO1xuICAgIGkgPSB0aGlzLmdldFBhcmVudChuKTtcbiAgfVxuICByZXR1cm4gITE7XG59LCBnZXRTaWJsaW5nczogZnVuY3Rpb24odCkge1xuICBpZiAoIXRoaXMuZXhpc3RzKHQpKSByZXR1cm4gdHQuJGNyZWF0ZSgpO1xuICB2YXIgZSA9IHRoaXMuZ2V0UGFyZW50KHQpO1xuICByZXR1cm4gdGhpcy5nZXRDaGlsZHJlbihlKTtcbn0sIGdldE5leHRTaWJsaW5nOiBmdW5jdGlvbih0KSB7XG4gIGZvciAodmFyIGUgPSB0aGlzLmdldFNpYmxpbmdzKHQpLCBuID0gMCwgaSA9IGUubGVuZ3RoOyBuIDwgaTsgbisrKSBpZiAobHQoZVtuXSwgdCkpIHtcbiAgICB2YXIgYSA9IGVbbiArIDFdO1xuICAgIHJldHVybiBhID09PSAwICYmIG4gPiAwICYmIChhID0gXCIwXCIpLCBhIHx8IG51bGw7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59LCBnZXRQcmV2U2libGluZzogZnVuY3Rpb24odCkge1xuICBmb3IgKHZhciBlID0gdGhpcy5nZXRTaWJsaW5ncyh0KSwgbiA9IDAsIGkgPSBlLmxlbmd0aDsgbiA8IGk7IG4rKykgaWYgKGx0KGVbbl0sIHQpKSB7XG4gICAgdmFyIGEgPSBlW24gLSAxXTtcbiAgICByZXR1cm4gYSA9PT0gMCAmJiBuID4gMCAmJiAoYSA9IFwiMFwiKSwgYSB8fCBudWxsO1xuICB9XG4gIHJldHVybiBudWxsO1xufSwgZ2V0UGFyZW50OiBmdW5jdGlvbih0KSB7XG4gIHZhciBlID0gbnVsbDtcbiAgcmV0dXJuIChlID0gdC5pZCAhPT0gdm9pZCAwID8gdCA6IHRoaXMuZ2V0SXRlbSh0KSkgPyBlW3RoaXMuJHBhcmVudFByb3BlcnR5XSA6IHRoaXMuJGdldFJvb3RJZCgpO1xufSwgY2xlYXJBbGw6IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9icmFuY2hlcyA9IHt9LCBpdC5wcm90b3R5cGUuY2xlYXJBbGwuY2FsbCh0aGlzKTtcbn0sIGNhbGN1bGF0ZUl0ZW1MZXZlbDogZnVuY3Rpb24odCkge1xuICB2YXIgZSA9IDA7XG4gIHJldHVybiB0aGlzLmVhY2hQYXJlbnQoZnVuY3Rpb24oKSB7XG4gICAgZSsrO1xuICB9LCB0KSwgZTtcbn0sIF9zZXRQYXJlbnRJbm5lcjogZnVuY3Rpb24odCwgZSwgbikge1xuICBuIHx8ICh0Lmhhc093blByb3BlcnR5KFwiJHJlbmRlcmVkX3BhcmVudFwiKSA/IHRoaXMuX21vdmVfYnJhbmNoKHQsIHQuJHJlbmRlcmVkX3BhcmVudCwgZSkgOiB0aGlzLl9tb3ZlX2JyYW5jaCh0LCB0W3RoaXMuJHBhcmVudFByb3BlcnR5XSwgZSkpO1xufSwgc2V0UGFyZW50OiBmdW5jdGlvbih0LCBlLCBuKSB7XG4gIHRoaXMuX3NldFBhcmVudElubmVyKHQsIGUsIG4pLCB0W3RoaXMuJHBhcmVudFByb3BlcnR5XSA9IGU7XG59LCBfZWFjaEl0ZW1DYWNoZWQ6IGZ1bmN0aW9uKHQsIGUpIHtcbiAgZm9yICh2YXIgbiA9IDAsIGkgPSBlLmxlbmd0aDsgbiA8IGk7IG4rKykgdC5jYWxsKHRoaXMsIGVbbl0pO1xufSwgX2VhY2hJdGVtSXRlcmF0ZTogZnVuY3Rpb24odCwgZSwgbikge1xuICB2YXIgaSA9IHRoaXMuZ2V0Q2hpbGRyZW4oZSk7XG4gIGZvciAoaS5sZW5ndGggJiYgKGkgPSBpLnNsaWNlKCkucmV2ZXJzZSgpKTsgaS5sZW5ndGg7ICkge1xuICAgIHZhciBhID0gaS5wb3AoKSwgciA9IHRoaXMuZ2V0SXRlbShhKTtcbiAgICBpZiAodC5jYWxsKHRoaXMsIHIpLCBuICYmIG4ucHVzaChyKSwgdGhpcy5oYXNDaGlsZChyLmlkKSkgZm9yICh2YXIgcyA9IHRoaXMuZ2V0Q2hpbGRyZW4oci5pZCksIG8gPSBzLmxlbmd0aCAtIDE7IG8gPj0gMDsgby0tKSBpLnB1c2goc1tvXSk7XG4gIH1cbn0sIGVhY2hJdGVtOiBmdW5jdGlvbih0LCBlKSB7XG4gIHZhciBuID0gdGhpcy4kZ2V0Um9vdElkKCk7XG4gIFcoZSkgfHwgKGUgPSBuKTtcbiAgdmFyIGkgPSBhdChlLCBuKSB8fCBuLCBhID0gITEsIHIgPSAhMSwgcyA9IG51bGw7XG4gIGkgPT09IG4gJiYgKHRoaXMuX2VhY2hJdGVtTWFpblJhbmdlQ2FjaGUgPyAoYSA9ICEwLCBzID0gdGhpcy5fZWFjaEl0ZW1NYWluUmFuZ2VDYWNoZSkgOiAociA9ICEwLCBzID0gdGhpcy5fZWFjaEl0ZW1NYWluUmFuZ2VDYWNoZSA9IFtdKSksIGEgPyB0aGlzLl9lYWNoSXRlbUNhY2hlZCh0LCBzKSA6IHRoaXMuX2VhY2hJdGVtSXRlcmF0ZSh0LCBpLCByID8gcyA6IG51bGwpO1xufSwgZWFjaFBhcmVudDogZnVuY3Rpb24odCwgZSkge1xuICBmb3IgKHZhciBuID0ge30sIGkgPSBlLCBhID0gdGhpcy5nZXRQYXJlbnQoaSk7IHRoaXMuZXhpc3RzKGEpOyApIHtcbiAgICBpZiAoblthXSkgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB0YXNrcyB0cmVlLiBDeWNsaWMgcmVmZXJlbmNlIGhhcyBiZWVuIGRldGVjdGVkIG9uIHRhc2sgXCIgKyBhKTtcbiAgICBuW2FdID0gITAsIGkgPSB0aGlzLmdldEl0ZW0oYSksIHQuY2FsbCh0aGlzLCBpKSwgYSA9IHRoaXMuZ2V0UGFyZW50KGkpO1xuICB9XG59LCBfYWRkX2JyYW5jaDogZnVuY3Rpb24odCwgZSwgbikge1xuICB2YXIgaSA9IG4gPT09IHZvaWQgMCA/IHRoaXMuZ2V0UGFyZW50KHQpIDogbjtcbiAgdGhpcy5oYXNDaGlsZChpKSB8fCAodGhpcy5fYnJhbmNoZXNbaV0gPSB0dC4kY3JlYXRlKCkpO1xuICB2YXIgYSA9IHRoaXMuZ2V0Q2hpbGRyZW4oaSk7XG4gIGEuaW5kZXhPZih0LmlkICsgXCJcIikgPiAtMSB8fCBhLmluZGV4T2YoK3QuaWQpID4gLTEgfHwgKDEgKiBlID09IGUgPyBhLnNwbGljZShlLCAwLCB0LmlkKSA6IGEucHVzaCh0LmlkKSwgdC4kcmVuZGVyZWRfcGFyZW50ID0gaSk7XG59LCBfbW92ZV9icmFuY2g6IGZ1bmN0aW9uKHQsIGUsIG4pIHtcbiAgdGhpcy5fZWFjaEl0ZW1NYWluUmFuZ2VDYWNoZSA9IG51bGwsIHRoaXMuX3JlcGxhY2VfYnJhbmNoX2NoaWxkKGUsIHQuaWQpLCB0aGlzLmV4aXN0cyhuKSB8fCBsdChuLCB0aGlzLiRnZXRSb290SWQoKSkgPyB0aGlzLl9hZGRfYnJhbmNoKHQsIHZvaWQgMCwgbikgOiBkZWxldGUgdGhpcy5fYnJhbmNoZXNbdC5pZF0sIHQuJGxldmVsID0gdGhpcy5jYWxjdWxhdGVJdGVtTGV2ZWwodCksIHRoaXMuZWFjaEl0ZW0oZnVuY3Rpb24oaSkge1xuICAgIGkuJGxldmVsID0gdGhpcy5jYWxjdWxhdGVJdGVtTGV2ZWwoaSk7XG4gIH0sIHQuaWQpO1xufSwgX3JlcGxhY2VfYnJhbmNoX2NoaWxkOiBmdW5jdGlvbih0LCBlLCBuKSB7XG4gIHZhciBpID0gdGhpcy5nZXRDaGlsZHJlbih0KTtcbiAgaWYgKGkgJiYgdCAhPT0gdm9pZCAwKSB7XG4gICAgdmFyIGEgPSB0dC4kY3JlYXRlKCk7XG4gICAgbGV0IHIgPSBpLmluZGV4T2YoZSArIFwiXCIpO1xuICAgIHIgIT0gLTEgfHwgaXNOYU4oK2UpIHx8IChyID0gaS5pbmRleE9mKCtlKSksIHIgPiAtMSAmJiAobiA/IGkuc3BsaWNlKHIsIDEsIG4pIDogaS5zcGxpY2UociwgMSkpLCBhID0gaSwgdGhpcy5fYnJhbmNoZXNbdF0gPSBhO1xuICB9XG59LCBzb3J0OiBmdW5jdGlvbih0LCBlLCBuKSB7XG4gIHRoaXMuZXhpc3RzKG4pIHx8IChuID0gdGhpcy4kZ2V0Um9vdElkKCkpLCB0IHx8ICh0ID0gXCJvcmRlclwiKTtcbiAgdmFyIGkgPSB0eXBlb2YgdCA9PSBcInN0cmluZ1wiID8gZnVuY3Rpb24obCwgZCkge1xuICAgIHJldHVybiBsW3RdID09IGRbdF0gfHwgWihsW3RdKSAmJiBaKGRbdF0pICYmIGxbdF0udmFsdWVPZigpID09IGRbdF0udmFsdWVPZigpID8gMCA6IGxbdF0gPiBkW3RdID8gMSA6IC0xO1xuICB9IDogdDtcbiAgaWYgKGUpIHtcbiAgICB2YXIgYSA9IGk7XG4gICAgaSA9IGZ1bmN0aW9uKGwsIGQpIHtcbiAgICAgIHJldHVybiBhKGQsIGwpO1xuICAgIH07XG4gIH1cbiAgdmFyIHIgPSB0aGlzLmdldENoaWxkcmVuKG4pO1xuICBpZiAocikge1xuICAgIGZvciAodmFyIHMgPSBbXSwgbyA9IHIubGVuZ3RoIC0gMTsgbyA+PSAwOyBvLS0pIHNbb10gPSB0aGlzLmdldEl0ZW0ocltvXSk7XG4gICAgZm9yIChzLnNvcnQoaSksIG8gPSAwOyBvIDwgcy5sZW5ndGg7IG8rKykgcltvXSA9IHNbb10uaWQsIHRoaXMuc29ydCh0LCBlLCByW29dKTtcbiAgfVxufSwgZmlsdGVyOiBmdW5jdGlvbih0KSB7XG4gIGZvciAobGV0IGUgaW4gdGhpcy5wdWxsKSB7XG4gICAgY29uc3QgbiA9IHRoaXMucHVsbFtlXS4kcmVuZGVyZWRfcGFyZW50LCBpID0gdGhpcy5nZXRQYXJlbnQodGhpcy5wdWxsW2VdKTtcbiAgICBsdChuLCBpKSB8fCB0aGlzLl9tb3ZlX2JyYW5jaCh0aGlzLnB1bGxbZV0sIG4sIGkpO1xuICB9XG4gIHJldHVybiBpdC5wcm90b3R5cGUuZmlsdGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59LCBvcGVuOiBmdW5jdGlvbih0KSB7XG4gIHRoaXMuZXhpc3RzKHQpICYmICh0aGlzLmdldEl0ZW0odCkuJG9wZW4gPSAhMCwgdGhpcy5fc2tpcFRhc2tSZWNhbGN1bGF0aW9uID0gITAsIHRoaXMuY2FsbEV2ZW50KFwib25JdGVtT3BlblwiLCBbdF0pKTtcbn0sIGNsb3NlOiBmdW5jdGlvbih0KSB7XG4gIHRoaXMuZXhpc3RzKHQpICYmICh0aGlzLmdldEl0ZW0odCkuJG9wZW4gPSAhMSwgdGhpcy5fc2tpcFRhc2tSZWNhbGN1bGF0aW9uID0gITAsIHRoaXMuY2FsbEV2ZW50KFwib25JdGVtQ2xvc2VcIiwgW3RdKSk7XG59LCBkZXN0cnVjdG9yOiBmdW5jdGlvbigpIHtcbiAgaXQucHJvdG90eXBlLmRlc3RydWN0b3IuY2FsbCh0aGlzKSwgdGhpcy5fYnJhbmNoZXMgPSBudWxsLCB0aGlzLl9pbmRleFJhbmdlQ2FjaGUgPSB7fSwgdGhpcy5fZWFjaEl0ZW1NYWluUmFuZ2VDYWNoZSA9IG51bGw7XG59IH0sIGl0LnByb3RvdHlwZSk7XG5jb25zdCBabiA9IGZ1bmN0aW9uKHQsIGUpIHtcbiAgY29uc3QgbiA9IGUuZ2V0RGF0YXN0b3JlKHQpLCBpID0gZnVuY3Rpb24obywgbCkge1xuICAgIGNvbnN0IGQgPSBsLmdldExheWVycygpLCBjID0gbi5nZXRJdGVtKG8pO1xuICAgIGlmIChjICYmIG4uaXNWaXNpYmxlKG8pKSBmb3IgKGxldCB1ID0gMDsgdSA8IGQubGVuZ3RoOyB1KyspIGRbdV0ucmVuZGVyX2l0ZW0oYyk7XG4gIH0sIGEgPSBmdW5jdGlvbihvKSB7XG4gICAgY29uc3QgbCA9IG8uZ2V0TGF5ZXJzKCk7XG4gICAgZm9yIChsZXQgZyA9IDA7IGcgPCBsLmxlbmd0aDsgZysrKSBsW2ddLmNsZWFyKCk7XG4gICAgbGV0IGQgPSBudWxsO1xuICAgIGNvbnN0IGMgPSB7fTtcbiAgICBmb3IgKGxldCBnID0gMDsgZyA8IGwubGVuZ3RoOyBnKyspIHtcbiAgICAgIGNvbnN0IHAgPSBsW2ddO1xuICAgICAgbGV0IHk7XG4gICAgICBpZiAocC5nZXRfdmlzaWJsZV9yYW5nZSkge1xuICAgICAgICB2YXIgdSA9IHAuZ2V0X3Zpc2libGVfcmFuZ2Uobik7XG4gICAgICAgIGlmICh1LnN0YXJ0ICE9PSB2b2lkIDAgJiYgdS5lbmQgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHZhciBoID0gdS5zdGFydCArIFwiIC0gXCIgKyB1LmVuZDtcbiAgICAgICAgICBjW2hdID8geSA9IGNbaF0gOiAoeSA9IG4uZ2V0SW5kZXhSYW5nZSh1LnN0YXJ0LCB1LmVuZCksIGNbaF0gPSB5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodS5pZHMgPT09IHZvaWQgMCkgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCByYW5nZSByZXR1cm5lZCBmcm9tICdnZXRWaXNpYmxlUmFuZ2UnIG9mIHRoZSBsYXllclwiKTtcbiAgICAgICAgICB5ID0gdS5pZHMubWFwKGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgIHJldHVybiBuLmdldEl0ZW0odik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBkIHx8IChkID0gbi5nZXRWaXNpYmxlSXRlbXMoKSksIHkgPSBkO1xuICAgICAgcC5wcmVwYXJlX2RhdGEgJiYgcC5wcmVwYXJlX2RhdGEoeSksIGxbZ10ucmVuZGVyX2l0ZW1zKHkpO1xuICAgIH1cbiAgfSwgciA9IGZ1bmN0aW9uKG8pIHtcbiAgICBpZiAoby51cGRhdGVfaXRlbXMpIHtcbiAgICAgIGxldCBkID0gW107XG4gICAgICBpZiAoby5nZXRfdmlzaWJsZV9yYW5nZSkge1xuICAgICAgICB2YXIgbCA9IG8uZ2V0X3Zpc2libGVfcmFuZ2Uobik7XG4gICAgICAgIGlmIChsLnN0YXJ0ICE9PSB2b2lkIDAgJiYgbC5lbmQgIT09IHZvaWQgMCAmJiAoZCA9IG4uZ2V0SW5kZXhSYW5nZShsLnN0YXJ0LCBsLmVuZCkpLCBsLmlkcyAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgbGV0IGMgPSBsLmlkcy5tYXAoZnVuY3Rpb24odSkge1xuICAgICAgICAgICAgcmV0dXJuIG4uZ2V0SXRlbSh1KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjLmxlbmd0aCA+IDAgJiYgKGMgPSBjLmZpbHRlcigodSkgPT4gdSAhPT0gdm9pZCAwKSwgZCA9IGQuY29uY2F0KGMpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKGwuc3RhcnQgPT0gbnVsbCB8fCBsLmVuZCA9PSBudWxsKSAmJiBsLmlkcyA9PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHJhbmdlIHJldHVybmVkIGZyb20gJ2dldFZpc2libGVSYW5nZScgb2YgdGhlIGxheWVyXCIpO1xuICAgICAgfSBlbHNlIGQgPSBuLmdldFZpc2libGVJdGVtcygpO1xuICAgICAgby5wcmVwYXJlX2RhdGEgJiYgby5wcmVwYXJlX2RhdGEoZCwgbyksIG8udXBkYXRlX2l0ZW1zKGQpO1xuICAgIH1cbiAgfTtcbiAgZnVuY3Rpb24gcyhvKSB7XG4gICAgcmV0dXJuICEhby4kc2VydmljZXMuZ2V0U2VydmljZShcInN0YXRlXCIpLmdldFN0YXRlKFwiYmF0Y2hVcGRhdGVcIikuYmF0Y2hfdXBkYXRlO1xuICB9XG4gIG4uYXR0YWNoRXZlbnQoXCJvblN0b3JlVXBkYXRlZFwiLCBmdW5jdGlvbihvLCBsLCBkKSB7XG4gICAgaWYgKEYoZSkpIHJldHVybiAhMDtcbiAgICBjb25zdCBjID0gZS4kc2VydmljZXMuZ2V0U2VydmljZShcImxheWVyc1wiKS5nZXREYXRhUmVuZGVyKHQpO1xuICAgIGMgJiYgKGMub25VcGRhdGVSZXF1ZXN0ID0gZnVuY3Rpb24odSkge1xuICAgICAgcih1KTtcbiAgICB9KTtcbiAgfSksIG4uYXR0YWNoRXZlbnQoXCJvblN0b3JlVXBkYXRlZFwiLCBmdW5jdGlvbihvLCBsLCBkKSB7XG4gICAgcyhlKSB8fCAobyAmJiBkICE9IFwibW92ZVwiICYmIGQgIT0gXCJkZWxldGVcIiA/IChuLmNhbGxFdmVudChcIm9uQmVmb3JlUmVmcmVzaEl0ZW1cIiwgW2wuaWRdKSwgbi5jYWxsRXZlbnQoXCJvbkFmdGVyUmVmcmVzaEl0ZW1cIiwgW2wuaWRdKSkgOiAobi5jYWxsRXZlbnQoXCJvbkJlZm9yZVJlZnJlc2hBbGxcIiwgW10pLCBuLmNhbGxFdmVudChcIm9uQWZ0ZXJSZWZyZXNoQWxsXCIsIFtdKSkpO1xuICB9KSwgbi5hdHRhY2hFdmVudChcIm9uQWZ0ZXJSZWZyZXNoQWxsXCIsIGZ1bmN0aW9uKCkge1xuICAgIGlmIChGKGUpKSByZXR1cm4gITA7XG4gICAgY29uc3QgbyA9IGUuJHNlcnZpY2VzLmdldFNlcnZpY2UoXCJsYXllcnNcIikuZ2V0RGF0YVJlbmRlcih0KTtcbiAgICBvICYmICFzKGUpICYmIGEobyk7XG4gIH0pLCBuLmF0dGFjaEV2ZW50KFwib25BZnRlclJlZnJlc2hJdGVtXCIsIGZ1bmN0aW9uKG8pIHtcbiAgICBpZiAoRihlKSkgcmV0dXJuICEwO1xuICAgIGNvbnN0IGwgPSBlLiRzZXJ2aWNlcy5nZXRTZXJ2aWNlKFwibGF5ZXJzXCIpLmdldERhdGFSZW5kZXIodCk7XG4gICAgbCAmJiBpKG8sIGwpO1xuICB9KSwgbi5hdHRhY2hFdmVudChcIm9uSXRlbU9wZW5cIiwgZnVuY3Rpb24oKSB7XG4gICAgaWYgKEYoZSkgfHwgbi5pc1NpbGVudCgpKSByZXR1cm4gITA7XG4gICAgZS5yZW5kZXIoKTtcbiAgfSksIG4uYXR0YWNoRXZlbnQoXCJvbkl0ZW1DbG9zZVwiLCBmdW5jdGlvbigpIHtcbiAgICBpZiAoRihlKSB8fCBuLmlzU2lsZW50KCkpIHJldHVybiAhMDtcbiAgICBlLnJlbmRlcigpO1xuICB9KSwgbi5hdHRhY2hFdmVudChcIm9uSWRDaGFuZ2VcIiwgZnVuY3Rpb24obywgbCkge1xuICAgIGlmIChGKGUpKSByZXR1cm4gITA7XG4gICAgaWYgKG4uY2FsbEV2ZW50KFwib25CZWZvcmVJZENoYW5nZVwiLCBbbywgbF0pLCAhcyhlKSAmJiAhbi5pc1NpbGVudCgpKSB7XG4gICAgICBjb25zdCBkID0gZS4kc2VydmljZXMuZ2V0U2VydmljZShcImxheWVyc1wiKS5nZXREYXRhUmVuZGVyKHQpO1xuICAgICAgZCA/IChmdW5jdGlvbihjLCB1LCBoKSB7XG4gICAgICAgIGZvciAobGV0IGcgPSAwOyBnIDwgYy5sZW5ndGg7IGcrKykgY1tnXS5jaGFuZ2VfaWQodSwgaCk7XG4gICAgICB9KGQuZ2V0TGF5ZXJzKCksIG8sIGwsIG4uZ2V0SXRlbShsKSksIGkobCwgZCkpIDogZS5yZW5kZXIoKTtcbiAgICB9XG4gIH0pO1xufTtcbmZ1bmN0aW9uIG5lKCkge1xuICBmb3IgKHZhciB0ID0gdGhpcy4kc2VydmljZXMuZ2V0U2VydmljZShcImRhdGFzdG9yZXNcIiksIGUgPSBbXSwgbiA9IDA7IG4gPCB0Lmxlbmd0aDsgbisrKSB7XG4gICAgdmFyIGkgPSB0aGlzLmdldERhdGFzdG9yZSh0W25dKTtcbiAgICBpLiRkZXN0cm95ZWQgfHwgZS5wdXNoKGkpO1xuICB9XG4gIHJldHVybiBlO1xufVxuY29uc3QgUW4gPSB7IGNyZWF0ZTogZnVuY3Rpb24oKSB7XG4gIHZhciB0ID0gUCh7fSwgeyBjcmVhdGVEYXRhc3RvcmU6IGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgbiA9IChlLnR5cGUgfHwgXCJcIikudG9Mb3dlckNhc2UoKSA9PSBcInRyZWVkYXRhc3RvcmVcIiA/IGNuIDogaXQ7XG4gICAgaWYgKGUpIHtcbiAgICAgIHZhciBpID0gdGhpcztcbiAgICAgIGUub3BlbkluaXRpYWxseSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gaS5jb25maWcub3Blbl90cmVlX2luaXRpYWxseTtcbiAgICAgIH0sIGUuY29weU9uUGFyc2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGkuY29uZmlnLmRlZXBjb3B5X29uX3BhcnNlO1xuICAgICAgfTtcbiAgICB9XG4gICAgdmFyIGEgPSBuZXcgbihlKTtcbiAgICBpZiAodGhpcy5taXhpbihhLCBmdW5jdGlvbihvKSB7XG4gICAgICB2YXIgbCA9IG51bGwsIGQgPSBvLl9yZW1vdmVJdGVtSW5uZXI7XG4gICAgICBmdW5jdGlvbiBjKHUpIHtcbiAgICAgICAgbCA9IG51bGwsIHRoaXMuY2FsbEV2ZW50KFwib25BZnRlclVuc2VsZWN0XCIsIFt1XSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gby5fcmVtb3ZlSXRlbUlubmVyID0gZnVuY3Rpb24odSkge1xuICAgICAgICByZXR1cm4gbCA9PSB1ICYmIGMuY2FsbCh0aGlzLCB1KSwgbCAmJiB0aGlzLmVhY2hJdGVtICYmIHRoaXMuZWFjaEl0ZW0oZnVuY3Rpb24oaCkge1xuICAgICAgICAgIGguaWQgPT0gbCAmJiBjLmNhbGwodGhpcywgaC5pZCk7XG4gICAgICAgIH0sIHUpLCBkLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9LCBvLmF0dGFjaEV2ZW50KFwib25JZENoYW5nZVwiLCBmdW5jdGlvbih1LCBoKSB7XG4gICAgICAgIG8uZ2V0U2VsZWN0ZWRJZCgpID09IHUgJiYgby5zaWxlbnQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgby51bnNlbGVjdCh1KSwgby5zZWxlY3QoaCk7XG4gICAgICAgIH0pO1xuICAgICAgfSksIHsgc2VsZWN0OiBmdW5jdGlvbih1KSB7XG4gICAgICAgIGlmICh1KSB7XG4gICAgICAgICAgaWYgKGwgPT0gdSkgcmV0dXJuIGw7XG4gICAgICAgICAgaWYgKCF0aGlzLl9za2lwX3JlZnJlc2ggJiYgIXRoaXMuY2FsbEV2ZW50KFwib25CZWZvcmVTZWxlY3RcIiwgW3VdKSkgcmV0dXJuICExO1xuICAgICAgICAgIHRoaXMudW5zZWxlY3QoKSwgbCA9IHUsIHRoaXMuX3NraXBfcmVmcmVzaCB8fCAodGhpcy5yZWZyZXNoKHUpLCB0aGlzLmNhbGxFdmVudChcIm9uQWZ0ZXJTZWxlY3RcIiwgW3VdKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGw7XG4gICAgICB9LCBnZXRTZWxlY3RlZElkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGw7XG4gICAgICB9LCBpc1NlbGVjdGVkOiBmdW5jdGlvbih1KSB7XG4gICAgICAgIHJldHVybiB1ID09IGw7XG4gICAgICB9LCB1bnNlbGVjdDogZnVuY3Rpb24odSkge1xuICAgICAgICAodSA9IHUgfHwgbCkgJiYgKGwgPSBudWxsLCB0aGlzLl9za2lwX3JlZnJlc2ggfHwgKHRoaXMucmVmcmVzaCh1KSwgYy5jYWxsKHRoaXMsIHUpKSk7XG4gICAgICB9IH07XG4gICAgfShhKSksIGUubmFtZSkge1xuICAgICAgdmFyIHIgPSBcImRhdGFzdG9yZTpcIiArIGUubmFtZTtcbiAgICAgIGEuYXR0YWNoRXZlbnQoXCJvbkRlc3Ryb3lcIiwgKGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLiRzZXJ2aWNlcy5kcm9wU2VydmljZShyKTtcbiAgICAgICAgZm9yICh2YXIgbyA9IHRoaXMuJHNlcnZpY2VzLmdldFNlcnZpY2UoXCJkYXRhc3RvcmVzXCIpLCBsID0gMDsgbCA8IG8ubGVuZ3RoOyBsKyspIGlmIChvW2xdID09PSBlLm5hbWUpIHtcbiAgICAgICAgICBvLnNwbGljZShsLCAxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSkuYmluZCh0aGlzKSksIHRoaXMuJHNlcnZpY2VzLmRyb3BTZXJ2aWNlKHIpLCB0aGlzLiRzZXJ2aWNlcy5zZXRTZXJ2aWNlKHIsIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gYTtcbiAgICAgIH0pO1xuICAgICAgdmFyIHMgPSB0aGlzLiRzZXJ2aWNlcy5nZXRTZXJ2aWNlKFwiZGF0YXN0b3Jlc1wiKTtcbiAgICAgIHMgPyBzLmluZGV4T2YoZS5uYW1lKSA8IDAgJiYgcy5wdXNoKGUubmFtZSkgOiAocyA9IFtdLCB0aGlzLiRzZXJ2aWNlcy5zZXRTZXJ2aWNlKFwiZGF0YXN0b3Jlc1wiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHM7XG4gICAgICB9KSwgcy5wdXNoKGUubmFtZSkpLCBabihlLm5hbWUsIHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gYTtcbiAgfSwgZ2V0RGF0YXN0b3JlOiBmdW5jdGlvbihlKSB7XG4gICAgcmV0dXJuIHRoaXMuJHNlcnZpY2VzLmdldFNlcnZpY2UoXCJkYXRhc3RvcmU6XCIgKyBlKTtcbiAgfSwgX2dldERhdGFzdG9yZXM6IG5lLCByZWZyZXNoRGF0YTogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGU7XG4gICAgRih0aGlzKSB8fCAoZSA9IHRoaXMuZ2V0U2Nyb2xsU3RhdGUoKSksIHRoaXMuY2FsbEV2ZW50KFwib25CZWZvcmVEYXRhUmVuZGVyXCIsIFtdKTtcbiAgICBmb3IgKHZhciBuID0gbmUuY2FsbCh0aGlzKSwgaSA9IDA7IGkgPCBuLmxlbmd0aDsgaSsrKSBuW2ldLnJlZnJlc2goKTtcbiAgICB0aGlzLmNvbmZpZy5wcmVzZXJ2ZV9zY3JvbGwgJiYgIUYodGhpcykgJiYgKGUueCB8fCBlLnkpICYmIHRoaXMuc2Nyb2xsVG8oZS54LCBlLnkpLCB0aGlzLmNhbGxFdmVudChcIm9uRGF0YVJlbmRlclwiLCBbXSk7XG4gIH0sIGlzQ2hpbGRPZjogZnVuY3Rpb24oZSwgbikge1xuICAgIHJldHVybiB0aGlzLiRkYXRhLnRhc2tzU3RvcmUuaXNDaGlsZE9mKGUsIG4pO1xuICB9LCByZWZyZXNoVGFzazogZnVuY3Rpb24oZSwgbikge1xuICAgIHZhciBpID0gdGhpcy5nZXRUYXNrKGUpLCBhID0gdGhpcztcbiAgICBmdW5jdGlvbiByKCkge1xuICAgICAgaWYgKG4gPT09IHZvaWQgMCB8fCBuKSB7XG4gICAgICAgIGZvciAodmFyIG8gPSAwOyBvIDwgaS4kc291cmNlLmxlbmd0aDsgbysrKSBhLnJlZnJlc2hMaW5rKGkuJHNvdXJjZVtvXSk7XG4gICAgICAgIGZvciAobyA9IDA7IG8gPCBpLiR0YXJnZXQubGVuZ3RoOyBvKyspIGEucmVmcmVzaExpbmsoaS4kdGFyZ2V0W29dKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGkgJiYgdGhpcy5pc1Rhc2tWaXNpYmxlKGUpKSB0aGlzLiRkYXRhLnRhc2tzU3RvcmUucmVmcmVzaChlLCAhIXRoaXMuZ2V0U3RhdGUoXCJ0YXNrc0RuZFwiKS5kcmFnX2lkIHx8IG4gPT09ICExKSwgcigpO1xuICAgIGVsc2UgaWYgKHRoaXMuaXNUYXNrRXhpc3RzKGUpICYmIHRoaXMuaXNUYXNrRXhpc3RzKHRoaXMuZ2V0UGFyZW50KGUpKSAmJiAhdGhpcy5fYnVsa19kbmQpIHtcbiAgICAgIHRoaXMucmVmcmVzaFRhc2sodGhpcy5nZXRQYXJlbnQoZSkpO1xuICAgICAgdmFyIHMgPSAhMTtcbiAgICAgIHRoaXMuZWFjaFBhcmVudChmdW5jdGlvbihvKSB7XG4gICAgICAgIChzIHx8IHRoaXMuaXNTcGxpdFRhc2sobykpICYmIChzID0gITApO1xuICAgICAgfSwgZSksIHMgJiYgcigpO1xuICAgIH1cbiAgfSwgcmVmcmVzaExpbms6IGZ1bmN0aW9uKGUpIHtcbiAgICB0aGlzLiRkYXRhLmxpbmtzU3RvcmUucmVmcmVzaChlLCAhIXRoaXMuZ2V0U3RhdGUoXCJ0YXNrc0RuZFwiKS5kcmFnX2lkKTtcbiAgfSwgc2lsZW50OiBmdW5jdGlvbihlKSB7XG4gICAgdmFyIG4gPSB0aGlzO1xuICAgIG4uJGRhdGEudGFza3NTdG9yZS5zaWxlbnQoZnVuY3Rpb24oKSB7XG4gICAgICBuLiRkYXRhLmxpbmtzU3RvcmUuc2lsZW50KGZ1bmN0aW9uKCkge1xuICAgICAgICBlKCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSwgY2xlYXJBbGw6IGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIGUgPSBuZS5jYWxsKHRoaXMpLCBuID0gMDsgbiA8IGUubGVuZ3RoOyBuKyspIGVbbl0uc2lsZW50KGZ1bmN0aW9uKCkge1xuICAgICAgZVtuXS5jbGVhckFsbCgpO1xuICAgIH0pO1xuICAgIGZvciAobiA9IDA7IG4gPCBlLmxlbmd0aDsgbisrKSBlW25dLmNsZWFyQWxsKCk7XG4gICAgdGhpcy5fdXBkYXRlX2ZsYWdzKCksIHRoaXMudXNlcmRhdGEgPSB7fSwgdGhpcy5jYWxsRXZlbnQoXCJvbkNsZWFyXCIsIFtdKSwgdGhpcy5yZW5kZXIoKTtcbiAgfSwgX2NsZWFyX2RhdGE6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuJGRhdGEudGFza3NTdG9yZS5jbGVhckFsbCgpLCB0aGlzLiRkYXRhLmxpbmtzU3RvcmUuY2xlYXJBbGwoKSwgdGhpcy5fdXBkYXRlX2ZsYWdzKCksIHRoaXMudXNlcmRhdGEgPSB7fTtcbiAgfSwgc2VsZWN0VGFzazogZnVuY3Rpb24oZSkge1xuICAgIHZhciBuID0gdGhpcy4kZGF0YS50YXNrc1N0b3JlO1xuICAgIGlmICghdGhpcy5jb25maWcuc2VsZWN0X3Rhc2spIHJldHVybiAhMTtcbiAgICBpZiAoZSA9IGF0KGUsIHRoaXMuY29uZmlnLnJvb3RfaWQpKSB7XG4gICAgICBsZXQgaSA9IHRoaXMuZ2V0U2VsZWN0ZWRJZCgpO1xuICAgICAgbi5fc2tpcFJlc291cmNlUmVwYWludCA9ICEwLCBuLnNlbGVjdChlKSwgbi5fc2tpcFJlc291cmNlUmVwYWludCA9ICExLCBpICYmIG4ucHVsbFtpXS4kc3BsaXRfc3VidGFzayAmJiBpICE9IGUgJiYgdGhpcy5yZWZyZXNoVGFzayhpKSwgbi5wdWxsW2VdLiRzcGxpdF9zdWJ0YXNrICYmIGkgIT0gZSAmJiB0aGlzLnJlZnJlc2hUYXNrKGUpO1xuICAgIH1cbiAgICByZXR1cm4gbi5nZXRTZWxlY3RlZElkKCk7XG4gIH0sIHVuc2VsZWN0VGFzazogZnVuY3Rpb24oZSkge1xuICAgIHZhciBuID0gdGhpcy4kZGF0YS50YXNrc1N0b3JlO1xuICAgIG4udW5zZWxlY3QoZSksIGUgJiYgbi5wdWxsW2VdLiRzcGxpdF9zdWJ0YXNrICYmIHRoaXMucmVmcmVzaFRhc2soZSk7XG4gIH0sIGlzU2VsZWN0ZWRUYXNrOiBmdW5jdGlvbihlKSB7XG4gICAgcmV0dXJuIHRoaXMuJGRhdGEudGFza3NTdG9yZS5pc1NlbGVjdGVkKGUpO1xuICB9LCBnZXRTZWxlY3RlZElkOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy4kZGF0YS50YXNrc1N0b3JlLmdldFNlbGVjdGVkSWQoKTtcbiAgfSB9KTtcbiAgcmV0dXJuIFAodCwgeyBnZXRUYXNrOiBmdW5jdGlvbihlKSB7XG4gICAgZSA9IGF0KGUsIHRoaXMuY29uZmlnLnJvb3RfaWQpLCB0aGlzLmFzc2VydChlLCBcIkludmFsaWQgYXJndW1lbnQgZm9yIGdhbnR0LmdldFRhc2tcIik7XG4gICAgdmFyIG4gPSB0aGlzLiRkYXRhLnRhc2tzU3RvcmUuZ2V0SXRlbShlKTtcbiAgICByZXR1cm4gdGhpcy5hc3NlcnQobiwgXCJUYXNrIG5vdCBmb3VuZCBpZD1cIiArIGUpLCBuO1xuICB9LCBnZXRUYXNrQnlUaW1lOiBmdW5jdGlvbihlLCBuKSB7XG4gICAgdmFyIGkgPSB0aGlzLiRkYXRhLnRhc2tzU3RvcmUuZ2V0SXRlbXMoKSwgYSA9IFtdO1xuICAgIGlmIChlIHx8IG4pIHtcbiAgICAgIGUgPSArZSB8fCAtMSAvIDAsIG4gPSArbiB8fCAxIC8gMDtcbiAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgaS5sZW5ndGg7IHIrKykge1xuICAgICAgICB2YXIgcyA9IGlbcl07XG4gICAgICAgICtzLnN0YXJ0X2RhdGUgPCBuICYmICtzLmVuZF9kYXRlID4gZSAmJiBhLnB1c2gocyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGEgPSBpO1xuICAgIHJldHVybiBhO1xuICB9LCBpc1Rhc2tFeGlzdHM6IGZ1bmN0aW9uKGUpIHtcbiAgICByZXR1cm4gISghdGhpcy4kZGF0YSB8fCAhdGhpcy4kZGF0YS50YXNrc1N0b3JlKSAmJiB0aGlzLiRkYXRhLnRhc2tzU3RvcmUuZXhpc3RzKGUpO1xuICB9LCB1cGRhdGVUYXNrOiBmdW5jdGlvbihlLCBuKSB7XG4gICAgVyhuKSB8fCAobiA9IHRoaXMuZ2V0VGFzayhlKSksIHRoaXMuJGRhdGEudGFza3NTdG9yZS51cGRhdGVJdGVtKGUsIG4pLCB0aGlzLmlzVGFza0V4aXN0cyhlKSAmJiB0aGlzLnJlZnJlc2hUYXNrKGUpO1xuICB9LCBhZGRUYXNrOiBmdW5jdGlvbihlLCBuLCBpKSB7XG4gICAgaWYgKFcoZS5pZCkgfHwgKGUuaWQgPSBzdCgpKSwgdGhpcy5pc1Rhc2tFeGlzdHMoZS5pZCkgJiYgdGhpcy5nZXRUYXNrKGUuaWQpLiRpbmRleCAhPSBlLiRpbmRleCkgcmV0dXJuIGUuc3RhcnRfZGF0ZSAmJiB0eXBlb2YgZS5zdGFydF9kYXRlID09IFwic3RyaW5nXCIgJiYgKGUuc3RhcnRfZGF0ZSA9IHRoaXMuZGF0ZS5wYXJzZURhdGUoZS5zdGFydF9kYXRlLCBcInBhcnNlX2RhdGVcIikpLCBlLmVuZF9kYXRlICYmIHR5cGVvZiBlLmVuZF9kYXRlID09IFwic3RyaW5nXCIgJiYgKGUuZW5kX2RhdGUgPSB0aGlzLmRhdGUucGFyc2VEYXRlKGUuZW5kX2RhdGUsIFwicGFyc2VfZGF0ZVwiKSksIHRoaXMuJGRhdGEudGFza3NTdG9yZS51cGRhdGVJdGVtKGUuaWQsIGUpO1xuICAgIGlmIChXKG4pIHx8IChuID0gdGhpcy5nZXRQYXJlbnQoZSkgfHwgMCksIHRoaXMuaXNUYXNrRXhpc3RzKG4pIHx8IChuID0gdGhpcy5jb25maWcucm9vdF9pZCksIHRoaXMuc2V0UGFyZW50KGUsIG4pLCB0aGlzLmdldFN0YXRlKCkubGlnaHRib3ggJiYgdGhpcy5pc1Rhc2tFeGlzdHMobikpIHtcbiAgICAgIHZhciBhID0gdGhpcy5nZXRUYXNrKG4pO1xuICAgICAgdGhpcy5jYWxsRXZlbnQoXCJvbkFmdGVyUGFyZW50RXhwYW5kXCIsIFtuLCBhXSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLiRkYXRhLnRhc2tzU3RvcmUuYWRkSXRlbShlLCBpLCBuKTtcbiAgfSwgZGVsZXRlVGFzazogZnVuY3Rpb24oZSkge1xuICAgIHJldHVybiBlID0gYXQoZSwgdGhpcy5jb25maWcucm9vdF9pZCksIHRoaXMuJGRhdGEudGFza3NTdG9yZS5yZW1vdmVJdGVtKGUpO1xuICB9LCBnZXRUYXNrQ291bnQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLiRkYXRhLnRhc2tzU3RvcmUuY291bnQoKTtcbiAgfSwgZ2V0VmlzaWJsZVRhc2tDb3VudDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuJGRhdGEudGFza3NTdG9yZS5jb3VudFZpc2libGUoKTtcbiAgfSwgZ2V0VGFza0luZGV4OiBmdW5jdGlvbihlKSB7XG4gICAgcmV0dXJuIHRoaXMuJGRhdGEudGFza3NTdG9yZS5nZXRCcmFuY2hJbmRleChlKTtcbiAgfSwgZ2V0R2xvYmFsVGFza0luZGV4OiBmdW5jdGlvbihlKSB7XG4gICAgcmV0dXJuIGUgPSBhdChlLCB0aGlzLmNvbmZpZy5yb290X2lkKSwgdGhpcy5hc3NlcnQoZSwgXCJJbnZhbGlkIGFyZ3VtZW50XCIpLCB0aGlzLiRkYXRhLnRhc2tzU3RvcmUuZ2V0SW5kZXhCeUlkKGUpO1xuICB9LCBlYWNoVGFzazogZnVuY3Rpb24oZSwgbiwgaSkge1xuICAgIHJldHVybiB0aGlzLiRkYXRhLnRhc2tzU3RvcmUuZWFjaEl0ZW0oUihlLCBpIHx8IHRoaXMpLCBuKTtcbiAgfSwgZWFjaFBhcmVudDogZnVuY3Rpb24oZSwgbiwgaSkge1xuICAgIHJldHVybiB0aGlzLiRkYXRhLnRhc2tzU3RvcmUuZWFjaFBhcmVudChSKGUsIGkgfHwgdGhpcyksIG4pO1xuICB9LCBjaGFuZ2VUYXNrSWQ6IGZ1bmN0aW9uKGUsIG4pIHtcbiAgICB0aGlzLiRkYXRhLnRhc2tzU3RvcmUuY2hhbmdlSWQoZSwgbik7XG4gICAgdmFyIGkgPSB0aGlzLiRkYXRhLnRhc2tzU3RvcmUuZ2V0SXRlbShuKSwgYSA9IFtdO1xuICAgIGkuJHNvdXJjZSAmJiAoYSA9IGEuY29uY2F0KGkuJHNvdXJjZSkpLCBpLiR0YXJnZXQgJiYgKGEgPSBhLmNvbmNhdChpLiR0YXJnZXQpKTtcbiAgICBmb3IgKHZhciByID0gMDsgciA8IGEubGVuZ3RoOyByKyspIHtcbiAgICAgIHZhciBzID0gdGhpcy5nZXRMaW5rKGFbcl0pO1xuICAgICAgcy5zb3VyY2UgPT0gZSAmJiAocy5zb3VyY2UgPSBuKSwgcy50YXJnZXQgPT0gZSAmJiAocy50YXJnZXQgPSBuKTtcbiAgICB9XG4gIH0sIGNhbGN1bGF0ZVRhc2tMZXZlbDogZnVuY3Rpb24oZSkge1xuICAgIHJldHVybiB0aGlzLiRkYXRhLnRhc2tzU3RvcmUuY2FsY3VsYXRlSXRlbUxldmVsKGUpO1xuICB9LCBnZXROZXh0OiBmdW5jdGlvbihlKSB7XG4gICAgcmV0dXJuIHRoaXMuJGRhdGEudGFza3NTdG9yZS5nZXROZXh0KGUpO1xuICB9LCBnZXRQcmV2OiBmdW5jdGlvbihlKSB7XG4gICAgcmV0dXJuIHRoaXMuJGRhdGEudGFza3NTdG9yZS5nZXRQcmV2KGUpO1xuICB9LCBnZXRQYXJlbnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICByZXR1cm4gdGhpcy4kZGF0YS50YXNrc1N0b3JlLmdldFBhcmVudChlKTtcbiAgfSwgc2V0UGFyZW50OiBmdW5jdGlvbihlLCBuLCBpKSB7XG4gICAgcmV0dXJuIHRoaXMuJGRhdGEudGFza3NTdG9yZS5zZXRQYXJlbnQoZSwgbiwgaSk7XG4gIH0sIGdldFNpYmxpbmdzOiBmdW5jdGlvbihlKSB7XG4gICAgcmV0dXJuIHRoaXMuJGRhdGEudGFza3NTdG9yZS5nZXRTaWJsaW5ncyhlKS5zbGljZSgpO1xuICB9LCBnZXROZXh0U2libGluZzogZnVuY3Rpb24oZSkge1xuICAgIHJldHVybiB0aGlzLiRkYXRhLnRhc2tzU3RvcmUuZ2V0TmV4dFNpYmxpbmcoZSk7XG4gIH0sIGdldFByZXZTaWJsaW5nOiBmdW5jdGlvbihlKSB7XG4gICAgcmV0dXJuIHRoaXMuJGRhdGEudGFza3NTdG9yZS5nZXRQcmV2U2libGluZyhlKTtcbiAgfSwgZ2V0VGFza0J5SW5kZXg6IGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgbiA9IHRoaXMuJGRhdGEudGFza3NTdG9yZS5nZXRJZEJ5SW5kZXgoZSk7XG4gICAgcmV0dXJuIHRoaXMuaXNUYXNrRXhpc3RzKG4pID8gdGhpcy5nZXRUYXNrKG4pIDogbnVsbDtcbiAgfSwgZ2V0Q2hpbGRyZW46IGZ1bmN0aW9uKGUpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNDaGlsZChlKSA/IHRoaXMuJGRhdGEudGFza3NTdG9yZS5nZXRDaGlsZHJlbihlKS5zbGljZSgpIDogW107XG4gIH0sIGhhc0NoaWxkOiBmdW5jdGlvbihlKSB7XG4gICAgcmV0dXJuIHRoaXMuJGRhdGEudGFza3NTdG9yZS5oYXNDaGlsZChlKTtcbiAgfSwgb3BlbjogZnVuY3Rpb24oZSkge1xuICAgIHRoaXMuJGRhdGEudGFza3NTdG9yZS5vcGVuKGUpO1xuICB9LCBjbG9zZTogZnVuY3Rpb24oZSkge1xuICAgIHRoaXMuJGRhdGEudGFza3NTdG9yZS5jbG9zZShlKTtcbiAgfSwgbW92ZVRhc2s6IGZ1bmN0aW9uKGUsIG4sIGkpIHtcbiAgICByZXR1cm4gaSA9IGF0KGksIHRoaXMuY29uZmlnLnJvb3RfaWQpLCB0aGlzLiRkYXRhLnRhc2tzU3RvcmUubW92ZS5hcHBseSh0aGlzLiRkYXRhLnRhc2tzU3RvcmUsIGFyZ3VtZW50cyk7XG4gIH0sIHNvcnQ6IGZ1bmN0aW9uKGUsIG4sIGksIGEpIHtcbiAgICB2YXIgciA9ICFhO1xuICAgIHRoaXMuJGRhdGEudGFza3NTdG9yZS5zb3J0KGUsIG4sIGkpLCB0aGlzLmNhbGxFdmVudChcIm9uQWZ0ZXJTb3J0XCIsIFtlLCBuLCBpXSksIHIgJiYgdGhpcy5yZW5kZXIoKTtcbiAgfSB9KSwgUCh0LCB7IGdldExpbmtDb3VudDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuJGRhdGEubGlua3NTdG9yZS5jb3VudCgpO1xuICB9LCBnZXRMaW5rOiBmdW5jdGlvbihlKSB7XG4gICAgcmV0dXJuIHRoaXMuJGRhdGEubGlua3NTdG9yZS5nZXRJdGVtKGUpO1xuICB9LCBnZXRMaW5rczogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuJGRhdGEubGlua3NTdG9yZS5nZXRJdGVtcygpO1xuICB9LCBpc0xpbmtFeGlzdHM6IGZ1bmN0aW9uKGUpIHtcbiAgICByZXR1cm4gdGhpcy4kZGF0YS5saW5rc1N0b3JlLmV4aXN0cyhlKTtcbiAgfSwgYWRkTGluazogZnVuY3Rpb24oZSkge1xuICAgIGNvbnN0IG4gPSB0aGlzLiRkYXRhLmxpbmtzU3RvcmUuYWRkSXRlbShlKTtcbiAgICByZXR1cm4gdGhpcy4kZGF0YS5saW5rc1N0b3JlLmlzU2lsZW50KCkgJiYgdGhpcy4kZGF0YS5saW5rc1N0b3JlLmZ1bGxPcmRlci5wdXNoKG4pLCBuO1xuICB9LCB1cGRhdGVMaW5rOiBmdW5jdGlvbihlLCBuKSB7XG4gICAgVyhuKSB8fCAobiA9IHRoaXMuZ2V0TGluayhlKSksIHRoaXMuJGRhdGEubGlua3NTdG9yZS51cGRhdGVJdGVtKGUsIG4pO1xuICB9LCBkZWxldGVMaW5rOiBmdW5jdGlvbihlKSB7XG4gICAgcmV0dXJuIHRoaXMuJGRhdGEubGlua3NTdG9yZS5yZW1vdmVJdGVtKGUpO1xuICB9LCBjaGFuZ2VMaW5rSWQ6IGZ1bmN0aW9uKGUsIG4pIHtcbiAgICByZXR1cm4gdGhpcy4kZGF0YS5saW5rc1N0b3JlLmNoYW5nZUlkKGUsIG4pO1xuICB9IH0pLCB0O1xufSB9O1xuZnVuY3Rpb24gcGUodCkge1xuICB2YXIgZSA9IHQuZGF0ZSwgbiA9IHQuJHNlcnZpY2VzO1xuICByZXR1cm4geyBnZXRTdW06IGZ1bmN0aW9uKGksIGEsIHIpIHtcbiAgICByID09PSB2b2lkIDAgJiYgKHIgPSBpLmxlbmd0aCAtIDEpLCBhID09PSB2b2lkIDAgJiYgKGEgPSAwKTtcbiAgICBmb3IgKHZhciBzID0gMCwgbyA9IGE7IG8gPD0gcjsgbysrKSBzICs9IGlbb107XG4gICAgcmV0dXJuIHM7XG4gIH0sIHNldFN1bVdpZHRoOiBmdW5jdGlvbihpLCBhLCByLCBzKSB7XG4gICAgdmFyIG8gPSBhLndpZHRoO1xuICAgIHMgPT09IHZvaWQgMCAmJiAocyA9IG8ubGVuZ3RoIC0gMSksIHIgPT09IHZvaWQgMCAmJiAociA9IDApO1xuICAgIHZhciBsID0gcyAtIHIgKyAxO1xuICAgIGlmICghKHIgPiBvLmxlbmd0aCAtIDEgfHwgbCA8PSAwIHx8IHMgPiBvLmxlbmd0aCAtIDEpKSB7XG4gICAgICB2YXIgZCA9IGkgLSB0aGlzLmdldFN1bShvLCByLCBzKTtcbiAgICAgIHRoaXMuYWRqdXN0U2l6ZShkLCBvLCByLCBzKSwgdGhpcy5hZGp1c3RTaXplKC1kLCBvLCBzICsgMSksIGEuZnVsbF93aWR0aCA9IHRoaXMuZ2V0U3VtKG8pO1xuICAgIH1cbiAgfSwgc3BsaXRTaXplOiBmdW5jdGlvbihpLCBhKSB7XG4gICAgZm9yICh2YXIgciA9IFtdLCBzID0gMDsgcyA8IGE7IHMrKykgcltzXSA9IDA7XG4gICAgcmV0dXJuIHRoaXMuYWRqdXN0U2l6ZShpLCByKSwgcjtcbiAgfSwgYWRqdXN0U2l6ZTogZnVuY3Rpb24oaSwgYSwgciwgcykge1xuICAgIHIgfHwgKHIgPSAwKSwgcyA9PT0gdm9pZCAwICYmIChzID0gYS5sZW5ndGggLSAxKTtcbiAgICBmb3IgKHZhciBvID0gcyAtIHIgKyAxLCBsID0gdGhpcy5nZXRTdW0oYSwgciwgcyksIGQgPSByOyBkIDw9IHM7IGQrKykge1xuICAgICAgdmFyIGMgPSBNYXRoLmZsb29yKGkgKiAobCA/IGFbZF0gLyBsIDogMSAvIG8pKTtcbiAgICAgIGwgLT0gYVtkXSwgaSAtPSBjLCBvLS0sIGFbZF0gKz0gYztcbiAgICB9XG4gICAgYVthLmxlbmd0aCAtIDFdICs9IGk7XG4gIH0sIHNvcnRTY2FsZXM6IGZ1bmN0aW9uKGkpIHtcbiAgICBmdW5jdGlvbiBhKHMsIG8pIHtcbiAgICAgIHZhciBsID0gbmV3IERhdGUoMTk3MCwgMCwgMSk7XG4gICAgICByZXR1cm4gZS5hZGQobCwgbywgcykgLSBsO1xuICAgIH1cbiAgICBpLnNvcnQoZnVuY3Rpb24ocywgbykge1xuICAgICAgcmV0dXJuIGEocy51bml0LCBzLnN0ZXApIDwgYShvLnVuaXQsIG8uc3RlcCkgPyAxIDogYShzLnVuaXQsIHMuc3RlcCkgPiBhKG8udW5pdCwgby5zdGVwKSA/IC0xIDogMDtcbiAgICB9KTtcbiAgICBmb3IgKHZhciByID0gMDsgciA8IGkubGVuZ3RoOyByKyspIGlbcl0uaW5kZXggPSByO1xuICB9LCBfaXNMZWdhY3lNb2RlOiBmdW5jdGlvbihpKSB7XG4gICAgdmFyIGEgPSBpIHx8IHQuY29uZmlnO1xuICAgIHJldHVybiBhLnNjYWxlX3VuaXQgfHwgYS5kYXRlX3NjYWxlIHx8IGEuc3Vic2NhbGVzO1xuICB9LCBfcHJlcGFyZVNjYWxlT2JqZWN0OiBmdW5jdGlvbihpKSB7XG4gICAgdmFyIGEgPSBpLmZvcm1hdDtcbiAgICByZXR1cm4gYSB8fCAoYSA9IGkudGVtcGxhdGUgfHwgaS5kYXRlIHx8IFwiJWQgJU1cIiksIHR5cGVvZiBhID09IFwic3RyaW5nXCIgJiYgKGEgPSB0LmRhdGUuZGF0ZV90b19zdHIoYSkpLCB7IHVuaXQ6IGkudW5pdCB8fCBcImRheVwiLCBzdGVwOiBpLnN0ZXAgfHwgMSwgZm9ybWF0OiBhLCBjc3M6IGkuY3NzIH07XG4gIH0sIHByaW1hcnlTY2FsZTogZnVuY3Rpb24oaSkge1xuICAgIHZhciBhLCByID0gbi5nZXRTZXJ2aWNlKFwidGVtcGxhdGVMb2FkZXJcIiksIHMgPSB0aGlzLl9pc0xlZ2FjeU1vZGUoaSksIG8gPSBpIHx8IHQuY29uZmlnO1xuICAgIGlmIChzKSByLmluaXRUZW1wbGF0ZShcImRhdGVfc2NhbGVcIiwgdm9pZCAwLCB2b2lkIDAsIG8sIHQuY29uZmlnLnRlbXBsYXRlcyksIGEgPSB7IHVuaXQ6IHQuY29uZmlnLnNjYWxlX3VuaXQsIHN0ZXA6IHQuY29uZmlnLnN0ZXAsIHRlbXBsYXRlOiB0LnRlbXBsYXRlcy5kYXRlX3NjYWxlLCBkYXRlOiB0LmNvbmZpZy5kYXRlX3NjYWxlLCBjc3M6IHQudGVtcGxhdGVzLnNjYWxlX2NlbGxfY2xhc3MgfTtcbiAgICBlbHNlIHtcbiAgICAgIHZhciBsID0gby5zY2FsZXNbMF07XG4gICAgICBhID0geyB1bml0OiBsLnVuaXQsIHN0ZXA6IGwuc3RlcCwgdGVtcGxhdGU6IGwudGVtcGxhdGUsIGZvcm1hdDogbC5mb3JtYXQsIGRhdGU6IGwuZGF0ZSwgY3NzOiBsLmNzcyB8fCB0LnRlbXBsYXRlcy5zY2FsZV9jZWxsX2NsYXNzIH07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9wcmVwYXJlU2NhbGVPYmplY3QoYSk7XG4gIH0sIGdldFN1YlNjYWxlczogZnVuY3Rpb24oaSkge1xuICAgIHZhciBhLCByID0gdGhpcy5faXNMZWdhY3lNb2RlKGkpLCBzID0gaSB8fCB0LmNvbmZpZztcbiAgICBpZiAocikge1xuICAgICAgbGV0IG8gPSBcImh0dHBzOi8vZG9jcy5kaHRtbHguY29tL2dhbnR0L21pZ3JhdGluZy5odG1sIzp+OnRleHQ9JTNEJTIwZmFsc2UlM0ItLFRpbWUlMjBzY2FsZSUyMHNldHRpbmdzLC1Db25maWd1cmF0aW9uJTIwb2YlMjB0aW1lXCI7XG4gICAgICB0LmVudi5pc0ZGICYmIChvID0gXCJodHRwczovL2RvY3MuZGh0bWx4LmNvbS9nYW50dC9taWdyYXRpbmcuaHRtbCM2MTYyXCIpLCBjb25zb2xlLndhcm4oYFlvdSBhcmUgdXNpbmcgdGhlIG9ic29sZXRlIHNjYWxlIGNvbmZpZ3VyYXRpb24uXG5JdCB3aWxsIHN0b3Agd29ya2luZyBpbiB0aGUgZnV0dXJlIHZlcnNpb25zLlxuUGxlYXNlIG1pZ3JhdGUgdGhlIGNvbmZpZ3VyYXRpb24gdG8gdGhlIG5ld2VyIHZlcnNpb246XG4ke299YCksIGEgPSBzLnN1YnNjYWxlcyB8fCBbXTtcbiAgICB9IGVsc2UgYSA9IHMuc2NhbGVzLnNsaWNlKDEpO1xuICAgIHJldHVybiBhLm1hcCgoZnVuY3Rpb24obykge1xuICAgICAgcmV0dXJuIHRoaXMuX3ByZXBhcmVTY2FsZU9iamVjdChvKTtcbiAgICB9KS5iaW5kKHRoaXMpKTtcbiAgfSwgcHJlcGFyZUNvbmZpZ3M6IGZ1bmN0aW9uKGksIGEsIHIsIHMsIG8sIGwsIGQpIHtcbiAgICBmb3IgKHZhciBjID0gdGhpcy5zcGxpdFNpemUocywgaS5sZW5ndGgpLCB1ID0gciwgaCA9IFtdLCBnID0gaS5sZW5ndGggLSAxOyBnID49IDA7IGctLSkge1xuICAgICAgdmFyIHAgPSBnID09IGkubGVuZ3RoIC0gMSwgeSA9IHRoaXMuaW5pdFNjYWxlQ29uZmlnKGlbZ10sIG8sIGwpO1xuICAgICAgcCAmJiB0aGlzLnByb2Nlc3NJZ25vcmVzKHkpLCB0aGlzLmluaXRDb2xTaXplcyh5LCBhLCB1LCBjW2ddKSwgdGhpcy5saW1pdFZpc2libGVSYW5nZSh5KSwgcCAmJiAodSA9IHkuZnVsbF93aWR0aCksIGgudW5zaGlmdCh5KTtcbiAgICB9XG4gICAgZm9yIChnID0gMDsgZyA8IGgubGVuZ3RoIC0gMTsgZysrKSB0aGlzLmFsaW5lU2NhbGVDb2x1bW5zKGhbaC5sZW5ndGggLSAxXSwgaFtnXSk7XG4gICAgZm9yIChnID0gMDsgZyA8IGgubGVuZ3RoOyBnKyspIGQgJiYgdGhpcy5yZXZlcnNlU2NhbGUoaFtnXSksIHRoaXMuc2V0UG9zU2V0dGluZ3MoaFtnXSk7XG4gICAgcmV0dXJuIGg7XG4gIH0sIHJldmVyc2VTY2FsZTogZnVuY3Rpb24oaSkge1xuICAgIGkud2lkdGggPSBpLndpZHRoLnJldmVyc2UoKSwgaS50cmFjZV94ID0gaS50cmFjZV94LnJldmVyc2UoKTtcbiAgICB2YXIgYSA9IGkudHJhY2VfaW5kZXhlcztcbiAgICBpLnRyYWNlX2luZGV4ZXMgPSB7fSwgaS50cmFjZV9pbmRleF90cmFuc2l0aW9uID0ge30sIGkucnRsID0gITA7XG4gICAgZm9yICh2YXIgciA9IDA7IHIgPCBpLnRyYWNlX3gubGVuZ3RoOyByKyspIGkudHJhY2VfaW5kZXhlc1tpLnRyYWNlX3hbcl0udmFsdWVPZigpXSA9IHIsIGkudHJhY2VfaW5kZXhfdHJhbnNpdGlvblthW2kudHJhY2VfeFtyXS52YWx1ZU9mKCldXSA9IHI7XG4gICAgcmV0dXJuIGk7XG4gIH0sIHNldFBvc1NldHRpbmdzOiBmdW5jdGlvbihpKSB7XG4gICAgZm9yICh2YXIgYSA9IDAsIHIgPSBpLnRyYWNlX3gubGVuZ3RoOyBhIDwgcjsgYSsrKSBpLmxlZnQucHVzaCgoaS53aWR0aFthIC0gMV0gfHwgMCkgKyAoaS5sZWZ0W2EgLSAxXSB8fCAwKSk7XG4gIH0sIF9pZ25vcmVfdGltZV9jb25maWc6IGZ1bmN0aW9uKGksIGEpIHtcbiAgICBpZiAodC5jb25maWcuc2tpcF9vZmZfdGltZSkge1xuICAgICAgZm9yICh2YXIgciA9ICEwLCBzID0gaSwgbyA9IDA7IG8gPCBhLnN0ZXA7IG8rKykgbyAmJiAocyA9IGUuYWRkKGksIG8sIGEudW5pdCkpLCByID0gciAmJiAhdGhpcy5pc1dvcmtUaW1lKHMsIGEudW5pdCk7XG4gICAgICByZXR1cm4gcjtcbiAgICB9XG4gICAgcmV0dXJuICExO1xuICB9LCBwcm9jZXNzSWdub3JlczogZnVuY3Rpb24oaSkge1xuICAgIGkuaWdub3JlX3ggPSB7fSwgaS5kaXNwbGF5X2NvdW50ID0gaS5jb3VudDtcbiAgfSwgaW5pdENvbFNpemVzOiBmdW5jdGlvbihpLCBhLCByLCBzKSB7XG4gICAgdmFyIG8gPSByO1xuICAgIGkuaGVpZ2h0ID0gcztcbiAgICB2YXIgbCA9IGkuZGlzcGxheV9jb3VudCA9PT0gdm9pZCAwID8gaS5jb3VudCA6IGkuZGlzcGxheV9jb3VudDtcbiAgICBsIHx8IChsID0gMSksIGkuY29sX3dpZHRoID0gTWF0aC5mbG9vcihvIC8gbCksIGEgJiYgaS5jb2xfd2lkdGggPCBhICYmIChpLmNvbF93aWR0aCA9IGEsIG8gPSBpLmNvbF93aWR0aCAqIGwpLCBpLndpZHRoID0gW107XG4gICAgZm9yICh2YXIgZCA9IGkuaWdub3JlX3ggfHwge30sIGMgPSAwOyBjIDwgaS50cmFjZV94Lmxlbmd0aDsgYysrKSBpZiAoZFtpLnRyYWNlX3hbY10udmFsdWVPZigpXSB8fCBpLmRpc3BsYXlfY291bnQgPT0gaS5jb3VudCkgaS53aWR0aFtjXSA9IDA7XG4gICAgZWxzZSB7XG4gICAgICB2YXIgdSA9IDE7XG4gICAgICBpLnVuaXQgPT0gXCJtb250aFwiICYmICh1ID0gTWF0aC5yb3VuZCgoZS5hZGQoaS50cmFjZV94W2NdLCBpLnN0ZXAsIGkudW5pdCkgLSBpLnRyYWNlX3hbY10pIC8gODY0ZTUpKSwgaS53aWR0aFtjXSA9IHU7XG4gICAgfVxuICAgIHRoaXMuYWRqdXN0U2l6ZShvIC0gdGhpcy5nZXRTdW0oaS53aWR0aCksIGkud2lkdGgpLCBpLmZ1bGxfd2lkdGggPSB0aGlzLmdldFN1bShpLndpZHRoKTtcbiAgfSwgaW5pdFNjYWxlQ29uZmlnOiBmdW5jdGlvbihpLCBhLCByKSB7XG4gICAgdmFyIHMgPSBQKHsgY291bnQ6IDAsIGNvbF93aWR0aDogMCwgZnVsbF93aWR0aDogMCwgaGVpZ2h0OiAwLCB3aWR0aDogW10sIGxlZnQ6IFtdLCB0cmFjZV94OiBbXSwgdHJhY2VfaW5kZXhlczoge30sIG1pbl9kYXRlOiBuZXcgRGF0ZShhKSwgbWF4X2RhdGU6IG5ldyBEYXRlKHIpIH0sIGkpO1xuICAgIHJldHVybiB0aGlzLmVhY2hDb2x1bW4oaS51bml0LCBpLnN0ZXAsIGEsIHIsIGZ1bmN0aW9uKG8pIHtcbiAgICAgIHMuY291bnQrKywgcy50cmFjZV94LnB1c2gobmV3IERhdGUobykpLCBzLnRyYWNlX2luZGV4ZXNbby52YWx1ZU9mKCldID0gcy50cmFjZV94Lmxlbmd0aCAtIDE7XG4gICAgfSksIHMudHJhY2VfeF9hc2NlbmRpbmcgPSBzLnRyYWNlX3guc2xpY2UoKSwgcztcbiAgfSwgaXRlcmF0ZVNjYWxlczogZnVuY3Rpb24oaSwgYSwgciwgcywgbykge1xuICAgIGZvciAodmFyIGwgPSBhLnRyYWNlX3gsIGQgPSBpLnRyYWNlX3gsIGMgPSByIHx8IDAsIHUgPSBzIHx8IGQubGVuZ3RoIC0gMSwgaCA9IDAsIGcgPSAxOyBnIDwgbC5sZW5ndGg7IGcrKykge1xuICAgICAgdmFyIHAgPSBpLnRyYWNlX2luZGV4ZXNbK2xbZ11dO1xuICAgICAgcCAhPT0gdm9pZCAwICYmIHAgPD0gdSAmJiAobyAmJiBvLmFwcGx5KHRoaXMsIFtoLCBnLCBjLCBwXSksIGMgPSBwLCBoID0gZyk7XG4gICAgfVxuICB9LCBhbGluZVNjYWxlQ29sdW1uczogZnVuY3Rpb24oaSwgYSwgciwgcykge1xuICAgIHRoaXMuaXRlcmF0ZVNjYWxlcyhpLCBhLCByLCBzLCBmdW5jdGlvbihvLCBsLCBkLCBjKSB7XG4gICAgICB2YXIgdSA9IHRoaXMuZ2V0U3VtKGkud2lkdGgsIGQsIGMgLSAxKTtcbiAgICAgIHRoaXMuZ2V0U3VtKGEud2lkdGgsIG8sIGwgLSAxKSAhPSB1ICYmIHRoaXMuc2V0U3VtV2lkdGgodSwgYSwgbywgbCAtIDEpO1xuICAgIH0pO1xuICB9LCBlYWNoQ29sdW1uOiBmdW5jdGlvbihpLCBhLCByLCBzLCBvKSB7XG4gICAgdmFyIGwgPSBuZXcgRGF0ZShyKSwgZCA9IG5ldyBEYXRlKHMpO1xuICAgIGVbaSArIFwiX3N0YXJ0XCJdICYmIChsID0gZVtpICsgXCJfc3RhcnRcIl0obCkpO1xuICAgIHZhciBjID0gbmV3IERhdGUobCk7XG4gICAgZm9yICgrYyA+PSArZCAmJiAoZCA9IGUuYWRkKGMsIGEsIGkpKTsgK2MgPCArZDsgKSB7XG4gICAgICBvLmNhbGwodGhpcywgbmV3IERhdGUoYykpO1xuICAgICAgdmFyIHUgPSBjLmdldFRpbWV6b25lT2Zmc2V0KCk7XG4gICAgICBjID0gZS5hZGQoYywgYSwgaSksIGMgPSB0Ll9jb3JyZWN0X2RzdF9jaGFuZ2UoYywgdSwgYSwgaSksIGVbaSArIFwiX3N0YXJ0XCJdICYmIChjID0gZVtpICsgXCJfc3RhcnRcIl0oYykpO1xuICAgIH1cbiAgfSwgbGltaXRWaXNpYmxlUmFuZ2U6IGZ1bmN0aW9uKGkpIHtcbiAgICB2YXIgYSA9IGkudHJhY2VfeCwgciA9IGkud2lkdGgubGVuZ3RoIC0gMSwgcyA9IDA7XG4gICAgaWYgKCthWzBdIDwgK2kubWluX2RhdGUgJiYgciAhPSAwKSB7XG4gICAgICB2YXIgbyA9IE1hdGguZmxvb3IoaS53aWR0aFswXSAqICgoYVsxXSAtIGkubWluX2RhdGUpIC8gKGFbMV0gLSBhWzBdKSkpO1xuICAgICAgcyArPSBpLndpZHRoWzBdIC0gbywgaS53aWR0aFswXSA9IG8sIGFbMF0gPSBuZXcgRGF0ZShpLm1pbl9kYXRlKTtcbiAgICB9XG4gICAgdmFyIGwgPSBhLmxlbmd0aCAtIDEsIGQgPSBhW2xdLCBjID0gZS5hZGQoZCwgaS5zdGVwLCBpLnVuaXQpO1xuICAgIGlmICgrYyA+ICtpLm1heF9kYXRlICYmIGwgPiAwICYmIChvID0gaS53aWR0aFtsXSAtIE1hdGguZmxvb3IoaS53aWR0aFtsXSAqICgoYyAtIGkubWF4X2RhdGUpIC8gKGMgLSBkKSkpLCBzICs9IGkud2lkdGhbbF0gLSBvLCBpLndpZHRoW2xdID0gbyksIHMpIHtcbiAgICAgIGZvciAodmFyIHUgPSB0aGlzLmdldFN1bShpLndpZHRoKSwgaCA9IDAsIGcgPSAwOyBnIDwgaS53aWR0aC5sZW5ndGg7IGcrKykge1xuICAgICAgICB2YXIgcCA9IE1hdGguZmxvb3IocyAqIChpLndpZHRoW2ddIC8gdSkpO1xuICAgICAgICBpLndpZHRoW2ddICs9IHAsIGggKz0gcDtcbiAgICAgIH1cbiAgICAgIHRoaXMuYWRqdXN0U2l6ZShzIC0gaCwgaS53aWR0aCk7XG4gICAgfVxuICB9IH07XG59XG5mdW5jdGlvbiB0aSh0KSB7XG4gIHZhciBlID0gZnVuY3Rpb24oYykge1xuICAgIHZhciB1ID0gbmV3IHBlKGMpLnByaW1hcnlTY2FsZSgpLCBoID0gdS51bml0LCBnID0gdS5zdGVwO1xuICAgIGlmIChjLmNvbmZpZy5zY2FsZV9vZmZzZXRfbWluaW1hbCkge1xuICAgICAgdmFyIHAgPSBuZXcgcGUoYyksIHkgPSBbcC5wcmltYXJ5U2NhbGUoKV0uY29uY2F0KHAuZ2V0U3ViU2NhbGVzKCkpO1xuICAgICAgcC5zb3J0U2NhbGVzKHkpLCBoID0geVt5Lmxlbmd0aCAtIDFdLnVuaXQsIGcgPSB5W3kubGVuZ3RoIC0gMV0uc3RlcCB8fCAxO1xuICAgIH1cbiAgICByZXR1cm4geyB1bml0OiBoLCBzdGVwOiBnIH07XG4gIH0odCksIG4gPSBlLnVuaXQsIGkgPSBlLnN0ZXAsIGEgPSBmdW5jdGlvbihjLCB1KSB7XG4gICAgdmFyIGggPSB7IHN0YXJ0X2RhdGU6IG51bGwsIGVuZF9kYXRlOiBudWxsIH07XG4gICAgaWYgKHUuY29uZmlnLnN0YXJ0X2RhdGUgJiYgdS5jb25maWcuZW5kX2RhdGUpIHtcbiAgICAgIGguc3RhcnRfZGF0ZSA9IHUuZGF0ZVtjICsgXCJfc3RhcnRcIl0obmV3IERhdGUodS5jb25maWcuc3RhcnRfZGF0ZSkpO1xuICAgICAgdmFyIGcgPSBuZXcgRGF0ZSh1LmNvbmZpZy5lbmRfZGF0ZSksIHAgPSB1LmRhdGVbYyArIFwiX3N0YXJ0XCJdKG5ldyBEYXRlKGcpKTtcbiAgICAgIGcgPSArZyAhPSArcCA/IHUuZGF0ZS5hZGQocCwgMSwgYykgOiBwLCBoLmVuZF9kYXRlID0gZztcbiAgICB9XG4gICAgcmV0dXJuIGg7XG4gIH0obiwgdCk7XG4gIGlmICghYS5zdGFydF9kYXRlIHx8ICFhLmVuZF9kYXRlKSB7XG4gICAgZm9yICh2YXIgciA9ICEwLCBzID0gdC5nZXRUYXNrQnlUaW1lKCksIG8gPSAwOyBvIDwgcy5sZW5ndGg7IG8rKylcbiAgICAgIGlmIChzW29dLnR5cGUgIT09IHQuY29uZmlnLnR5cGVzLnByb2plY3QpIHtcbiAgICAgICAgciA9ICExO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICBpZiAocy5sZW5ndGggJiYgcikge1xuICAgICAgdmFyIGwgPSBzWzBdLnN0YXJ0X2RhdGUsIGQgPSB0LmRhdGUuYWRkKGwsIDEsIHQuY29uZmlnLmR1cmF0aW9uX3VuaXQpO1xuICAgICAgYSA9IHsgc3RhcnRfZGF0ZTogbmV3IERhdGUobCksIGVuZF9kYXRlOiBuZXcgRGF0ZShkKSB9O1xuICAgIH0gZWxzZSBhID0gdC5nZXRTdWJ0YXNrRGF0ZXMoKTtcbiAgICBhLnN0YXJ0X2RhdGUgJiYgYS5lbmRfZGF0ZSB8fCAoYSA9IHsgc3RhcnRfZGF0ZTogLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCksIGVuZF9kYXRlOiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSB9KSwgdC5lYWNoVGFzayhmdW5jdGlvbihjKSB7XG4gICAgICB0LmNvbmZpZy5kZWFkbGluZXMgJiYgYy5kZWFkbGluZSAmJiBpZShhLCBjLmRlYWRsaW5lLCBjLmRlYWRsaW5lKSwgYy5jb25zdHJhaW50X2RhdGUgJiYgYy5jb25zdHJhaW50X3R5cGUgJiYgdC5jb25maWcuY29uc3RyYWludF90eXBlcyAmJiBjLmNvbnN0cmFpbnRfdHlwZSAhPT0gdC5jb25maWcuY29uc3RyYWludF90eXBlcy5BU0FQICYmIGMuY29uc3RyYWludF90eXBlICE9PSB0LmNvbmZpZy5jb25zdHJhaW50X3R5cGVzLkFMQVAgJiYgaWUoYSwgYy5jb25zdHJhaW50X2RhdGUsIGMuY29uc3RyYWludF9kYXRlKSwgdC5jb25maWcuYmFzZWxpbmVzICYmIGMuYmFzZWxpbmVzICYmIGMuYmFzZWxpbmVzLmZvckVhY2goZnVuY3Rpb24odSkge1xuICAgICAgICBpZShhLCB1LnN0YXJ0X2RhdGUsIHUuZW5kX2RhdGUpO1xuICAgICAgfSk7XG4gICAgfSksIGEuc3RhcnRfZGF0ZSA9IHQuZGF0ZVtuICsgXCJfc3RhcnRcIl0oYS5zdGFydF9kYXRlKSwgYS5zdGFydF9kYXRlID0gdC5jYWxjdWxhdGVFbmREYXRlKHsgc3RhcnRfZGF0ZTogdC5kYXRlW24gKyBcIl9zdGFydFwiXShhLnN0YXJ0X2RhdGUpLCBkdXJhdGlvbjogLTEsIHVuaXQ6IG4sIHN0ZXA6IGkgfSksIGEuZW5kX2RhdGUgPSB0LmRhdGVbbiArIFwiX3N0YXJ0XCJdKGEuZW5kX2RhdGUpLCBhLmVuZF9kYXRlID0gdC5jYWxjdWxhdGVFbmREYXRlKHsgc3RhcnRfZGF0ZTogYS5lbmRfZGF0ZSwgZHVyYXRpb246IDIsIHVuaXQ6IG4sIHN0ZXA6IGkgfSk7XG4gIH1cbiAgdC5fbWluX2RhdGUgPSBhLnN0YXJ0X2RhdGUsIHQuX21heF9kYXRlID0gYS5lbmRfZGF0ZTtcbn1cbmZ1bmN0aW9uIGllKHQsIGUsIG4pIHtcbiAgZSA8IHQuc3RhcnRfZGF0ZSAmJiAodC5zdGFydF9kYXRlID0gbmV3IERhdGUoZSkpLCBuID4gdC5lbmRfZGF0ZSAmJiAodC5lbmRfZGF0ZSA9IG5ldyBEYXRlKG4pKTtcbn1cbmZ1bmN0aW9uIG1lKHQpIHtcbiAgdGkodCksIGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAoZS5jb25maWcuZml0X3Rhc2tzKSB7XG4gICAgICB2YXIgbiA9ICtlLl9taW5fZGF0ZSwgaSA9ICtlLl9tYXhfZGF0ZTtcbiAgICAgIGlmICgrZS5fbWluX2RhdGUgIT0gbiB8fCArZS5fbWF4X2RhdGUgIT0gaSkgcmV0dXJuIGUucmVuZGVyKCksIGUuY2FsbEV2ZW50KFwib25TY2FsZUFkanVzdGVkXCIsIFtdKSwgITA7XG4gICAgfVxuICB9KHQpO1xufVxuZnVuY3Rpb24gUmUodCwgZSwgbikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGUubGVuZ3RoOyBpKyspIHQuaXNMaW5rRXhpc3RzKGVbaV0pICYmIChuW2VbaV1dID0gdC5nZXRMaW5rKGVbaV0pKTtcbn1cbmZ1bmN0aW9uIEhlKHQsIGUsIG4pIHtcbiAgUmUodCwgZS4kc291cmNlLCBuKSwgUmUodCwgZS4kdGFyZ2V0LCBuKTtcbn1cbmNvbnN0IHZlID0geyBnZXRTdWJ0cmVlTGlua3M6IGZ1bmN0aW9uKHQsIGUpIHtcbiAgdmFyIG4gPSB7fTtcbiAgcmV0dXJuIHQuaXNUYXNrRXhpc3RzKGUpICYmIEhlKHQsIHQuZ2V0VGFzayhlKSwgbiksIHQuZWFjaFRhc2soZnVuY3Rpb24oaSkge1xuICAgIEhlKHQsIGksIG4pO1xuICB9LCBlKSwgbjtcbn0sIGdldFN1YnRyZWVUYXNrczogZnVuY3Rpb24odCwgZSkge1xuICB2YXIgbiA9IHt9O1xuICByZXR1cm4gdC5lYWNoVGFzayhmdW5jdGlvbihpKSB7XG4gICAgbltpLmlkXSA9IGk7XG4gIH0sIGUpLCBuO1xufSB9O1xuY2xhc3MgZWkge1xuICBjb25zdHJ1Y3RvcihlLCBuKSB7XG4gICAgdGhpcy4kZ2FudHQgPSBlLCB0aGlzLiRkcCA9IG4sIHRoaXMuX2RhdGFQcm9jZXNzb3JIYW5kbGVycyA9IFtdO1xuICB9XG4gIGF0dGFjaCgpIHtcbiAgICBjb25zdCBlID0gdGhpcy4kZHAsIG4gPSB0aGlzLiRnYW50dCwgaSA9IHt9LCBhID0gKG8pID0+IHRoaXMuY2xpZW50U2lkZURlbGV0ZShvLCBlLCBuKTtcbiAgICB0aGlzLl9kYXRhUHJvY2Vzc29ySGFuZGxlcnMucHVzaChuLmF0dGFjaEV2ZW50KFwib25BZnRlclRhc2tBZGRcIiwgZnVuY3Rpb24obywgbCkge1xuICAgICAgbi5pc1Rhc2tFeGlzdHMobykgJiYgKGUuc2V0R2FudHRNb2RlKFwidGFza3NcIiksIGUuc2V0VXBkYXRlZChvLCAhMCwgXCJpbnNlcnRlZFwiKSk7XG4gICAgfSkpLCB0aGlzLl9kYXRhUHJvY2Vzc29ySGFuZGxlcnMucHVzaChuLmF0dGFjaEV2ZW50KFwib25BZnRlclRhc2tVcGRhdGVcIiwgZnVuY3Rpb24obywgbCkge1xuICAgICAgbi5pc1Rhc2tFeGlzdHMobykgJiYgKGUuc2V0R2FudHRNb2RlKFwidGFza3NcIiksIGUuc2V0VXBkYXRlZChvLCAhMCksIG4uX3NlbmRUYXNrT3JkZXIgJiYgbi5fc2VuZFRhc2tPcmRlcihvLCBsKSk7XG4gICAgfSkpLCB0aGlzLl9kYXRhUHJvY2Vzc29ySGFuZGxlcnMucHVzaChuLmF0dGFjaEV2ZW50KFwib25CZWZvcmVUYXNrRGVsZXRlXCIsIGZ1bmN0aW9uKG8sIGwpIHtcbiAgICAgIHJldHVybiBuLmNvbmZpZy5jYXNjYWRlX2RlbGV0ZSAmJiAoaVtvXSA9IHsgdGFza3M6IHZlLmdldFN1YnRyZWVUYXNrcyhuLCBvKSwgbGlua3M6IHZlLmdldFN1YnRyZWVMaW5rcyhuLCBvKSB9KSwgIWUuZGVsZXRlQWZ0ZXJDb25maXJtYXRpb24gfHwgKGUuc2V0R2FudHRNb2RlKFwidGFza3NcIiksIGUuc2V0VXBkYXRlZChvLCAhMCwgXCJkZWxldGVkXCIpLCAhMSk7XG4gICAgfSkpLCB0aGlzLl9kYXRhUHJvY2Vzc29ySGFuZGxlcnMucHVzaChuLmF0dGFjaEV2ZW50KFwib25BZnRlclRhc2tEZWxldGVcIiwgZnVuY3Rpb24obywgbCkge1xuICAgICAgZS5zZXRHYW50dE1vZGUoXCJ0YXNrc1wiKTtcbiAgICAgIGNvbnN0IGQgPSAhYShvKSwgYyA9IG4uY29uZmlnLmNhc2NhZGVfZGVsZXRlICYmIGlbb107XG4gICAgICBpZiAoZCB8fCBjKSB7XG4gICAgICAgIGlmIChjKSB7XG4gICAgICAgICAgY29uc3QgdSA9IGUudXBkYXRlTW9kZTtcbiAgICAgICAgICBlLnNldFVwZGF0ZU1vZGUoXCJvZmZcIik7XG4gICAgICAgICAgY29uc3QgaCA9IGlbb107XG4gICAgICAgICAgZm9yIChjb25zdCBnIGluIGgudGFza3MpIGEoZykgfHwgKGUuc3RvcmVJdGVtKGgudGFza3NbZ10pLCBlLnNldFVwZGF0ZWQoZywgITAsIFwiZGVsZXRlZFwiKSk7XG4gICAgICAgICAgZS5zZXRHYW50dE1vZGUoXCJsaW5rc1wiKTtcbiAgICAgICAgICBmb3IgKGNvbnN0IGcgaW4gaC5saW5rcykgYShnKSB8fCAoZS5zdG9yZUl0ZW0oaC5saW5rc1tnXSksIGUuc2V0VXBkYXRlZChnLCAhMCwgXCJkZWxldGVkXCIpKTtcbiAgICAgICAgICBpW29dID0gbnVsbCwgdSAhPT0gXCJvZmZcIiAmJiBlLnNlbmRBbGxEYXRhKCksIGUuc2V0R2FudHRNb2RlKFwidGFza3NcIiksIGUuc2V0VXBkYXRlTW9kZSh1KTtcbiAgICAgICAgfVxuICAgICAgICBkICYmIChlLnN0b3JlSXRlbShsKSwgZS5kZWxldGVBZnRlckNvbmZpcm1hdGlvbiB8fCBlLnNldFVwZGF0ZWQobywgITAsIFwiZGVsZXRlZFwiKSksIGUudXBkYXRlTW9kZSA9PT0gXCJvZmZcIiB8fCBlLl90U2VuZCB8fCBlLnNlbmRBbGxEYXRhKCk7XG4gICAgICB9XG4gICAgfSkpLCB0aGlzLl9kYXRhUHJvY2Vzc29ySGFuZGxlcnMucHVzaChuLmF0dGFjaEV2ZW50KFwib25BZnRlckxpbmtVcGRhdGVcIiwgZnVuY3Rpb24obywgbCkge1xuICAgICAgbi5pc0xpbmtFeGlzdHMobykgJiYgKGUuc2V0R2FudHRNb2RlKFwibGlua3NcIiksIGUuc2V0VXBkYXRlZChvLCAhMCkpO1xuICAgIH0pKSwgdGhpcy5fZGF0YVByb2Nlc3NvckhhbmRsZXJzLnB1c2gobi5hdHRhY2hFdmVudChcIm9uQWZ0ZXJMaW5rQWRkXCIsIGZ1bmN0aW9uKG8sIGwpIHtcbiAgICAgIG4uaXNMaW5rRXhpc3RzKG8pICYmIChlLnNldEdhbnR0TW9kZShcImxpbmtzXCIpLCBlLnNldFVwZGF0ZWQobywgITAsIFwiaW5zZXJ0ZWRcIikpO1xuICAgIH0pKSwgdGhpcy5fZGF0YVByb2Nlc3NvckhhbmRsZXJzLnB1c2gobi5hdHRhY2hFdmVudChcIm9uQWZ0ZXJMaW5rRGVsZXRlXCIsIGZ1bmN0aW9uKG8sIGwpIHtcbiAgICAgIGUuc2V0R2FudHRNb2RlKFwibGlua3NcIiksICFhKG8pICYmIChlLnN0b3JlSXRlbShsKSwgZS5zZXRVcGRhdGVkKG8sICEwLCBcImRlbGV0ZWRcIikpO1xuICAgIH0pKSwgdGhpcy5fZGF0YVByb2Nlc3NvckhhbmRsZXJzLnB1c2gobi5hdHRhY2hFdmVudChcIm9uUm93RHJhZ0VuZFwiLCBmdW5jdGlvbihvLCBsKSB7XG4gICAgICBuLl9zZW5kVGFza09yZGVyKG8sIG4uZ2V0VGFzayhvKSk7XG4gICAgfSkpO1xuICAgIGxldCByID0gbnVsbCwgcyA9IG51bGw7XG4gICAgdGhpcy5fZGF0YVByb2Nlc3NvckhhbmRsZXJzLnB1c2gobi5hdHRhY2hFdmVudChcIm9uVGFza0lkQ2hhbmdlXCIsIGZ1bmN0aW9uKG8sIGwpIHtcbiAgICAgIGlmICghZS5fd2FpdE1vZGUpIHJldHVybjtcbiAgICAgIGNvbnN0IGQgPSBuLmdldENoaWxkcmVuKGwpO1xuICAgICAgaWYgKGQubGVuZ3RoKSB7XG4gICAgICAgIHIgPSByIHx8IHt9O1xuICAgICAgICBmb3IgKGxldCB1ID0gMDsgdSA8IGQubGVuZ3RoOyB1KyspIHtcbiAgICAgICAgICBjb25zdCBoID0gdGhpcy5nZXRUYXNrKGRbdV0pO1xuICAgICAgICAgIHJbaC5pZF0gPSBoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBjID0gZnVuY3Rpb24odSkge1xuICAgICAgICBsZXQgaCA9IFtdO1xuICAgICAgICByZXR1cm4gdS4kc291cmNlICYmIChoID0gaC5jb25jYXQodS4kc291cmNlKSksIHUuJHRhcmdldCAmJiAoaCA9IGguY29uY2F0KHUuJHRhcmdldCkpLCBoO1xuICAgICAgfSh0aGlzLmdldFRhc2sobCkpO1xuICAgICAgaWYgKGMubGVuZ3RoKSB7XG4gICAgICAgIHMgPSBzIHx8IHt9O1xuICAgICAgICBmb3IgKGxldCB1ID0gMDsgdSA8IGMubGVuZ3RoOyB1KyspIHtcbiAgICAgICAgICBjb25zdCBoID0gdGhpcy5nZXRMaW5rKGNbdV0pO1xuICAgICAgICAgIHNbaC5pZF0gPSBoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSkpLCBlLmF0dGFjaEV2ZW50KFwib25BZnRlclVwZGF0ZUZpbmlzaFwiLCBmdW5jdGlvbigpIHtcbiAgICAgIChyIHx8IHMpICYmIChuLmJhdGNoVXBkYXRlKGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IgKGNvbnN0IG8gaW4gcikgbi51cGRhdGVUYXNrKHJbb10uaWQpO1xuICAgICAgICBmb3IgKGNvbnN0IG8gaW4gcykgbi51cGRhdGVMaW5rKHNbb10uaWQpO1xuICAgICAgICByID0gbnVsbCwgcyA9IG51bGw7XG4gICAgICB9KSwgciA/IG4uX2RwLnNldEdhbnR0TW9kZShcInRhc2tzXCIpIDogbi5fZHAuc2V0R2FudHRNb2RlKFwibGlua3NcIikpO1xuICAgIH0pLCBlLmF0dGFjaEV2ZW50KFwib25CZWZvcmVEYXRhU2VuZGluZ1wiLCBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLl90TW9kZSA9PT0gXCJDVVNUT01cIikgcmV0dXJuICEwO1xuICAgICAgbGV0IG8gPSB0aGlzLl9zZXJ2ZXJQcm9jZXNzb3I7XG4gICAgICBpZiAodGhpcy5fdE1vZGUgPT09IFwiUkVTVC1KU09OXCIgfHwgdGhpcy5fdE1vZGUgPT09IFwiUkVTVFwiKSB7XG4gICAgICAgIGNvbnN0IGwgPSB0aGlzLl9nYW50dE1vZGU7XG4gICAgICAgIG8gPSBvLnN1YnN0cmluZygwLCBvLmluZGV4T2YoXCI/XCIpID4gLTEgPyBvLmluZGV4T2YoXCI/XCIpIDogby5sZW5ndGgpLCB0aGlzLnNlcnZlclByb2Nlc3NvciA9IG8gKyAoby5zbGljZSgtMSkgPT09IFwiL1wiID8gXCJcIiA6IFwiL1wiKSArIGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBsID0gdGhpcy5fZ2FudHRNb2RlICsgXCJzXCI7XG4gICAgICAgIHRoaXMuc2VydmVyUHJvY2Vzc29yID0gbyArIG4uYWpheC51cmxTZXBhcmF0b3IobykgKyBcImdhbnR0X21vZGU9XCIgKyBsO1xuICAgICAgfVxuICAgICAgcmV0dXJuICEwO1xuICAgIH0pLCBlLmF0dGFjaEV2ZW50KFwiaW5zZXJ0Q2FsbGJhY2tcIiwgZnVuY3Rpb24obywgbCwgZCwgYykge1xuICAgICAgY29uc3QgdSA9IG8uZGF0YSB8fCBuLnhtbC5feG1sTm9kZVRvSlNPTihvLmZpcnN0Q2hpbGQpLCBoID0geyBhZGQ6IG4uYWRkVGFzaywgaXNFeGlzdDogbi5pc1Rhc2tFeGlzdHMgfTtcbiAgICAgIGMgPT09IFwibGlua3NcIiAmJiAoaC5hZGQgPSBuLmFkZExpbmssIGguaXNFeGlzdCA9IG4uaXNMaW5rRXhpc3RzKSwgaC5pc0V4aXN0LmNhbGwobiwgbCkgfHwgKHUuaWQgPSBsLCBoLmFkZC5jYWxsKG4sIHUpKTtcbiAgICB9KSwgZS5hdHRhY2hFdmVudChcInVwZGF0ZUNhbGxiYWNrXCIsIGZ1bmN0aW9uKG8sIGwpIHtcbiAgICAgIGNvbnN0IGQgPSBvLmRhdGEgfHwgbi54bWwuX3htbE5vZGVUb0pTT04oby5maXJzdENoaWxkKTtcbiAgICAgIGlmICghbi5pc1Rhc2tFeGlzdHMobCkpIHJldHVybjtcbiAgICAgIGNvbnN0IGMgPSBuLmdldFRhc2sobCk7XG4gICAgICBmb3IgKGNvbnN0IHUgaW4gZCkge1xuICAgICAgICBsZXQgaCA9IGRbdV07XG4gICAgICAgIHN3aXRjaCAodSkge1xuICAgICAgICAgIGNhc2UgXCJpZFwiOlxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgY2FzZSBcInN0YXJ0X2RhdGVcIjpcbiAgICAgICAgICBjYXNlIFwiZW5kX2RhdGVcIjpcbiAgICAgICAgICAgIGggPSBuLmRlZmluZWQobi50ZW1wbGF0ZXMueG1sX2RhdGUpID8gbi50ZW1wbGF0ZXMueG1sX2RhdGUoaCkgOiBuLnRlbXBsYXRlcy5wYXJzZV9kYXRlKGgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImR1cmF0aW9uXCI6XG4gICAgICAgICAgICBjLmVuZF9kYXRlID0gbi5jYWxjdWxhdGVFbmREYXRlKHsgc3RhcnRfZGF0ZTogYy5zdGFydF9kYXRlLCBkdXJhdGlvbjogaCwgdGFzazogYyB9KTtcbiAgICAgICAgfVxuICAgICAgICBjW3VdID0gaDtcbiAgICAgIH1cbiAgICAgIG4udXBkYXRlVGFzayhsKSwgbi5yZWZyZXNoRGF0YSgpO1xuICAgIH0pLCBlLmF0dGFjaEV2ZW50KFwiZGVsZXRlQ2FsbGJhY2tcIiwgZnVuY3Rpb24obywgbCwgZCwgYykge1xuICAgICAgY29uc3QgdSA9IHsgZGVsZXRlOiBuLmRlbGV0ZVRhc2ssIGlzRXhpc3Q6IG4uaXNUYXNrRXhpc3RzIH07XG4gICAgICBjID09PSBcImxpbmtzXCIgPyAodS5kZWxldGUgPSBuLmRlbGV0ZUxpbmssIHUuaXNFeGlzdCA9IG4uaXNMaW5rRXhpc3RzKSA6IGMgPT09IFwiYXNzaWdubWVudFwiICYmICh1LmRlbGV0ZSA9IGZ1bmN0aW9uKGgpIHtcbiAgICAgICAgbi4kZGF0YS5hc3NpZ25tZW50c1N0b3JlLnJlbW92ZShoKTtcbiAgICAgIH0sIHUuaXNFeGlzdCA9IGZ1bmN0aW9uKGgpIHtcbiAgICAgICAgcmV0dXJuIG4uJGRhdGEuYXNzaWdubWVudHNTdG9yZS5leGlzdHMoaCk7XG4gICAgICB9KSwgdS5pc0V4aXN0LmNhbGwobiwgbCkgJiYgdS5kZWxldGUuY2FsbChuLCBsKTtcbiAgICB9KSwgdGhpcy5oYW5kbGVSZXNvdXJjZUNSVUQoZSwgbiksIHRoaXMuaGFuZGxlUmVzb3VyY2VBc3NpZ25tZW50Q1JVRChlLCBuKSwgdGhpcy5oYW5kbGVCYXNlbGluZUNSVUQoZSwgbik7XG4gIH1cbiAgY2xpZW50U2lkZURlbGV0ZShlLCBuLCBpKSB7XG4gICAgY29uc3QgYSA9IG4udXBkYXRlZFJvd3Muc2xpY2UoKTtcbiAgICBsZXQgciA9ICExO1xuICAgIGkuZ2V0VXNlckRhdGEoZSwgXCIhbmF0aXZlZWRpdG9yX3N0YXR1c1wiLCBuLl9nYW50dE1vZGUpID09PSBcInRydWVfZGVsZXRlZFwiICYmIChyID0gITAsIG4uc2V0VXBkYXRlZChlLCAhMSkpO1xuICAgIGZvciAobGV0IHMgPSAwOyBzIDwgYS5sZW5ndGggJiYgIW4uX2luX3Byb2dyZXNzW2VdOyBzKyspIGFbc10gPT09IGUgJiYgKGkuZ2V0VXNlckRhdGEoZSwgXCIhbmF0aXZlZWRpdG9yX3N0YXR1c1wiLCBuLl9nYW50dE1vZGUpID09PSBcImluc2VydGVkXCIgJiYgKHIgPSAhMCksIG4uc2V0VXBkYXRlZChlLCAhMSkpO1xuICAgIHJldHVybiByO1xuICB9XG4gIGhhbmRsZVJlc291cmNlQXNzaWdubWVudENSVUQoZSwgbikge1xuICAgIGlmICghbi5jb25maWcucmVzb3VyY2VzIHx8IG4uY29uZmlnLnJlc291cmNlcy5kYXRhcHJvY2Vzc29yX2Fzc2lnbm1lbnRzICE9PSAhMCkgcmV0dXJuO1xuICAgIGNvbnN0IGkgPSBuLmdldERhdGFzdG9yZShuLmNvbmZpZy5yZXNvdXJjZV9hc3NpZ25tZW50X3N0b3JlKSwgYSA9IHt9LCByID0ge307XG4gICAgZnVuY3Rpb24gcyhvKSB7XG4gICAgICBjb25zdCBsID0gby5pZDtcbiAgICAgIGkuZXhpc3RzKGwpICYmIChlLnNldEdhbnR0TW9kZShcImFzc2lnbm1lbnRcIiksIGUuc2V0VXBkYXRlZChsLCAhMCwgXCJpbnNlcnRlZFwiKSksIGRlbGV0ZSByW2xdO1xuICAgIH1cbiAgICBuLmF0dGFjaEV2ZW50KFwib25CZWZvcmVUYXNrQWRkXCIsIGZ1bmN0aW9uKG8sIGwpIHtcbiAgICAgIHJldHVybiBhW29dID0gITAsICEwO1xuICAgIH0pLCBuLmF0dGFjaEV2ZW50KFwib25UYXNrSWRDaGFuZ2VcIiwgZnVuY3Rpb24obywgbCkge1xuICAgICAgZGVsZXRlIGFbb107XG4gICAgfSksIGkuYXR0YWNoRXZlbnQoXCJvbkFmdGVyQWRkXCIsIChvLCBsKSA9PiB7XG4gICAgICBhW2wudGFza19pZF0gPyBmdW5jdGlvbihkKSB7XG4gICAgICAgIHJbZC5pZF0gPSBkLCBhW2QudGFza19pZF0gPSAhMDtcbiAgICAgIH0obCkgOiBzKGwpO1xuICAgIH0pLCBpLmF0dGFjaEV2ZW50KFwib25BZnRlclVwZGF0ZVwiLCAobywgbCkgPT4ge1xuICAgICAgaS5leGlzdHMobykgJiYgKHJbb10gPyBzKGwpIDogKGUuc2V0R2FudHRNb2RlKFwiYXNzaWdubWVudFwiKSwgZS5zZXRVcGRhdGVkKG8sICEwKSkpO1xuICAgIH0pLCBpLmF0dGFjaEV2ZW50KFwib25BZnRlckRlbGV0ZVwiLCAobywgbCkgPT4ge1xuICAgICAgZS5zZXRHYW50dE1vZGUoXCJhc3NpZ25tZW50XCIpLCAhdGhpcy5jbGllbnRTaWRlRGVsZXRlKG8sIGUsIG4pICYmIChlLnN0b3JlSXRlbShsKSwgZS5zZXRVcGRhdGVkKG8sICEwLCBcImRlbGV0ZWRcIikpO1xuICAgIH0pO1xuICB9XG4gIGhhbmRsZVJlc291cmNlQ1JVRChlLCBuKSB7XG4gICAgaWYgKCFuLmNvbmZpZy5yZXNvdXJjZXMgfHwgbi5jb25maWcucmVzb3VyY2VzLmRhdGFwcm9jZXNzb3JfcmVzb3VyY2VzICE9PSAhMCkgcmV0dXJuO1xuICAgIGNvbnN0IGkgPSBuLmdldERhdGFzdG9yZShuLmNvbmZpZy5yZXNvdXJjZV9zdG9yZSk7XG4gICAgaS5hdHRhY2hFdmVudChcIm9uQWZ0ZXJBZGRcIiwgKGEsIHIpID0+IHtcbiAgICAgIChmdW5jdGlvbihzKSB7XG4gICAgICAgIGNvbnN0IG8gPSBzLmlkO1xuICAgICAgICBpLmV4aXN0cyhvKSAmJiAoZS5zZXRHYW50dE1vZGUoXCJyZXNvdXJjZVwiKSwgZS5zZXRVcGRhdGVkKG8sICEwLCBcImluc2VydGVkXCIpKTtcbiAgICAgIH0pKHIpO1xuICAgIH0pLCBpLmF0dGFjaEV2ZW50KFwib25BZnRlclVwZGF0ZVwiLCAoYSwgcikgPT4ge1xuICAgICAgaS5leGlzdHMoYSkgJiYgKGUuc2V0R2FudHRNb2RlKFwicmVzb3VyY2VcIiksIGUuc2V0VXBkYXRlZChhLCAhMCkpO1xuICAgIH0pLCBpLmF0dGFjaEV2ZW50KFwib25BZnRlckRlbGV0ZVwiLCAoYSwgcikgPT4ge1xuICAgICAgZS5zZXRHYW50dE1vZGUoXCJyZXNvdXJjZVwiKSwgIXRoaXMuY2xpZW50U2lkZURlbGV0ZShhLCBlLCBuKSAmJiAoZS5zdG9yZUl0ZW0ociksIGUuc2V0VXBkYXRlZChhLCAhMCwgXCJkZWxldGVkXCIpKTtcbiAgICB9KTtcbiAgfVxuICBoYW5kbGVCYXNlbGluZUNSVUQoZSwgbikge1xuICAgIGlmICghbi5jb25maWcuYmFzZWxpbmVzIHx8IG4uY29uZmlnLmJhc2VsaW5lcy5kYXRhcHJvY2Vzc29yX2Jhc2VsaW5lcyAhPT0gITApIHJldHVybjtcbiAgICBjb25zdCBpID0gbi5nZXREYXRhc3RvcmUobi5jb25maWcuYmFzZWxpbmVzLmRhdGFzdG9yZSk7XG4gICAgaS5hdHRhY2hFdmVudChcIm9uQWZ0ZXJBZGRcIiwgKGEsIHIpID0+IHtcbiAgICAgIChmdW5jdGlvbihzKSB7XG4gICAgICAgIGNvbnN0IG8gPSBzLmlkO1xuICAgICAgICBpLmV4aXN0cyhvKSAmJiAoZS5zZXRHYW50dE1vZGUoXCJiYXNlbGluZVwiKSwgZS5zZXRVcGRhdGVkKG8sICEwLCBcImluc2VydGVkXCIpKTtcbiAgICAgIH0pKHIpO1xuICAgIH0pLCBpLmF0dGFjaEV2ZW50KFwib25BZnRlclVwZGF0ZVwiLCAoYSwgcikgPT4ge1xuICAgICAgaS5leGlzdHMoYSkgJiYgKGUuc2V0R2FudHRNb2RlKFwiYmFzZWxpbmVcIiksIGUuc2V0VXBkYXRlZChhLCAhMCkpO1xuICAgIH0pLCBpLmF0dGFjaEV2ZW50KFwib25BZnRlckRlbGV0ZVwiLCAoYSwgcikgPT4ge1xuICAgICAgZS5zZXRHYW50dE1vZGUoXCJiYXNlbGluZVwiKSwgIXRoaXMuY2xpZW50U2lkZURlbGV0ZShhLCBlLCBuKSAmJiAoZS5zdG9yZUl0ZW0ociksIGUuc2V0VXBkYXRlZChhLCAhMCwgXCJkZWxldGVkXCIpKTtcbiAgICB9KTtcbiAgfVxuICBkZXRhY2goKSB7XG4gICAga3QodGhpcy5fZGF0YVByb2Nlc3NvckhhbmRsZXJzLCAoZSkgPT4ge1xuICAgICAgdGhpcy4kZ2FudHQuZGV0YWNoRXZlbnQoZSk7XG4gICAgfSksIHRoaXMuX2RhdGFQcm9jZXNzb3JIYW5kbGVycyA9IFtdO1xuICB9XG59XG5jb25zdCBYdCA9IGNsYXNzIFh0IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5jbGVhciA9ICgpID0+IHtcbiAgICAgIHRoaXMuX3N0b3JhZ2UgPSB7fTtcbiAgICB9LCB0aGlzLnN0b3JlSXRlbSA9IChlKSA9PiB7XG4gICAgICB0aGlzLl9zdG9yYWdlW2UuaWRdID0gcShlKTtcbiAgICB9LCB0aGlzLmdldFN0b3JlZEl0ZW0gPSAoZSkgPT4gdGhpcy5fc3RvcmFnZVtlXSB8fCBudWxsLCB0aGlzLl9zdG9yYWdlID0ge307XG4gIH1cbn07XG5YdC5jcmVhdGUgPSAoKSA9PiBuZXcgWHQoKTtcbmxldCBKdCA9IFh0LCB1biA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IodCkge1xuICAgIHRoaXMuc2VydmVyUHJvY2Vzc29yID0gdCwgdGhpcy5hY3Rpb25fcGFyYW0gPSBcIiFuYXRpdmVlZGl0b3Jfc3RhdHVzXCIsIHRoaXMudXBkYXRlZFJvd3MgPSBbXSwgdGhpcy5hdXRvVXBkYXRlID0gITAsIHRoaXMudXBkYXRlTW9kZSA9IFwiY2VsbFwiLCB0aGlzLl9oZWFkZXJzID0gbnVsbCwgdGhpcy5fcGF5bG9hZCA9IG51bGwsIHRoaXMuX3Bvc3REZWxpbSA9IFwiX1wiLCB0aGlzLl9yb3V0ZXJQYXJhbWV0ZXJzRm9ybWF0ID0gXCJwYXJhbWV0ZXJzXCIsIHRoaXMuX3dhaXRNb2RlID0gMCwgdGhpcy5faW5fcHJvZ3Jlc3MgPSB7fSwgdGhpcy5fc3RvcmFnZSA9IEp0LmNyZWF0ZSgpLCB0aGlzLl9pbnZhbGlkID0ge30sIHRoaXMubWVzc2FnZXMgPSBbXSwgdGhpcy5zdHlsZXMgPSB7IHVwZGF0ZWQ6IFwiZm9udC13ZWlnaHQ6Ym9sZDtcIiwgaW5zZXJ0ZWQ6IFwiZm9udC13ZWlnaHQ6Ym9sZDtcIiwgZGVsZXRlZDogXCJ0ZXh0LWRlY29yYXRpb24gOiBsaW5lLXRocm91Z2g7XCIsIGludmFsaWQ6IFwiYmFja2dyb3VuZC1jb2xvcjpGRkUwRTA7XCIsIGludmFsaWRfY2VsbDogXCJib3JkZXItYm90dG9tOjJweCBzb2xpZCByZWQ7XCIsIGVycm9yOiBcImNvbG9yOnJlZDtcIiwgY2xlYXI6IFwiZm9udC13ZWlnaHQ6bm9ybWFsO3RleHQtZGVjb3JhdGlvbjpub25lO1wiIH0sIHRoaXMuZW5hYmxlVVRGZW5jb2RpbmcoITApLCBvdCh0aGlzKTtcbiAgfVxuICBzZXRUcmFuc2FjdGlvbk1vZGUodCwgZSkge1xuICAgIHR5cGVvZiB0ID09IFwib2JqZWN0XCIgPyAodGhpcy5fdE1vZGUgPSB0Lm1vZGUgfHwgdGhpcy5fdE1vZGUsIFcodC5oZWFkZXJzKSAmJiAodGhpcy5faGVhZGVycyA9IHQuaGVhZGVycyksIFcodC5wYXlsb2FkKSAmJiAodGhpcy5fcGF5bG9hZCA9IHQucGF5bG9hZCksIHRoaXMuX3RTZW5kID0gISFlKSA6ICh0aGlzLl90TW9kZSA9IHQsIHRoaXMuX3RTZW5kID0gZSksIHRoaXMuX3RNb2RlID09PSBcIlJFU1RcIiAmJiAodGhpcy5fdFNlbmQgPSAhMSksIHRoaXMuX3RNb2RlID09PSBcIkpTT05cIiB8fCB0aGlzLl90TW9kZSA9PT0gXCJSRVNULUpTT05cIiA/ICh0aGlzLl90U2VuZCA9ICExLCB0aGlzLl9zZXJpYWxpemVBc0pzb24gPSAhMCwgdGhpcy5faGVhZGVycyA9IHRoaXMuX2hlYWRlcnMgfHwge30sIHRoaXMuX2hlYWRlcnNbXCJDb250ZW50LVR5cGVcIl0gPSBcImFwcGxpY2F0aW9uL2pzb25cIikgOiB0aGlzLl9oZWFkZXJzICYmICF0aGlzLl9oZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdICYmICh0aGlzLl9oZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdID0gXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiksIHRoaXMuX3RNb2RlID09PSBcIkNVU1RPTVwiICYmICh0aGlzLl90U2VuZCA9ICExLCB0aGlzLl9yb3V0ZXIgPSB0LnJvdXRlcik7XG4gIH1cbiAgZXNjYXBlKHQpIHtcbiAgICByZXR1cm4gdGhpcy5fdXRmID8gZW5jb2RlVVJJQ29tcG9uZW50KHQpIDogZXNjYXBlKHQpO1xuICB9XG4gIGVuYWJsZVVURmVuY29kaW5nKHQpIHtcbiAgICB0aGlzLl91dGYgPSAhIXQ7XG4gIH1cbiAgZ2V0U3luY1N0YXRlKCkge1xuICAgIHJldHVybiAhdGhpcy51cGRhdGVkUm93cy5sZW5ndGg7XG4gIH1cbiAgc2V0VXBkYXRlTW9kZSh0LCBlKSB7XG4gICAgdGhpcy5hdXRvVXBkYXRlID0gdCA9PT0gXCJjZWxsXCIsIHRoaXMudXBkYXRlTW9kZSA9IHQsIHRoaXMuZG5kID0gZTtcbiAgfVxuICBpZ25vcmUodCwgZSkge1xuICAgIHRoaXMuX3NpbGVudF9tb2RlID0gITAsIHQuY2FsbChlIHx8IGR0KSwgdGhpcy5fc2lsZW50X21vZGUgPSAhMTtcbiAgfVxuICBzZXRVcGRhdGVkKHQsIGUsIG4pIHtcbiAgICBpZiAodGhpcy5fc2lsZW50X21vZGUpIHJldHVybjtcbiAgICBjb25zdCBpID0gdGhpcy5maW5kUm93KHQpO1xuICAgIG4gPSBuIHx8IFwidXBkYXRlZFwiO1xuICAgIGNvbnN0IGEgPSB0aGlzLiRnYW50dC5nZXRVc2VyRGF0YSh0LCB0aGlzLmFjdGlvbl9wYXJhbSwgdGhpcy5fZ2FudHRNb2RlKTtcbiAgICBhICYmIG4gPT09IFwidXBkYXRlZFwiICYmIChuID0gYSksIGUgPyAodGhpcy5zZXRfaW52YWxpZCh0LCAhMSksIHRoaXMudXBkYXRlZFJvd3NbaV0gPSB0LCB0aGlzLiRnYW50dC5zZXRVc2VyRGF0YSh0LCB0aGlzLmFjdGlvbl9wYXJhbSwgbiwgdGhpcy5fZ2FudHRNb2RlKSwgdGhpcy5faW5fcHJvZ3Jlc3NbdF0gJiYgKHRoaXMuX2luX3Byb2dyZXNzW3RdID0gXCJ3YWl0XCIpKSA6IHRoaXMuaXNfaW52YWxpZCh0KSB8fCAodGhpcy51cGRhdGVkUm93cy5zcGxpY2UoaSwgMSksIHRoaXMuJGdhbnR0LnNldFVzZXJEYXRhKHQsIHRoaXMuYWN0aW9uX3BhcmFtLCBcIlwiLCB0aGlzLl9nYW50dE1vZGUpKSwgdGhpcy5tYXJrUm93KHQsIGUsIG4pLCBlICYmIHRoaXMuYXV0b1VwZGF0ZSAmJiB0aGlzLnNlbmREYXRhKHQpO1xuICB9XG4gIG1hcmtSb3codCwgZSwgbikge1xuICAgIGxldCBpID0gXCJcIjtcbiAgICBjb25zdCBhID0gdGhpcy5pc19pbnZhbGlkKHQpO1xuICAgIGlmIChhICYmIChpID0gdGhpcy5zdHlsZXNbYV0sIGUgPSAhMCksIHRoaXMuY2FsbEV2ZW50KFwib25Sb3dNYXJrXCIsIFt0LCBlLCBuLCBhXSkgJiYgKGkgPSB0aGlzLnN0eWxlc1tlID8gbiA6IFwiY2xlYXJcIl0gKyBcIiBcIiArIGksIHRoaXMuJGdhbnR0W3RoaXMuX21ldGhvZHNbMF1dKHQsIGkpLCBhICYmIGEuZGV0YWlscykpIHtcbiAgICAgIGkgKz0gdGhpcy5zdHlsZXNbYSArIFwiX2NlbGxcIl07XG4gICAgICBmb3IgKGxldCByID0gMDsgciA8IGEuZGV0YWlscy5sZW5ndGg7IHIrKykgYS5kZXRhaWxzW3JdICYmIHRoaXMuJGdhbnR0W3RoaXMuX21ldGhvZHNbMV1dKHQsIHIsIGkpO1xuICAgIH1cbiAgfVxuICBnZXRBY3Rpb25CeVN0YXRlKHQpIHtcbiAgICByZXR1cm4gdCA9PT0gXCJpbnNlcnRlZFwiID8gXCJjcmVhdGVcIiA6IHQgPT09IFwidXBkYXRlZFwiID8gXCJ1cGRhdGVcIiA6IHQgPT09IFwiZGVsZXRlZFwiID8gXCJkZWxldGVcIiA6IFwidXBkYXRlXCI7XG4gIH1cbiAgZ2V0U3RhdGUodCkge1xuICAgIHJldHVybiB0aGlzLiRnYW50dC5nZXRVc2VyRGF0YSh0LCB0aGlzLmFjdGlvbl9wYXJhbSwgdGhpcy5fZ2FudHRNb2RlKTtcbiAgfVxuICBpc19pbnZhbGlkKHQpIHtcbiAgICByZXR1cm4gdGhpcy5faW52YWxpZFt0XTtcbiAgfVxuICBzZXRfaW52YWxpZCh0LCBlLCBuKSB7XG4gICAgbiAmJiAoZSA9IHsgdmFsdWU6IGUsIGRldGFpbHM6IG4sIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnZhbHVlLnRvU3RyaW5nKCk7XG4gICAgfSB9KSwgdGhpcy5faW52YWxpZFt0XSA9IGU7XG4gIH1cbiAgY2hlY2tCZWZvcmVVcGRhdGUodCkge1xuICAgIHJldHVybiAhMDtcbiAgfVxuICBzZW5kRGF0YSh0KSB7XG4gICAgaWYgKHRoaXMuJGdhbnR0LmVkaXRTdG9wICYmIHRoaXMuJGdhbnR0LmVkaXRTdG9wKCksIHQgPT09IHZvaWQgMCB8fCB0aGlzLl90U2VuZCkge1xuICAgICAgY29uc3QgZSA9IFtdO1xuICAgICAgaWYgKHRoaXMubW9kZXMgJiYgW1widGFza1wiLCBcImxpbmtcIiwgXCJhc3NpZ25tZW50XCIsIFwiYmFzZWxpbmVcIl0uZm9yRWFjaCgobikgPT4ge1xuICAgICAgICB0aGlzLm1vZGVzW25dICYmIHRoaXMubW9kZXNbbl0udXBkYXRlZFJvd3MubGVuZ3RoICYmIGUucHVzaChuKTtcbiAgICAgIH0pLCBlLmxlbmd0aCkge1xuICAgICAgICBmb3IgKGxldCBuID0gMDsgbiA8IGUubGVuZ3RoOyBuKyspIHRoaXMuc2V0R2FudHRNb2RlKGVbbl0pLCB0aGlzLnNlbmRBbGxEYXRhKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnNlbmRBbGxEYXRhKCk7XG4gICAgfVxuICAgIHJldHVybiAhdGhpcy5faW5fcHJvZ3Jlc3NbdF0gJiYgKHRoaXMubWVzc2FnZXMgPSBbXSwgISghdGhpcy5jaGVja0JlZm9yZVVwZGF0ZSh0KSAmJiB0aGlzLmNhbGxFdmVudChcIm9uVmFsaWRhdGlvbkVycm9yXCIsIFt0LCB0aGlzLm1lc3NhZ2VzXSkpICYmIHZvaWQgdGhpcy5fYmVmb3JlU2VuZERhdGEodGhpcy5fZ2V0Um93RGF0YSh0KSwgdCkpO1xuICB9XG4gIHNlcmlhbGl6ZSh0LCBlKSB7XG4gICAgaWYgKHRoaXMuX3NlcmlhbGl6ZUFzSnNvbikgcmV0dXJuIHRoaXMuX3NlcmlhbGl6ZUFzSlNPTih0KTtcbiAgICBpZiAodHlwZW9mIHQgPT0gXCJzdHJpbmdcIikgcmV0dXJuIHQ7XG4gICAgaWYgKGUgIT09IHZvaWQgMCkgcmV0dXJuIHRoaXMuc2VyaWFsaXplX29uZSh0LCBcIlwiKTtcbiAgICB7XG4gICAgICBjb25zdCBuID0gW10sIGkgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgYSBpbiB0KSB0Lmhhc093blByb3BlcnR5KGEpICYmIChuLnB1c2godGhpcy5zZXJpYWxpemVfb25lKHRbYV0sIGEgKyB0aGlzLl9wb3N0RGVsaW0pKSwgaS5wdXNoKGEpKTtcbiAgICAgIHJldHVybiBuLnB1c2goXCJpZHM9XCIgKyB0aGlzLmVzY2FwZShpLmpvaW4oXCIsXCIpKSksIHRoaXMuJGdhbnR0LnNlY3VyaXR5X2tleSAmJiBuLnB1c2goXCJkaHhfc2VjdXJpdHk9XCIgKyB0aGlzLiRnYW50dC5zZWN1cml0eV9rZXkpLCBuLmpvaW4oXCImXCIpO1xuICAgIH1cbiAgfVxuICBzZXJpYWxpemVfb25lKHQsIGUpIHtcbiAgICBpZiAodHlwZW9mIHQgPT0gXCJzdHJpbmdcIikgcmV0dXJuIHQ7XG4gICAgY29uc3QgbiA9IFtdO1xuICAgIGxldCBpID0gXCJcIjtcbiAgICBmb3IgKGNvbnN0IGEgaW4gdCkgaWYgKHQuaGFzT3duUHJvcGVydHkoYSkpIHtcbiAgICAgIGlmICgoYSA9PT0gXCJpZFwiIHx8IGEgPT0gdGhpcy5hY3Rpb25fcGFyYW0pICYmIHRoaXMuX3RNb2RlID09PSBcIlJFU1RcIikgY29udGludWU7XG4gICAgICBpID0gdHlwZW9mIHRbYV0gPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdFthXSA9PSBcIm51bWJlclwiID8gU3RyaW5nKHRbYV0pIDogSlNPTi5zdHJpbmdpZnkodFthXSksIG4ucHVzaCh0aGlzLmVzY2FwZSgoZSB8fCBcIlwiKSArIGEpICsgXCI9XCIgKyB0aGlzLmVzY2FwZShpKSk7XG4gICAgfVxuICAgIHJldHVybiBuLmpvaW4oXCImXCIpO1xuICB9XG4gIHNlbmRBbGxEYXRhKCkge1xuICAgIGlmICghdGhpcy51cGRhdGVkUm93cy5sZW5ndGgpIHJldHVybjtcbiAgICB0aGlzLm1lc3NhZ2VzID0gW107XG4gICAgbGV0IHQgPSAhMDtcbiAgICBpZiAodGhpcy5fZm9yRWFjaFVwZGF0ZWRSb3coZnVuY3Rpb24oZSkge1xuICAgICAgdCA9IHQgJiYgdGhpcy5jaGVja0JlZm9yZVVwZGF0ZShlKTtcbiAgICB9KSwgIXQgJiYgIXRoaXMuY2FsbEV2ZW50KFwib25WYWxpZGF0aW9uRXJyb3JcIiwgW1wiXCIsIHRoaXMubWVzc2FnZXNdKSkgcmV0dXJuICExO1xuICAgIHRoaXMuX3RTZW5kID8gdGhpcy5fc2VuZERhdGEodGhpcy5fZ2V0QWxsRGF0YSgpKSA6IHRoaXMuX2ZvckVhY2hVcGRhdGVkUm93KGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmICghdGhpcy5faW5fcHJvZ3Jlc3NbZV0pIHtcbiAgICAgICAgaWYgKHRoaXMuaXNfaW52YWxpZChlKSkgcmV0dXJuO1xuICAgICAgICB0aGlzLl9iZWZvcmVTZW5kRGF0YSh0aGlzLl9nZXRSb3dEYXRhKGUpLCBlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBmaW5kUm93KHQpIHtcbiAgICBsZXQgZSA9IDA7XG4gICAgZm9yIChlID0gMDsgZSA8IHRoaXMudXBkYXRlZFJvd3MubGVuZ3RoICYmIHQgIT0gdGhpcy51cGRhdGVkUm93c1tlXTsgZSsrKSA7XG4gICAgcmV0dXJuIGU7XG4gIH1cbiAgZGVmaW5lQWN0aW9uKHQsIGUpIHtcbiAgICB0aGlzLl91QWN0aW9ucyB8fCAodGhpcy5fdUFjdGlvbnMgPSB7fSksIHRoaXMuX3VBY3Rpb25zW3RdID0gZTtcbiAgfVxuICBhZnRlclVwZGF0ZUNhbGxiYWNrKHQsIGUsIG4sIGksIGEpIHtcbiAgICBpZiAoIXRoaXMuJGdhbnR0KSByZXR1cm47XG4gICAgdGhpcy5zZXRHYW50dE1vZGUoYSk7XG4gICAgY29uc3QgciA9IHQsIHMgPSBuICE9PSBcImVycm9yXCIgJiYgbiAhPT0gXCJpbnZhbGlkXCI7XG4gICAgaWYgKHMgfHwgdGhpcy5zZXRfaW52YWxpZCh0LCBuKSwgdGhpcy5fdUFjdGlvbnMgJiYgdGhpcy5fdUFjdGlvbnNbbl0gJiYgIXRoaXMuX3VBY3Rpb25zW25dKGkpKSByZXR1cm4gZGVsZXRlIHRoaXMuX2luX3Byb2dyZXNzW3JdO1xuICAgIHRoaXMuX2luX3Byb2dyZXNzW3JdICE9PSBcIndhaXRcIiAmJiB0aGlzLnNldFVwZGF0ZWQodCwgITEpO1xuICAgIGNvbnN0IG8gPSB0O1xuICAgIHN3aXRjaCAobikge1xuICAgICAgY2FzZSBcImluc2VydGVkXCI6XG4gICAgICBjYXNlIFwiaW5zZXJ0XCI6XG4gICAgICAgIGUgIT0gdCAmJiAodGhpcy5zZXRVcGRhdGVkKHQsICExKSwgdGhpcy4kZ2FudHRbdGhpcy5fbWV0aG9kc1syXV0odCwgZSksIHQgPSBlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZGVsZXRlXCI6XG4gICAgICBjYXNlIFwiZGVsZXRlZFwiOlxuICAgICAgICBpZiAodGhpcy5kZWxldGVBZnRlckNvbmZpcm1hdGlvbiAmJiB0aGlzLl9nYW50dE1vZGUgPT09IFwidGFza1wiKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2dhbnR0TW9kZSA9PT0gXCJ0YXNrXCIgJiYgdGhpcy4kZ2FudHQuaXNUYXNrRXhpc3RzKHQpKSB7XG4gICAgICAgICAgICB0aGlzLiRnYW50dC5zZXRVc2VyRGF0YSh0LCB0aGlzLmFjdGlvbl9wYXJhbSwgXCJ0cnVlX2RlbGV0ZWRcIiwgdGhpcy5fZ2FudHRNb2RlKTtcbiAgICAgICAgICAgIGNvbnN0IGwgPSB0aGlzLiRnYW50dC5nZXRUYXNrKHQpO1xuICAgICAgICAgICAgdGhpcy4kZ2FudHQuc2lsZW50KCgpID0+IHtcbiAgICAgICAgICAgICAgdGhpcy4kZ2FudHQuZGVsZXRlVGFzayh0KTtcbiAgICAgICAgICAgIH0pLCB0aGlzLiRnYW50dC5jYWxsRXZlbnQoXCJvbkFmdGVyVGFza0RlbGV0ZVwiLCBbdCwgbF0pLCB0aGlzLiRnYW50dC5yZW5kZXIoKSwgZGVsZXRlIHRoaXMuX2luX3Byb2dyZXNzW3JdO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpcy5jYWxsRXZlbnQoXCJvbkFmdGVyVXBkYXRlXCIsIFt0LCBuLCBlLCBpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuJGdhbnR0LnNldFVzZXJEYXRhKHQsIHRoaXMuYWN0aW9uX3BhcmFtLCBcInRydWVfZGVsZXRlZFwiLCB0aGlzLl9nYW50dE1vZGUpLCB0aGlzLiRnYW50dFt0aGlzLl9tZXRob2RzWzNdXSh0KSwgZGVsZXRlIHRoaXMuX2luX3Byb2dyZXNzW3JdLCB0aGlzLmNhbGxFdmVudChcIm9uQWZ0ZXJVcGRhdGVcIiwgW3QsIG4sIGUsIGldKTtcbiAgICB9XG4gICAgdGhpcy5faW5fcHJvZ3Jlc3Nbcl0gIT09IFwid2FpdFwiID8gKHMgJiYgdGhpcy4kZ2FudHQuc2V0VXNlckRhdGEodCwgdGhpcy5hY3Rpb25fcGFyYW0sIFwiXCIsIHRoaXMuX2dhbnR0TW9kZSksIGRlbGV0ZSB0aGlzLl9pbl9wcm9ncmVzc1tyXSkgOiAoZGVsZXRlIHRoaXMuX2luX3Byb2dyZXNzW3JdLCB0aGlzLnNldFVwZGF0ZWQoZSwgITAsIHRoaXMuJGdhbnR0LmdldFVzZXJEYXRhKHQsIHRoaXMuYWN0aW9uX3BhcmFtLCB0aGlzLl9nYW50dE1vZGUpKSksIHRoaXMuY2FsbEV2ZW50KFwib25BZnRlclVwZGF0ZVwiLCBbbywgbiwgZSwgaV0pO1xuICB9XG4gIGFmdGVyVXBkYXRlKHQsIGUsIG4pIHtcbiAgICBsZXQgaTtcbiAgICBpID0gYXJndW1lbnRzLmxlbmd0aCA9PT0gMyA/IGFyZ3VtZW50c1sxXSA6IGFyZ3VtZW50c1s0XTtcbiAgICBsZXQgYSA9IHRoaXMuZ2V0R2FudHRNb2RlKCk7XG4gICAgY29uc3QgciA9IGkuZmlsZVBhdGggfHwgaS51cmw7XG4gICAgYSA9IHRoaXMuX3RNb2RlICE9PSBcIlJFU1RcIiAmJiB0aGlzLl90TW9kZSAhPT0gXCJSRVNULUpTT05cIiA/IHIuaW5kZXhPZihcImdhbnR0X21vZGU9bGlua3NcIikgIT09IC0xID8gXCJsaW5rXCIgOiByLmluZGV4T2YoXCJnYW50dF9tb2RlPWFzc2lnbm1lbnRzXCIpICE9PSAtMSA/IFwiYXNzaWdubWVudFwiIDogci5pbmRleE9mKFwiZ2FudHRfbW9kZT1iYXNlbGluZXNcIikgIT09IC0xID8gXCJiYXNlbGluZVwiIDogXCJ0YXNrXCIgOiByLmluZGV4T2YoXCIvbGlua1wiKSA+PSAwID8gXCJsaW5rXCIgOiByLmluZGV4T2YoXCIvYXNzaWdubWVudFwiKSA+PSAwID8gXCJhc3NpZ25tZW50XCIgOiByLmluZGV4T2YoXCIvYmFzZWxpbmVcIikgPj0gMCA/IFwiYmFzZWxpbmVcIiA6IFwidGFza1wiLCB0aGlzLnNldEdhbnR0TW9kZShhKTtcbiAgICBjb25zdCBzID0gdGhpcy4kZ2FudHQuYWpheDtcbiAgICBsZXQgbztcbiAgICB0cnkge1xuICAgICAgbyA9IEpTT04ucGFyc2UoZS54bWxEb2MucmVzcG9uc2VUZXh0KTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIGUueG1sRG9jLnJlc3BvbnNlVGV4dC5sZW5ndGggfHwgKG8gPSB7fSk7XG4gICAgfVxuICAgIGNvbnN0IGwgPSAodSkgPT4ge1xuICAgICAgY29uc3QgaCA9IG8uYWN0aW9uIHx8IHRoaXMuZ2V0U3RhdGUodSkgfHwgXCJ1cGRhdGVkXCIsIGcgPSBvLnNpZCB8fCB1WzBdLCBwID0gby50aWQgfHwgdVswXTtcbiAgICAgIHQuYWZ0ZXJVcGRhdGVDYWxsYmFjayhnLCBwLCBoLCBvLCBhKTtcbiAgICB9O1xuICAgIGlmIChvKSByZXR1cm4gQXJyYXkuaXNBcnJheShuKSAmJiBuLmxlbmd0aCA+IDEgPyBuLmZvckVhY2goKHUpID0+IGwodSkpIDogbChuKSwgdC5maW5hbGl6ZVVwZGF0ZSgpLCB2b2lkIHRoaXMuc2V0R2FudHRNb2RlKGEpO1xuICAgIGNvbnN0IGQgPSBzLnhtbHRvcChcImRhdGFcIiwgZS54bWxEb2MpO1xuICAgIGlmICghZCkgcmV0dXJuIHRoaXMuY2xlYW5VcGRhdGUobik7XG4gICAgY29uc3QgYyA9IHMueHBhdGgoXCIvL2RhdGEvYWN0aW9uXCIsIGQpO1xuICAgIGlmICghYy5sZW5ndGgpIHJldHVybiB0aGlzLmNsZWFuVXBkYXRlKG4pO1xuICAgIGZvciAobGV0IHUgPSAwOyB1IDwgYy5sZW5ndGg7IHUrKykge1xuICAgICAgY29uc3QgaCA9IGNbdV0sIGcgPSBoLmdldEF0dHJpYnV0ZShcInR5cGVcIiksIHAgPSBoLmdldEF0dHJpYnV0ZShcInNpZFwiKSwgeSA9IGguZ2V0QXR0cmlidXRlKFwidGlkXCIpO1xuICAgICAgdC5hZnRlclVwZGF0ZUNhbGxiYWNrKHAsIHksIGcsIGgsIGEpO1xuICAgIH1cbiAgICB0LmZpbmFsaXplVXBkYXRlKCk7XG4gIH1cbiAgY2xlYW5VcGRhdGUodCkge1xuICAgIGlmICh0KSBmb3IgKGxldCBlID0gMDsgZSA8IHQubGVuZ3RoOyBlKyspIGRlbGV0ZSB0aGlzLl9pbl9wcm9ncmVzc1t0W2VdXTtcbiAgfVxuICBmaW5hbGl6ZVVwZGF0ZSgpIHtcbiAgICB0aGlzLl93YWl0TW9kZSAmJiB0aGlzLl93YWl0TW9kZS0tLCB0aGlzLmNhbGxFdmVudChcIm9uQWZ0ZXJVcGRhdGVGaW5pc2hcIiwgW10pLCB0aGlzLnVwZGF0ZWRSb3dzLmxlbmd0aCB8fCB0aGlzLmNhbGxFdmVudChcIm9uRnVsbFN5bmNcIiwgW10pO1xuICB9XG4gIGluaXQodCkge1xuICAgIGlmICh0aGlzLl9pbml0aWFsaXplZCkgcmV0dXJuO1xuICAgIHRoaXMuJGdhbnR0ID0gdCwgdGhpcy4kZ2FudHQuX2RwX2luaXQgJiYgdGhpcy4kZ2FudHQuX2RwX2luaXQodGhpcyksIHRoaXMuX3NldERlZmF1bHRUcmFuc2FjdGlvbk1vZGUoKSwgdGhpcy5zdHlsZXMgPSB7IHVwZGF0ZWQ6IFwiZ2FudHRfdXBkYXRlZFwiLCBvcmRlcjogXCJnYW50dF91cGRhdGVkXCIsIGluc2VydGVkOiBcImdhbnR0X2luc2VydGVkXCIsIGRlbGV0ZWQ6IFwiZ2FudHRfZGVsZXRlZFwiLCBkZWxldGVfY29uZmlybWF0aW9uOiBcImdhbnR0X2RlbGV0ZWRcIiwgaW52YWxpZDogXCJnYW50dF9pbnZhbGlkXCIsIGVycm9yOiBcImdhbnR0X2Vycm9yXCIsIGNsZWFyOiBcIlwiIH0sIHRoaXMuX21ldGhvZHMgPSBbXCJfcm93X3N0eWxlXCIsIFwic2V0Q2VsbFRleHRTdHlsZVwiLCBcIl9jaGFuZ2VfaWRcIiwgXCJfZGVsZXRlX3Rhc2tcIl0sIGZ1bmN0aW9uKG4sIGkpIHtcbiAgICAgIG4uZ2V0VXNlckRhdGEgPSBmdW5jdGlvbihhLCByLCBzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVzZXJkYXRhIHx8ICh0aGlzLnVzZXJkYXRhID0ge30pLCB0aGlzLnVzZXJkYXRhW3NdID0gdGhpcy51c2VyZGF0YVtzXSB8fCB7fSwgdGhpcy51c2VyZGF0YVtzXVthXSAmJiB0aGlzLnVzZXJkYXRhW3NdW2FdW3JdID8gdGhpcy51c2VyZGF0YVtzXVthXVtyXSA6IFwiXCI7XG4gICAgICB9LCBuLnNldFVzZXJEYXRhID0gZnVuY3Rpb24oYSwgciwgcywgbykge1xuICAgICAgICB0aGlzLnVzZXJkYXRhIHx8ICh0aGlzLnVzZXJkYXRhID0ge30pLCB0aGlzLnVzZXJkYXRhW29dID0gdGhpcy51c2VyZGF0YVtvXSB8fCB7fSwgdGhpcy51c2VyZGF0YVtvXVthXSA9IHRoaXMudXNlcmRhdGFbb11bYV0gfHwge30sIHRoaXMudXNlcmRhdGFbb11bYV1bcl0gPSBzO1xuICAgICAgfSwgbi5fY2hhbmdlX2lkID0gZnVuY3Rpb24oYSwgcikge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuX2RwLl9nYW50dE1vZGUpIHtcbiAgICAgICAgICBjYXNlIFwidGFza1wiOlxuICAgICAgICAgICAgdGhpcy5jaGFuZ2VUYXNrSWQoYSwgcik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwibGlua1wiOlxuICAgICAgICAgICAgdGhpcy5jaGFuZ2VMaW5rSWQoYSwgcik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiYXNzaWdubWVudFwiOlxuICAgICAgICAgICAgdGhpcy4kZGF0YS5hc3NpZ25tZW50c1N0b3JlLmNoYW5nZUlkKGEsIHIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcInJlc291cmNlXCI6XG4gICAgICAgICAgICB0aGlzLiRkYXRhLnJlc291cmNlc1N0b3JlLmNoYW5nZUlkKGEsIHIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImJhc2VsaW5lXCI6XG4gICAgICAgICAgICB0aGlzLiRkYXRhLmJhc2VsaW5lU3RvcmUuY2hhbmdlSWQoYSwgcik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG1vZGUgb2YgdGhlIGRhdGFQcm9jZXNzb3IgYWZ0ZXIgZGF0YWJhc2UgaWQgaXMgcmVjZWl2ZWQ6ICR7dGhpcy5fZHAuX2dhbnR0TW9kZX0sIG5ldyBpZDogJHtyfWApO1xuICAgICAgICB9XG4gICAgICB9LCBuLl9yb3dfc3R5bGUgPSBmdW5jdGlvbihhLCByKSB7XG4gICAgICAgIHRoaXMuX2RwLl9nYW50dE1vZGUgPT09IFwidGFza1wiICYmIG4uaXNUYXNrRXhpc3RzKGEpICYmIChuLmdldFRhc2soYSkuJGRhdGFwcm9jZXNzb3JfY2xhc3MgPSByLCBuLnJlZnJlc2hUYXNrKGEpKTtcbiAgICAgIH0sIG4uX2RlbGV0ZV90YXNrID0gZnVuY3Rpb24oYSwgcikge1xuICAgICAgfSwgbi5fc2VuZFRhc2tPcmRlciA9IGZ1bmN0aW9uKGEsIHIpIHtcbiAgICAgICAgci4kZHJvcF90YXJnZXQgJiYgKHRoaXMuX2RwLnNldEdhbnR0TW9kZShcInRhc2tcIiksIHRoaXMuZ2V0VGFzayhhKS50YXJnZXQgPSByLiRkcm9wX3RhcmdldCwgdGhpcy5fZHAuc2V0VXBkYXRlZChhLCAhMCwgXCJvcmRlclwiKSwgZGVsZXRlIHRoaXMuZ2V0VGFzayhhKS4kZHJvcF90YXJnZXQpO1xuICAgICAgfSwgbi5zZXREcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9kcCA9IGk7XG4gICAgICB9LCBuLnNldERwKCk7XG4gICAgfSh0aGlzLiRnYW50dCwgdGhpcyk7XG4gICAgY29uc3QgZSA9IG5ldyBlaSh0aGlzLiRnYW50dCwgdGhpcyk7XG4gICAgZS5hdHRhY2goKSwgdGhpcy5hdHRhY2hFdmVudChcIm9uRGVzdHJveVwiLCBmdW5jdGlvbigpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLnNldEdhbnR0TW9kZSwgZGVsZXRlIHRoaXMuX2dldFJvd0RhdGEsIGRlbGV0ZSB0aGlzLiRnYW50dC5fZHAsIGRlbGV0ZSB0aGlzLiRnYW50dC5fY2hhbmdlX2lkLCBkZWxldGUgdGhpcy4kZ2FudHQuX3Jvd19zdHlsZSwgZGVsZXRlIHRoaXMuJGdhbnR0Ll9kZWxldGVfdGFzaywgZGVsZXRlIHRoaXMuJGdhbnR0Ll9zZW5kVGFza09yZGVyLCBkZWxldGUgdGhpcy4kZ2FudHQsIGUuZGV0YWNoKCk7XG4gICAgfSksIHRoaXMuJGdhbnR0LmNhbGxFdmVudChcIm9uRGF0YVByb2Nlc3NvclJlYWR5XCIsIFt0aGlzXSksIHRoaXMuX2luaXRpYWxpemVkID0gITA7XG4gIH1cbiAgc2V0T25BZnRlclVwZGF0ZSh0KSB7XG4gICAgdGhpcy5hdHRhY2hFdmVudChcIm9uQWZ0ZXJVcGRhdGVcIiwgdCk7XG4gIH1cbiAgc2V0T25CZWZvcmVVcGRhdGVIYW5kbGVyKHQpIHtcbiAgICB0aGlzLmF0dGFjaEV2ZW50KFwib25CZWZvcmVEYXRhU2VuZGluZ1wiLCB0KTtcbiAgfVxuICBzZXRBdXRvVXBkYXRlKHQsIGUpIHtcbiAgICB0ID0gdCB8fCAyZTMsIHRoaXMuX3VzZXIgPSBlIHx8ICgvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSkudmFsdWVPZigpLCB0aGlzLl9uZWVkVXBkYXRlID0gITEsIHRoaXMuX3VwZGF0ZUJ1c3kgPSAhMSwgdGhpcy5hdHRhY2hFdmVudChcIm9uQWZ0ZXJVcGRhdGVcIiwgdGhpcy5hZnRlckF1dG9VcGRhdGUpLCB0aGlzLmF0dGFjaEV2ZW50KFwib25GdWxsU3luY1wiLCB0aGlzLmZ1bGxTeW5jKSwgc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgdGhpcy5sb2FkVXBkYXRlKCk7XG4gICAgfSwgdCk7XG4gIH1cbiAgYWZ0ZXJBdXRvVXBkYXRlKHQsIGUsIG4sIGkpIHtcbiAgICByZXR1cm4gZSAhPT0gXCJjb2xsaXNpb25cIiB8fCAodGhpcy5fbmVlZFVwZGF0ZSA9ICEwLCAhMSk7XG4gIH1cbiAgZnVsbFN5bmMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX25lZWRVcGRhdGUgJiYgKHRoaXMuX25lZWRVcGRhdGUgPSAhMSwgdGhpcy5sb2FkVXBkYXRlKCkpLCAhMDtcbiAgfVxuICBnZXRVcGRhdGVzKHQsIGUpIHtcbiAgICBjb25zdCBuID0gdGhpcy4kZ2FudHQuYWpheDtcbiAgICBpZiAodGhpcy5fdXBkYXRlQnVzeSkgcmV0dXJuICExO1xuICAgIHRoaXMuX3VwZGF0ZUJ1c3kgPSAhMCwgbi5nZXQodCwgZSk7XG4gIH1cbiAgbG9hZFVwZGF0ZSgpIHtcbiAgICBjb25zdCB0ID0gdGhpcy4kZ2FudHQuYWpheCwgZSA9IHRoaXMuJGdhbnR0LmdldFVzZXJEYXRhKDAsIFwidmVyc2lvblwiLCB0aGlzLl9nYW50dE1vZGUpO1xuICAgIGxldCBuID0gdGhpcy5zZXJ2ZXJQcm9jZXNzb3IgKyB0LnVybFNlcGFyYXRvcih0aGlzLnNlcnZlclByb2Nlc3NvcikgKyBbXCJkaHhfdXNlcj1cIiArIHRoaXMuX3VzZXIsIFwiZGh4X3ZlcnNpb249XCIgKyBlXS5qb2luKFwiJlwiKTtcbiAgICBuID0gbi5yZXBsYWNlKFwiZWRpdGluZz10cnVlJlwiLCBcIlwiKSwgdGhpcy5nZXRVcGRhdGVzKG4sIChpKSA9PiB7XG4gICAgICBjb25zdCBhID0gdC54cGF0aChcIi8vdXNlcmRhdGFcIiwgaSk7XG4gICAgICB0aGlzLiRnYW50dC5zZXRVc2VyRGF0YSgwLCBcInZlcnNpb25cIiwgdGhpcy5fZ2V0WG1sTm9kZVZhbHVlKGFbMF0pLCB0aGlzLl9nYW50dE1vZGUpO1xuICAgICAgY29uc3QgciA9IHQueHBhdGgoXCIvL3VwZGF0ZVwiLCBpKTtcbiAgICAgIGlmIChyLmxlbmd0aCkge1xuICAgICAgICB0aGlzLl9zaWxlbnRfbW9kZSA9ICEwO1xuICAgICAgICBmb3IgKGxldCBzID0gMDsgcyA8IHIubGVuZ3RoOyBzKyspIHtcbiAgICAgICAgICBjb25zdCBvID0gcltzXS5nZXRBdHRyaWJ1dGUoXCJzdGF0dXNcIiksIGwgPSByW3NdLmdldEF0dHJpYnV0ZShcImlkXCIpLCBkID0gcltzXS5nZXRBdHRyaWJ1dGUoXCJwYXJlbnRcIik7XG4gICAgICAgICAgc3dpdGNoIChvKSB7XG4gICAgICAgICAgICBjYXNlIFwiaW5zZXJ0ZWRcIjpcbiAgICAgICAgICAgICAgdGhpcy5jYWxsRXZlbnQoXCJpbnNlcnRDYWxsYmFja1wiLCBbcltzXSwgbCwgZF0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJ1cGRhdGVkXCI6XG4gICAgICAgICAgICAgIHRoaXMuY2FsbEV2ZW50KFwidXBkYXRlQ2FsbGJhY2tcIiwgW3Jbc10sIGwsIGRdKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZGVsZXRlZFwiOlxuICAgICAgICAgICAgICB0aGlzLmNhbGxFdmVudChcImRlbGV0ZUNhbGxiYWNrXCIsIFtyW3NdLCBsLCBkXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NpbGVudF9tb2RlID0gITE7XG4gICAgICB9XG4gICAgICB0aGlzLl91cGRhdGVCdXN5ID0gITE7XG4gICAgfSk7XG4gIH1cbiAgZGVzdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmNhbGxFdmVudChcIm9uRGVzdHJveVwiLCBbXSksIHRoaXMuZGV0YWNoQWxsRXZlbnRzKCksIHRoaXMudXBkYXRlZFJvd3MgPSBbXSwgdGhpcy5faW5fcHJvZ3Jlc3MgPSB7fSwgdGhpcy5faW52YWxpZCA9IHt9LCB0aGlzLl9zdG9yYWdlLmNsZWFyKCksIHRoaXMuX3N0b3JhZ2UgPSBudWxsLCB0aGlzLl9oZWFkZXJzID0gbnVsbCwgdGhpcy5fcGF5bG9hZCA9IG51bGwsIGRlbGV0ZSB0aGlzLl9pbml0aWFsaXplZDtcbiAgfVxuICBzZXRHYW50dE1vZGUodCkge1xuICAgIHQgPT09IFwidGFza3NcIiA/IHQgPSBcInRhc2tcIiA6IHQgPT09IFwibGlua3NcIiAmJiAodCA9IFwibGlua1wiKTtcbiAgICBjb25zdCBlID0gdGhpcy5tb2RlcyB8fCB7fSwgbiA9IHRoaXMuZ2V0R2FudHRNb2RlKCk7XG4gICAgbiAmJiAoZVtuXSA9IHsgX2luX3Byb2dyZXNzOiB0aGlzLl9pbl9wcm9ncmVzcywgX2ludmFsaWQ6IHRoaXMuX2ludmFsaWQsIF9zdG9yYWdlOiB0aGlzLl9zdG9yYWdlLCB1cGRhdGVkUm93czogdGhpcy51cGRhdGVkUm93cyB9KTtcbiAgICBsZXQgaSA9IGVbdF07XG4gICAgaSB8fCAoaSA9IGVbdF0gPSB7IF9pbl9wcm9ncmVzczoge30sIF9pbnZhbGlkOiB7fSwgX3N0b3JhZ2U6IEp0LmNyZWF0ZSgpLCB1cGRhdGVkUm93czogW10gfSksIHRoaXMuX2luX3Byb2dyZXNzID0gaS5faW5fcHJvZ3Jlc3MsIHRoaXMuX2ludmFsaWQgPSBpLl9pbnZhbGlkLCB0aGlzLl9zdG9yYWdlID0gaS5fc3RvcmFnZSwgdGhpcy51cGRhdGVkUm93cyA9IGkudXBkYXRlZFJvd3MsIHRoaXMubW9kZXMgPSBlLCB0aGlzLl9nYW50dE1vZGUgPSB0O1xuICB9XG4gIGdldEdhbnR0TW9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2FudHRNb2RlO1xuICB9XG4gIHN0b3JlSXRlbSh0KSB7XG4gICAgdGhpcy5fc3RvcmFnZS5zdG9yZUl0ZW0odCk7XG4gIH1cbiAgdXJsKHQpIHtcbiAgICB0aGlzLnNlcnZlclByb2Nlc3NvciA9IHRoaXMuX3NlcnZlclByb2Nlc3NvciA9IHQ7XG4gIH1cbiAgX2JlZm9yZVNlbmREYXRhKHQsIGUpIHtcbiAgICBpZiAoIXRoaXMuY2FsbEV2ZW50KFwib25CZWZvcmVVcGRhdGVcIiwgW2UsIHRoaXMuZ2V0U3RhdGUoZSksIHRdKSkgcmV0dXJuICExO1xuICAgIHRoaXMuX3NlbmREYXRhKHQsIGUpO1xuICB9XG4gIF9zZXJpYWxpemVBc0pTT04odCkge1xuICAgIGlmICh0eXBlb2YgdCA9PSBcInN0cmluZ1wiKSByZXR1cm4gdDtcbiAgICBjb25zdCBlID0gcSh0KTtcbiAgICByZXR1cm4gdGhpcy5fdE1vZGUgPT09IFwiUkVTVC1KU09OXCIgJiYgKGRlbGV0ZSBlLmlkLCBkZWxldGUgZVt0aGlzLmFjdGlvbl9wYXJhbV0pLCBKU09OLnN0cmluZ2lmeShlKTtcbiAgfVxuICBfYXBwbHlQYXlsb2FkKHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy4kZ2FudHQuYWpheDtcbiAgICBpZiAodGhpcy5fcGF5bG9hZCkgZm9yIChjb25zdCBuIGluIHRoaXMuX3BheWxvYWQpIHQgPSB0ICsgZS51cmxTZXBhcmF0b3IodCkgKyB0aGlzLmVzY2FwZShuKSArIFwiPVwiICsgdGhpcy5lc2NhcGUodGhpcy5fcGF5bG9hZFtuXSk7XG4gICAgcmV0dXJuIHQ7XG4gIH1cbiAgX2NsZWFudXBBcmd1bWVudHNCZWZvcmVTZW5kKHQpIHtcbiAgICBsZXQgZTtcbiAgICBpZiAodFt0aGlzLmFjdGlvbl9wYXJhbV0gPT09IHZvaWQgMCkge1xuICAgICAgZSA9IHt9O1xuICAgICAgZm9yIChjb25zdCBuIGluIHQpIGVbbl0gPSB0aGlzLl9jbGVhbnVwQXJndW1lbnRzQmVmb3JlU2VuZCh0W25dKTtcbiAgICB9IGVsc2UgZSA9IHRoaXMuX2NsZWFudXBJdGVtQmVmb3JlU2VuZCh0KTtcbiAgICByZXR1cm4gZTtcbiAgfVxuICBfY2xlYW51cEl0ZW1CZWZvcmVTZW5kKHQpIHtcbiAgICBsZXQgZSA9IG51bGw7XG4gICAgcmV0dXJuIHQgJiYgKHRbdGhpcy5hY3Rpb25fcGFyYW1dID09PSBcImRlbGV0ZWRcIiA/IChlID0ge30sIGUuaWQgPSB0LmlkLCBlW3RoaXMuYWN0aW9uX3BhcmFtXSA9IHRbdGhpcy5hY3Rpb25fcGFyYW1dKSA6IGUgPSB0KSwgZTtcbiAgfVxuICBfc2VuZERhdGEodCwgZSkge1xuICAgIGlmICghdCkgcmV0dXJuO1xuICAgIGlmICghdGhpcy5jYWxsRXZlbnQoXCJvbkJlZm9yZURhdGFTZW5kaW5nXCIsIGUgPyBbZSwgdGhpcy5nZXRTdGF0ZShlKSwgdF0gOiBbbnVsbCwgbnVsbCwgdF0pKSByZXR1cm4gITE7XG4gICAgZSAmJiAodGhpcy5faW5fcHJvZ3Jlc3NbZV0gPSAoLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkpLnZhbHVlT2YoKSk7XG4gICAgY29uc3QgbiA9IHRoaXMuJGdhbnR0LmFqYXg7XG4gICAgaWYgKHRoaXMuX3RNb2RlID09PSBcIkNVU1RPTVwiKSB7XG4gICAgICBjb25zdCBsID0gdGhpcy5nZXRTdGF0ZShlKSwgZCA9IHRoaXMuZ2V0QWN0aW9uQnlTdGF0ZShsKSwgYyA9IHRoaXMuZ2V0R2FudHRNb2RlKCksIHUgPSAoZykgPT4ge1xuICAgICAgICBsZXQgcCA9IGwgfHwgXCJ1cGRhdGVkXCIsIHkgPSBlLCB2ID0gZTtcbiAgICAgICAgZyAmJiAocCA9IGcuYWN0aW9uIHx8IGwsIHkgPSBnLnNpZCB8fCB5LCB2ID0gZy5pZCB8fCBnLnRpZCB8fCB2KSwgdGhpcy5hZnRlclVwZGF0ZUNhbGxiYWNrKHksIHYsIHAsIGcsIGMpO1xuICAgICAgfTtcbiAgICAgIGxldCBoO1xuICAgICAgaWYgKHRoaXMuX3JvdXRlciBpbnN0YW5jZW9mIEZ1bmN0aW9uKSBpZiAodGhpcy5fcm91dGVyUGFyYW1ldGVyc0Zvcm1hdCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBjb25zdCBnID0geyBlbnRpdHk6IGMsIGFjdGlvbjogZCwgZGF0YTogdCwgaWQ6IGUgfTtcbiAgICAgICAgaCA9IHRoaXMuX3JvdXRlcihnKTtcbiAgICAgIH0gZWxzZSBoID0gdGhpcy5fcm91dGVyKGMsIGQsIHQsIGUpO1xuICAgICAgZWxzZSBpZiAodGhpcy5fcm91dGVyW2NdIGluc3RhbmNlb2YgRnVuY3Rpb24pIGggPSB0aGlzLl9yb3V0ZXJbY10oZCwgdCwgZSk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgZyA9IFwiSW5jb3JyZWN0IGNvbmZpZ3VyYXRpb24gb2YgZ2FudHQuY3JlYXRlRGF0YVByb2Nlc3NvclwiLCBwID0gYFxuWW91IG5lZWQgdG8gZWl0aGVyIGFkZCBtaXNzaW5nIHByb3BlcnRpZXMgdG8gdGhlIGRhdGFQcm9jZXNzb3Igcm91dGVyIG9iamVjdCBvciB0byB1c2UgYSByb3V0ZXIgZnVuY3Rpb24uXG5TZWUgaHR0cHM6Ly9kb2NzLmRodG1seC5jb20vZ2FudHQvZGVza3RvcF9fc2VydmVyX3NpZGUuaHRtbCNjdXN0b21yb3V0aW5nIGFuZCBodHRwczovL2RvY3MuZGh0bWx4LmNvbS9nYW50dC9hcGlfX2dhbnR0X2NyZWF0ZWRhdGFwcm9jZXNzb3IuaHRtbCBmb3IgZGV0YWlscy5gO1xuICAgICAgICBpZiAoIXRoaXMuX3JvdXRlcltjXSkgdGhyb3cgbmV3IEVycm9yKGAke2d9OiByb3V0ZXIgZm9yIHRoZSAqKiR7Y30qKiBlbnRpdHkgaXMgbm90IGRlZmluZWQuICR7cH1gKTtcbiAgICAgICAgc3dpdGNoIChsKSB7XG4gICAgICAgICAgY2FzZSBcImluc2VydGVkXCI6XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3JvdXRlcltjXS5jcmVhdGUpIHRocm93IG5ldyBFcnJvcihgJHtnfTogKipjcmVhdGUqKiBhY3Rpb24gZm9yIHRoZSAqKiR7Y30qKiBlbnRpdHkgaXMgbm90IGRlZmluZWQuICR7cH1gKTtcbiAgICAgICAgICAgIGggPSB0aGlzLl9yb3V0ZXJbY10uY3JlYXRlKHQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImRlbGV0ZWRcIjpcbiAgICAgICAgICAgIGlmICghdGhpcy5fcm91dGVyW2NdLmRlbGV0ZSkgdGhyb3cgbmV3IEVycm9yKGAke2d9OiAqKmRlbGV0ZSoqIGFjdGlvbiBmb3IgdGhlICoqJHtjfSoqIGVudGl0eSBpcyBub3QgZGVmaW5lZC4gJHtwfWApO1xuICAgICAgICAgICAgaCA9IHRoaXMuX3JvdXRlcltjXS5kZWxldGUoZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaWYgKCF0aGlzLl9yb3V0ZXJbY10udXBkYXRlKSB0aHJvdyBuZXcgRXJyb3IoYCR7Z306ICoqdXBkYXRlKipcIiBhY3Rpb24gZm9yIHRoZSAqKiR7Y30qKiBlbnRpdHkgaXMgbm90IGRlZmluZWQuICR7cH1gKTtcbiAgICAgICAgICAgIGggPSB0aGlzLl9yb3V0ZXJbY10udXBkYXRlKHQsIGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaCkge1xuICAgICAgICBpZiAoIWgudGhlbiAmJiBoLmlkID09PSB2b2lkIDAgJiYgaC50aWQgPT09IHZvaWQgMCAmJiBoLmFjdGlvbiA9PT0gdm9pZCAwKSB0aHJvdyBuZXcgRXJyb3IoXCJJbmNvcnJlY3Qgcm91dGVyIHJldHVybiB2YWx1ZS4gQSBQcm9taXNlIG9yIGEgcmVzcG9uc2Ugb2JqZWN0IGlzIGV4cGVjdGVkXCIpO1xuICAgICAgICBoLnRoZW4gPyBoLnRoZW4odSkuY2F0Y2goKGcpID0+IHtcbiAgICAgICAgICBnICYmIGcuYWN0aW9uID8gdShnKSA6IHUoeyBhY3Rpb246IFwiZXJyb3JcIiwgdmFsdWU6IGcgfSk7XG4gICAgICAgIH0pIDogdShoKTtcbiAgICAgIH0gZWxzZSB1KG51bGwpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgaTtcbiAgICBpID0geyBjYWxsYmFjazogKGwpID0+IHtcbiAgICAgIGNvbnN0IGQgPSBbXTtcbiAgICAgIGlmIChlKSBkLnB1c2goZSk7XG4gICAgICBlbHNlIGlmICh0KSBmb3IgKGNvbnN0IGMgaW4gdCkgZC5wdXNoKGMpO1xuICAgICAgcmV0dXJuIHRoaXMuYWZ0ZXJVcGRhdGUodGhpcywgbCwgZCk7XG4gICAgfSwgaGVhZGVyczogdGhpcy5faGVhZGVycyB9O1xuICAgIGNvbnN0IGEgPSBcImRoeF92ZXJzaW9uPVwiICsgdGhpcy4kZ2FudHQuZ2V0VXNlckRhdGEoMCwgXCJ2ZXJzaW9uXCIsIHRoaXMuX2dhbnR0TW9kZSksIHIgPSB0aGlzLnNlcnZlclByb2Nlc3NvciArICh0aGlzLl91c2VyID8gbi51cmxTZXBhcmF0b3IodGhpcy5zZXJ2ZXJQcm9jZXNzb3IpICsgW1wiZGh4X3VzZXI9XCIgKyB0aGlzLl91c2VyLCBhXS5qb2luKFwiJlwiKSA6IFwiXCIpO1xuICAgIGxldCBzLCBvID0gdGhpcy5fYXBwbHlQYXlsb2FkKHIpO1xuICAgIHN3aXRjaCAodGhpcy5fdE1vZGUpIHtcbiAgICAgIGNhc2UgXCJHRVRcIjpcbiAgICAgICAgcyA9IHRoaXMuX2NsZWFudXBBcmd1bWVudHNCZWZvcmVTZW5kKHQpLCBpLnVybCA9IG8gKyBuLnVybFNlcGFyYXRvcihvKSArIHRoaXMuc2VyaWFsaXplKHMsIGUpLCBpLm1ldGhvZCA9IFwiR0VUXCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIlBPU1RcIjpcbiAgICAgICAgcyA9IHRoaXMuX2NsZWFudXBBcmd1bWVudHNCZWZvcmVTZW5kKHQpLCBpLnVybCA9IG8sIGkubWV0aG9kID0gXCJQT1NUXCIsIGkuZGF0YSA9IHRoaXMuc2VyaWFsaXplKHMsIGUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJKU09OXCI6XG4gICAgICAgIHMgPSB7fTtcbiAgICAgICAgY29uc3QgbCA9IHRoaXMuX2NsZWFudXBJdGVtQmVmb3JlU2VuZCh0KTtcbiAgICAgICAgZm9yIChjb25zdCBkIGluIGwpIGQgIT09IHRoaXMuYWN0aW9uX3BhcmFtICYmIGQgIT09IFwiaWRcIiAmJiBkICE9PSBcImdyX2lkXCIgJiYgKHNbZF0gPSBsW2RdKTtcbiAgICAgICAgaS51cmwgPSBvLCBpLm1ldGhvZCA9IFwiUE9TVFwiLCBpLmRhdGEgPSBKU09OLnN0cmluZ2lmeSh7IGlkOiBlLCBhY3Rpb246IHRbdGhpcy5hY3Rpb25fcGFyYW1dLCBkYXRhOiBzIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJSRVNUXCI6XG4gICAgICBjYXNlIFwiUkVTVC1KU09OXCI6XG4gICAgICAgIHN3aXRjaCAobyA9IHIucmVwbGFjZSgvKCZ8XFw/KWVkaXRpbmc9dHJ1ZS8sIFwiXCIpLCBzID0gXCJcIiwgdGhpcy5nZXRTdGF0ZShlKSkge1xuICAgICAgICAgIGNhc2UgXCJpbnNlcnRlZFwiOlxuICAgICAgICAgICAgaS5tZXRob2QgPSBcIlBPU1RcIiwgaS5kYXRhID0gdGhpcy5zZXJpYWxpemUodCwgZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiZGVsZXRlZFwiOlxuICAgICAgICAgICAgaS5tZXRob2QgPSBcIkRFTEVURVwiLCBvID0gbyArIChvLnNsaWNlKC0xKSA9PT0gXCIvXCIgPyBcIlwiIDogXCIvXCIpICsgZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBpLm1ldGhvZCA9IFwiUFVUXCIsIGkuZGF0YSA9IHRoaXMuc2VyaWFsaXplKHQsIGUpLCBvID0gbyArIChvLnNsaWNlKC0xKSA9PT0gXCIvXCIgPyBcIlwiIDogXCIvXCIpICsgZTtcbiAgICAgICAgfVxuICAgICAgICBpLnVybCA9IHRoaXMuX2FwcGx5UGF5bG9hZChvKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3dhaXRNb2RlKyssIG4ucXVlcnkoaSk7XG4gIH1cbiAgX2ZvckVhY2hVcGRhdGVkUm93KHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy51cGRhdGVkUm93cy5zbGljZSgpO1xuICAgIGZvciAobGV0IG4gPSAwOyBuIDwgZS5sZW5ndGg7IG4rKykge1xuICAgICAgY29uc3QgaSA9IGVbbl07XG4gICAgICB0aGlzLiRnYW50dC5nZXRVc2VyRGF0YShpLCB0aGlzLmFjdGlvbl9wYXJhbSwgdGhpcy5fZ2FudHRNb2RlKSAmJiB0LmNhbGwodGhpcywgaSk7XG4gICAgfVxuICB9XG4gIF9zZXREZWZhdWx0VHJhbnNhY3Rpb25Nb2RlKCkge1xuICAgIHRoaXMuc2VydmVyUHJvY2Vzc29yICYmICh0aGlzLnNldFRyYW5zYWN0aW9uTW9kZShcIlBPU1RcIiwgITApLCB0aGlzLnNlcnZlclByb2Nlc3NvciArPSAodGhpcy5zZXJ2ZXJQcm9jZXNzb3IuaW5kZXhPZihcIj9cIikgIT09IC0xID8gXCImXCIgOiBcIj9cIikgKyBcImVkaXRpbmc9dHJ1ZVwiLCB0aGlzLl9zZXJ2ZXJQcm9jZXNzb3IgPSB0aGlzLnNlcnZlclByb2Nlc3Nvcik7XG4gIH1cbiAgX2dldFhtbE5vZGVWYWx1ZSh0KSB7XG4gICAgcmV0dXJuIHQuZmlyc3RDaGlsZCA/IHQuZmlyc3RDaGlsZC5ub2RlVmFsdWUgOiBcIlwiO1xuICB9XG4gIF9nZXRBbGxEYXRhKCkge1xuICAgIGNvbnN0IHQgPSB7fTtcbiAgICBsZXQgZSA9ICExO1xuICAgIHJldHVybiB0aGlzLl9mb3JFYWNoVXBkYXRlZFJvdyhmdW5jdGlvbihuKSB7XG4gICAgICBpZiAodGhpcy5faW5fcHJvZ3Jlc3Nbbl0gfHwgdGhpcy5pc19pbnZhbGlkKG4pKSByZXR1cm47XG4gICAgICBjb25zdCBpID0gdGhpcy5fZ2V0Um93RGF0YShuKTtcbiAgICAgIHRoaXMuY2FsbEV2ZW50KFwib25CZWZvcmVVcGRhdGVcIiwgW24sIHRoaXMuZ2V0U3RhdGUobiksIGldKSAmJiAodFtuXSA9IGksIGUgPSAhMCwgdGhpcy5faW5fcHJvZ3Jlc3Nbbl0gPSAoLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkpLnZhbHVlT2YoKSk7XG4gICAgfSksIGUgPyB0IDogbnVsbDtcbiAgfVxuICBfcHJlcGFyZURhdGUodCkge1xuICAgIHJldHVybiB0aGlzLiRnYW50dC5kZWZpbmVkKHRoaXMuJGdhbnR0LnRlbXBsYXRlcy54bWxfZm9ybWF0KSA/IHRoaXMuJGdhbnR0LnRlbXBsYXRlcy54bWxfZm9ybWF0KHQpIDogdGhpcy4kZ2FudHQudGVtcGxhdGVzLmZvcm1hdF9kYXRlKHQpO1xuICB9XG4gIF9wcmVwYXJlQXJyYXkodCwgZSkge1xuICAgIHJldHVybiBlLnB1c2godCksIHQubWFwKChuKSA9PiBaKG4pID8gdGhpcy5fcHJlcGFyZURhdGUobikgOiBBcnJheS5pc0FycmF5KG4pICYmICF6dChlLCBuKSA/IHRoaXMuX3ByZXBhcmVBcnJheShuLCBlKSA6IG4gJiYgdHlwZW9mIG4gPT0gXCJvYmplY3RcIiAmJiAhenQoZSwgbikgPyB0aGlzLl9wcmVwYXJlT2JqZWN0KG4sIGUpIDogbik7XG4gIH1cbiAgX3ByZXBhcmVPYmplY3QodCwgZSkge1xuICAgIGNvbnN0IG4gPSB7fTtcbiAgICBlLnB1c2godCk7XG4gICAgZm9yIChjb25zdCBpIGluIHQpIHtcbiAgICAgIGlmIChpLnN1YnN0cigwLCAxKSA9PT0gXCIkXCIpIGNvbnRpbnVlO1xuICAgICAgY29uc3QgYSA9IHRbaV07XG4gICAgICBaKGEpID8gbltpXSA9IHRoaXMuX3ByZXBhcmVEYXRlKGEpIDogYSA9PT0gbnVsbCA/IG5baV0gPSBcIlwiIDogQXJyYXkuaXNBcnJheShhKSAmJiAhenQoZSwgYSkgPyBuW2ldID0gdGhpcy5fcHJlcGFyZUFycmF5KGEsIGUpIDogYSAmJiB0eXBlb2YgYSA9PSBcIm9iamVjdFwiICYmICF6dChlLCBhKSA/IG5baV0gPSB0aGlzLl9wcmVwYXJlT2JqZWN0KGEsIGUpIDogbltpXSA9IGE7XG4gICAgfVxuICAgIHJldHVybiBuO1xuICB9XG4gIF9wcmVwYXJlRGF0YUl0ZW0odCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLl9wcmVwYXJlT2JqZWN0KHQsIFtdKTtcbiAgICByZXR1cm4gZVt0aGlzLmFjdGlvbl9wYXJhbV0gPSB0aGlzLiRnYW50dC5nZXRVc2VyRGF0YSh0LmlkLCB0aGlzLmFjdGlvbl9wYXJhbSwgdGhpcy5fZ2FudHRNb2RlKSwgZTtcbiAgfVxuICBnZXRTdG9yZWRJdGVtKHQpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RvcmFnZS5nZXRTdG9yZWRJdGVtKHQpO1xuICB9XG4gIF9nZXRSb3dEYXRhKHQpIHtcbiAgICBsZXQgZTtcbiAgICBjb25zdCBuID0gdGhpcy4kZ2FudHQ7XG4gICAgcmV0dXJuIHRoaXMuZ2V0R2FudHRNb2RlKCkgPT09IFwidGFza1wiID8gbi5pc1Rhc2tFeGlzdHModCkgJiYgKGUgPSB0aGlzLiRnYW50dC5nZXRUYXNrKHQpKSA6IHRoaXMuZ2V0R2FudHRNb2RlKCkgPT09IFwiYXNzaWdubWVudFwiID8gdGhpcy4kZ2FudHQuJGRhdGEuYXNzaWdubWVudHNTdG9yZS5leGlzdHModCkgJiYgKGUgPSB0aGlzLiRnYW50dC4kZGF0YS5hc3NpZ25tZW50c1N0b3JlLmdldEl0ZW0odCkpIDogdGhpcy5nZXRHYW50dE1vZGUoKSA9PT0gXCJiYXNlbGluZVwiID8gdGhpcy4kZ2FudHQuJGRhdGEuYmFzZWxpbmVTdG9yZS5leGlzdHModCkgJiYgKGUgPSB0aGlzLiRnYW50dC4kZGF0YS5iYXNlbGluZVN0b3JlLmdldEl0ZW0odCkpIDogbi5pc0xpbmtFeGlzdHModCkgJiYgKGUgPSB0aGlzLiRnYW50dC5nZXRMaW5rKHQpKSwgZSB8fCAoZSA9IHRoaXMuZ2V0U3RvcmVkSXRlbSh0KSksIGUgfHwgKGUgPSB7IGlkOiB0IH0pLCB0aGlzLl9wcmVwYXJlRGF0YUl0ZW0oZSk7XG4gIH1cbn07XG5jb25zdCBuaSA9IGZ1bmN0aW9uKHQpIHtcbiAgcmV0dXJuIG5ldyB1bih0KTtcbn0sIGlpID0gZnVuY3Rpb24odCkge1xuICBsZXQgZSwgbiwgaTtcbiAgdCBpbnN0YW5jZW9mIEZ1bmN0aW9uID8gZSA9IHQgOiB0Lmhhc093blByb3BlcnR5KFwicm91dGVyXCIpID8gZSA9IHQucm91dGVyIDogdC5oYXNPd25Qcm9wZXJ0eShcImFzc2lnbm1lbnRcIikgfHwgdC5oYXNPd25Qcm9wZXJ0eShcImJhc2VsaW5lXCIpIHx8IHQuaGFzT3duUHJvcGVydHkoXCJsaW5rXCIpIHx8IHQuaGFzT3duUHJvcGVydHkoXCJ0YXNrXCIpID8gZSA9IHQgOiB0Lmhhc093blByb3BlcnR5KFwiaGVhZGVyc1wiKSAmJiAoaSA9IHQuaGVhZGVycyksIG4gPSBlID8gXCJDVVNUT01cIiA6IHQubW9kZSB8fCBcIlJFU1QtSlNPTlwiO1xuICBjb25zdCBhID0gbmV3IHVuKHQudXJsKTtcbiAgcmV0dXJuIGEuaW5pdCh0aGlzKSwgYS5zZXRUcmFuc2FjdGlvbk1vZGUoeyBtb2RlOiBuLCByb3V0ZXI6IGUsIGhlYWRlcnM6IGkgfSwgdC5iYXRjaFVwZGF0ZSksIHQuZGVsZXRlQWZ0ZXJDb25maXJtYXRpb24gJiYgKGEuZGVsZXRlQWZ0ZXJDb25maXJtYXRpb24gPSB0LmRlbGV0ZUFmdGVyQ29uZmlybWF0aW9uKSwgYTtcbn07XG5mdW5jdGlvbiBhaSh0KSB7XG4gIHZhciBlID0ge30sIG4gPSAhMTtcbiAgZnVuY3Rpb24gaShsLCBkKSB7XG4gICAgZCA9IHR5cGVvZiBkID09IFwiZnVuY3Rpb25cIiA/IGQgOiBmdW5jdGlvbigpIHtcbiAgICB9LCBlW2xdIHx8IChlW2xdID0gdGhpc1tsXSwgdGhpc1tsXSA9IGQpO1xuICB9XG4gIGZ1bmN0aW9uIGEobCkge1xuICAgIGVbbF0gJiYgKHRoaXNbbF0gPSBlW2xdLCBlW2xdID0gbnVsbCk7XG4gIH1cbiAgZnVuY3Rpb24gcihsKSB7XG4gICAgZm9yICh2YXIgZCBpbiBsKSBpLmNhbGwodGhpcywgZCwgbFtkXSk7XG4gIH1cbiAgZnVuY3Rpb24gcygpIHtcbiAgICBmb3IgKHZhciBsIGluIGUpIGEuY2FsbCh0aGlzLCBsKTtcbiAgfVxuICBmdW5jdGlvbiBvKGwpIHtcbiAgICB0cnkge1xuICAgICAgbCgpO1xuICAgIH0gY2F0Y2ggKGQpIHtcbiAgICAgIGR0LmNvbnNvbGUuZXJyb3IoZCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0LiRzZXJ2aWNlcy5nZXRTZXJ2aWNlKFwic3RhdGVcIikucmVnaXN0ZXJQcm92aWRlcihcImJhdGNoVXBkYXRlXCIsIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7IGJhdGNoX3VwZGF0ZTogbiB9O1xuICB9LCAhMSksIGZ1bmN0aW9uKGwsIGQpIHtcbiAgICBpZiAobikgbyhsKTtcbiAgICBlbHNlIHtcbiAgICAgIHZhciBjLCB1ID0gdGhpcy5fZHAgJiYgdGhpcy5fZHAudXBkYXRlTW9kZSAhPSBcIm9mZlwiO1xuICAgICAgdSAmJiAoYyA9IHRoaXMuX2RwLnVwZGF0ZU1vZGUsIHRoaXMuX2RwLnNldFVwZGF0ZU1vZGUoXCJvZmZcIikpO1xuICAgICAgdmFyIGggPSB7fSwgZyA9IHsgcmVuZGVyOiAhMCwgcmVmcmVzaERhdGE6ICEwLCByZWZyZXNoVGFzazogITAsIHJlZnJlc2hMaW5rOiAhMCwgcmVzZXRQcm9qZWN0RGF0ZXM6IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgaFt5LmlkXSA9IHk7XG4gICAgICB9IH07XG4gICAgICBmb3IgKHZhciBwIGluIHIuY2FsbCh0aGlzLCBnKSwgbiA9ICEwLCB0aGlzLmNhbGxFdmVudChcIm9uQmVmb3JlQmF0Y2hVcGRhdGVcIiwgW10pLCBvKGwpLCB0aGlzLmNhbGxFdmVudChcIm9uQWZ0ZXJCYXRjaFVwZGF0ZVwiLCBbXSksIHMuY2FsbCh0aGlzKSwgaCkgdGhpcy5yZXNldFByb2plY3REYXRlcyhoW3BdKTtcbiAgICAgIG4gPSAhMSwgZCB8fCB0aGlzLnJlbmRlcigpLCB1ICYmICh0aGlzLl9kcC5zZXRVcGRhdGVNb2RlKGMpLCB0aGlzLl9kcC5zZXRHYW50dE1vZGUoXCJ0YXNrXCIpLCB0aGlzLl9kcC5zZW5kRGF0YSgpLCB0aGlzLl9kcC5zZXRHYW50dE1vZGUoXCJsaW5rXCIpLCB0aGlzLl9kcC5zZW5kRGF0YSgpKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiByaSh0KSB7XG4gIHQuYmF0Y2hVcGRhdGUgPSBhaSh0KTtcbn1cbmZ1bmN0aW9uIHNpKHQpIHtcbiAgY29uc3QgZSA9IC8qIEBfX1BVUkVfXyAqLyBmdW5jdGlvbihpKSB7XG4gICAgcmV0dXJuIHsgX25lZWRSZWNhbGM6ICEwLCByZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9uZWVkUmVjYWxjID0gITA7XG4gICAgfSwgX2lzUmVjYWxjTmVlZGVkOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAhdGhpcy5faXNHcm91cFNvcnQoKSAmJiB0aGlzLl9uZWVkUmVjYWxjO1xuICAgIH0sIF9pc0dyb3VwU29ydDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gISFpLmdldFN0YXRlKCkuZ3JvdXBfbW9kZTtcbiAgICB9LCBfZ2V0V0JTQ29kZTogZnVuY3Rpb24oYSkge1xuICAgICAgcmV0dXJuIGEgPyAodGhpcy5faXNSZWNhbGNOZWVkZWQoKSAmJiB0aGlzLl9jYWxjV0JTKCksIGEuJHZpcnR1YWwgPyBcIlwiIDogdGhpcy5faXNHcm91cFNvcnQoKSA/IGEuJHdicyB8fCBcIlwiIDogKGEuJHdicyB8fCAodGhpcy5yZXNldCgpLCB0aGlzLl9jYWxjV0JTKCkpLCBhLiR3YnMpKSA6IFwiXCI7XG4gICAgfSwgX3NldFdCU0NvZGU6IGZ1bmN0aW9uKGEsIHIpIHtcbiAgICAgIGEuJHdicyA9IHI7XG4gICAgfSwgZ2V0V0JTQ29kZTogZnVuY3Rpb24oYSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldFdCU0NvZGUoYSk7XG4gICAgfSwgZ2V0QnlXQlNDb2RlOiBmdW5jdGlvbihhKSB7XG4gICAgICBsZXQgciA9IGEuc3BsaXQoXCIuXCIpLCBzID0gaS5jb25maWcucm9vdF9pZDtcbiAgICAgIGZvciAobGV0IG8gPSAwOyBvIDwgci5sZW5ndGg7IG8rKykge1xuICAgICAgICBjb25zdCBsID0gaS5nZXRDaGlsZHJlbihzKTtcbiAgICAgICAgbGV0IGQgPSAxICogcltvXSAtIDE7XG4gICAgICAgIGlmICghaS5pc1Rhc2tFeGlzdHMobFtkXSkpIHJldHVybiBudWxsO1xuICAgICAgICBzID0gbFtkXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpLmlzVGFza0V4aXN0cyhzKSA/IGkuZ2V0VGFzayhzKSA6IG51bGw7XG4gICAgfSwgX2NhbGNXQlM6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLl9pc1JlY2FsY05lZWRlZCgpKSByZXR1cm47XG4gICAgICBsZXQgYSA9ICEwO1xuICAgICAgaS5lYWNoVGFzayhmdW5jdGlvbihyKSB7XG4gICAgICAgIGlmIChyLnR5cGUgPT0gaS5jb25maWcudHlwZXMucGxhY2Vob2xkZXIpIHJldHVybjtcbiAgICAgICAgaWYgKGEpIHJldHVybiBhID0gITEsIHZvaWQgdGhpcy5fc2V0V0JTQ29kZShyLCBcIjFcIik7XG4gICAgICAgIGNvbnN0IHMgPSB0aGlzLl9nZXRQcmV2Tm9uUGxhY2Vob2xkZXJTaWJsaW5nKHIuaWQpO1xuICAgICAgICBpZiAocyAhPT0gbnVsbCkgdGhpcy5faW5jcmVhc2VXQlMociwgcyk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGxldCBvID0gaS5nZXRQYXJlbnQoci5pZCk7XG4gICAgICAgICAgdGhpcy5fc2V0V0JTQ29kZShyLCBpLmdldFRhc2sobykuJHdicyArIFwiLjFcIik7XG4gICAgICAgIH1cbiAgICAgIH0sIGkuY29uZmlnLnJvb3RfaWQsIHRoaXMpLCB0aGlzLl9uZWVkUmVjYWxjID0gITE7XG4gICAgfSwgX2luY3JlYXNlV0JTOiBmdW5jdGlvbihhLCByKSB7XG4gICAgICBsZXQgcyA9IGkuZ2V0VGFzayhyKS4kd2JzO1xuICAgICAgcyAmJiAocyA9IHMuc3BsaXQoXCIuXCIpLCBzW3MubGVuZ3RoIC0gMV0rKywgdGhpcy5fc2V0V0JTQ29kZShhLCBzLmpvaW4oXCIuXCIpKSk7XG4gICAgfSwgX2dldFByZXZOb25QbGFjZWhvbGRlclNpYmxpbmc6IGZ1bmN0aW9uKGEpIHtcbiAgICAgIGxldCByLCBzID0gYTtcbiAgICAgIGRvXG4gICAgICAgIHIgPSBpLmdldFByZXZTaWJsaW5nKHMpLCBzID0gcjtcbiAgICAgIHdoaWxlIChyICE9PSBudWxsICYmIGkuZ2V0VGFzayhyKS50eXBlID09IGkuY29uZmlnLnR5cGVzLnBsYWNlaG9sZGVyKTtcbiAgICAgIHJldHVybiByO1xuICAgIH0gfTtcbiAgfSh0KTtcbiAgZnVuY3Rpb24gbigpIHtcbiAgICByZXR1cm4gZS5yZXNldCgpLCAhMDtcbiAgfVxuICB0LmdldFdCU0NvZGUgPSBmdW5jdGlvbihpKSB7XG4gICAgcmV0dXJuIGUuZ2V0V0JTQ29kZShpKTtcbiAgfSwgdC5nZXRUYXNrQnlXQlNDb2RlID0gZnVuY3Rpb24oaSkge1xuICAgIHJldHVybiBlLmdldEJ5V0JTQ29kZShpKTtcbiAgfSwgdC5hdHRhY2hFdmVudChcIm9uQWZ0ZXJUYXNrTW92ZVwiLCBuKSwgdC5hdHRhY2hFdmVudChcIm9uQmVmb3JlUGFyc2VcIiwgbiksIHQuYXR0YWNoRXZlbnQoXCJvbkFmdGVyVGFza0RlbGV0ZVwiLCBuKSwgdC5hdHRhY2hFdmVudChcIm9uQWZ0ZXJUYXNrQWRkXCIsIG4pLCB0LmF0dGFjaEV2ZW50KFwib25BZnRlclNvcnRcIiwgbik7XG59XG5mdW5jdGlvbiBvaSh0KSB7XG4gIHZhciBlID0ge30sIG4gPSAhMTtcbiAgdC4kZGF0YS50YXNrc1N0b3JlLmF0dGFjaEV2ZW50KFwib25TdG9yZVVwZGF0ZWRcIiwgZnVuY3Rpb24oKSB7XG4gICAgZSA9IHt9LCBuID0gITE7XG4gIH0pLCB0LmF0dGFjaEV2ZW50KFwib25CZWZvcmVHYW50dFJlbmRlclwiLCBmdW5jdGlvbigpIHtcbiAgICBlID0ge307XG4gIH0pO1xuICB2YXIgaSA9IFN0cmluZyhNYXRoLnJhbmRvbSgpKTtcbiAgZnVuY3Rpb24gYShsKSB7XG4gICAgcmV0dXJuIGwgPT09IG51bGwgPyBpICsgU3RyaW5nKGwpIDogU3RyaW5nKGwpO1xuICB9XG4gIGZ1bmN0aW9uIHIobCwgZCwgYykge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGwpID8gbC5tYXAoZnVuY3Rpb24odSkge1xuICAgICAgcmV0dXJuIGEodSk7XG4gICAgfSkuam9pbihcIl9cIikgKyBgXyR7ZH1fJHtjfWAgOiBhKGwpICsgYF8ke2R9XyR7Y31gO1xuICB9XG4gIGZ1bmN0aW9uIHMobCwgZCwgYykge1xuICAgIHZhciB1LCBoID0gcihkLCBsLCBKU09OLnN0cmluZ2lmeShjKSksIGcgPSB7fTtcbiAgICByZXR1cm4ga3QoZCwgZnVuY3Rpb24ocCkge1xuICAgICAgZ1thKHApXSA9ICEwO1xuICAgIH0pLCBlW2hdID8gdSA9IGVbaF0gOiAodSA9IGVbaF0gPSBbXSwgdC5lYWNoVGFzayhmdW5jdGlvbihwKSB7XG4gICAgICBpZiAoYykge1xuICAgICAgICBpZiAoIWNbdC5nZXRUYXNrVHlwZShwKV0pIHJldHVybjtcbiAgICAgIH0gZWxzZSBpZiAocC50eXBlID09IHQuY29uZmlnLnR5cGVzLnByb2plY3QpIHJldHVybjtcbiAgICAgIGwgaW4gcCAmJiBrdChmZShwW2xdKSA/IHBbbF0gOiBbcFtsXV0sIGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgdmFyIHYgPSB5ICYmIHkucmVzb3VyY2VfaWQgPyB5LnJlc291cmNlX2lkIDogeTtcbiAgICAgICAgaWYgKGdbYSh2KV0pIHUucHVzaChwKTtcbiAgICAgICAgZWxzZSBpZiAoIW4pIHtcbiAgICAgICAgICB2YXIgYiA9IHIoeSwgbCk7XG4gICAgICAgICAgZVtiXSB8fCAoZVtiXSA9IFtdKSwgZVtiXS5wdXNoKHApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KSwgbiA9ICEwKSwgdTtcbiAgfVxuICBmdW5jdGlvbiBvKGwsIGQsIGMpIHtcbiAgICB2YXIgdSA9IHQuY29uZmlnLnJlc291cmNlX3Byb3BlcnR5LCBoID0gW107XG4gICAgaWYgKHQuZ2V0RGF0YXN0b3JlKFwidGFza1wiKS5leGlzdHMoZCkpIHtcbiAgICAgIHZhciBnID0gdC5nZXRUYXNrKGQpO1xuICAgICAgaCA9IGdbdV0gfHwgW107XG4gICAgfVxuICAgIEFycmF5LmlzQXJyYXkoaCkgfHwgKGggPSBbaF0pO1xuICAgIGZvciAodmFyIHAgPSAwOyBwIDwgaC5sZW5ndGg7IHArKykgaFtwXS5yZXNvdXJjZV9pZCA9PSBsICYmIGMucHVzaCh7IHRhc2tfaWQ6IGcuaWQsIHJlc291cmNlX2lkOiBoW3BdLnJlc291cmNlX2lkLCB2YWx1ZTogaFtwXS52YWx1ZSB9KTtcbiAgfVxuICByZXR1cm4geyBnZXRUYXNrQnk6IGZ1bmN0aW9uKGwsIGQsIGMpIHtcbiAgICByZXR1cm4gdHlwZW9mIGwgPT0gXCJmdW5jdGlvblwiID8gKHUgPSBsLCBoID0gW10sIHQuZWFjaFRhc2soZnVuY3Rpb24oZykge1xuICAgICAgdShnKSAmJiBoLnB1c2goZyk7XG4gICAgfSksIGgpIDogZmUoZCkgPyBzKGwsIGQsIGMpIDogcyhsLCBbZF0sIGMpO1xuICAgIHZhciB1LCBoO1xuICB9LCBnZXRSZXNvdXJjZUFzc2lnbm1lbnRzOiBmdW5jdGlvbihsLCBkKSB7XG4gICAgdmFyIGMgPSBbXSwgdSA9IHQuY29uZmlnLnJlc291cmNlX3Byb3BlcnR5O1xuICAgIHJldHVybiBkICE9PSB2b2lkIDAgPyBvKGwsIGQsIGMpIDogdC5nZXRUYXNrQnkodSwgbCkuZm9yRWFjaChmdW5jdGlvbihoKSB7XG4gICAgICBvKGwsIGguaWQsIGMpO1xuICAgIH0pLCBjO1xuICB9IH07XG59XG5mdW5jdGlvbiBsaSh0KSB7XG4gIHZhciBlID0gb2kodCk7XG4gIHQuZXh0LnJlc291cmNlcyA9IC8qIEBfX1BVUkVfXyAqLyBmdW5jdGlvbihhKSB7XG4gICAgY29uc3QgciA9IHsgcmVuZGVyRWRpdGFibGVMYWJlbDogZnVuY3Rpb24ocywgbywgbCwgZCwgYykge1xuICAgICAgY29uc3QgdSA9IGEuY29uZmlnLnJlYWRvbmx5ID8gXCJcIiA6IFwiY29udGVudGVkaXRhYmxlXCI7XG4gICAgICBpZiAocyA8IGwuZW5kX2RhdGUgJiYgbyA+IGwuc3RhcnRfZGF0ZSkge1xuICAgICAgICBmb3IgKGxldCBoID0gMDsgaCA8IGMubGVuZ3RoOyBoKyspIHtcbiAgICAgICAgICBjb25zdCBnID0gY1toXTtcbiAgICAgICAgICByZXR1cm4gXCI8ZGl2IFwiICsgdSArIFwiIGRhdGEtYXNzaWdubWVudC1jZWxsIGRhdGEtYXNzaWdubWVudC1pZD0nXCIgKyBnLmlkICsgXCInIGRhdGEtcm93LWlkPSdcIiArIGwuaWQgKyBcIicgZGF0YS10YXNrPSdcIiArIGwuJHRhc2tfaWQgKyBcIicgZGF0YS1zdGFydC1kYXRlPSdcIiArIGEudGVtcGxhdGVzLmZvcm1hdF9kYXRlKHMpICsgXCInIGRhdGEtZW5kLWRhdGU9J1wiICsgYS50ZW1wbGF0ZXMuZm9ybWF0X2RhdGUobykgKyBcIic+XCIgKyBnLnZhbHVlICsgXCI8L2Rpdj5cIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCI8ZGl2IFwiICsgdSArIFwiIGRhdGEtYXNzaWdubWVudC1jZWxsIGRhdGEtZW1wdHkgIGRhdGEtcm93LWlkPSdcIiArIGwuaWQgKyBcIicgZGF0YS1yZXNvdXJjZS1pZD0nXCIgKyBsLiRyZXNvdXJjZV9pZCArIFwiJyBkYXRhLXRhc2s9J1wiICsgbC4kdGFza19pZCArIFwiJyBkYXRhLXN0YXJ0LWRhdGU9J1wiICsgYS50ZW1wbGF0ZXMuZm9ybWF0X2RhdGUocykgKyBcIicnICBkYXRhLWVuZC1kYXRlPSdcIiArIGEudGVtcGxhdGVzLmZvcm1hdF9kYXRlKG8pICsgXCInPi08L2Rpdj5cIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH0sIHJlbmRlclN1bW1hcnlMYWJlbDogZnVuY3Rpb24ocywgbywgbCwgZCwgYykge1xuICAgICAgbGV0IHUgPSBjLnJlZHVjZShmdW5jdGlvbihoLCBnKSB7XG4gICAgICAgIHJldHVybiBoICsgTnVtYmVyKGcudmFsdWUpO1xuICAgICAgfSwgMCk7XG4gICAgICByZXR1cm4gdSAlIDEgJiYgKHUgPSBNYXRoLnJvdW5kKDEwICogdSkgLyAxMCksIHUgPyBcIjxkaXY+XCIgKyB1ICsgXCI8L2Rpdj5cIiA6IFwiXCI7XG4gICAgfSwgZWRpdGFibGVSZXNvdXJjZUNlbGxUZW1wbGF0ZTogZnVuY3Rpb24ocywgbywgbCwgZCwgYykge1xuICAgICAgcmV0dXJuIGwuJHJvbGUgPT09IFwidGFza1wiID8gci5yZW5kZXJFZGl0YWJsZUxhYmVsKHMsIG8sIGwsIGQsIGMpIDogci5yZW5kZXJTdW1tYXJ5TGFiZWwocywgbywgbCwgZCwgYyk7XG4gICAgfSwgZWRpdGFibGVSZXNvdXJjZUNlbGxDbGFzczogZnVuY3Rpb24ocywgbywgbCwgZCwgYykge1xuICAgICAgY29uc3QgdSA9IFtdO1xuICAgICAgdS5wdXNoKFwicmVzb3VyY2VfbWFya2VyXCIpLCBsLiRyb2xlID09PSBcInRhc2tcIiA/IHUucHVzaChcInRhc2tfY2VsbFwiKSA6IHUucHVzaChcInJlc291cmNlX2NlbGxcIik7XG4gICAgICBjb25zdCBoID0gYy5yZWR1Y2UoZnVuY3Rpb24ocCwgeSkge1xuICAgICAgICByZXR1cm4gcCArIE51bWJlcih5LnZhbHVlKTtcbiAgICAgIH0sIDApO1xuICAgICAgbGV0IGcgPSBOdW1iZXIobC5jYXBhY2l0eSk7XG4gICAgICByZXR1cm4gaXNOYU4oZykgJiYgKGcgPSA4KSwgaCA8PSBnID8gdS5wdXNoKFwid29ya2RheV9va1wiKSA6IHUucHVzaChcIndvcmtkYXlfb3ZlclwiKSwgdS5qb2luKFwiIFwiKTtcbiAgICB9LCBnZXRTdW1tYXJ5UmVzb3VyY2VBc3NpZ25tZW50czogZnVuY3Rpb24ocykge1xuICAgICAgbGV0IG87XG4gICAgICBjb25zdCBsID0gYS5nZXREYXRhc3RvcmUoYS5jb25maWcucmVzb3VyY2Vfc3RvcmUpLCBkID0gbC5nZXRJdGVtKHMpO1xuICAgICAgcmV0dXJuIGQuJHJvbGUgPT09IFwidGFza1wiID8gbyA9IGEuZ2V0UmVzb3VyY2VBc3NpZ25tZW50cyhkLiRyZXNvdXJjZV9pZCwgZC4kdGFza19pZCkgOiAobyA9IGEuZ2V0UmVzb3VyY2VBc3NpZ25tZW50cyhzKSwgbC5lYWNoSXRlbSAmJiBsLmVhY2hJdGVtKGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgYy4kcm9sZSAhPT0gXCJ0YXNrXCIgJiYgKG8gPSBvLmNvbmNhdChhLmdldFJlc291cmNlQXNzaWdubWVudHMoYy5pZCkpKTtcbiAgICAgIH0sIHMpKSwgbztcbiAgICB9LCBpbml0RWRpdGFibGVEaWFncmFtOiBmdW5jdGlvbigpIHtcbiAgICAgIGEuY29uZmlnLnJlc291cmNlX3JlbmRlcl9lbXB0eV9jZWxscyA9ICEwLCBmdW5jdGlvbigpIHtcbiAgICAgICAgbGV0IGwgPSBudWxsO1xuICAgICAgICBmdW5jdGlvbiBkKCkge1xuICAgICAgICAgIHJldHVybiBsICYmIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGwpLCBsID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgYS4kY29udGFpbmVyICYmIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGEuJGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKFwiLnJlc291cmNlVGltZWxpbmVfY2VsbCBbZGF0YS1hc3NpZ25tZW50LWNlbGxdXCIpKS5mb3JFYWNoKGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgICAgICAgYy5jb250ZW50RWRpdGFibGUgPSAhMDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pLCAhMDtcbiAgICAgICAgfVxuICAgICAgICBhLmF0dGFjaEV2ZW50KFwib25HYW50dFJlYWR5XCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGEuZ2V0RGF0YXN0b3JlKGEuY29uZmlnLnJlc291cmNlX2Fzc2lnbm1lbnRfc3RvcmUpLmF0dGFjaEV2ZW50KFwib25TdG9yZVVwZGF0ZWRcIiwgZCksIGEuZ2V0RGF0YXN0b3JlKGEuY29uZmlnLnJlc291cmNlX3N0b3JlKS5hdHRhY2hFdmVudChcIm9uU3RvcmVVcGRhdGVkXCIsIGQpO1xuICAgICAgICB9LCB7IG9uY2U6ICEwIH0pLCBhLmF0dGFjaEV2ZW50KFwib25HYW50dExheW91dFJlYWR5XCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGEuJGxheW91dC5nZXRDZWxsc0J5VHlwZShcInZpZXdDZWxsXCIpLmZvckVhY2goZnVuY3Rpb24oYykge1xuICAgICAgICAgICAgYy4kY29uZmlnICYmIGMuJGNvbmZpZy52aWV3ID09PSBcInJlc291cmNlVGltZWxpbmVcIiAmJiBjLiRjb250ZW50ICYmIGMuJGNvbnRlbnQuYXR0YWNoRXZlbnQoXCJvblNjcm9sbFwiLCBkKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KCk7XG4gICAgICBsZXQgcyA9IG51bGw7XG4gICAgICBmdW5jdGlvbiBvKCkge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGNvbnN0IGwgPSBMdChhLiRjb250YWluZXIpO1xuICAgICAgICAgIHMgPiAtMSAmJiBsW3MgKyAxXS5mb2N1cygpO1xuICAgICAgICB9LCAzMDApO1xuICAgICAgfVxuICAgICAgYS5hdHRhY2hFdmVudChcIm9uR2FudHRSZWFkeVwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgbGV0IGwgPSAhMTtcbiAgICAgICAgYS5ldmVudChhLiRjb250YWluZXIsIFwia2V5cHJlc3NcIiwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgIHZhciBjID0gZC50YXJnZXQuY2xvc2VzdChcIi5yZXNvdXJjZVRpbWVsaW5lX2NlbGwgW2RhdGEtYXNzaWdubWVudC1jZWxsXVwiKTtcbiAgICAgICAgICBjICYmIChkLmtleUNvZGUgIT09IDEzICYmIGQua2V5Q29kZSAhPT0gMjcgfHwgYy5ibHVyKCkpO1xuICAgICAgICB9KSwgYS5ldmVudChhLiRjb250YWluZXIsIFwia2V5ZG93blwiLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgZC5rZXkgPT09IFwiVGFiXCIgJiYgKHMgPSBMdChhLiRjb250YWluZXIpLmluZGV4T2YoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkpO1xuICAgICAgICB9KSwgYS5ldmVudChhLiRjb250YWluZXIsIFwiZm9jdXNvdXRcIiwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgIGlmICghbCkge1xuICAgICAgICAgICAgbCA9ICEwLCBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBsID0gITE7XG4gICAgICAgICAgICB9LCAzMDApO1xuICAgICAgICAgICAgdmFyIGMgPSBkLnRhcmdldC5jbG9zZXN0KFwiLnJlc291cmNlVGltZWxpbmVfY2VsbCBbZGF0YS1hc3NpZ25tZW50LWNlbGxdXCIpO1xuICAgICAgICAgICAgaWYgKGMpIHtcbiAgICAgICAgICAgICAgdmFyIHUgPSAoYy5pbm5lclRleHQgfHwgXCJcIikudHJpbSgpO1xuICAgICAgICAgICAgICB1ID09IFwiLVwiICYmICh1ID0gXCIwXCIpO1xuICAgICAgICAgICAgICB2YXIgaCA9IE51bWJlcih1KSwgZyA9IGMuZ2V0QXR0cmlidXRlKFwiZGF0YS1yb3ctaWRcIiksIHAgPSBjLmdldEF0dHJpYnV0ZShcImRhdGEtYXNzaWdubWVudC1pZFwiKSwgeSA9IGMuZ2V0QXR0cmlidXRlKFwiZGF0YS10YXNrXCIpLCB2ID0gYy5nZXRBdHRyaWJ1dGUoXCJkYXRhLXJlc291cmNlLWlkXCIpLCBiID0gYS50ZW1wbGF0ZXMucGFyc2VfZGF0ZShjLmdldEF0dHJpYnV0ZShcImRhdGEtc3RhcnQtZGF0ZVwiKSksIF8gPSBhLnRlbXBsYXRlcy5wYXJzZV9kYXRlKGMuZ2V0QXR0cmlidXRlKFwiZGF0YS1lbmQtZGF0ZVwiKSksIG0gPSBhLmdldERhdGFzdG9yZShhLmNvbmZpZy5yZXNvdXJjZV9hc3NpZ25tZW50X3N0b3JlKTtcbiAgICAgICAgICAgICAgaWYgKGlzTmFOKGgpKSBhLmdldERhdGFzdG9yZShhLmNvbmZpZy5yZXNvdXJjZV9zdG9yZSkucmVmcmVzaChnKTtcbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGYgPSBhLmdldFRhc2soeSk7XG4gICAgICAgICAgICAgICAgaWYgKGEucGx1Z2lucygpLnVuZG8gJiYgYS5leHQudW5kby5zYXZlU3RhdGUoeSwgXCJ0YXNrXCIpLCBwKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoaCA9PT0gKHggPSBtLmdldEl0ZW0ocCkpLnZhbHVlKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICBpZiAoeC5zdGFydF9kYXRlLnZhbHVlT2YoKSA9PT0gYi52YWx1ZU9mKCkgJiYgeC5lbmRfZGF0ZS52YWx1ZU9mKCkgPT09IF8udmFsdWVPZigpKSB4LnZhbHVlID0gaCwgaCA/IG0udXBkYXRlSXRlbSh4LmlkKSA6IG0ucmVtb3ZlSXRlbSh4LmlkKTtcbiAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoeC5lbmRfZGF0ZS52YWx1ZU9mKCkgPiBfLnZhbHVlT2YoKSkge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBrID0gYS5jb3B5KHgpO1xuICAgICAgICAgICAgICAgICAgICAgIGsuaWQgPSBhLnVpZCgpLCBrLnN0YXJ0X2RhdGUgPSBfLCBrLmR1cmF0aW9uID0gYS5jYWxjdWxhdGVEdXJhdGlvbih7IHN0YXJ0X2RhdGU6IGsuc3RhcnRfZGF0ZSwgZW5kX2RhdGU6IGsuZW5kX2RhdGUsIHRhc2s6IGYgfSksIGsuZGVsYXkgPSBhLmNhbGN1bGF0ZUR1cmF0aW9uKHsgc3RhcnRfZGF0ZTogZi5zdGFydF9kYXRlLCBlbmRfZGF0ZTogay5zdGFydF9kYXRlLCB0YXNrOiBmIH0pLCBrLm1vZGUgPSB4Lm1vZGUgfHwgXCJkZWZhdWx0XCIsIGsuZHVyYXRpb24gIT09IDAgJiYgbS5hZGRJdGVtKGspO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHguc3RhcnRfZGF0ZS52YWx1ZU9mKCkgPCBiLnZhbHVlT2YoKSA/ICh4LmVuZF9kYXRlID0gYiwgeC5kdXJhdGlvbiA9IGEuY2FsY3VsYXRlRHVyYXRpb24oeyBzdGFydF9kYXRlOiB4LnN0YXJ0X2RhdGUsIGVuZF9kYXRlOiB4LmVuZF9kYXRlLCB0YXNrOiBmIH0pLCB4Lm1vZGUgPSBcImZpeGVkRHVyYXRpb25cIiwgeC5kdXJhdGlvbiA9PT0gMCA/IG0ucmVtb3ZlSXRlbSh4LmlkKSA6IG0udXBkYXRlSXRlbSh4LmlkKSkgOiBtLnJlbW92ZUl0ZW0oeC5pZCksIGggJiYgbS5hZGRJdGVtKHsgdGFza19pZDogeC50YXNrX2lkLCByZXNvdXJjZV9pZDogeC5yZXNvdXJjZV9pZCwgdmFsdWU6IGgsIHN0YXJ0X2RhdGU6IGIsIGVuZF9kYXRlOiBfLCBkdXJhdGlvbjogYS5jYWxjdWxhdGVEdXJhdGlvbih7IHN0YXJ0X2RhdGU6IGIsIGVuZF9kYXRlOiBfLCB0YXNrOiBmIH0pLCBkZWxheTogYS5jYWxjdWxhdGVEdXJhdGlvbih7IHN0YXJ0X2RhdGU6IGYuc3RhcnRfZGF0ZSwgZW5kX2RhdGU6IGIsIHRhc2s6IGYgfSksIG1vZGU6IFwiZml4ZWREdXJhdGlvblwiIH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYS51cGRhdGVUYXNrQXNzaWdubWVudHMoZi5pZCksIGEudXBkYXRlVGFzayhmLmlkKSwgbygpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaCkge1xuICAgICAgICAgICAgICAgICAgdmFyIHggPSB7IHRhc2tfaWQ6IHksIHJlc291cmNlX2lkOiB2LCB2YWx1ZTogaCwgc3RhcnRfZGF0ZTogYiwgZW5kX2RhdGU6IF8sIGR1cmF0aW9uOiBhLmNhbGN1bGF0ZUR1cmF0aW9uKHsgc3RhcnRfZGF0ZTogYiwgZW5kX2RhdGU6IF8sIHRhc2s6IGYgfSksIGRlbGF5OiBhLmNhbGN1bGF0ZUR1cmF0aW9uKHsgc3RhcnRfZGF0ZTogZi5zdGFydF9kYXRlLCBlbmRfZGF0ZTogYiwgdGFzazogZiB9KSwgbW9kZTogXCJmaXhlZER1cmF0aW9uXCIgfTtcbiAgICAgICAgICAgICAgICAgIG0uYWRkSXRlbSh4KSwgYS51cGRhdGVUYXNrQXNzaWdubWVudHMoZi5pZCksIGEudXBkYXRlVGFzayhmLmlkKSwgbygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9LCB7IG9uY2U6ICEwIH0pO1xuICAgIH0gfTtcbiAgICByZXR1cm4gcjtcbiAgfSh0KSwgdC5jb25maWcucmVzb3VyY2VzID0geyBkYXRhcHJvY2Vzc29yX2Fzc2lnbm1lbnRzOiAhMSwgZGF0YXByb2Nlc3Nvcl9yZXNvdXJjZXM6ICExLCBlZGl0YWJsZV9yZXNvdXJjZV9kaWFncmFtOiAhMSwgcmVzb3VyY2Vfc3RvcmU6IHsgdHlwZTogXCJ0cmVlRGF0YVN0b3JlXCIsIGZldGNoVGFza3M6ICExLCBpbml0SXRlbTogZnVuY3Rpb24oYSkge1xuICAgIHJldHVybiBhLnBhcmVudCA9IGEucGFyZW50IHx8IHQuY29uZmlnLnJvb3RfaWQsIGFbdC5jb25maWcucmVzb3VyY2VfcHJvcGVydHldID0gYS5wYXJlbnQsIGEub3BlbiA9ICEwLCBhO1xuICB9IH0sIGxpZ2h0Ym94X3Jlc291cmNlczogZnVuY3Rpb24oYSkge1xuICAgIGNvbnN0IHIgPSBbXSwgcyA9IHQuZ2V0RGF0YXN0b3JlKHQuY29uZmlnLnJlc291cmNlX3N0b3JlKTtcbiAgICByZXR1cm4gYS5mb3JFYWNoKGZ1bmN0aW9uKG8pIHtcbiAgICAgIGlmICghcy5oYXNDaGlsZChvLmlkKSkge1xuICAgICAgICBjb25zdCBsID0gdC5jb3B5KG8pO1xuICAgICAgICBsLmtleSA9IG8uaWQsIGwubGFiZWwgPSBvLnRleHQsIHIucHVzaChsKTtcbiAgICAgIH1cbiAgICB9KSwgcjtcbiAgfSB9LCB0LmF0dGFjaEV2ZW50KFwib25CZWZvcmVHYW50dFJlYWR5XCIsIGZ1bmN0aW9uKCkge1xuICAgIGlmICh0LmdldERhdGFzdG9yZSh0LmNvbmZpZy5yZXNvdXJjZV9zdG9yZSkpIHJldHVybjtcbiAgICBjb25zdCBhID0gdC5jb25maWcucmVzb3VyY2VzID8gdC5jb25maWcucmVzb3VyY2VzLnJlc291cmNlX3N0b3JlIDogdm9pZCAwO1xuICAgIGxldCByID0gYSA/IGEuZmV0Y2hUYXNrcyA6IHZvaWQgMDtcbiAgICB0LmNvbmZpZy5yZXNvdXJjZXMgJiYgdC5jb25maWcucmVzb3VyY2VzLmVkaXRhYmxlX3Jlc291cmNlX2RpYWdyYW0gJiYgKHIgPSAhMCk7XG4gICAgbGV0IHMgPSBmdW5jdGlvbihsKSB7XG4gICAgICByZXR1cm4gbC5wYXJlbnQgPSBsLnBhcmVudCB8fCB0LmNvbmZpZy5yb290X2lkLCBsW3QuY29uZmlnLnJlc291cmNlX3Byb3BlcnR5XSA9IGwucGFyZW50LCBsLm9wZW4gPSAhMCwgbDtcbiAgICB9O1xuICAgIGEgJiYgYS5pbml0SXRlbSAmJiAocyA9IGEuaW5pdEl0ZW0pO1xuICAgIGNvbnN0IG8gPSBhICYmIGEudHlwZSA/IGEudHlwZSA6IFwidHJlZURhdGFzdG9yZVwiO1xuICAgIHQuJHJlc291cmNlc1N0b3JlID0gdC5jcmVhdGVEYXRhc3RvcmUoeyBuYW1lOiB0LmNvbmZpZy5yZXNvdXJjZV9zdG9yZSwgdHlwZTogbywgZmV0Y2hUYXNrczogciAhPT0gdm9pZCAwICYmIHIsIGluaXRJdGVtOiBzIH0pLCB0LiRkYXRhLnJlc291cmNlc1N0b3JlID0gdC4kcmVzb3VyY2VzU3RvcmUsIHQuJHJlc291cmNlc1N0b3JlLmF0dGFjaEV2ZW50KFwib25QYXJzZVwiLCBmdW5jdGlvbigpIHtcbiAgICAgIGxldCBsLCBkID0gZnVuY3Rpb24oYykge1xuICAgICAgICBjb25zdCB1ID0gW107XG4gICAgICAgIHJldHVybiBjLmZvckVhY2goZnVuY3Rpb24oaCkge1xuICAgICAgICAgIGNvbnN0IGcgPSB0LmNvcHkoaCk7XG4gICAgICAgICAgZy5rZXkgPSBoLmlkLCBnLmxhYmVsID0gaC50ZXh0LCB1LnB1c2goZyk7XG4gICAgICAgIH0pLCB1O1xuICAgICAgfTtcbiAgICAgIHQuY29uZmlnLnJlc291cmNlcyAmJiB0LmNvbmZpZy5yZXNvdXJjZXMubGlnaHRib3hfcmVzb3VyY2VzICYmIChkID0gdC5jb25maWcucmVzb3VyY2VzLmxpZ2h0Ym94X3Jlc291cmNlcyksIHQuY29uZmlnLnJlc291cmNlcyAmJiB0LmNvbmZpZy5yZXNvdXJjZXMuZWRpdGFibGVfcmVzb3VyY2VfZGlhZ3JhbSA/IGwgPSBkKHQuJHJlc291cmNlc1N0b3JlLmdldEl0ZW1zKCkuZmlsdGVyKChjKSA9PiB7XG4gICAgICAgIGxldCB1ID0gdC5nZXRSZXNvdXJjZUFzc2lnbm1lbnRzKGMuaWQpO1xuICAgICAgICBpZiAoIXQuJHJlc291cmNlc1N0b3JlLmhhc0NoaWxkKGMuaWQpIHx8IHUgJiYgdS5sZW5ndGgpIHJldHVybiAhYy4kcmVzb3VyY2VfaWQgfHwgIWMuJHRhc2tfaWQ7XG4gICAgICB9KSkgOiBsID0gZCh0LiRyZXNvdXJjZXNTdG9yZS5nZXRJdGVtcygpKSwgdC51cGRhdGVDb2xsZWN0aW9uKFwicmVzb3VyY2VPcHRpb25zXCIsIGwpO1xuICAgIH0pO1xuICB9KSwgdC5nZXRUYXNrQnkgPSBlLmdldFRhc2tCeSwgdC5nZXRSZXNvdXJjZUFzc2lnbm1lbnRzID0gZS5nZXRSZXNvdXJjZUFzc2lnbm1lbnRzLCB0LmNvbmZpZy5yZXNvdXJjZV9wcm9wZXJ0eSA9IFwib3duZXJfaWRcIiwgdC5jb25maWcucmVzb3VyY2Vfc3RvcmUgPSBcInJlc291cmNlXCIsIHQuY29uZmlnLnJlc291cmNlX3JlbmRlcl9lbXB0eV9jZWxscyA9ICExLCB0LnRlbXBsYXRlcy5oaXN0b2dyYW1fY2VsbF9jbGFzcyA9IGZ1bmN0aW9uKGEsIHIsIHMsIG8sIGwpIHtcbiAgfSwgdC50ZW1wbGF0ZXMuaGlzdG9ncmFtX2NlbGxfbGFiZWwgPSBmdW5jdGlvbihhLCByLCBzLCBvLCBsKSB7XG4gICAgcmV0dXJuIG8ubGVuZ3RoICsgXCIvM1wiO1xuICB9LCB0LnRlbXBsYXRlcy5oaXN0b2dyYW1fY2VsbF9hbGxvY2F0ZWQgPSBmdW5jdGlvbihhLCByLCBzLCBvLCBsKSB7XG4gICAgcmV0dXJuIG8ubGVuZ3RoIC8gMztcbiAgfSwgdC50ZW1wbGF0ZXMuaGlzdG9ncmFtX2NlbGxfY2FwYWNpdHkgPSBmdW5jdGlvbihhLCByLCBzLCBvLCBsKSB7XG4gICAgcmV0dXJuIDA7XG4gIH07XG4gIGNvbnN0IG4gPSBmdW5jdGlvbihhLCByLCBzLCBvLCBsKSB7XG4gICAgcmV0dXJuIG8ubGVuZ3RoIDw9IDEgPyBcImdhbnR0X3Jlc291cmNlX21hcmtlcl9va1wiIDogXCJnYW50dF9yZXNvdXJjZV9tYXJrZXJfb3ZlcnRpbWVcIjtcbiAgfSwgaSA9IGZ1bmN0aW9uKGEsIHIsIHMsIG8sIGwpIHtcbiAgICByZXR1cm4gOCAqIG8ubGVuZ3RoO1xuICB9O1xuICB0LnRlbXBsYXRlcy5yZXNvdXJjZV9jZWxsX3ZhbHVlID0gaSwgdC50ZW1wbGF0ZXMucmVzb3VyY2VfY2VsbF9jbGFzcyA9IG4sIHQuYXR0YWNoRXZlbnQoXCJvbkJlZm9yZUdhbnR0UmVhZHlcIiwgZnVuY3Rpb24oKSB7XG4gICAgdC5jb25maWcucmVzb3VyY2VzICYmIHQuY29uZmlnLnJlc291cmNlcy5lZGl0YWJsZV9yZXNvdXJjZV9kaWFncmFtICYmICh0LmNvbmZpZy5yZXNvdXJjZV9yZW5kZXJfZW1wdHlfY2VsbHMgPSAhMCwgdC50ZW1wbGF0ZXMucmVzb3VyY2VfY2VsbF92YWx1ZSA9PT0gaSAmJiAodC50ZW1wbGF0ZXMucmVzb3VyY2VfY2VsbF92YWx1ZSA9IHQuZXh0LnJlc291cmNlcy5lZGl0YWJsZVJlc291cmNlQ2VsbFRlbXBsYXRlKSwgdC50ZW1wbGF0ZXMucmVzb3VyY2VfY2VsbF9jbGFzcyA9PT0gbiAmJiAodC50ZW1wbGF0ZXMucmVzb3VyY2VfY2VsbF9jbGFzcyA9IHQuZXh0LnJlc291cmNlcy5lZGl0YWJsZVJlc291cmNlQ2VsbENsYXNzKSwgdC5leHQucmVzb3VyY2VzLmluaXRFZGl0YWJsZURpYWdyYW0odCkpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGRpKHQpIHtcbiAgdmFyIGUgPSBcIiRyZXNvdXJjZUFzc2lnbm1lbnRzXCI7XG4gIHQuY29uZmlnLnJlc291cmNlX2Fzc2lnbm1lbnRfc3RvcmUgPSBcInJlc291cmNlQXNzaWdubWVudHNcIiwgdC5jb25maWcucHJvY2Vzc19yZXNvdXJjZV9hc3NpZ25tZW50cyA9ICEwO1xuICB2YXIgbiA9IFwiYXV0b1wiLCBpID0gXCJzaW5nbGVWYWx1ZVwiLCBhID0gXCJ2YWx1ZUFycmF5XCIsIHIgPSBcInJlc291cmNlVmFsdWVBcnJheVwiLCBzID0gXCJhc3NpZ25tZW50c0FycmF5XCIsIG8gPSBuLCBsID0gXCJmaXhlZERhdGVzXCIsIGQgPSBcImZpeGVkRHVyYXRpb25cIiwgYyA9IFwiZGVmYXVsdFwiO1xuICBmdW5jdGlvbiB1KGYsIGspIHtcbiAgICBmLnN0YXJ0X2RhdGUgPyBmLnN0YXJ0X2RhdGUgPSB0LmRhdGUucGFyc2VEYXRlKGYuc3RhcnRfZGF0ZSwgXCJwYXJzZV9kYXRlXCIpIDogZi5zdGFydF9kYXRlID0gbnVsbCwgZi5lbmRfZGF0ZSA/IGYuZW5kX2RhdGUgPSB0LmRhdGUucGFyc2VEYXRlKGYuZW5kX2RhdGUsIFwicGFyc2VfZGF0ZVwiKSA6IGYuZW5kX2RhdGUgPSBudWxsO1xuICAgIHZhciB4ID0gTnVtYmVyKGYuZGVsYXkpLCAkID0gITE7XG4gICAgaWYgKGlzTmFOKHgpID8gKGYuZGVsYXkgPSAwLCAkID0gITApIDogZi5kZWxheSA9IHgsIHQuZGVmaW5lZChmLnZhbHVlKSB8fCAoZi52YWx1ZSA9IG51bGwpLCAhZi50YXNrX2lkIHx8ICFmLnJlc291cmNlX2lkKSByZXR1cm4gITE7XG4gICAgaWYgKGYubW9kZSA9IGYubW9kZSB8fCBjLCBmLm1vZGUgPT09IGQgJiYgKGlzTmFOKE51bWJlcihmLmR1cmF0aW9uKSkgJiYgKGsgPSBrIHx8IHQuZ2V0VGFzayhmLnRhc2tfaWQpLCBmLmR1cmF0aW9uID0gdC5jYWxjdWxhdGVEdXJhdGlvbih7IHN0YXJ0X2RhdGU6IGYuc3RhcnRfZGF0ZSwgZW5kX2RhdGU6IGYuZW5kX2RhdGUsIGlkOiBrIH0pKSwgJCAmJiAoayA9IGsgfHwgdC5nZXRUYXNrKGYudGFza19pZCksIGYuZGVsYXkgPSB0LmNhbGN1bGF0ZUR1cmF0aW9uKHsgc3RhcnRfZGF0ZTogay5zdGFydF9kYXRlLCBlbmRfZGF0ZTogZi5zdGFydF9kYXRlLCBpZDogayB9KSkpLCBmLm1vZGUgIT09IGwgJiYgKGsgfHwgdC5pc1Rhc2tFeGlzdHMoZi50YXNrX2lkKSkpIHtcbiAgICAgIHZhciB3ID0gZyhmLCBrID0gayB8fCB0LmdldFRhc2soZi50YXNrX2lkKSk7XG4gICAgICBmLnN0YXJ0X2RhdGUgPSB3LnN0YXJ0X2RhdGUsIGYuZW5kX2RhdGUgPSB3LmVuZF9kYXRlLCBmLmR1cmF0aW9uID0gdy5kdXJhdGlvbjtcbiAgICB9XG4gIH1cbiAgdmFyIGggPSB0LmNyZWF0ZURhdGFzdG9yZSh7IG5hbWU6IHQuY29uZmlnLnJlc291cmNlX2Fzc2lnbm1lbnRfc3RvcmUsIGluaXRJdGVtOiBmdW5jdGlvbihmKSB7XG4gICAgcmV0dXJuIGYuaWQgfHwgKGYuaWQgPSB0LnVpZCgpKSwgdShmKSwgZjtcbiAgfSB9KTtcbiAgZnVuY3Rpb24gZyhmLCBrKSB7XG4gICAgaWYgKGYubW9kZSA9PT0gbCkgcmV0dXJuIHsgc3RhcnRfZGF0ZTogZi5zdGFydF9kYXRlLCBlbmRfZGF0ZTogZi5lbmRfZGF0ZSwgZHVyYXRpb246IGYuZHVyYXRpb24gfTtcbiAgICB2YXIgeCwgJCwgdyA9IGYuZGVsYXkgPyB0LmNhbGN1bGF0ZUVuZERhdGUoeyBzdGFydF9kYXRlOiBrLnN0YXJ0X2RhdGUsIGR1cmF0aW9uOiBmLmRlbGF5LCB0YXNrOiBrIH0pIDogbmV3IERhdGUoay5zdGFydF9kYXRlKTtcbiAgICByZXR1cm4gZi5tb2RlID09PSBkID8gKHggPSB0LmNhbGN1bGF0ZUVuZERhdGUoeyBzdGFydF9kYXRlOiB3LCBkdXJhdGlvbjogZi5kdXJhdGlvbiwgdGFzazogayB9KSwgJCA9IGYuZHVyYXRpb24pIDogKHggPSBuZXcgRGF0ZShrLmVuZF9kYXRlKSwgJCA9IGsuZHVyYXRpb24gLSBmLmRlbGF5KSwgeyBzdGFydF9kYXRlOiB3LCBlbmRfZGF0ZTogeCwgZHVyYXRpb246ICQgfTtcbiAgfVxuICBmdW5jdGlvbiBwKGYpIHtcbiAgICBjb25zdCBrID0gdC5jb25maWcucmVzb3VyY2VfcHJvcGVydHk7XG4gICAgbGV0IHggPSBmW2tdO1xuICAgIGNvbnN0ICQgPSBbXTtcbiAgICBsZXQgdyA9IG8gPT09IG47XG4gICAgaWYgKHQuZGVmaW5lZCh4KSAmJiB4KSB7XG4gICAgICBBcnJheS5pc0FycmF5KHgpIHx8ICh4ID0gW3hdLCB3ICYmIChvID0gaSwgdyA9ICExKSk7XG4gICAgICBjb25zdCBTID0ge307XG4gICAgICB4LmZvckVhY2goZnVuY3Rpb24oVCkge1xuICAgICAgICBULnJlc291cmNlX2lkIHx8IChUID0geyByZXNvdXJjZV9pZDogVCB9LCB3ICYmIChvID0gYSwgdyA9ICExKSksIHcgJiYgKFQuaWQgJiYgVC5yZXNvdXJjZV9pZCA/IChvID0gcywgdyA9ICExKSA6IChvID0gciwgdyA9ICExKSk7XG4gICAgICAgIGxldCBFLCBDID0gYztcbiAgICAgICAgVC5tb2RlIHx8IChULnN0YXJ0X2RhdGUgJiYgVC5lbmRfZGF0ZSB8fCBULnN0YXJ0X2RhdGUgJiYgVC5kdXJhdGlvbikgJiYgKEMgPSBkKSwgRSA9IFQuaWQgfHwgIVQuJGlkIHx8IFNbVC4kaWRdID8gVC5pZCAmJiAhU1tULmlkXSA/IFQuaWQgOiB0LnVpZCgpIDogVC4kaWQsIFNbRV0gPSAhMDtcbiAgICAgICAgY29uc3QgRCA9IHsgaWQ6IEUsIHN0YXJ0X2RhdGU6IFQuc3RhcnRfZGF0ZSwgZHVyYXRpb246IFQuZHVyYXRpb24sIGVuZF9kYXRlOiBULmVuZF9kYXRlLCBkZWxheTogVC5kZWxheSwgdGFza19pZDogZi5pZCwgcmVzb3VyY2VfaWQ6IFQucmVzb3VyY2VfaWQsIHZhbHVlOiBULnZhbHVlLCBtb2RlOiBULm1vZGUgfHwgQyB9O1xuICAgICAgICBPYmplY3Qua2V5cyhUKS5mb3JFYWNoKChNKSA9PiB7XG4gICAgICAgICAgTSAhPSBcIiRpZFwiICYmIChEW01dID0gVFtNXSk7XG4gICAgICAgIH0pLCBELnN0YXJ0X2RhdGUgJiYgRC5zdGFydF9kYXRlLmdldE1vbnRoICYmIEQuZW5kX2RhdGUgJiYgRC5lbmRfZGF0ZS5nZXRNb250aCAmJiB0eXBlb2YgRC5kdXJhdGlvbiA9PSBcIm51bWJlclwiIHx8IHUoRCwgZiksICQucHVzaChEKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gJDtcbiAgfVxuICBmdW5jdGlvbiB5KGYpIHtcbiAgICBpZiAodC5pc1Rhc2tFeGlzdHMoZikpIHtcbiAgICAgIHZhciBrID0gdC5nZXRUYXNrKGYpO1xuICAgICAgdihrLCB0LmdldFRhc2tBc3NpZ25tZW50cyhrLmlkKSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHYoZiwgaykge1xuICAgIGsuc29ydChmdW5jdGlvbih4LCAkKSB7XG4gICAgICByZXR1cm4geC5zdGFydF9kYXRlICYmICQuc3RhcnRfZGF0ZSAmJiB4LnN0YXJ0X2RhdGUudmFsdWVPZigpICE9ICQuc3RhcnRfZGF0ZS52YWx1ZU9mKCkgPyB4LnN0YXJ0X2RhdGUgLSAkLnN0YXJ0X2RhdGUgOiAwO1xuICAgIH0pLCBvID09IHMgPyBmW3QuY29uZmlnLnJlc291cmNlX3Byb3BlcnR5XSA9IGsgOiBvID09IHIgJiYgKGZbdC5jb25maWcucmVzb3VyY2VfcHJvcGVydHldID0gay5tYXAoZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIHsgJGlkOiB4LmlkLCBzdGFydF9kYXRlOiB4LnN0YXJ0X2RhdGUsIGR1cmF0aW9uOiB4LmR1cmF0aW9uLCBlbmRfZGF0ZTogeC5lbmRfZGF0ZSwgZGVsYXk6IHguZGVsYXksIHJlc291cmNlX2lkOiB4LnJlc291cmNlX2lkLCB2YWx1ZTogeC52YWx1ZSwgbW9kZTogeC5tb2RlIH07XG4gICAgfSkpLCBmW2VdID0gaztcbiAgfVxuICBmdW5jdGlvbiBiKGYpIHtcbiAgICB2YXIgayA9IHAoZik7XG4gICAgcmV0dXJuIGsuZm9yRWFjaChmdW5jdGlvbih4KSB7XG4gICAgICB4LmlkID0geC5pZCB8fCB0LnVpZCgpO1xuICAgIH0pLCBrO1xuICB9XG4gIGZ1bmN0aW9uIF8oZiwgaykge1xuICAgIHZhciB4ID0gZnVuY3Rpb24oJCwgdykge1xuICAgICAgdmFyIFMgPSB7IGluQm90aDogW10sIGluVGFza05vdEluU3RvcmU6IFtdLCBpblN0b3JlTm90SW5UYXNrOiBbXSB9O1xuICAgICAgaWYgKG8gPT0gaSkge1xuICAgICAgICB2YXIgVCA9ICRbMF0sIEUgPSBUID8gVC5yZXNvdXJjZV9pZCA6IG51bGwsIEMgPSAhMTtcbiAgICAgICAgdy5mb3JFYWNoKGZ1bmN0aW9uKEEpIHtcbiAgICAgICAgICBBLnJlc291cmNlX2lkICE9IEUgPyBTLmluU3RvcmVOb3RJblRhc2sucHVzaChBKSA6IEEucmVzb3VyY2VfaWQgPT0gRSAmJiAoUy5pbkJvdGgucHVzaCh7IHN0b3JlOiBBLCB0YXNrOiBUIH0pLCBDID0gITApO1xuICAgICAgICB9KSwgIUMgJiYgVCAmJiBTLmluVGFza05vdEluU3RvcmUucHVzaChUKTtcbiAgICAgIH0gZWxzZSBpZiAobyA9PSBhKSB7XG4gICAgICAgIHZhciBEID0ge30sIE0gPSB7fSwgSSA9IHt9O1xuICAgICAgICAkLmZvckVhY2goZnVuY3Rpb24oQSkge1xuICAgICAgICAgIERbQS5yZXNvdXJjZV9pZF0gPSBBO1xuICAgICAgICB9KSwgdy5mb3JFYWNoKGZ1bmN0aW9uKEEpIHtcbiAgICAgICAgICBNW0EucmVzb3VyY2VfaWRdID0gQTtcbiAgICAgICAgfSksICQuY29uY2F0KHcpLmZvckVhY2goZnVuY3Rpb24oQSkge1xuICAgICAgICAgIGlmICghSVtBLnJlc291cmNlX2lkXSkge1xuICAgICAgICAgICAgSVtBLnJlc291cmNlX2lkXSA9ICEwO1xuICAgICAgICAgICAgdmFyIE4gPSBEW0EucmVzb3VyY2VfaWRdLCBMID0gTVtBLnJlc291cmNlX2lkXTtcbiAgICAgICAgICAgIE4gJiYgTCA/IFMuaW5Cb3RoLnB1c2goeyBzdG9yZTogTCwgdGFzazogTiB9KSA6IE4gJiYgIUwgPyBTLmluVGFza05vdEluU3RvcmUucHVzaChOKSA6ICFOICYmIEwgJiYgUy5pblN0b3JlTm90SW5UYXNrLnB1c2goTCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBvICE9IHMgJiYgbyAhPSByIHx8IChEID0ge30sIE0gPSB7fSwgSSA9IHt9LCAkLmZvckVhY2goZnVuY3Rpb24oQSkge1xuICAgICAgICBEW0EuaWQgfHwgQS4kaWRdID0gQTtcbiAgICAgIH0pLCB3LmZvckVhY2goZnVuY3Rpb24oQSkge1xuICAgICAgICBNW0EuaWRdID0gQTtcbiAgICAgIH0pLCAkLmNvbmNhdCh3KS5mb3JFYWNoKGZ1bmN0aW9uKEEpIHtcbiAgICAgICAgdmFyIE4gPSBBLmlkIHx8IEEuJGlkO1xuICAgICAgICBpZiAoIUlbTl0pIHtcbiAgICAgICAgICBJW05dID0gITA7XG4gICAgICAgICAgdmFyIEwgPSBEW05dLCBPID0gTVtOXTtcbiAgICAgICAgICBMICYmIE8gPyBTLmluQm90aC5wdXNoKHsgc3RvcmU6IE8sIHRhc2s6IEwgfSkgOiBMICYmICFPID8gUy5pblRhc2tOb3RJblN0b3JlLnB1c2goTCkgOiAhTCAmJiBPICYmIFMuaW5TdG9yZU5vdEluVGFzay5wdXNoKE8pO1xuICAgICAgICB9XG4gICAgICB9KSk7XG4gICAgICByZXR1cm4gUztcbiAgICB9KHAoZiksIGspO1xuICAgIHguaW5TdG9yZU5vdEluVGFzay5mb3JFYWNoKGZ1bmN0aW9uKCQpIHtcbiAgICAgIGgucmVtb3ZlSXRlbSgkLmlkKTtcbiAgICB9KSwgeC5pblRhc2tOb3RJblN0b3JlLmZvckVhY2goZnVuY3Rpb24oJCkge1xuICAgICAgaC5hZGRJdGVtKCQpO1xuICAgIH0pLCB4LmluQm90aC5mb3JFYWNoKGZ1bmN0aW9uKCQpIHtcbiAgICAgIGlmIChmdW5jdGlvbihTLCBUKSB7XG4gICAgICAgIHZhciBFID0geyBpZDogITAgfTtcbiAgICAgICAgZm9yICh2YXIgQyBpbiBTKSBpZiAoIUVbQ10gJiYgU3RyaW5nKFNbQ10pICE9PSBTdHJpbmcoVFtDXSkpIHJldHVybiAhMDtcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgfSgkLnRhc2ssICQuc3RvcmUpKSAoZnVuY3Rpb24oUywgVCkge1xuICAgICAgICB2YXIgRSA9IHsgaWQ6ICEwIH07XG4gICAgICAgIGZvciAodmFyIEMgaW4gUykgRVtDXSB8fCAoVFtDXSA9IFNbQ10pO1xuICAgICAgfSkoJC50YXNrLCAkLnN0b3JlKSwgaC51cGRhdGVJdGVtKCQuc3RvcmUuaWQpO1xuICAgICAgZWxzZSBpZiAoJC50YXNrLnN0YXJ0X2RhdGUgJiYgJC50YXNrLmVuZF9kYXRlICYmICQudGFzay5tb2RlICE9PSBsKSB7XG4gICAgICAgIHZhciB3ID0gZygkLnN0b3JlLCBmKTtcbiAgICAgICAgJC5zdG9yZS5zdGFydF9kYXRlLnZhbHVlT2YoKSA9PSB3LnN0YXJ0X2RhdGUudmFsdWVPZigpICYmICQuc3RvcmUuZW5kX2RhdGUudmFsdWVPZigpID09IHcuZW5kX2RhdGUudmFsdWVPZigpIHx8ICgkLnN0b3JlLnN0YXJ0X2RhdGUgPSB3LnN0YXJ0X2RhdGUsICQuc3RvcmUuZW5kX2RhdGUgPSB3LmVuZF9kYXRlLCAkLnN0b3JlLmR1cmF0aW9uID0gdy5kdXJhdGlvbiwgaC51cGRhdGVJdGVtKCQuc3RvcmUuaWQpKTtcbiAgICAgIH1cbiAgICB9KSwgeShmLmlkKTtcbiAgfVxuICBmdW5jdGlvbiBtKGYpIHtcbiAgICB2YXIgayA9IGZbZV0gfHwgaC5maW5kKGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiB4LnRhc2tfaWQgPT0gZi5pZDtcbiAgICB9KTtcbiAgICBfKGYsIGspO1xuICB9XG4gIHQuJGRhdGEuYXNzaWdubWVudHNTdG9yZSA9IGgsIHQuYXR0YWNoRXZlbnQoXCJvbkdhbnR0UmVhZHlcIiwgZnVuY3Rpb24oKSB7XG4gICAgaWYgKHQuY29uZmlnLnByb2Nlc3NfcmVzb3VyY2VfYXNzaWdubWVudHMpIHtcbiAgICAgIHQuYXR0YWNoRXZlbnQoXCJvblBhcnNlXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICB0LnNpbGVudChmdW5jdGlvbigpIHtcbiAgICAgICAgICBoLmNsZWFyQWxsKCk7XG4gICAgICAgICAgdmFyIEUgPSBbXTtcbiAgICAgICAgICB0LmVhY2hUYXNrKGZ1bmN0aW9uKEMpIHtcbiAgICAgICAgICAgIGlmIChDLnR5cGUgIT09IHQuY29uZmlnLnR5cGVzLnByb2plY3QpIHtcbiAgICAgICAgICAgICAgdmFyIEQgPSBiKEMpO1xuICAgICAgICAgICAgICB2KEMsIEQpLCBELmZvckVhY2goZnVuY3Rpb24oTSkge1xuICAgICAgICAgICAgICAgIEUucHVzaChNKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSksIGgucGFyc2UoRSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICB2YXIgZiA9ICExLCBrID0gITEsIHggPSB7fSwgJCA9ICExO1xuICAgICAgdC5hdHRhY2hFdmVudChcIm9uQmVmb3JlQmF0Y2hVcGRhdGVcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGYgPSAhMDtcbiAgICAgIH0pLCB0LmF0dGFjaEV2ZW50KFwib25BZnRlckJhdGNoVXBkYXRlXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoaykge1xuICAgICAgICAgIHZhciBFID0ge307XG4gICAgICAgICAgZm9yICh2YXIgQyBpbiB4KSBFW0NdID0gdC5nZXRUYXNrQXNzaWdubWVudHMoeFtDXS5pZCk7XG4gICAgICAgICAgZm9yICh2YXIgQyBpbiB0LmNvbmZpZy5wcm9jZXNzX3Jlc291cmNlX2Fzc2lnbm1lbnRzICYmIG8gPT09IFwicmVzb3VyY2VWYWx1ZUFycmF5XCIgJiYgKFQgPSBudWxsKSwgeCkgXyh4W0NdLCBFW0NdKTtcbiAgICAgICAgfVxuICAgICAgICBrID0gITEsIGYgPSAhMSwgeCA9IHt9O1xuICAgICAgfSksIHQuYXR0YWNoRXZlbnQoXCJvblRhc2tDcmVhdGVkXCIsIGZ1bmN0aW9uKEUpIHtcbiAgICAgICAgdmFyIEMgPSBiKEUpO1xuICAgICAgICByZXR1cm4gaC5wYXJzZShDKSwgdihFLCBDKSwgITA7XG4gICAgICB9KSwgdC5hdHRhY2hFdmVudChcIm9uQWZ0ZXJUYXNrVXBkYXRlXCIsIGZ1bmN0aW9uKEUsIEMpIHtcbiAgICAgICAgZiA/IChrID0gITAsIHhbRV0gPSBDKSA6IEMudW5zY2hlZHVsZWQgfHwgbShDKTtcbiAgICAgIH0pLCB0LmF0dGFjaEV2ZW50KFwib25BZnRlclRhc2tBZGRcIiwgZnVuY3Rpb24oRSwgQykge1xuICAgICAgICBmID8gKGsgPSAhMCwgeFtFXSA9IEMpIDogbShDKTtcbiAgICAgIH0pLCB0LmF0dGFjaEV2ZW50KFwib25Sb3dEcmFnRW5kXCIsIGZ1bmN0aW9uKEUpIHtcbiAgICAgICAgbSh0LmdldFRhc2soRSkpO1xuICAgICAgfSksIHQuJGRhdGEudGFza3NTdG9yZS5hdHRhY2hFdmVudChcIm9uQWZ0ZXJEZWxldGVDb25maXJtZWRcIiwgZnVuY3Rpb24oRSwgQykge1xuICAgICAgICB2YXIgRCwgTSA9IFtFXTtcbiAgICAgICAgdC5lYWNoVGFzayhmdW5jdGlvbihJKSB7XG4gICAgICAgICAgTS5wdXNoKEkuaWQpO1xuICAgICAgICB9LCBFKSwgRCA9IHt9LCBNLmZvckVhY2goZnVuY3Rpb24oSSkge1xuICAgICAgICAgIERbSV0gPSAhMDtcbiAgICAgICAgfSksIGguZmluZChmdW5jdGlvbihJKSB7XG4gICAgICAgICAgcmV0dXJuIERbSS50YXNrX2lkXTtcbiAgICAgICAgfSkuZm9yRWFjaChmdW5jdGlvbihJKSB7XG4gICAgICAgICAgaC5yZW1vdmVJdGVtKEkuaWQpO1xuICAgICAgICB9KTtcbiAgICAgIH0pLCB0LiRkYXRhLnRhc2tzU3RvcmUuYXR0YWNoRXZlbnQoXCJvbkNsZWFyQWxsXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdyA9IG51bGwsIFMgPSBudWxsLCBUID0gbnVsbCwgaC5jbGVhckFsbCgpLCAhMDtcbiAgICAgIH0pLCB0LmF0dGFjaEV2ZW50KFwib25UYXNrSWRDaGFuZ2VcIiwgZnVuY3Rpb24oRSwgQykge1xuICAgICAgICBoLmZpbmQoZnVuY3Rpb24oRCkge1xuICAgICAgICAgIHJldHVybiBELnRhc2tfaWQgPT0gRTtcbiAgICAgICAgfSkuZm9yRWFjaChmdW5jdGlvbihEKSB7XG4gICAgICAgICAgRC50YXNrX2lkID0gQywgaC51cGRhdGVJdGVtKEQuaWQpO1xuICAgICAgICB9KSwgeShDKTtcbiAgICAgIH0pLCB0LmF0dGFjaEV2ZW50KFwib25CZWZvcmVVbmRvXCIsIGZ1bmN0aW9uKEUpIHtcbiAgICAgICAgcmV0dXJuICQgPSAhMCwgITA7XG4gICAgICB9KSwgdC5hdHRhY2hFdmVudChcIm9uQWZ0ZXJVbmRvXCIsIGZ1bmN0aW9uKEUpIHtcbiAgICAgICAgJCA9ICEwO1xuICAgICAgfSk7XG4gICAgICB2YXIgdyA9IG51bGwsIFMgPSBudWxsLCBUID0gbnVsbDtcbiAgICAgIGguYXR0YWNoRXZlbnQoXCJvblN0b3JlVXBkYXRlZFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGYgJiYgISQgfHwgKHcgPSBudWxsLCBTID0gbnVsbCwgVCA9IG51bGwpLCAhMDtcbiAgICAgIH0pLCB0LmdldFJlc291cmNlQXNzaWdubWVudHMgPSBmdW5jdGlvbihFLCBDKSB7XG4gICAgICAgIHZhciBEID0gdC5kZWZpbmVkKEMpICYmIEMgIT09IG51bGw7XG4gICAgICAgIHJldHVybiB3ID09PSBudWxsICYmICh3ID0ge30sIFMgPSB7fSwgaC5lYWNoSXRlbShmdW5jdGlvbihNKSB7XG4gICAgICAgICAgd1tNLnJlc291cmNlX2lkXSB8fCAod1tNLnJlc291cmNlX2lkXSA9IFtdKSwgd1tNLnJlc291cmNlX2lkXS5wdXNoKE0pO1xuICAgICAgICAgIHZhciBJID0gTS5yZXNvdXJjZV9pZCArIFwiLVwiICsgTS50YXNrX2lkO1xuICAgICAgICAgIFNbSV0gfHwgKFNbSV0gPSBbXSksIFNbSV0ucHVzaChNKTtcbiAgICAgICAgfSkpLCBEID8gKFNbRSArIFwiLVwiICsgQ10gfHwgW10pLnNsaWNlKCkgOiAod1tFXSB8fCBbXSkuc2xpY2UoKTtcbiAgICAgIH0sIHQuZ2V0VGFza0Fzc2lnbm1lbnRzID0gZnVuY3Rpb24oRSkge1xuICAgICAgICBpZiAoVCA9PT0gbnVsbCkge1xuICAgICAgICAgIHZhciBDID0gW107XG4gICAgICAgICAgVCA9IHt9LCBoLmVhY2hJdGVtKGZ1bmN0aW9uKEQpIHtcbiAgICAgICAgICAgIFRbRC50YXNrX2lkXSB8fCAoVFtELnRhc2tfaWRdID0gW10pLCBUW0QudGFza19pZF0ucHVzaChEKSwgRC50YXNrX2lkID09IEUgJiYgQy5wdXNoKEQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoVFtFXSB8fCBbXSkuc2xpY2UoKTtcbiAgICAgIH0sIHQuZ2V0VGFza1Jlc291cmNlcyA9IGZ1bmN0aW9uKEUpIHtcbiAgICAgICAgY29uc3QgQyA9IHQuZ2V0RGF0YXN0b3JlKFwicmVzb3VyY2VcIiksIEQgPSB0LmdldFRhc2tBc3NpZ25tZW50cyhFKSwgTSA9IHt9O1xuICAgICAgICBELmZvckVhY2goZnVuY3Rpb24oQSkge1xuICAgICAgICAgIE1bQS5yZXNvdXJjZV9pZF0gfHwgKE1bQS5yZXNvdXJjZV9pZF0gPSBBLnJlc291cmNlX2lkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IEkgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBBIGluIE0pIHtcbiAgICAgICAgICBjb25zdCBOID0gQy5nZXRJdGVtKE1bQV0pO1xuICAgICAgICAgIE4gJiYgSS5wdXNoKE4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBJO1xuICAgICAgfSwgdC51cGRhdGVUYXNrQXNzaWdubWVudHMgPSB5O1xuICAgIH1cbiAgfSwgeyBvbmNlOiAhMCB9KTtcbn1cbmZ1bmN0aW9uIGNpKHQpIHtcbiAgZnVuY3Rpb24gZShvKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICF0LmNvbmZpZy5wbGFjZWhvbGRlcl90YXNrIHx8IG8uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIG4oKSB7XG4gICAgdmFyIG8gPSB0LmdldFRhc2tCeShcInR5cGVcIiwgdC5jb25maWcudHlwZXMucGxhY2Vob2xkZXIpO1xuICAgIGlmICghby5sZW5ndGggfHwgIXQuaXNUYXNrRXhpc3RzKG9bMF0uaWQpKSB7XG4gICAgICB2YXIgbCA9IHsgdW5zY2hlZHVsZWQ6ICEwLCB0eXBlOiB0LmNvbmZpZy50eXBlcy5wbGFjZWhvbGRlciwgZHVyYXRpb246IDAsIHRleHQ6IHQubG9jYWxlLmxhYmVscy5uZXdfdGFzayB9O1xuICAgICAgaWYgKHQuY2FsbEV2ZW50KFwib25UYXNrQ3JlYXRlZFwiLCBbbF0pID09PSAhMSkgcmV0dXJuO1xuICAgICAgdC5hZGRUYXNrKGwpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBpKG8pIHtcbiAgICB2YXIgbCA9IHQuZ2V0VGFzayhvKTtcbiAgICBsLnR5cGUgPT0gdC5jb25maWcudHlwZXMucGxhY2Vob2xkZXIgJiYgKGwuc3RhcnRfZGF0ZSAmJiBsLmVuZF9kYXRlICYmIGwudW5zY2hlZHVsZWQgJiYgKGwudW5zY2hlZHVsZWQgPSAhMSksIHQuYmF0Y2hVcGRhdGUoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZCA9IHQuY29weShsKTtcbiAgICAgIHQuc2lsZW50KGZ1bmN0aW9uKCkge1xuICAgICAgICB0LmRlbGV0ZVRhc2sobC5pZCk7XG4gICAgICB9KSwgZGVsZXRlIGRbXCIhbmF0aXZlZWRpdG9yX3N0YXR1c1wiXSwgZC50eXBlID0gdC5jb25maWcudHlwZXMudGFzaywgZC5pZCA9IHQudWlkKCksIHQuYWRkVGFzayhkKTtcbiAgICB9KSk7XG4gIH1cbiAgdC5jb25maWcudHlwZXMucGxhY2Vob2xkZXIgPSBcInBsYWNlaG9sZGVyXCIsIHQuYXR0YWNoRXZlbnQoXCJvbkRhdGFQcm9jZXNzb3JSZWFkeVwiLCBlKGZ1bmN0aW9uKG8pIHtcbiAgICBvICYmICFvLl9zaWxlbmNlZFBsYWNlaG9sZGVyICYmIChvLl9zaWxlbmNlZFBsYWNlaG9sZGVyID0gITAsIG8uYXR0YWNoRXZlbnQoXCJvbkJlZm9yZVVwZGF0ZVwiLCBlKGZ1bmN0aW9uKGwsIGQsIGMpIHtcbiAgICAgIHJldHVybiBjLnR5cGUgIT0gdC5jb25maWcudHlwZXMucGxhY2Vob2xkZXIgfHwgKG8uc2V0VXBkYXRlZChsLCAhMSksICExKTtcbiAgICB9KSkpO1xuICB9KSk7XG4gIHZhciBhID0gITE7XG4gIGZ1bmN0aW9uIHIobykge1xuICAgIHJldHVybiAhISh0LmNvbmZpZy50eXBlcy5wbGFjZWhvbGRlciAmJiB0LmlzVGFza0V4aXN0cyhvKSAmJiB0LmdldFRhc2sobykudHlwZSA9PSB0LmNvbmZpZy50eXBlcy5wbGFjZWhvbGRlcik7XG4gIH1cbiAgZnVuY3Rpb24gcyhvKSB7XG4gICAgcmV0dXJuICEoIXIoby5zb3VyY2UpICYmICFyKG8udGFyZ2V0KSk7XG4gIH1cbiAgdC5hdHRhY2hFdmVudChcIm9uR2FudHRSZWFkeVwiLCBmdW5jdGlvbigpIHtcbiAgICBhIHx8IChhID0gITAsIHQuYXR0YWNoRXZlbnQoXCJvbkFmdGVyVGFza1VwZGF0ZVwiLCBlKGkpKSwgdC5hdHRhY2hFdmVudChcIm9uQWZ0ZXJUYXNrQWRkXCIsIGUoZnVuY3Rpb24obywgbCkge1xuICAgICAgbC50eXBlICE9IHQuY29uZmlnLnR5cGVzLnBsYWNlaG9sZGVyICYmICh0LmdldFRhc2tCeShcInR5cGVcIiwgdC5jb25maWcudHlwZXMucGxhY2Vob2xkZXIpLmZvckVhY2goZnVuY3Rpb24oZCkge1xuICAgICAgICB0LnNpbGVudChmdW5jdGlvbigpIHtcbiAgICAgICAgICB0LmlzVGFza0V4aXN0cyhkLmlkKSAmJiB0LmRlbGV0ZVRhc2soZC5pZCk7XG4gICAgICAgIH0pO1xuICAgICAgfSksIG4oKSk7XG4gICAgfSkpLCB0LmF0dGFjaEV2ZW50KFwib25QYXJzZVwiLCBlKG4pKSk7XG4gIH0pLCB0LmF0dGFjaEV2ZW50KFwib25MaW5rVmFsaWRhdGlvblwiLCBmdW5jdGlvbihvKSB7XG4gICAgcmV0dXJuICFzKG8pO1xuICB9KSwgdC5hdHRhY2hFdmVudChcIm9uQmVmb3JlTGlua0FkZFwiLCBmdW5jdGlvbihvLCBsKSB7XG4gICAgcmV0dXJuICFzKGwpO1xuICB9KSwgdC5hdHRhY2hFdmVudChcIm9uQmVmb3JlVW5kb1N0YWNrXCIsIGZ1bmN0aW9uKG8pIHtcbiAgICBmb3IgKHZhciBsID0gMDsgbCA8IG8uY29tbWFuZHMubGVuZ3RoOyBsKyspIHtcbiAgICAgIHZhciBkID0gby5jb21tYW5kc1tsXTtcbiAgICAgIGQuZW50aXR5ID09PSBcInRhc2tcIiAmJiBkLnZhbHVlLnR5cGUgPT09IHQuY29uZmlnLnR5cGVzLnBsYWNlaG9sZGVyICYmIChvLmNvbW1hbmRzLnNwbGljZShsLCAxKSwgbC0tKTtcbiAgICB9XG4gICAgcmV0dXJuICEwO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHVpKHQpIHtcbiAgZnVuY3Rpb24gZShjKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICF0LmNvbmZpZy5hdXRvX3R5cGVzIHx8IHQuZ2V0VGFza1R5cGUodC5jb25maWcudHlwZXMucHJvamVjdCkgIT0gdC5jb25maWcudHlwZXMucHJvamVjdCB8fCBjLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBuKGMsIHUpIHtcbiAgICB2YXIgaCA9IHQuZ2V0VGFzayhjKSwgZyA9IHIoaCk7XG4gICAgZyAhPT0gITEgJiYgdC5nZXRUYXNrVHlwZShoKSAhPT0gZyAmJiAodS4kbmVlZHNVcGRhdGUgPSAhMCwgdVtoLmlkXSA9IHsgdGFzazogaCwgdHlwZTogZyB9KTtcbiAgfVxuICBmdW5jdGlvbiBpKGMpIHtcbiAgICBpZiAoIXQuZ2V0U3RhdGUoKS5ncm91cF9tb2RlKSB7XG4gICAgICB2YXIgdSA9IGZ1bmN0aW9uKGgsIGcpIHtcbiAgICAgICAgcmV0dXJuIG4oaCwgZyA9IGcgfHwge30pLCB0LmVhY2hQYXJlbnQoZnVuY3Rpb24ocCkge1xuICAgICAgICAgIG4ocC5pZCwgZyk7XG4gICAgICAgIH0sIGgpLCBnO1xuICAgICAgfShjKTtcbiAgICAgIHUuJG5lZWRzVXBkYXRlICYmIHQuYmF0Y2hVcGRhdGUoZnVuY3Rpb24oKSB7XG4gICAgICAgIChmdW5jdGlvbihoKSB7XG4gICAgICAgICAgZm9yICh2YXIgZyBpbiBoKSBpZiAoaFtnXSAmJiBoW2ddLnRhc2spIHtcbiAgICAgICAgICAgIHZhciBwID0gaFtnXS50YXNrO1xuICAgICAgICAgICAgcC50eXBlID0gaFtnXS50eXBlLCB0LnVwZGF0ZVRhc2socC5pZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KSh1KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICB2YXIgYTtcbiAgZnVuY3Rpb24gcihjKSB7XG4gICAgdmFyIHUgPSB0LmNvbmZpZy50eXBlcywgaCA9IHQuaGFzQ2hpbGQoYy5pZCksIGcgPSB0LmdldFRhc2tUeXBlKGMudHlwZSk7XG4gICAgcmV0dXJuIGggJiYgZyA9PT0gdS50YXNrID8gdS5wcm9qZWN0IDogIWggJiYgZyA9PT0gdS5wcm9qZWN0ICYmIHUudGFzaztcbiAgfVxuICB2YXIgcywgbywgbCA9ICEwO1xuICBmdW5jdGlvbiBkKGMpIHtcbiAgICBjICE9IHQuY29uZmlnLnJvb3RfaWQgJiYgdC5pc1Rhc2tFeGlzdHMoYykgJiYgaShjKTtcbiAgfVxuICB0LmF0dGFjaEV2ZW50KFwib25QYXJzZVwiLCBlKGZ1bmN0aW9uKCkge1xuICAgIGwgPSAhMSwgdC5nZXRTdGF0ZSgpLmdyb3VwX21vZGUgfHwgKHQuYmF0Y2hVcGRhdGUoZnVuY3Rpb24oKSB7XG4gICAgICB0LmVhY2hUYXNrKGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgdmFyIHUgPSByKGMpO1xuICAgICAgICB1ICE9PSAhMSAmJiBmdW5jdGlvbihoLCBnKSB7XG4gICAgICAgICAgdC5nZXRTdGF0ZSgpLmdyb3VwX21vZGUgfHwgKGgudHlwZSA9IGcsIHQudXBkYXRlVGFzayhoLmlkKSk7XG4gICAgICAgIH0oYywgdSk7XG4gICAgICB9KTtcbiAgICB9KSwgbCA9ICEwKTtcbiAgfSkpLCB0LmF0dGFjaEV2ZW50KFwib25BZnRlclRhc2tBZGRcIiwgZShmdW5jdGlvbihjKSB7XG4gICAgbCAmJiBpKGMpO1xuICB9KSksIHQuYXR0YWNoRXZlbnQoXCJvbkFmdGVyVGFza1VwZGF0ZVwiLCBlKGZ1bmN0aW9uKGMpIHtcbiAgICBsICYmIGkoYyk7XG4gIH0pKSwgdC5hdHRhY2hFdmVudChcIm9uQmVmb3JlVGFza0RlbGV0ZVwiLCBlKGZ1bmN0aW9uKGMsIHUpIHtcbiAgICByZXR1cm4gYSA9IHQuZ2V0UGFyZW50KGMpLCAhMDtcbiAgfSkpLCB0LmF0dGFjaEV2ZW50KFwib25BZnRlclRhc2tEZWxldGVcIiwgZShmdW5jdGlvbihjLCB1KSB7XG4gICAgZChhKTtcbiAgfSkpLCB0LmF0dGFjaEV2ZW50KFwib25Sb3dEcmFnU3RhcnRcIiwgZShmdW5jdGlvbihjLCB1LCBoKSB7XG4gICAgcmV0dXJuIHMgPSB0LmdldFBhcmVudChjKSwgITA7XG4gIH0pKSwgdC5hdHRhY2hFdmVudChcIm9uUm93RHJhZ0VuZFwiLCBlKGZ1bmN0aW9uKGMsIHUpIHtcbiAgICBkKHMpLCBpKGMpO1xuICB9KSksIHQuYXR0YWNoRXZlbnQoXCJvbkJlZm9yZVRhc2tNb3ZlXCIsIGUoZnVuY3Rpb24oYywgdSwgaCkge1xuICAgIHJldHVybiBvID0gdC5nZXRQYXJlbnQoYyksICEwO1xuICB9KSksIHQuYXR0YWNoRXZlbnQoXCJvbkFmdGVyVGFza01vdmVcIiwgZShmdW5jdGlvbihjLCB1LCBoKSB7XG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi5nYW50dF9kcmFnX21hcmtlclwiKSB8fCAoZChvKSwgaShjKSk7XG4gIH0pKTtcbn1cbmNvbnN0IFp0ID0gY2xhc3MgWnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmNhblBhcnNlID0gKGUpID0+ICFpc05hTih0aGlzLnBhcnNlKGUpKSwgdGhpcy5mb3JtYXQgPSAoZSkgPT4gU3RyaW5nKGUpLCB0aGlzLnBhcnNlID0gKGUpID0+IHBhcnNlSW50KGUsIDEwKTtcbiAgfVxufTtcblp0LmNyZWF0ZSA9IChlID0gbnVsbCkgPT4gbmV3IFp0KCk7XG5sZXQgUHQgPSBadDtcbmNvbnN0IFF0ID0gY2xhc3MgUXQge1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgdGhpcy5mb3JtYXQgPSAobikgPT4gdGhpcy5fZ2V0V0JTQ29kZShuLnNvdXJjZSksIHRoaXMuY2FuUGFyc2UgPSAobikgPT4gdGhpcy5fbGlua1JlZy50ZXN0KG4pLCB0aGlzLnBhcnNlID0gKG4pID0+IHtcbiAgICAgIGlmICghdGhpcy5jYW5QYXJzZShuKSkgcmV0dXJuIG51bGw7XG4gICAgICBjb25zdCBpID0gdGhpcy5fbGlua1JlZy5leGVjKG4pWzBdLnRyaW0oKTtcbiAgICAgIHJldHVybiB7IGlkOiB2b2lkIDAsIHNvdXJjZTogdGhpcy5fZmluZFNvdXJjZShpKSB8fCBudWxsLCB0YXJnZXQ6IG51bGwsIHR5cGU6IHRoaXMuX2dhbnR0LmNvbmZpZy5saW5rcy5maW5pc2hfdG9fc3RhcnQsIGxhZzogMCB9O1xuICAgIH0sIHRoaXMuX2dldFdCU0NvZGUgPSAobikgPT4ge1xuICAgICAgY29uc3QgaSA9IHRoaXMuX2dhbnR0LmdldFRhc2sobik7XG4gICAgICByZXR1cm4gdGhpcy5fZ2FudHQuZ2V0V0JTQ29kZShpKTtcbiAgICB9LCB0aGlzLl9maW5kU291cmNlID0gKG4pID0+IHtcbiAgICAgIGNvbnN0IGkgPSBuZXcgUmVnRXhwKFwiXlswLTkuXStcIiwgXCJpXCIpO1xuICAgICAgaWYgKGkuZXhlYyhuKSkge1xuICAgICAgICBjb25zdCBhID0gaS5leGVjKG4pWzBdLCByID0gdGhpcy5fZ2FudHQuZ2V0VGFza0J5V0JTQ29kZShhKTtcbiAgICAgICAgaWYgKHIpIHJldHVybiByLmlkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSwgdGhpcy5fbGlua1JlZyA9IC9eWzAtOVxcLl0rLywgdGhpcy5fZ2FudHQgPSBlO1xuICB9XG59O1xuUXQuY3JlYXRlID0gKGUgPSBudWxsLCBuKSA9PiBuZXcgUXQobik7XG5sZXQga2UgPSBRdDtcbmZ1bmN0aW9uIGhpKHQpIHtcbiAgdC5leHQuZm9ybWF0dGVycyA9IHsgZHVyYXRpb25Gb3JtYXR0ZXI6IGZ1bmN0aW9uKGUpIHtcbiAgICByZXR1cm4gZSB8fCAoZSA9IHt9KSwgZS5zdG9yZSB8fCAoZS5zdG9yZSA9IHQuY29uZmlnLmR1cmF0aW9uX3VuaXQpLCBlLmVudGVyIHx8IChlLmVudGVyID0gdC5jb25maWcuZHVyYXRpb25fdW5pdCksIFB0LmNyZWF0ZShlLCB0KTtcbiAgfSwgbGlua0Zvcm1hdHRlcjogZnVuY3Rpb24oZSkge1xuICAgIHJldHVybiBrZS5jcmVhdGUoZSwgdCk7XG4gIH0gfTtcbn1cbmZ1bmN0aW9uIF9pKHQpIHtcbiAgdC5leHQgPSB0LmV4dCB8fCB7fSwgdC5jb25maWcuc2hvd19lbXB0eV9zdGF0ZSA9ICExLCB0LmV4dC5lbXB0eVN0YXRlRWxlbWVudCA9IHQuZXh0LmVtcHR5U3RhdGVFbGVtZW50IHx8IHsgaXNFbmFibGVkOiAoKSA9PiB0LmNvbmZpZy5zaG93X2VtcHR5X3N0YXRlID09PSAhMCwgaXNHYW50dEVtcHR5OiAoKSA9PiAhdC5nZXRUYXNrQnlUaW1lKCkubGVuZ3RoLCByZW5kZXJDb250ZW50KGUpIHtcbiAgICBjb25zdCBuID0gYDxkaXYgY2xhc3M9J2dhbnR0X2VtcHR5X3N0YXRlJz48ZGl2IGNsYXNzPSdnYW50dF9lbXB0eV9zdGF0ZV9pbWFnZSc+PC9kaXY+JHtgPGRpdiBjbGFzcz0nZ2FudHRfZW1wdHlfc3RhdGVfdGV4dCc+XG4gICAgPGRpdiBjbGFzcz0nZ2FudHRfZW1wdHlfc3RhdGVfdGV4dF9saW5rJyBkYXRhLWVtcHR5LXN0YXRlLWNyZWF0ZS10YXNrPiR7dC5sb2NhbGUubGFiZWxzLmVtcHR5X3N0YXRlX3RleHRfbGlua308L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPSdnYW50dF9lbXB0eV9zdGF0ZV90ZXh0X2Rlc2NyaXB0aW9uJz4ke3QubG9jYWxlLmxhYmVscy5lbXB0eV9zdGF0ZV90ZXh0X2Rlc2NyaXB0aW9ufTwvZGl2PlxuICAgIDwvZGl2PmB9PC9kaXY+YDtcbiAgICBlLmlubmVySFRNTCA9IG47XG4gIH0sIGNsaWNrRXZlbnRzOiBbXSwgYXR0YWNoQWRkVGFza0V2ZW50KCkge1xuICAgIGNvbnN0IGUgPSB0LmF0dGFjaEV2ZW50KFwib25FbXB0eUNsaWNrXCIsIGZ1bmN0aW9uKG4pIHtcbiAgICAgIHQudXRpbHMuZG9tLmNsb3Nlc3Qobi50YXJnZXQsIFwiW2RhdGEtZW1wdHktc3RhdGUtY3JlYXRlLXRhc2tdXCIpICYmIHQuY3JlYXRlVGFzayh7IGlkOiB0LnVpZCgpLCB0ZXh0OiBcIk5ldyBUYXNrXCIgfSk7XG4gICAgfSk7XG4gICAgdGhpcy5jbGlja0V2ZW50cy5wdXNoKGUpO1xuICB9LCBkZXRhY2hBZGRUYXNrRXZlbnRzKCkge1xuICAgIHRoaXMuY2xpY2tFdmVudHMuZm9yRWFjaChmdW5jdGlvbihlKSB7XG4gICAgICB0LmRldGFjaEV2ZW50KGUpO1xuICAgIH0pLCB0aGlzLmNsaWNrRXZlbnRzID0gW107XG4gIH0sIGdldENvbnRhaW5lcigpIHtcbiAgICBpZiAodC4kY29udGFpbmVyKSB7XG4gICAgICBjb25zdCBlID0gdC51dGlscy5kb207XG4gICAgICBpZiAodC4kY29udGFpbmVyLmNvbnRhaW5zKHQuJGdyaWRfZGF0YSkpIHJldHVybiBlLmNsb3Nlc3QodC4kZ3JpZF9kYXRhLCBcIi5nYW50dF9sYXlvdXRfY29udGVudFwiKTtcbiAgICAgIGlmICh0LiRjb250YWluZXIuY29udGFpbnModC4kdGFza19kYXRhKSkgcmV0dXJuIGUuY2xvc2VzdCh0LiR0YXNrX2RhdGEsIFwiLmdhbnR0X2xheW91dF9jb250ZW50XCIpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfSwgZ2V0Tm9kZSgpIHtcbiAgICBjb25zdCBlID0gdGhpcy5nZXRDb250YWluZXIoKTtcbiAgICByZXR1cm4gZSA/IGUucXVlcnlTZWxlY3RvcihcIi5nYW50dF9lbXB0eV9zdGF0ZV93cmFwcGVyXCIpIDogbnVsbDtcbiAgfSwgc2hvdygpIHtcbiAgICBjb25zdCBlID0gdGhpcy5nZXRDb250YWluZXIoKTtcbiAgICBpZiAoIWUgJiYgdGhpcy5pc0dhbnR0RW1wdHkoKSkgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgbi5jbGFzc05hbWUgPSBcImdhbnR0X2VtcHR5X3N0YXRlX3dyYXBwZXJcIiwgbi5zdHlsZS5tYXJnaW5Ub3AgPSB0LmNvbmZpZy5zY2FsZV9oZWlnaHQgLSBlLm9mZnNldEhlaWdodCArIFwicHhcIjtcbiAgICBjb25zdCBpID0gdC4kY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoXCIuZ2FudHRfZW1wdHlfc3RhdGVfd3JhcHBlclwiKTtcbiAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKGksIGZ1bmN0aW9uKGEpIHtcbiAgICAgIGEucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChhKTtcbiAgICB9KSwgdGhpcy5kZXRhY2hBZGRUYXNrRXZlbnRzKCksIHRoaXMuYXR0YWNoQWRkVGFza0V2ZW50KCksIGUuYXBwZW5kQ2hpbGQobiksIHRoaXMucmVuZGVyQ29udGVudChuKTtcbiAgfSwgaGlkZSgpIHtcbiAgICBjb25zdCBlID0gdGhpcy5nZXROb2RlKCk7XG4gICAgaWYgKCFlKSByZXR1cm4gITE7XG4gICAgZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGUpO1xuICB9LCBpbml0KCkge1xuICB9IH0sIHQuYXR0YWNoRXZlbnQoXCJvbkRhdGFSZW5kZXJcIiwgZnVuY3Rpb24oKSB7XG4gICAgY29uc3QgZSA9IHQuZXh0LmVtcHR5U3RhdGVFbGVtZW50O1xuICAgIGUuaXNFbmFibGVkKCkgJiYgZS5pc0dhbnR0RW1wdHkoKSA/IGUuc2hvdygpIDogZS5oaWRlKCk7XG4gIH0pO1xufVxuY29uc3QgaG4gPSBmdW5jdGlvbih0LCBlKSB7XG4gIGNvbnN0IG4gPSBlLmJhc2VsaW5lcyAmJiBlLmJhc2VsaW5lcy5sZW5ndGgsIGkgPSB0LmNvbmZpZy5iYXNlbGluZXMucmVuZGVyX21vZGUgPT0gXCJzZXBhcmF0ZVJvd1wiIHx8IHQuY29uZmlnLmJhc2VsaW5lcy5yZW5kZXJfbW9kZSA9PSBcImluZGl2aWR1YWxSb3dcIjtcbiAgaWYgKG4gJiYgaSkgcmV0dXJuICEwO1xufSwgJHQgPSBmdW5jdGlvbih0KSB7XG4gIHJldHVybiB0LnJlbmRlciAmJiB0LnJlbmRlciA9PSBcInNwbGl0XCIgJiYgIXQuJG9wZW47XG59O1xuZnVuY3Rpb24gZ2kodCkge1xuICB0LmNvbmZpZy5iYXNlbGluZXMgPSB7IGRhdGFzdG9yZTogXCJiYXNlbGluZXNcIiwgcmVuZGVyX21vZGU6ICExLCBkYXRhcHJvY2Vzc29yX2Jhc2VsaW5lczogITEsIHJvd19oZWlnaHQ6IDE2LCBiYXJfaGVpZ2h0OiA4IH07XG4gIGNvbnN0IGUgPSB0LmNyZWF0ZURhdGFzdG9yZSh7IG5hbWU6IHQuY29uZmlnLmJhc2VsaW5lcy5kYXRhc3RvcmUsIGluaXRJdGVtOiBmdW5jdGlvbihhKSB7XG4gICAgcmV0dXJuIGEuaWQgfHwgKGEuaWQgPSB0LnVpZCgpKSwgZnVuY3Rpb24ocikge1xuICAgICAgaWYgKCFyLnRhc2tfaWQgfHwgIXIuc3RhcnRfZGF0ZSAmJiAhci5lbmRfZGF0ZSkgcmV0dXJuICExO1xuICAgICAgci5zdGFydF9kYXRlID8gci5zdGFydF9kYXRlID0gdC5kYXRlLnBhcnNlRGF0ZShyLnN0YXJ0X2RhdGUsIFwicGFyc2VfZGF0ZVwiKSA6IHIuc3RhcnRfZGF0ZSA9IG51bGwsIHIuZW5kX2RhdGUgPyByLmVuZF9kYXRlID0gdC5kYXRlLnBhcnNlRGF0ZShyLmVuZF9kYXRlLCBcInBhcnNlX2RhdGVcIikgOiByLmVuZF9kYXRlID0gbnVsbCwgci5kdXJhdGlvbiA9IHIuZHVyYXRpb24gfHwgMSwgci5zdGFydF9kYXRlICYmICFyLmVuZF9kYXRlID8gci5lbmRfZGF0ZSA9IHQuY2FsY3VsYXRlRW5kRGF0ZShyLnN0YXJ0X2RhdGUsIHIuZHVyYXRpb24pIDogci5lbmRfZGF0ZSAmJiAhci5zdGFydF9kYXRlICYmIChyLnN0YXJ0X2RhdGUgPSB0LmNhbGN1bGF0ZUVuZERhdGUoci5lbmRfZGF0ZSwgLXIuZHVyYXRpb24pKTtcbiAgICB9KGEpLCBhO1xuICB9IH0pO1xuICBmdW5jdGlvbiBuKGEpIHtcbiAgICBsZXQgciA9IDA7XG4gICAgdC5hZGp1c3RUYXNrSGVpZ2h0Rm9yQmFzZWxpbmVzKGEpLCB0LmVhY2hUYXNrKGZ1bmN0aW9uKHMpIHtcbiAgICAgIGxldCBvID0gcy5yb3dfaGVpZ2h0IHx8IHQuY29uZmlnLnJvd19oZWlnaHQ7XG4gICAgICByID0gciB8fCBvLCBvID4gciAmJiAociA9IG8pO1xuICAgIH0sIGEuaWQpLCBhLnJvd19oZWlnaHQgPCByICYmIChhLnJvd19oZWlnaHQgPSByKTtcbiAgfVxuICBmdW5jdGlvbiBpKGEpIHtcbiAgICB0LmVhY2hQYXJlbnQoZnVuY3Rpb24ocikge1xuICAgICAgaWYgKCR0KHIpKSB7XG4gICAgICAgIGNvbnN0IHMgPSByLnJvd19oZWlnaHQgfHwgdC5nZXRMYXlvdXRWaWV3KFwidGltZWxpbmVcIikuZ2V0QmFySGVpZ2h0KHIuaWQpO1xuICAgICAgICBsZXQgbyA9IGEucm93X2hlaWdodDtcbiAgICAgICAgdC5nZXRDaGlsZHJlbihyLmlkKS5mb3JFYWNoKGZ1bmN0aW9uKGwpIHtcbiAgICAgICAgICBjb25zdCBkID0gdC5nZXRUYXNrKGwpO1xuICAgICAgICAgIGlmIChkLmlkID09IGEuaWQpIHJldHVybjtcbiAgICAgICAgICBjb25zdCBjID0gZC5yb3dfaGVpZ2h0IHx8IHQuZ2V0TGF5b3V0VmlldyhcInRpbWVsaW5lXCIpLmdldEJhckhlaWdodChkLmlkKTtcbiAgICAgICAgICBvID0gbyB8fCBjLCBjID4gbyAmJiAobyA9IGMpO1xuICAgICAgICB9KSwgci5yb3dfaGVpZ2h0ID0gbywgci5iYXJfaGVpZ2h0ID0gci5iYXJfaGVpZ2h0IHx8IHM7XG4gICAgICB9XG4gICAgfSwgYS5pZCk7XG4gIH1cbiAgdC4kZGF0YS5iYXNlbGluZVN0b3JlID0gZSwgdC5hZGp1c3RUYXNrSGVpZ2h0Rm9yQmFzZWxpbmVzID0gZnVuY3Rpb24oYSkge1xuICAgIGxldCByLCBzLCBvID0gYS5iYXNlbGluZXMgJiYgYS5iYXNlbGluZXMubGVuZ3RoIHx8IDA7XG4gICAgY29uc3QgbCA9IHQuY29uZmlnLmJhc2VsaW5lcy5yb3dfaGVpZ2h0LCBkID0gdC5nZXRMYXlvdXRWaWV3KFwidGltZWxpbmVcIik7XG4gICAgaWYgKGQgJiYgdC5jb25maWcuc2hvd19jaGFydCkgc3dpdGNoICh0LmNvbmZpZy5iYXNlbGluZXMucmVuZGVyX21vZGUpIHtcbiAgICAgIGNhc2UgXCJ0YXNrUm93XCI6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBhLnJvd19oZWlnaHQgPSBhLmJhcl9oZWlnaHQgKyA4O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJzZXBhcmF0ZVJvd1wiOlxuICAgICAgICByID0gZC5nZXRCYXJIZWlnaHQoYS5pZCksIG8gPyAoYS5iYXJfaGVpZ2h0ID0gYS5iYXJfaGVpZ2h0IHx8IHIsIGEuYmFyX2hlaWdodCA+IHIgJiYgKHIgPSBhLmJhcl9oZWlnaHQpLCBhLnJvd19oZWlnaHQgPSByICsgbCkgOiBhLmJhcl9oZWlnaHQgJiYgKGEucm93X2hlaWdodCA9IGEuYmFyX2hlaWdodCArIDQpLCBpKGEpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJpbmRpdmlkdWFsUm93XCI6XG4gICAgICAgIHIgPSBkLmdldEJhckhlaWdodChhLmlkKSwgbyA/IChhLmJhcl9oZWlnaHQgPSBhLmJhcl9oZWlnaHQgfHwgciwgYS5iYXJfaGVpZ2h0ID4gciAmJiAociA9IGEuYmFyX2hlaWdodCksIHMgPSBsICogbywgYS5yb3dfaGVpZ2h0ID0gciArIHMgKyAyKSA6IGEuYmFyX2hlaWdodCAmJiAoYS5yb3dfaGVpZ2h0ID0gYS5iYXJfaGVpZ2h0ICsgNCksIGkoYSk7XG4gICAgfVxuICB9LCB0LmF0dGFjaEV2ZW50KFwib25HYW50dFJlYWR5XCIsIGZ1bmN0aW9uKCkge1xuICAgIHQuY29uZmlnLmJhc2VsaW5lcyAmJiAodC5hdHRhY2hFdmVudChcIm9uUGFyc2VcIiwgZnVuY3Rpb24oKSB7XG4gICAgICBlLmVhY2hJdGVtKGZ1bmN0aW9uKGEpIHtcbiAgICAgICAgY29uc3QgciA9IGEudGFza19pZDtcbiAgICAgICAgaWYgKHQuaXNUYXNrRXhpc3RzKHIpKSB7XG4gICAgICAgICAgY29uc3QgcyA9IHQuZ2V0VGFzayhyKTtcbiAgICAgICAgICBzLmJhc2VsaW5lcyA9IHMuYmFzZWxpbmVzIHx8IFtdO1xuICAgICAgICAgIGxldCBvID0gITA7XG4gICAgICAgICAgZm9yIChsZXQgbCA9IDA7IGwgPCBzLmJhc2VsaW5lcy5sZW5ndGg7IGwrKykge1xuICAgICAgICAgICAgbGV0IGQgPSBzLmJhc2VsaW5lc1tsXTtcbiAgICAgICAgICAgIGlmIChkLmlkID09IGEuaWQpIHtcbiAgICAgICAgICAgICAgbyA9ICExLCB0Lm1peGluKGQsIGEsICEwKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIG8gJiYgcy5iYXNlbGluZXMucHVzaChhKSwgRih0KSB8fCAoJHQocykgPyBuKHMpIDogdC5hZGp1c3RUYXNrSGVpZ2h0Rm9yQmFzZWxpbmVzKHMpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSksIHQuYXR0YWNoRXZlbnQoXCJvbkJlZm9yZVRhc2tVcGRhdGVcIiwgZnVuY3Rpb24oYSwgcikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgbGV0IG8gPSAhMTtcbiAgICAgICAgY29uc3QgbCA9IHt9LCBkID0gcy5iYXNlbGluZXMgfHwgW10sIGMgPSB0LmdldFRhc2tCYXNlbGluZXMocy5pZCk7XG4gICAgICAgIGQubGVuZ3RoICE9IGMubGVuZ3RoICYmIChvID0gITApLCBkLmZvckVhY2goZnVuY3Rpb24odSkge1xuICAgICAgICAgIGxbdS5pZF0gPSAhMDtcbiAgICAgICAgICBjb25zdCBoID0gZS5nZXRJdGVtKHUuaWQpO1xuICAgICAgICAgIGlmIChoKSB7XG4gICAgICAgICAgICBjb25zdCBnID0gK2guc3RhcnRfZGF0ZSAhPSArdS5zdGFydF9kYXRlLCBwID0gK2guZW5kX2RhdGUgIT0gK3UuZW5kX2RhdGU7XG4gICAgICAgICAgICAoZyB8fCBwKSAmJiBlLnVwZGF0ZUl0ZW0odS5pZCwgdSk7XG4gICAgICAgICAgfSBlbHNlIGUuYWRkSXRlbSh1KTtcbiAgICAgICAgfSksIGMuZm9yRWFjaChmdW5jdGlvbih1KSB7XG4gICAgICAgICAgbFt1LmlkXSB8fCBlLnJlbW92ZUl0ZW0odS5pZCk7XG4gICAgICAgIH0pLCBvICYmICgkdChzKSA/IG4ocykgOiB0LmFkanVzdFRhc2tIZWlnaHRGb3JCYXNlbGluZXMocyksIHQucmVuZGVyKCkpO1xuICAgICAgfShyKSwgITA7XG4gICAgfSksIHQuYXR0YWNoRXZlbnQoXCJvbkFmdGVyVW5kb1wiLCBmdW5jdGlvbihhKSB7XG4gICAgICBpZiAoKHQuY29uZmlnLmJhc2VsaW5lcy5yZW5kZXJfbW9kZSA9PSBcInNlcGFyYXRlUm93XCIgfHwgdC5jb25maWcuYmFzZWxpbmVzLnJlbmRlcl9tb2RlID09IFwiaW5kaXZpZHVhbFJvd1wiKSAmJiBhKSB7XG4gICAgICAgIGxldCByID0gITE7XG4gICAgICAgIGEuY29tbWFuZHMuZm9yRWFjaChmdW5jdGlvbihzKSB7XG4gICAgICAgICAgaWYgKHMuZW50aXR5ID09IFwidGFza1wiKSB7XG4gICAgICAgICAgICBjb25zdCBvID0gcy52YWx1ZS5pZDtcbiAgICAgICAgICAgIGlmICh0LmlzVGFza0V4aXN0cyhvKSkge1xuICAgICAgICAgICAgICBjb25zdCBsID0gdC5nZXRUYXNrKG8pO1xuICAgICAgICAgICAgICBpZiAobC5wYXJlbnQgJiYgdC5pc1Rhc2tFeGlzdHMobC5wYXJlbnQpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZCA9IHQuZ2V0VGFzayhsLnBhcmVudCk7XG4gICAgICAgICAgICAgICAgJHQoZCkgJiYgKG4oZCksIHIgPSAhMCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pLCByICYmIHQucmVuZGVyKCk7XG4gICAgICB9XG4gICAgfSksIHQuYXR0YWNoRXZlbnQoXCJvbkFmdGVyVGFza0RlbGV0ZVwiLCBmdW5jdGlvbihhLCByKSB7XG4gICAgICBpZiAoaG4gJiYgci5wYXJlbnQgJiYgdC5pc1Rhc2tFeGlzdHMoci5wYXJlbnQpKSB7XG4gICAgICAgIGNvbnN0IHMgPSB0LmdldFRhc2soci5wYXJlbnQpO1xuICAgICAgICAkdChzKSAmJiBuKHMpO1xuICAgICAgfVxuICAgICAgZS5lYWNoSXRlbShmdW5jdGlvbihzKSB7XG4gICAgICAgIHQuaXNUYXNrRXhpc3RzKHMudGFza19pZCkgfHwgZS5yZW1vdmVJdGVtKHMuaWQpO1xuICAgICAgfSk7XG4gICAgfSksIHQuZ2V0VGFza0Jhc2VsaW5lcyA9IGZ1bmN0aW9uKGEpIHtcbiAgICAgIGNvbnN0IHIgPSBbXTtcbiAgICAgIHJldHVybiBlLmVhY2hJdGVtKGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgcy50YXNrX2lkID09IGEgJiYgci5wdXNoKHMpO1xuICAgICAgfSksIHI7XG4gICAgfSwgdC4kZGF0YS5iYXNlbGluZVN0b3JlLmF0dGFjaEV2ZW50KFwib25DbGVhckFsbFwiLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0LmVhY2hUYXNrKGZ1bmN0aW9uKGEpIHtcbiAgICAgICAgYS5iYXNlbGluZXMgJiYgZGVsZXRlIGEuYmFzZWxpbmVzO1xuICAgICAgfSksICEwO1xuICAgIH0pLCB0LiRkYXRhLnRhc2tzU3RvcmUuYXR0YWNoRXZlbnQoXCJvbkNsZWFyQWxsXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGUuY2xlYXJBbGwoKSwgITA7XG4gICAgfSksIHQuYXR0YWNoRXZlbnQoXCJvblRhc2tJZENoYW5nZVwiLCBmdW5jdGlvbihhLCByKSB7XG4gICAgICBlLmZpbmQoZnVuY3Rpb24ocykge1xuICAgICAgICByZXR1cm4gcy50YXNrX2lkID09IGE7XG4gICAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgcy50YXNrX2lkID0gciwgZS51cGRhdGVJdGVtKHMuaWQpO1xuICAgICAgfSk7XG4gICAgfSkpO1xuICB9LCB7IG9uY2U6ICEwIH0pO1xufVxuZnVuY3Rpb24gZmkodCkge1xuICBmdW5jdGlvbiBlKG4pIHtcbiAgICB0aHJvdyB0LmFzc2VydCghMSwgXCJDYW4ndCBwYXJzZSBkYXRhOiBpbmNvcnJlY3QgdmFsdWUgb2YgZ2FudHQucGFyc2Ugb3IgZ2FudHQubG9hZCBtZXRob2QuIEFjdHVhbCBhcmd1bWVudCB2YWx1ZTogXCIgKyBKU09OLnN0cmluZ2lmeShuKSksIG5ldyBFcnJvcihcIkludmFsaWQgYXJndW1lbnQgZm9yIGdhbnR0LnBhcnNlIG9yIGdhbnR0LmxvYWQuIEFuIG9iamVjdCBvciBhIEpTT04gc3RyaW5nIG9mIGZvcm1hdCBodHRwczovL2RvY3MuZGh0bWx4LmNvbS9nYW50dC9kZXNrdG9wX19zdXBwb3J0ZWRfZGF0YV9mb3JtYXRzLmh0bWwjanNvbiBpcyBleHBlY3RlZC4gQWN0dWFsIGFyZ3VtZW50IHZhbHVlOiBcIiArIEpTT04uc3RyaW5naWZ5KG4pKTtcbiAgfVxuICB0LmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJnYW50dC5sb2FkKCkgbWV0aG9kIGlzIG5vdCBhdmFpbGFibGUgaW4gdGhlIG5vZGUuanMsIHVzZSBnYW50dC5wYXJzZSgpIGluc3RlYWRcIik7XG4gIH0sIHQucGFyc2UgPSBmdW5jdGlvbihuLCBpKSB7XG4gICAgdGhpcy5vbl9sb2FkKHsgeG1sRG9jOiB7IHJlc3BvbnNlVGV4dDogbiB9IH0sIGkpO1xuICB9LCB0LnNlcmlhbGl6ZSA9IGZ1bmN0aW9uKG4pIHtcbiAgICByZXR1cm4gdGhpc1tuID0gbiB8fCBcImpzb25cIl0uc2VyaWFsaXplKCk7XG4gIH0sIHQub25fbG9hZCA9IGZ1bmN0aW9uKG4sIGkpIHtcbiAgICBpZiAobi54bWxEb2MgJiYgbi54bWxEb2Muc3RhdHVzID09PSA0MDQpIHRoaXMuYXNzZXJ0KCExLCBcIkZhaWxlZCB0byBsb2FkIHRoZSBkYXRhIGZyb20gPGEgaHJlZj0nXCIgKyBuLnhtbERvYy5yZXNwb25zZVVSTCArIFwiJyB0YXJnZXQ9J19ibGFuayc+XCIgKyBuLnhtbERvYy5yZXNwb25zZVVSTCArIFwiPC9hPiwgc2VydmVyIHJldHVybnMgNDA0XCIpO1xuICAgIGVsc2UgaWYgKCF0LiRkZXN0cm95ZWQpIHtcbiAgICAgIHRoaXMuY2FsbEV2ZW50KFwib25CZWZvcmVQYXJzZVwiLCBbXSksIGkgfHwgKGkgPSBcImpzb25cIiksIHRoaXMuYXNzZXJ0KHRoaXNbaV0sIFwiSW52YWxpZCBkYXRhIHR5cGU6J1wiICsgaSArIFwiJ1wiKTtcbiAgICAgIHZhciBhID0gbi54bWxEb2MucmVzcG9uc2VUZXh0LCByID0gdGhpc1tpXS5wYXJzZShhLCBuKTtcbiAgICAgIHRoaXMuX3Byb2Nlc3NfbG9hZGluZyhyKTtcbiAgICB9XG4gIH0sIHQuX3Byb2Nlc3NfbG9hZGluZyA9IGZ1bmN0aW9uKG4pIHtcbiAgICBuLmNvbGxlY3Rpb25zICYmIHRoaXMuX2xvYWRfY29sbGVjdGlvbnMobi5jb2xsZWN0aW9ucyksIG4ucmVzb3VyY2VzICYmIHRoaXMuJGRhdGEucmVzb3VyY2VzU3RvcmUgJiYgdGhpcy4kZGF0YS5yZXNvdXJjZXNTdG9yZS5wYXJzZShuLnJlc291cmNlcyksIHQuY29uZmlnLmJhc2VsaW5lcyAmJiBuLmJhc2VsaW5lcyAmJiB0aGlzLiRkYXRhLmJhc2VsaW5lU3RvcmUgJiYgdGhpcy4kZGF0YS5iYXNlbGluZVN0b3JlLnBhcnNlKG4uYmFzZWxpbmVzKTtcbiAgICBjb25zdCBpID0gbi5kYXRhIHx8IG4udGFza3M7XG4gICAgbi5hc3NpZ25tZW50cyAmJiBmdW5jdGlvbihyLCBzKSB7XG4gICAgICBjb25zdCBvID0ge307XG4gICAgICBzLmZvckVhY2goKGwpID0+IHtcbiAgICAgICAgb1tsLnRhc2tfaWRdIHx8IChvW2wudGFza19pZF0gPSBbXSksIG9bbC50YXNrX2lkXS5wdXNoKGwpO1xuICAgICAgfSksIHIuZm9yRWFjaCgobCkgPT4ge1xuICAgICAgICBsW3QuY29uZmlnLnJlc291cmNlX3Byb3BlcnR5XSA9IG9bbC5pZF0gfHwgW107XG4gICAgICB9KTtcbiAgICB9KGksIG4uYXNzaWdubWVudHMpLCB0aGlzLiRkYXRhLnRhc2tzU3RvcmUucGFyc2UoaSk7XG4gICAgdmFyIGEgPSBuLmxpbmtzIHx8IChuLmNvbGxlY3Rpb25zICYmIG4uY29sbGVjdGlvbnMubGlua3MgPyBuLmNvbGxlY3Rpb25zLmxpbmtzIDogW10pO1xuICAgIHRoaXMuJGRhdGEubGlua3NTdG9yZS5wYXJzZShhKSwgdGhpcy5jYWxsRXZlbnQoXCJvblBhcnNlXCIsIFtdKSwgdGhpcy5yZW5kZXIoKTtcbiAgfSwgdC5fbG9hZF9jb2xsZWN0aW9ucyA9IGZ1bmN0aW9uKG4pIHtcbiAgICB2YXIgaSA9ICExO1xuICAgIGZvciAodmFyIGEgaW4gbikgaWYgKG4uaGFzT3duUHJvcGVydHkoYSkpIHtcbiAgICAgIGkgPSAhMDtcbiAgICAgIHZhciByID0gblthXTtcbiAgICAgIHRoaXMuc2VydmVyTGlzdFthXSA9IHRoaXMuc2VydmVyTGlzdFthXSB8fCBbXTtcbiAgICAgIHZhciBzID0gdGhpcy5zZXJ2ZXJMaXN0W2FdO1xuICAgICAgaWYgKCFzKSBjb250aW51ZTtcbiAgICAgIHMuc3BsaWNlKDAsIHMubGVuZ3RoKTtcbiAgICAgIGZvciAodmFyIG8gPSAwOyBvIDwgci5sZW5ndGg7IG8rKykge1xuICAgICAgICB2YXIgbCA9IHJbb10sIGQgPSB0aGlzLmNvcHkobCk7XG4gICAgICAgIGZvciAodmFyIGMgaW4gZC5rZXkgPSBkLnZhbHVlLCBsKSBpZiAobC5oYXNPd25Qcm9wZXJ0eShjKSkge1xuICAgICAgICAgIGlmIChjID09IFwidmFsdWVcIiB8fCBjID09IFwibGFiZWxcIikgY29udGludWU7XG4gICAgICAgICAgZFtjXSA9IGxbY107XG4gICAgICAgIH1cbiAgICAgICAgcy5wdXNoKGQpO1xuICAgICAgfVxuICAgIH1cbiAgICBpICYmIHRoaXMuY2FsbEV2ZW50KFwib25PcHRpb25zTG9hZFwiLCBbXSk7XG4gIH0sIHQuYXR0YWNoRXZlbnQoXCJvbkJlZm9yZVRhc2tEaXNwbGF5XCIsIGZ1bmN0aW9uKG4sIGkpIHtcbiAgICByZXR1cm4gIWkuJGlnbm9yZTtcbiAgfSksIHQuanNvbiA9IHsgcGFyc2U6IGZ1bmN0aW9uKG4pIHtcbiAgICBpZiAobiB8fCBlKG4pLCB0eXBlb2YgbiA9PSBcInN0cmluZ1wiKSBpZiAodHlwZW9mIEpTT04gIT0gbnVsbCkgdHJ5IHtcbiAgICAgIG4gPSBKU09OLnBhcnNlKG4pO1xuICAgIH0gY2F0Y2gge1xuICAgICAgZShuKTtcbiAgICB9XG4gICAgZWxzZSB0LmFzc2VydCghMSwgXCJKU09OIGlzIG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgcmV0dXJuIG4uZGF0YSB8fCBuLnRhc2tzIHx8IGUobiksIG4uZGh4X3NlY3VyaXR5ICYmICh0LnNlY3VyaXR5X2tleSA9IG4uZGh4X3NlY3VyaXR5KSwgbjtcbiAgfSwgc2VyaWFsaXplVGFzazogZnVuY3Rpb24obikge1xuICAgIHJldHVybiB0aGlzLl9jb3B5T2JqZWN0KG4pO1xuICB9LCBzZXJpYWxpemVMaW5rOiBmdW5jdGlvbihuKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvcHlMaW5rKG4pO1xuICB9LCBfY29weUxpbms6IGZ1bmN0aW9uKG4pIHtcbiAgICB2YXIgaSA9IHt9O1xuICAgIGZvciAodmFyIGEgaW4gbikgaVthXSA9IG5bYV07XG4gICAgcmV0dXJuIGk7XG4gIH0sIF9jb3B5T2JqZWN0OiBmdW5jdGlvbihuKSB7XG4gICAgdmFyIGkgPSB7fTtcbiAgICBmb3IgKHZhciBhIGluIG4pIGEuY2hhckF0KDApICE9IFwiJFwiICYmIChpW2FdID0gblthXSwgWihpW2FdKSAmJiAoaVthXSA9IHQuZGVmaW5lZCh0LnRlbXBsYXRlcy54bWxfZm9ybWF0KSA/IHQudGVtcGxhdGVzLnhtbF9mb3JtYXQoaVthXSkgOiB0LnRlbXBsYXRlcy5mb3JtYXRfZGF0ZShpW2FdKSkpO1xuICAgIHJldHVybiBpO1xuICB9LCBzZXJpYWxpemU6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBuID0gW10sIGkgPSBbXTtcbiAgICBsZXQgYSA9IFtdO1xuICAgIHQuZWFjaFRhc2soZnVuY3Rpb24obykge1xuICAgICAgdC5yZXNldFByb2plY3REYXRlcyhvKSwgbi5wdXNoKHRoaXMuc2VyaWFsaXplVGFzayhvKSk7XG4gICAgfSwgdC5jb25maWcucm9vdF9pZCwgdGhpcyk7XG4gICAgZm9yICh2YXIgciA9IHQuZ2V0TGlua3MoKSwgcyA9IDA7IHMgPCByLmxlbmd0aDsgcysrKSBpLnB1c2godGhpcy5zZXJpYWxpemVMaW5rKHJbc10pKTtcbiAgICByZXR1cm4gdC5nZXREYXRhc3RvcmUoXCJiYXNlbGluZXNcIikuZWFjaEl0ZW0oZnVuY3Rpb24obykge1xuICAgICAgY29uc3QgbCA9IHQuanNvbi5zZXJpYWxpemVUYXNrKG8pO1xuICAgICAgYS5wdXNoKGwpO1xuICAgIH0pLCB7IGRhdGE6IG4sIGxpbmtzOiBpLCBiYXNlbGluZXM6IGEgfTtcbiAgfSB9LCB0LnhtbCA9IHsgX3htbE5vZGVUb0pTT046IGZ1bmN0aW9uKG4sIGkpIHtcbiAgICBmb3IgKHZhciBhID0ge30sIHIgPSAwOyByIDwgbi5hdHRyaWJ1dGVzLmxlbmd0aDsgcisrKSBhW24uYXR0cmlidXRlc1tyXS5uYW1lXSA9IG4uYXR0cmlidXRlc1tyXS52YWx1ZTtcbiAgICBpZiAoIWkpIHtcbiAgICAgIGZvciAociA9IDA7IHIgPCBuLmNoaWxkTm9kZXMubGVuZ3RoOyByKyspIHtcbiAgICAgICAgdmFyIHMgPSBuLmNoaWxkTm9kZXNbcl07XG4gICAgICAgIHMubm9kZVR5cGUgPT0gMSAmJiAoYVtzLnRhZ05hbWVdID0gcy5maXJzdENoaWxkID8gcy5maXJzdENoaWxkLm5vZGVWYWx1ZSA6IFwiXCIpO1xuICAgICAgfVxuICAgICAgYS50ZXh0IHx8IChhLnRleHQgPSBuLmZpcnN0Q2hpbGQgPyBuLmZpcnN0Q2hpbGQubm9kZVZhbHVlIDogXCJcIik7XG4gICAgfVxuICAgIHJldHVybiBhO1xuICB9LCBfZ2V0Q29sbGVjdGlvbnM6IGZ1bmN0aW9uKG4pIHtcbiAgICBmb3IgKHZhciBpID0ge30sIGEgPSB0LmFqYXgueHBhdGgoXCIvL2NvbGxfb3B0aW9uc1wiLCBuKSwgciA9IDA7IHIgPCBhLmxlbmd0aDsgcisrKSBmb3IgKHZhciBzID0gaVthW3JdLmdldEF0dHJpYnV0ZShcImZvclwiKV0gPSBbXSwgbyA9IHQuYWpheC54cGF0aChcIi4vL2l0ZW1cIiwgYVtyXSksIGwgPSAwOyBsIDwgby5sZW5ndGg7IGwrKykge1xuICAgICAgZm9yICh2YXIgZCA9IG9bbF0uYXR0cmlidXRlcywgYyA9IHsga2V5OiBvW2xdLmdldEF0dHJpYnV0ZShcInZhbHVlXCIpLCBsYWJlbDogb1tsXS5nZXRBdHRyaWJ1dGUoXCJsYWJlbFwiKSB9LCB1ID0gMDsgdSA8IGQubGVuZ3RoOyB1KyspIHtcbiAgICAgICAgdmFyIGggPSBkW3VdO1xuICAgICAgICBoLm5vZGVOYW1lICE9IFwidmFsdWVcIiAmJiBoLm5vZGVOYW1lICE9IFwibGFiZWxcIiAmJiAoY1toLm5vZGVOYW1lXSA9IGgubm9kZVZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHMucHVzaChjKTtcbiAgICB9XG4gICAgcmV0dXJuIGk7XG4gIH0sIF9nZXRYTUw6IGZ1bmN0aW9uKG4sIGksIGEpIHtcbiAgICBhID0gYSB8fCBcImRhdGFcIiwgaS5nZXRYTUxUb3BOb2RlIHx8IChpID0gdC5hamF4LnBhcnNlKGkpKTtcbiAgICB2YXIgciA9IHQuYWpheC54bWx0b3AoYSwgaS54bWxEb2MpO1xuICAgIHIgJiYgci50YWdOYW1lID09IGEgfHwgZnVuY3Rpb24obykge1xuICAgICAgdGhyb3cgdC5hc3NlcnQoITEsIFwiQ2FuJ3QgcGFyc2UgZGF0YTogaW5jb3JyZWN0IHZhbHVlIG9mIGdhbnR0LnBhcnNlIG9yIGdhbnR0LmxvYWQgbWV0aG9kLiBBY3R1YWwgYXJndW1lbnQgdmFsdWU6IFwiICsgSlNPTi5zdHJpbmdpZnkobykpLCBuZXcgRXJyb3IoXCJJbnZhbGlkIGFyZ3VtZW50IGZvciBnYW50dC5wYXJzZSBvciBnYW50dC5sb2FkLiBBbiBYTUwgb2YgZm9ybWF0IGh0dHBzOi8vZG9jcy5kaHRtbHguY29tL2dhbnR0L2Rlc2t0b3BfX3N1cHBvcnRlZF9kYXRhX2Zvcm1hdHMuaHRtbCN4bWxkaHRtbHhnYW50dDIwIGlzIGV4cGVjdGVkLiBBY3R1YWwgYXJndW1lbnQgdmFsdWU6IFwiICsgSlNPTi5zdHJpbmdpZnkobykpO1xuICAgIH0obik7XG4gICAgdmFyIHMgPSByLmdldEF0dHJpYnV0ZShcImRoeF9zZWN1cml0eVwiKTtcbiAgICByZXR1cm4gcyAmJiAodC5zZWN1cml0eV9rZXkgPSBzKSwgcjtcbiAgfSwgcGFyc2U6IGZ1bmN0aW9uKG4sIGkpIHtcbiAgICBpID0gdGhpcy5fZ2V0WE1MKG4sIGkpO1xuICAgIGZvciAodmFyIGEgPSB7fSwgciA9IGEuZGF0YSA9IFtdLCBzID0gdC5hamF4LnhwYXRoKFwiLy90YXNrXCIsIGkpLCBvID0gMDsgbyA8IHMubGVuZ3RoOyBvKyspIHJbb10gPSB0aGlzLl94bWxOb2RlVG9KU09OKHNbb10pO1xuICAgIHJldHVybiBhLmNvbGxlY3Rpb25zID0gdGhpcy5fZ2V0Q29sbGVjdGlvbnMoaSksIGE7XG4gIH0sIF9jb3B5TGluazogZnVuY3Rpb24obikge1xuICAgIHJldHVybiBcIjxpdGVtIGlkPSdcIiArIG4uaWQgKyBcIicgc291cmNlPSdcIiArIG4uc291cmNlICsgXCInIHRhcmdldD0nXCIgKyBuLnRhcmdldCArIFwiJyB0eXBlPSdcIiArIG4udHlwZSArIFwiJyAvPlwiO1xuICB9LCBfY29weU9iamVjdDogZnVuY3Rpb24obikge1xuICAgIHJldHVybiBcIjx0YXNrIGlkPSdcIiArIG4uaWQgKyBcIicgcGFyZW50PSdcIiArIChuLnBhcmVudCB8fCBcIlwiKSArIFwiJyBzdGFydF9kYXRlPSdcIiArIG4uc3RhcnRfZGF0ZSArIFwiJyBkdXJhdGlvbj0nXCIgKyBuLmR1cmF0aW9uICsgXCInIG9wZW49J1wiICsgISFuLm9wZW4gKyBcIicgcHJvZ3Jlc3M9J1wiICsgbi5wcm9ncmVzcyArIFwiJyBlbmRfZGF0ZT0nXCIgKyBuLmVuZF9kYXRlICsgXCInPjwhW0NEQVRBW1wiICsgbi50ZXh0ICsgXCJdXT48L3Rhc2s+XCI7XG4gIH0sIHNlcmlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgZm9yICh2YXIgbiA9IFtdLCBpID0gW10sIGEgPSB0Lmpzb24uc2VyaWFsaXplKCksIHIgPSAwLCBzID0gYS5kYXRhLmxlbmd0aDsgciA8IHM7IHIrKykgbi5wdXNoKHRoaXMuX2NvcHlPYmplY3QoYS5kYXRhW3JdKSk7XG4gICAgZm9yIChyID0gMCwgcyA9IGEubGlua3MubGVuZ3RoOyByIDwgczsgcisrKSBpLnB1c2godGhpcy5fY29weUxpbmsoYS5saW5rc1tyXSkpO1xuICAgIHJldHVybiBcIjxkYXRhPlwiICsgbi5qb2luKFwiXCIpICsgXCI8Y29sbF9vcHRpb25zIGZvcj0nbGlua3MnPlwiICsgaS5qb2luKFwiXCIpICsgXCI8L2NvbGxfb3B0aW9ucz48L2RhdGE+XCI7XG4gIH0gfSwgdC5vbGR4bWwgPSB7IHBhcnNlOiBmdW5jdGlvbihuLCBpKSB7XG4gICAgaSA9IHQueG1sLl9nZXRYTUwobiwgaSwgXCJwcm9qZWN0c1wiKTtcbiAgICBmb3IgKHZhciBhID0geyBjb2xsZWN0aW9uczogeyBsaW5rczogW10gfSB9LCByID0gYS5kYXRhID0gW10sIHMgPSB0LmFqYXgueHBhdGgoXCIvL3Rhc2tcIiwgaSksIG8gPSAwOyBvIDwgcy5sZW5ndGg7IG8rKykge1xuICAgICAgcltvXSA9IHQueG1sLl94bWxOb2RlVG9KU09OKHNbb10pO1xuICAgICAgdmFyIGwgPSBzW29dLnBhcmVudE5vZGU7XG4gICAgICBsLnRhZ05hbWUgPT0gXCJwcm9qZWN0XCIgPyByW29dLnBhcmVudCA9IFwicHJvamVjdC1cIiArIGwuZ2V0QXR0cmlidXRlKFwiaWRcIikgOiByW29dLnBhcmVudCA9IGwucGFyZW50Tm9kZS5nZXRBdHRyaWJ1dGUoXCJpZFwiKTtcbiAgICB9XG4gICAgZm9yIChzID0gdC5hamF4LnhwYXRoKFwiLy9wcm9qZWN0XCIsIGkpLCBvID0gMDsgbyA8IHMubGVuZ3RoOyBvKyspXG4gICAgICAoZCA9IHQueG1sLl94bWxOb2RlVG9KU09OKHNbb10sICEwKSkuaWQgPSBcInByb2plY3QtXCIgKyBkLmlkLCByLnB1c2goZCk7XG4gICAgZm9yIChvID0gMDsgbyA8IHIubGVuZ3RoOyBvKyspIHtcbiAgICAgIHZhciBkO1xuICAgICAgKGQgPSByW29dKS5zdGFydF9kYXRlID0gZC5zdGFydGRhdGUgfHwgZC5lc3QsIGQuZW5kX2RhdGUgPSBkLmVuZGRhdGUsIGQudGV4dCA9IGQubmFtZSwgZC5kdXJhdGlvbiA9IGQuZHVyYXRpb24gLyA4LCBkLm9wZW4gPSAxLCBkLmR1cmF0aW9uIHx8IGQuZW5kX2RhdGUgfHwgKGQuZHVyYXRpb24gPSAxKSwgZC5wcmVkZWNlc3NvcnRhc2tzICYmIGEuY29sbGVjdGlvbnMubGlua3MucHVzaCh7IHRhcmdldDogZC5pZCwgc291cmNlOiBkLnByZWRlY2Vzc29ydGFza3MsIHR5cGU6IHQuY29uZmlnLmxpbmtzLmZpbmlzaF90b19zdGFydCB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGE7XG4gIH0sIHNlcmlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgdC5tZXNzYWdlKFwiU2VyaWFsaXphdGlvbiB0byAnb2xkIFhNTCcgaXMgbm90IGltcGxlbWVudGVkXCIpO1xuICB9IH0sIHQuc2VydmVyTGlzdCA9IGZ1bmN0aW9uKG4sIGkpIHtcbiAgICByZXR1cm4gaSA/IHRoaXMuc2VydmVyTGlzdFtuXSA9IGkuc2xpY2UoMCkgOiB0aGlzLnNlcnZlckxpc3Rbbl0gfHwgKHRoaXMuc2VydmVyTGlzdFtuXSA9IFtdKSwgdGhpcy5zZXJ2ZXJMaXN0W25dO1xuICB9O1xufVxuZnVuY3Rpb24gYWUodCwgZSwgbiwgaSwgYSkge1xuICByZXR1cm4gdGhpcy5kYXRlID0gdCwgdGhpcy51bml0ID0gZSwgdGhpcy50YXNrID0gbiwgdGhpcy5pZCA9IGksIHRoaXMuY2FsZW5kYXIgPSBhLCB0aGlzO1xufVxuZnVuY3Rpb24gcmUodCwgZSwgbiwgaSwgYSwgcikge1xuICByZXR1cm4gdGhpcy5kYXRlID0gdCwgdGhpcy5kaXIgPSBlLCB0aGlzLnVuaXQgPSBuLCB0aGlzLnRhc2sgPSBpLCB0aGlzLmlkID0gYSwgdGhpcy5jYWxlbmRhciA9IHIsIHRoaXM7XG59XG5mdW5jdGlvbiBzZSh0LCBlLCBuLCBpLCBhLCByLCBzKSB7XG4gIHJldHVybiB0aGlzLnN0YXJ0X2RhdGUgPSB0LCB0aGlzLmR1cmF0aW9uID0gZSwgdGhpcy51bml0ID0gbiwgdGhpcy5zdGVwID0gaSwgdGhpcy50YXNrID0gYSwgdGhpcy5pZCA9IHIsIHRoaXMuY2FsZW5kYXIgPSBzLCB0aGlzO1xufVxuZnVuY3Rpb24gcGkodCwgZSwgbiwgaSkge1xuICByZXR1cm4gdGhpcy5zdGFydF9kYXRlID0gdCwgdGhpcy5lbmRfZGF0ZSA9IGUsIHRoaXMudGFzayA9IG4sIHRoaXMuY2FsZW5kYXIgPSBpLCB0aGlzLnVuaXQgPSBudWxsLCB0aGlzLnN0ZXAgPSBudWxsLCB0aGlzO1xufVxudmFyIF9uID0gZnVuY3Rpb24odCkge1xuICByZXR1cm4geyBnZXRXb3JrSG91cnNBcmd1bWVudHM6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBlID0gYXJndW1lbnRzWzBdO1xuICAgIGlmICghYnQoKGUgPSBaKGUpID8geyBkYXRlOiBlIH0gOiBQKHt9LCBlKSkuZGF0ZSkpIHRocm93IHQuYXNzZXJ0KCExLCBcIkludmFsaWQgZGF0ZSBhcmd1bWVudCBmb3IgZ2V0V29ya0hvdXJzIG1ldGhvZFwiKSwgbmV3IEVycm9yKFwiSW52YWxpZCBkYXRlIGFyZ3VtZW50IGZvciBnZXRXb3JrSG91cnMgbWV0aG9kXCIpO1xuICAgIHJldHVybiBlO1xuICB9LCBzZXRXb3JrVGltZUFyZ3VtZW50czogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50c1swXTtcbiAgfSwgdW5zZXRXb3JrVGltZUFyZ3VtZW50czogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50c1swXTtcbiAgfSwgaXNXb3JrVGltZUFyZ3VtZW50czogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGUsIG4gPSBhcmd1bWVudHNbMF07XG4gICAgaWYgKG4gaW5zdGFuY2VvZiBhZSkgcmV0dXJuIG47XG4gICAgaWYgKChlID0gbi5kYXRlID8gbmV3IGFlKG4uZGF0ZSwgbi51bml0LCBuLnRhc2ssIG51bGwsIG4uY2FsZW5kYXIpIDogbmV3IGFlKGFyZ3VtZW50c1swXSwgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0sIG51bGwsIGFyZ3VtZW50c1szXSkpLnVuaXQgPSBlLnVuaXQgfHwgdC5jb25maWcuZHVyYXRpb25fdW5pdCwgIWJ0KGUuZGF0ZSkpIHRocm93IHQuYXNzZXJ0KCExLCBcIkludmFsaWQgZGF0ZSBhcmd1bWVudCBmb3IgaXNXb3JrVGltZSBtZXRob2RcIiksIG5ldyBFcnJvcihcIkludmFsaWQgZGF0ZSBhcmd1bWVudCBmb3IgaXNXb3JrVGltZSBtZXRob2RcIik7XG4gICAgcmV0dXJuIGU7XG4gIH0sIGdldENsb3Nlc3RXb3JrVGltZUFyZ3VtZW50czogZnVuY3Rpb24oZSkge1xuICAgIHZhciBuLCBpID0gYXJndW1lbnRzWzBdO1xuICAgIGlmIChpIGluc3RhbmNlb2YgcmUpIHJldHVybiBpO1xuICAgIGlmIChuID0gWihpKSA/IG5ldyByZShpKSA6IG5ldyByZShpLmRhdGUsIGkuZGlyLCBpLnVuaXQsIGkudGFzaywgbnVsbCwgaS5jYWxlbmRhciksIGkuaWQgJiYgKG4udGFzayA9IGkpLCBuLmRpciA9IGkuZGlyIHx8IFwiYW55XCIsIG4udW5pdCA9IGkudW5pdCB8fCB0LmNvbmZpZy5kdXJhdGlvbl91bml0LCAhYnQobi5kYXRlKSkgdGhyb3cgdC5hc3NlcnQoITEsIFwiSW52YWxpZCBkYXRlIGFyZ3VtZW50IGZvciBnZXRDbG9zZXN0V29ya1RpbWUgbWV0aG9kXCIpLCBuZXcgRXJyb3IoXCJJbnZhbGlkIGRhdGUgYXJndW1lbnQgZm9yIGdldENsb3Nlc3RXb3JrVGltZSBtZXRob2RcIik7XG4gICAgcmV0dXJuIG47XG4gIH0sIF9nZXRTdGFydEVuZENvbmZpZzogZnVuY3Rpb24oZSkge1xuICAgIHZhciBuLCBpID0gcGk7XG4gICAgaWYgKGUgaW5zdGFuY2VvZiBpKSByZXR1cm4gZTtcbiAgICBpZiAoWihlKSA/IG4gPSBuZXcgaShhcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdLCBhcmd1bWVudHNbM10pIDogKG4gPSBuZXcgaShlLnN0YXJ0X2RhdGUsIGUuZW5kX2RhdGUsIGUudGFzayksIGUuaWQgIT09IG51bGwgJiYgZS5pZCAhPT0gdm9pZCAwICYmIChuLnRhc2sgPSBlKSksIG4udW5pdCA9IG4udW5pdCB8fCB0LmNvbmZpZy5kdXJhdGlvbl91bml0LCBuLnN0ZXAgPSBuLnN0ZXAgfHwgdC5jb25maWcuZHVyYXRpb25fc3RlcCwgbi5zdGFydF9kYXRlID0gbi5zdGFydF9kYXRlIHx8IG4uc3RhcnQgfHwgbi5kYXRlLCAhYnQobi5zdGFydF9kYXRlKSkgdGhyb3cgdC5hc3NlcnQoITEsIFwiSW52YWxpZCBzdGFydF9kYXRlIGFyZ3VtZW50IGZvciBnZXREdXJhdGlvbiBtZXRob2RcIiksIG5ldyBFcnJvcihcIkludmFsaWQgc3RhcnRfZGF0ZSBhcmd1bWVudCBmb3IgZ2V0RHVyYXRpb24gbWV0aG9kXCIpO1xuICAgIGlmICghYnQobi5lbmRfZGF0ZSkpIHRocm93IHQuYXNzZXJ0KCExLCBcIkludmFsaWQgZW5kX2RhdGUgYXJndW1lbnQgZm9yIGdldER1cmF0aW9uIG1ldGhvZFwiKSwgbmV3IEVycm9yKFwiSW52YWxpZCBlbmRfZGF0ZSBhcmd1bWVudCBmb3IgZ2V0RHVyYXRpb24gbWV0aG9kXCIpO1xuICAgIHJldHVybiBuO1xuICB9LCBnZXREdXJhdGlvbkFyZ3VtZW50czogZnVuY3Rpb24oZSwgbiwgaSwgYSkge1xuICAgIHJldHVybiB0aGlzLl9nZXRTdGFydEVuZENvbmZpZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9LCBoYXNEdXJhdGlvbkFyZ3VtZW50czogZnVuY3Rpb24oZSwgbiwgaSwgYSkge1xuICAgIHJldHVybiB0aGlzLl9nZXRTdGFydEVuZENvbmZpZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9LCBjYWxjdWxhdGVFbmREYXRlQXJndW1lbnRzOiBmdW5jdGlvbihlLCBuLCBpLCBhKSB7XG4gICAgdmFyIHIsIHMgPSBhcmd1bWVudHNbMF07XG4gICAgaWYgKHMgaW5zdGFuY2VvZiBzZSkgcmV0dXJuIHM7XG4gICAgaWYgKHIgPSBaKHMpID8gbmV3IHNlKGFyZ3VtZW50c1swXSwgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0sIHZvaWQgMCwgYXJndW1lbnRzWzNdLCB2b2lkIDAsIGFyZ3VtZW50c1s0XSkgOiBuZXcgc2Uocy5zdGFydF9kYXRlLCBzLmR1cmF0aW9uLCBzLnVuaXQsIHMuc3RlcCwgcy50YXNrLCBudWxsLCBzLmNhbGVuZGFyKSwgcy5pZCAhPT0gbnVsbCAmJiBzLmlkICE9PSB2b2lkIDAgJiYgKHIudGFzayA9IHMsIHIudW5pdCA9IG51bGwsIHIuc3RlcCA9IG51bGwpLCByLnVuaXQgPSByLnVuaXQgfHwgdC5jb25maWcuZHVyYXRpb25fdW5pdCwgci5zdGVwID0gci5zdGVwIHx8IHQuY29uZmlnLmR1cmF0aW9uX3N0ZXAsICFidChyLnN0YXJ0X2RhdGUpKSB0aHJvdyB0LmFzc2VydCghMSwgXCJJbnZhbGlkIHN0YXJ0X2RhdGUgYXJndW1lbnQgZm9yIGNhbGN1bGF0ZUVuZERhdGUgbWV0aG9kXCIpLCBuZXcgRXJyb3IoXCJJbnZhbGlkIHN0YXJ0X2RhdGUgYXJndW1lbnQgZm9yIGNhbGN1bGF0ZUVuZERhdGUgbWV0aG9kXCIpO1xuICAgIHJldHVybiByO1xuICB9IH07XG59O1xuZnVuY3Rpb24gZ24oKSB7XG59XG5nbi5wcm90b3R5cGUgPSB7IF9nZXRJbnRlcnZhbHM6IGZ1bmN0aW9uKHQpIHtcbiAgZm9yICh2YXIgZSA9IFtdLCBuID0gMDsgbiA8IHQubGVuZ3RoOyBuICs9IDIpIGUucHVzaCh7IHN0YXJ0OiB0W25dLCBlbmQ6IHRbbiArIDFdIH0pO1xuICByZXR1cm4gZTtcbn0sIF90b0hvdXJzQXJyYXk6IGZ1bmN0aW9uKHQpIHtcbiAgdmFyIGUgPSBbXTtcbiAgZnVuY3Rpb24gbihhKSB7XG4gICAgdmFyIHIsIHMgPSBNYXRoLmZsb29yKGEgLyAzNjAwKSwgbyA9IGEgLSA2MCAqIHMgKiA2MCwgbCA9IE1hdGguZmxvb3IobyAvIDYwKTtcbiAgICByZXR1cm4gcyArIFwiOlwiICsgKChyID0gU3RyaW5nKGwpKS5sZW5ndGggPCAyICYmIChyID0gXCIwXCIgKyByKSwgcik7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0Lmxlbmd0aDsgaSsrKSBlLnB1c2gobih0W2ldLnN0YXJ0KSArIFwiLVwiICsgbih0W2ldLmVuZCkpO1xuICByZXR1cm4gZTtcbn0sIF9pbnRlcnNlY3RIb3VyUmFuZ2VzOiBmdW5jdGlvbih0LCBlKSB7XG4gIHZhciBuID0gW10sIGkgPSB0Lmxlbmd0aCA+IGUubGVuZ3RoID8gdCA6IGUsIGEgPSB0ID09PSBpID8gZSA6IHQ7XG4gIGkgPSBpLnNsaWNlKCksIGEgPSBhLnNsaWNlKCksIG4gPSBbXTtcbiAgZm9yICh2YXIgciA9IDA7IHIgPCBpLmxlbmd0aDsgcisrKSBmb3IgKHZhciBzID0gaVtyXSwgbyA9IDA7IG8gPCBhLmxlbmd0aDsgbysrKSB7XG4gICAgdmFyIGwgPSBhW29dO1xuICAgIGwuc3RhcnQgPCBzLmVuZCAmJiBsLmVuZCA+IHMuc3RhcnQgJiYgKG4ucHVzaCh7IHN0YXJ0OiBNYXRoLm1heChzLnN0YXJ0LCBsLnN0YXJ0KSwgZW5kOiBNYXRoLm1pbihzLmVuZCwgbC5lbmQpIH0pLCBzLmVuZCA+IGwuZW5kICYmIChhLnNwbGljZShvLCAxKSwgby0tLCByLS0pKTtcbiAgfVxuICByZXR1cm4gbjtcbn0sIF9tZXJnZUFkamFjZW50SW50ZXJ2YWxzOiBmdW5jdGlvbih0KSB7XG4gIHZhciBlID0gdC5zbGljZSgpO1xuICBlLnNvcnQoZnVuY3Rpb24ociwgcykge1xuICAgIHJldHVybiByLnN0YXJ0IC0gcy5zdGFydDtcbiAgfSk7XG4gIGZvciAodmFyIG4gPSBlWzBdLCBpID0gMTsgaSA8IGUubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYSA9IGVbaV07XG4gICAgYS5zdGFydCA8PSBuLmVuZCA/IChhLmVuZCA+IG4uZW5kICYmIChuLmVuZCA9IGEuZW5kKSwgZS5zcGxpY2UoaSwgMSksIGktLSkgOiBuID0gYTtcbiAgfVxuICByZXR1cm4gZTtcbn0sIF9tZXJnZUhvdXJzQ29uZmlnOiBmdW5jdGlvbih0LCBlKSB7XG4gIHJldHVybiB0aGlzLl9tZXJnZUFkamFjZW50SW50ZXJ2YWxzKHRoaXMuX2ludGVyc2VjdEhvdXJSYW5nZXModCwgZSkpO1xufSwgbWVyZ2U6IGZ1bmN0aW9uKHQsIGUpIHtcbiAgdmFyIG4gPSBxKHQuZ2V0Q29uZmlnKCkucGFyc2VkKSwgaSA9IHEoZS5nZXRDb25maWcoKS5wYXJzZWQpLCBhID0geyBob3VyczogdGhpcy5fdG9Ib3Vyc0FycmF5KHRoaXMuX21lcmdlSG91cnNDb25maWcobi5ob3VycywgaS5ob3VycykpLCBkYXRlczoge30sIGN1c3RvbVdlZWtzOiB7fSB9O1xuICBjb25zdCByID0gKG8sIGwpID0+IHtcbiAgICBmb3IgKGxldCBkIGluIG8uZGF0ZXMpIHtcbiAgICAgIGNvbnN0IGMgPSBvLmRhdGVzW2RdO1xuICAgICAgK2QgPiAxZTMgJiYgKGEuZGF0ZXNbZF0gPSAhMSk7XG4gICAgICBmb3IgKGNvbnN0IHUgaW4gbC5kYXRlcykge1xuICAgICAgICBjb25zdCBoID0gbC5kYXRlc1t1XTtcbiAgICAgICAgaWYgKHUgPT0gZCAmJiAoYS5kYXRlc1tkXSA9ICEoIWMgfHwgIWgpKSwgQXJyYXkuaXNBcnJheShjKSkge1xuICAgICAgICAgIGNvbnN0IGcgPSBBcnJheS5pc0FycmF5KGgpID8gaCA6IGwuaG91cnM7XG4gICAgICAgICAgYS5kYXRlc1tkXSA9IHRoaXMuX3RvSG91cnNBcnJheSh0aGlzLl9tZXJnZUhvdXJzQ29uZmlnKGMsIGcpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgaWYgKHIobiwgaSksIHIoaSwgbiksIG4uY3VzdG9tV2Vla3MpIGZvciAodmFyIHMgaW4gbi5jdXN0b21XZWVrcykgYS5jdXN0b21XZWVrc1tzXSA9IG4uY3VzdG9tV2Vla3Nbc107XG4gIGlmIChpLmN1c3RvbVdlZWtzKSBmb3IgKHZhciBzIGluIGkuY3VzdG9tV2Vla3MpIGEuY3VzdG9tV2Vla3Nbc10gPSBpLmN1c3RvbVdlZWtzW3NdO1xuICByZXR1cm4gYTtcbn0gfTtcbmNsYXNzIG1pIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5jbGVhcigpO1xuICB9XG4gIGdldEl0ZW0oZSwgbiwgaSkge1xuICAgIGlmICh0aGlzLl9jYWNoZS5oYXMoZSkpIHtcbiAgICAgIGNvbnN0IGEgPSB0aGlzLl9jYWNoZS5nZXQoZSlbaS5nZXRGdWxsWWVhcigpXTtcbiAgICAgIGlmIChhICYmIGEuaGFzKG4pKSByZXR1cm4gYS5nZXQobik7XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuICBzZXRJdGVtKGUsIG4sIGksIGEpIHtcbiAgICBpZiAoIWUgfHwgIW4pIHJldHVybjtcbiAgICBjb25zdCByID0gdGhpcy5fY2FjaGUsIHMgPSBhLmdldEZ1bGxZZWFyKCk7XG4gICAgbGV0IG87XG4gICAgci5oYXMoZSkgPyBvID0gci5nZXQoZSkgOiAobyA9IFtdLCByLnNldChlLCBvKSk7XG4gICAgbGV0IGwgPSBvW3NdO1xuICAgIGwgfHwgKGwgPSBvW3NdID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSksIGwuc2V0KG4sIGkpO1xuICB9XG4gIGNsZWFyKCkge1xuICAgIHRoaXMuX2NhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgfVxufVxuY2xhc3Mgdmkge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmNsZWFyKCk7XG4gIH1cbiAgZ2V0SXRlbShlLCBuLCBpKSB7XG4gICAgY29uc3QgYSA9IHRoaXMuX2NhY2hlO1xuICAgIGlmIChhICYmIGFbZV0pIHtcbiAgICAgIGNvbnN0IHIgPSBhW2VdO1xuICAgICAgaWYgKHIgPT09IHZvaWQgMCkgcmV0dXJuIC0xO1xuICAgICAgY29uc3QgcyA9IHJbaS5nZXRGdWxsWWVhcigpXTtcbiAgICAgIGlmIChzICYmIHNbbl0gIT09IHZvaWQgMCkgcmV0dXJuIHNbbl07XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuICBzZXRJdGVtKGUsIG4sIGksIGEpIHtcbiAgICBpZiAoIWUgfHwgIW4pIHJldHVybjtcbiAgICBjb25zdCByID0gdGhpcy5fY2FjaGU7XG4gICAgaWYgKCFyKSByZXR1cm47XG4gICAgcltlXSB8fCAocltlXSA9IFtdKTtcbiAgICBjb25zdCBzID0gcltlXSwgbyA9IGEuZ2V0RnVsbFllYXIoKTtcbiAgICBsZXQgbCA9IHNbb107XG4gICAgbCB8fCAobCA9IHNbb10gPSB7fSksIGxbbl0gPSBpO1xuICB9XG4gIGNsZWFyKCkge1xuICAgIHRoaXMuX2NhY2hlID0ge307XG4gIH1cbn1cbmNsYXNzIGtpIHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHRoaXMuZ2V0TWludXRlc1BlcldlZWsgPSAobikgPT4ge1xuICAgICAgY29uc3QgaSA9IG4udmFsdWVPZigpO1xuICAgICAgaWYgKHRoaXMuX3dlZWtDYWNoZS5oYXMoaSkpIHJldHVybiB0aGlzLl93ZWVrQ2FjaGUuZ2V0KGkpO1xuICAgICAgY29uc3QgYSA9IHRoaXMuX2NhbGVuZGFyLCByID0gdGhpcy5fY2FsZW5kYXIuJGdhbnR0O1xuICAgICAgbGV0IHMgPSAwLCBvID0gci5kYXRlLndlZWtfc3RhcnQobmV3IERhdGUobikpO1xuICAgICAgZm9yIChsZXQgbCA9IDA7IGwgPCA3OyBsKyspIHMgKz0gNjAgKiBhLmdldEhvdXJzUGVyRGF5KG8pLCBvID0gci5kYXRlLmFkZChvLCAxLCBcImRheVwiKTtcbiAgICAgIHJldHVybiB0aGlzLl93ZWVrQ2FjaGUuc2V0KGksIHMpLCBzO1xuICAgIH0sIHRoaXMuZ2V0TWludXRlc1Blck1vbnRoID0gKG4pID0+IHtcbiAgICAgIGNvbnN0IGkgPSBuLnZhbHVlT2YoKTtcbiAgICAgIGlmICh0aGlzLl9tb250aENhY2hlLmhhcyhpKSkgcmV0dXJuIHRoaXMuX21vbnRoQ2FjaGUuZ2V0KGkpO1xuICAgICAgY29uc3QgYSA9IHRoaXMuX2NhbGVuZGFyLCByID0gdGhpcy5fY2FsZW5kYXIuJGdhbnR0O1xuICAgICAgbGV0IHMgPSAwLCBvID0gci5kYXRlLndlZWtfc3RhcnQobmV3IERhdGUobikpO1xuICAgICAgY29uc3QgbCA9IHIuZGF0ZS5hZGQobywgMSwgXCJtb250aFwiKS52YWx1ZU9mKCk7XG4gICAgICBmb3IgKDsgby52YWx1ZU9mKCkgPCBsOyApIHMgKz0gNjAgKiBhLmdldEhvdXJzUGVyRGF5KG8pLCBvID0gci5kYXRlLmFkZChvLCAxLCBcImRheVwiKTtcbiAgICAgIHJldHVybiB0aGlzLl9tb250aENhY2hlLnNldChpLCBzKSwgcztcbiAgICB9LCB0aGlzLmNsZWFyID0gKCkgPT4ge1xuICAgICAgdGhpcy5fd2Vla0NhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgdGhpcy5fbW9udGhDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgfSwgdGhpcy5jbGVhcigpLCB0aGlzLl9jYWxlbmRhciA9IGU7XG4gIH1cbn1cbmNsYXNzIHlpIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5jbGVhcigpO1xuICB9XG4gIF9nZXRDYWNoZU9iamVjdChlLCBuLCBpKSB7XG4gICAgY29uc3QgYSA9IHRoaXMuX2NhY2hlO1xuICAgIGFbbl0gfHwgKGFbbl0gPSBbXSk7XG4gICAgbGV0IHIgPSBhW25dO1xuICAgIHIgfHwgKHIgPSBhW25dID0ge30pO1xuICAgIGxldCBzID0gcltpXTtcbiAgICBzIHx8IChzID0gcltpXSA9IHt9KTtcbiAgICBjb25zdCBvID0gZS5nZXRGdWxsWWVhcigpO1xuICAgIGxldCBsID0gc1tvXTtcbiAgICByZXR1cm4gbCB8fCAobCA9IHNbb10gPSB7IGR1cmF0aW9uczoge30sIGVuZERhdGVzOiB7fSB9KSwgbDtcbiAgfVxuICBfZW5kRGF0ZUNhY2hlS2V5KGUsIG4pIHtcbiAgICByZXR1cm4gU3RyaW5nKGUpICsgXCItXCIgKyBTdHJpbmcobik7XG4gIH1cbiAgX2R1cmF0aW9uQ2FjaGVLZXkoZSwgbikge1xuICAgIHJldHVybiBTdHJpbmcoZSkgKyBcIi1cIiArIFN0cmluZyhuKTtcbiAgfVxuICBnZXRFbmREYXRlKGUsIG4sIGksIGEsIHIpIHtcbiAgICBjb25zdCBzID0gdGhpcy5fZ2V0Q2FjaGVPYmplY3QoZSwgaSwgYSksIG8gPSBlLnZhbHVlT2YoKSwgbCA9IHRoaXMuX2VuZERhdGVDYWNoZUtleShvLCBuKTtcbiAgICBsZXQgZDtcbiAgICBpZiAocy5lbmREYXRlc1tsXSA9PT0gdm9pZCAwKSB7XG4gICAgICBjb25zdCBjID0gcigpLCB1ID0gYy52YWx1ZU9mKCk7XG4gICAgICBzLmVuZERhdGVzW2xdID0gdSwgcy5kdXJhdGlvbnNbdGhpcy5fZHVyYXRpb25DYWNoZUtleShvLCB1KV0gPSBuLCBkID0gYztcbiAgICB9IGVsc2UgZCA9IG5ldyBEYXRlKHMuZW5kRGF0ZXNbbF0pO1xuICAgIHJldHVybiBkO1xuICB9XG4gIGdldER1cmF0aW9uKGUsIG4sIGksIGEsIHIpIHtcbiAgICBjb25zdCBzID0gdGhpcy5fZ2V0Q2FjaGVPYmplY3QoZSwgaSwgYSksIG8gPSBlLnZhbHVlT2YoKSwgbCA9IG4udmFsdWVPZigpLCBkID0gdGhpcy5fZHVyYXRpb25DYWNoZUtleShvLCBsKTtcbiAgICBsZXQgYztcbiAgICBpZiAocy5kdXJhdGlvbnNbZF0gPT09IHZvaWQgMCkge1xuICAgICAgY29uc3QgdSA9IHIoKTtcbiAgICAgIHMuZHVyYXRpb25zW2RdID0gdS52YWx1ZU9mKCksIGMgPSB1O1xuICAgIH0gZWxzZSBjID0gcy5kdXJhdGlvbnNbZF07XG4gICAgcmV0dXJuIGM7XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5fY2FjaGUgPSB7fTtcbiAgfVxufVxuZnVuY3Rpb24geWUodCwgZSkge1xuICB0aGlzLmFyZ3VtZW50c0hlbHBlciA9IGUsIHRoaXMuJGdhbnR0ID0gdCwgdGhpcy5fd29ya2luZ1VuaXRzQ2FjaGUgPSB0eXBlb2YgTWFwIDwgXCJ1XCIgPyBuZXcgbWkoKSA6IG5ldyB2aSgpLCB0aGlzLl9sYXJnZVVuaXRzQ2FjaGUgPSBuZXcga2kodGhpcyksIHRoaXMuX2RhdGVEdXJhdGlvbkNhY2hlID0gbmV3IHlpKCksIHRoaXMuX3dvcmt0aW1lID0gbnVsbCwgdGhpcy5fY2FjaGVkX3RpbWVzdGFtcHMgPSB7fSwgdGhpcy5fY2FjaGVkX3RpbWVzdGFtcHNfY291bnQgPSAwO1xufVxueWUucHJvdG90eXBlID0geyB1bml0czogW1wieWVhclwiLCBcIm1vbnRoXCIsIFwid2Vla1wiLCBcImRheVwiLCBcImhvdXJcIiwgXCJtaW51dGVcIl0sIF9jbGVhckNhY2hlczogZnVuY3Rpb24oKSB7XG4gIHRoaXMuX3dvcmtpbmdVbml0c0NhY2hlLmNsZWFyKCksIHRoaXMuX2xhcmdlVW5pdHNDYWNoZS5jbGVhcigpLCB0aGlzLl9kYXRlRHVyYXRpb25DYWNoZS5jbGVhcigpO1xufSwgX2dldFVuaXRPcmRlcjogZnVuY3Rpb24odCkge1xuICBmb3IgKHZhciBlID0gMCwgbiA9IHRoaXMudW5pdHMubGVuZ3RoOyBlIDwgbjsgZSsrKSBpZiAodGhpcy51bml0c1tlXSA9PSB0KSByZXR1cm4gZTtcbn0sIF9yZXNldFRpbWVzdGFtcENhY2hlOiBmdW5jdGlvbigpIHtcbiAgdGhpcy5fY2FjaGVkX3RpbWVzdGFtcHMgPSB7fSwgdGhpcy5fY2FjaGVkX3RpbWVzdGFtcHNfY291bnQgPSAwO1xufSwgX3RpbWVzdGFtcDogZnVuY3Rpb24odCkge1xuICB0aGlzLl9jYWNoZWRfdGltZXN0YW1wc19jb3VudCA+IDFlNiAmJiB0aGlzLl9yZXNldFRpbWVzdGFtcENhY2hlKCk7XG4gIHZhciBlID0gbnVsbDtcbiAgaWYgKHQuZGF5IHx8IHQuZGF5ID09PSAwKSBlID0gdC5kYXk7XG4gIGVsc2UgaWYgKHQuZGF0ZSkge1xuICAgIHZhciBuID0gU3RyaW5nKHQuZGF0ZS52YWx1ZU9mKCkpO1xuICAgIHRoaXMuX2NhY2hlZF90aW1lc3RhbXBzW25dID8gZSA9IHRoaXMuX2NhY2hlZF90aW1lc3RhbXBzW25dIDogKGUgPSBEYXRlLlVUQyh0LmRhdGUuZ2V0RnVsbFllYXIoKSwgdC5kYXRlLmdldE1vbnRoKCksIHQuZGF0ZS5nZXREYXRlKCkpLCB0aGlzLl9jYWNoZWRfdGltZXN0YW1wc1tuXSA9IGUsIHRoaXMuX2NhY2hlZF90aW1lc3RhbXBzX2NvdW50KyspO1xuICB9XG4gIHJldHVybiBlO1xufSwgX2NoZWNrSWZXb3JraW5nVW5pdDogZnVuY3Rpb24odCwgZSkge1xuICBpZiAoIXRoaXNbXCJfaXNfd29ya19cIiArIGVdKSB7XG4gICAgY29uc3QgbiA9IHRoaXMuJGdhbnR0LmRhdGVbYCR7ZX1fc3RhcnRgXShuZXcgRGF0ZSh0KSksIGkgPSB0aGlzLiRnYW50dC5kYXRlLmFkZChuLCAxLCBlKTtcbiAgICByZXR1cm4gdGhpcy5oYXNEdXJhdGlvbihuLCBpKTtcbiAgfVxuICByZXR1cm4gdGhpc1tcIl9pc193b3JrX1wiICsgZV0odCk7XG59LCBfaXNfd29ya19kYXk6IGZ1bmN0aW9uKHQpIHtcbiAgdmFyIGUgPSB0aGlzLl9nZXRXb3JrSG91cnModCk7XG4gIHJldHVybiAhIUFycmF5LmlzQXJyYXkoZSkgJiYgZS5sZW5ndGggPiAwO1xufSwgX2lzX3dvcmtfaG91cjogZnVuY3Rpb24odCkge1xuICBmb3IgKHZhciBlID0gdGhpcy5fZ2V0V29ya0hvdXJzKHQpLCBuID0gdC5nZXRIb3VycygpLCBpID0gMDsgaSA8IGUubGVuZ3RoOyBpKyspIGlmIChuID49IGVbaV0uc3RhcnRIb3VyICYmIG4gPCBlW2ldLmVuZEhvdXIpIHJldHVybiAhMDtcbiAgcmV0dXJuICExO1xufSwgX2dldFRpbWVPZkRheVN0YW1wOiBmdW5jdGlvbih0LCBlKSB7XG4gIHZhciBuID0gdC5nZXRIb3VycygpO1xuICByZXR1cm4gdC5nZXRIb3VycygpIHx8IHQuZ2V0TWludXRlcygpIHx8ICFlIHx8IChuID0gMjQpLCA2MCAqIG4gKiA2MCArIDYwICogdC5nZXRNaW51dGVzKCk7XG59LCBfaXNfd29ya19taW51dGU6IGZ1bmN0aW9uKHQpIHtcbiAgZm9yICh2YXIgZSA9IHRoaXMuX2dldFdvcmtIb3Vycyh0KSwgbiA9IHRoaXMuX2dldFRpbWVPZkRheVN0YW1wKHQpLCBpID0gMDsgaSA8IGUubGVuZ3RoOyBpKyspIGlmIChuID49IGVbaV0uc3RhcnQgJiYgbiA8IGVbaV0uZW5kKSByZXR1cm4gITA7XG4gIHJldHVybiAhMTtcbn0sIF9uZXh0RGF0ZTogZnVuY3Rpb24odCwgZSwgbikge1xuICByZXR1cm4gdGhpcy4kZ2FudHQuZGF0ZS5hZGQodCwgbiwgZSk7XG59LCBfZ2V0V29ya1VuaXRzQmV0d2VlbkdlbmVyaWM6IGZ1bmN0aW9uKHQsIGUsIG4sIGkpIHtcbiAgdmFyIGEgPSB0aGlzLiRnYW50dC5kYXRlLCByID0gbmV3IERhdGUodCksIHMgPSBuZXcgRGF0ZShlKTtcbiAgaSA9IGkgfHwgMTtcbiAgdmFyIG8sIGwsIGQgPSAwLCBjID0gbnVsbCwgdSA9ICExO1xuICAobyA9IGFbbiArIFwiX3N0YXJ0XCJdKG5ldyBEYXRlKHIpKSkudmFsdWVPZigpICE9IHIudmFsdWVPZigpICYmICh1ID0gITApO1xuICB2YXIgaCA9ICExO1xuICAobCA9IGFbbiArIFwiX3N0YXJ0XCJdKG5ldyBEYXRlKGUpKSkudmFsdWVPZigpICE9IGUudmFsdWVPZigpICYmIChoID0gITApO1xuICBmb3IgKHZhciBnID0gITE7IHIudmFsdWVPZigpIDwgcy52YWx1ZU9mKCk7ICkge1xuICAgIGlmIChnID0gKGMgPSB0aGlzLl9uZXh0RGF0ZShyLCBuLCBpKSkudmFsdWVPZigpID4gcy52YWx1ZU9mKCksIHRoaXMuX2lzV29ya1RpbWUociwgbikpICh1IHx8IGggJiYgZykgJiYgKG8gPSBhW24gKyBcIl9zdGFydFwiXShuZXcgRGF0ZShyKSksIGwgPSBhLmFkZChvLCBpLCBuKSksIHUgPyAodSA9ICExLCBjID0gdGhpcy5fbmV4dERhdGUobywgbiwgaSksIGQgKz0gKGwudmFsdWVPZigpIC0gci52YWx1ZU9mKCkpIC8gKGwudmFsdWVPZigpIC0gby52YWx1ZU9mKCkpKSA6IGggJiYgZyA/IChoID0gITEsIGQgKz0gKHMudmFsdWVPZigpIC0gci52YWx1ZU9mKCkpIC8gKGwudmFsdWVPZigpIC0gby52YWx1ZU9mKCkpKSA6IGQrKztcbiAgICBlbHNlIHtcbiAgICAgIHZhciBwID0gdGhpcy5fZ2V0VW5pdE9yZGVyKG4pLCB5ID0gdGhpcy51bml0c1twIC0gMV07XG4gICAgICB5ICYmICF0aGlzLl9pc1dvcmtUaW1lKHIsIHkpICYmIChjID0gdGhpcy5fZ2V0Q2xvc2VzdFdvcmtUaW1lRnV0dXJlKHIsIHkpKTtcbiAgICB9XG4gICAgciA9IGM7XG4gIH1cbiAgcmV0dXJuIGQ7XG59LCBfZ2V0TWludXRlc1BlckhvdXI6IGZ1bmN0aW9uKHQpIHtcbiAgdmFyIGUgPSB0aGlzLl9nZXRUaW1lT2ZEYXlTdGFtcCh0KSwgbiA9IHRoaXMuX2dldFRpbWVPZkRheVN0YW1wKHRoaXMuX25leHREYXRlKHQsIFwiaG91clwiLCAxKSk7XG4gIG4gPT09IDAgJiYgKG4gPSA4NjQwMCk7XG4gIGZvciAodmFyIGkgPSB0aGlzLl9nZXRXb3JrSG91cnModCksIGEgPSAwOyBhIDwgaS5sZW5ndGg7IGErKykge1xuICAgIHZhciByID0gaVthXTtcbiAgICBpZiAoZSA+PSByLnN0YXJ0ICYmIG4gPD0gci5lbmQpIHJldHVybiA2MDtcbiAgICBpZiAoZSA8IHIuZW5kICYmIG4gPiByLnN0YXJ0KSByZXR1cm4gKE1hdGgubWluKG4sIHIuZW5kKSAtIE1hdGgubWF4KGUsIHIuc3RhcnQpKSAvIDYwO1xuICB9XG4gIHJldHVybiAwO1xufSwgX2dldE1pbnV0ZXNQZXJEYXk6IGZ1bmN0aW9uKHQpIHtcbiAgdmFyIGUgPSB0aGlzLl9nZXRXb3JrSG91cnModCksIG4gPSAwO1xuICByZXR1cm4gZS5mb3JFYWNoKGZ1bmN0aW9uKGkpIHtcbiAgICBuICs9IGkuZHVyYXRpb25NaW51dGVzO1xuICB9KSwgbjtcbn0sIGdldEhvdXJzUGVyRGF5OiBmdW5jdGlvbih0KSB7XG4gIHZhciBlID0gdGhpcy5fZ2V0V29ya0hvdXJzKHQpLCBuID0gMDtcbiAgcmV0dXJuIGUuZm9yRWFjaChmdW5jdGlvbihpKSB7XG4gICAgbiArPSBpLmR1cmF0aW9uSG91cnM7XG4gIH0pLCBuO1xufSwgX2dldFdvcmtVbml0c0ZvclJhbmdlOiBmdW5jdGlvbih0LCBlLCBuLCBpKSB7XG4gIHZhciBhLCByID0gMCwgcyA9IG5ldyBEYXRlKHQpLCBvID0gbmV3IERhdGUoZSk7XG4gIGZvciAoYSA9IFIobiA9PSBcIm1pbnV0ZVwiID8gdGhpcy5fZ2V0TWludXRlc1BlckRheSA6IHRoaXMuZ2V0SG91cnNQZXJEYXksIHRoaXMpOyBzLnZhbHVlT2YoKSA8IG8udmFsdWVPZigpOyApIGlmIChvIC0gcyA+IDI3NjQ4ZTUgJiYgcy5nZXREYXRlKCkgPT09IDApIHtcbiAgICB2YXIgbCA9IHRoaXMuX2xhcmdlVW5pdHNDYWNoZS5nZXRNaW51dGVzUGVyTW9udGgocyk7XG4gICAgbiA9PSBcImhvdXJcIiAmJiAobCAvPSA2MCksIHIgKz0gbCwgcyA9IHRoaXMuJGdhbnR0LmRhdGUuYWRkKHMsIDEsIFwibW9udGhcIik7XG4gIH0gZWxzZSB7XG4gICAgaWYgKG8gLSBzID4gMTM4MjRlNSkge1xuICAgICAgdmFyIGQgPSB0aGlzLiRnYW50dC5kYXRlLndlZWtfc3RhcnQobmV3IERhdGUocykpO1xuICAgICAgaWYgKHMudmFsdWVPZigpID09PSBkLnZhbHVlT2YoKSkge1xuICAgICAgICBsID0gdGhpcy5fbGFyZ2VVbml0c0NhY2hlLmdldE1pbnV0ZXNQZXJXZWVrKHMpLCBuID09IFwiaG91clwiICYmIChsIC89IDYwKSwgciArPSBsLCBzID0gdGhpcy4kZ2FudHQuZGF0ZS5hZGQocywgNywgXCJkYXlcIik7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByICs9IGEocyksIHMgPSB0aGlzLl9uZXh0RGF0ZShzLCBcImRheVwiLCAxKTtcbiAgfVxuICByZXR1cm4gciAvIGk7XG59LCBfZ2V0TWludXRlc0JldHdlZW5TaW5nbGVEYXk6IGZ1bmN0aW9uKHQsIGUpIHtcbiAgZm9yICh2YXIgbiA9IHRoaXMuX2dldEludGVydmFsVGltZXN0YW1wKHQsIGUpLCBpID0gdGhpcy5fZ2V0V29ya0hvdXJzKHQpLCBhID0gMCwgciA9IDA7IHIgPCBpLmxlbmd0aDsgcisrKSB7XG4gICAgdmFyIHMgPSBpW3JdO1xuICAgIGlmIChuLmVuZCA+PSBzLnN0YXJ0ICYmIG4uc3RhcnQgPD0gcy5lbmQpIHtcbiAgICAgIHZhciBvID0gTWF0aC5tYXgocy5zdGFydCwgbi5zdGFydCksIGwgPSBNYXRoLm1pbihzLmVuZCwgbi5lbmQpO1xuICAgICAgYSArPSAobCAtIG8pIC8gNjAsIG4uc3RhcnQgPSBsO1xuICAgIH1cbiAgfVxuICByZXR1cm4gTWF0aC5mbG9vcihhKTtcbn0sIF9nZXRNaW51dGVzQmV0d2VlbjogZnVuY3Rpb24odCwgZSwgbiwgaSkge1xuICB2YXIgYSA9IG5ldyBEYXRlKHQpLCByID0gbmV3IERhdGUoZSk7XG4gIGkgPSBpIHx8IDE7XG4gIHZhciBzID0gbmV3IERhdGUoYSksIG8gPSB0aGlzLiRnYW50dC5kYXRlLmFkZCh0aGlzLiRnYW50dC5kYXRlLmRheV9zdGFydChuZXcgRGF0ZShhKSksIDEsIFwiZGF5XCIpO1xuICBpZiAoci52YWx1ZU9mKCkgPD0gby52YWx1ZU9mKCkpIHJldHVybiB0aGlzLl9nZXRNaW51dGVzQmV0d2VlblNpbmdsZURheSh0LCBlKTtcbiAgdmFyIGwgPSB0aGlzLiRnYW50dC5kYXRlLmRheV9zdGFydChuZXcgRGF0ZShyKSksIGQgPSByLCBjID0gdGhpcy5fZ2V0TWludXRlc0JldHdlZW5TaW5nbGVEYXkocywgbyksIHUgPSB0aGlzLl9nZXRNaW51dGVzQmV0d2VlblNpbmdsZURheShsLCBkKTtcbiAgcmV0dXJuIGMgKyB0aGlzLl9nZXRXb3JrVW5pdHNGb3JSYW5nZShvLCBsLCBuLCBpKSArIHU7XG59LCBfZ2V0SG91cnNCZXR3ZWVuOiBmdW5jdGlvbih0LCBlLCBuLCBpKSB7XG4gIHZhciBhID0gbmV3IERhdGUodCksIHIgPSBuZXcgRGF0ZShlKTtcbiAgaSA9IGkgfHwgMTtcbiAgdmFyIHMgPSBuZXcgRGF0ZShhKSwgbyA9IHRoaXMuJGdhbnR0LmRhdGUuYWRkKHRoaXMuJGdhbnR0LmRhdGUuZGF5X3N0YXJ0KG5ldyBEYXRlKGEpKSwgMSwgXCJkYXlcIik7XG4gIGlmIChyLnZhbHVlT2YoKSA8PSBvLnZhbHVlT2YoKSkgcmV0dXJuIE1hdGgucm91bmQodGhpcy5fZ2V0TWludXRlc0JldHdlZW5TaW5nbGVEYXkodCwgZSkgLyA2MCk7XG4gIHZhciBsID0gdGhpcy4kZ2FudHQuZGF0ZS5kYXlfc3RhcnQobmV3IERhdGUocikpLCBkID0gciwgYyA9IHRoaXMuX2dldE1pbnV0ZXNCZXR3ZWVuU2luZ2xlRGF5KHMsIG8sIG4sIGkpIC8gNjAsIHUgPSB0aGlzLl9nZXRNaW51dGVzQmV0d2VlblNpbmdsZURheShsLCBkLCBuLCBpKSAvIDYwLCBoID0gYyArIHRoaXMuX2dldFdvcmtVbml0c0ZvclJhbmdlKG8sIGwsIG4sIGkpICsgdTtcbiAgcmV0dXJuIE1hdGgucm91bmQoaCk7XG59LCBnZXRDb25maWc6IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fd29ya3RpbWU7XG59LCBfc2V0Q29uZmlnOiBmdW5jdGlvbih0KSB7XG4gIHRoaXMuX3dvcmt0aW1lID0gdCwgdGhpcy5fcGFyc2VTZXR0aW5ncygpLCB0aGlzLl9jbGVhckNhY2hlcygpO1xufSwgX3BhcnNlU2V0dGluZ3M6IGZ1bmN0aW9uKCkge1xuICB2YXIgdCA9IHRoaXMuZ2V0Q29uZmlnKCk7XG4gIGZvciAodmFyIGUgaW4gdC5wYXJzZWQgPSB7IGRhdGVzOiB7fSwgaG91cnM6IG51bGwsIGhhdmVDdXN0b21XZWVrczogITEsIGN1c3RvbVdlZWtzOiB7fSwgY3VzdG9tV2Vla3NSYW5nZVN0YXJ0OiBudWxsLCBjdXN0b21XZWVrc1JhbmdlRW5kOiBudWxsLCBjdXN0b21XZWVrc0JvdW5kYXJpZXM6IFtdIH0sIHQucGFyc2VkLmhvdXJzID0gdGhpcy5fcGFyc2VIb3Vycyh0LmhvdXJzKSwgdC5kYXRlcykgdC5wYXJzZWQuZGF0ZXNbZV0gPSB0aGlzLl9wYXJzZUhvdXJzKHQuZGF0ZXNbZV0pO1xuICBpZiAodC5jdXN0b21XZWVrcykge1xuICAgIHZhciBuID0gbnVsbCwgaSA9IG51bGw7XG4gICAgZm9yICh2YXIgZSBpbiB0LmN1c3RvbVdlZWtzKSB7XG4gICAgICB2YXIgYSA9IHQuY3VzdG9tV2Vla3NbZV07XG4gICAgICBpZiAoYS5mcm9tICYmIGEudG8pIHtcbiAgICAgICAgdmFyIHIgPSBhLmZyb20sIHMgPSBhLnRvO1xuICAgICAgICAoIW4gfHwgbiA+IHIudmFsdWVPZigpKSAmJiAobiA9IHIudmFsdWVPZigpKSwgKCFpIHx8IGkgPCBzLnZhbHVlT2YoKSkgJiYgKGkgPSBzLnZhbHVlT2YoKSksIHQucGFyc2VkLmN1c3RvbVdlZWtzQm91bmRhcmllcy5wdXNoKHsgZnJvbTogci52YWx1ZU9mKCksIGZyb21SZWFkYWJsZTogbmV3IERhdGUociksIHRvOiBzLnZhbHVlT2YoKSwgdG9SZWFkYWJsZTogbmV3IERhdGUocyksIG5hbWU6IGUgfSksIHQucGFyc2VkLmhhdmVDdXN0b21XZWVrcyA9ICEwO1xuICAgICAgICB2YXIgbyA9IHQucGFyc2VkLmN1c3RvbVdlZWtzW2VdID0geyBmcm9tOiBhLmZyb20sIHRvOiBhLnRvLCBob3VyczogdGhpcy5fcGFyc2VIb3VycyhhLmhvdXJzKSwgZGF0ZXM6IHt9IH07XG4gICAgICAgIGZvciAodmFyIGwgaW4gYS5kYXRlcykgby5kYXRlc1tsXSA9IHRoaXMuX3BhcnNlSG91cnMoYS5kYXRlc1tsXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHQucGFyc2VkLmN1c3RvbVdlZWtzUmFuZ2VTdGFydCA9IG4sIHQucGFyc2VkLmN1c3RvbVdlZWtzUmFuZ2VFbmQgPSBpO1xuICB9XG59LCBfdHJ5Q2hhbmdlQ2FsZW5kYXJTZXR0aW5nczogZnVuY3Rpb24odCkge1xuICB2YXIgZSA9IEpTT04uc3RyaW5naWZ5KHRoaXMuZ2V0Q29uZmlnKCkpO1xuICByZXR1cm4gdCgpLCAhIXRoaXMuaGFzV29ya1RpbWUoKSB8fCAodGhpcy5fc2V0Q29uZmlnKEpTT04ucGFyc2UoZSkpLCB0aGlzLl9jbGVhckNhY2hlcygpLCAhMSk7XG59LCBfYXJyYXlzRXF1YWw6IGZ1bmN0aW9uKHQsIGUpIHtcbiAgaWYgKHQgPT09IGUpIHJldHVybiAhMDtcbiAgaWYgKCF0IHx8ICFlIHx8IHQubGVuZ3RoICE9IGUubGVuZ3RoKSByZXR1cm4gITE7XG4gIGZvciAodmFyIG4gPSAwOyBuIDwgdC5sZW5ndGg7ICsrbikgaWYgKHRbbl0gIT09IGVbbl0pIHJldHVybiAhMTtcbiAgcmV0dXJuICEwO1xufSwgX2NvbXBhcmVTZXR0aW5nczogZnVuY3Rpb24odCwgZSkge1xuICBpZiAoIXRoaXMuX2FycmF5c0VxdWFsKHQuaG91cnMsIGUuaG91cnMpKSByZXR1cm4gITE7XG4gIHZhciBuID0gT2JqZWN0LmtleXModC5kYXRlcyksIGkgPSBPYmplY3Qua2V5cyhlLmRhdGVzKTtcbiAgaWYgKG4uc29ydCgpLCBpLnNvcnQoKSwgIXRoaXMuX2FycmF5c0VxdWFsKG4sIGkpKSByZXR1cm4gITE7XG4gIGZvciAodmFyIGEgPSAwOyBhIDwgbi5sZW5ndGg7IGErKykge1xuICAgIHZhciByID0gblthXSwgcyA9IHQuZGF0ZXNbcl0sIG8gPSB0LmRhdGVzW3JdO1xuICAgIGlmIChzICE9PSBvICYmICEoQXJyYXkuaXNBcnJheShzKSAmJiBBcnJheS5pc0FycmF5KG8pICYmIHRoaXMuX2FycmF5c0VxdWFsKHMsIG8pKSkgcmV0dXJuICExO1xuICB9XG4gIHJldHVybiAhMDtcbn0sIGVxdWFsczogZnVuY3Rpb24odCkge1xuICBpZiAoISh0IGluc3RhbmNlb2YgeWUpKSByZXR1cm4gITE7XG4gIHZhciBlID0gdGhpcy5nZXRDb25maWcoKSwgbiA9IHQuZ2V0Q29uZmlnKCk7XG4gIGlmICghdGhpcy5fY29tcGFyZVNldHRpbmdzKGUsIG4pKSByZXR1cm4gITE7XG4gIGlmIChlLnBhcnNlZC5oYXZlQ3VzdG9tV2Vla3MgJiYgbi5wYXJzZWQuaGF2ZUN1c3RvbVdlZWtzKSB7XG4gICAgaWYgKGUucGFyc2VkLmN1c3RvbVdlZWtzQm91bmRhcmllcy5sZW5ndGggIT0gbi5wYXJzZWQuY3VzdG9tV2Vla3NCb3VuZGFyaWVzLmxlbmd0aCkgcmV0dXJuICExO1xuICAgIGZvciAodmFyIGkgaW4gZS5wYXJzZWQuY3VzdG9tV2Vla3MpIHtcbiAgICAgIHZhciBhID0gZS5wYXJzZWQuY3VzdG9tV2Vla3NbaV0sIHIgPSBuLnBhcnNlZC5jdXN0b21XZWVrc1tpXTtcbiAgICAgIGlmICghciB8fCAhdGhpcy5fY29tcGFyZVNldHRpbmdzKGEsIHIpKSByZXR1cm4gITE7XG4gICAgfVxuICB9IGVsc2UgaWYgKGUucGFyc2UuaGF2ZUN1c3RvbVdlZWtzICE9PSBuLnBhcnNlZC5oYXZlQ3VzdG9tV2Vla3MpIHJldHVybiAhMTtcbiAgcmV0dXJuICEwO1xufSwgZ2V0V29ya0hvdXJzOiBmdW5jdGlvbigpIHtcbiAgdmFyIHQgPSB0aGlzLmFyZ3VtZW50c0hlbHBlci5nZXRXb3JrSG91cnNBcmd1bWVudHMuYXBwbHkodGhpcy5hcmd1bWVudHNIZWxwZXIsIGFyZ3VtZW50cyk7XG4gIHJldHVybiB0aGlzLl9nZXRXb3JrSG91cnModC5kYXRlLCAhMSk7XG59LCBfZ2V0V29ya0hvdXJzOiBmdW5jdGlvbih0LCBlKSB7XG4gIHZhciBuID0gdGhpcy5nZXRDb25maWcoKTtcbiAgaWYgKGUgIT09ICExICYmIChuID0gbi5wYXJzZWQpLCAhdCkgcmV0dXJuIG4uaG91cnM7XG4gIHZhciBpID0gdGhpcy5fdGltZXN0YW1wKHsgZGF0ZTogdCB9KTtcbiAgaWYgKG4uaGF2ZUN1c3RvbVdlZWtzICYmIG4uY3VzdG9tV2Vla3NSYW5nZVN0YXJ0IDw9IGkgJiYgbi5jdXN0b21XZWVrc1JhbmdlRW5kID4gaSkge1xuICAgIGZvciAodmFyIGEgPSAwOyBhIDwgbi5jdXN0b21XZWVrc0JvdW5kYXJpZXMubGVuZ3RoOyBhKyspIGlmIChuLmN1c3RvbVdlZWtzQm91bmRhcmllc1thXS5mcm9tIDw9IGkgJiYgbi5jdXN0b21XZWVrc0JvdW5kYXJpZXNbYV0udG8gPiBpKSB7XG4gICAgICBuID0gbi5jdXN0b21XZWVrc1tuLmN1c3RvbVdlZWtzQm91bmRhcmllc1thXS5uYW1lXTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICB2YXIgciA9ICEwO1xuICByZXR1cm4gbi5kYXRlc1tpXSAhPT0gdm9pZCAwID8gciA9IG4uZGF0ZXNbaV0gOiBuLmRhdGVzW3QuZ2V0RGF5KCldICE9PSB2b2lkIDAgJiYgKHIgPSBuLmRhdGVzW3QuZ2V0RGF5KCldKSwgciA9PT0gITAgPyBuLmhvdXJzIDogciB8fCBbXTtcbn0sIF9nZXRJbnRlcnZhbFRpbWVzdGFtcDogZnVuY3Rpb24odCwgZSkge1xuICB2YXIgbiA9IHsgc3RhcnQ6IDAsIGVuZDogMCB9O1xuICBuLnN0YXJ0ID0gNjAgKiB0LmdldEhvdXJzKCkgKiA2MCArIDYwICogdC5nZXRNaW51dGVzKCkgKyB0LmdldFNlY29uZHMoKTtcbiAgdmFyIGkgPSBlLmdldEhvdXJzKCk7XG4gIHJldHVybiAhaSAmJiAhZS5nZXRNaW51dGVzKCkgJiYgIWUuZ2V0U2Vjb25kcygpICYmIHQudmFsdWVPZigpIDwgZS52YWx1ZU9mKCkgJiYgKGkgPSAyNCksIG4uZW5kID0gNjAgKiBpICogNjAgKyA2MCAqIGUuZ2V0TWludXRlcygpICsgZS5nZXRTZWNvbmRzKCksIG47XG59LCBfcGFyc2VIb3VyczogZnVuY3Rpb24odCkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh0KSkge1xuICAgIHZhciBlID0gW107XG4gICAgdC5mb3JFYWNoKGZ1bmN0aW9uKG8pIHtcbiAgICAgIHR5cGVvZiBvID09IFwibnVtYmVyXCIgPyBlLnB1c2goNjAgKiBvICogNjApIDogdHlwZW9mIG8gPT0gXCJzdHJpbmdcIiAmJiBvLnNwbGl0KFwiLVwiKS5tYXAoZnVuY3Rpb24obCkge1xuICAgICAgICByZXR1cm4gbC50cmltKCk7XG4gICAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uKGwpIHtcbiAgICAgICAgdmFyIGQgPSBsLnNwbGl0KFwiOlwiKS5tYXAoZnVuY3Rpb24odSkge1xuICAgICAgICAgIHJldHVybiB1LnRyaW0oKTtcbiAgICAgICAgfSksIGMgPSBwYXJzZUludCg2MCAqIGRbMF0gKiA2MCk7XG4gICAgICAgIGRbMV0gJiYgKGMgKz0gcGFyc2VJbnQoNjAgKiBkWzFdKSksIGRbMl0gJiYgKGMgKz0gcGFyc2VJbnQoZFsyXSkpLCBlLnB1c2goYyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBmb3IgKHZhciBuID0gW10sIGkgPSAwOyBpIDwgZS5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgdmFyIGEgPSBlW2ldLCByID0gZVtpICsgMV0sIHMgPSByIC0gYTtcbiAgICAgIG4ucHVzaCh7IHN0YXJ0OiBhLCBlbmQ6IHIsIHN0YXJ0SG91cjogTWF0aC5mbG9vcihhIC8gMzYwMCksIHN0YXJ0TWludXRlOiBNYXRoLmZsb29yKGEgLyA2MCksIGVuZEhvdXI6IE1hdGguY2VpbChyIC8gMzYwMCksIGVuZE1pbnV0ZTogTWF0aC5jZWlsKHIgLyA2MCksIGR1cmF0aW9uU2Vjb25kczogcywgZHVyYXRpb25NaW51dGVzOiBzIC8gNjAsIGR1cmF0aW9uSG91cnM6IHMgLyAzNjAwIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbjtcbiAgfVxuICByZXR1cm4gdDtcbn0sIHNldFdvcmtUaW1lOiBmdW5jdGlvbih0KSB7XG4gIHJldHVybiB0aGlzLl90cnlDaGFuZ2VDYWxlbmRhclNldHRpbmdzKFIoZnVuY3Rpb24oKSB7XG4gICAgdmFyIGUgPSB0LmhvdXJzID09PSB2b2lkIDAgfHwgdC5ob3VycywgbiA9IHRoaXMuX3RpbWVzdGFtcCh0KSwgaSA9IHRoaXMuZ2V0Q29uZmlnKCk7XG4gICAgaWYgKG4gIT09IG51bGwgPyBpLmRhdGVzW25dID0gZSA6IHQuY3VzdG9tV2Vla3MgfHwgKGkuaG91cnMgPSBlKSwgdC5jdXN0b21XZWVrcykge1xuICAgICAgaWYgKGkuY3VzdG9tV2Vla3MgfHwgKGkuY3VzdG9tV2Vla3MgPSB7fSksIHR5cGVvZiB0LmN1c3RvbVdlZWtzID09IFwic3RyaW5nXCIpIG4gIT09IG51bGwgPyBpLmN1c3RvbVdlZWtzW3QuY3VzdG9tV2Vla3NdLmRhdGVzW25dID0gZSA6IHQuY3VzdG9tV2Vla3MgfHwgKGkuY3VzdG9tV2Vla3NbdC5jdXN0b21XZWVrc10uaG91cnMgPSBlKTtcbiAgICAgIGVsc2UgaWYgKHR5cGVvZiB0LmN1c3RvbVdlZWtzID09IFwib2JqZWN0XCIgJiYgRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodC5jdXN0b21XZWVrcy5jb25zdHJ1Y3RvcikgPT09IFwiZnVuY3Rpb24gT2JqZWN0KCkgeyBbbmF0aXZlIGNvZGVdIH1cIikgZm9yICh2YXIgYSBpbiB0LmN1c3RvbVdlZWtzKSBpLmN1c3RvbVdlZWtzW2FdID0gdC5jdXN0b21XZWVrc1thXTtcbiAgICB9XG4gICAgdGhpcy5fcGFyc2VTZXR0aW5ncygpLCB0aGlzLl9jbGVhckNhY2hlcygpO1xuICB9LCB0aGlzKSk7XG59LCB1bnNldFdvcmtUaW1lOiBmdW5jdGlvbih0KSB7XG4gIHJldHVybiB0aGlzLl90cnlDaGFuZ2VDYWxlbmRhclNldHRpbmdzKFIoZnVuY3Rpb24oKSB7XG4gICAgaWYgKHQpIHtcbiAgICAgIHZhciBlID0gdGhpcy5fdGltZXN0YW1wKHQpO1xuICAgICAgZSAhPT0gbnVsbCAmJiBkZWxldGUgdGhpcy5nZXRDb25maWcoKS5kYXRlc1tlXTtcbiAgICB9IGVsc2UgdGhpcy5yZXNldF9jYWxlbmRhcigpO1xuICAgIHRoaXMuX3BhcnNlU2V0dGluZ3MoKSwgdGhpcy5fY2xlYXJDYWNoZXMoKTtcbiAgfSwgdGhpcykpO1xufSwgX2lzV29ya1RpbWU6IGZ1bmN0aW9uKHQsIGUpIHtcbiAgdmFyIG4sIGkgPSAtMTtcbiAgcmV0dXJuIG4gPSBTdHJpbmcodC52YWx1ZU9mKCkpLCAoaSA9IHRoaXMuX3dvcmtpbmdVbml0c0NhY2hlLmdldEl0ZW0oZSwgbiwgdCkpID09IC0xICYmIChpID0gdGhpcy5fY2hlY2tJZldvcmtpbmdVbml0KHQsIGUpLCB0aGlzLl93b3JraW5nVW5pdHNDYWNoZS5zZXRJdGVtKGUsIG4sIGksIHQpKSwgaTtcbn0sIGlzV29ya1RpbWU6IGZ1bmN0aW9uKCkge1xuICB2YXIgdCA9IHRoaXMuYXJndW1lbnRzSGVscGVyLmlzV29ya1RpbWVBcmd1bWVudHMuYXBwbHkodGhpcy5hcmd1bWVudHNIZWxwZXIsIGFyZ3VtZW50cyk7XG4gIHJldHVybiB0aGlzLl9pc1dvcmtUaW1lKHQuZGF0ZSwgdC51bml0KTtcbn0sIGNhbGN1bGF0ZUR1cmF0aW9uOiBmdW5jdGlvbigpIHtcbiAgdmFyIHQgPSB0aGlzLmFyZ3VtZW50c0hlbHBlci5nZXREdXJhdGlvbkFyZ3VtZW50cy5hcHBseSh0aGlzLmFyZ3VtZW50c0hlbHBlciwgYXJndW1lbnRzKTtcbiAgaWYgKCF0LnVuaXQpIHJldHVybiAhMTtcbiAgdmFyIGUgPSB0aGlzO1xuICByZXR1cm4gdGhpcy5fZGF0ZUR1cmF0aW9uQ2FjaGUuZ2V0RHVyYXRpb24odC5zdGFydF9kYXRlLCB0LmVuZF9kYXRlLCB0LnVuaXQsIHQuc3RlcCwgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGUuX2NhbGN1bGF0ZUR1cmF0aW9uKHQuc3RhcnRfZGF0ZSwgdC5lbmRfZGF0ZSwgdC51bml0LCB0LnN0ZXApO1xuICB9KTtcbn0sIF9jYWxjdWxhdGVEdXJhdGlvbjogZnVuY3Rpb24odCwgZSwgbiwgaSkge1xuICB2YXIgYSA9IDAsIHIgPSAxO1xuICBpZiAodC52YWx1ZU9mKCkgPiBlLnZhbHVlT2YoKSkge1xuICAgIHZhciBzID0gZTtcbiAgICBlID0gdCwgdCA9IHMsIHIgPSAtMTtcbiAgfVxuICByZXR1cm4gYSA9IG4gPT0gXCJob3VyXCIgJiYgaSA9PSAxID8gdGhpcy5fZ2V0SG91cnNCZXR3ZWVuKHQsIGUsIG4sIGkpIDogbiA9PSBcIm1pbnV0ZVwiICYmIGkgPT0gMSA/IHRoaXMuX2dldE1pbnV0ZXNCZXR3ZWVuKHQsIGUsIG4sIGkpIDogdGhpcy5fZ2V0V29ya1VuaXRzQmV0d2VlbkdlbmVyaWModCwgZSwgbiwgaSksIHIgKiBNYXRoLnJvdW5kKGEpO1xufSwgaGFzRHVyYXRpb246IGZ1bmN0aW9uKCkge1xuICB2YXIgdCA9IHRoaXMuYXJndW1lbnRzSGVscGVyLmdldER1cmF0aW9uQXJndW1lbnRzLmFwcGx5KHRoaXMuYXJndW1lbnRzSGVscGVyLCBhcmd1bWVudHMpLCBlID0gdC5zdGFydF9kYXRlLCBuID0gdC5lbmRfZGF0ZSwgaSA9IHQudW5pdCwgYSA9IHQuc3RlcDtcbiAgaWYgKCFpKSByZXR1cm4gITE7XG4gIHZhciByID0gbmV3IERhdGUoZSksIHMgPSBuZXcgRGF0ZShuKTtcbiAgZm9yIChhID0gYSB8fCAxOyByLnZhbHVlT2YoKSA8IHMudmFsdWVPZigpOyApIHtcbiAgICBpZiAodGhpcy5faXNXb3JrVGltZShyLCBpKSkgcmV0dXJuICEwO1xuICAgIHIgPSB0aGlzLl9uZXh0RGF0ZShyLCBpLCBhKTtcbiAgfVxuICByZXR1cm4gITE7XG59LCBjYWxjdWxhdGVFbmREYXRlOiBmdW5jdGlvbigpIHtcbiAgdmFyIHQgPSB0aGlzLmFyZ3VtZW50c0hlbHBlci5jYWxjdWxhdGVFbmREYXRlQXJndW1lbnRzLmFwcGx5KHRoaXMuYXJndW1lbnRzSGVscGVyLCBhcmd1bWVudHMpLCBlID0gdC5zdGFydF9kYXRlLCBuID0gdC5kdXJhdGlvbiwgaSA9IHQudW5pdCwgYSA9IHQuc3RlcDtcbiAgaWYgKCFpKSByZXR1cm4gITE7XG4gIHZhciByID0gdC5kdXJhdGlvbiA+PSAwID8gMSA6IC0xO1xuICBuID0gTWF0aC5hYnMoMSAqIG4pO1xuICB2YXIgcyA9IHRoaXM7XG4gIHJldHVybiB0aGlzLl9kYXRlRHVyYXRpb25DYWNoZS5nZXRFbmREYXRlKGUsIG4sIGksIGEgKiByLCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gcy5fY2FsY3VsYXRlRW5kRGF0ZShlLCBuLCBpLCBhICogcik7XG4gIH0pO1xufSwgX2NhbGN1bGF0ZUVuZERhdGU6IGZ1bmN0aW9uKHQsIGUsIG4sIGkpIHtcbiAgcmV0dXJuICEhbiAmJiAoaSA9PSAxICYmIG4gPT0gXCJtaW51dGVcIiA/IHRoaXMuX2NhbGN1bGF0ZU1pbnV0ZUVuZERhdGUodCwgZSwgaSkgOiBpID09IC0xICYmIG4gPT0gXCJtaW51dGVcIiA/IHRoaXMuX3N1YnRyYWN0TWludXRlRGF0ZSh0LCBlLCBpKSA6IGkgPT0gMSAmJiBuID09IFwiaG91clwiID8gdGhpcy5fY2FsY3VsYXRlSG91ckVuZERhdGUodCwgZSwgaSkgOiB0aGlzLl9hZGRJbnRlcnZhbCh0LCBlLCBuLCBpLCBudWxsKS5lbmQpO1xufSwgX2FkZEludGVydmFsOiBmdW5jdGlvbih0LCBlLCBuLCBpLCBhKSB7XG4gIGZvciAodmFyIHIgPSAwLCBzID0gdCwgbyA9ICExOyByIDwgZSAmJiAoIWEgfHwgIWEocykpOyApIHtcbiAgICB2YXIgbCA9IHRoaXMuX25leHREYXRlKHMsIG4sIGkpO1xuICAgIG4gPT0gXCJkYXlcIiAmJiAobyA9IG8gfHwgIXMuZ2V0SG91cnMoKSAmJiBsLmdldEhvdXJzKCkpICYmIChsLnNldEhvdXJzKDApLCBsLmdldEhvdXJzKCkgfHwgKG8gPSAhMSkpO1xuICAgIHZhciBkID0gbmV3IERhdGUobC52YWx1ZU9mKCkgKyAxKTtcbiAgICBpID4gMCAmJiAoZCA9IG5ldyBEYXRlKGwudmFsdWVPZigpIC0gMSkpLCB0aGlzLl9pc1dvcmtUaW1lKGQsIG4pICYmICFvICYmIHIrKywgcyA9IGw7XG4gIH1cbiAgcmV0dXJuIHsgZW5kOiBzLCBzdGFydDogdCwgYWRkZWQ6IHIgfTtcbn0sIF9hZGRIb3Vyc1VudGlsRGF5RW5kOiBmdW5jdGlvbih0LCBlKSB7XG4gIGZvciAodmFyIG4gPSB0aGlzLiRnYW50dC5kYXRlLmFkZCh0aGlzLiRnYW50dC5kYXRlLmRheV9zdGFydChuZXcgRGF0ZSh0KSksIDEsIFwiZGF5XCIpLCBpID0gMCwgYSA9IGUsIHIgPSB0aGlzLl9nZXRJbnRlcnZhbFRpbWVzdGFtcCh0LCBuKSwgcyA9IHRoaXMuX2dldFdvcmtIb3Vycyh0KSwgbyA9IDA7IG8gPCBzLmxlbmd0aCAmJiBpIDwgZTsgbysrKSB7XG4gICAgdmFyIGwgPSBzW29dO1xuICAgIGlmIChyLmVuZCA+PSBsLnN0YXJ0ICYmIHIuc3RhcnQgPD0gbC5lbmQpIHtcbiAgICAgIHZhciBkID0gTWF0aC5tYXgobC5zdGFydCwgci5zdGFydCksIGMgPSBNYXRoLm1pbihsLmVuZCwgci5lbmQpLCB1ID0gKGMgLSBkKSAvIDM2MDA7XG4gICAgICB1ID4gYSAmJiAodSA9IGEsIGMgPSBkICsgNjAgKiBhICogNjApO1xuICAgICAgdmFyIGggPSBNYXRoLnJvdW5kKChjIC0gZCkgLyAzNjAwKTtcbiAgICAgIGkgKz0gaCwgYSAtPSBoLCByLnN0YXJ0ID0gYztcbiAgICB9XG4gIH1cbiAgdmFyIGcgPSBuO1xuICByZXR1cm4gaSA9PT0gZSAmJiAoZyA9IG5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKSwgdC5nZXRNb250aCgpLCB0LmdldERhdGUoKSwgMCwgMCwgci5zdGFydCkpLCB7IGFkZGVkOiBpLCBlbmQ6IGcgfTtcbn0sIF9jYWxjdWxhdGVIb3VyRW5kRGF0ZTogZnVuY3Rpb24odCwgZSwgbikge1xuICB2YXIgaSA9IG5ldyBEYXRlKHQpLCBhID0gMDtcbiAgbiA9IG4gfHwgMSwgZSA9IE1hdGguYWJzKDEgKiBlKTtcbiAgdmFyIHIgPSB0aGlzLl9hZGRIb3Vyc1VudGlsRGF5RW5kKGksIGUpO1xuICBpZiAoYSA9IHIuYWRkZWQsIGkgPSByLmVuZCwgZCA9IGUgLSBhKSB7XG4gICAgZm9yICh2YXIgcyA9IGk7IGEgPCBlOyApIHtcbiAgICAgIHZhciBvID0gdGhpcy5fbmV4dERhdGUocywgXCJkYXlcIiwgbik7XG4gICAgICBvLnNldEhvdXJzKDApLCBvLnNldE1pbnV0ZXMoMCksIG8uc2V0U2Vjb25kcygwKTtcbiAgICAgIHZhciBsID0gMDtcbiAgICAgIGlmIChhICsgKGwgPSBuID4gMCA/IHRoaXMuZ2V0SG91cnNQZXJEYXkobmV3IERhdGUoby52YWx1ZU9mKCkgLSAxKSkgOiB0aGlzLmdldEhvdXJzUGVyRGF5KG5ldyBEYXRlKG8udmFsdWVPZigpICsgMSkpKSA+PSBlKSBicmVhaztcbiAgICAgIGEgKz0gbCwgcyA9IG87XG4gICAgfVxuICAgIGkgPSBzO1xuICB9XG4gIGlmIChhIDwgZSkge1xuICAgIHZhciBkID0gZSAtIGE7XG4gICAgaSA9IChyID0gdGhpcy5fYWRkSG91cnNVbnRpbERheUVuZChpLCBkKSkuZW5kO1xuICB9XG4gIHJldHVybiBpO1xufSwgX2FkZE1pbnV0ZXNVbnRpbEhvdXJFbmQ6IGZ1bmN0aW9uKHQsIGUpIHtcbiAgaWYgKHQuZ2V0TWludXRlcygpID09PSAwKSByZXR1cm4geyBhZGRlZDogMCwgZW5kOiBuZXcgRGF0ZSh0KSB9O1xuICBmb3IgKHZhciBuID0gdGhpcy4kZ2FudHQuZGF0ZS5hZGQodGhpcy4kZ2FudHQuZGF0ZS5ob3VyX3N0YXJ0KG5ldyBEYXRlKHQpKSwgMSwgXCJob3VyXCIpLCBpID0gMCwgYSA9IGUsIHIgPSB0aGlzLl9nZXRJbnRlcnZhbFRpbWVzdGFtcCh0LCBuKSwgcyA9IHRoaXMuX2dldFdvcmtIb3Vycyh0KSwgbyA9IDA7IG8gPCBzLmxlbmd0aCAmJiBpIDwgZTsgbysrKSB7XG4gICAgdmFyIGwgPSBzW29dO1xuICAgIGlmIChyLmVuZCA+PSBsLnN0YXJ0ICYmIHIuc3RhcnQgPD0gbC5lbmQpIHtcbiAgICAgIHZhciBkID0gTWF0aC5tYXgobC5zdGFydCwgci5zdGFydCksIGMgPSBNYXRoLm1pbihsLmVuZCwgci5lbmQpLCB1ID0gKGMgLSBkKSAvIDYwO1xuICAgICAgdSA+IGEgJiYgKHUgPSBhLCBjID0gZCArIDYwICogYSk7XG4gICAgICB2YXIgaCA9IE1hdGgucm91bmQoKGMgLSBkKSAvIDYwKTtcbiAgICAgIGEgLT0gaCwgaSArPSBoLCByLnN0YXJ0ID0gYztcbiAgICB9XG4gIH1cbiAgdmFyIGcgPSBuO1xuICByZXR1cm4gaSA9PT0gZSAmJiAoZyA9IG5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKSwgdC5nZXRNb250aCgpLCB0LmdldERhdGUoKSwgMCwgMCwgci5zdGFydCkpLCB7IGFkZGVkOiBpLCBlbmQ6IGcgfTtcbn0sIF9zdWJ0cmFjdE1pbnV0ZXNVbnRpbEhvdXJTdGFydDogZnVuY3Rpb24odCwgZSkge1xuICBmb3IgKHZhciBuID0gdGhpcy4kZ2FudHQuZGF0ZS5ob3VyX3N0YXJ0KG5ldyBEYXRlKHQpKSwgaSA9IDAsIGEgPSBlLCByID0gNjAgKiBuLmdldEhvdXJzKCkgKiA2MCArIDYwICogbi5nZXRNaW51dGVzKCkgKyBuLmdldFNlY29uZHMoKSwgcyA9IDYwICogdC5nZXRIb3VycygpICogNjAgKyA2MCAqIHQuZ2V0TWludXRlcygpICsgdC5nZXRTZWNvbmRzKCksIG8gPSB0aGlzLl9nZXRXb3JrSG91cnModCksIGwgPSBvLmxlbmd0aCAtIDE7IGwgPj0gMCAmJiBpIDwgZTsgbC0tKSB7XG4gICAgdmFyIGQgPSBvW2xdO1xuICAgIGlmIChzID4gZC5zdGFydCAmJiByIDw9IGQuZW5kKSB7XG4gICAgICB2YXIgYyA9IE1hdGgubWluKHMsIGQuZW5kKSwgdSA9IE1hdGgubWF4KHIsIGQuc3RhcnQpLCBoID0gKGMgLSB1KSAvIDYwO1xuICAgICAgaCA+IGEgJiYgKGggPSBhLCB1ID0gYyAtIDYwICogYSk7XG4gICAgICB2YXIgZyA9IE1hdGguYWJzKE1hdGgucm91bmQoKGMgLSB1KSAvIDYwKSk7XG4gICAgICBhIC09IGcsIGkgKz0gZywgcyA9IHU7XG4gICAgfVxuICB9XG4gIHZhciBwID0gbjtcbiAgcmV0dXJuIGkgPT09IGUgJiYgKHAgPSBuZXcgRGF0ZSh0LmdldEZ1bGxZZWFyKCksIHQuZ2V0TW9udGgoKSwgdC5nZXREYXRlKCksIDAsIDAsIHMpKSwgeyBhZGRlZDogaSwgZW5kOiBwIH07XG59LCBfc3VidHJhY3RNaW51dGVEYXRlOiBmdW5jdGlvbih0LCBlLCBuKSB7XG4gIHZhciBpID0gdGhpcy5nZXRDbG9zZXN0V29ya1RpbWUoeyBkYXRlOiB0LCBkaXI6IFwicGFzdFwiLCB1bml0OiBcIm1pbnV0ZVwiIH0pLCBhID0gMDtcbiAgbiA9IG4gfHwgLTEsIGUgPSBNYXRoLmFicygxICogZSksIGUgPSBNYXRoLnJvdW5kKGUpO1xuICBjb25zdCByID0gdGhpcy5faXNNaW51dGVQcmVjaXNpb24oaSk7XG4gIGxldCBzID0gdGhpcy5fc3VidHJhY3RNaW51dGVzVW50aWxIb3VyU3RhcnQoaSwgZSk7XG4gIGEgKz0gcy5hZGRlZCwgaSA9IHMuZW5kO1xuICBmb3IgKHZhciBvID0gMCwgbCA9IFtdLCBkID0gMDsgYSA8IGU7ICkge1xuICAgIHZhciBjID0gdGhpcy4kZ2FudHQuZGF0ZS5kYXlfc3RhcnQobmV3IERhdGUoaSkpLCB1ID0gITE7XG4gICAgaS52YWx1ZU9mKCkgPT09IGMudmFsdWVPZigpICYmIChjID0gdGhpcy4kZ2FudHQuZGF0ZS5hZGQoYywgLTEsIFwiZGF5XCIpLCB1ID0gITApO1xuICAgIHZhciBoID0gbmV3IERhdGUoYy5nZXRGdWxsWWVhcigpLCBjLmdldE1vbnRoKCksIGMuZ2V0RGF0ZSgpLCAyMywgNTksIDU5LCA5OTkpLnZhbHVlT2YoKTtcbiAgICBoICE9PSBvICYmIChsID0gdGhpcy5fZ2V0V29ya0hvdXJzKGMpLCBkID0gdGhpcy5fZ2V0TWludXRlc1BlckRheShjKSwgbyA9IGgpO1xuICAgIHZhciBnID0gZSAtIGEsIHAgPSB0aGlzLl9nZXRUaW1lT2ZEYXlTdGFtcChpLCB1KTtcbiAgICBpZiAobC5sZW5ndGggJiYgZCkgaWYgKGxbbC5sZW5ndGggLSAxXS5lbmQgPD0gcCAmJiBnID4gZCkgYSArPSBkLCBpID0gdGhpcy4kZ2FudHQuZGF0ZS5hZGQoaSwgLTEsIFwiZGF5XCIpO1xuICAgIGVsc2Uge1xuICAgICAgZm9yICh2YXIgeSA9ICExLCB2ID0gbnVsbCwgYiA9IG51bGwsIF8gPSBsLmxlbmd0aCAtIDE7IF8gPj0gMDsgXy0tKSBpZiAobFtfXS5zdGFydCA8IHAgLSAxICYmIGxbX10uZW5kID49IHAgLSAxKSB7XG4gICAgICAgIHkgPSAhMCwgdiA9IGxbX10sIGIgPSBsW18gLSAxXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoeSkgaWYgKHAgPT09IHYuZW5kICYmIGcgPj0gdi5kdXJhdGlvbk1pbnV0ZXMpIGEgKz0gdi5kdXJhdGlvbk1pbnV0ZXMsIGkgPSB0aGlzLiRnYW50dC5kYXRlLmFkZChpLCAtdi5kdXJhdGlvbk1pbnV0ZXMsIFwibWludXRlXCIpO1xuICAgICAgZWxzZSBpZiAoIXIgJiYgZyA8PSBwIC8gNjAgLSB2LnN0YXJ0TWludXRlKSBhICs9IGcsIGkgPSB0aGlzLiRnYW50dC5kYXRlLmFkZChpLCAtZywgXCJtaW51dGVcIik7XG4gICAgICBlbHNlIGlmIChyKSBnIDw9IHAgLyA2MCAtIHYuc3RhcnRNaW51dGUgPyAoYSArPSBnLCBpID0gdGhpcy4kZ2FudHQuZGF0ZS5hZGQoaSwgLWcsIFwibWludXRlXCIpKSA6IChhICs9IHAgLyA2MCAtIHYuc3RhcnRNaW51dGUsIGkgPSBiID8gbmV3IERhdGUoaS5nZXRGdWxsWWVhcigpLCBpLmdldE1vbnRoKCksIGkuZ2V0RGF0ZSgpLCAwLCAwLCBiLmVuZCkgOiB0aGlzLiRnYW50dC5kYXRlLmRheV9zdGFydChpKSk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIG0gPSB0aGlzLl9nZXRNaW51dGVzUGVySG91cihpKTtcbiAgICAgICAgbSA8PSBnID8gKGEgKz0gbSwgaSA9IHRoaXMuX25leHREYXRlKGksIFwiaG91clwiLCBuKSkgOiAocyA9IHRoaXMuX3N1YnRyYWN0TWludXRlc1VudGlsSG91clN0YXJ0KGksIGcpLCBhICs9IHMuYWRkZWQsIGkgPSBzLmVuZCk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChpLmdldEhvdXJzKCkgPT09IDAgJiYgaS5nZXRNaW51dGVzKCkgPT09IDAgJiYgaS5nZXRTZWNvbmRzKCkgPT09IDApIHtcbiAgICAgICAgaWYgKChmID0gdGhpcy5fZ2V0Q2xvc2VzdFdvcmtUaW1lUGFzdChpLCBcImhvdXJcIikpLnZhbHVlT2YoKSA9PT0gaS52YWx1ZU9mKCkpIHtcbiAgICAgICAgICB2YXIgZiA9IHRoaXMuJGdhbnR0LmRhdGUuYWRkKGksIC0xLCBcImRheVwiKSwgayA9IHRoaXMuX2dldFdvcmtIb3VycyhmKTtcbiAgICAgICAgICBpZiAoay5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciB4ID0ga1trLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgZi5zZXRTZWNvbmRzKHguZHVyYXRpb25TZWNvbmRzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaSA9IGY7XG4gICAgICB9IGVsc2UgaSA9IHRoaXMuX2dldENsb3Nlc3RXb3JrVGltZVBhc3QobmV3IERhdGUoaSAtIDEpLCBcImhvdXJcIik7XG4gICAgfVxuICAgIGVsc2UgaSA9IHRoaXMuJGdhbnR0LmRhdGUuYWRkKGksIC0xLCBcImRheVwiKTtcbiAgfVxuICBpZiAoYSA8IGUpIHtcbiAgICB2YXIgJCA9IGUgLSBhO1xuICAgIHMgPSB0aGlzLl9zdWJ0cmFjdE1pbnV0ZXNVbnRpbEhvdXJTdGFydChpLCAkKSwgYSArPSBzLmFkZGVkLCBpID0gcy5lbmQ7XG4gIH1cbiAgcmV0dXJuIGk7XG59LCBfY2FsY3VsYXRlTWludXRlRW5kRGF0ZTogZnVuY3Rpb24odCwgZSwgbikge1xuICB2YXIgaSA9IG5ldyBEYXRlKHQpLCBhID0gMDtcbiAgbiA9IG4gfHwgMSwgZSA9IE1hdGguYWJzKDEgKiBlKSwgZSA9IE1hdGgucm91bmQoZSk7XG4gIHZhciByID0gdGhpcy5fYWRkTWludXRlc1VudGlsSG91ckVuZChpLCBlKTtcbiAgYSArPSByLmFkZGVkLCBpID0gci5lbmQ7XG4gIGZvciAodmFyIHMgPSAwLCBvID0gW10sIGwgPSAwLCBkID0gdGhpcy5faXNNaW51dGVQcmVjaXNpb24oaSk7IGEgPCBlOyApIHtcbiAgICB2YXIgYyA9IHRoaXMuJGdhbnR0LmRhdGUuZGF5X3N0YXJ0KG5ldyBEYXRlKGkpKS52YWx1ZU9mKCk7XG4gICAgYyAhPT0gcyAmJiAobyA9IHRoaXMuX2dldFdvcmtIb3VycyhpKSwgbCA9IHRoaXMuX2dldE1pbnV0ZXNQZXJEYXkoaSksIHMgPSBjKTtcbiAgICB2YXIgdSA9IGUgLSBhLCBoID0gdGhpcy5fZ2V0VGltZU9mRGF5U3RhbXAoaSk7XG4gICAgaWYgKG8ubGVuZ3RoICYmIGwpIGlmIChvWzBdLnN0YXJ0ID49IGggJiYgdSA+PSBsKSB7XG4gICAgICBpZiAoYSArPSBsLCB1ID09IGwpIHtcbiAgICAgICAgaSA9IG5ldyBEYXRlKGkuZ2V0RnVsbFllYXIoKSwgaS5nZXRNb250aCgpLCBpLmdldERhdGUoKSwgMCwgMCwgb1tvLmxlbmd0aCAtIDFdLmVuZCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaSA9IHRoaXMuJGdhbnR0LmRhdGUuYWRkKGksIDEsIFwiZGF5XCIpLCBpID0gdGhpcy4kZ2FudHQuZGF0ZS5kYXlfc3RhcnQoaSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGcgPSAhMSwgcCA9IG51bGwsIHkgPSAwOyB5IDwgby5sZW5ndGg7IHkrKykgaWYgKG9beV0uc3RhcnQgPD0gaCAmJiBvW3ldLmVuZCA+IGgpIHtcbiAgICAgICAgZyA9ICEwLCBwID0gb1t5XTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoZykgaWYgKGggPT09IHAuc3RhcnQgJiYgdSA+PSBwLmR1cmF0aW9uTWludXRlcykgYSArPSBwLmR1cmF0aW9uTWludXRlcywgaSA9IHRoaXMuJGdhbnR0LmRhdGUuYWRkKGksIHAuZHVyYXRpb25NaW51dGVzLCBcIm1pbnV0ZVwiKTtcbiAgICAgIGVsc2UgaWYgKHUgPD0gcC5lbmRNaW51dGUgLSBoIC8gNjApIGEgKz0gdSwgaSA9IHRoaXMuJGdhbnR0LmRhdGUuYWRkKGksIHUsIFwibWludXRlXCIpO1xuICAgICAgZWxzZSB7XG4gICAgICAgIHZhciB2ID0gdGhpcy5fZ2V0TWludXRlc1BlckhvdXIoaSk7XG4gICAgICAgIHYgPD0gdSA/IChhICs9IHYsIGkgPSBkID8gdGhpcy4kZ2FudHQuZGF0ZS5hZGQoaSwgdiwgXCJtaW51dGVcIikgOiB0aGlzLl9uZXh0RGF0ZShpLCBcImhvdXJcIiwgbikpIDogKGEgKz0gKHIgPSB0aGlzLl9hZGRNaW51dGVzVW50aWxIb3VyRW5kKGksIHUpKS5hZGRlZCwgaSA9IHIuZW5kKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaSA9IHRoaXMuX2dldENsb3Nlc3RXb3JrVGltZUZ1dHVyZShpLCBcImhvdXJcIik7XG4gICAgfVxuICAgIGVsc2UgaSA9IHRoaXMuJGdhbnR0LmRhdGUuYWRkKHRoaXMuJGdhbnR0LmRhdGUuZGF5X3N0YXJ0KGkpLCAxLCBcImRheVwiKTtcbiAgfVxuICBpZiAoYSA8IGUpIHtcbiAgICB2YXIgYiA9IGUgLSBhO1xuICAgIGEgKz0gKHIgPSB0aGlzLl9hZGRNaW51dGVzVW50aWxIb3VyRW5kKGksIGIpKS5hZGRlZCwgaSA9IHIuZW5kO1xuICB9XG4gIHJldHVybiBpO1xufSwgZ2V0Q2xvc2VzdFdvcmtUaW1lOiBmdW5jdGlvbigpIHtcbiAgdmFyIHQgPSB0aGlzLmFyZ3VtZW50c0hlbHBlci5nZXRDbG9zZXN0V29ya1RpbWVBcmd1bWVudHMuYXBwbHkodGhpcy5hcmd1bWVudHNIZWxwZXIsIGFyZ3VtZW50cyk7XG4gIHJldHVybiB0aGlzLl9nZXRDbG9zZXN0V29ya1RpbWUodC5kYXRlLCB0LnVuaXQsIHQuZGlyKTtcbn0sIF9nZXRDbG9zZXN0V29ya1RpbWU6IGZ1bmN0aW9uKHQsIGUsIG4pIHtcbiAgdmFyIGkgPSBuZXcgRGF0ZSh0KTtcbiAgaWYgKHRoaXMuX2lzV29ya1RpbWUoaSwgZSkpIHJldHVybiBpO1xuICBpZiAoaSA9IHRoaXMuJGdhbnR0LmRhdGVbZSArIFwiX3N0YXJ0XCJdKGkpLCBuICE9IFwiYW55XCIgJiYgbikgaSA9IG4gPT0gXCJwYXN0XCIgPyB0aGlzLl9nZXRDbG9zZXN0V29ya1RpbWVQYXN0KGksIGUpIDogdGhpcy5fZ2V0Q2xvc2VzdFdvcmtUaW1lRnV0dXJlKGksIGUpO1xuICBlbHNlIHtcbiAgICB2YXIgYSA9IHRoaXMuX2dldENsb3Nlc3RXb3JrVGltZUZ1dHVyZShpLCBlKSwgciA9IHRoaXMuX2dldENsb3Nlc3RXb3JrVGltZVBhc3QoaSwgZSk7XG4gICAgaSA9IE1hdGguYWJzKGEgLSB0KSA8PSBNYXRoLmFicyh0IC0gcikgPyBhIDogcjtcbiAgfVxuICByZXR1cm4gaTtcbn0sIF9nZXRDbG9zZXN0V29ya1RpbWVGdXR1cmU6IGZ1bmN0aW9uKHQsIGUpIHtcbiAgcmV0dXJuIHRoaXMuX2dldENsb3Nlc3RXb3JrVGltZUdlbmVyaWModCwgZSwgMSk7XG59LCBfZ2V0Q2xvc2VzdFdvcmtUaW1lUGFzdDogZnVuY3Rpb24odCwgZSkge1xuICB2YXIgbiA9IHRoaXMuX2dldENsb3Nlc3RXb3JrVGltZUdlbmVyaWModCwgZSwgLTEpO1xuICByZXR1cm4gdGhpcy4kZ2FudHQuZGF0ZS5hZGQobiwgMSwgZSk7XG59LCBfZmluZENsb3Nlc3RUaW1lSW5EYXk6IGZ1bmN0aW9uKHQsIGUsIG4pIHtcbiAgdmFyIGkgPSBuZXcgRGF0ZSh0KSwgYSA9IG51bGwsIHIgPSAhMTtcbiAgdGhpcy5fZ2V0V29ya0hvdXJzKGkpLmxlbmd0aCB8fCAoaSA9IHRoaXMuX2dldENsb3Nlc3RXb3JrVGltZShpLCBcImRheVwiLCBlIDwgMCA/IFwicGFzdFwiIDogXCJmdXR1cmVcIiksIGUgPCAwICYmIChpID0gbmV3IERhdGUoaS52YWx1ZU9mKCkgLSAxKSwgciA9ICEwKSwgbiA9IHRoaXMuX2dldFdvcmtIb3VycyhpKSk7XG4gIHZhciBzID0gdGhpcy5fZ2V0VGltZU9mRGF5U3RhbXAoaSk7XG4gIGlmIChyICYmIChzID0gdGhpcy5fZ2V0VGltZU9mRGF5U3RhbXAobmV3IERhdGUoaS52YWx1ZU9mKCkgKyAxKSwgcikpLCBlID4gMCkge1xuICAgIGZvciAodmFyIG8gPSAwOyBvIDwgbi5sZW5ndGg7IG8rKykgaWYgKG5bb10uc3RhcnQgPj0gcykge1xuICAgICAgYSA9IG5ldyBEYXRlKGkuZ2V0RnVsbFllYXIoKSwgaS5nZXRNb250aCgpLCBpLmdldERhdGUoKSwgMCwgMCwgbltvXS5zdGFydCk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH0gZWxzZSBmb3IgKG8gPSBuLmxlbmd0aCAtIDE7IG8gPj0gMDsgby0tKSB7XG4gICAgaWYgKG5bb10uZW5kIDw9IHMpIHtcbiAgICAgIGEgPSBuZXcgRGF0ZShpLmdldEZ1bGxZZWFyKCksIGkuZ2V0TW9udGgoKSwgaS5nZXREYXRlKCksIDAsIDAsIG5bb10uZW5kKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAobltvXS5lbmQgPiBzICYmIG5bb10uc3RhcnQgPD0gcykge1xuICAgICAgYSA9IG5ldyBEYXRlKGkuZ2V0RnVsbFllYXIoKSwgaS5nZXRNb250aCgpLCBpLmdldERhdGUoKSwgMCwgMCwgcyk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGE7XG59LCBfZ2V0Q2xvc2VzdFdvcmtNaW51dGU6IGZ1bmN0aW9uKHQsIGUsIG4pIHtcbiAgdmFyIGkgPSBuZXcgRGF0ZSh0KSwgYSA9IHRoaXMuX2dldFdvcmtIb3VycyhpKSwgciA9IHRoaXMuX2ZpbmRDbG9zZXN0VGltZUluRGF5KGksIG4sIGEpO1xuICByZXR1cm4gciB8fCAobiA+IDAgPyAoaSA9IHRoaXMuY2FsY3VsYXRlRW5kRGF0ZShpLCBuLCBlKSwgaSA9IHRoaXMuJGdhbnR0LmRhdGUuZGF5X3N0YXJ0KGkpKSA6IChpID0gdGhpcy5jYWxjdWxhdGVFbmREYXRlKGksIG4sIFwiZGF5XCIpLCBpID0gdGhpcy4kZ2FudHQuZGF0ZS5kYXlfc3RhcnQoaSksIGkgPSB0aGlzLiRnYW50dC5kYXRlLmFkZChpLCAxLCBcImRheVwiKSwgaSA9IG5ldyBEYXRlKGkudmFsdWVPZigpIC0gMSkpLCBhID0gdGhpcy5fZ2V0V29ya0hvdXJzKGkpLCByID0gdGhpcy5fZmluZENsb3Nlc3RUaW1lSW5EYXkoaSwgbiwgYSkpLCBuIDwgMCAmJiAociA9IHRoaXMuJGdhbnR0LmRhdGUuYWRkKHIsIC0xLCBlKSksIHI7XG59LCBfZ2V0Q2xvc2VzdFdvcmtUaW1lR2VuZXJpYzogZnVuY3Rpb24odCwgZSwgbikge1xuICBpZiAoZSA9PT0gXCJob3VyXCIgfHwgZSA9PT0gXCJtaW51dGVcIikgcmV0dXJuIHRoaXMuX2dldENsb3Nlc3RXb3JrTWludXRlKHQsIGUsIG4pO1xuICBmb3IgKHZhciBpID0gdGhpcy5fZ2V0VW5pdE9yZGVyKGUpLCBhID0gdGhpcy51bml0c1tpIC0gMV0sIHIgPSB0LCBzID0gMDsgIXRoaXMuX2lzV29ya1RpbWUociwgZSkgJiYgKCFhIHx8IHRoaXMuX2lzV29ya1RpbWUociwgYSkgfHwgKHIgPSBuID4gMCA/IHRoaXMuX2dldENsb3Nlc3RXb3JrVGltZUZ1dHVyZShyLCBhKSA6IHRoaXMuX2dldENsb3Nlc3RXb3JrVGltZVBhc3QociwgYSksICF0aGlzLl9pc1dvcmtUaW1lKHIsIGUpKSk7ICkge1xuICAgIGlmICgrK3MgPiAzZTMpIHJldHVybiB0aGlzLiRnYW50dC5hc3NlcnQoITEsIFwiSW52YWxpZCB3b3JraW5nIHRpbWUgY2hlY2tcIiksICExO1xuICAgIHZhciBvID0gci5nZXRUaW1lem9uZU9mZnNldCgpO1xuICAgIHIgPSB0aGlzLiRnYW50dC5kYXRlLmFkZChyLCBuLCBlKSwgciA9IHRoaXMuJGdhbnR0Ll9jb3JyZWN0X2RzdF9jaGFuZ2UociwgbywgbiwgZSksIHRoaXMuJGdhbnR0LmRhdGVbZSArIFwiX3N0YXJ0XCJdICYmIChyID0gdGhpcy4kZ2FudHQuZGF0ZVtlICsgXCJfc3RhcnRcIl0ocikpO1xuICB9XG4gIHJldHVybiByO1xufSwgaGFzV29ya1RpbWU6IGZ1bmN0aW9uKCkge1xuICB2YXIgdCA9IHRoaXMuZ2V0Q29uZmlnKCksIGUgPSB0LmRhdGVzO1xuICBmb3IgKHZhciBuIGluIHQuZGF0ZXMpIDtcbiAgdmFyIGkgPSB0aGlzLl9jaGVja1dvcmtIb3Vycyh0LmhvdXJzKSwgYSA9ICExO1xuICByZXR1cm4gWzAsIDEsIDIsIDMsIDQsIDUsIDZdLmZvckVhY2goKGZ1bmN0aW9uKHIpIHtcbiAgICBpZiAoIWEpIHtcbiAgICAgIHZhciBzID0gZVtyXTtcbiAgICAgIHMgPT09ICEwID8gYSA9IGkgOiBBcnJheS5pc0FycmF5KHMpICYmIChhID0gdGhpcy5fY2hlY2tXb3JrSG91cnMocykpO1xuICAgIH1cbiAgfSkuYmluZCh0aGlzKSksIGE7XG59LCBfY2hlY2tXb3JrSG91cnM6IGZ1bmN0aW9uKHQpIHtcbiAgaWYgKHQubGVuZ3RoID09PSAwKSByZXR1cm4gITE7XG4gIGZvciAodmFyIGUgPSAhMSwgbiA9IDA7IG4gPCB0Lmxlbmd0aDsgbiArPSAyKSB0W25dICE9PSB0W24gKyAxXSAmJiAoZSA9ICEwKTtcbiAgcmV0dXJuIGU7XG59LCBfaXNNaW51dGVQcmVjaXNpb246IGZ1bmN0aW9uKHQpIHtcbiAgbGV0IGUgPSAhMTtcbiAgcmV0dXJuIHRoaXMuX2dldFdvcmtIb3Vycyh0KS5mb3JFYWNoKGZ1bmN0aW9uKG4pIHtcbiAgICAobi5zdGFydE1pbnV0ZSAlIDYwIHx8IG4uZW5kTWludXRlICUgNjApICYmIChlID0gITApO1xuICB9KSwgZTtcbn0gfTtcbmNvbnN0IEl0ID0geyBpc0xlZ2FjeVJlc291cmNlQ2FsZW5kYXJGb3JtYXQ6IGZ1bmN0aW9uKHQpIHtcbiAgaWYgKCF0KSByZXR1cm4gITE7XG4gIGZvciAodmFyIGUgaW4gdCkgaWYgKHRbZV0gJiYgdHlwZW9mIHRbZV0gPT0gXCJvYmplY3RcIikgcmV0dXJuICEwO1xuICByZXR1cm4gITE7XG59LCBnZXRSZXNvdXJjZVByb3BlcnR5OiBmdW5jdGlvbih0KSB7XG4gIHZhciBlID0gdC5yZXNvdXJjZV9jYWxlbmRhcnMsIG4gPSB0LnJlc291cmNlX3Byb3BlcnR5O1xuICBpZiAodGhpcy5pc0xlZ2FjeVJlc291cmNlQ2FsZW5kYXJGb3JtYXQoZSkpIGZvciAodmFyIGkgaW4gdCkge1xuICAgIG4gPSBpO1xuICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiBuO1xufSwgZ2V0Q2FsZW5kYXJJZEZyb21MZWdhY3lDb25maWc6IGZ1bmN0aW9uKHQsIGUpIHtcbiAgaWYgKGUpIGZvciAodmFyIG4gaW4gZSkge1xuICAgIHZhciBpID0gZVtuXTtcbiAgICBpZiAodFtuXSkge1xuICAgICAgdmFyIGEgPSBpW3Rbbl1dO1xuICAgICAgaWYgKGEpIHJldHVybiBhO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn0gfSwgYmkgPSAoV3QgPSB7fSwgeyBnZXRDYWxlbmRhcklkRnJvbU11bHRpcGxlUmVzb3VyY2VzOiBmdW5jdGlvbih0LCBlKSB7XG4gIHZhciBuID0gZnVuY3Rpb24oYSkge1xuICAgIHJldHVybiBhLm1hcChmdW5jdGlvbihyKSB7XG4gICAgICByZXR1cm4gciAmJiByLnJlc291cmNlX2lkID8gci5yZXNvdXJjZV9pZCA6IHI7XG4gICAgfSkuc29ydCgpLmpvaW4oXCItXCIpO1xuICB9KHQpO1xuICBpZiAodC5sZW5ndGgpIHtcbiAgICBpZiAodC5sZW5ndGggPT09IDEpIHJldHVybiBlLmdldFJlc291cmNlQ2FsZW5kYXIobikuaWQ7XG4gICAgaWYgKFd0W25dKSByZXR1cm4gV3Rbbl0uaWQ7XG4gICAgdmFyIGkgPSBmdW5jdGlvbihhLCByKSB7XG4gICAgICByZXR1cm4gci5tZXJnZUNhbGVuZGFycyhhLm1hcChmdW5jdGlvbihzKSB7XG4gICAgICAgIHZhciBvID0gcyAmJiBzLnJlc291cmNlX2lkID8gcy5yZXNvdXJjZV9pZCA6IHM7XG4gICAgICAgIHJldHVybiByLmdldFJlc291cmNlQ2FsZW5kYXIobyk7XG4gICAgICB9KSk7XG4gICAgfSh0LCBlKTtcbiAgICByZXR1cm4gV3Rbbl0gPSBpLCBlLmFkZENhbGVuZGFyKGkpO1xuICB9XG4gIHJldHVybiBudWxsO1xufSB9KTtcbnZhciBXdDtcbmZ1bmN0aW9uIGZuKHQpIHtcbiAgdGhpcy4kZ2FudHQgPSB0LCB0aGlzLl9jYWxlbmRhcnMgPSB7fSwgdGhpcy5fbGVnYWN5Q29uZmlnID0gdm9pZCAwLCB0aGlzLiRnYW50dC5hdHRhY2hFdmVudChcIm9uR2FudHRSZWFkeVwiLCAoZnVuY3Rpb24oKSB7XG4gICAgdGhpcy4kZ2FudHQuY29uZmlnLnJlc291cmNlX2NhbGVuZGFycyAmJiAodGhpcy5faXNMZWdhY3lDb25maWcgPSBJdC5pc0xlZ2FjeVJlc291cmNlQ2FsZW5kYXJGb3JtYXQodGhpcy4kZ2FudHQuY29uZmlnLnJlc291cmNlX2NhbGVuZGFycykpO1xuICB9KS5iaW5kKHRoaXMpKSwgdGhpcy4kZ2FudHQuYXR0YWNoRXZlbnQoXCJvbkJlZm9yZUdhbnR0UmVhZHlcIiwgKGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY3JlYXRlRGVmYXVsdENhbGVuZGFycygpO1xuICB9KS5iaW5kKHRoaXMpKSwgdGhpcy4kZ2FudHQuYXR0YWNoRXZlbnQoXCJvbkJlZm9yZUdhbnR0UmVuZGVyXCIsIChmdW5jdGlvbigpIHtcbiAgICB0aGlzLmNyZWF0ZURlZmF1bHRDYWxlbmRhcnMoKTtcbiAgfSkuYmluZCh0aGlzKSk7XG59XG5mdW5jdGlvbiBiZSh0LCBlKSB7XG4gIHRoaXMuYXJndW1lbnRzSGVscGVyID0gZSwgdGhpcy4kZ2FudHQgPSB0O1xufVxuZnVuY3Rpb24gcG4odCkge1xuICB0aGlzLiRnYW50dCA9IHQuJGdhbnR0LCB0aGlzLmFyZ3VtZW50c0hlbHBlciA9IF9uKHRoaXMuJGdhbnR0KSwgdGhpcy5jYWxlbmRhck1hbmFnZXIgPSB0LCB0aGlzLiRkaXNhYmxlZENhbGVuZGFyID0gbmV3IGJlKHRoaXMuJGdhbnR0LCB0aGlzLmFyZ3VtZW50c0hlbHBlcik7XG59XG5mbi5wcm90b3R5cGUgPSB7IF9jYWxlbmRhcnM6IHt9LCBfY29udmVydFdvcmtUaW1lU2V0dGluZ3M6IGZ1bmN0aW9uKHQpIHtcbiAgdmFyIGUgPSB0LmRheXM7XG4gIGlmIChlICYmICF0LmRhdGVzKSB7XG4gICAgdC5kYXRlcyA9IHQuZGF0ZXMgfHwge307XG4gICAgZm9yICh2YXIgbiA9IDA7IG4gPCBlLmxlbmd0aDsgbisrKSB0LmRhdGVzW25dID0gZVtuXSwgZVtuXSBpbnN0YW5jZW9mIEFycmF5IHx8ICh0LmRhdGVzW25dID0gISFlW25dKTtcbiAgfVxuICByZXR1cm4gZGVsZXRlIHQuZGF5cywgdDtcbn0sIG1lcmdlQ2FsZW5kYXJzOiBmdW5jdGlvbigpIHtcbiAgdmFyIHQgPSBbXSwgZSA9IGFyZ3VtZW50cztcbiAgaWYgKEFycmF5LmlzQXJyYXkoZVswXSkpIHQgPSBlWzBdLnNsaWNlKCk7XG4gIGVsc2UgZm9yICh2YXIgbiA9IDA7IG4gPCBhcmd1bWVudHMubGVuZ3RoOyBuKyspIHQucHVzaChhcmd1bWVudHNbbl0pO1xuICB2YXIgaSwgYSA9IG5ldyBnbigpO1xuICByZXR1cm4gdC5mb3JFYWNoKChmdW5jdGlvbihyKSB7XG4gICAgaSA9IGkgPyB0aGlzLl9jcmVhdGVDYWxlbmRhckZyb21Db25maWcoYS5tZXJnZShpLCByKSkgOiByO1xuICB9KS5iaW5kKHRoaXMpKSwgdGhpcy5jcmVhdGVDYWxlbmRhcihpKTtcbn0sIF9jcmVhdGVDYWxlbmRhckZyb21Db25maWc6IGZ1bmN0aW9uKHQpIHtcbiAgdmFyIGUgPSBuZXcgeWUodGhpcy4kZ2FudHQsIF9uKHRoaXMuJGdhbnR0KSk7XG4gIGUuaWQgPSBTdHJpbmcoc3QoKSk7XG4gIHZhciBuID0gdGhpcy5fY29udmVydFdvcmtUaW1lU2V0dGluZ3ModCk7XG4gIGlmIChuLmN1c3RvbVdlZWtzKSBmb3IgKHZhciBpIGluIG4uY3VzdG9tV2Vla3MpIG4uY3VzdG9tV2Vla3NbaV0gPSB0aGlzLl9jb252ZXJ0V29ya1RpbWVTZXR0aW5ncyhuLmN1c3RvbVdlZWtzW2ldKTtcbiAgcmV0dXJuIGUuX3NldENvbmZpZyhuKSwgZTtcbn0sIGNyZWF0ZUNhbGVuZGFyOiBmdW5jdGlvbih0KSB7XG4gIHZhciBlO1xuICByZXR1cm4gdCB8fCAodCA9IHt9KSwgUChlID0gdC5nZXRDb25maWcgPyBxKHQuZ2V0Q29uZmlnKCkpIDogdC53b3JrdGltZSA/IHEodC53b3JrdGltZSkgOiBxKHQpLCBxKHRoaXMuZGVmYXVsdHMuZnVsbHRpbWUud29ya3RpbWUpKSwgdGhpcy5fY3JlYXRlQ2FsZW5kYXJGcm9tQ29uZmlnKGUpO1xufSwgZ2V0Q2FsZW5kYXI6IGZ1bmN0aW9uKHQpIHtcbiAgdCA9IHQgfHwgXCJnbG9iYWxcIjtcbiAgdmFyIGUgPSB0aGlzLl9jYWxlbmRhcnNbdF07XG4gIHJldHVybiBlIHx8ICh0aGlzLmNyZWF0ZURlZmF1bHRDYWxlbmRhcnMoKSwgZSA9IHRoaXMuX2NhbGVuZGFyc1t0XSksIGU7XG59LCBnZXRDYWxlbmRhcnM6IGZ1bmN0aW9uKCkge1xuICB2YXIgdCA9IFtdO1xuICBmb3IgKHZhciBlIGluIHRoaXMuX2NhbGVuZGFycykgdC5wdXNoKHRoaXMuZ2V0Q2FsZW5kYXIoZSkpO1xuICByZXR1cm4gdDtcbn0sIF9nZXRPd25DYWxlbmRhcjogZnVuY3Rpb24odCkge1xuICB2YXIgZSA9IHRoaXMuJGdhbnR0LmNvbmZpZztcbiAgaWYgKHRbZS5jYWxlbmRhcl9wcm9wZXJ0eV0pIHJldHVybiB0aGlzLmdldENhbGVuZGFyKHRbZS5jYWxlbmRhcl9wcm9wZXJ0eV0pO1xuICBpZiAoZS5yZXNvdXJjZV9jYWxlbmRhcnMpIHtcbiAgICB2YXIgbjtcbiAgICBpZiAobiA9IHRoaXMuX2xlZ2FjeUNvbmZpZyA9PT0gITEgPyBlLnJlc291cmNlX3Byb3BlcnR5IDogSXQuZ2V0UmVzb3VyY2VQcm9wZXJ0eShlKSwgQXJyYXkuaXNBcnJheSh0W25dKSkgZS5keW5hbWljX3Jlc291cmNlX2NhbGVuZGFycyA/IGkgPSBiaS5nZXRDYWxlbmRhcklkRnJvbU11bHRpcGxlUmVzb3VyY2VzKHRbbl0sIHRoaXMpIDogYSA9IHRoaXMuZ2V0UmVzb3VyY2VDYWxlbmRhcih0W25dKTtcbiAgICBlbHNlIGlmICh0aGlzLl9sZWdhY3lDb25maWcgPT09IHZvaWQgMCAmJiAodGhpcy5fbGVnYWN5Q29uZmlnID0gSXQuaXNMZWdhY3lSZXNvdXJjZUNhbGVuZGFyRm9ybWF0KGUucmVzb3VyY2VfY2FsZW5kYXJzKSksIHRoaXMuX2xlZ2FjeUNvbmZpZykgdmFyIGkgPSBJdC5nZXRDYWxlbmRhcklkRnJvbUxlZ2FjeUNvbmZpZyh0LCBlLnJlc291cmNlX2NhbGVuZGFycyk7XG4gICAgZWxzZSBpZiAobiAmJiB0W25dICYmIGUucmVzb3VyY2VfY2FsZW5kYXJzW3Rbbl1dKSB2YXIgYSA9IHRoaXMuZ2V0UmVzb3VyY2VDYWxlbmRhcih0W25dKTtcbiAgICBpZiAoaSAmJiAoYSA9IHRoaXMuZ2V0Q2FsZW5kYXIoaSkpLCBhKSByZXR1cm4gYTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn0sIGdldFJlc291cmNlQ2FsZW5kYXI6IGZ1bmN0aW9uKHQpIHtcbiAgaWYgKHQgPT0gbnVsbCkgcmV0dXJuIHRoaXMuZ2V0Q2FsZW5kYXIoKTtcbiAgdmFyIGUgPSBudWxsO1xuICBlID0gdHlwZW9mIHQgPT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgdCA9PSBcInN0cmluZ1wiID8gdCA6IHQuaWQgfHwgdC5rZXk7XG4gIHZhciBuID0gdGhpcy4kZ2FudHQuY29uZmlnLCBpID0gbi5yZXNvdXJjZV9jYWxlbmRhcnMsIGEgPSBudWxsO1xuICBpZiAoQXJyYXkuaXNBcnJheSh0KSAmJiB0Lmxlbmd0aCA9PT0gMSAmJiAoZSA9IHR5cGVvZiB0WzBdID09IFwib2JqZWN0XCIgPyB0WzBdLnJlc291cmNlX2lkIDogdFswXSksIGkpIHtcbiAgICBpZiAodGhpcy5fbGVnYWN5Q29uZmlnID09PSB2b2lkIDAgJiYgKHRoaXMuX2xlZ2FjeUNvbmZpZyA9IEl0LmlzTGVnYWN5UmVzb3VyY2VDYWxlbmRhckZvcm1hdChuLnJlc291cmNlX2NhbGVuZGFycykpLCB0aGlzLl9sZWdhY3lDb25maWcpIHtcbiAgICAgIGZvciAodmFyIHIgaW4gaSkgaWYgKGlbcl1bZV0pIHtcbiAgICAgICAgYSA9IGlbcl1bZV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSBhID0gaVtlXTtcbiAgICBpZiAoYSkgcmV0dXJuIHRoaXMuZ2V0Q2FsZW5kYXIoYSk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuZ2V0Q2FsZW5kYXIoKTtcbn0sIGdldFRhc2tDYWxlbmRhcjogZnVuY3Rpb24odCkge1xuICB2YXIgZSwgbiA9IHRoaXMuJGdhbnR0O1xuICBpZiAodCA9PSBudWxsKSByZXR1cm4gdGhpcy5nZXRDYWxlbmRhcigpO1xuICBpZiAoIShlID0gdHlwZW9mIHQgIT0gXCJudW1iZXJcIiAmJiB0eXBlb2YgdCAhPSBcInN0cmluZ1wiIHx8ICFuLmlzVGFza0V4aXN0cyh0KSA/IHQgOiBuLmdldFRhc2sodCkpKSByZXR1cm4gdGhpcy5nZXRDYWxlbmRhcigpO1xuICB2YXIgaSA9IHRoaXMuX2dldE93bkNhbGVuZGFyKGUpLCBhID0gISFuLmdldFN0YXRlKCkuZ3JvdXBfbW9kZTtcbiAgaWYgKCFpICYmIG4uY29uZmlnLmluaGVyaXRfY2FsZW5kYXIgJiYgbi5pc1Rhc2tFeGlzdHMoZS5wYXJlbnQpKSB7XG4gICAgZm9yICh2YXIgciA9IGU7IG4uaXNUYXNrRXhpc3RzKHIucGFyZW50KSAmJiAociA9IG4uZ2V0VGFzayhyLnBhcmVudCksICFuLmlzU3VtbWFyeVRhc2socikgfHwgIShpID0gdGhpcy5fZ2V0T3duQ2FsZW5kYXIocikpKTsgKSA7XG4gICAgYSAmJiAhaSAmJiB0LiRlZmZlY3RpdmVfY2FsZW5kYXIgJiYgKGkgPSB0aGlzLmdldENhbGVuZGFyKHQuJGVmZmVjdGl2ZV9jYWxlbmRhcikpO1xuICB9XG4gIHJldHVybiBpIHx8IHRoaXMuZ2V0Q2FsZW5kYXIoKTtcbn0sIGFkZENhbGVuZGFyOiBmdW5jdGlvbih0KSB7XG4gIGlmICghdGhpcy5pc0NhbGVuZGFyKHQpKSB7XG4gICAgdmFyIGUgPSB0LmlkO1xuICAgICh0ID0gdGhpcy5jcmVhdGVDYWxlbmRhcih0KSkuaWQgPSBlO1xuICB9XG4gIGlmICh0Ll90cnlDaGFuZ2VDYWxlbmRhclNldHRpbmdzKGZ1bmN0aW9uKCkge1xuICB9KSkge1xuICAgIHZhciBuID0gdGhpcy4kZ2FudHQuY29uZmlnO1xuICAgIHJldHVybiB0LmlkID0gdC5pZCB8fCBzdCgpLCB0aGlzLl9jYWxlbmRhcnNbdC5pZF0gPSB0LCBuLndvcmt0aW1lcyB8fCAobi53b3JrdGltZXMgPSB7fSksIG4ud29ya3RpbWVzW3QuaWRdID0gdC5nZXRDb25maWcoKSwgdC5pZDtcbiAgfVxuICByZXR1cm4gdGhpcy4kZ2FudHQuY2FsbEV2ZW50KFwib25DYWxlbmRhckVycm9yXCIsIFt7IG1lc3NhZ2U6IFwiSW52YWxpZCBjYWxlbmRhciBzZXR0aW5ncywgbm8gd29ya3RpbWUgYXZhaWxhYmxlXCIgfSwgdF0pLCBudWxsO1xufSwgZGVsZXRlQ2FsZW5kYXI6IGZ1bmN0aW9uKHQpIHtcbiAgdmFyIGUgPSB0aGlzLiRnYW50dC5jb25maWc7XG4gIHJldHVybiAhIXQgJiYgISF0aGlzLl9jYWxlbmRhcnNbdF0gJiYgKGRlbGV0ZSB0aGlzLl9jYWxlbmRhcnNbdF0sIGUud29ya3RpbWVzICYmIGUud29ya3RpbWVzW3RdICYmIGRlbGV0ZSBlLndvcmt0aW1lc1t0XSwgITApO1xufSwgcmVzdG9yZUNvbmZpZ0NhbGVuZGFyczogZnVuY3Rpb24odCkge1xuICBmb3IgKHZhciBlIGluIHQpIGlmICghdGhpcy5fY2FsZW5kYXJzW2VdKSB7XG4gICAgdmFyIG4gPSB0W2VdLCBpID0gdGhpcy5jcmVhdGVDYWxlbmRhcihuKTtcbiAgICBpLmlkID0gZSwgdGhpcy5hZGRDYWxlbmRhcihpKTtcbiAgfVxufSwgZGVmYXVsdHM6IHsgZ2xvYmFsOiB7IGlkOiBcImdsb2JhbFwiLCB3b3JrdGltZTogeyBob3VyczogWzgsIDEyLCAxMywgMTddLCBkYXlzOiBbMCwgMSwgMSwgMSwgMSwgMSwgMF0gfSB9LCBmdWxsdGltZTogeyBpZDogXCJmdWxsdGltZVwiLCB3b3JrdGltZTogeyBob3VyczogWzAsIDI0XSwgZGF5czogWzEsIDEsIDEsIDEsIDEsIDEsIDFdIH0gfSB9LCBjcmVhdGVEZWZhdWx0Q2FsZW5kYXJzOiBmdW5jdGlvbigpIHtcbiAgdmFyIHQgPSB0aGlzLiRnYW50dC5jb25maWc7XG4gIHRoaXMucmVzdG9yZUNvbmZpZ0NhbGVuZGFycyh0aGlzLmRlZmF1bHRzKSwgdGhpcy5yZXN0b3JlQ29uZmlnQ2FsZW5kYXJzKHQud29ya3RpbWVzKTtcbn0sIGlzQ2FsZW5kYXI6IGZ1bmN0aW9uKHQpIHtcbiAgcmV0dXJuIFt0LmlzV29ya1RpbWUsIHQuc2V0V29ya1RpbWUsIHQuZ2V0V29ya0hvdXJzLCB0LnVuc2V0V29ya1RpbWUsIHQuZ2V0Q2xvc2VzdFdvcmtUaW1lLCB0LmNhbGN1bGF0ZUR1cmF0aW9uLCB0Lmhhc0R1cmF0aW9uLCB0LmNhbGN1bGF0ZUVuZERhdGVdLmV2ZXJ5KGZ1bmN0aW9uKGUpIHtcbiAgICByZXR1cm4gZSBpbnN0YW5jZW9mIEZ1bmN0aW9uO1xuICB9KTtcbn0gfSwgYmUucHJvdG90eXBlID0geyBnZXRXb3JrSG91cnM6IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gWzAsIDI0XTtcbn0sIHNldFdvcmtUaW1lOiBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICEwO1xufSwgdW5zZXRXb3JrVGltZTogZnVuY3Rpb24oKSB7XG4gIHJldHVybiAhMDtcbn0sIGlzV29ya1RpbWU6IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gITA7XG59LCBnZXRDbG9zZXN0V29ya1RpbWU6IGZ1bmN0aW9uKHQpIHtcbiAgcmV0dXJuIHRoaXMuYXJndW1lbnRzSGVscGVyLmdldENsb3Nlc3RXb3JrVGltZUFyZ3VtZW50cy5hcHBseSh0aGlzLmFyZ3VtZW50c0hlbHBlciwgYXJndW1lbnRzKS5kYXRlO1xufSwgY2FsY3VsYXRlRHVyYXRpb246IGZ1bmN0aW9uKCkge1xuICB2YXIgdCA9IHRoaXMuYXJndW1lbnRzSGVscGVyLmdldER1cmF0aW9uQXJndW1lbnRzLmFwcGx5KHRoaXMuYXJndW1lbnRzSGVscGVyLCBhcmd1bWVudHMpLCBlID0gdC5zdGFydF9kYXRlLCBuID0gdC5lbmRfZGF0ZSwgaSA9IHQudW5pdCwgYSA9IHQuc3RlcDtcbiAgcmV0dXJuIHRoaXMuX2NhbGN1bGF0ZUR1cmF0aW9uKGUsIG4sIGksIGEpO1xufSwgX2NhbGN1bGF0ZUR1cmF0aW9uOiBmdW5jdGlvbih0LCBlLCBuLCBpKSB7XG4gIHZhciBhID0gdGhpcy4kZ2FudHQuZGF0ZSwgciA9IHsgd2VlazogNjA0OGU1LCBkYXk6IDg2NGU1LCBob3VyOiAzNmU1LCBtaW51dGU6IDZlNCB9LCBzID0gMDtcbiAgaWYgKHJbbl0pIHMgPSBNYXRoLnJvdW5kKChlIC0gdCkgLyAoaSAqIHJbbl0pKTtcbiAgZWxzZSB7XG4gICAgZm9yICh2YXIgbyA9IG5ldyBEYXRlKHQpLCBsID0gbmV3IERhdGUoZSk7IG8udmFsdWVPZigpIDwgbC52YWx1ZU9mKCk7ICkgcyArPSAxLCBvID0gYS5hZGQobywgaSwgbik7XG4gICAgby52YWx1ZU9mKCkgIT0gZS52YWx1ZU9mKCkgJiYgKHMgKz0gKGwgLSBvKSAvIChhLmFkZChvLCBpLCBuKSAtIG8pKTtcbiAgfVxuICByZXR1cm4gTWF0aC5yb3VuZChzKTtcbn0sIGhhc0R1cmF0aW9uOiBmdW5jdGlvbigpIHtcbiAgdmFyIHQgPSB0aGlzLmFyZ3VtZW50c0hlbHBlci5nZXREdXJhdGlvbkFyZ3VtZW50cy5hcHBseSh0aGlzLmFyZ3VtZW50c0hlbHBlciwgYXJndW1lbnRzKSwgZSA9IHQuc3RhcnRfZGF0ZSwgbiA9IHQuZW5kX2RhdGU7XG4gIHJldHVybiAhIXQudW5pdCAmJiAoZSA9IG5ldyBEYXRlKGUpLCBuID0gbmV3IERhdGUobiksIGUudmFsdWVPZigpIDwgbi52YWx1ZU9mKCkpO1xufSwgaGFzV29ya1RpbWU6IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gITA7XG59LCBlcXVhbHM6IGZ1bmN0aW9uKHQpIHtcbiAgcmV0dXJuIHQgaW5zdGFuY2VvZiBiZTtcbn0sIGNhbGN1bGF0ZUVuZERhdGU6IGZ1bmN0aW9uKCkge1xuICB2YXIgdCA9IHRoaXMuYXJndW1lbnRzSGVscGVyLmNhbGN1bGF0ZUVuZERhdGVBcmd1bWVudHMuYXBwbHkodGhpcy5hcmd1bWVudHNIZWxwZXIsIGFyZ3VtZW50cyksIGUgPSB0LnN0YXJ0X2RhdGUsIG4gPSB0LmR1cmF0aW9uLCBpID0gdC51bml0LCBhID0gdC5zdGVwO1xuICByZXR1cm4gdGhpcy4kZ2FudHQuZGF0ZS5hZGQoZSwgYSAqIG4sIGkpO1xufSB9LCBwbi5wcm90b3R5cGUgPSB7IF9nZXRDYWxlbmRhcjogZnVuY3Rpb24odCkge1xuICB2YXIgZTtcbiAgaWYgKHRoaXMuJGdhbnR0LmNvbmZpZy53b3JrX3RpbWUpIHtcbiAgICB2YXIgbiA9IHRoaXMuY2FsZW5kYXJNYW5hZ2VyO1xuICAgIHQudGFzayA/IGUgPSBuLmdldFRhc2tDYWxlbmRhcih0LnRhc2spIDogdC5pZCA/IGUgPSBuLmdldFRhc2tDYWxlbmRhcih0KSA6IHQuY2FsZW5kYXIgJiYgKGUgPSB0LmNhbGVuZGFyKSwgZSB8fCAoZSA9IG4uZ2V0VGFza0NhbGVuZGFyKCkpO1xuICB9IGVsc2UgZSA9IHRoaXMuJGRpc2FibGVkQ2FsZW5kYXI7XG4gIHJldHVybiBlO1xufSwgZ2V0V29ya0hvdXJzOiBmdW5jdGlvbih0KSB7XG4gIHJldHVybiB0ID0gdGhpcy5hcmd1bWVudHNIZWxwZXIuZ2V0V29ya0hvdXJzQXJndW1lbnRzLmFwcGx5KHRoaXMuYXJndW1lbnRzSGVscGVyLCBhcmd1bWVudHMpLCB0aGlzLl9nZXRDYWxlbmRhcih0KS5nZXRXb3JrSG91cnModC5kYXRlKTtcbn0sIHNldFdvcmtUaW1lOiBmdW5jdGlvbih0LCBlKSB7XG4gIHJldHVybiB0ID0gdGhpcy5hcmd1bWVudHNIZWxwZXIuc2V0V29ya1RpbWVBcmd1bWVudHMuYXBwbHkodGhpcy5hcmd1bWVudHNIZWxwZXIsIGFyZ3VtZW50cyksIGUgfHwgKGUgPSB0aGlzLmNhbGVuZGFyTWFuYWdlci5nZXRDYWxlbmRhcigpKSwgZS5zZXRXb3JrVGltZSh0KTtcbn0sIHVuc2V0V29ya1RpbWU6IGZ1bmN0aW9uKHQsIGUpIHtcbiAgcmV0dXJuIHQgPSB0aGlzLmFyZ3VtZW50c0hlbHBlci51bnNldFdvcmtUaW1lQXJndW1lbnRzLmFwcGx5KHRoaXMuYXJndW1lbnRzSGVscGVyLCBhcmd1bWVudHMpLCBlIHx8IChlID0gdGhpcy5jYWxlbmRhck1hbmFnZXIuZ2V0Q2FsZW5kYXIoKSksIGUudW5zZXRXb3JrVGltZSh0KTtcbn0sIGlzV29ya1RpbWU6IGZ1bmN0aW9uKHQsIGUsIG4sIGkpIHtcbiAgdmFyIGEgPSB0aGlzLmFyZ3VtZW50c0hlbHBlci5pc1dvcmtUaW1lQXJndW1lbnRzLmFwcGx5KHRoaXMuYXJndW1lbnRzSGVscGVyLCBhcmd1bWVudHMpO1xuICByZXR1cm4gKGkgPSB0aGlzLl9nZXRDYWxlbmRhcihhKSkuaXNXb3JrVGltZShhKTtcbn0sIGdldENsb3Nlc3RXb3JrVGltZTogZnVuY3Rpb24odCkge1xuICByZXR1cm4gdCA9IHRoaXMuYXJndW1lbnRzSGVscGVyLmdldENsb3Nlc3RXb3JrVGltZUFyZ3VtZW50cy5hcHBseSh0aGlzLmFyZ3VtZW50c0hlbHBlciwgYXJndW1lbnRzKSwgdGhpcy5fZ2V0Q2FsZW5kYXIodCkuZ2V0Q2xvc2VzdFdvcmtUaW1lKHQpO1xufSwgY2FsY3VsYXRlRHVyYXRpb246IGZ1bmN0aW9uKCkge1xuICB2YXIgdCA9IHRoaXMuYXJndW1lbnRzSGVscGVyLmdldER1cmF0aW9uQXJndW1lbnRzLmFwcGx5KHRoaXMuYXJndW1lbnRzSGVscGVyLCBhcmd1bWVudHMpO1xuICByZXR1cm4gdGhpcy5fZ2V0Q2FsZW5kYXIodCkuY2FsY3VsYXRlRHVyYXRpb24odCk7XG59LCBoYXNEdXJhdGlvbjogZnVuY3Rpb24oKSB7XG4gIHZhciB0ID0gdGhpcy5hcmd1bWVudHNIZWxwZXIuaGFzRHVyYXRpb25Bcmd1bWVudHMuYXBwbHkodGhpcy5hcmd1bWVudHNIZWxwZXIsIGFyZ3VtZW50cyk7XG4gIHJldHVybiB0aGlzLl9nZXRDYWxlbmRhcih0KS5oYXNEdXJhdGlvbih0KTtcbn0sIGNhbGN1bGF0ZUVuZERhdGU6IGZ1bmN0aW9uKHQpIHtcbiAgcmV0dXJuIHQgPSB0aGlzLmFyZ3VtZW50c0hlbHBlci5jYWxjdWxhdGVFbmREYXRlQXJndW1lbnRzLmFwcGx5KHRoaXMuYXJndW1lbnRzSGVscGVyLCBhcmd1bWVudHMpLCB0aGlzLl9nZXRDYWxlbmRhcih0KS5jYWxjdWxhdGVFbmREYXRlKHQpO1xufSB9O1xuY29uc3QgeGkgPSBmdW5jdGlvbih0LCBlKSB7XG4gIHJldHVybiB7IGdldFdvcmtIb3VyczogZnVuY3Rpb24obikge1xuICAgIHJldHVybiBlLmdldFdvcmtIb3VycyhuKTtcbiAgfSwgc2V0V29ya1RpbWU6IGZ1bmN0aW9uKG4pIHtcbiAgICByZXR1cm4gZS5zZXRXb3JrVGltZShuKTtcbiAgfSwgdW5zZXRXb3JrVGltZTogZnVuY3Rpb24obikge1xuICAgIGUudW5zZXRXb3JrVGltZShuKTtcbiAgfSwgaXNXb3JrVGltZTogZnVuY3Rpb24obiwgaSwgYSkge1xuICAgIHJldHVybiBlLmlzV29ya1RpbWUobiwgaSwgYSk7XG4gIH0sIGdldENsb3Nlc3RXb3JrVGltZTogZnVuY3Rpb24obikge1xuICAgIHJldHVybiBlLmdldENsb3Nlc3RXb3JrVGltZShuKTtcbiAgfSwgY2FsY3VsYXRlRHVyYXRpb246IGZ1bmN0aW9uKG4sIGksIGEpIHtcbiAgICByZXR1cm4gZS5jYWxjdWxhdGVEdXJhdGlvbihuLCBpLCBhKTtcbiAgfSwgX2hhc0R1cmF0aW9uOiBmdW5jdGlvbihuLCBpLCBhKSB7XG4gICAgcmV0dXJuIGUuaGFzRHVyYXRpb24obiwgaSwgYSk7XG4gIH0sIGNhbGN1bGF0ZUVuZERhdGU6IGZ1bmN0aW9uKG4sIGksIGEsIHIpIHtcbiAgICByZXR1cm4gZS5jYWxjdWxhdGVFbmREYXRlKG4sIGksIGEsIHIpO1xuICB9LCBtZXJnZUNhbGVuZGFyczogUih0Lm1lcmdlQ2FsZW5kYXJzLCB0KSwgY3JlYXRlQ2FsZW5kYXI6IFIodC5jcmVhdGVDYWxlbmRhciwgdCksIGFkZENhbGVuZGFyOiBSKHQuYWRkQ2FsZW5kYXIsIHQpLCBnZXRDYWxlbmRhcjogUih0LmdldENhbGVuZGFyLCB0KSwgZ2V0Q2FsZW5kYXJzOiBSKHQuZ2V0Q2FsZW5kYXJzLCB0KSwgZ2V0UmVzb3VyY2VDYWxlbmRhcjogUih0LmdldFJlc291cmNlQ2FsZW5kYXIsIHQpLCBnZXRUYXNrQ2FsZW5kYXI6IFIodC5nZXRUYXNrQ2FsZW5kYXIsIHQpLCBkZWxldGVDYWxlbmRhcjogUih0LmRlbGV0ZUNhbGVuZGFyLCB0KSB9O1xufTtcbmZ1bmN0aW9uICRpKHQpIHtcbiAgdC5pc1Vuc2NoZWR1bGVkVGFzayA9IGZ1bmN0aW9uKHMpIHtcbiAgICByZXR1cm4gdC5hc3NlcnQocyAmJiBzIGluc3RhbmNlb2YgT2JqZWN0LCBcIkludmFsaWQgYXJndW1lbnQgPGI+dGFzazwvYj49XCIgKyBzICsgXCIgb2YgZ2FudHQuaXNVbnNjaGVkdWxlZFRhc2suIFRhc2sgb2JqZWN0IHdhcyBleHBlY3RlZFwiKSwgISFzLnVuc2NoZWR1bGVkIHx8ICFzLnN0YXJ0X2RhdGU7XG4gIH0sIHQuX2lzQWxsb3dlZFVuc2NoZWR1bGVkVGFzayA9IGZ1bmN0aW9uKHMpIHtcbiAgICByZXR1cm4gISghcy51bnNjaGVkdWxlZCB8fCAhdC5jb25maWcuc2hvd191bnNjaGVkdWxlZCk7XG4gIH0sIHQuX2lzVGFza0luVGltZWxpbmVMaW1pdHMgPSBmdW5jdGlvbihzKSB7XG4gICAgdmFyIG8gPSBzLnN0YXJ0X2RhdGUgPyBzLnN0YXJ0X2RhdGUudmFsdWVPZigpIDogbnVsbCwgbCA9IHMuZW5kX2RhdGUgPyBzLmVuZF9kYXRlLnZhbHVlT2YoKSA6IG51bGw7XG4gICAgcmV0dXJuICEhKG8gJiYgbCAmJiBvIDw9IHRoaXMuX21heF9kYXRlLnZhbHVlT2YoKSAmJiBsID49IHRoaXMuX21pbl9kYXRlLnZhbHVlT2YoKSk7XG4gIH0sIHQuaXNUYXNrVmlzaWJsZSA9IGZ1bmN0aW9uKHMpIHtcbiAgICBpZiAoIXRoaXMuaXNUYXNrRXhpc3RzKHMpKSByZXR1cm4gITE7XG4gICAgdmFyIG8gPSB0aGlzLmdldFRhc2socyk7XG4gICAgcmV0dXJuICEoIXRoaXMuX2lzQWxsb3dlZFVuc2NoZWR1bGVkVGFzayhvKSAmJiAhdGhpcy5faXNUYXNrSW5UaW1lbGluZUxpbWl0cyhvKSkgJiYgdGhpcy5nZXRHbG9iYWxUYXNrSW5kZXgocykgPj0gMDtcbiAgfSwgdC5fZ2V0UHJvamVjdEVuZCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0LmNvbmZpZy5wcm9qZWN0X2VuZCkgcmV0dXJuIHQuY29uZmlnLnByb2plY3RfZW5kO1xuICAgIHZhciBzID0gdC5nZXRUYXNrQnlUaW1lKCk7XG4gICAgcmV0dXJuIChzID0gcy5zb3J0KGZ1bmN0aW9uKG8sIGwpIHtcbiAgICAgIHJldHVybiArby5lbmRfZGF0ZSA+ICtsLmVuZF9kYXRlID8gMSA6IC0xO1xuICAgIH0pKS5sZW5ndGggPyBzW3MubGVuZ3RoIC0gMV0uZW5kX2RhdGUgOiBudWxsO1xuICB9LCB0Ll9nZXRQcm9qZWN0U3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodC5jb25maWcucHJvamVjdF9zdGFydCkgcmV0dXJuIHQuY29uZmlnLnByb2plY3Rfc3RhcnQ7XG4gICAgaWYgKHQuY29uZmlnLnN0YXJ0X2RhdGUpIHJldHVybiB0LmNvbmZpZy5zdGFydF9kYXRlO1xuICAgIGlmICh0LmdldFN0YXRlKCkubWluX2RhdGUpIHJldHVybiB0LmdldFN0YXRlKCkubWluX2RhdGU7XG4gICAgdmFyIHMgPSB0LmdldFRhc2tCeVRpbWUoKTtcbiAgICByZXR1cm4gKHMgPSBzLnNvcnQoZnVuY3Rpb24obywgbCkge1xuICAgICAgcmV0dXJuICtvLnN0YXJ0X2RhdGUgPiArbC5zdGFydF9kYXRlID8gMSA6IC0xO1xuICAgIH0pKS5sZW5ndGggPyBzWzBdLnN0YXJ0X2RhdGUgOiBudWxsO1xuICB9O1xuICB2YXIgZSA9IGZ1bmN0aW9uKHMsIG8pIHtcbiAgICB2YXIgbCA9ICEhKG8gJiYgbyAhPSB0LmNvbmZpZy5yb290X2lkICYmIHQuaXNUYXNrRXhpc3RzKG8pKSAmJiB0LmdldFRhc2sobyksIGQgPSBudWxsO1xuICAgIGlmIChsKSBpZiAodC5jb25maWcuc2NoZWR1bGVfZnJvbV9lbmQpIGQgPSB0LmNhbGN1bGF0ZUVuZERhdGUoeyBzdGFydF9kYXRlOiBsLmVuZF9kYXRlLCBkdXJhdGlvbjogLXQuY29uZmlnLmR1cmF0aW9uX3N0ZXAsIHRhc2s6IHMgfSk7XG4gICAgZWxzZSB7XG4gICAgICBpZiAoIWwuc3RhcnRfZGF0ZSkgcmV0dXJuIGUobCwgdC5nZXRQYXJlbnQobCkpO1xuICAgICAgZCA9IGwuc3RhcnRfZGF0ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAodC5jb25maWcuc2NoZWR1bGVfZnJvbV9lbmQpIGQgPSB0LmNhbGN1bGF0ZUVuZERhdGUoeyBzdGFydF9kYXRlOiB0Ll9nZXRQcm9qZWN0RW5kKCksIGR1cmF0aW9uOiAtdC5jb25maWcuZHVyYXRpb25fc3RlcCwgdGFzazogcyB9KTtcbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IGMgPSB0LmdldFRhc2tCeUluZGV4KDApLCB1ID0gdC5jb25maWcuc3RhcnRfZGF0ZSB8fCB0LmdldFN0YXRlKCkubWluX2RhdGU7XG4gICAgICBkID0gYyA/IGMuc3RhcnRfZGF0ZSA/IGMuc3RhcnRfZGF0ZSA6IGMuZW5kX2RhdGUgPyB0LmNhbGN1bGF0ZUVuZERhdGUoeyBzdGFydF9kYXRlOiBjLmVuZF9kYXRlLCBkdXJhdGlvbjogLXQuY29uZmlnLmR1cmF0aW9uX3N0ZXAsIHRhc2s6IHMgfSkgOiB1IDogdTtcbiAgICB9XG4gICAgcmV0dXJuIHQuYXNzZXJ0KGQsIFwiSW52YWxpZCBkYXRlc1wiKSwgbmV3IERhdGUoZCk7XG4gIH07XG4gIHQuX3NldF9kZWZhdWx0X3Rhc2tfdGltaW5nID0gZnVuY3Rpb24ocykge1xuICAgIHMuc3RhcnRfZGF0ZSA9IHMuc3RhcnRfZGF0ZSB8fCBlKHMsIHQuZ2V0UGFyZW50KHMpKSwgcy5kdXJhdGlvbiA9IHMuZHVyYXRpb24gfHwgdC5jb25maWcuZHVyYXRpb25fc3RlcCwgcy5lbmRfZGF0ZSA9IHMuZW5kX2RhdGUgfHwgdC5jYWxjdWxhdGVFbmREYXRlKHMpO1xuICB9LCB0LmNyZWF0ZVRhc2sgPSBmdW5jdGlvbihzLCBvLCBsKSB7XG4gICAgaWYgKHMgPSBzIHx8IHt9LCB0LmRlZmluZWQocy5pZCkgfHwgKHMuaWQgPSB0LnVpZCgpKSwgcy5zdGFydF9kYXRlIHx8IChzLnN0YXJ0X2RhdGUgPSBlKHMsIG8pKSwgcy50ZXh0ID09PSB2b2lkIDAgJiYgKHMudGV4dCA9IHQubG9jYWxlLmxhYmVscy5uZXdfdGFzayksIHMuZHVyYXRpb24gPT09IHZvaWQgMCAmJiAocy5kdXJhdGlvbiA9IDEpLCB0aGlzLmlzVGFza0V4aXN0cyhvKSkge1xuICAgICAgdGhpcy5zZXRQYXJlbnQocywgbywgITApO1xuICAgICAgdmFyIGQgPSB0aGlzLmdldFRhc2sobyk7XG4gICAgICBkLiRvcGVuID0gITAsIHRoaXMuY29uZmlnLmRldGFpbHNfb25fY3JlYXRlIHx8IHRoaXMuY2FsbEV2ZW50KFwib25BZnRlclBhcmVudEV4cGFuZFwiLCBbbywgZF0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jYWxsRXZlbnQoXCJvblRhc2tDcmVhdGVkXCIsIFtzXSkgPyAodGhpcy5jb25maWcuZGV0YWlsc19vbl9jcmVhdGUgPyAodC5pc1Rhc2tFeGlzdHMocy5pZCkgPyB0LmdldFRhc2socy5pZCkuJGluZGV4ICE9IHMuJGluZGV4ICYmIChzLnN0YXJ0X2RhdGUgJiYgdHlwZW9mIHMuc3RhcnRfZGF0ZSA9PSBcInN0cmluZ1wiICYmIChzLnN0YXJ0X2RhdGUgPSB0aGlzLmRhdGUucGFyc2VEYXRlKHMuc3RhcnRfZGF0ZSwgXCJwYXJzZV9kYXRlXCIpKSwgcy5lbmRfZGF0ZSAmJiB0eXBlb2Ygcy5lbmRfZGF0ZSA9PSBcInN0cmluZ1wiICYmIChzLmVuZF9kYXRlID0gdGhpcy5kYXRlLnBhcnNlRGF0ZShzLmVuZF9kYXRlLCBcInBhcnNlX2RhdGVcIikpLCB0aGlzLiRkYXRhLnRhc2tzU3RvcmUudXBkYXRlSXRlbShzLmlkLCBzKSkgOiAocy4kbmV3ID0gITAsIHRoaXMuc2lsZW50KGZ1bmN0aW9uKCkge1xuICAgICAgdC4kZGF0YS50YXNrc1N0b3JlLmFkZEl0ZW0ocywgbCk7XG4gICAgfSkpLCB0aGlzLnNlbGVjdFRhc2socy5pZCksIHRoaXMucmVmcmVzaERhdGEoKSwgdGhpcy5zaG93TGlnaHRib3gocy5pZCkpIDogdGhpcy5hZGRUYXNrKHMsIG8sIGwpICYmICh0aGlzLnNob3dUYXNrKHMuaWQpLCB0aGlzLnNlbGVjdFRhc2socy5pZCkpLCBzLmlkKSA6IG51bGw7XG4gIH0sIHQuX3VwZGF0ZV9mbGFncyA9IGZ1bmN0aW9uKHMsIG8pIHtcbiAgICB2YXIgbCA9IHQuJGRhdGEudGFza3NTdG9yZTtcbiAgICBzID09PSB2b2lkIDAgPyAodGhpcy5fbGlnaHRib3hfaWQgPSBudWxsLCBsLnNpbGVudChmdW5jdGlvbigpIHtcbiAgICAgIGwudW5zZWxlY3QoKTtcbiAgICB9KSwgdGhpcy5nZXRTZWxlY3RlZFRhc2tzICYmIHRoaXMuX211bHRpc2VsZWN0LnJlc2V0KCksIHRoaXMuX3Rhc2tzX2RuZCAmJiB0aGlzLl90YXNrc19kbmQuZHJhZyAmJiAodGhpcy5fdGFza3NfZG5kLmRyYWcuaWQgPSBudWxsKSkgOiAodGhpcy5fbGlnaHRib3hfaWQgPT0gcyAmJiAodGhpcy5fbGlnaHRib3hfaWQgPSBvKSwgbC5nZXRTZWxlY3RlZElkKCkgPT0gcyAmJiBsLnNpbGVudChmdW5jdGlvbigpIHtcbiAgICAgIGwudW5zZWxlY3QocyksIGwuc2VsZWN0KG8pO1xuICAgIH0pLCB0aGlzLl90YXNrc19kbmQgJiYgdGhpcy5fdGFza3NfZG5kLmRyYWcgJiYgdGhpcy5fdGFza3NfZG5kLmRyYWcuaWQgPT0gcyAmJiAodGhpcy5fdGFza3NfZG5kLmRyYWcuaWQgPSBvKSk7XG4gIH07XG4gIHZhciBuID0gZnVuY3Rpb24ocywgbykge1xuICAgIHZhciBsID0gdC5nZXRUYXNrVHlwZShzLnR5cGUpLCBkID0geyB0eXBlOiBsLCAkbm9fc3RhcnQ6ICExLCAkbm9fZW5kOiAhMSwgc2NoZWR1bGVkX3N1bW1hcnk6ICExIH07XG4gICAgcmV0dXJuIGwgPT09IHQuY29uZmlnLnR5cGVzLnByb2plY3QgJiYgcy5hdXRvX3NjaGVkdWxpbmcgPT09ICExICYmIChkLnNjaGVkdWxlZF9zdW1tYXJ5ID0gITApLCBvIHx8IGwgIT0gcy4kcmVuZGVyZWRfdHlwZSA/IChsID09IHQuY29uZmlnLnR5cGVzLnByb2plY3QgPyBkLiRub19lbmQgPSBkLiRub19zdGFydCA9ICEwIDogbCAhPSB0LmNvbmZpZy50eXBlcy5taWxlc3RvbmUgJiYgKGQuJG5vX2VuZCA9ICEocy5lbmRfZGF0ZSB8fCBzLmR1cmF0aW9uKSwgZC4kbm9fc3RhcnQgPSAhcy5zdGFydF9kYXRlLCB0Ll9pc0FsbG93ZWRVbnNjaGVkdWxlZFRhc2socykgJiYgKGQuJG5vX2VuZCA9IGQuJG5vX3N0YXJ0ID0gITEpKSwgZCkgOiAoZC4kbm9fc3RhcnQgPSBzLiRub19zdGFydCwgZC4kbm9fZW5kID0gcy4kbm9fZW5kLCBkKTtcbiAgfTtcbiAgZnVuY3Rpb24gaShzKSB7XG4gICAgcy4kZWZmZWN0aXZlX2NhbGVuZGFyID0gdC5nZXRUYXNrQ2FsZW5kYXIocykuaWQsIHMuc3RhcnRfZGF0ZSA9IHQuZ2V0Q2xvc2VzdFdvcmtUaW1lKHsgZGlyOiBcImZ1dHVyZVwiLCBkYXRlOiBzLnN0YXJ0X2RhdGUsIHVuaXQ6IHQuY29uZmlnLmR1cmF0aW9uX3VuaXQsIHRhc2s6IHMgfSksIHMuZW5kX2RhdGUgPSB0LmNhbGN1bGF0ZUVuZERhdGUocyk7XG4gIH1cbiAgZnVuY3Rpb24gYShzLCBvLCBsLCBkKSB7XG4gICAgY29uc3QgYyA9IHsgc3RhcnQ6IFwic3RhcnRfZGF0ZVwiLCBlbmQ6IFwiZW5kX2RhdGVcIiB9LCB1ID0geyBzdGFydDogXCIkYXV0b19zdGFydF9kYXRlXCIsIGVuZDogXCIkYXV0b19lbmRfZGF0ZVwiIH07XG4gICAgbGV0IGg7XG4gICAgaCA9IHMudHlwZSA9PT0gdC5jb25maWcudHlwZXMucHJvamVjdCAmJiBzLmF1dG9fc2NoZWR1bGluZyA9PT0gITEgPyB1IDogYywgby4kbm9fc3RhcnQgJiYgKHNbaC5zdGFydF0gPSBsID8gbmV3IERhdGUobCkgOiBlKHMsIHRoaXMuZ2V0UGFyZW50KHMpKSksIG8uJG5vX2VuZCAmJiAoc1toLmVuZF0gPSBkID8gbmV3IERhdGUoZCkgOiB0aGlzLmNhbGN1bGF0ZUVuZERhdGUoeyBzdGFydF9kYXRlOiBzW2guc3RhcnRdLCBkdXJhdGlvbjogdGhpcy5jb25maWcuZHVyYXRpb25fc3RlcCwgdGFzazogcyB9KSksIChvLiRub19zdGFydCB8fCBvLiRub19lbmQpICYmIHRoaXMuX2luaXRfdGFza190aW1pbmcocyk7XG4gIH1cbiAgZnVuY3Rpb24gcihzKSB7XG4gICAgdmFyIG8gPSBudWxsLCBsID0gbnVsbCwgZCA9IHMgIT09IHZvaWQgMCA/IHMgOiB0LmNvbmZpZy5yb290X2lkLCBjID0gW107XG4gICAgcmV0dXJuIHQuZWFjaFRhc2soZnVuY3Rpb24odSkge1xuICAgICAgY29uc3QgaCA9IHQuZ2V0VGFza1R5cGUodS50eXBlKSA9PSB0LmNvbmZpZy50eXBlcy5wcm9qZWN0ICYmIHUuYXV0b19zY2hlZHVsaW5nID09PSAhMTtcbiAgICAgIHQuZ2V0VGFza1R5cGUodS50eXBlKSA9PSB0LmNvbmZpZy50eXBlcy5wcm9qZWN0ICYmICFoIHx8IHQuaXNVbnNjaGVkdWxlZFRhc2sodSkgfHwgKHUucm9sbHVwICYmIGMucHVzaCh1LmlkKSwgIXUuc3RhcnRfZGF0ZSB8fCB1LiRub19zdGFydCAmJiAhaCB8fCBvICYmICEobyA+IHUuc3RhcnRfZGF0ZS52YWx1ZU9mKCkpIHx8IChvID0gdS5zdGFydF9kYXRlLnZhbHVlT2YoKSksICF1LmVuZF9kYXRlIHx8IHUuJG5vX2VuZCAmJiAhaCB8fCBsICYmICEobCA8IHUuZW5kX2RhdGUudmFsdWVPZigpKSB8fCAobCA9IHUuZW5kX2RhdGUudmFsdWVPZigpKSk7XG4gICAgfSwgZCksIHsgc3RhcnRfZGF0ZTogbyA/IG5ldyBEYXRlKG8pIDogbnVsbCwgZW5kX2RhdGU6IGwgPyBuZXcgRGF0ZShsKSA6IG51bGwsIHJvbGx1cDogYyB9O1xuICB9XG4gIHQuX2luaXRfdGFza190aW1pbmcgPSBmdW5jdGlvbihzKSB7XG4gICAgdmFyIG8gPSBuKHMsICEwKSwgbCA9IHMuJHJlbmRlcmVkX3R5cGUgIT0gby50eXBlLCBkID0gby50eXBlO1xuICAgIGwgJiYgKHMuJG5vX3N0YXJ0ID0gby4kbm9fc3RhcnQsIHMuJG5vX2VuZCA9IG8uJG5vX2VuZCwgcy4kcmVuZGVyZWRfdHlwZSA9IG8udHlwZSksIGwgJiYgZCAhPSB0aGlzLmNvbmZpZy50eXBlcy5taWxlc3RvbmUgJiYgZCA9PSB0aGlzLmNvbmZpZy50eXBlcy5wcm9qZWN0ICYmICh0aGlzLl9zZXRfZGVmYXVsdF90YXNrX3RpbWluZyhzKSwgcy4kY2FsY3VsYXRlX2R1cmF0aW9uID0gITEpLCBkID09IHRoaXMuY29uZmlnLnR5cGVzLm1pbGVzdG9uZSAmJiAocy5lbmRfZGF0ZSA9IHMuc3RhcnRfZGF0ZSksIHMuc3RhcnRfZGF0ZSAmJiBzLmVuZF9kYXRlICYmIHMuJGNhbGN1bGF0ZV9kdXJhdGlvbiAhPT0gITEgJiYgKHMuZHVyYXRpb24gPSB0aGlzLmNhbGN1bGF0ZUR1cmF0aW9uKHMpKSwgcy4kY2FsY3VsYXRlX2R1cmF0aW9uIHx8IChzLiRjYWxjdWxhdGVfZHVyYXRpb24gPSAhMCksIHMuZW5kX2RhdGUgfHwgKHMuZW5kX2RhdGUgPSBzLnN0YXJ0X2RhdGUpLCBzLmR1cmF0aW9uID0gcy5kdXJhdGlvbiB8fCAwLCB0aGlzLmNvbmZpZy5taW5fZHVyYXRpb24gPT09IDAgJiYgcy5kdXJhdGlvbiA9PT0gMCAmJiAocy4kbm9fZW5kID0gITEpO1xuICAgIHZhciBjID0gdGhpcy5nZXRUYXNrQ2FsZW5kYXIocyk7XG4gICAgcy4kZWZmZWN0aXZlX2NhbGVuZGFyICYmIHMuJGVmZmVjdGl2ZV9jYWxlbmRhciAhPT0gYy5pZCAmJiAoaShzKSwgdGhpcy5jb25maWcuaW5oZXJpdF9jYWxlbmRhciAmJiB0aGlzLmlzU3VtbWFyeVRhc2socykgJiYgdGhpcy5lYWNoVGFzayhmdW5jdGlvbih1KSB7XG4gICAgICBpKHUpO1xuICAgIH0sIHMuaWQpKSwgcy4kZWZmZWN0aXZlX2NhbGVuZGFyID0gYy5pZDtcbiAgfSwgdC5pc1N1bW1hcnlUYXNrID0gZnVuY3Rpb24ocykge1xuICAgIHQuYXNzZXJ0KHMgJiYgcyBpbnN0YW5jZW9mIE9iamVjdCwgXCJJbnZhbGlkIGFyZ3VtZW50IDxiPnRhc2s8L2I+PVwiICsgcyArIFwiIG9mIGdhbnR0LmlzU3VtbWFyeVRhc2suIFRhc2sgb2JqZWN0IHdhcyBleHBlY3RlZFwiKTtcbiAgICB2YXIgbyA9IG4ocyk7XG4gICAgcmV0dXJuICEoIW8uJG5vX2VuZCAmJiAhby4kbm9fc3RhcnQpO1xuICB9LCB0LnJlc2V0UHJvamVjdERhdGVzID0gZnVuY3Rpb24ocykge1xuICAgIHZhciBvID0gbihzKTtcbiAgICBpZiAoby4kbm9fZW5kIHx8IG8uJG5vX3N0YXJ0KSB7XG4gICAgICB2YXIgbCA9IHIocy5pZCk7XG4gICAgICBhLmNhbGwodGhpcywgcywgbywgbC5zdGFydF9kYXRlLCBsLmVuZF9kYXRlKSwgcy4kcm9sbHVwID0gbC5yb2xsdXA7XG4gICAgfVxuICB9LCB0LmdldFN1YnRhc2tEdXJhdGlvbiA9IGZ1bmN0aW9uKHMpIHtcbiAgICB2YXIgbyA9IDAsIGwgPSBzICE9PSB2b2lkIDAgPyBzIDogdC5jb25maWcucm9vdF9pZDtcbiAgICByZXR1cm4gdGhpcy5lYWNoVGFzayhmdW5jdGlvbihkKSB7XG4gICAgICB0aGlzLmdldFRhc2tUeXBlKGQudHlwZSkgPT0gdC5jb25maWcudHlwZXMucHJvamVjdCB8fCB0aGlzLmlzVW5zY2hlZHVsZWRUYXNrKGQpIHx8IChvICs9IGQuZHVyYXRpb24pO1xuICAgIH0sIGwpLCBvO1xuICB9LCB0LmdldFN1YnRhc2tEYXRlcyA9IGZ1bmN0aW9uKHMpIHtcbiAgICB2YXIgbyA9IHIocyk7XG4gICAgcmV0dXJuIHsgc3RhcnRfZGF0ZTogby5zdGFydF9kYXRlLCBlbmRfZGF0ZTogby5lbmRfZGF0ZSB9O1xuICB9LCB0Ll91cGRhdGVfcGFyZW50cyA9IGZ1bmN0aW9uKHMsIG8sIGwpIHtcbiAgICBpZiAocykge1xuICAgICAgdmFyIGQgPSB0aGlzLmdldFRhc2socyk7XG4gICAgICBkLnJvbGx1cCAmJiAobCA9ICEwKTtcbiAgICAgIHZhciBjID0gdGhpcy5nZXRQYXJlbnQoZCksIHUgPSBuKGQpLCBoID0gITA7XG4gICAgICBpZiAobCB8fCBkLnN0YXJ0X2RhdGUgJiYgZC5lbmRfZGF0ZSAmJiAodS4kbm9fc3RhcnQgfHwgdS4kbm9fZW5kKSkge1xuICAgICAgICBjb25zdCB5ID0gZC4kYXV0b19zdGFydF9kYXRlID8gXCIkYXV0b19zdGFydF9kYXRlXCIgOiBcInN0YXJ0X2RhdGVcIiwgdiA9IGQuJGF1dG9fZW5kX2RhdGUgPyBcIiRhdXRvX2VuZF9kYXRlXCIgOiBcImVuZF9kYXRlXCI7XG4gICAgICAgIHZhciBnID0gZFt5XS52YWx1ZU9mKCksIHAgPSBkW3ZdLnZhbHVlT2YoKTtcbiAgICAgICAgdC5yZXNldFByb2plY3REYXRlcyhkKSwgbCB8fCBnICE9IGRbeV0udmFsdWVPZigpIHx8IHAgIT0gZFt2XS52YWx1ZU9mKCkgfHwgKGggPSAhMSksIGggJiYgIW8gJiYgdGhpcy5yZWZyZXNoVGFzayhkLmlkLCAhMCksIHUuc2NoZWR1bGVkX3N1bW1hcnkgJiYgKGggPSAhMCk7XG4gICAgICB9XG4gICAgICBoICYmIGMgJiYgdGhpcy5pc1Rhc2tFeGlzdHMoYykgJiYgdGhpcy5fdXBkYXRlX3BhcmVudHMoYywgbywgbCk7XG4gICAgfVxuICB9LCB0LnJvdW5kRGF0ZSA9IGZ1bmN0aW9uKHMpIHtcbiAgICB2YXIgbyA9IHQuZ2V0U2NhbGUoKTtcbiAgICBaKHMpICYmIChzID0geyBkYXRlOiBzLCB1bml0OiBvID8gby51bml0IDogdC5jb25maWcuZHVyYXRpb25fdW5pdCwgc3RlcDogbyA/IG8uc3RlcCA6IHQuY29uZmlnLmR1cmF0aW9uX3N0ZXAgfSk7XG4gICAgdmFyIGwsIGQsIGMsIHUgPSBzLmRhdGUsIGggPSBzLnN0ZXAsIGcgPSBzLnVuaXQ7XG4gICAgaWYgKCFvKSByZXR1cm4gdTtcbiAgICBpZiAoZyA9PSBvLnVuaXQgJiYgaCA9PSBvLnN0ZXAgJiYgK3UgPj0gK28ubWluX2RhdGUgJiYgK3UgPD0gK28ubWF4X2RhdGUpIGMgPSBNYXRoLmZsb29yKHQuY29sdW1uSW5kZXhCeURhdGUodSkpLCBvLnRyYWNlX3hbY10gfHwgKGMgLT0gMSwgby5ydGwgJiYgKGMgPSAwKSksIGQgPSBuZXcgRGF0ZShvLnRyYWNlX3hbY10pLCBsID0gdC5kYXRlLmFkZChkLCBoLCBnKTtcbiAgICBlbHNlIHtcbiAgICAgIGZvciAoYyA9IE1hdGguZmxvb3IodC5jb2x1bW5JbmRleEJ5RGF0ZSh1KSksIGwgPSB0LmRhdGVbZyArIFwiX3N0YXJ0XCJdKG5ldyBEYXRlKG8ubWluX2RhdGUpKSwgby50cmFjZV94W2NdICYmIChsID0gdC5kYXRlW2cgKyBcIl9zdGFydFwiXShvLnRyYWNlX3hbY10pKTsgK2wgPCArdTsgKSB7XG4gICAgICAgIHZhciBwID0gKGwgPSB0LmRhdGVbZyArIFwiX3N0YXJ0XCJdKHQuZGF0ZS5hZGQobCwgaCwgZykpKS5nZXRUaW1lem9uZU9mZnNldCgpO1xuICAgICAgICBsID0gdC5fY29ycmVjdF9kc3RfY2hhbmdlKGwsIHAsIGwsIGcpLCB0LmRhdGVbZyArIFwiX3N0YXJ0XCJdICYmIChsID0gdC5kYXRlW2cgKyBcIl9zdGFydFwiXShsKSk7XG4gICAgICB9XG4gICAgICBkID0gdC5kYXRlLmFkZChsLCAtMSAqIGgsIGcpO1xuICAgIH1cbiAgICByZXR1cm4gcy5kaXIgJiYgcy5kaXIgPT0gXCJmdXR1cmVcIiA/IGwgOiBzLmRpciAmJiBzLmRpciA9PSBcInBhc3RcIiB8fCBNYXRoLmFicyh1IC0gZCkgPCBNYXRoLmFicyhsIC0gdSkgPyBkIDogbDtcbiAgfSwgdC5jb3JyZWN0VGFza1dvcmtUaW1lID0gZnVuY3Rpb24ocykge1xuICAgIHQuY29uZmlnLndvcmtfdGltZSAmJiB0LmNvbmZpZy5jb3JyZWN0X3dvcmtfdGltZSAmJiAodGhpcy5pc1dvcmtUaW1lKHMuc3RhcnRfZGF0ZSwgdm9pZCAwLCBzKSA/IHRoaXMuaXNXb3JrVGltZShuZXcgRGF0ZSgrcy5lbmRfZGF0ZSAtIDEpLCB2b2lkIDAsIHMpIHx8IChzLmVuZF9kYXRlID0gdGhpcy5jYWxjdWxhdGVFbmREYXRlKHMpKSA6IChzLnN0YXJ0X2RhdGUgPSB0aGlzLmdldENsb3Nlc3RXb3JrVGltZSh7IGRhdGU6IHMuc3RhcnRfZGF0ZSwgZGlyOiBcImZ1dHVyZVwiLCB0YXNrOiBzIH0pLCBzLmVuZF9kYXRlID0gdGhpcy5jYWxjdWxhdGVFbmREYXRlKHMpKSk7XG4gIH0sIHQuYXR0YWNoRXZlbnQoXCJvbkJlZm9yZVRhc2tVcGRhdGVcIiwgZnVuY3Rpb24ocywgbykge1xuICAgIHJldHVybiB0Ll9pbml0X3Rhc2tfdGltaW5nKG8pLCAhMDtcbiAgfSksIHQuYXR0YWNoRXZlbnQoXCJvbkJlZm9yZVRhc2tBZGRcIiwgZnVuY3Rpb24ocywgbykge1xuICAgIHJldHVybiB0Ll9pbml0X3Rhc2tfdGltaW5nKG8pLCAhMDtcbiAgfSksIHQuYXR0YWNoRXZlbnQoXCJvbkFmdGVyVGFza01vdmVcIiwgZnVuY3Rpb24ocywgbywgbCkge1xuICAgIHJldHVybiB0Ll9pbml0X3Rhc2tfdGltaW5nKHQuZ2V0VGFzayhzKSksICEwO1xuICB9KTtcbn1cbmZ1bmN0aW9uIE9lKHQsIGUpIHtcbiAgdmFyIG4sIGkgPSB0LmNvbmZpZy5jb250YWluZXJfcmVzaXplX3RpbWVvdXQgfHwgMjA7XG4gIGxldCBhID0gQmUodCk7XG4gIGlmICh0LmNvbmZpZy5jb250YWluZXJfcmVzaXplX21ldGhvZCA9PSBcInRpbWVvdXRcIikgbCgpO1xuICBlbHNlIHRyeSB7XG4gICAgdC5ldmVudChlLCBcInJlc2l6ZVwiLCBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0LiRzY3JvbGxiYXJSZXBhaW50KSB0LiRzY3JvbGxiYXJSZXBhaW50ID0gbnVsbDtcbiAgICAgIGVsc2Uge1xuICAgICAgICBsZXQgZCA9IEJlKHQpO1xuICAgICAgICBpZiAoYS54ID09IGQueCAmJiBhLnkgPT0gZC55KSByZXR1cm47XG4gICAgICAgIGEgPSBkLCByKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0gY2F0Y2gge1xuICAgIGwoKTtcbiAgfVxuICBmdW5jdGlvbiByKCkge1xuICAgIGNsZWFyVGltZW91dChuKSwgbiA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICB0LiRkZXN0cm95ZWQgfHwgdC5yZW5kZXIoKTtcbiAgICB9LCBpKTtcbiAgfVxuICB2YXIgcyA9IHQuJHJvb3Qub2Zmc2V0SGVpZ2h0LCBvID0gdC4kcm9vdC5vZmZzZXRXaWR0aDtcbiAgZnVuY3Rpb24gbCgpIHtcbiAgICB0LiRyb290Lm9mZnNldEhlaWdodCA9PSBzICYmIHQuJHJvb3Qub2Zmc2V0V2lkdGggPT0gbyB8fCByKCksIHMgPSB0LiRyb290Lm9mZnNldEhlaWdodCwgbyA9IHQuJHJvb3Qub2Zmc2V0V2lkdGgsIHNldFRpbWVvdXQobCwgaSk7XG4gIH1cbn1cbmZ1bmN0aW9uIEJlKHQpIHtcbiAgcmV0dXJuIHsgeDogdC4kcm9vdC5vZmZzZXRXaWR0aCwgeTogdC4kcm9vdC5vZmZzZXRIZWlnaHQgfTtcbn1cbmZ1bmN0aW9uIHdpKHQpIHtcbiAgdC5hc3NlcnQgPSAvKiBAX19QVVJFX18gKi8gZnVuY3Rpb24ocikge1xuICAgIHJldHVybiBmdW5jdGlvbihzLCBvKSB7XG4gICAgICBzIHx8IHIuY29uZmlnLnNob3dfZXJyb3JzICYmIHIuY2FsbEV2ZW50KFwib25FcnJvclwiLCBbb10pICE9PSAhMSAmJiAoci5tZXNzYWdlID8gci5tZXNzYWdlKHsgdHlwZTogXCJlcnJvclwiLCB0ZXh0OiBvLCBleHBpcmU6IC0xIH0pIDogY29uc29sZS5sb2cobykpO1xuICAgIH07XG4gIH0odCk7XG4gIHZhciBlID0gXCJJbnZhbGlkIHZhbHVlIG9mIHRoZSBmaXJzdCBhcmd1bWVudCBvZiBgZ2FudHQuaW5pdGAuIFN1cHBvcnRlZCB2YWx1ZXM6IEhUTUxFbGVtZW50LCBTdHJpbmcgKGVsZW1lbnQgaWQpLlRoaXMgZXJyb3IgbWVhbnMgdGhhdCBlaXRoZXIgaW52YWxpZCBvYmplY3QgaXMgcGFzc2VkIGludG8gYGdhbnR0LmluaXRgIG9yIHRoYXQgdGhlIGVsZW1lbnQgd2l0aCB0aGUgc3BlY2lmaWVkIElEIGRvZXNuJ3QgZXhpc3Qgb24gdGhlIHBhZ2Ugd2hlbiBgZ2FudHQuaW5pdGAgaXMgY2FsbGVkLlwiO1xuICBmdW5jdGlvbiBuKHIpIHtcbiAgICBpZiAoIXIgfHwgdHlwZW9mIHIgPT0gXCJzdHJpbmdcIiAmJiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChyKSB8fCBmdW5jdGlvbihzKSB7XG4gICAgICB0cnkge1xuICAgICAgICBzLmNsb25lTm9kZSghMSk7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgfVxuICAgICAgcmV0dXJuICEwO1xuICAgIH0ocikpIHJldHVybiAhMDtcbiAgICB0aHJvdyB0LmFzc2VydCghMSwgZSksIG5ldyBFcnJvcihlKTtcbiAgfVxuICB0LmluaXQgPSBmdW5jdGlvbihyLCBzLCBvKSB7XG4gICAgdC5lbnYuaXNOb2RlID8gciA9IG51bGwgOiBuKHIpLCBzICYmIG8gJiYgKHRoaXMuY29uZmlnLnN0YXJ0X2RhdGUgPSB0aGlzLl9taW5fZGF0ZSA9IG5ldyBEYXRlKHMpLCB0aGlzLmNvbmZpZy5lbmRfZGF0ZSA9IHRoaXMuX21heF9kYXRlID0gbmV3IERhdGUobykpLCB0aGlzLmRhdGUuaW5pdCgpLCB0aGlzLmluaXQgPSBmdW5jdGlvbihsKSB7XG4gICAgICB0LmVudi5pc05vZGUgPyBsID0gbnVsbCA6IG4obCksIHRoaXMuJGNvbnRhaW5lciAmJiB0aGlzLiRjb250YWluZXIucGFyZW50Tm9kZSAmJiAodGhpcy4kY29udGFpbmVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy4kY29udGFpbmVyKSwgdGhpcy4kY29udGFpbmVyID0gbnVsbCksIHRoaXMuJGxheW91dCAmJiB0aGlzLiRsYXlvdXQuY2xlYXIoKSwgdGhpcy5fcmVpbml0KGwpO1xuICAgIH0sIHRoaXMuX3JlaW5pdChyKTtcbiAgfSwgdC5fcXVpY2tSZWZyZXNoID0gZnVuY3Rpb24ocikge1xuICAgIGZvciAodmFyIHMgPSB0aGlzLl9nZXREYXRhc3RvcmVzLmNhbGwodGhpcyksIG8gPSAwOyBvIDwgcy5sZW5ndGg7IG8rKykgc1tvXS5fcXVpY2tfcmVmcmVzaCA9ICEwO1xuICAgIGZvciAocigpLCBvID0gMDsgbyA8IHMubGVuZ3RoOyBvKyspIHNbb10uX3F1aWNrX3JlZnJlc2ggPSAhMTtcbiAgfTtcbiAgdmFyIGkgPSAoZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fY2xlYXJUYXNrTGF5ZXJzICYmIHRoaXMuX2NsZWFyVGFza0xheWVycygpLCB0aGlzLl9jbGVhckxpbmtMYXllcnMgJiYgdGhpcy5fY2xlYXJMaW5rTGF5ZXJzKCksIHRoaXMuJGxheW91dCAmJiAodGhpcy4kbGF5b3V0LmRlc3RydWN0b3IoKSwgdGhpcy4kbGF5b3V0ID0gbnVsbCwgdGhpcy4kdWkucmVzZXQoKSk7XG4gIH0pLmJpbmQodCksIGEgPSAoZnVuY3Rpb24oKSB7XG4gICAgRih0KSB8fCAodGhpcy4kcm9vdC5pbm5lckhUTUwgPSBcIlwiLCB0aGlzLiRyb290LmdhbnR0ID0gdGhpcywgbWUodGhpcyksIHRoaXMuY29uZmlnLmxheW91dC5pZCA9IFwibWFpblwiLCB0aGlzLiRsYXlvdXQgPSB0aGlzLiR1aS5jcmVhdGVWaWV3KFwibGF5b3V0XCIsIHRoaXMuJHJvb3QsIHRoaXMuY29uZmlnLmxheW91dCksIHRoaXMuJGxheW91dC5hdHRhY2hFdmVudChcIm9uQmVmb3JlUmVzaXplXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgZm9yICh2YXIgciA9IHQuJHNlcnZpY2VzLmdldFNlcnZpY2UoXCJkYXRhc3RvcmVzXCIpLCBzID0gMDsgcyA8IHIubGVuZ3RoOyBzKyspIHQuZ2V0RGF0YXN0b3JlKHJbc10pLmZpbHRlcigpLCB0LiRkYXRhLnRhc2tzU3RvcmUuX3NraXBUYXNrUmVjYWxjdWxhdGlvbiA/IHQuJGRhdGEudGFza3NTdG9yZS5fc2tpcFRhc2tSZWNhbGN1bGF0aW9uICE9IFwibGlnaHRib3hcIiAmJiAodC4kZGF0YS50YXNrc1N0b3JlLl9za2lwVGFza1JlY2FsY3VsYXRpb24gPSAhMSkgOiB0LmdldERhdGFzdG9yZShyW3NdKS5jYWxsRXZlbnQoXCJvbkJlZm9yZVJlZnJlc2hBbGxcIiwgW10pO1xuICAgIH0pLCB0aGlzLiRsYXlvdXQuYXR0YWNoRXZlbnQoXCJvblJlc2l6ZVwiLCBmdW5jdGlvbigpIHtcbiAgICAgIHQuX3F1aWNrUmVmcmVzaChmdW5jdGlvbigpIHtcbiAgICAgICAgdC5yZWZyZXNoRGF0YSgpO1xuICAgICAgfSk7XG4gICAgfSksIHRoaXMuY2FsbEV2ZW50KFwib25HYW50dExheW91dFJlYWR5XCIsIFtdKSwgdGhpcy4kbGF5b3V0LnJlbmRlcigpLCB0aGlzLiRjb250YWluZXIgPSB0aGlzLiRsYXlvdXQuJGNvbnRhaW5lci5maXJzdENoaWxkLCBmdW5jdGlvbihyKSB7XG4gICAgICB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShyLiRyb290KS5nZXRQcm9wZXJ0eVZhbHVlKFwicG9zaXRpb25cIikgPT0gXCJzdGF0aWNcIiAmJiAoci4kcm9vdC5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIik7XG4gICAgICB2YXIgcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpZnJhbWVcIik7XG4gICAgICBzLmNsYXNzTmFtZSA9IFwiZ2FudHRfY29udGFpbmVyX3Jlc2l6ZV93YXRjaGVyXCIsIHMudGFiSW5kZXggPSAtMSwgci5jb25maWcud2FpX2FyaWFfYXR0cmlidXRlcyAmJiAocy5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwibm9uZVwiKSwgcy5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCAhMCkpLCAod2luZG93LlNmZGMgfHwgd2luZG93LiRBIHx8IHdpbmRvdy5BdXJhKSAmJiAoci5jb25maWcuY29udGFpbmVyX3Jlc2l6ZV9tZXRob2QgPSBcInRpbWVvdXRcIiksIHIuJHJvb3QuYXBwZW5kQ2hpbGQocyksIHMuY29udGVudFdpbmRvdyA/IE9lKHIsIHMuY29udGVudFdpbmRvdykgOiAoci4kcm9vdC5yZW1vdmVDaGlsZChzKSwgT2Uociwgd2luZG93KSk7XG4gICAgfSh0aGlzKSk7XG4gIH0pLmJpbmQodCk7XG4gIHQucmVzZXRMYXlvdXQgPSBmdW5jdGlvbigpIHtcbiAgICBpKCksIGEoKSwgdGhpcy5yZW5kZXIoKTtcbiAgfSwgdC5fcmVpbml0ID0gZnVuY3Rpb24ocikge1xuICAgIHRoaXMuY2FsbEV2ZW50KFwib25CZWZvcmVHYW50dFJlYWR5XCIsIFtdKSwgdGhpcy5fdXBkYXRlX2ZsYWdzKCksIHRoaXMuJHNlcnZpY2VzLmdldFNlcnZpY2UoXCJ0ZW1wbGF0ZUxvYWRlclwiKS5pbml0VGVtcGxhdGVzKHRoaXMpLCBpKCksIHRoaXMuJHJvb3QgPSBudWxsLCByICYmICh0aGlzLiRyb290ID0gd2UociksIGEoKSwgdGhpcy4kbW91c2VFdmVudHMucmVzZXQodGhpcy4kcm9vdCksIGZ1bmN0aW9uKHMpIHtcbiAgICAgIHMuJGNvbnRhaW5lciAmJiAhcy5jb25maWcuYXV0b3NpemUgJiYgcy4kcm9vdC5vZmZzZXRIZWlnaHQgPCA1MCAmJiBjb25zb2xlLndhcm4oYFRoZSBHYW50dCBjb250YWluZXIgaGFzIGEgc21hbGwgaGVpZ2h0LCBzbyB5b3UgY2Fubm90IHNlZSBpdHMgY29udGVudC4gSWYgaXQgaXMgbm90IGludGVuZGVkLCB5b3UgbmVlZCB0byBzZXQgdGhlICdoZWlnaHQnIHN0eWxlIHJ1bGUgdG8gdGhlIGNvbnRhaW5lcjpcbmh0dHBzOi8vZG9jcy5kaHRtbHguY29tL2dhbnR0L2ZhcS5odG1sI3RoZWdhbnR0Y2hhcnRpc250cmVuZGVyZWRjb3JyZWN0bHlgKTtcbiAgICB9KHQpKSwgdGhpcy5jYWxsRXZlbnQoXCJvblRlbXBsYXRlc1JlYWR5XCIsIFtdKSwgdGhpcy5jYWxsRXZlbnQoXCJvbkdhbnR0UmVhZHlcIiwgW10pLCB0aGlzLnJlbmRlcigpO1xuICB9LCB0LiRjbGljayA9IHsgYnV0dG9uczogeyBlZGl0OiBmdW5jdGlvbihyKSB7XG4gICAgdC5pc1JlYWRvbmx5KHQuZ2V0VGFzayhyKSkgfHwgdC5zaG93TGlnaHRib3gocik7XG4gIH0sIGRlbGV0ZTogZnVuY3Rpb24ocikge1xuICAgIHZhciBzID0gdC5nZXRUYXNrKHIpO1xuICAgIGlmICghdC5pc1JlYWRvbmx5KHMpKSB7XG4gICAgICB2YXIgbyA9IHQubG9jYWxlLmxhYmVscy5jb25maXJtX2RlbGV0aW5nLCBsID0gdC5sb2NhbGUubGFiZWxzLmNvbmZpcm1fZGVsZXRpbmdfdGl0bGU7XG4gICAgICB0Ll9kZWxldGVfdGFza19jb25maXJtKHsgdGFzazogcywgbWVzc2FnZTogbywgdGl0bGU6IGwsIGNhbGxiYWNrOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdC5pc1Rhc2tFeGlzdHMocikgJiYgKHMuJG5ldyA/ICh0LiRkYXRhLnRhc2tzU3RvcmUuX3NraXBUYXNrUmVjYWxjdWxhdGlvbiA9IFwibGlnaHRib3hcIiwgdC5zaWxlbnQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdC5kZWxldGVUYXNrKHIsICEwKTtcbiAgICAgICAgfSksIHQuJGRhdGEudGFza3NTdG9yZS5fc2tpcFRhc2tSZWNhbGN1bGF0aW9uID0gITEsIHQucmVmcmVzaERhdGEoKSkgOiAodC4kZGF0YS50YXNrc1N0b3JlLl9za2lwVGFza1JlY2FsY3VsYXRpb24gPSAhMCwgdC5kZWxldGVUYXNrKHIpKSksIHQuaGlkZUxpZ2h0Ym94KCk7XG4gICAgICB9IH0pO1xuICAgIH1cbiAgfSB9IH0sIHQucmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHI7XG4gICAgaWYgKHRoaXMuY2FsbEV2ZW50KFwib25CZWZvcmVHYW50dFJlbmRlclwiLCBbXSksICFGKHQpKSB7XG4gICAgICAhdGhpcy5jb25maWcuc29ydCAmJiB0aGlzLl9zb3J0ICYmICh0aGlzLl9zb3J0ID0gdm9pZCAwKSwgdGhpcy4kcm9vdCAmJiAodGhpcy5jb25maWcucnRsID8gKHRoaXMuJHJvb3QuY2xhc3NMaXN0LmFkZChcImdhbnR0X3J0bFwiKSwgdGhpcy4kcm9vdC5maXJzdENoaWxkLmNsYXNzTGlzdC5hZGQoXCJnYW50dF9ydGxcIikpIDogKHRoaXMuJHJvb3QuY2xhc3NMaXN0LnJlbW92ZShcImdhbnR0X3J0bFwiKSwgdGhpcy4kcm9vdC5maXJzdENoaWxkLmNsYXNzTGlzdC5yZW1vdmUoXCJnYW50dF9ydGxcIikpKTtcbiAgICAgIHZhciBzID0gdGhpcy5nZXRTY3JvbGxTdGF0ZSgpLCBvID0gcyA/IHMueCA6IDA7XG4gICAgICB0aGlzLl9nZXRIb3Jpem9udGFsU2Nyb2xsYmFyKCkgJiYgKG8gPSB0aGlzLl9nZXRIb3Jpem9udGFsU2Nyb2xsYmFyKCkuJGNvbmZpZy5jb2RlU2Nyb2xsTGVmdCB8fCBvIHx8IDApLCByID0gbnVsbCwgbyAmJiAociA9IHQuZGF0ZUZyb21Qb3MobyArIHRoaXMuY29uZmlnLnRhc2tfc2Nyb2xsX29mZnNldCkpO1xuICAgIH1cbiAgICBpZiAobWUodGhpcyksIEYodCkpIHQucmVmcmVzaERhdGEoKTtcbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuJGxheW91dC4kY29uZmlnLmF1dG9zaXplID0gdGhpcy5jb25maWcuYXV0b3NpemU7XG4gICAgICB2YXIgbCA9IHRoaXMuY29uZmlnLnByZXNlcnZlX3Njcm9sbDtcbiAgICAgIGlmICh0aGlzLmNvbmZpZy5wcmVzZXJ2ZV9zY3JvbGwgPSAhMSwgdGhpcy4kbGF5b3V0LnJlc2l6ZSgpLCB0aGlzLmNvbmZpZy5wcmVzZXJ2ZV9zY3JvbGwgPSBsLCB0aGlzLmNvbmZpZy5wcmVzZXJ2ZV9zY3JvbGwgJiYgcykge1xuICAgICAgICBpZiAobyB8fCBzLnkpIHtcbiAgICAgICAgICB2YXIgZCA9IHQuZ2V0U2Nyb2xsU3RhdGUoKTtcbiAgICAgICAgICBpZiAoK3IgIT0gK3QuZGF0ZUZyb21Qb3MoZC54KSB8fCBkLnkgIT0gcy55KSB7XG4gICAgICAgICAgICBvID0gbnVsbDtcbiAgICAgICAgICAgIHZhciBjID0gbnVsbDtcbiAgICAgICAgICAgIHIgJiYgKG8gPSBNYXRoLm1heCh0LnBvc0Zyb21EYXRlKHIpIC0gdC5jb25maWcudGFza19zY3JvbGxfb2Zmc2V0LCAwKSksIHMueSAmJiAoYyA9IHMueSksIHQuc2Nyb2xsVG8obywgYyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuJGxheW91dC5nZXRTY3JvbGxiYXJzSW5mbygpLmZvckVhY2goKHUpID0+IHtcbiAgICAgICAgICBjb25zdCBoID0gdC4kdWkuZ2V0Vmlldyh1LmlkKSwgZyA9IHQudXRpbHMuZG9tLmlzQ2hpbGRPZihoLiR2aWV3LCB0LiRjb250YWluZXIpO1xuICAgICAgICAgIHUuYm91bmRWaWV3cy5mb3JFYWNoKChwKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB5ID0gdC4kdWkuZ2V0VmlldyhwKTtcbiAgICAgICAgICAgIHUueSAmJiB1LnkgIT0gcy55ICYmIHkgJiYgIWcgJiYgeS5zY3JvbGxUbyh2b2lkIDAsIDApLCB1LnhfcG9zICYmIHUueF9wb3MgIT0gcy54ICYmIHkgJiYgZyAmJiB5LnNjcm9sbFRvKHUueF9wb3MsIHZvaWQgMCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmNhbGxFdmVudChcIm9uR2FudHRSZW5kZXJcIiwgW10pO1xuICB9LCB0LnNldFNpemVzID0gdC5yZW5kZXIsIHQuZ2V0VGFza1Jvd05vZGUgPSBmdW5jdGlvbihyKSB7XG4gICAgZm9yICh2YXIgcyA9IHRoaXMuJGdyaWRfZGF0YS5jaGlsZE5vZGVzLCBvID0gdGhpcy5jb25maWcudGFza19hdHRyaWJ1dGUsIGwgPSAwOyBsIDwgcy5sZW5ndGg7IGwrKylcbiAgICAgIGlmIChzW2xdLmdldEF0dHJpYnV0ZSAmJiBzW2xdLmdldEF0dHJpYnV0ZShvKSA9PSByKSByZXR1cm4gc1tsXTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSwgdC5jaGFuZ2VMaWdodGJveFR5cGUgPSBmdW5jdGlvbihyKSB7XG4gICAgaWYgKHRoaXMuZ2V0TGlnaHRib3hUeXBlKCkgPT0gcikgcmV0dXJuICEwO1xuICAgIHQuX3NpbGVudF9yZWRyYXdfbGlnaHRib3gocik7XG4gIH0sIHQuX2dldF9saW5rX3R5cGUgPSBmdW5jdGlvbihyLCBzKSB7XG4gICAgdmFyIG8gPSBudWxsO1xuICAgIHJldHVybiByICYmIHMgPyBvID0gdC5jb25maWcubGlua3Muc3RhcnRfdG9fc3RhcnQgOiAhciAmJiBzID8gbyA9IHQuY29uZmlnLmxpbmtzLmZpbmlzaF90b19zdGFydCA6IHIgfHwgcyA/IHIgJiYgIXMgJiYgKG8gPSB0LmNvbmZpZy5saW5rcy5zdGFydF90b19maW5pc2gpIDogbyA9IHQuY29uZmlnLmxpbmtzLmZpbmlzaF90b19maW5pc2gsIG87XG4gIH0sIHQuaXNMaW5rQWxsb3dlZCA9IGZ1bmN0aW9uKHIsIHMsIG8sIGwpIHtcbiAgICB2YXIgZCA9IG51bGw7XG4gICAgaWYgKCEoZCA9IHR5cGVvZiByID09IFwib2JqZWN0XCIgPyByIDogeyBzb3VyY2U6IHIsIHRhcmdldDogcywgdHlwZTogdGhpcy5fZ2V0X2xpbmtfdHlwZShvLCBsKSB9KSB8fCAhKGQuc291cmNlICYmIGQudGFyZ2V0ICYmIGQudHlwZSkgfHwgZC5zb3VyY2UgPT0gZC50YXJnZXQpIHJldHVybiAhMTtcbiAgICB2YXIgYyA9ICEwO1xuICAgIHJldHVybiB0aGlzLmNoZWNrRXZlbnQoXCJvbkxpbmtWYWxpZGF0aW9uXCIpICYmIChjID0gdGhpcy5jYWxsRXZlbnQoXCJvbkxpbmtWYWxpZGF0aW9uXCIsIFtkXSkpLCBjO1xuICB9LCB0Ll9jb3JyZWN0X2RzdF9jaGFuZ2UgPSBmdW5jdGlvbihyLCBzLCBvLCBsKSB7XG4gICAgdmFyIGQgPSBWdChsKSAqIG87XG4gICAgaWYgKGQgPiAzNjAwICYmIGQgPCA4NjQwMCkge1xuICAgICAgdmFyIGMgPSByLmdldFRpbWV6b25lT2Zmc2V0KCkgLSBzO1xuICAgICAgYyAmJiAociA9IHQuZGF0ZS5hZGQociwgYywgXCJtaW51dGVcIikpO1xuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfSwgdC5pc1NwbGl0VGFzayA9IGZ1bmN0aW9uKHIpIHtcbiAgICByZXR1cm4gdC5hc3NlcnQociAmJiByIGluc3RhbmNlb2YgT2JqZWN0LCBcIkludmFsaWQgYXJndW1lbnQgPGI+dGFzazwvYj49XCIgKyByICsgXCIgb2YgZ2FudHQuaXNTcGxpdFRhc2suIFRhc2sgb2JqZWN0IHdhcyBleHBlY3RlZFwiKSwgdGhpcy4kZGF0YS50YXNrc1N0b3JlLl9pc1NwbGl0SXRlbShyKTtcbiAgfSwgdC5faXNfaWNvbl9vcGVuX2NsaWNrID0gZnVuY3Rpb24ocikge1xuICAgIGlmICghcikgcmV0dXJuICExO1xuICAgIHZhciBzID0gci50YXJnZXQgfHwgci5zcmNFbGVtZW50O1xuICAgIGlmICghcyB8fCAhcy5jbGFzc05hbWUpIHJldHVybiAhMTtcbiAgICB2YXIgbyA9IFgocyk7XG4gICAgcmV0dXJuIG8uaW5kZXhPZihcImdhbnR0X3RyZWVfaWNvblwiKSAhPT0gLTEgJiYgKG8uaW5kZXhPZihcImdhbnR0X2Nsb3NlXCIpICE9PSAtMSB8fCBvLmluZGV4T2YoXCJnYW50dF9vcGVuXCIpICE9PSAtMSk7XG4gIH07XG59XG5jb25zdCBTaSA9IHsgZGF0ZTogeyBtb250aF9mdWxsOiBbXCLZg9in2YbZiNmGINin2YTYq9in2YbZilwiLCBcIti02KjYp9i3XCIsIFwi2KLYsNin2LFcIiwgXCLZhtmK2LPYp9mGXCIsIFwi2KPZitin2LFcIiwgXCLYrdiy2YrYsdin2YZcIiwgXCLYqtmF2YjYslwiLCBcItii2KhcIiwgXCLYo9mK2YTZiNmEXCIsIFwi2KrYtNix2YrZhiDYp9mE2KPZiNmEXCIsIFwi2KrYtNix2YrZhiDYp9mE2KvYp9mG2YpcIiwgXCLZg9in2YbZiNmGINin2YTYo9mI2YRcIl0sIG1vbnRoX3Nob3J0OiBbXCLZitmG2KfZitixXCIsIFwi2YHYqNix2KfZitixXCIsIFwi2YXYp9ix2LNcIiwgXCLYo9io2LHZitmEXCIsIFwi2YXYp9mK2YhcIiwgXCLZitmI2YbZitmIXCIsIFwi2YrZiNmE2YrZiFwiLCBcItij2LrYs9i32LNcIiwgXCLYs9io2KrZhdio2LFcIiwgXCLYo9mD2KrZiNio2LFcIiwgXCLZhtmI2YHZhdio2LFcIiwgXCLYr9mK2LPZhdio2LFcIl0sIGRheV9mdWxsOiBbXCLYp9mE2KPYrdivXCIsIFwi2KfZhNij2KvZhtmK2YZcIiwgXCLYo9mE2KvZhNin2KvYp9ihXCIsIFwi2KfZhNij2LHYqNi52KfYoVwiLCBcItij2YTYrdmF2YrYs1wiLCBcItij2YTYrNmF2LnYqVwiLCBcItin2YTYs9io2KpcIl0sIGRheV9zaG9ydDogW1wi2KfYrdivXCIsIFwi2KfYq9mG2YrZhlwiLCBcItir2YTYp9ir2KfYoVwiLCBcItin2LHYqNi52KfYoVwiLCBcItiu2YXZitizXCIsIFwi2KzZhdi52KlcIiwgXCLYs9io2KpcIl0gfSwgbGFiZWxzOiB7IG5ld190YXNrOiBcItmF2YfZhdipINis2K/ZitivXCIsIGljb25fc2F2ZTogXCLYp9iu2LLZhlwiLCBpY29uX2NhbmNlbDogXCLYp9mE2LrYp9ihXCIsIGljb25fZGV0YWlsczogXCLYqtmB2KfYtdmK2YRcIiwgaWNvbl9lZGl0OiBcItiq2K3YsdmK2LFcIiwgaWNvbl9kZWxldGU6IFwi2K3YsNmBXCIsIGNvbmZpcm1fY2xvc2luZzogXCLYp9mE2KrYutmK2YrYsdin2Kog2LPZiNmBINiq2LbZiti5LCDZh9mEINin2YbYqiDZhdiq2KPZg9iv2J9cIiwgY29uZmlybV9kZWxldGluZzogXCLYp9mE2K3Yr9irINiz2YrYqtmFINit2LDZgdmH2Kcg2YbZh9in2KbZitinINiMINmH2YQg2KPZhtiqINmF2KrYo9mD2K/Yn1wiLCBzZWN0aW9uX2Rlc2NyaXB0aW9uOiBcItin2YTZiNi12YFcIiwgc2VjdGlvbl90aW1lOiBcItin2YTZgdiq2LHYqSDYp9mE2LLZhdmG2YrYqVwiLCBzZWN0aW9uX3R5cGU6IFwiVHlwZVwiLCBzZWN0aW9uX2RlYWRsaW5lOiBcIkRlYWRsaW5lXCIsIHNlY3Rpb25fYmFzZWxpbmVzOiBcIkJhc2VsaW5lc1wiLCBjb2x1bW5fd2JzOiBcIldCU1wiLCBjb2x1bW5fdGV4dDogXCJUYXNrIG5hbWVcIiwgY29sdW1uX3N0YXJ0X2RhdGU6IFwiU3RhcnQgdGltZVwiLCBjb2x1bW5fZHVyYXRpb246IFwiRHVyYXRpb25cIiwgY29sdW1uX2FkZDogXCJcIiwgbGluazogXCJMaW5rXCIsIGNvbmZpcm1fbGlua19kZWxldGluZzogXCJ3aWxsIGJlIGRlbGV0ZWRcIiwgbGlua19zdGFydDogXCIgKHN0YXJ0KVwiLCBsaW5rX2VuZDogXCIgKGVuZClcIiwgdHlwZV90YXNrOiBcIlRhc2tcIiwgdHlwZV9wcm9qZWN0OiBcIlByb2plY3RcIiwgdHlwZV9taWxlc3RvbmU6IFwiTWlsZXN0b25lXCIsIG1pbnV0ZXM6IFwiTWludXRlc1wiLCBob3VyczogXCJIb3Vyc1wiLCBkYXlzOiBcIkRheXNcIiwgd2Vla3M6IFwiV2Vla1wiLCBtb250aHM6IFwiTW9udGhzXCIsIHllYXJzOiBcIlllYXJzXCIsIG1lc3NhZ2Vfb2s6IFwiT0tcIiwgbWVzc2FnZV9jYW5jZWw6IFwi2KfZhNi62KfYoVwiLCBzZWN0aW9uX2NvbnN0cmFpbnQ6IFwiQ29uc3RyYWludFwiLCBjb25zdHJhaW50X3R5cGU6IFwiQ29uc3RyYWludCB0eXBlXCIsIGNvbnN0cmFpbnRfZGF0ZTogXCJDb25zdHJhaW50IGRhdGVcIiwgYXNhcDogXCJBcyBTb29uIEFzIFBvc3NpYmxlXCIsIGFsYXA6IFwiQXMgTGF0ZSBBcyBQb3NzaWJsZVwiLCBzbmV0OiBcIlN0YXJ0IE5vIEVhcmxpZXIgVGhhblwiLCBzbmx0OiBcIlN0YXJ0IE5vIExhdGVyIFRoYW5cIiwgZm5ldDogXCJGaW5pc2ggTm8gRWFybGllciBUaGFuXCIsIGZubHQ6IFwiRmluaXNoIE5vIExhdGVyIFRoYW5cIiwgbXNvOiBcIk11c3QgU3RhcnQgT25cIiwgbWZvOiBcIk11c3QgRmluaXNoIE9uXCIsIHJlc291cmNlc19maWx0ZXJfcGxhY2Vob2xkZXI6IFwidHlwZSB0byBmaWx0ZXJcIiwgcmVzb3VyY2VzX2ZpbHRlcl9sYWJlbDogXCJoaWRlIGVtcHR5XCIsIGVtcHR5X3N0YXRlX3RleHRfbGluazogXCJDbGljayBoZXJlXCIsIGVtcHR5X3N0YXRlX3RleHRfZGVzY3JpcHRpb246IFwidG8gY3JlYXRlIHlvdXIgZmlyc3QgdGFza1wiLCBiYXNlbGluZXNfc2VjdGlvbl9wbGFjZWhvbGRlcjogXCJTdGFydCBhZGRpbmcgYSBuZXcgYmFzZWxpbmVcIiwgYmFzZWxpbmVzX2FkZF9idXR0b246IFwiQWRkIEJhc2VsaW5lXCIsIGJhc2VsaW5lc19yZW1vdmVfYnV0dG9uOiBcIlJlbW92ZVwiLCBiYXNlbGluZXNfcmVtb3ZlX2FsbF9idXR0b246IFwiUmVtb3ZlIEFsbFwiLCBkZWFkbGluZV9lbmFibGVfYnV0dG9uOiBcIlNldFwiLCBkZWFkbGluZV9kaXNhYmxlX2J1dHRvbjogXCJSZW1vdmVcIiB9IH0sIFRpID0geyBkYXRlOiB7IG1vbnRoX2Z1bGw6IFtcItCh0YLRg9C00LfQtdC90YxcIiwgXCLQm9GO0YLRi1wiLCBcItCh0LDQutCw0LLRltC6XCIsIFwi0JrRgNCw0YHQsNCy0ZbQulwiLCBcIk1h0LlcIiwgXCLQp9GN0YDQstC10L3RjFwiLCBcItCb0ZbQv9C10L3RjFwiLCBcItCW0L3RltCy0LXQvdGMXCIsIFwi0JLQtdGA0LDRgdC10L3RjFwiLCBcItCa0LDRgdGC0YDRi9GH0L3RltC6XCIsIFwi0JvRltGB0YLQsNC/0LDQtFwiLCBcItCh0L3QtdC20LDQvdGMXCJdLCBtb250aF9zaG9ydDogW1wi0KHRgtGD0LTQt1wiLCBcItCb0Y7RglwiLCBcItCh0LDQulwiLCBcItCa0YDQsNGBXCIsIFwiTWHQuVwiLCBcItCn0Y3RgFwiLCBcItCb0ZbQv1wiLCBcItCW0L3RltCyXCIsIFwi0JLQtdGAXCIsIFwi0JrQsNGB0YJcIiwgXCLQm9GW0YHRglwiLCBcItCh0L3QtdC2XCJdLCBkYXlfZnVsbDogW1wi0J3Rj9C00LfQtdC70Y9cIiwgXCLQn9Cw0L3Rj9C00LfQtdC70LDQulwiLCBcItCQ0Z7RgtC+0YDQsNC6XCIsIFwi0KHQtdGA0LDQtNCwXCIsIFwi0KfQsNGG0LLQtdGAXCIsIFwi0J/Rj9GC0L3RltGG0LBcIiwgXCLQodGD0LHQvtGC0LBcIl0sIGRheV9zaG9ydDogW1wi0J3QtFwiLCBcItCf0L1cIiwgXCLQkNGe0YJcIiwgXCLQodGAXCIsIFwi0KfRhtCyXCIsIFwi0J/RglwiLCBcItCh0LFcIl0gfSwgbGFiZWxzOiB7IG5ld190YXNrOiBcItCd0L7QstCw0LUg0LfQsNC00LDQvdC90LVcIiwgaWNvbl9zYXZlOiBcItCX0LDRhdCw0LLQsNGG0YxcIiwgaWNvbl9jYW5jZWw6IFwi0JDQtNC80Y/QvdGW0YbRjFwiLCBpY29uX2RldGFpbHM6IFwi0JTRjdGC0LDQu9GWXCIsIGljb25fZWRpdDogXCLQl9C80Y/QvdGW0YbRjFwiLCBpY29uX2RlbGV0ZTogXCLQktGL0LTQsNC70ZbRhtGMXCIsIGNvbmZpcm1fY2xvc2luZzogXCJcIiwgY29uZmlybV9kZWxldGluZzogXCLQn9Cw0LTQt9C10Y8g0LHRg9C00LfQtSDQstGL0LTQsNC70LXQvdCwINC90LXQt9Cy0LDRgNC+0YLQvdCwLCDQv9GA0LDRhtGP0LPQvdGD0YbRjD9cIiwgc2VjdGlvbl9kZXNjcmlwdGlvbjogXCLQkNC/0ZbRgdCw0L3QvdC1XCIsIHNlY3Rpb25fdGltZTogXCLQn9C10YDRi9GP0LQg0YfQsNGB0YNcIiwgc2VjdGlvbl90eXBlOiBcItCi0YvQv1wiLCBzZWN0aW9uX2RlYWRsaW5lOiBcIkRlYWRsaW5lXCIsIHNlY3Rpb25fYmFzZWxpbmVzOiBcIkJhc2VsaW5lc1wiLCBjb2x1bW5fd2JzOiBcItCG0KHQoFwiLCBjb2x1bW5fdGV4dDogXCLQl9Cw0LTQsNGH0LBcIiwgY29sdW1uX3N0YXJ0X2RhdGU6IFwi0J/QsNGH0LDRgtCw0LpcIiwgY29sdW1uX2R1cmF0aW9uOiBcItCf0YDQsNGG0Y/Qs1wiLCBjb2x1bW5fYWRkOiBcIlwiLCBsaW5rOiBcItCh0YPQstGP0LfRjFwiLCBjb25maXJtX2xpbmtfZGVsZXRpbmc6IFwi0LHRg9C00LfQtSDQstGL0LTQsNC70LXQvdCwXCIsIGxpbmtfc3RhcnQ6IFwiKNC/0LDRh9Cw0YLQsNC6KVwiLCBsaW5rX2VuZDogXCIo0LrQsNC90LXRhilcIiwgdHlwZV90YXNrOiBcIlRhc2tcIiwgdHlwZV9wcm9qZWN0OiBcIlByb2plY3RcIiwgdHlwZV9taWxlc3RvbmU6IFwiTWlsZXN0b25lXCIsIG1pbnV0ZXM6IFwi0KXQsmnQu2nQvdCwXCIsIGhvdXJzOiBcItCT0LDQtNC3adC90LBcIiwgZGF5czogXCLQlNC30LXQvdGMXCIsIHdlZWtzOiBcItCi0YvQtNC30LXQvdGMXCIsIG1vbnRoczogXCLQnNC10YHRj9GGXCIsIHllYXJzOiBcItCT0L7QtFwiLCBtZXNzYWdlX29rOiBcIk9LXCIsIG1lc3NhZ2VfY2FuY2VsOiBcItCQ0LTQvNGP0L3RltGG0YxcIiwgc2VjdGlvbl9jb25zdHJhaW50OiBcIkNvbnN0cmFpbnRcIiwgY29uc3RyYWludF90eXBlOiBcIkNvbnN0cmFpbnQgdHlwZVwiLCBjb25zdHJhaW50X2RhdGU6IFwiQ29uc3RyYWludCBkYXRlXCIsIGFzYXA6IFwiQXMgU29vbiBBcyBQb3NzaWJsZVwiLCBhbGFwOiBcIkFzIExhdGUgQXMgUG9zc2libGVcIiwgc25ldDogXCJTdGFydCBObyBFYXJsaWVyIFRoYW5cIiwgc25sdDogXCJTdGFydCBObyBMYXRlciBUaGFuXCIsIGZuZXQ6IFwiRmluaXNoIE5vIEVhcmxpZXIgVGhhblwiLCBmbmx0OiBcIkZpbmlzaCBObyBMYXRlciBUaGFuXCIsIG1zbzogXCJNdXN0IFN0YXJ0IE9uXCIsIG1mbzogXCJNdXN0IEZpbmlzaCBPblwiLCByZXNvdXJjZXNfZmlsdGVyX3BsYWNlaG9sZGVyOiBcInR5cGUgdG8gZmlsdGVyXCIsIHJlc291cmNlc19maWx0ZXJfbGFiZWw6IFwiaGlkZSBlbXB0eVwiLCBlbXB0eV9zdGF0ZV90ZXh0X2xpbms6IFwiQ2xpY2sgaGVyZVwiLCBlbXB0eV9zdGF0ZV90ZXh0X2Rlc2NyaXB0aW9uOiBcInRvIGNyZWF0ZSB5b3VyIGZpcnN0IHRhc2tcIiwgYmFzZWxpbmVzX3NlY3Rpb25fcGxhY2Vob2xkZXI6IFwiU3RhcnQgYWRkaW5nIGEgbmV3IGJhc2VsaW5lXCIsIGJhc2VsaW5lc19hZGRfYnV0dG9uOiBcIkFkZCBCYXNlbGluZVwiLCBiYXNlbGluZXNfcmVtb3ZlX2J1dHRvbjogXCJSZW1vdmVcIiwgYmFzZWxpbmVzX3JlbW92ZV9hbGxfYnV0dG9uOiBcIlJlbW92ZSBBbGxcIiwgZGVhZGxpbmVfZW5hYmxlX2J1dHRvbjogXCJTZXRcIiwgZGVhZGxpbmVfZGlzYWJsZV9idXR0b246IFwiUmVtb3ZlXCIgfSB9LCBFaSA9IHsgZGF0ZTogeyBtb250aF9mdWxsOiBbXCJHZW5lclwiLCBcIkZlYnJlclwiLCBcIk1hcsOnXCIsIFwiQWJyaWxcIiwgXCJNYWlnXCIsIFwiSnVueVwiLCBcIkp1bGlvbFwiLCBcIkFnb3N0XCIsIFwiU2V0ZW1icmVcIiwgXCJPY3R1YnJlXCIsIFwiTm92ZW1icmVcIiwgXCJEZXNlbWJyZVwiXSwgbW9udGhfc2hvcnQ6IFtcIkdlblwiLCBcIkZlYlwiLCBcIk1hclwiLCBcIkFiclwiLCBcIk1haVwiLCBcIkp1blwiLCBcIkp1bFwiLCBcIkFnb1wiLCBcIlNldFwiLCBcIk9jdFwiLCBcIk5vdlwiLCBcIkRlc1wiXSwgZGF5X2Z1bGw6IFtcIkRpdW1lbmdlXCIsIFwiRGlsbHVuc1wiLCBcIkRpbWFydHNcIiwgXCJEaW1lY3Jlc1wiLCBcIkRpam91c1wiLCBcIkRpdmVuZHJlc1wiLCBcIkRpc3NhYnRlXCJdLCBkYXlfc2hvcnQ6IFtcIkRnXCIsIFwiRGxcIiwgXCJEbVwiLCBcIkRjXCIsIFwiRGpcIiwgXCJEdlwiLCBcIkRzXCJdIH0sIGxhYmVsczogeyBuZXdfdGFzazogXCJOb3ZhIHRhc2NhXCIsIGljb25fc2F2ZTogXCJHdWFyZGFyXCIsIGljb25fY2FuY2VsOiBcIkNhbmNlbMK3bGFyXCIsIGljb25fZGV0YWlsczogXCJEZXRhbGxzXCIsIGljb25fZWRpdDogXCJFZGl0YXJcIiwgaWNvbl9kZWxldGU6IFwiRXNib3JyYXJcIiwgY29uZmlybV9jbG9zaW5nOiBcIlwiLCBjb25maXJtX2RlbGV0aW5nOiBcIkwnZXNkZXZlbmltZW50IHMnZXNib3JyYXLDoCBkZWZpbml0aXZhbWVudCwgY29udGludWFyID9cIiwgc2VjdGlvbl9kZXNjcmlwdGlvbjogXCJEZXNjcmlwY2nDs1wiLCBzZWN0aW9uX3RpbWU6IFwiUGVyaW9kZSBkZSB0ZW1wc1wiLCBzZWN0aW9uX3R5cGU6IFwiVHlwZVwiLCBzZWN0aW9uX2RlYWRsaW5lOiBcIkRlYWRsaW5lXCIsIHNlY3Rpb25fYmFzZWxpbmVzOiBcIkJhc2VsaW5lc1wiLCBjb2x1bW5fd2JzOiBcIldCU1wiLCBjb2x1bW5fdGV4dDogXCJUYXNrIG5hbWVcIiwgY29sdW1uX3N0YXJ0X2RhdGU6IFwiU3RhcnQgdGltZVwiLCBjb2x1bW5fZHVyYXRpb246IFwiRHVyYXRpb25cIiwgY29sdW1uX2FkZDogXCJcIiwgbGluazogXCJMaW5rXCIsIGNvbmZpcm1fbGlua19kZWxldGluZzogXCJ3aWxsIGJlIGRlbGV0ZWRcIiwgbGlua19zdGFydDogXCIgKHN0YXJ0KVwiLCBsaW5rX2VuZDogXCIgKGVuZClcIiwgdHlwZV90YXNrOiBcIlRhc2tcIiwgdHlwZV9wcm9qZWN0OiBcIlByb2plY3RcIiwgdHlwZV9taWxlc3RvbmU6IFwiTWlsZXN0b25lXCIsIG1pbnV0ZXM6IFwiTWludXRlc1wiLCBob3VyczogXCJIb3Vyc1wiLCBkYXlzOiBcIkRheXNcIiwgd2Vla3M6IFwiV2Vla1wiLCBtb250aHM6IFwiTW9udGhzXCIsIHllYXJzOiBcIlllYXJzXCIsIG1lc3NhZ2Vfb2s6IFwiT0tcIiwgbWVzc2FnZV9jYW5jZWw6IFwiQ2FuY2VswrdsYXJcIiwgc2VjdGlvbl9jb25zdHJhaW50OiBcIkNvbnN0cmFpbnRcIiwgY29uc3RyYWludF90eXBlOiBcIkNvbnN0cmFpbnQgdHlwZVwiLCBjb25zdHJhaW50X2RhdGU6IFwiQ29uc3RyYWludCBkYXRlXCIsIGFzYXA6IFwiQXMgU29vbiBBcyBQb3NzaWJsZVwiLCBhbGFwOiBcIkFzIExhdGUgQXMgUG9zc2libGVcIiwgc25ldDogXCJTdGFydCBObyBFYXJsaWVyIFRoYW5cIiwgc25sdDogXCJTdGFydCBObyBMYXRlciBUaGFuXCIsIGZuZXQ6IFwiRmluaXNoIE5vIEVhcmxpZXIgVGhhblwiLCBmbmx0OiBcIkZpbmlzaCBObyBMYXRlciBUaGFuXCIsIG1zbzogXCJNdXN0IFN0YXJ0IE9uXCIsIG1mbzogXCJNdXN0IEZpbmlzaCBPblwiLCByZXNvdXJjZXNfZmlsdGVyX3BsYWNlaG9sZGVyOiBcInR5cGUgdG8gZmlsdGVyXCIsIHJlc291cmNlc19maWx0ZXJfbGFiZWw6IFwiaGlkZSBlbXB0eVwiLCBlbXB0eV9zdGF0ZV90ZXh0X2xpbms6IFwiQ2xpY2sgaGVyZVwiLCBlbXB0eV9zdGF0ZV90ZXh0X2Rlc2NyaXB0aW9uOiBcInRvIGNyZWF0ZSB5b3VyIGZpcnN0IHRhc2tcIiwgYmFzZWxpbmVzX3NlY3Rpb25fcGxhY2Vob2xkZXI6IFwiU3RhcnQgYWRkaW5nIGEgbmV3IGJhc2VsaW5lXCIsIGJhc2VsaW5lc19hZGRfYnV0dG9uOiBcIkFkZCBCYXNlbGluZVwiLCBiYXNlbGluZXNfcmVtb3ZlX2J1dHRvbjogXCJSZW1vdmVcIiwgYmFzZWxpbmVzX3JlbW92ZV9hbGxfYnV0dG9uOiBcIlJlbW92ZSBBbGxcIiwgZGVhZGxpbmVfZW5hYmxlX2J1dHRvbjogXCJTZXRcIiwgZGVhZGxpbmVfZGlzYWJsZV9idXR0b246IFwiUmVtb3ZlXCIgfSB9LCBDaSA9IHsgZGF0ZTogeyBtb250aF9mdWxsOiBbXCLkuIDmnIhcIiwgXCLkuozmnIhcIiwgXCLkuInmnIhcIiwgXCLlm5vmnIhcIiwgXCLkupTmnIhcIiwgXCLlha3mnIhcIiwgXCLkuIPmnIhcIiwgXCLlhavmnIhcIiwgXCLkuZ3mnIhcIiwgXCLljYHmnIhcIiwgXCLljYHkuIDmnIhcIiwgXCLljYHkuozmnIhcIl0sIG1vbnRoX3Nob3J0OiBbXCIx5pyIXCIsIFwiMuaciFwiLCBcIjPmnIhcIiwgXCI05pyIXCIsIFwiNeaciFwiLCBcIjbmnIhcIiwgXCI35pyIXCIsIFwiOOaciFwiLCBcIjnmnIhcIiwgXCIxMOaciFwiLCBcIjEx5pyIXCIsIFwiMTLmnIhcIl0sIGRheV9mdWxsOiBbXCLmmJ/mnJ/ml6VcIiwgXCLmmJ/mnJ/kuIBcIiwgXCLmmJ/mnJ/kuoxcIiwgXCLmmJ/mnJ/kuIlcIiwgXCLmmJ/mnJ/lm5tcIiwgXCLmmJ/mnJ/kupRcIiwgXCLmmJ/mnJ/lha1cIl0sIGRheV9zaG9ydDogW1wi5pelXCIsIFwi5LiAXCIsIFwi5LqMXCIsIFwi5LiJXCIsIFwi5ZubXCIsIFwi5LqUXCIsIFwi5YWtXCJdIH0sIGxhYmVsczogeyBuZXdfdGFzazogXCLmlrDku7vli5lcIiwgaWNvbl9zYXZlOiBcIuS/neWtmFwiLCBpY29uX2NhbmNlbDogXCLlhbPpl61cIiwgaWNvbl9kZXRhaWxzOiBcIuivpue7hlwiLCBpY29uX2VkaXQ6IFwi57yW6L6RXCIsIGljb25fZGVsZXRlOiBcIuWIoOmZpFwiLCBjb25maXJtX2Nsb3Npbmc6IFwi6K+356Gu6K6k5piv5ZCm5pKk6ZSA5L+u5pS5IVwiLCBjb25maXJtX2RlbGV0aW5nOiBcIuaYr+WQpuWIoOmZpOaXpeeoiz9cIiwgc2VjdGlvbl9kZXNjcmlwdGlvbjogXCLmj4/ov7BcIiwgc2VjdGlvbl90aW1lOiBcIuaXtumXtOiMg+WbtFwiLCBzZWN0aW9uX3R5cGU6IFwi57G75Z6LXCIsIHNlY3Rpb25fZGVhZGxpbmU6IFwiRGVhZGxpbmVcIiwgc2VjdGlvbl9iYXNlbGluZXM6IFwiQmFzZWxpbmVzXCIsIGNvbHVtbl93YnM6IFwi5bel5L2c5YiG6Kej57uT5p6EXCIsIGNvbHVtbl90ZXh0OiBcIuS7u+WKoeWQjVwiLCBjb2x1bW5fc3RhcnRfZGF0ZTogXCLlvIDlp4vml7bpl7RcIiwgY29sdW1uX2R1cmF0aW9uOiBcIuaMgee7reaXtumXtFwiLCBjb2x1bW5fYWRkOiBcIlwiLCBsaW5rOiBcIuWFs+iBlFwiLCBjb25maXJtX2xpbmtfZGVsZXRpbmc6IFwi5bCG6KKr5Yig6ZmkXCIsIGxpbmtfc3RhcnQ6IFwiICjlvIDlp4spXCIsIGxpbmtfZW5kOiBcIiAo57uT5p2fKVwiLCB0eXBlX3Rhc2s6IFwi5Lu75YqhXCIsIHR5cGVfcHJvamVjdDogXCLpobnnm65cIiwgdHlwZV9taWxlc3RvbmU6IFwi6YeM56iL56KRXCIsIG1pbnV0ZXM6IFwi5YiG6ZKfXCIsIGhvdXJzOiBcIuWwj+aXtlwiLCBkYXlzOiBcIuWkqVwiLCB3ZWVrczogXCLlkahcIiwgbW9udGhzOiBcIuaciFwiLCB5ZWFyczogXCLlubRcIiwgbWVzc2FnZV9vazogXCJPS1wiLCBtZXNzYWdlX2NhbmNlbDogXCLlhbPpl61cIiwgc2VjdGlvbl9jb25zdHJhaW50OiBcIkNvbnN0cmFpbnRcIiwgY29uc3RyYWludF90eXBlOiBcIkNvbnN0cmFpbnQgdHlwZVwiLCBjb25zdHJhaW50X2RhdGU6IFwiQ29uc3RyYWludCBkYXRlXCIsIGFzYXA6IFwiQXMgU29vbiBBcyBQb3NzaWJsZVwiLCBhbGFwOiBcIkFzIExhdGUgQXMgUG9zc2libGVcIiwgc25ldDogXCJTdGFydCBObyBFYXJsaWVyIFRoYW5cIiwgc25sdDogXCJTdGFydCBObyBMYXRlciBUaGFuXCIsIGZuZXQ6IFwiRmluaXNoIE5vIEVhcmxpZXIgVGhhblwiLCBmbmx0OiBcIkZpbmlzaCBObyBMYXRlciBUaGFuXCIsIG1zbzogXCJNdXN0IFN0YXJ0IE9uXCIsIG1mbzogXCJNdXN0IEZpbmlzaCBPblwiLCByZXNvdXJjZXNfZmlsdGVyX3BsYWNlaG9sZGVyOiBcInR5cGUgdG8gZmlsdGVyXCIsIHJlc291cmNlc19maWx0ZXJfbGFiZWw6IFwiaGlkZSBlbXB0eVwiLCBlbXB0eV9zdGF0ZV90ZXh0X2xpbms6IFwiQ2xpY2sgaGVyZVwiLCBlbXB0eV9zdGF0ZV90ZXh0X2Rlc2NyaXB0aW9uOiBcInRvIGNyZWF0ZSB5b3VyIGZpcnN0IHRhc2tcIiwgYmFzZWxpbmVzX3NlY3Rpb25fcGxhY2Vob2xkZXI6IFwiU3RhcnQgYWRkaW5nIGEgbmV3IGJhc2VsaW5lXCIsIGJhc2VsaW5lc19hZGRfYnV0dG9uOiBcIkFkZCBCYXNlbGluZVwiLCBiYXNlbGluZXNfcmVtb3ZlX2J1dHRvbjogXCJSZW1vdmVcIiwgYmFzZWxpbmVzX3JlbW92ZV9hbGxfYnV0dG9uOiBcIlJlbW92ZSBBbGxcIiwgZGVhZGxpbmVfZW5hYmxlX2J1dHRvbjogXCJTZXRcIiwgZGVhZGxpbmVfZGlzYWJsZV9idXR0b246IFwiUmVtb3ZlXCIgfSB9LCBEaSA9IHsgZGF0ZTogeyBtb250aF9mdWxsOiBbXCJMZWRlblwiLCBcIsOabm9yXCIsIFwiQsWZZXplblwiLCBcIkR1YmVuXCIsIFwiS3bEm3RlblwiLCBcIsSMZXJ2ZW5cIiwgXCLEjGVydmVuZWNcIiwgXCJTcnBlblwiLCBcIlrDocWZw61cIiwgXCLFmMOtamVuXCIsIFwiTGlzdG9wYWRcIiwgXCJQcm9zaW5lY1wiXSwgbW9udGhfc2hvcnQ6IFtcIkxlZFwiLCBcIsOablwiLCBcIkLFmWVcIiwgXCJEdWJcIiwgXCJLdsSbXCIsIFwixIxlclwiLCBcIsSMZWNcIiwgXCJTcnBcIiwgXCJaw6HFmcOtXCIsIFwixZjDrWpcIiwgXCJMaXN0XCIsIFwiUHJvXCJdLCBkYXlfZnVsbDogW1wiTmVkxJtsZVwiLCBcIlBvbmTEm2zDrVwiLCBcIsOadGVyw71cIiwgXCJTdMWZZWRhXCIsIFwixIx0dnJ0ZWtcIiwgXCJQw6F0ZWtcIiwgXCJTb2JvdGFcIl0sIGRheV9zaG9ydDogW1wiTmVcIiwgXCJQb1wiLCBcIsOadFwiLCBcIlN0XCIsIFwixIx0XCIsIFwiUMOhXCIsIFwiU29cIl0gfSwgbGFiZWxzOiB7IG5ld190YXNrOiBcIk5vdsOhIHByw6FjZVwiLCBpY29uX3NhdmU6IFwiVWxvxb5pdFwiLCBpY29uX2NhbmNlbDogXCJacMSbdFwiLCBpY29uX2RldGFpbHM6IFwiRGV0YWlsXCIsIGljb25fZWRpdDogXCJFZGl0dWpcIiwgaWNvbl9kZWxldGU6IFwiU21hemF0XCIsIGNvbmZpcm1fY2xvc2luZzogXCJcIiwgY29uZmlybV9kZWxldGluZzogXCJVZMOhbG9zdCBidWRlIHRydmFsZSBzbWF6w6FuYSwgb3ByYXZkdT9cIiwgc2VjdGlvbl9kZXNjcmlwdGlvbjogXCJQb3puw6Fta3lcIiwgc2VjdGlvbl90aW1lOiBcIkRvYmEgcGxhdG5vc3RpXCIsIHNlY3Rpb25fdHlwZTogXCJUeXBlXCIsIHNlY3Rpb25fZGVhZGxpbmU6IFwiRGVhZGxpbmVcIiwgc2VjdGlvbl9iYXNlbGluZXM6IFwiQmFzZWxpbmVzXCIsIGNvbHVtbl93YnM6IFwiV0JTXCIsIGNvbHVtbl90ZXh0OiBcIlRhc2sgbmFtZVwiLCBjb2x1bW5fc3RhcnRfZGF0ZTogXCJTdGFydCB0aW1lXCIsIGNvbHVtbl9kdXJhdGlvbjogXCJEdXJhdGlvblwiLCBjb2x1bW5fYWRkOiBcIlwiLCBsaW5rOiBcIkxpbmtcIiwgY29uZmlybV9saW5rX2RlbGV0aW5nOiBcIndpbGwgYmUgZGVsZXRlZFwiLCBsaW5rX3N0YXJ0OiBcIiAoc3RhcnQpXCIsIGxpbmtfZW5kOiBcIiAoZW5kKVwiLCB0eXBlX3Rhc2s6IFwiVGFza1wiLCB0eXBlX3Byb2plY3Q6IFwiUHJvamVjdFwiLCB0eXBlX21pbGVzdG9uZTogXCJNaWxlc3RvbmVcIiwgbWludXRlczogXCJNaW51dGVzXCIsIGhvdXJzOiBcIkhvdXJzXCIsIGRheXM6IFwiRGF5c1wiLCB3ZWVrczogXCJXZWVrXCIsIG1vbnRoczogXCJNb250aHNcIiwgeWVhcnM6IFwiWWVhcnNcIiwgbWVzc2FnZV9vazogXCJPS1wiLCBtZXNzYWdlX2NhbmNlbDogXCJacMSbdFwiLCBzZWN0aW9uX2NvbnN0cmFpbnQ6IFwiQ29uc3RyYWludFwiLCBjb25zdHJhaW50X3R5cGU6IFwiQ29uc3RyYWludCB0eXBlXCIsIGNvbnN0cmFpbnRfZGF0ZTogXCJDb25zdHJhaW50IGRhdGVcIiwgYXNhcDogXCJBcyBTb29uIEFzIFBvc3NpYmxlXCIsIGFsYXA6IFwiQXMgTGF0ZSBBcyBQb3NzaWJsZVwiLCBzbmV0OiBcIlN0YXJ0IE5vIEVhcmxpZXIgVGhhblwiLCBzbmx0OiBcIlN0YXJ0IE5vIExhdGVyIFRoYW5cIiwgZm5ldDogXCJGaW5pc2ggTm8gRWFybGllciBUaGFuXCIsIGZubHQ6IFwiRmluaXNoIE5vIExhdGVyIFRoYW5cIiwgbXNvOiBcIk11c3QgU3RhcnQgT25cIiwgbWZvOiBcIk11c3QgRmluaXNoIE9uXCIsIHJlc291cmNlc19maWx0ZXJfcGxhY2Vob2xkZXI6IFwidHlwZSB0byBmaWx0ZXJcIiwgcmVzb3VyY2VzX2ZpbHRlcl9sYWJlbDogXCJoaWRlIGVtcHR5XCIsIGVtcHR5X3N0YXRlX3RleHRfbGluazogXCJDbGljayBoZXJlXCIsIGVtcHR5X3N0YXRlX3RleHRfZGVzY3JpcHRpb246IFwidG8gY3JlYXRlIHlvdXIgZmlyc3QgdGFza1wiLCBiYXNlbGluZXNfc2VjdGlvbl9wbGFjZWhvbGRlcjogXCJTdGFydCBhZGRpbmcgYSBuZXcgYmFzZWxpbmVcIiwgYmFzZWxpbmVzX2FkZF9idXR0b246IFwiQWRkIEJhc2VsaW5lXCIsIGJhc2VsaW5lc19yZW1vdmVfYnV0dG9uOiBcIlJlbW92ZVwiLCBiYXNlbGluZXNfcmVtb3ZlX2FsbF9idXR0b246IFwiUmVtb3ZlIEFsbFwiLCBkZWFkbGluZV9lbmFibGVfYnV0dG9uOiBcIlNldFwiLCBkZWFkbGluZV9kaXNhYmxlX2J1dHRvbjogXCJSZW1vdmVcIiB9IH0sIEFpID0geyBkYXRlOiB7IG1vbnRoX2Z1bGw6IFtcIkphbnVhclwiLCBcIkZlYnJ1YXJcIiwgXCJNYXJ0c1wiLCBcIkFwcmlsXCIsIFwiTWFqXCIsIFwiSnVuaVwiLCBcIkp1bGlcIiwgXCJBdWd1c3RcIiwgXCJTZXB0ZW1iZXJcIiwgXCJPa3RvYmVyXCIsIFwiTm92ZW1iZXJcIiwgXCJEZWNlbWJlclwiXSwgbW9udGhfc2hvcnQ6IFtcIkphblwiLCBcIkZlYlwiLCBcIk1hclwiLCBcIkFwclwiLCBcIk1halwiLCBcIkp1blwiLCBcIkp1bFwiLCBcIkF1Z1wiLCBcIlNlcFwiLCBcIk9rdFwiLCBcIk5vdlwiLCBcIkRlY1wiXSwgZGF5X2Z1bGw6IFtcIlPDuG5kYWdcIiwgXCJNYW5kYWdcIiwgXCJUaXJzZGFnXCIsIFwiT25zZGFnXCIsIFwiVG9yc2RhZ1wiLCBcIkZyZWRhZ1wiLCBcIkzDuHJkYWdcIl0sIGRheV9zaG9ydDogW1wiU8O4blwiLCBcIk1hblwiLCBcIlRpclwiLCBcIk9uc1wiLCBcIlRvclwiLCBcIkZyZVwiLCBcIkzDuHJcIl0gfSwgbGFiZWxzOiB7IG5ld190YXNrOiBcIk55IG9wZ2F2ZVwiLCBpY29uX3NhdmU6IFwiR2VtXCIsIGljb25fY2FuY2VsOiBcIkZvcnRyeWRcIiwgaWNvbl9kZXRhaWxzOiBcIkRldGFsamVyXCIsIGljb25fZWRpdDogXCJUaWxyZXRcIiwgaWNvbl9kZWxldGU6IFwiU2xldFwiLCBjb25maXJtX2Nsb3Npbmc6IFwiRGluZSByZXR0ZWxzZXIgdmlsIGfDpSB0YWJ0Li4gRXIgZHkgc2lra2VyP1wiLCBjb25maXJtX2RlbGV0aW5nOiBcIkJpZ2l2ZW5oZWRlbiB2aWwgYmxpdmUgc2xldHRldCBwZXJtYW5lbnQuIEVyIGR1IHNpa2tlcj9cIiwgc2VjdGlvbl9kZXNjcmlwdGlvbjogXCJCZXNrcml2ZWxzZVwiLCBzZWN0aW9uX3RpbWU6IFwiVGlkc3BlcmlvZGVcIiwgc2VjdGlvbl90eXBlOiBcIlR5cGVcIiwgc2VjdGlvbl9kZWFkbGluZTogXCJEZWFkbGluZVwiLCBzZWN0aW9uX2Jhc2VsaW5lczogXCJCYXNlbGluZXNcIiwgY29sdW1uX3diczogXCJXQlNcIiwgY29sdW1uX3RleHQ6IFwiVGFzayBuYW1lXCIsIGNvbHVtbl9zdGFydF9kYXRlOiBcIlN0YXJ0IHRpbWVcIiwgY29sdW1uX2R1cmF0aW9uOiBcIkR1cmF0aW9uXCIsIGNvbHVtbl9hZGQ6IFwiXCIsIGxpbms6IFwiTGlua1wiLCBjb25maXJtX2xpbmtfZGVsZXRpbmc6IFwid2lsbCBiZSBkZWxldGVkXCIsIGxpbmtfc3RhcnQ6IFwiIChzdGFydClcIiwgbGlua19lbmQ6IFwiIChlbmQpXCIsIHR5cGVfdGFzazogXCJUYXNrXCIsIHR5cGVfcHJvamVjdDogXCJQcm9qZWN0XCIsIHR5cGVfbWlsZXN0b25lOiBcIk1pbGVzdG9uZVwiLCBtaW51dGVzOiBcIk1pbnV0ZXNcIiwgaG91cnM6IFwiSG91cnNcIiwgZGF5czogXCJEYXlzXCIsIHdlZWtzOiBcIldlZWtcIiwgbW9udGhzOiBcIk1vbnRoc1wiLCB5ZWFyczogXCJZZWFyc1wiLCBtZXNzYWdlX29rOiBcIk9LXCIsIG1lc3NhZ2VfY2FuY2VsOiBcIkZvcnRyeWRcIiwgc2VjdGlvbl9jb25zdHJhaW50OiBcIkNvbnN0cmFpbnRcIiwgY29uc3RyYWludF90eXBlOiBcIkNvbnN0cmFpbnQgdHlwZVwiLCBjb25zdHJhaW50X2RhdGU6IFwiQ29uc3RyYWludCBkYXRlXCIsIGFzYXA6IFwiQXMgU29vbiBBcyBQb3NzaWJsZVwiLCBhbGFwOiBcIkFzIExhdGUgQXMgUG9zc2libGVcIiwgc25ldDogXCJTdGFydCBObyBFYXJsaWVyIFRoYW5cIiwgc25sdDogXCJTdGFydCBObyBMYXRlciBUaGFuXCIsIGZuZXQ6IFwiRmluaXNoIE5vIEVhcmxpZXIgVGhhblwiLCBmbmx0OiBcIkZpbmlzaCBObyBMYXRlciBUaGFuXCIsIG1zbzogXCJNdXN0IFN0YXJ0IE9uXCIsIG1mbzogXCJNdXN0IEZpbmlzaCBPblwiLCByZXNvdXJjZXNfZmlsdGVyX3BsYWNlaG9sZGVyOiBcInR5cGUgdG8gZmlsdGVyXCIsIHJlc291cmNlc19maWx0ZXJfbGFiZWw6IFwiaGlkZSBlbXB0eVwiLCBlbXB0eV9zdGF0ZV90ZXh0X2xpbms6IFwiQ2xpY2sgaGVyZVwiLCBlbXB0eV9zdGF0ZV90ZXh0X2Rlc2NyaXB0aW9uOiBcInRvIGNyZWF0ZSB5b3VyIGZpcnN0IHRhc2tcIiwgYmFzZWxpbmVzX3NlY3Rpb25fcGxhY2Vob2xkZXI6IFwiU3RhcnQgYWRkaW5nIGEgbmV3IGJhc2VsaW5lXCIsIGJhc2VsaW5lc19hZGRfYnV0dG9uOiBcIkFkZCBCYXNlbGluZVwiLCBiYXNlbGluZXNfcmVtb3ZlX2J1dHRvbjogXCJSZW1vdmVcIiwgYmFzZWxpbmVzX3JlbW92ZV9hbGxfYnV0dG9uOiBcIlJlbW92ZSBBbGxcIiwgZGVhZGxpbmVfZW5hYmxlX2J1dHRvbjogXCJTZXRcIiwgZGVhZGxpbmVfZGlzYWJsZV9idXR0b246IFwiUmVtb3ZlXCIgfSB9LCBJaSA9IHsgZGF0ZTogeyBtb250aF9mdWxsOiBbXCIgSmFudWFyXCIsIFwiIEZlYnJ1YXJcIiwgXCIgTcOkcnogXCIsIFwiIEFwcmlsXCIsIFwiIE1haVwiLCBcIiBKdW5pXCIsIFwiIEp1bGlcIiwgXCIgQXVndXN0XCIsIFwiIFNlcHRlbWJlciBcIiwgXCIgT2t0b2JlclwiLCBcIiBOb3ZlbWJlciBcIiwgXCIgRGV6ZW1iZXJcIl0sIG1vbnRoX3Nob3J0OiBbXCJKYW5cIiwgXCJGZWJcIiwgXCJNw6RyXCIsIFwiQXByXCIsIFwiTWFpXCIsIFwiSnVuXCIsIFwiSnVsXCIsIFwiQXVnXCIsIFwiU2VwXCIsIFwiT2t0XCIsIFwiTm92XCIsIFwiRGV6XCJdLCBkYXlfZnVsbDogW1wiU29ubnRhZ1wiLCBcIk1vbnRhZ1wiLCBcIkRpZW5zdGFnXCIsIFwiIE1pdHR3b2NoXCIsIFwiIERvbm5lcnN0YWdcIiwgXCJGcmVpdGFnXCIsIFwiU2Ftc3RhZ1wiXSwgZGF5X3Nob3J0OiBbXCJTb1wiLCBcIk1vXCIsIFwiRGlcIiwgXCJNaVwiLCBcIkRvXCIsIFwiRnJcIiwgXCJTYVwiXSB9LCBsYWJlbHM6IHsgbmV3X3Rhc2s6IFwiTmV1ZSBBdWZnYWJlXCIsIGljb25fc2F2ZTogXCJTcGVpY2hlcm5cIiwgaWNvbl9jYW5jZWw6IFwiQWJicmVjaGVuXCIsIGljb25fZGV0YWlsczogXCJEZXRhaWxzXCIsIGljb25fZWRpdDogXCLDhG5kZXJuXCIsIGljb25fZGVsZXRlOiBcIkzDtnNjaGVuXCIsIGNvbmZpcm1fY2xvc2luZzogXCJcIiwgY29uZmlybV9kZWxldGluZzogXCJEZXIgRWludHJhZyB3aXJkIGdlbMO2c2NodFwiLCBzZWN0aW9uX2Rlc2NyaXB0aW9uOiBcIkJlc2NocmVpYnVuZ1wiLCBzZWN0aW9uX3RpbWU6IFwiWmVpdHNwYW5uZVwiLCBzZWN0aW9uX3R5cGU6IFwiVHlwZVwiLCBzZWN0aW9uX2RlYWRsaW5lOiBcIkRlYWRsaW5lXCIsIHNlY3Rpb25fYmFzZWxpbmVzOiBcIkJhc2VsaW5lc1wiLCBjb2x1bW5fd2JzOiBcIlBTUFwiLCBjb2x1bW5fdGV4dDogXCJUYXNrLU5hbWVuXCIsIGNvbHVtbl9zdGFydF9kYXRlOiBcIlN0YXJ0emVpdFwiLCBjb2x1bW5fZHVyYXRpb246IFwiRGF1ZXJcIiwgY29sdW1uX2FkZDogXCJcIiwgbGluazogXCJMaW5rXCIsIGNvbmZpcm1fbGlua19kZWxldGluZzogXCJ3ZXJkZW4gZ2Vsw7ZzY2h0XCIsIGxpbmtfc3RhcnQ6IFwiKHN0YXJ0ZW4pXCIsIGxpbmtfZW5kOiBcIihlbmRlKVwiLCB0eXBlX3Rhc2s6IFwiVGFza1wiLCB0eXBlX3Byb2plY3Q6IFwiUHJvamVjdFwiLCB0eXBlX21pbGVzdG9uZTogXCJNaWxlc3RvbmVcIiwgbWludXRlczogXCJNaW51dGVuXCIsIGhvdXJzOiBcIlN0dW5kZW5cIiwgZGF5czogXCJUYWdlXCIsIHdlZWtzOiBcIldvY2hlblwiLCBtb250aHM6IFwiTW9uYXRlXCIsIHllYXJzOiBcIkphaHJlXCIsIG1lc3NhZ2Vfb2s6IFwiT0tcIiwgbWVzc2FnZV9jYW5jZWw6IFwiQWJicmVjaGVuXCIsIHNlY3Rpb25fY29uc3RyYWludDogXCJSZWdlbFwiLCBjb25zdHJhaW50X3R5cGU6IFwiUmVnZWxcIiwgY29uc3RyYWludF9kYXRlOiBcIlJlZ2VsIC0gRGF0dW1cIiwgYXNhcDogXCJTbyBiYWxkIHdpZSBtw7ZnbGljaFwiLCBhbGFwOiBcIlNvIHNww6R0IHdpZSBtw7ZnbGljaFwiLCBzbmV0OiBcIkJlZ2lubiBuaWNodCB2b3JcIiwgc25sdDogXCJCZWdpbm4gbmljaHQgc3DDpHRlciBhbHNcIiwgZm5ldDogXCJGZXJ0aWdzdGVsbHVuZyBuaWNodCB2b3JcIiwgZm5sdDogXCJGZXJ0aWdzdGVsbHVuZyBuaWNodCBzcMOkdGVyIGFsc1wiLCBtc286IFwiTXVzcyBiZWdpbm5lbiBhbVwiLCBtZm86IFwiTXVzcyBmZXJ0aWcgc2VpbiBhbVwiLCByZXNvdXJjZXNfZmlsdGVyX3BsYWNlaG9sZGVyOiBcInR5cGUgdG8gZmlsdGVyXCIsIHJlc291cmNlc19maWx0ZXJfbGFiZWw6IFwiaGlkZSBlbXB0eVwiLCBlbXB0eV9zdGF0ZV90ZXh0X2xpbms6IFwiQ2xpY2sgaGVyZVwiLCBlbXB0eV9zdGF0ZV90ZXh0X2Rlc2NyaXB0aW9uOiBcInRvIGNyZWF0ZSB5b3VyIGZpcnN0IHRhc2tcIiwgYmFzZWxpbmVzX3NlY3Rpb25fcGxhY2Vob2xkZXI6IFwiU3RhcnQgYWRkaW5nIGEgbmV3IGJhc2VsaW5lXCIsIGJhc2VsaW5lc19hZGRfYnV0dG9uOiBcIkFkZCBCYXNlbGluZVwiLCBiYXNlbGluZXNfcmVtb3ZlX2J1dHRvbjogXCJSZW1vdmVcIiwgYmFzZWxpbmVzX3JlbW92ZV9hbGxfYnV0dG9uOiBcIlJlbW92ZSBBbGxcIiwgZGVhZGxpbmVfZW5hYmxlX2J1dHRvbjogXCJTZXRcIiwgZGVhZGxpbmVfZGlzYWJsZV9idXR0b246IFwiUmVtb3ZlXCIgfSB9LCBNaSA9IHsgZGF0ZTogeyBtb250aF9mdWxsOiBbXCLOmc6xzr3Ov8+FzqzPgc65zr/PglwiLCBcIs6mzrXOss+Bzr/Phc6sz4HOuc6/z4JcIiwgXCLOnM6sz4HPhM65zr/PglwiLCBcIs6Rz4DPgc6vzrvOuc6/z4JcIiwgXCLOnM6sz4rOv8+CXCIsIFwizpnOv8+Nzr3Ouc6/z4JcIiwgXCLOmc6/z43Ou865zr/PglwiLCBcIs6Rz43Os86/z4XPg8+Ezr/PglwiLCBcIs6jzrXPgM+Ezq3OvM6yz4HOuc6/z4JcIiwgXCLOn866z4TPjs6yz4HOuc6/z4JcIiwgXCLOnc6/zq3OvM6yz4HOuc6/z4JcIiwgXCLOlM61zrrOrc68zrLPgc65zr/PglwiXSwgbW9udGhfc2hvcnQ6IFtcIs6ZzpHOnVwiLCBcIs6mzpXOklwiLCBcIs6czpHOoVwiLCBcIs6RzqDOoVwiLCBcIs6czpHOmVwiLCBcIs6Zzp/Opc6dXCIsIFwizpnOn86lzptcIiwgXCLOkc6lzpNcIiwgXCLOo86VzqBcIiwgXCLOn86azqRcIiwgXCLOnc6fzpVcIiwgXCLOlM6VzppcIl0sIGRheV9mdWxsOiBbXCLOms+Fz4HOuc6xzrrOrlwiLCBcIs6UzrXPhc+Ezq3Pgc6xXCIsIFwizqTPgc6vz4TOt1wiLCBcIs6kzrXPhM6sz4HPhM63XCIsIFwizqDOrc68z4DPhM63XCIsIFwizqDOsc+BzrHPg866zrXPhc6uXCIsIFwizprPhc+BzrnOsc66zq5cIl0sIGRheV9zaG9ydDogW1wizprOpVwiLCBcIs6UzpVcIiwgXCLOpM6hXCIsIFwizqTOlVwiLCBcIs6gzpVcIiwgXCLOoM6RXCIsIFwizqPOkVwiXSB9LCBsYWJlbHM6IHsgbmV3X3Rhc2s6IFwizp3Orc6xIM61z4HOs86xz4POr86xXCIsIGljb25fc2F2ZTogXCLOkc+Azr/OuM6uzrrOtc+Fz4POt1wiLCBpY29uX2NhbmNlbDogXCLOhs66z4XPgc6/XCIsIGljb25fZGV0YWlsczogXCLOm861z4DPhM6/zrzOrc+BzrXOuc61z4JcIiwgaWNvbl9lZGl0OiBcIs6Vz4DOtc6+zrXPgc6zzrHPg86vzrFcIiwgaWNvbl9kZWxldGU6IFwizpTOuc6xzrPPgc6xz4bOrlwiLCBjb25maXJtX2Nsb3Npbmc6IFwiXCIsIGNvbmZpcm1fZGVsZXRpbmc6IFwizqTOvyDOrc+BzrPOvyDOuM6xIM60zrnOsc6zz4HOsc+GzrXOryDOv8+BzrnPg8+EzrnOus6sLiDOmM6tzrvOtc+EzrUgzr3OsSDPg8+Fzr3Otc+Hzq/Pg861z4TOtTtcIiwgc2VjdGlvbl9kZXNjcmlwdGlvbjogXCLOoM61z4HOuc6zz4HOsc+Gzq5cIiwgc2VjdGlvbl90aW1lOiBcIs6nz4HOv869zrnOus6uIM+AzrXPgc6vzr/OtM6/z4JcIiwgc2VjdGlvbl90eXBlOiBcIlR5cGVcIiwgc2VjdGlvbl9kZWFkbGluZTogXCJEZWFkbGluZVwiLCBzZWN0aW9uX2Jhc2VsaW5lczogXCJCYXNlbGluZXNcIiwgY29sdW1uX3diczogXCJXQlNcIiwgY29sdW1uX3RleHQ6IFwiVGFzayBuYW1lXCIsIGNvbHVtbl9zdGFydF9kYXRlOiBcIlN0YXJ0IHRpbWVcIiwgY29sdW1uX2R1cmF0aW9uOiBcIkR1cmF0aW9uXCIsIGNvbHVtbl9hZGQ6IFwiXCIsIGxpbms6IFwiTGlua1wiLCBjb25maXJtX2xpbmtfZGVsZXRpbmc6IFwid2lsbCBiZSBkZWxldGVkXCIsIGxpbmtfc3RhcnQ6IFwiIChzdGFydClcIiwgbGlua19lbmQ6IFwiIChlbmQpXCIsIHR5cGVfdGFzazogXCJUYXNrXCIsIHR5cGVfcHJvamVjdDogXCJQcm9qZWN0XCIsIHR5cGVfbWlsZXN0b25lOiBcIk1pbGVzdG9uZVwiLCBtaW51dGVzOiBcIk1pbnV0ZXNcIiwgaG91cnM6IFwiSG91cnNcIiwgZGF5czogXCJEYXlzXCIsIHdlZWtzOiBcIldlZWtcIiwgbW9udGhzOiBcIk1vbnRoc1wiLCB5ZWFyczogXCJZZWFyc1wiLCBtZXNzYWdlX29rOiBcIk9LXCIsIG1lc3NhZ2VfY2FuY2VsOiBcIs6GzrrPhc+Bzr9cIiwgc2VjdGlvbl9jb25zdHJhaW50OiBcIkNvbnN0cmFpbnRcIiwgY29uc3RyYWludF90eXBlOiBcIkNvbnN0cmFpbnQgdHlwZVwiLCBjb25zdHJhaW50X2RhdGU6IFwiQ29uc3RyYWludCBkYXRlXCIsIGFzYXA6IFwiQXMgU29vbiBBcyBQb3NzaWJsZVwiLCBhbGFwOiBcIkFzIExhdGUgQXMgUG9zc2libGVcIiwgc25ldDogXCJTdGFydCBObyBFYXJsaWVyIFRoYW5cIiwgc25sdDogXCJTdGFydCBObyBMYXRlciBUaGFuXCIsIGZuZXQ6IFwiRmluaXNoIE5vIEVhcmxpZXIgVGhhblwiLCBmbmx0OiBcIkZpbmlzaCBObyBMYXRlciBUaGFuXCIsIG1zbzogXCJNdXN0IFN0YXJ0IE9uXCIsIG1mbzogXCJNdXN0IEZpbmlzaCBPblwiLCByZXNvdXJjZXNfZmlsdGVyX3BsYWNlaG9sZGVyOiBcInR5cGUgdG8gZmlsdGVyXCIsIHJlc291cmNlc19maWx0ZXJfbGFiZWw6IFwiaGlkZSBlbXB0eVwiLCBlbXB0eV9zdGF0ZV90ZXh0X2xpbms6IFwiQ2xpY2sgaGVyZVwiLCBlbXB0eV9zdGF0ZV90ZXh0X2Rlc2NyaXB0aW9uOiBcInRvIGNyZWF0ZSB5b3VyIGZpcnN0IHRhc2tcIiwgYmFzZWxpbmVzX3NlY3Rpb25fcGxhY2Vob2xkZXI6IFwiU3RhcnQgYWRkaW5nIGEgbmV3IGJhc2VsaW5lXCIsIGJhc2VsaW5lc19hZGRfYnV0dG9uOiBcIkFkZCBCYXNlbGluZVwiLCBiYXNlbGluZXNfcmVtb3ZlX2J1dHRvbjogXCJSZW1vdmVcIiwgYmFzZWxpbmVzX3JlbW92ZV9hbGxfYnV0dG9uOiBcIlJlbW92ZSBBbGxcIiwgZGVhZGxpbmVfZW5hYmxlX2J1dHRvbjogXCJTZXRcIiwgZGVhZGxpbmVfZGlzYWJsZV9idXR0b246IFwiUmVtb3ZlXCIgfSB9LCBOaSA9IHsgZGF0ZTogeyBtb250aF9mdWxsOiBbXCJKYW51YXJ5XCIsIFwiRmVicnVhcnlcIiwgXCJNYXJjaFwiLCBcIkFwcmlsXCIsIFwiTWF5XCIsIFwiSnVuZVwiLCBcIkp1bHlcIiwgXCJBdWd1c3RcIiwgXCJTZXB0ZW1iZXJcIiwgXCJPY3RvYmVyXCIsIFwiTm92ZW1iZXJcIiwgXCJEZWNlbWJlclwiXSwgbW9udGhfc2hvcnQ6IFtcIkphblwiLCBcIkZlYlwiLCBcIk1hclwiLCBcIkFwclwiLCBcIk1heVwiLCBcIkp1blwiLCBcIkp1bFwiLCBcIkF1Z1wiLCBcIlNlcFwiLCBcIk9jdFwiLCBcIk5vdlwiLCBcIkRlY1wiXSwgZGF5X2Z1bGw6IFtcIlN1bmRheVwiLCBcIk1vbmRheVwiLCBcIlR1ZXNkYXlcIiwgXCJXZWRuZXNkYXlcIiwgXCJUaHVyc2RheVwiLCBcIkZyaWRheVwiLCBcIlNhdHVyZGF5XCJdLCBkYXlfc2hvcnQ6IFtcIlN1blwiLCBcIk1vblwiLCBcIlR1ZVwiLCBcIldlZFwiLCBcIlRodVwiLCBcIkZyaVwiLCBcIlNhdFwiXSB9LCBsYWJlbHM6IHsgbmV3X3Rhc2s6IFwiTmV3IHRhc2tcIiwgaWNvbl9zYXZlOiBcIlNhdmVcIiwgaWNvbl9jYW5jZWw6IFwiQ2FuY2VsXCIsIGljb25fZGV0YWlsczogXCJEZXRhaWxzXCIsIGljb25fZWRpdDogXCJFZGl0XCIsIGljb25fZGVsZXRlOiBcIkRlbGV0ZVwiLCBjb25maXJtX2Nsb3Npbmc6IFwiXCIsIGNvbmZpcm1fZGVsZXRpbmc6IFwiVGFzayB3aWxsIGJlIGRlbGV0ZWQgcGVybWFuZW50bHksIGFyZSB5b3Ugc3VyZT9cIiwgc2VjdGlvbl9kZXNjcmlwdGlvbjogXCJEZXNjcmlwdGlvblwiLCBzZWN0aW9uX3RpbWU6IFwiVGltZSBwZXJpb2RcIiwgc2VjdGlvbl90eXBlOiBcIlR5cGVcIiwgc2VjdGlvbl9kZWFkbGluZTogXCJEZWFkbGluZVwiLCBzZWN0aW9uX2Jhc2VsaW5lczogXCJCYXNlbGluZXNcIiwgY29sdW1uX3diczogXCJXQlNcIiwgY29sdW1uX3RleHQ6IFwiVGFzayBuYW1lXCIsIGNvbHVtbl9zdGFydF9kYXRlOiBcIlN0YXJ0IHRpbWVcIiwgY29sdW1uX2R1cmF0aW9uOiBcIkR1cmF0aW9uXCIsIGNvbHVtbl9hZGQ6IFwiXCIsIGxpbms6IFwiTGlua1wiLCBjb25maXJtX2xpbmtfZGVsZXRpbmc6IFwid2lsbCBiZSBkZWxldGVkXCIsIGxpbmtfc3RhcnQ6IFwiIChzdGFydClcIiwgbGlua19lbmQ6IFwiIChlbmQpXCIsIHR5cGVfdGFzazogXCJUYXNrXCIsIHR5cGVfcHJvamVjdDogXCJQcm9qZWN0XCIsIHR5cGVfbWlsZXN0b25lOiBcIk1pbGVzdG9uZVwiLCBtaW51dGVzOiBcIk1pbnV0ZXNcIiwgaG91cnM6IFwiSG91cnNcIiwgZGF5czogXCJEYXlzXCIsIHdlZWtzOiBcIldlZWtcIiwgbW9udGhzOiBcIk1vbnRoc1wiLCB5ZWFyczogXCJZZWFyc1wiLCBtZXNzYWdlX29rOiBcIk9LXCIsIG1lc3NhZ2VfY2FuY2VsOiBcIkNhbmNlbFwiLCBzZWN0aW9uX2NvbnN0cmFpbnQ6IFwiQ29uc3RyYWludFwiLCBjb25zdHJhaW50X3R5cGU6IFwiQ29uc3RyYWludCB0eXBlXCIsIGNvbnN0cmFpbnRfZGF0ZTogXCJDb25zdHJhaW50IGRhdGVcIiwgYXNhcDogXCJBcyBTb29uIEFzIFBvc3NpYmxlXCIsIGFsYXA6IFwiQXMgTGF0ZSBBcyBQb3NzaWJsZVwiLCBzbmV0OiBcIlN0YXJ0IE5vIEVhcmxpZXIgVGhhblwiLCBzbmx0OiBcIlN0YXJ0IE5vIExhdGVyIFRoYW5cIiwgZm5ldDogXCJGaW5pc2ggTm8gRWFybGllciBUaGFuXCIsIGZubHQ6IFwiRmluaXNoIE5vIExhdGVyIFRoYW5cIiwgbXNvOiBcIk11c3QgU3RhcnQgT25cIiwgbWZvOiBcIk11c3QgRmluaXNoIE9uXCIsIHJlc291cmNlc19maWx0ZXJfcGxhY2Vob2xkZXI6IFwidHlwZSB0byBmaWx0ZXJcIiwgcmVzb3VyY2VzX2ZpbHRlcl9sYWJlbDogXCJoaWRlIGVtcHR5XCIsIGVtcHR5X3N0YXRlX3RleHRfbGluazogXCJDbGljayBoZXJlXCIsIGVtcHR5X3N0YXRlX3RleHRfZGVzY3JpcHRpb246IFwidG8gY3JlYXRlIHlvdXIgZmlyc3QgdGFza1wiLCBiYXNlbGluZXNfc2VjdGlvbl9wbGFjZWhvbGRlcjogXCJTdGFydCBhZGRpbmcgYSBuZXcgYmFzZWxpbmVcIiwgYmFzZWxpbmVzX2FkZF9idXR0b246IFwiQWRkIEJhc2VsaW5lXCIsIGJhc2VsaW5lc19yZW1vdmVfYnV0dG9uOiBcIlJlbW92ZVwiLCBiYXNlbGluZXNfcmVtb3ZlX2FsbF9idXR0b246IFwiUmVtb3ZlIEFsbFwiLCBkZWFkbGluZV9lbmFibGVfYnV0dG9uOiBcIlNldFwiLCBkZWFkbGluZV9kaXNhYmxlX2J1dHRvbjogXCJSZW1vdmVcIiB9IH0sIExpID0geyBkYXRlOiB7IG1vbnRoX2Z1bGw6IFtcIkVuZXJvXCIsIFwiRmVicmVyb1wiLCBcIk1hcnpvXCIsIFwiQWJyaWxcIiwgXCJNYXlvXCIsIFwiSnVuaW9cIiwgXCJKdWxpb1wiLCBcIkFnb3N0b1wiLCBcIlNlcHRpZW1icmVcIiwgXCJPY3R1YnJlXCIsIFwiTm92aWVtYnJlXCIsIFwiRGljaWVtYnJlXCJdLCBtb250aF9zaG9ydDogW1wiRW5lXCIsIFwiRmViXCIsIFwiTWFyXCIsIFwiQWJyXCIsIFwiTWF5XCIsIFwiSnVuXCIsIFwiSnVsXCIsIFwiQWdvXCIsIFwiU2VwXCIsIFwiT2N0XCIsIFwiTm92XCIsIFwiRGljXCJdLCBkYXlfZnVsbDogW1wiRG9taW5nb1wiLCBcIkx1bmVzXCIsIFwiTWFydGVzXCIsIFwiTWnDqXJjb2xlc1wiLCBcIkp1ZXZlc1wiLCBcIlZpZXJuZXNcIiwgXCJTw6FiYWRvXCJdLCBkYXlfc2hvcnQ6IFtcIkRvbVwiLCBcIkx1blwiLCBcIk1hclwiLCBcIk1pw6lcIiwgXCJKdWVcIiwgXCJWaWVcIiwgXCJTw6FiXCJdIH0sIGxhYmVsczogeyBuZXdfdGFzazogXCJOdWV2YSB0YXJlYVwiLCBpY29uX3NhdmU6IFwiR3VhcmRhclwiLCBpY29uX2NhbmNlbDogXCJDYW5jZWxhclwiLCBpY29uX2RldGFpbHM6IFwiRGV0YWxsZXNcIiwgaWNvbl9lZGl0OiBcIkVkaXRhclwiLCBpY29uX2RlbGV0ZTogXCJFbGltaW5hclwiLCBjb25maXJtX2Nsb3Npbmc6IFwiXCIsIGNvbmZpcm1fZGVsZXRpbmc6IFwiRWwgZXZlbnRvIHNlIGJvcnJhcsOhIGRlZmluaXRpdmFtZW50ZSwgwr9jb250aW51YXI/XCIsIHNlY3Rpb25fZGVzY3JpcHRpb246IFwiRGVzY3JpcGNpw7NuXCIsIHNlY3Rpb25fdGltZTogXCJQZXLDrW9kb1wiLCBzZWN0aW9uX3R5cGU6IFwiVGlwb1wiLCBzZWN0aW9uX2RlYWRsaW5lOiBcIkRlYWRsaW5lXCIsIHNlY3Rpb25fYmFzZWxpbmVzOiBcIkJhc2VsaW5lc1wiLCBjb2x1bW5fd2JzOiBcIkVEVFwiLCBjb2x1bW5fdGV4dDogXCJUYXJlYVwiLCBjb2x1bW5fc3RhcnRfZGF0ZTogXCJJbmljaW9cIiwgY29sdW1uX2R1cmF0aW9uOiBcIkR1cmFjacOzblwiLCBjb2x1bW5fYWRkOiBcIlwiLCBsaW5rOiBcIkVubGFjZVwiLCBjb25maXJtX2xpbmtfZGVsZXRpbmc6IFwic2Vyw6EgYm9ycmFkYVwiLCBsaW5rX3N0YXJ0OiBcIiAoaW5pY2lvKVwiLCBsaW5rX2VuZDogXCIgKGZpbilcIiwgdHlwZV90YXNrOiBcIlRhcmVhXCIsIHR5cGVfcHJvamVjdDogXCJQcm95ZWN0b1wiLCB0eXBlX21pbGVzdG9uZTogXCJIaXRvXCIsIG1pbnV0ZXM6IFwiTWludXRvc1wiLCBob3VyczogXCJIb3Jhc1wiLCBkYXlzOiBcIkTDrWFzXCIsIHdlZWtzOiBcIlNlbWFuYXNcIiwgbW9udGhzOiBcIk1lc2VzXCIsIHllYXJzOiBcIkHDsW9zXCIsIG1lc3NhZ2Vfb2s6IFwiT0tcIiwgbWVzc2FnZV9jYW5jZWw6IFwiQ2FuY2VsYXJcIiwgc2VjdGlvbl9jb25zdHJhaW50OiBcIkNvbnN0cmFpbnRcIiwgY29uc3RyYWludF90eXBlOiBcIkNvbnN0cmFpbnQgdHlwZVwiLCBjb25zdHJhaW50X2RhdGU6IFwiQ29uc3RyYWludCBkYXRlXCIsIGFzYXA6IFwiQXMgU29vbiBBcyBQb3NzaWJsZVwiLCBhbGFwOiBcIkFzIExhdGUgQXMgUG9zc2libGVcIiwgc25ldDogXCJTdGFydCBObyBFYXJsaWVyIFRoYW5cIiwgc25sdDogXCJTdGFydCBObyBMYXRlciBUaGFuXCIsIGZuZXQ6IFwiRmluaXNoIE5vIEVhcmxpZXIgVGhhblwiLCBmbmx0OiBcIkZpbmlzaCBObyBMYXRlciBUaGFuXCIsIG1zbzogXCJNdXN0IFN0YXJ0IE9uXCIsIG1mbzogXCJNdXN0IEZpbmlzaCBPblwiLCByZXNvdXJjZXNfZmlsdGVyX3BsYWNlaG9sZGVyOiBcInR5cGUgdG8gZmlsdGVyXCIsIHJlc291cmNlc19maWx0ZXJfbGFiZWw6IFwiaGlkZSBlbXB0eVwiLCBlbXB0eV9zdGF0ZV90ZXh0X2xpbms6IFwiQ2xpY2sgaGVyZVwiLCBlbXB0eV9zdGF0ZV90ZXh0X2Rlc2NyaXB0aW9uOiBcInRvIGNyZWF0ZSB5b3VyIGZpcnN0IHRhc2tcIiwgYmFzZWxpbmVzX3NlY3Rpb25fcGxhY2Vob2xkZXI6IFwiU3RhcnQgYWRkaW5nIGEgbmV3IGJhc2VsaW5lXCIsIGJhc2VsaW5lc19hZGRfYnV0dG9uOiBcIkFkZCBCYXNlbGluZVwiLCBiYXNlbGluZXNfcmVtb3ZlX2J1dHRvbjogXCJSZW1vdmVcIiwgYmFzZWxpbmVzX3JlbW92ZV9hbGxfYnV0dG9uOiBcIlJlbW92ZSBBbGxcIiwgZGVhZGxpbmVfZW5hYmxlX2J1dHRvbjogXCJTZXRcIiwgZGVhZGxpbmVfZGlzYWJsZV9idXR0b246IFwiUmVtb3ZlXCIgfSB9LCBQaSA9IHsgZGF0ZTogeyBtb250aF9mdWxsOiBbXCLamNin2YbZiNuM2YdcIiwgXCLZgdmI2LHbjNmHXCIsIFwi2YXYp9ix2LNcIiwgXCLYotmI2LHbjNmEXCIsIFwi2YXZh1wiLCBcItqY2YjYptmGXCIsIFwi2pjZiNim24zZh1wiLCBcItin2YjYqlwiLCBcItiz2b7Yqtin2YXYqNixXCIsIFwi2Kfaqdiq2KjYsVwiLCBcItmG2YjYp9mF2KjYsVwiLCBcItiv2LPYp9mF2KjYsVwiXSwgbW9udGhfc2hvcnQ6IFtcIjFcIiwgXCIyXCIsIFwiM1wiLCBcIjRcIiwgXCI1XCIsIFwiNlwiLCBcIjdcIiwgXCI4XCIsIFwiOVwiLCBcIjEwXCIsIFwiMTFcIiwgXCIxMlwiXSwgZGF5X2Z1bGw6IFtcItmK2qnYtNmG2KjZh1wiLCBcItiv2YjYtNmG2KjZh1wiLCBcItiz2YfigIzYtNmG2KjZh1wiLCBcItqG2YfYp9ix2LTZhtio2YdcIiwgXCLZvtmG2KzYtNmG2KjZh1wiLCBcItis2YXYudmHXCIsIFwi2LTZhtio2YdcIl0sIGRheV9zaG9ydDogW1wi24xcIiwgXCLYr1wiLCBcItizXCIsIFwi2oZcIiwgXCLZvlwiLCBcItisXCIsIFwi2LRcIl0gfSwgbGFiZWxzOiB7IG5ld190YXNrOiBcItmI2LjbjNmB2Ycg2KzYr9uM2K9cIiwgaWNvbl9zYXZlOiBcItiw2K7bjNix2YdcIiwgaWNvbl9jYW5jZWw6IFwi2YTYutmIXCIsIGljb25fZGV0YWlsczogXCLYrNiy24zbjNin2KpcIiwgaWNvbl9lZGl0OiBcItmI24zYsdin24zYtFwiLCBpY29uX2RlbGV0ZTogXCLYrdiw2YFcIiwgY29uZmlybV9jbG9zaW5nOiBcItiq2LrbjNuM2LHYp9iqINi02YXYpyDYp9iy2K/Ys9iqINiu2YjYp9mH2K8g2LHZgdiq2Iwg2KLbjNinINmF2LfZhdim2YYg2YfYs9iq24zYr9ifXCIsIGNvbmZpcm1fZGVsZXRpbmc6IFwi2KfbjNmGINmF2YjYsdivINio2LHYp9uMINmH2YXbjNi02Ycg2K3YsNmBINiu2YjYp9mH2K8g2LTYr9iMINii24zYpyDZhdi32YXYptmGINmH2LPYqtuM2K/Yn1wiLCBzZWN0aW9uX2Rlc2NyaXB0aW9uOiBcItiq2YjYttuM2K3Yp9iqXCIsIHNlY3Rpb25fdGltZTogXCLZhdiv2Kog2LLZhdin2YZcIiwgc2VjdGlvbl90eXBlOiBcItmG2YjYuVwiLCBzZWN0aW9uX2RlYWRsaW5lOiBcIkRlYWRsaW5lXCIsIHNlY3Rpb25fYmFzZWxpbmVzOiBcIkJhc2VsaW5lc1wiLCBjb2x1bW5fd2JzOiBcIldCU1wiLCBjb2x1bW5fdGV4dDogXCLYudmG2YjYp9mGXCIsIGNvbHVtbl9zdGFydF9kYXRlOiBcItiy2YXYp9mGINi02LHZiNi5XCIsIGNvbHVtbl9kdXJhdGlvbjogXCLZhdiv2KpcIiwgY29sdW1uX2FkZDogXCJcIiwgbGluazogXCLYp9ix2KrYqNin2LdcIiwgY29uZmlybV9saW5rX2RlbGV0aW5nOiBcItit2LDZgSDYrtmI2KfZh9ivINi02K9cIiwgbGlua19zdGFydDogXCIgKNii2LrYp9iyKVwiLCBsaW5rX2VuZDogXCIgKNm+2KfbjNin2YYpXCIsIHR5cGVfdGFzazogXCLZiNi424zZgdmHXCIsIHR5cGVfcHJvamVjdDogXCLZvtix2YjamNmHXCIsIHR5cGVfbWlsZXN0b25lOiBcItmG2q/Yp9ix2LRcIiwgbWludXRlczogXCLYr9mC2KfbjNmCXCIsIGhvdXJzOiBcItiz2KfYudin2KpcIiwgZGF5czogXCLYsdmI2LLZh9inXCIsIHdlZWtzOiBcItmH2YHYqtmHXCIsIG1vbnRoczogXCLZhdin2YfigIzZh9inXCIsIHllYXJzOiBcItiz2KfZhOKAjNmH2KdcIiwgbWVzc2FnZV9vazogXCLYqtin24zbjNivXCIsIG1lc3NhZ2VfY2FuY2VsOiBcItmE2LrZiFwiLCBzZWN0aW9uX2NvbnN0cmFpbnQ6IFwiQ29uc3RyYWludFwiLCBjb25zdHJhaW50X3R5cGU6IFwiQ29uc3RyYWludCB0eXBlXCIsIGNvbnN0cmFpbnRfZGF0ZTogXCJDb25zdHJhaW50IGRhdGVcIiwgYXNhcDogXCJBcyBTb29uIEFzIFBvc3NpYmxlXCIsIGFsYXA6IFwiQXMgTGF0ZSBBcyBQb3NzaWJsZVwiLCBzbmV0OiBcIlN0YXJ0IE5vIEVhcmxpZXIgVGhhblwiLCBzbmx0OiBcIlN0YXJ0IE5vIExhdGVyIFRoYW5cIiwgZm5ldDogXCJGaW5pc2ggTm8gRWFybGllciBUaGFuXCIsIGZubHQ6IFwiRmluaXNoIE5vIExhdGVyIFRoYW5cIiwgbXNvOiBcIk11c3QgU3RhcnQgT25cIiwgbWZvOiBcIk11c3QgRmluaXNoIE9uXCIsIHJlc291cmNlc19maWx0ZXJfcGxhY2Vob2xkZXI6IFwidHlwZSB0byBmaWx0ZXJcIiwgcmVzb3VyY2VzX2ZpbHRlcl9sYWJlbDogXCJoaWRlIGVtcHR5XCIsIGVtcHR5X3N0YXRlX3RleHRfbGluazogXCJDbGljayBoZXJlXCIsIGVtcHR5X3N0YXRlX3RleHRfZGVzY3JpcHRpb246IFwidG8gY3JlYXRlIHlvdXIgZmlyc3QgdGFza1wiLCBiYXNlbGluZXNfc2VjdGlvbl9wbGFjZWhvbGRlcjogXCJTdGFydCBhZGRpbmcgYSBuZXcgYmFzZWxpbmVcIiwgYmFzZWxpbmVzX2FkZF9idXR0b246IFwiQWRkIEJhc2VsaW5lXCIsIGJhc2VsaW5lc19yZW1vdmVfYnV0dG9uOiBcIlJlbW92ZVwiLCBiYXNlbGluZXNfcmVtb3ZlX2FsbF9idXR0b246IFwiUmVtb3ZlIEFsbFwiLCBkZWFkbGluZV9lbmFibGVfYnV0dG9uOiBcIlNldFwiLCBkZWFkbGluZV9kaXNhYmxlX2J1dHRvbjogXCJSZW1vdmVcIiB9IH0sIFJpID0geyBkYXRlOiB7IG1vbnRoX2Z1bGw6IFtcIlRhbW1pa3V1XCIsIFwiSGVsbWlrdXVcIiwgXCJNYWFsaXNrdXVcIiwgXCJIdWh0aWt1dVwiLCBcIlRvdWtva3V1XCIsIFwiS2VzJmF1bWw7a3V1XCIsIFwiSGVpbiZhdW1sO2t1dVwiLCBcIkVsb2t1dVwiLCBcIlN5eXNrdXVcIiwgXCJMb2tha3V1XCIsIFwiTWFycmFza3V1XCIsIFwiSm91bHVrdXVcIl0sIG1vbnRoX3Nob3J0OiBbXCJUYW1cIiwgXCJIZWxcIiwgXCJNYWFcIiwgXCJIdWhcIiwgXCJUb3VcIiwgXCJLZXNcIiwgXCJIZWlcIiwgXCJFbG9cIiwgXCJTeXlcIiwgXCJMb2tcIiwgXCJNYXJcIiwgXCJKb3VcIl0sIGRheV9mdWxsOiBbXCJTdW5udW50YWlcIiwgXCJNYWFuYW50YWlcIiwgXCJUaWlzdGFpXCIsIFwiS2Vza2l2aWlra29cIiwgXCJUb3JzdGFpXCIsIFwiUGVyamFudGFpXCIsIFwiTGF1YW50YWlcIl0sIGRheV9zaG9ydDogW1wiU3VcIiwgXCJNYVwiLCBcIlRpXCIsIFwiS2VcIiwgXCJUb1wiLCBcIlBlXCIsIFwiTGFcIl0gfSwgbGFiZWxzOiB7IG5ld190YXNrOiBcIlV1c2kgdGVodMOkdsOkXCIsIGljb25fc2F2ZTogXCJUYWxsZW5uYVwiLCBpY29uX2NhbmNlbDogXCJQZXJ1XCIsIGljb25fZGV0YWlsczogXCJUaWVkb3RcIiwgaWNvbl9lZGl0OiBcIk11b2trYWFcIiwgaWNvbl9kZWxldGU6IFwiUG9pc3RhXCIsIGNvbmZpcm1fY2xvc2luZzogXCJcIiwgY29uZmlybV9kZWxldGluZzogXCJIYWx1YXRrbyB2YXJtYXN0aSBwb2lzdGFhIHRhcGFodHVtYW4/XCIsIHNlY3Rpb25fZGVzY3JpcHRpb246IFwiS3V2YXVzXCIsIHNlY3Rpb25fdGltZTogXCJBaWthamFrc29cIiwgc2VjdGlvbl90eXBlOiBcIlR5cGVcIiwgc2VjdGlvbl9kZWFkbGluZTogXCJEZWFkbGluZVwiLCBzZWN0aW9uX2Jhc2VsaW5lczogXCJCYXNlbGluZXNcIiwgY29sdW1uX3diczogXCJXQlNcIiwgY29sdW1uX3RleHQ6IFwiVGFzayBuYW1lXCIsIGNvbHVtbl9zdGFydF9kYXRlOiBcIlN0YXJ0IHRpbWVcIiwgY29sdW1uX2R1cmF0aW9uOiBcIkR1cmF0aW9uXCIsIGNvbHVtbl9hZGQ6IFwiXCIsIGxpbms6IFwiTGlua1wiLCBjb25maXJtX2xpbmtfZGVsZXRpbmc6IFwid2lsbCBiZSBkZWxldGVkXCIsIGxpbmtfc3RhcnQ6IFwiIChzdGFydClcIiwgbGlua19lbmQ6IFwiIChlbmQpXCIsIHR5cGVfdGFzazogXCJUYXNrXCIsIHR5cGVfcHJvamVjdDogXCJQcm9qZWN0XCIsIHR5cGVfbWlsZXN0b25lOiBcIk1pbGVzdG9uZVwiLCBtaW51dGVzOiBcIk1pbnV0ZXNcIiwgaG91cnM6IFwiSG91cnNcIiwgZGF5czogXCJEYXlzXCIsIHdlZWtzOiBcIldlZWtcIiwgbW9udGhzOiBcIk1vbnRoc1wiLCB5ZWFyczogXCJZZWFyc1wiLCBtZXNzYWdlX29rOiBcIk9LXCIsIG1lc3NhZ2VfY2FuY2VsOiBcIlBlcnVcIiwgc2VjdGlvbl9jb25zdHJhaW50OiBcIkNvbnN0cmFpbnRcIiwgY29uc3RyYWludF90eXBlOiBcIkNvbnN0cmFpbnQgdHlwZVwiLCBjb25zdHJhaW50X2RhdGU6IFwiQ29uc3RyYWludCBkYXRlXCIsIGFzYXA6IFwiQXMgU29vbiBBcyBQb3NzaWJsZVwiLCBhbGFwOiBcIkFzIExhdGUgQXMgUG9zc2libGVcIiwgc25ldDogXCJTdGFydCBObyBFYXJsaWVyIFRoYW5cIiwgc25sdDogXCJTdGFydCBObyBMYXRlciBUaGFuXCIsIGZuZXQ6IFwiRmluaXNoIE5vIEVhcmxpZXIgVGhhblwiLCBmbmx0OiBcIkZpbmlzaCBObyBMYXRlciBUaGFuXCIsIG1zbzogXCJNdXN0IFN0YXJ0IE9uXCIsIG1mbzogXCJNdXN0IEZpbmlzaCBPblwiLCByZXNvdXJjZXNfZmlsdGVyX3BsYWNlaG9sZGVyOiBcInR5cGUgdG8gZmlsdGVyXCIsIHJlc291cmNlc19maWx0ZXJfbGFiZWw6IFwiaGlkZSBlbXB0eVwiLCBlbXB0eV9zdGF0ZV90ZXh0X2xpbms6IFwiQ2xpY2sgaGVyZVwiLCBlbXB0eV9zdGF0ZV90ZXh0X2Rlc2NyaXB0aW9uOiBcInRvIGNyZWF0ZSB5b3VyIGZpcnN0IHRhc2tcIiwgYmFzZWxpbmVzX3NlY3Rpb25fcGxhY2Vob2xkZXI6IFwiU3RhcnQgYWRkaW5nIGEgbmV3IGJhc2VsaW5lXCIsIGJhc2VsaW5lc19hZGRfYnV0dG9uOiBcIkFkZCBCYXNlbGluZVwiLCBiYXNlbGluZXNfcmVtb3ZlX2J1dHRvbjogXCJSZW1vdmVcIiwgYmFzZWxpbmVzX3JlbW92ZV9hbGxfYnV0dG9uOiBcIlJlbW92ZSBBbGxcIiwgZGVhZGxpbmVfZW5hYmxlX2J1dHRvbjogXCJTZXRcIiwgZGVhZGxpbmVfZGlzYWJsZV9idXR0b246IFwiUmVtb3ZlXCIgfSB9LCBIaSA9IHsgZGF0ZTogeyBtb250aF9mdWxsOiBbXCJKYW52aWVyXCIsIFwiRsOpdnJpZXJcIiwgXCJNYXJzXCIsIFwiQXZyaWxcIiwgXCJNYWlcIiwgXCJKdWluXCIsIFwiSnVpbGxldFwiLCBcIkFvw7t0XCIsIFwiU2VwdGVtYnJlXCIsIFwiT2N0b2JyZVwiLCBcIk5vdmVtYnJlXCIsIFwiRMOpY2VtYnJlXCJdLCBtb250aF9zaG9ydDogW1wiSmFuXCIsIFwiRsOpdlwiLCBcIk1hclwiLCBcIkF2clwiLCBcIk1haVwiLCBcIkp1aW5cIiwgXCJKdWlsXCIsIFwiQW/Du1wiLCBcIlNlcFwiLCBcIk9jdFwiLCBcIk5vdlwiLCBcIkTDqWNcIl0sIGRheV9mdWxsOiBbXCJEaW1hbmNoZVwiLCBcIkx1bmRpXCIsIFwiTWFyZGlcIiwgXCJNZXJjcmVkaVwiLCBcIkpldWRpXCIsIFwiVmVuZHJlZGlcIiwgXCJTYW1lZGlcIl0sIGRheV9zaG9ydDogW1wiRGltXCIsIFwiTHVuXCIsIFwiTWFyXCIsIFwiTWVyXCIsIFwiSmV1XCIsIFwiVmVuXCIsIFwiU2FtXCJdIH0sIGxhYmVsczogeyBuZXdfdGFzazogXCJOb3V2ZWxsZSB0w6JjaGVcIiwgaWNvbl9zYXZlOiBcIkVucmVnaXN0cmVyXCIsIGljb25fY2FuY2VsOiBcIkFubnVsZXJcIiwgaWNvbl9kZXRhaWxzOiBcIkTDqXRhaWxzXCIsIGljb25fZWRpdDogXCJNb2RpZmllclwiLCBpY29uX2RlbGV0ZTogXCJFZmZhY2VyXCIsIGNvbmZpcm1fY2xvc2luZzogXCJcIiwgY29uZmlybV9kZWxldGluZzogXCJMJ8OpdsOpbmVtZW50IHNlcmEgZWZmYWPDqSBzYW5zIGFwcGVsLCDDqnRlcy12b3VzIHPDu3IgP1wiLCBzZWN0aW9uX2Rlc2NyaXB0aW9uOiBcIkRlc2NyaXB0aW9uXCIsIHNlY3Rpb25fdGltZTogXCJQw6lyaW9kZVwiLCBzZWN0aW9uX3R5cGU6IFwiVHlwZVwiLCBzZWN0aW9uX2RlYWRsaW5lOiBcIkRlYWRsaW5lXCIsIHNlY3Rpb25fYmFzZWxpbmVzOiBcIkJhc2VsaW5lc1wiLCBjb2x1bW5fd2JzOiBcIk9UUFwiLCBjb2x1bW5fdGV4dDogXCJOb20gZGUgbGEgdMOiY2hlXCIsIGNvbHVtbl9zdGFydF9kYXRlOiBcIkRhdGUgaW5pdGlhbGVcIiwgY29sdW1uX2R1cmF0aW9uOiBcIkR1csOpZVwiLCBjb2x1bW5fYWRkOiBcIlwiLCBsaW5rOiBcIkxlIGxpZW5cIiwgY29uZmlybV9saW5rX2RlbGV0aW5nOiBcInNlcmEgc3VwcHJpbcOpXCIsIGxpbmtfc3RhcnQ6IFwiKGTDqWJ1dClcIiwgbGlua19lbmQ6IFwiKGZpbilcIiwgdHlwZV90YXNrOiBcIlRhc2tcIiwgdHlwZV9wcm9qZWN0OiBcIlByb2plY3RcIiwgdHlwZV9taWxlc3RvbmU6IFwiTWlsZXN0b25lXCIsIG1pbnV0ZXM6IFwiTWludXRlc1wiLCBob3VyczogXCJIZXVyZXNcIiwgZGF5czogXCJKb3Vyc1wiLCB3ZWVrczogXCJTZW1haW5lc1wiLCBtb250aHM6IFwiTW9pc1wiLCB5ZWFyczogXCJBbm7DqWVzXCIsIG1lc3NhZ2Vfb2s6IFwiT0tcIiwgbWVzc2FnZV9jYW5jZWw6IFwiQW5udWxlclwiLCBzZWN0aW9uX2NvbnN0cmFpbnQ6IFwiQ29uc3RyYWludFwiLCBjb25zdHJhaW50X3R5cGU6IFwiQ29uc3RyYWludCB0eXBlXCIsIGNvbnN0cmFpbnRfZGF0ZTogXCJDb25zdHJhaW50IGRhdGVcIiwgYXNhcDogXCJBcyBTb29uIEFzIFBvc3NpYmxlXCIsIGFsYXA6IFwiQXMgTGF0ZSBBcyBQb3NzaWJsZVwiLCBzbmV0OiBcIlN0YXJ0IE5vIEVhcmxpZXIgVGhhblwiLCBzbmx0OiBcIlN0YXJ0IE5vIExhdGVyIFRoYW5cIiwgZm5ldDogXCJGaW5pc2ggTm8gRWFybGllciBUaGFuXCIsIGZubHQ6IFwiRmluaXNoIE5vIExhdGVyIFRoYW5cIiwgbXNvOiBcIk11c3QgU3RhcnQgT25cIiwgbWZvOiBcIk11c3QgRmluaXNoIE9uXCIsIHJlc291cmNlc19maWx0ZXJfcGxhY2Vob2xkZXI6IFwidHlwZSB0byBmaWx0ZXJcIiwgcmVzb3VyY2VzX2ZpbHRlcl9sYWJlbDogXCJoaWRlIGVtcHR5XCIsIGVtcHR5X3N0YXRlX3RleHRfbGluazogXCJDbGljayBoZXJlXCIsIGVtcHR5X3N0YXRlX3RleHRfZGVzY3JpcHRpb246IFwidG8gY3JlYXRlIHlvdXIgZmlyc3QgdGFza1wiLCBiYXNlbGluZXNfc2VjdGlvbl9wbGFjZWhvbGRlcjogXCJTdGFydCBhZGRpbmcgYSBuZXcgYmFzZWxpbmVcIiwgYmFzZWxpbmVzX2FkZF9idXR0b246IFwiQWRkIEJhc2VsaW5lXCIsIGJhc2VsaW5lc19yZW1vdmVfYnV0dG9uOiBcIlJlbW92ZVwiLCBiYXNlbGluZXNfcmVtb3ZlX2FsbF9idXR0b246IFwiUmVtb3ZlIEFsbFwiLCBkZWFkbGluZV9lbmFibGVfYnV0dG9uOiBcIlNldFwiLCBkZWFkbGluZV9kaXNhYmxlX2J1dHRvbjogXCJSZW1vdmVcIiB9IH0sIE9pID0geyBkYXRlOiB7IG1vbnRoX2Z1bGw6IFtcIteZ16DXldeQ16hcIiwgXCLXpNeR16jXldeQ16hcIiwgXCLXnteo16VcIiwgXCLXkNek16jXmdecXCIsIFwi157XkNeZXCIsIFwi15nXldeg15lcIiwgXCLXmdeV15zXmVwiLCBcIteQ15XXkteV16HXmFwiLCBcIteh16TXmNee15HXqFwiLCBcIteQ15XXp9eY15XXkdeoXCIsIFwi16DXldeR157XkdeoXCIsIFwi15PXptee15HXqFwiXSwgbW9udGhfc2hvcnQ6IFtcIteZ16DXlVwiLCBcItek15HXqFwiLCBcItee16jXpVwiLCBcIteQ16TXqFwiLCBcItee15DXmVwiLCBcIteZ15XXoFwiLCBcIteZ15XXnFwiLCBcIteQ15XXklwiLCBcIteh16TXmFwiLCBcIteQ15XXp1wiLCBcIteg15XXkVwiLCBcIteT16bXnlwiXSwgZGF5X2Z1bGw6IFtcIteo15DXqdeV159cIiwgXCLXqdeg15lcIiwgXCLXqdec15nXqdeZXCIsIFwi16jXkdeZ16LXmVwiLCBcIteX157Xmdep15lcIiwgXCLXqdeZ16nXmVwiLCBcItep15HXqlwiXSwgZGF5X3Nob3J0OiBbXCLXkFwiLCBcIteRXCIsIFwi15JcIiwgXCLXk1wiLCBcIteUXCIsIFwi15VcIiwgXCLXqVwiXSB9LCBsYWJlbHM6IHsgbmV3X3Rhc2s6IFwi157XqdeZ157XlCDXl9eT16lcIiwgaWNvbl9zYXZlOiBcItep157XldeoXCIsIGljb25fY2FuY2VsOiBcIteR15jXnFwiLCBpY29uX2RldGFpbHM6IFwi16TXqNeY15nXnVwiLCBpY29uX2VkaXQ6IFwi16LXqNeV15pcIiwgaWNvbl9kZWxldGU6IFwi157Xl9enXCIsIGNvbmZpcm1fY2xvc2luZzogXCJcIiwgY29uZmlybV9kZWxldGluZzogXCLXkNeo15XXoiDXmdee15fXpyDXodeV16TXmdeqLtec15TXntep15nXmj9cIiwgc2VjdGlvbl9kZXNjcmlwdGlvbjogXCLXlNeh15HXqFwiLCBzZWN0aW9uX3RpbWU6IFwi16rXp9eV16TXlFwiLCBzZWN0aW9uX3R5cGU6IFwiVHlwZVwiLCBzZWN0aW9uX2RlYWRsaW5lOiBcIkRlYWRsaW5lXCIsIHNlY3Rpb25fYmFzZWxpbmVzOiBcIkJhc2VsaW5lc1wiLCBjb2x1bW5fd2JzOiBcIldCU1wiLCBjb2x1bW5fdGV4dDogXCJUYXNrIG5hbWVcIiwgY29sdW1uX3N0YXJ0X2RhdGU6IFwiU3RhcnQgdGltZVwiLCBjb2x1bW5fZHVyYXRpb246IFwiRHVyYXRpb25cIiwgY29sdW1uX2FkZDogXCJcIiwgbGluazogXCJMaW5rXCIsIGNvbmZpcm1fbGlua19kZWxldGluZzogXCJ3aWxsIGJlIGRlbGV0ZWRcIiwgbGlua19zdGFydDogXCIgKHN0YXJ0KVwiLCBsaW5rX2VuZDogXCIgKGVuZClcIiwgdHlwZV90YXNrOiBcIlRhc2tcIiwgdHlwZV9wcm9qZWN0OiBcIlByb2plY3RcIiwgdHlwZV9taWxlc3RvbmU6IFwiTWlsZXN0b25lXCIsIG1pbnV0ZXM6IFwiTWludXRlc1wiLCBob3VyczogXCJIb3Vyc1wiLCBkYXlzOiBcIkRheXNcIiwgd2Vla3M6IFwiV2Vla1wiLCBtb250aHM6IFwiTW9udGhzXCIsIHllYXJzOiBcIlllYXJzXCIsIG1lc3NhZ2Vfb2s6IFwiT0tcIiwgbWVzc2FnZV9jYW5jZWw6IFwi15HXmNecXCIsIHNlY3Rpb25fY29uc3RyYWludDogXCJDb25zdHJhaW50XCIsIGNvbnN0cmFpbnRfdHlwZTogXCJDb25zdHJhaW50IHR5cGVcIiwgY29uc3RyYWludF9kYXRlOiBcIkNvbnN0cmFpbnQgZGF0ZVwiLCBhc2FwOiBcIkFzIFNvb24gQXMgUG9zc2libGVcIiwgYWxhcDogXCJBcyBMYXRlIEFzIFBvc3NpYmxlXCIsIHNuZXQ6IFwiU3RhcnQgTm8gRWFybGllciBUaGFuXCIsIHNubHQ6IFwiU3RhcnQgTm8gTGF0ZXIgVGhhblwiLCBmbmV0OiBcIkZpbmlzaCBObyBFYXJsaWVyIFRoYW5cIiwgZm5sdDogXCJGaW5pc2ggTm8gTGF0ZXIgVGhhblwiLCBtc286IFwiTXVzdCBTdGFydCBPblwiLCBtZm86IFwiTXVzdCBGaW5pc2ggT25cIiwgcmVzb3VyY2VzX2ZpbHRlcl9wbGFjZWhvbGRlcjogXCJ0eXBlIHRvIGZpbHRlclwiLCByZXNvdXJjZXNfZmlsdGVyX2xhYmVsOiBcImhpZGUgZW1wdHlcIiwgZW1wdHlfc3RhdGVfdGV4dF9saW5rOiBcIkNsaWNrIGhlcmVcIiwgZW1wdHlfc3RhdGVfdGV4dF9kZXNjcmlwdGlvbjogXCJ0byBjcmVhdGUgeW91ciBmaXJzdCB0YXNrXCIsIGJhc2VsaW5lc19zZWN0aW9uX3BsYWNlaG9sZGVyOiBcIlN0YXJ0IGFkZGluZyBhIG5ldyBiYXNlbGluZVwiLCBiYXNlbGluZXNfYWRkX2J1dHRvbjogXCJBZGQgQmFzZWxpbmVcIiwgYmFzZWxpbmVzX3JlbW92ZV9idXR0b246IFwiUmVtb3ZlXCIsIGJhc2VsaW5lc19yZW1vdmVfYWxsX2J1dHRvbjogXCJSZW1vdmUgQWxsXCIsIGRlYWRsaW5lX2VuYWJsZV9idXR0b246IFwiU2V0XCIsIGRlYWRsaW5lX2Rpc2FibGVfYnV0dG9uOiBcIlJlbW92ZVwiIH0gfSwgQmkgPSB7IGRhdGU6IHsgbW9udGhfZnVsbDogW1wiU2lqZcSNYW5qXCIsIFwiVmVsamHEjWFcIiwgXCJPxb51amFrXCIsIFwiVHJhdmFualwiLCBcIlN2aWJhbmpcIiwgXCJMaXBhbmpcIiwgXCJTcnBhbmpcIiwgXCJLb2xvdm96XCIsIFwiUnVqYW5cIiwgXCJMaXN0b3BhZFwiLCBcIlN0dWRlbmlcIiwgXCJQcm9zaW5hY1wiXSwgbW9udGhfc2hvcnQ6IFtcIlNpalwiLCBcIlZlbGpcIiwgXCJPxb51XCIsIFwiVHJhXCIsIFwiU3ZpXCIsIFwiTGlwXCIsIFwiU3JwXCIsIFwiS29sXCIsIFwiUnVqXCIsIFwiTGlzXCIsIFwiU3R1XCIsIFwiUHJvXCJdLCBkYXlfZnVsbDogW1wiTmVkamVsamFcIiwgXCJQb25lZGplbGpha1wiLCBcIlV0b3Jha1wiLCBcIlNyaWplZGFcIiwgXCLEjGV0dnJ0YWtcIiwgXCJQZXRha1wiLCBcIlN1Ym90YVwiXSwgZGF5X3Nob3J0OiBbXCJOZWRcIiwgXCJQb25cIiwgXCJVdG9cIiwgXCJTcmlcIiwgXCLEjGV0XCIsIFwiUGV0XCIsIFwiU3ViXCJdIH0sIGxhYmVsczogeyBuZXdfdGFzazogXCJOb3ZpIFphZGF0YWtcIiwgaWNvbl9zYXZlOiBcIlNwcmVtaVwiLCBpY29uX2NhbmNlbDogXCJPZHVzdGFuaVwiLCBpY29uX2RldGFpbHM6IFwiRGV0YWxqaVwiLCBpY29uX2VkaXQ6IFwiSXptamVuaVwiLCBpY29uX2RlbGV0ZTogXCJPYnJpxaFpXCIsIGNvbmZpcm1fY2xvc2luZzogXCJcIiwgY29uZmlybV9kZWxldGluZzogXCJaYWRhdGFrIMSHZSBiaXRpIHRyYWpubyBpemJyaXNhbiwgamVzdGUgbGkgc2lndXJuaT9cIiwgc2VjdGlvbl9kZXNjcmlwdGlvbjogXCJPcGlzXCIsIHNlY3Rpb25fdGltZTogXCJWcmVtZW5za2kgUGVyaW9kXCIsIHNlY3Rpb25fdHlwZTogXCJUaXBcIiwgc2VjdGlvbl9kZWFkbGluZTogXCJEZWFkbGluZVwiLCBzZWN0aW9uX2Jhc2VsaW5lczogXCJCYXNlbGluZXNcIiwgY29sdW1uX3diczogXCJXQlNcIiwgY29sdW1uX3RleHQ6IFwiTmF6aXYgWmFkYXRrYVwiLCBjb2x1bW5fc3RhcnRfZGF0ZTogXCJQb8SNZXRubyBWcmlqZW1lXCIsIGNvbHVtbl9kdXJhdGlvbjogXCJUcmFqYW5qZVwiLCBjb2x1bW5fYWRkOiBcIlwiLCBsaW5rOiBcIlBvdmV6bmljYVwiLCBjb25maXJtX2xpbmtfZGVsZXRpbmc6IFwixIdlIGJpdGkgaXpicmlzYW5cIiwgbGlua19zdGFydDogXCIgKHBvxI1ldGFrKVwiLCBsaW5rX2VuZDogXCIgKGtyYWopXCIsIHR5cGVfdGFzazogXCJaYWRhdGFrXCIsIHR5cGVfcHJvamVjdDogXCJQcm9qZWt0XCIsIHR5cGVfbWlsZXN0b25lOiBcIk1pbGVzdG9uZVwiLCBtaW51dGVzOiBcIk1pbnV0ZVwiLCBob3VyczogXCJTYXRpXCIsIGRheXM6IFwiRGFuaVwiLCB3ZWVrczogXCJUamVkbmlcIiwgbW9udGhzOiBcIk1qZXNlY2lcIiwgeWVhcnM6IFwiR29kaW5lXCIsIG1lc3NhZ2Vfb2s6IFwiT0tcIiwgbWVzc2FnZV9jYW5jZWw6IFwiT2R1c3RhbmlcIiwgc2VjdGlvbl9jb25zdHJhaW50OiBcIkNvbnN0cmFpbnRcIiwgY29uc3RyYWludF90eXBlOiBcIkNvbnN0cmFpbnQgdHlwZVwiLCBjb25zdHJhaW50X2RhdGU6IFwiQ29uc3RyYWludCBkYXRlXCIsIGFzYXA6IFwiQXMgU29vbiBBcyBQb3NzaWJsZVwiLCBhbGFwOiBcIkFzIExhdGUgQXMgUG9zc2libGVcIiwgc25ldDogXCJTdGFydCBObyBFYXJsaWVyIFRoYW5cIiwgc25sdDogXCJTdGFydCBObyBMYXRlciBUaGFuXCIsIGZuZXQ6IFwiRmluaXNoIE5vIEVhcmxpZXIgVGhhblwiLCBmbmx0OiBcIkZpbmlzaCBObyBMYXRlciBUaGFuXCIsIG1zbzogXCJNdXN0IFN0YXJ0IE9uXCIsIG1mbzogXCJNdXN0IEZpbmlzaCBPblwiLCByZXNvdXJjZXNfZmlsdGVyX3BsYWNlaG9sZGVyOiBcInR5cGUgdG8gZmlsdGVyXCIsIHJlc291cmNlc19maWx0ZXJfbGFiZWw6IFwiaGlkZSBlbXB0eVwiLCBlbXB0eV9zdGF0ZV90ZXh0X2xpbms6IFwiQ2xpY2sgaGVyZVwiLCBlbXB0eV9zdGF0ZV90ZXh0X2Rlc2NyaXB0aW9uOiBcInRvIGNyZWF0ZSB5b3VyIGZpcnN0IHRhc2tcIiwgYmFzZWxpbmVzX3NlY3Rpb25fcGxhY2Vob2xkZXI6IFwiU3RhcnQgYWRkaW5nIGEgbmV3IGJhc2VsaW5lXCIsIGJhc2VsaW5lc19hZGRfYnV0dG9uOiBcIkFkZCBCYXNlbGluZVwiLCBiYXNlbGluZXNfcmVtb3ZlX2J1dHRvbjogXCJSZW1vdmVcIiwgYmFzZWxpbmVzX3JlbW92ZV9hbGxfYnV0dG9uOiBcIlJlbW92ZSBBbGxcIiwgZGVhZGxpbmVfZW5hYmxlX2J1dHRvbjogXCJTZXRcIiwgZGVhZGxpbmVfZGlzYWJsZV9idXR0b246IFwiUmVtb3ZlXCIgfSB9LCB6aSA9IHsgZGF0ZTogeyBtb250aF9mdWxsOiBbXCJKYW51w6FyXCIsIFwiRmVicnXDoXJcIiwgXCJNw6FyY2l1c1wiLCBcIsOBcHJpbGlzXCIsIFwiTcOhanVzXCIsIFwiSsO6bml1c1wiLCBcIkrDumxpdXNcIiwgXCJBdWd1c3p0dXNcIiwgXCJTemVwdGVtYmVyXCIsIFwiT2t0w7NiZXJcIiwgXCJOb3ZlbWJlclwiLCBcIkRlY2VtYmVyXCJdLCBtb250aF9zaG9ydDogW1wiSmFuXCIsIFwiRmViXCIsIFwiTcOhclwiLCBcIsOBcHJcIiwgXCJNw6FqXCIsIFwiSsO6blwiLCBcIkrDumxcIiwgXCJBdWdcIiwgXCJTZXBcIiwgXCJPa3RcIiwgXCJOb3ZcIiwgXCJEZWNcIl0sIGRheV9mdWxsOiBbXCJWYXPDoXJuYXBcIiwgXCJIw6l0ZsO1XCIsIFwiS2VkZFwiLCBcIlN6ZXJkYVwiLCBcIkNzw7x0w7ZydMO2a1wiLCBcIlDDqW50ZWtcIiwgXCJzem9tYmF0XCJdLCBkYXlfc2hvcnQ6IFtcIlZhXCIsIFwiSMOpXCIsIFwiS2VcIiwgXCJTemVcIiwgXCJDc8O8XCIsIFwiUMOpXCIsIFwiU3pvXCJdIH0sIGxhYmVsczogeyBuZXdfdGFzazogXCLDmmogZmVsYWRhdFwiLCBpY29uX3NhdmU6IFwiTWVudMOpc1wiLCBpY29uX2NhbmNlbDogXCJNw6lnc2VcIiwgaWNvbl9kZXRhaWxzOiBcIlLDqXN6bGV0ZWtcIiwgaWNvbl9lZGl0OiBcIlN6ZXJrZXN6dMOpc1wiLCBpY29uX2RlbGV0ZTogXCJUw7ZybMOpc1wiLCBjb25maXJtX2Nsb3Npbmc6IFwiXCIsIGNvbmZpcm1fZGVsZXRpbmc6IFwiQXogZXNlbcOpbnkgdMO2csO2bHZlIGxlc3osIGJpenRvc2FuIGZvbHl0YXRqYT9cIiwgc2VjdGlvbl9kZXNjcmlwdGlvbjogXCJMZcOtcsOhc1wiLCBzZWN0aW9uX3RpbWU6IFwiSWTDtXN6YWtcIiwgc2VjdGlvbl90eXBlOiBcIlR5cGVcIiwgc2VjdGlvbl9kZWFkbGluZTogXCJEZWFkbGluZVwiLCBzZWN0aW9uX2Jhc2VsaW5lczogXCJCYXNlbGluZXNcIiwgY29sdW1uX3diczogXCJXQlNcIiwgY29sdW1uX3RleHQ6IFwiVGFzayBuYW1lXCIsIGNvbHVtbl9zdGFydF9kYXRlOiBcIlN0YXJ0IHRpbWVcIiwgY29sdW1uX2R1cmF0aW9uOiBcIkR1cmF0aW9uXCIsIGNvbHVtbl9hZGQ6IFwiXCIsIGxpbms6IFwiTGlua1wiLCBjb25maXJtX2xpbmtfZGVsZXRpbmc6IFwid2lsbCBiZSBkZWxldGVkXCIsIGxpbmtfc3RhcnQ6IFwiIChzdGFydClcIiwgbGlua19lbmQ6IFwiIChlbmQpXCIsIHR5cGVfdGFzazogXCJUYXNrXCIsIHR5cGVfcHJvamVjdDogXCJQcm9qZWN0XCIsIHR5cGVfbWlsZXN0b25lOiBcIk1pbGVzdG9uZVwiLCBtaW51dGVzOiBcIk1pbnV0ZXNcIiwgaG91cnM6IFwiSG91cnNcIiwgZGF5czogXCJEYXlzXCIsIHdlZWtzOiBcIldlZWtcIiwgbW9udGhzOiBcIk1vbnRoc1wiLCB5ZWFyczogXCJZZWFyc1wiLCBtZXNzYWdlX29rOiBcIk9LXCIsIG1lc3NhZ2VfY2FuY2VsOiBcIk3DqWdzZVwiLCBzZWN0aW9uX2NvbnN0cmFpbnQ6IFwiQ29uc3RyYWludFwiLCBjb25zdHJhaW50X3R5cGU6IFwiQ29uc3RyYWludCB0eXBlXCIsIGNvbnN0cmFpbnRfZGF0ZTogXCJDb25zdHJhaW50IGRhdGVcIiwgYXNhcDogXCJBcyBTb29uIEFzIFBvc3NpYmxlXCIsIGFsYXA6IFwiQXMgTGF0ZSBBcyBQb3NzaWJsZVwiLCBzbmV0OiBcIlN0YXJ0IE5vIEVhcmxpZXIgVGhhblwiLCBzbmx0OiBcIlN0YXJ0IE5vIExhdGVyIFRoYW5cIiwgZm5ldDogXCJGaW5pc2ggTm8gRWFybGllciBUaGFuXCIsIGZubHQ6IFwiRmluaXNoIE5vIExhdGVyIFRoYW5cIiwgbXNvOiBcIk11c3QgU3RhcnQgT25cIiwgbWZvOiBcIk11c3QgRmluaXNoIE9uXCIsIHJlc291cmNlc19maWx0ZXJfcGxhY2Vob2xkZXI6IFwidHlwZSB0byBmaWx0ZXJcIiwgcmVzb3VyY2VzX2ZpbHRlcl9sYWJlbDogXCJoaWRlIGVtcHR5XCIsIGVtcHR5X3N0YXRlX3RleHRfbGluazogXCJDbGljayBoZXJlXCIsIGVtcHR5X3N0YXRlX3RleHRfZGVzY3JpcHRpb246IFwidG8gY3JlYXRlIHlvdXIgZmlyc3QgdGFza1wiLCBiYXNlbGluZXNfc2VjdGlvbl9wbGFjZWhvbGRlcjogXCJTdGFydCBhZGRpbmcgYSBuZXcgYmFzZWxpbmVcIiwgYmFzZWxpbmVzX2FkZF9idXR0b246IFwiQWRkIEJhc2VsaW5lXCIsIGJhc2VsaW5lc19yZW1vdmVfYnV0dG9uOiBcIlJlbW92ZVwiLCBiYXNlbGluZXNfcmVtb3ZlX2FsbF9idXR0b246IFwiUmVtb3ZlIEFsbFwiLCBkZWFkbGluZV9lbmFibGVfYnV0dG9uOiBcIlNldFwiLCBkZWFkbGluZV9kaXNhYmxlX2J1dHRvbjogXCJSZW1vdmVcIiB9IH0sIFdpID0geyBkYXRlOiB7IG1vbnRoX2Z1bGw6IFtcIkphbnVhcmlcIiwgXCJGZWJydWFyaVwiLCBcIk1hcmV0XCIsIFwiQXByaWxcIiwgXCJNZWlcIiwgXCJKdW5pXCIsIFwiSnVsaVwiLCBcIkFndXN0dXNcIiwgXCJTZXB0ZW1iZXJcIiwgXCJPa3RvYmVyXCIsIFwiTm92ZW1iZXJcIiwgXCJEZXNlbWJlclwiXSwgbW9udGhfc2hvcnQ6IFtcIkphblwiLCBcIkZlYlwiLCBcIk1hclwiLCBcIkFwclwiLCBcIk1laVwiLCBcIkp1blwiLCBcIkp1bFwiLCBcIkFnc1wiLCBcIlNlcFwiLCBcIk9rdFwiLCBcIk5vdlwiLCBcIkRlc1wiXSwgZGF5X2Z1bGw6IFtcIk1pbmdndVwiLCBcIlNlbmluXCIsIFwiU2VsYXNhXCIsIFwiUmFidVwiLCBcIkthbWlzXCIsIFwiSnVtYXRcIiwgXCJTYWJ0dVwiXSwgZGF5X3Nob3J0OiBbXCJNaW5nXCIsIFwiU2VuXCIsIFwiU2VsXCIsIFwiUmFiXCIsIFwiS2FtXCIsIFwiSnVtXCIsIFwiU2FiXCJdIH0sIGxhYmVsczogeyBuZXdfdGFzazogXCJUdWdhcyBiYXJ1XCIsIGljb25fc2F2ZTogXCJTaW1wYW5cIiwgaWNvbl9jYW5jZWw6IFwiQmF0YWxcIiwgaWNvbl9kZXRhaWxzOiBcIkRldGFpbFwiLCBpY29uX2VkaXQ6IFwiRWRpdFwiLCBpY29uX2RlbGV0ZTogXCJIYXB1c1wiLCBjb25maXJtX2Nsb3Npbmc6IFwiXCIsIGNvbmZpcm1fZGVsZXRpbmc6IFwiQWNhcmEgYWthbiBkaWhhcHVzXCIsIHNlY3Rpb25fZGVzY3JpcHRpb246IFwiS2V0ZXJhbmdhblwiLCBzZWN0aW9uX3RpbWU6IFwiUGVyaW9kZVwiLCBzZWN0aW9uX3R5cGU6IFwiVHlwZVwiLCBzZWN0aW9uX2RlYWRsaW5lOiBcIkRlYWRsaW5lXCIsIHNlY3Rpb25fYmFzZWxpbmVzOiBcIkJhc2VsaW5lc1wiLCBjb2x1bW5fd2JzOiBcIldCU1wiLCBjb2x1bW5fdGV4dDogXCJUYXNrIG5hbWVcIiwgY29sdW1uX3N0YXJ0X2RhdGU6IFwiU3RhcnQgdGltZVwiLCBjb2x1bW5fZHVyYXRpb246IFwiRHVyYXRpb25cIiwgY29sdW1uX2FkZDogXCJcIiwgbGluazogXCJMaW5rXCIsIGNvbmZpcm1fbGlua19kZWxldGluZzogXCJ3aWxsIGJlIGRlbGV0ZWRcIiwgbGlua19zdGFydDogXCIgKHN0YXJ0KVwiLCBsaW5rX2VuZDogXCIgKGVuZClcIiwgdHlwZV90YXNrOiBcIlRhc2tcIiwgdHlwZV9wcm9qZWN0OiBcIlByb2plY3RcIiwgdHlwZV9taWxlc3RvbmU6IFwiTWlsZXN0b25lXCIsIG1pbnV0ZXM6IFwiTWludXRlc1wiLCBob3VyczogXCJIb3Vyc1wiLCBkYXlzOiBcIkRheXNcIiwgd2Vla3M6IFwiV2Vla1wiLCBtb250aHM6IFwiTW9udGhzXCIsIHllYXJzOiBcIlllYXJzXCIsIG1lc3NhZ2Vfb2s6IFwiT0tcIiwgbWVzc2FnZV9jYW5jZWw6IFwiQmF0YWxcIiwgc2VjdGlvbl9jb25zdHJhaW50OiBcIkNvbnN0cmFpbnRcIiwgY29uc3RyYWludF90eXBlOiBcIkNvbnN0cmFpbnQgdHlwZVwiLCBjb25zdHJhaW50X2RhdGU6IFwiQ29uc3RyYWludCBkYXRlXCIsIGFzYXA6IFwiQXMgU29vbiBBcyBQb3NzaWJsZVwiLCBhbGFwOiBcIkFzIExhdGUgQXMgUG9zc2libGVcIiwgc25ldDogXCJTdGFydCBObyBFYXJsaWVyIFRoYW5cIiwgc25sdDogXCJTdGFydCBObyBMYXRlciBUaGFuXCIsIGZuZXQ6IFwiRmluaXNoIE5vIEVhcmxpZXIgVGhhblwiLCBmbmx0OiBcIkZpbmlzaCBObyBMYXRlciBUaGFuXCIsIG1zbzogXCJNdXN0IFN0YXJ0IE9uXCIsIG1mbzogXCJNdXN0IEZpbmlzaCBPblwiLCByZXNvdXJjZXNfZmlsdGVyX3BsYWNlaG9sZGVyOiBcInR5cGUgdG8gZmlsdGVyXCIsIHJlc291cmNlc19maWx0ZXJfbGFiZWw6IFwiaGlkZSBlbXB0eVwiLCBlbXB0eV9zdGF0ZV90ZXh0X2xpbms6IFwiQ2xpY2sgaGVyZVwiLCBlbXB0eV9zdGF0ZV90ZXh0X2Rlc2NyaXB0aW9uOiBcInRvIGNyZWF0ZSB5b3VyIGZpcnN0IHRhc2tcIiwgYmFzZWxpbmVzX3NlY3Rpb25fcGxhY2Vob2xkZXI6IFwiU3RhcnQgYWRkaW5nIGEgbmV3IGJhc2VsaW5lXCIsIGJhc2VsaW5lc19hZGRfYnV0dG9uOiBcIkFkZCBCYXNlbGluZVwiLCBiYXNlbGluZXNfcmVtb3ZlX2J1dHRvbjogXCJSZW1vdmVcIiwgYmFzZWxpbmVzX3JlbW92ZV9hbGxfYnV0dG9uOiBcIlJlbW92ZSBBbGxcIiwgZGVhZGxpbmVfZW5hYmxlX2J1dHRvbjogXCJTZXRcIiwgZGVhZGxpbmVfZGlzYWJsZV9idXR0b246IFwiUmVtb3ZlXCIgfSB9LCBqaSA9IHsgZGF0ZTogeyBtb250aF9mdWxsOiBbXCJHZW5uYWlvXCIsIFwiRmViYnJhaW9cIiwgXCJNYXJ6b1wiLCBcIkFwcmlsZVwiLCBcIk1hZ2dpb1wiLCBcIkdpdWdub1wiLCBcIkx1Z2xpb1wiLCBcIkFnb3N0b1wiLCBcIlNldHRlbWJyZVwiLCBcIk90dG9icmVcIiwgXCJOb3ZlbWJyZVwiLCBcIkRpY2VtYnJlXCJdLCBtb250aF9zaG9ydDogW1wiR2VuXCIsIFwiRmViXCIsIFwiTWFyXCIsIFwiQXByXCIsIFwiTWFnXCIsIFwiR2l1XCIsIFwiTHVnXCIsIFwiQWdvXCIsIFwiU2V0XCIsIFwiT3R0XCIsIFwiTm92XCIsIFwiRGljXCJdLCBkYXlfZnVsbDogW1wiRG9tZW5pY2FcIiwgXCJMdW5lZMOsXCIsIFwiTWFydGVkw6xcIiwgXCJNZXJjb2xlZMOsXCIsIFwiR2lvdmVkw6xcIiwgXCJWZW5lcmTDrFwiLCBcIlNhYmF0b1wiXSwgZGF5X3Nob3J0OiBbXCJEb21cIiwgXCJMdW5cIiwgXCJNYXJcIiwgXCJNZXJcIiwgXCJHaW9cIiwgXCJWZW5cIiwgXCJTYWJcIl0gfSwgbGFiZWxzOiB7IG5ld190YXNrOiBcIk51b3ZvIGNvbXBpdG9cIiwgaWNvbl9zYXZlOiBcIlNhbHZhXCIsIGljb25fY2FuY2VsOiBcIkNoaXVkaVwiLCBpY29uX2RldGFpbHM6IFwiRGV0dGFnbGlcIiwgaWNvbl9lZGl0OiBcIk1vZGlmaWNhXCIsIGljb25fZGVsZXRlOiBcIkVsaW1pbmFcIiwgY29uZmlybV9jbG9zaW5nOiBcIlwiLCBjb25maXJtX2RlbGV0aW5nOiBcIlNlaSBzaWN1cm8gZGkgY29uZmVybWFyZSBsJ2VsaW1pbmF6aW9uZT9cIiwgc2VjdGlvbl9kZXNjcmlwdGlvbjogXCJEZXNjcml6aW9uZVwiLCBzZWN0aW9uX3RpbWU6IFwiUGVyaW9kbyBkaSB0ZW1wb1wiLCBzZWN0aW9uX3R5cGU6IFwiVGlwb1wiLCBzZWN0aW9uX2RlYWRsaW5lOiBcIkRlYWRsaW5lXCIsIHNlY3Rpb25fYmFzZWxpbmVzOiBcIkJhc2VsaW5lc1wiLCBjb2x1bW5fd2JzOiBcIldCU1wiLCBjb2x1bW5fdGV4dDogXCJOb21lIEF0dGl2aXTDoFwiLCBjb2x1bW5fc3RhcnRfZGF0ZTogXCJJbml6aW9cIiwgY29sdW1uX2R1cmF0aW9uOiBcIkR1cmF0YVwiLCBjb2x1bW5fYWRkOiBcIlwiLCBsaW5rOiBcIkxpbmtcIiwgY29uZmlybV9saW5rX2RlbGV0aW5nOiBcInNhcsOgIGVsaW1pbmF0b1wiLCBsaW5rX3N0YXJ0OiBcIiAoaW5pemlvKVwiLCBsaW5rX2VuZDogXCIgKGZpbmUpXCIsIHR5cGVfdGFzazogXCJUYXNrXCIsIHR5cGVfcHJvamVjdDogXCJQcm9qZWN0XCIsIHR5cGVfbWlsZXN0b25lOiBcIk1pbGVzdG9uZVwiLCBtaW51dGVzOiBcIk1pbnV0aVwiLCBob3VyczogXCJPcmVcIiwgZGF5czogXCJHaW9ybmlcIiwgd2Vla3M6IFwiU2V0dGltYW5lXCIsIG1vbnRoczogXCJNZXNpXCIsIHllYXJzOiBcIkFubmlcIiwgbWVzc2FnZV9vazogXCJPS1wiLCBtZXNzYWdlX2NhbmNlbDogXCJDaGl1ZGlcIiwgc2VjdGlvbl9jb25zdHJhaW50OiBcIkNvbnN0cmFpbnRcIiwgY29uc3RyYWludF90eXBlOiBcIkNvbnN0cmFpbnQgdHlwZVwiLCBjb25zdHJhaW50X2RhdGU6IFwiQ29uc3RyYWludCBkYXRlXCIsIGFzYXA6IFwiQXMgU29vbiBBcyBQb3NzaWJsZVwiLCBhbGFwOiBcIkFzIExhdGUgQXMgUG9zc2libGVcIiwgc25ldDogXCJTdGFydCBObyBFYXJsaWVyIFRoYW5cIiwgc25sdDogXCJTdGFydCBObyBMYXRlciBUaGFuXCIsIGZuZXQ6IFwiRmluaXNoIE5vIEVhcmxpZXIgVGhhblwiLCBmbmx0OiBcIkZpbmlzaCBObyBMYXRlciBUaGFuXCIsIG1zbzogXCJNdXN0IFN0YXJ0IE9uXCIsIG1mbzogXCJNdXN0IEZpbmlzaCBPblwiLCByZXNvdXJjZXNfZmlsdGVyX3BsYWNlaG9sZGVyOiBcInR5cGUgdG8gZmlsdGVyXCIsIHJlc291cmNlc19maWx0ZXJfbGFiZWw6IFwiaGlkZSBlbXB0eVwiLCBlbXB0eV9zdGF0ZV90ZXh0X2xpbms6IFwiQ2xpY2sgaGVyZVwiLCBlbXB0eV9zdGF0ZV90ZXh0X2Rlc2NyaXB0aW9uOiBcInRvIGNyZWF0ZSB5b3VyIGZpcnN0IHRhc2tcIiwgYmFzZWxpbmVzX3NlY3Rpb25fcGxhY2Vob2xkZXI6IFwiU3RhcnQgYWRkaW5nIGEgbmV3IGJhc2VsaW5lXCIsIGJhc2VsaW5lc19hZGRfYnV0dG9uOiBcIkFkZCBCYXNlbGluZVwiLCBiYXNlbGluZXNfcmVtb3ZlX2J1dHRvbjogXCJSZW1vdmVcIiwgYmFzZWxpbmVzX3JlbW92ZV9hbGxfYnV0dG9uOiBcIlJlbW92ZSBBbGxcIiwgZGVhZGxpbmVfZW5hYmxlX2J1dHRvbjogXCJTZXRcIiwgZGVhZGxpbmVfZGlzYWJsZV9idXR0b246IFwiUmVtb3ZlXCIgfSB9LCBGaSA9IHsgZGF0ZTogeyBtb250aF9mdWxsOiBbXCIx5pyIXCIsIFwiMuaciFwiLCBcIjPmnIhcIiwgXCI05pyIXCIsIFwiNeaciFwiLCBcIjbmnIhcIiwgXCI35pyIXCIsIFwiOOaciFwiLCBcIjnmnIhcIiwgXCIxMOaciFwiLCBcIjEx5pyIXCIsIFwiMTLmnIhcIl0sIG1vbnRoX3Nob3J0OiBbXCIx5pyIXCIsIFwiMuaciFwiLCBcIjPmnIhcIiwgXCI05pyIXCIsIFwiNeaciFwiLCBcIjbmnIhcIiwgXCI35pyIXCIsIFwiOOaciFwiLCBcIjnmnIhcIiwgXCIxMOaciFwiLCBcIjEx5pyIXCIsIFwiMTLmnIhcIl0sIGRheV9mdWxsOiBbXCLml6Xmm5zml6VcIiwgXCLmnIjmm5zml6VcIiwgXCLngavmm5zml6VcIiwgXCLmsLTmm5zml6VcIiwgXCLmnKjmm5zml6VcIiwgXCLph5Hmm5zml6VcIiwgXCLlnJ/mm5zml6VcIl0sIGRheV9zaG9ydDogW1wi5pelXCIsIFwi5pyIXCIsIFwi54GrXCIsIFwi5rC0XCIsIFwi5pyoXCIsIFwi6YeRXCIsIFwi5ZyfXCJdIH0sIGxhYmVsczogeyBuZXdfdGFzazogXCLmlrDjgZfjgYTku5XkuotcIiwgaWNvbl9zYXZlOiBcIuS/neWtmFwiLCBpY29uX2NhbmNlbDogXCLjgq3jg6Pjg7Pjgrvjg6tcIiwgaWNvbl9kZXRhaWxzOiBcIuips+e0sFwiLCBpY29uX2VkaXQ6IFwi57eo6ZuGXCIsIGljb25fZGVsZXRlOiBcIuWJiumZpFwiLCBjb25maXJtX2Nsb3Npbmc6IFwiXCIsIGNvbmZpcm1fZGVsZXRpbmc6IFwi44Kk44OZ44Oz44OI5a6M5YWo44Gr5YmK6Zmk44GV44KM44G+44GZ44CB5a6c44GX44GE44Gn44GZ44GL77yfXCIsIHNlY3Rpb25fZGVzY3JpcHRpb246IFwi44OH44K544Kv44Oq44OX44K344On44OzXCIsIHNlY3Rpb25fdGltZTogXCLmnJ/plpNcIiwgc2VjdGlvbl90eXBlOiBcIlR5cGVcIiwgc2VjdGlvbl9kZWFkbGluZTogXCJEZWFkbGluZVwiLCBzZWN0aW9uX2Jhc2VsaW5lczogXCJCYXNlbGluZXNcIiwgY29sdW1uX3diczogXCJXQlNcIiwgY29sdW1uX3RleHQ6IFwiVGFzayBuYW1lXCIsIGNvbHVtbl9zdGFydF9kYXRlOiBcIlN0YXJ0IHRpbWVcIiwgY29sdW1uX2R1cmF0aW9uOiBcIkR1cmF0aW9uXCIsIGNvbHVtbl9hZGQ6IFwiXCIsIGxpbms6IFwiTGlua1wiLCBjb25maXJtX2xpbmtfZGVsZXRpbmc6IFwid2lsbCBiZSBkZWxldGVkXCIsIGxpbmtfc3RhcnQ6IFwiIChzdGFydClcIiwgbGlua19lbmQ6IFwiIChlbmQpXCIsIHR5cGVfdGFzazogXCJUYXNrXCIsIHR5cGVfcHJvamVjdDogXCJQcm9qZWN0XCIsIHR5cGVfbWlsZXN0b25lOiBcIk1pbGVzdG9uZVwiLCBtaW51dGVzOiBcIk1pbnV0ZXNcIiwgaG91cnM6IFwiSG91cnNcIiwgZGF5czogXCJEYXlzXCIsIHdlZWtzOiBcIldlZWtcIiwgbW9udGhzOiBcIk1vbnRoc1wiLCB5ZWFyczogXCJZZWFyc1wiLCBtZXNzYWdlX29rOiBcIk9LXCIsIG1lc3NhZ2VfY2FuY2VsOiBcIuOCreODo+ODs+OCu+ODq1wiLCBzZWN0aW9uX2NvbnN0cmFpbnQ6IFwiQ29uc3RyYWludFwiLCBjb25zdHJhaW50X3R5cGU6IFwiQ29uc3RyYWludCB0eXBlXCIsIGNvbnN0cmFpbnRfZGF0ZTogXCJDb25zdHJhaW50IGRhdGVcIiwgYXNhcDogXCJBcyBTb29uIEFzIFBvc3NpYmxlXCIsIGFsYXA6IFwiQXMgTGF0ZSBBcyBQb3NzaWJsZVwiLCBzbmV0OiBcIlN0YXJ0IE5vIEVhcmxpZXIgVGhhblwiLCBzbmx0OiBcIlN0YXJ0IE5vIExhdGVyIFRoYW5cIiwgZm5ldDogXCJGaW5pc2ggTm8gRWFybGllciBUaGFuXCIsIGZubHQ6IFwiRmluaXNoIE5vIExhdGVyIFRoYW5cIiwgbXNvOiBcIk11c3QgU3RhcnQgT25cIiwgbWZvOiBcIk11c3QgRmluaXNoIE9uXCIsIHJlc291cmNlc19maWx0ZXJfcGxhY2Vob2xkZXI6IFwidHlwZSB0byBmaWx0ZXJcIiwgcmVzb3VyY2VzX2ZpbHRlcl9sYWJlbDogXCJoaWRlIGVtcHR5XCIsIGVtcHR5X3N0YXRlX3RleHRfbGluazogXCJDbGljayBoZXJlXCIsIGVtcHR5X3N0YXRlX3RleHRfZGVzY3JpcHRpb246IFwidG8gY3JlYXRlIHlvdXIgZmlyc3QgdGFza1wiLCBiYXNlbGluZXNfc2VjdGlvbl9wbGFjZWhvbGRlcjogXCJTdGFydCBhZGRpbmcgYSBuZXcgYmFzZWxpbmVcIiwgYmFzZWxpbmVzX2FkZF9idXR0b246IFwiQWRkIEJhc2VsaW5lXCIsIGJhc2VsaW5lc19yZW1vdmVfYnV0dG9uOiBcIlJlbW92ZVwiLCBiYXNlbGluZXNfcmVtb3ZlX2FsbF9idXR0b246IFwiUmVtb3ZlIEFsbFwiLCBkZWFkbGluZV9lbmFibGVfYnV0dG9uOiBcIlNldFwiLCBkZWFkbGluZV9kaXNhYmxlX2J1dHRvbjogXCJSZW1vdmVcIiB9IH0sIFZpID0geyBkYXRlOiB7IG1vbnRoX2Z1bGw6IFtcIjHsm5RcIiwgXCIy7JuUXCIsIFwiM+yblFwiLCBcIjTsm5RcIiwgXCI17JuUXCIsIFwiNuyblFwiLCBcIjfsm5RcIiwgXCI47JuUXCIsIFwiOeyblFwiLCBcIjEw7JuUXCIsIFwiMTHsm5RcIiwgXCIxMuyblFwiXSwgbW9udGhfc2hvcnQ6IFtcIjHsm5RcIiwgXCIy7JuUXCIsIFwiM+yblFwiLCBcIjTsm5RcIiwgXCI17JuUXCIsIFwiNuyblFwiLCBcIjfsm5RcIiwgXCI47JuUXCIsIFwiOeyblFwiLCBcIjEw7JuUXCIsIFwiMTHsm5RcIiwgXCIxMuyblFwiXSwgZGF5X2Z1bGw6IFtcIuydvOyalOydvFwiLCBcIuyblOyalOydvFwiLCBcIu2ZlOyalOydvFwiLCBcIuyImOyalOydvFwiLCBcIuuqqeyalOydvFwiLCBcIuq4iOyalOydvFwiLCBcIu2GoOyalOydvFwiXSwgZGF5X3Nob3J0OiBbXCLsnbxcIiwgXCLsm5RcIiwgXCLtmZRcIiwgXCLsiJhcIiwgXCLrqqlcIiwgXCLquIhcIiwgXCLthqBcIl0gfSwgbGFiZWxzOiB7IG5ld190YXNrOiBcIuydtOumhOyXhuuKlCDsnpHsl4VcIiwgaWNvbl9zYXZlOiBcIuyggOyepVwiLCBpY29uX2NhbmNlbDogXCLst6jshoxcIiwgaWNvbl9kZXRhaWxzOiBcIuyEuOu2gCDsgqztla1cIiwgaWNvbl9lZGl0OiBcIuyImOyglVwiLCBpY29uX2RlbGV0ZTogXCLsgq3soJxcIiwgY29uZmlybV9jbG9zaW5nOiBcIlwiLCBjb25maXJtX2RlbGV0aW5nOiBcIuyekeyXheydhCDsgq3soJztlZjsi5zqsqDsirXri4jquYw/XCIsIHNlY3Rpb25fZGVzY3JpcHRpb246IFwi7ISk66qFXCIsIHNlY3Rpb25fdGltZTogXCLquLDqsIRcIiwgc2VjdGlvbl90eXBlOiBcIlR5cGVcIiwgc2VjdGlvbl9kZWFkbGluZTogXCJEZWFkbGluZVwiLCBzZWN0aW9uX2Jhc2VsaW5lczogXCJCYXNlbGluZXNcIiwgY29sdW1uX3diczogXCJXQlNcIiwgY29sdW1uX3RleHQ6IFwi7J6R7JeF66qFXCIsIGNvbHVtbl9zdGFydF9kYXRlOiBcIuyLnOyekeydvFwiLCBjb2x1bW5fZHVyYXRpb246IFwi6riw6rCEXCIsIGNvbHVtbl9hZGQ6IFwiXCIsIGxpbms6IFwi7KCE7KCcXCIsIGNvbmZpcm1fbGlua19kZWxldGluZzogXCLsgq3soJwg7ZWY7Iuc6rKg7Iq164uI6rmMP1wiLCBsaW5rX3N0YXJ0OiBcIiAoc3RhcnQpXCIsIGxpbmtfZW5kOiBcIiAoZW5kKVwiLCB0eXBlX3Rhc2s6IFwi7J6R7JeFXCIsIHR5cGVfcHJvamVjdDogXCLtlITroZzsoJ3tirhcIiwgdHlwZV9taWxlc3RvbmU6IFwi66eI7J287Iqk7YakXCIsIG1pbnV0ZXM6IFwi67aEXCIsIGhvdXJzOiBcIuyLnOqwhFwiLCBkYXlzOiBcIuydvFwiLCB3ZWVrczogXCLso7xcIiwgbW9udGhzOiBcIuuLrFwiLCB5ZWFyczogXCLrhYRcIiwgbWVzc2FnZV9vazogXCJPS1wiLCBtZXNzYWdlX2NhbmNlbDogXCLst6jshoxcIiwgc2VjdGlvbl9jb25zdHJhaW50OiBcIkNvbnN0cmFpbnRcIiwgY29uc3RyYWludF90eXBlOiBcIkNvbnN0cmFpbnQgdHlwZVwiLCBjb25zdHJhaW50X2RhdGU6IFwiQ29uc3RyYWludCBkYXRlXCIsIGFzYXA6IFwiQXMgU29vbiBBcyBQb3NzaWJsZVwiLCBhbGFwOiBcIkFzIExhdGUgQXMgUG9zc2libGVcIiwgc25ldDogXCJTdGFydCBObyBFYXJsaWVyIFRoYW5cIiwgc25sdDogXCJTdGFydCBObyBMYXRlciBUaGFuXCIsIGZuZXQ6IFwiRmluaXNoIE5vIEVhcmxpZXIgVGhhblwiLCBmbmx0OiBcIkZpbmlzaCBObyBMYXRlciBUaGFuXCIsIG1zbzogXCJNdXN0IFN0YXJ0IE9uXCIsIG1mbzogXCJNdXN0IEZpbmlzaCBPblwiLCByZXNvdXJjZXNfZmlsdGVyX3BsYWNlaG9sZGVyOiBcInR5cGUgdG8gZmlsdGVyXCIsIHJlc291cmNlc19maWx0ZXJfbGFiZWw6IFwiaGlkZSBlbXB0eVwiLCBlbXB0eV9zdGF0ZV90ZXh0X2xpbms6IFwiQ2xpY2sgaGVyZVwiLCBlbXB0eV9zdGF0ZV90ZXh0X2Rlc2NyaXB0aW9uOiBcInRvIGNyZWF0ZSB5b3VyIGZpcnN0IHRhc2tcIiwgYmFzZWxpbmVzX3NlY3Rpb25fcGxhY2Vob2xkZXI6IFwiU3RhcnQgYWRkaW5nIGEgbmV3IGJhc2VsaW5lXCIsIGJhc2VsaW5lc19hZGRfYnV0dG9uOiBcIkFkZCBCYXNlbGluZVwiLCBiYXNlbGluZXNfcmVtb3ZlX2J1dHRvbjogXCJSZW1vdmVcIiwgYmFzZWxpbmVzX3JlbW92ZV9hbGxfYnV0dG9uOiBcIlJlbW92ZSBBbGxcIiwgZGVhZGxpbmVfZW5hYmxlX2J1dHRvbjogXCJTZXRcIiwgZGVhZGxpbmVfZGlzYWJsZV9idXR0b246IFwiUmVtb3ZlXCIgfSB9O1xuY2xhc3MgVWkge1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgdGhpcy5hZGRMb2NhbGUgPSAobiwgaSkgPT4ge1xuICAgICAgdGhpcy5fbG9jYWxlc1tuXSA9IGk7XG4gICAgfSwgdGhpcy5nZXRMb2NhbGUgPSAobikgPT4gdGhpcy5fbG9jYWxlc1tuXSwgdGhpcy5fbG9jYWxlcyA9IHt9O1xuICAgIGZvciAoY29uc3QgbiBpbiBlKSB0aGlzLl9sb2NhbGVzW25dID0gZVtuXTtcbiAgfVxufVxuY29uc3QgcWkgPSB7IGRhdGU6IHsgbW9udGhfZnVsbDogW1wiSmFudWFyXCIsIFwiRmVicnVhclwiLCBcIk1hcnNcIiwgXCJBcHJpbFwiLCBcIk1haVwiLCBcIkp1bmlcIiwgXCJKdWxpXCIsIFwiQXVndXN0XCIsIFwiU2VwdGVtYmVyXCIsIFwiT2t0b2JlclwiLCBcIk5vdmVtYmVyXCIsIFwiRGVzZW1iZXJcIl0sIG1vbnRoX3Nob3J0OiBbXCJKYW5cIiwgXCJGZWJcIiwgXCJNYXJcIiwgXCJBcHJcIiwgXCJNYWlcIiwgXCJKdW5cIiwgXCJKdWxcIiwgXCJBdWdcIiwgXCJTZXBcIiwgXCJPa3RcIiwgXCJOb3ZcIiwgXCJEZXNcIl0sIGRheV9mdWxsOiBbXCJTw7huZGFnXCIsIFwiTWFuZGFnXCIsIFwiVGlyc2RhZ1wiLCBcIk9uc2RhZ1wiLCBcIlRvcnNkYWdcIiwgXCJGcmVkYWdcIiwgXCJMw7hyZGFnXCJdLCBkYXlfc2hvcnQ6IFtcIlPDuG5cIiwgXCJNb25cIiwgXCJUaXJcIiwgXCJPbnNcIiwgXCJUb3JcIiwgXCJGcmVcIiwgXCJMw7hyXCJdIH0sIGxhYmVsczogeyBuZXdfdGFzazogXCJOeSBvcHBnYXZlXCIsIGljb25fc2F2ZTogXCJMYWdyZVwiLCBpY29uX2NhbmNlbDogXCJBdmJyeXRcIiwgaWNvbl9kZXRhaWxzOiBcIkRldGFsamVyXCIsIGljb25fZWRpdDogXCJSZWRpZ2VyXCIsIGljb25fZGVsZXRlOiBcIlNsZXR0XCIsIGNvbmZpcm1fY2xvc2luZzogXCJcIiwgY29uZmlybV9kZWxldGluZzogXCJIZW5kZWxzZW4gdmlsIGJsaSBzbGV0dGV0IHBlcm1hbmVudC4gRXIgZHUgc2lra2VyP1wiLCBzZWN0aW9uX2Rlc2NyaXB0aW9uOiBcIkJlc2tyaXZlbHNlXCIsIHNlY3Rpb25fdGltZTogXCJUaWRzcGVyaW9kZVwiLCBzZWN0aW9uX3R5cGU6IFwiVHlwZVwiLCBzZWN0aW9uX2RlYWRsaW5lOiBcIkRlYWRsaW5lXCIsIHNlY3Rpb25fYmFzZWxpbmVzOiBcIkJhc2VsaW5lc1wiLCBjb2x1bW5fd2JzOiBcIldCU1wiLCBjb2x1bW5fdGV4dDogXCJUYXNrIG5hbWVcIiwgY29sdW1uX3N0YXJ0X2RhdGU6IFwiU3RhcnQgdGltZVwiLCBjb2x1bW5fZHVyYXRpb246IFwiRHVyYXRpb25cIiwgY29sdW1uX2FkZDogXCJcIiwgbGluazogXCJMaW5rXCIsIGNvbmZpcm1fbGlua19kZWxldGluZzogXCJ3aWxsIGJlIGRlbGV0ZWRcIiwgbGlua19zdGFydDogXCIgKHN0YXJ0KVwiLCBsaW5rX2VuZDogXCIgKGVuZClcIiwgdHlwZV90YXNrOiBcIlRhc2tcIiwgdHlwZV9wcm9qZWN0OiBcIlByb2plY3RcIiwgdHlwZV9taWxlc3RvbmU6IFwiTWlsZXN0b25lXCIsIG1pbnV0ZXM6IFwiTWludXRlc1wiLCBob3VyczogXCJIb3Vyc1wiLCBkYXlzOiBcIkRheXNcIiwgd2Vla3M6IFwiV2Vla1wiLCBtb250aHM6IFwiTW9udGhzXCIsIHllYXJzOiBcIlllYXJzXCIsIG1lc3NhZ2Vfb2s6IFwiT0tcIiwgbWVzc2FnZV9jYW5jZWw6IFwiQXZicnl0XCIsIHNlY3Rpb25fY29uc3RyYWludDogXCJDb25zdHJhaW50XCIsIGNvbnN0cmFpbnRfdHlwZTogXCJDb25zdHJhaW50IHR5cGVcIiwgY29uc3RyYWludF9kYXRlOiBcIkNvbnN0cmFpbnQgZGF0ZVwiLCBhc2FwOiBcIkFzIFNvb24gQXMgUG9zc2libGVcIiwgYWxhcDogXCJBcyBMYXRlIEFzIFBvc3NpYmxlXCIsIHNuZXQ6IFwiU3RhcnQgTm8gRWFybGllciBUaGFuXCIsIHNubHQ6IFwiU3RhcnQgTm8gTGF0ZXIgVGhhblwiLCBmbmV0OiBcIkZpbmlzaCBObyBFYXJsaWVyIFRoYW5cIiwgZm5sdDogXCJGaW5pc2ggTm8gTGF0ZXIgVGhhblwiLCBtc286IFwiTXVzdCBTdGFydCBPblwiLCBtZm86IFwiTXVzdCBGaW5pc2ggT25cIiwgcmVzb3VyY2VzX2ZpbHRlcl9wbGFjZWhvbGRlcjogXCJ0eXBlIHRvIGZpbHRlclwiLCByZXNvdXJjZXNfZmlsdGVyX2xhYmVsOiBcImhpZGUgZW1wdHlcIiwgZW1wdHlfc3RhdGVfdGV4dF9saW5rOiBcIkNsaWNrIGhlcmVcIiwgZW1wdHlfc3RhdGVfdGV4dF9kZXNjcmlwdGlvbjogXCJ0byBjcmVhdGUgeW91ciBmaXJzdCB0YXNrXCIsIGJhc2VsaW5lc19zZWN0aW9uX3BsYWNlaG9sZGVyOiBcIlN0YXJ0IGFkZGluZyBhIG5ldyBiYXNlbGluZVwiLCBiYXNlbGluZXNfYWRkX2J1dHRvbjogXCJBZGQgQmFzZWxpbmVcIiwgYmFzZWxpbmVzX3JlbW92ZV9idXR0b246IFwiUmVtb3ZlXCIsIGJhc2VsaW5lc19yZW1vdmVfYWxsX2J1dHRvbjogXCJSZW1vdmUgQWxsXCIsIGRlYWRsaW5lX2VuYWJsZV9idXR0b246IFwiU2V0XCIsIGRlYWRsaW5lX2Rpc2FibGVfYnV0dG9uOiBcIlJlbW92ZVwiIH0gfSwgR2kgPSB7IGRhdGU6IHsgbW9udGhfZnVsbDogW1wiSmFudWFyaVwiLCBcIkZlYnJ1YXJpXCIsIFwiTWFhcnRcIiwgXCJBcHJpbFwiLCBcIk1laVwiLCBcIkp1bmlcIiwgXCJKdWxpXCIsIFwiQXVndXN0dXNcIiwgXCJTZXB0ZW1iZXJcIiwgXCJPa3RvYmVyXCIsIFwiTm92ZW1iZXJcIiwgXCJEZWNlbWJlclwiXSwgbW9udGhfc2hvcnQ6IFtcIkphblwiLCBcIkZlYlwiLCBcIm1ydFwiLCBcIkFwclwiLCBcIk1laVwiLCBcIkp1blwiLCBcIkp1bFwiLCBcIkF1Z1wiLCBcIlNlcFwiLCBcIk9rdFwiLCBcIk5vdlwiLCBcIkRlY1wiXSwgZGF5X2Z1bGw6IFtcIlpvbmRhZ1wiLCBcIk1hYW5kYWdcIiwgXCJEaW5zZGFnXCIsIFwiV29lbnNkYWdcIiwgXCJEb25kZXJkYWdcIiwgXCJWcmlqZGFnXCIsIFwiWmF0ZXJkYWdcIl0sIGRheV9zaG9ydDogW1wiWm9cIiwgXCJNYVwiLCBcIkRpXCIsIFwiV29cIiwgXCJEb1wiLCBcIlZyXCIsIFwiWmFcIl0gfSwgbGFiZWxzOiB7IG5ld190YXNrOiBcIk5pZXV3ZSB0YWFrXCIsIGljb25fc2F2ZTogXCJPcHNsYWFuXCIsIGljb25fY2FuY2VsOiBcIkFubnVsZXJlblwiLCBpY29uX2RldGFpbHM6IFwiRGV0YWlsc1wiLCBpY29uX2VkaXQ6IFwiQmV3ZXJrZW5cIiwgaWNvbl9kZWxldGU6IFwiVmVyd2lqZGVyZW5cIiwgY29uZmlybV9jbG9zaW5nOiBcIlwiLCBjb25maXJtX2RlbGV0aW5nOiBcIkl0ZW0gemFsIHBlcm1hbmVudCB3b3JkZW4gdmVyd2lqZGVyZCwgZG9vcmdhYW4/XCIsIHNlY3Rpb25fZGVzY3JpcHRpb246IFwiQmVzY2hyaWp2aW5nXCIsIHNlY3Rpb25fdGltZTogXCJUaWpkIHBlcmlvZGVcIiwgc2VjdGlvbl90eXBlOiBcIlR5cGVcIiwgc2VjdGlvbl9kZWFkbGluZTogXCJEZWFkbGluZVwiLCBzZWN0aW9uX2Jhc2VsaW5lczogXCJCYXNlbGluZXNcIiwgY29sdW1uX3diczogXCJXQlNcIiwgY29sdW1uX3RleHQ6IFwiVGFhayBvbXNjaHJpanZpbmdcIiwgY29sdW1uX3N0YXJ0X2RhdGU6IFwiU3RhcnRkYXR1bVwiLCBjb2x1bW5fZHVyYXRpb246IFwiRHV1clwiLCBjb2x1bW5fYWRkOiBcIlwiLCBsaW5rOiBcIktvcHBlbGluZ1wiLCBjb25maXJtX2xpbmtfZGVsZXRpbmc6IFwiemFsIHdvcmRlbiB2ZXJ3aWpkZXJkXCIsIGxpbmtfc3RhcnQ6IFwiIChzdGFydClcIiwgbGlua19lbmQ6IFwiIChlaW5kKVwiLCB0eXBlX3Rhc2s6IFwiVGFza1wiLCB0eXBlX3Byb2plY3Q6IFwiUHJvamVjdFwiLCB0eXBlX21pbGVzdG9uZTogXCJNaWxlc3RvbmVcIiwgbWludXRlczogXCJtaW51dGVuXCIsIGhvdXJzOiBcInVyZW5cIiwgZGF5czogXCJkYWdlblwiLCB3ZWVrczogXCJ3ZWtlblwiLCBtb250aHM6IFwibWFhbmRlblwiLCB5ZWFyczogXCJqYXJlblwiLCBtZXNzYWdlX29rOiBcIk9LXCIsIG1lc3NhZ2VfY2FuY2VsOiBcIkFubnVsZXJlblwiLCBzZWN0aW9uX2NvbnN0cmFpbnQ6IFwiQ29uc3RyYWludFwiLCBjb25zdHJhaW50X3R5cGU6IFwiQ29uc3RyYWludCB0eXBlXCIsIGNvbnN0cmFpbnRfZGF0ZTogXCJDb25zdHJhaW50IGRhdGVcIiwgYXNhcDogXCJBcyBTb29uIEFzIFBvc3NpYmxlXCIsIGFsYXA6IFwiQXMgTGF0ZSBBcyBQb3NzaWJsZVwiLCBzbmV0OiBcIlN0YXJ0IE5vIEVhcmxpZXIgVGhhblwiLCBzbmx0OiBcIlN0YXJ0IE5vIExhdGVyIFRoYW5cIiwgZm5ldDogXCJGaW5pc2ggTm8gRWFybGllciBUaGFuXCIsIGZubHQ6IFwiRmluaXNoIE5vIExhdGVyIFRoYW5cIiwgbXNvOiBcIk11c3QgU3RhcnQgT25cIiwgbWZvOiBcIk11c3QgRmluaXNoIE9uXCIsIHJlc291cmNlc19maWx0ZXJfcGxhY2Vob2xkZXI6IFwidHlwZSB0byBmaWx0ZXJcIiwgcmVzb3VyY2VzX2ZpbHRlcl9sYWJlbDogXCJoaWRlIGVtcHR5XCIsIGVtcHR5X3N0YXRlX3RleHRfbGluazogXCJDbGljayBoZXJlXCIsIGVtcHR5X3N0YXRlX3RleHRfZGVzY3JpcHRpb246IFwidG8gY3JlYXRlIHlvdXIgZmlyc3QgdGFza1wiLCBiYXNlbGluZXNfc2VjdGlvbl9wbGFjZWhvbGRlcjogXCJTdGFydCBhZGRpbmcgYSBuZXcgYmFzZWxpbmVcIiwgYmFzZWxpbmVzX2FkZF9idXR0b246IFwiQWRkIEJhc2VsaW5lXCIsIGJhc2VsaW5lc19yZW1vdmVfYnV0dG9uOiBcIlJlbW92ZVwiLCBiYXNlbGluZXNfcmVtb3ZlX2FsbF9idXR0b246IFwiUmVtb3ZlIEFsbFwiLCBkZWFkbGluZV9lbmFibGVfYnV0dG9uOiBcIlNldFwiLCBkZWFkbGluZV9kaXNhYmxlX2J1dHRvbjogXCJSZW1vdmVcIiB9IH0sIFlpID0geyBkYXRlOiB7IG1vbnRoX2Z1bGw6IFtcIkphbnVhclwiLCBcIkZlYnJ1YXJcIiwgXCJNYXJzXCIsIFwiQXByaWxcIiwgXCJNYWlcIiwgXCJKdW5pXCIsIFwiSnVsaVwiLCBcIkF1Z3VzdFwiLCBcIlNlcHRlbWJlclwiLCBcIk9rdG9iZXJcIiwgXCJOb3ZlbWJlclwiLCBcIkRlc2VtYmVyXCJdLCBtb250aF9zaG9ydDogW1wiSmFuXCIsIFwiRmViXCIsIFwiTWFyXCIsIFwiQXByXCIsIFwiTWFpXCIsIFwiSnVuXCIsIFwiSnVsXCIsIFwiQXVnXCIsIFwiU2VwXCIsIFwiT2t0XCIsIFwiTm92XCIsIFwiRGVzXCJdLCBkYXlfZnVsbDogW1wiU8O4bmRhZ1wiLCBcIk1hbmRhZ1wiLCBcIlRpcnNkYWdcIiwgXCJPbnNkYWdcIiwgXCJUb3JzZGFnXCIsIFwiRnJlZGFnXCIsIFwiTMO4cmRhZ1wiXSwgZGF5X3Nob3J0OiBbXCJTw7huXCIsIFwiTWFuXCIsIFwiVGlyXCIsIFwiT25zXCIsIFwiVG9yXCIsIFwiRnJlXCIsIFwiTMO4clwiXSB9LCBsYWJlbHM6IHsgbmV3X3Rhc2s6IFwiTnkgb3BwZ2F2ZVwiLCBpY29uX3NhdmU6IFwiTGFncmVcIiwgaWNvbl9jYW5jZWw6IFwiQXZicnl0XCIsIGljb25fZGV0YWlsczogXCJEZXRhbGplclwiLCBpY29uX2VkaXQ6IFwiRW5kcmVcIiwgaWNvbl9kZWxldGU6IFwiU2xldHRcIiwgY29uZmlybV9jbG9zaW5nOiBcIkVuZHJpbmdlciBibGlyIGlra2UgbGFncmV0LCBlciBkdSBzaWtrZXI/XCIsIGNvbmZpcm1fZGVsZXRpbmc6IFwiT3BwZsO4cmluZ2VuIHZpbCBibGkgc2xldHRldCwgZXIgZHUgc2lra2VyP1wiLCBzZWN0aW9uX2Rlc2NyaXB0aW9uOiBcIkJlc2tyaXZlbHNlXCIsIHNlY3Rpb25fdGltZTogXCJUaWRzcGVyaW9kZVwiLCBzZWN0aW9uX3R5cGU6IFwiVHlwZVwiLCBzZWN0aW9uX2RlYWRsaW5lOiBcIkRlYWRsaW5lXCIsIHNlY3Rpb25fYmFzZWxpbmVzOiBcIkJhc2VsaW5lc1wiLCBjb2x1bW5fd2JzOiBcIldCU1wiLCBjb2x1bW5fdGV4dDogXCJUYXNrIG5hbWVcIiwgY29sdW1uX3N0YXJ0X2RhdGU6IFwiU3RhcnQgdGltZVwiLCBjb2x1bW5fZHVyYXRpb246IFwiRHVyYXRpb25cIiwgY29sdW1uX2FkZDogXCJcIiwgbGluazogXCJMaW5rXCIsIGNvbmZpcm1fbGlua19kZWxldGluZzogXCJ3aWxsIGJlIGRlbGV0ZWRcIiwgbGlua19zdGFydDogXCIgKHN0YXJ0KVwiLCBsaW5rX2VuZDogXCIgKGVuZClcIiwgdHlwZV90YXNrOiBcIlRhc2tcIiwgdHlwZV9wcm9qZWN0OiBcIlByb2plY3RcIiwgdHlwZV9taWxlc3RvbmU6IFwiTWlsZXN0b25lXCIsIG1pbnV0ZXM6IFwiTWludXRlc1wiLCBob3VyczogXCJIb3Vyc1wiLCBkYXlzOiBcIkRheXNcIiwgd2Vla3M6IFwiV2Vla1wiLCBtb250aHM6IFwiTW9udGhzXCIsIHllYXJzOiBcIlllYXJzXCIsIG1lc3NhZ2Vfb2s6IFwiT0tcIiwgbWVzc2FnZV9jYW5jZWw6IFwiQXZicnl0XCIsIHNlY3Rpb25fY29uc3RyYWludDogXCJDb25zdHJhaW50XCIsIGNvbnN0cmFpbnRfdHlwZTogXCJDb25zdHJhaW50IHR5cGVcIiwgY29uc3RyYWludF9kYXRlOiBcIkNvbnN0cmFpbnQgZGF0ZVwiLCBhc2FwOiBcIkFzIFNvb24gQXMgUG9zc2libGVcIiwgYWxhcDogXCJBcyBMYXRlIEFzIFBvc3NpYmxlXCIsIHNuZXQ6IFwiU3RhcnQgTm8gRWFybGllciBUaGFuXCIsIHNubHQ6IFwiU3RhcnQgTm8gTGF0ZXIgVGhhblwiLCBmbmV0OiBcIkZpbmlzaCBObyBFYXJsaWVyIFRoYW5cIiwgZm5sdDogXCJGaW5pc2ggTm8gTGF0ZXIgVGhhblwiLCBtc286IFwiTXVzdCBTdGFydCBPblwiLCBtZm86IFwiTXVzdCBGaW5pc2ggT25cIiwgcmVzb3VyY2VzX2ZpbHRlcl9wbGFjZWhvbGRlcjogXCJ0eXBlIHRvIGZpbHRlclwiLCByZXNvdXJjZXNfZmlsdGVyX2xhYmVsOiBcImhpZGUgZW1wdHlcIiwgZW1wdHlfc3RhdGVfdGV4dF9saW5rOiBcIkNsaWNrIGhlcmVcIiwgZW1wdHlfc3RhdGVfdGV4dF9kZXNjcmlwdGlvbjogXCJ0byBjcmVhdGUgeW91ciBmaXJzdCB0YXNrXCIsIGJhc2VsaW5lc19zZWN0aW9uX3BsYWNlaG9sZGVyOiBcIlN0YXJ0IGFkZGluZyBhIG5ldyBiYXNlbGluZVwiLCBiYXNlbGluZXNfYWRkX2J1dHRvbjogXCJBZGQgQmFzZWxpbmVcIiwgYmFzZWxpbmVzX3JlbW92ZV9idXR0b246IFwiUmVtb3ZlXCIsIGJhc2VsaW5lc19yZW1vdmVfYWxsX2J1dHRvbjogXCJSZW1vdmUgQWxsXCIsIGRlYWRsaW5lX2VuYWJsZV9idXR0b246IFwiU2V0XCIsIGRlYWRsaW5lX2Rpc2FibGVfYnV0dG9uOiBcIlJlbW92ZVwiIH0gfSwgSmkgPSB7IGRhdGU6IHsgbW9udGhfZnVsbDogW1wiU3R5Y3plxYRcIiwgXCJMdXR5XCIsIFwiTWFyemVjXCIsIFwiS3dpZWNpZcWEXCIsIFwiTWFqXCIsIFwiQ3plcndpZWNcIiwgXCJMaXBpZWNcIiwgXCJTaWVycGllxYRcIiwgXCJXcnplc2llxYRcIiwgXCJQYcW6ZHppZXJuaWtcIiwgXCJMaXN0b3BhZFwiLCBcIkdydWR6aWXFhFwiXSwgbW9udGhfc2hvcnQ6IFtcIlN0eVwiLCBcIkx1dFwiLCBcIk1hclwiLCBcIkt3aVwiLCBcIk1halwiLCBcIkN6ZVwiLCBcIkxpcFwiLCBcIlNpZVwiLCBcIldyelwiLCBcIlBhxbpcIiwgXCJMaXNcIiwgXCJHcnVcIl0sIGRheV9mdWxsOiBbXCJOaWVkemllbGFcIiwgXCJQb25pZWR6aWHFgmVrXCIsIFwiV3RvcmVrXCIsIFwixZpyb2RhXCIsIFwiQ3p3YXJ0ZWtcIiwgXCJQacSFdGVrXCIsIFwiU29ib3RhXCJdLCBkYXlfc2hvcnQ6IFtcIk5pZVwiLCBcIlBvblwiLCBcIld0b1wiLCBcIsWacm9cIiwgXCJDendcIiwgXCJQacSFXCIsIFwiU29iXCJdIH0sIGxhYmVsczogeyBuZXdfdGFzazogXCJOb3dlIHphZGFuaWVcIiwgaWNvbl9zYXZlOiBcIlphcGlzelwiLCBpY29uX2NhbmNlbDogXCJBbnVsdWpcIiwgaWNvbl9kZXRhaWxzOiBcIlN6Y3plZ8OzxYJ5XCIsIGljb25fZWRpdDogXCJFZHl0dWpcIiwgaWNvbl9kZWxldGU6IFwiVXN1xYRcIiwgY29uZmlybV9jbG9zaW5nOiBcIlwiLCBjb25maXJtX2RlbGV0aW5nOiBcIlpkYXJ6ZW5pZSB6b3N0YW5pZSB1c3VuacSZdGUgbmEgemF3c3plLCBrb250eW51b3dhxIc/XCIsIHNlY3Rpb25fZGVzY3JpcHRpb246IFwiT3Bpc1wiLCBzZWN0aW9uX3RpbWU6IFwiT2tyZXMgY3phc3VcIiwgc2VjdGlvbl90eXBlOiBcIlR5cFwiLCBzZWN0aW9uX2RlYWRsaW5lOiBcIkRlYWRsaW5lXCIsIHNlY3Rpb25fYmFzZWxpbmVzOiBcIkJhc2VsaW5lc1wiLCBjb2x1bW5fd2JzOiBcIldCU1wiLCBjb2x1bW5fdGV4dDogXCJOYXp3YSB6YWRhbmlhXCIsIGNvbHVtbl9zdGFydF9kYXRlOiBcIlBvY3rEhXRla1wiLCBjb2x1bW5fZHVyYXRpb246IFwiQ3phcyB0cndhbmlhXCIsIGNvbHVtbl9hZGQ6IFwiXCIsIGxpbms6IFwiTGlua1wiLCBjb25maXJtX2xpbmtfZGVsZXRpbmc6IFwiem9zdGFuaWUgdXN1bmnEmXR5XCIsIGxpbmtfc3RhcnQ6IFwiIChwb2N6xIV0ZWspXCIsIGxpbmtfZW5kOiBcIiAoa29uaWVjKVwiLCB0eXBlX3Rhc2s6IFwiWmFkYW5pZVwiLCB0eXBlX3Byb2plY3Q6IFwiUHJvamVrdFwiLCB0eXBlX21pbGVzdG9uZTogXCJNaWxlc3RvbmVcIiwgbWludXRlczogXCJNaW51dHlcIiwgaG91cnM6IFwiR29kemlueVwiLCBkYXlzOiBcIkRuaVwiLCB3ZWVrczogXCJUeWR6aWXFhFwiLCBtb250aHM6IFwiTWllc2nEhWNlXCIsIHllYXJzOiBcIkxhdGFcIiwgbWVzc2FnZV9vazogXCJPS1wiLCBtZXNzYWdlX2NhbmNlbDogXCJBbnVsdWpcIiwgc2VjdGlvbl9jb25zdHJhaW50OiBcIkNvbnN0cmFpbnRcIiwgY29uc3RyYWludF90eXBlOiBcIkNvbnN0cmFpbnQgdHlwZVwiLCBjb25zdHJhaW50X2RhdGU6IFwiQ29uc3RyYWludCBkYXRlXCIsIGFzYXA6IFwiQXMgU29vbiBBcyBQb3NzaWJsZVwiLCBhbGFwOiBcIkFzIExhdGUgQXMgUG9zc2libGVcIiwgc25ldDogXCJTdGFydCBObyBFYXJsaWVyIFRoYW5cIiwgc25sdDogXCJTdGFydCBObyBMYXRlciBUaGFuXCIsIGZuZXQ6IFwiRmluaXNoIE5vIEVhcmxpZXIgVGhhblwiLCBmbmx0OiBcIkZpbmlzaCBObyBMYXRlciBUaGFuXCIsIG1zbzogXCJNdXN0IFN0YXJ0IE9uXCIsIG1mbzogXCJNdXN0IEZpbmlzaCBPblwiLCByZXNvdXJjZXNfZmlsdGVyX3BsYWNlaG9sZGVyOiBcInR5cGUgdG8gZmlsdGVyXCIsIHJlc291cmNlc19maWx0ZXJfbGFiZWw6IFwiaGlkZSBlbXB0eVwiLCBlbXB0eV9zdGF0ZV90ZXh0X2xpbms6IFwiQ2xpY2sgaGVyZVwiLCBlbXB0eV9zdGF0ZV90ZXh0X2Rlc2NyaXB0aW9uOiBcInRvIGNyZWF0ZSB5b3VyIGZpcnN0IHRhc2tcIiwgYmFzZWxpbmVzX3NlY3Rpb25fcGxhY2Vob2xkZXI6IFwiU3RhcnQgYWRkaW5nIGEgbmV3IGJhc2VsaW5lXCIsIGJhc2VsaW5lc19hZGRfYnV0dG9uOiBcIkFkZCBCYXNlbGluZVwiLCBiYXNlbGluZXNfcmVtb3ZlX2J1dHRvbjogXCJSZW1vdmVcIiwgYmFzZWxpbmVzX3JlbW92ZV9hbGxfYnV0dG9uOiBcIlJlbW92ZSBBbGxcIiwgZGVhZGxpbmVfZW5hYmxlX2J1dHRvbjogXCJTZXRcIiwgZGVhZGxpbmVfZGlzYWJsZV9idXR0b246IFwiUmVtb3ZlXCIgfSB9LCBLaSA9IHsgZGF0ZTogeyBtb250aF9mdWxsOiBbXCJKYW5laXJvXCIsIFwiRmV2ZXJlaXJvXCIsIFwiTWFyw6dvXCIsIFwiQWJyaWxcIiwgXCJNYWlvXCIsIFwiSnVuaG9cIiwgXCJKdWxob1wiLCBcIkFnb3N0b1wiLCBcIlNldGVtYnJvXCIsIFwiT3V0dWJyb1wiLCBcIk5vdmVtYnJvXCIsIFwiRGV6ZW1icm9cIl0sIG1vbnRoX3Nob3J0OiBbXCJKYW5cIiwgXCJGZXZcIiwgXCJNYXJcIiwgXCJBYnJcIiwgXCJNYWlcIiwgXCJKdW5cIiwgXCJKdWxcIiwgXCJBZ29cIiwgXCJTZXRcIiwgXCJPdXRcIiwgXCJOb3ZcIiwgXCJEZXpcIl0sIGRheV9mdWxsOiBbXCJEb21pbmdvXCIsIFwiU2VndW5kYVwiLCBcIlRlcsOnYVwiLCBcIlF1YXJ0YVwiLCBcIlF1aW50YVwiLCBcIlNleHRhXCIsIFwiU8OhYmFkb1wiXSwgZGF5X3Nob3J0OiBbXCJEb21cIiwgXCJTZWdcIiwgXCJUZXJcIiwgXCJRdWFcIiwgXCJRdWlcIiwgXCJTZXhcIiwgXCJTYWJcIl0gfSwgbGFiZWxzOiB7IG5ld190YXNrOiBcIk5vdmEgdGFyZWZhXCIsIGljb25fc2F2ZTogXCJTYWx2YXJcIiwgaWNvbl9jYW5jZWw6IFwiQ2FuY2VsYXJcIiwgaWNvbl9kZXRhaWxzOiBcIkRldGFsaGVzXCIsIGljb25fZWRpdDogXCJFZGl0YXJcIiwgaWNvbl9kZWxldGU6IFwiRXhjbHVpclwiLCBjb25maXJtX2Nsb3Npbmc6IFwiXCIsIGNvbmZpcm1fZGVsZXRpbmc6IFwiQXMgdGFyZWZhcyBzZXLDo28gZXhjbHVpZGFzIHBlcm1hbmVudGVtZW50ZSwgY29uZmlybWU/XCIsIHNlY3Rpb25fZGVzY3JpcHRpb246IFwiRGVzY3Jpw6fDo29cIiwgc2VjdGlvbl90aW1lOiBcIlBlcsOtb2RvXCIsIHNlY3Rpb25fdHlwZTogXCJUaXBvXCIsIHNlY3Rpb25fZGVhZGxpbmU6IFwiRGVhZGxpbmVcIiwgc2VjdGlvbl9iYXNlbGluZXM6IFwiQmFzZWxpbmVzXCIsIGNvbHVtbl93YnM6IFwiRUFQXCIsIGNvbHVtbl90ZXh0OiBcIk5vbWUgdGFyZWZhXCIsIGNvbHVtbl9zdGFydF9kYXRlOiBcIkRhdGEgaW7DrWNpb1wiLCBjb2x1bW5fZHVyYXRpb246IFwiRHVyYcOnw6NvXCIsIGNvbHVtbl9hZGQ6IFwiXCIsIGxpbms6IFwiTGlua1wiLCBjb25maXJtX2xpbmtfZGVsZXRpbmc6IFwiU2Vyw6EgZXhjbHXDrWRvIVwiLCBsaW5rX3N0YXJ0OiBcIiAoaW7DrWNpbylcIiwgbGlua19lbmQ6IFwiIChmaW0pXCIsIHR5cGVfdGFzazogXCJUYXNrXCIsIHR5cGVfcHJvamVjdDogXCJQcm9qZXRvXCIsIHR5cGVfbWlsZXN0b25lOiBcIk1hcmNvXCIsIG1pbnV0ZXM6IFwiTWludXRvc1wiLCBob3VyczogXCJIb3Jhc1wiLCBkYXlzOiBcIkRpYXNcIiwgd2Vla3M6IFwiU2VtYW5hc1wiLCBtb250aHM6IFwiTWVzZXNcIiwgeWVhcnM6IFwiQW5vc1wiLCBtZXNzYWdlX29rOiBcIk9LXCIsIG1lc3NhZ2VfY2FuY2VsOiBcIkNhbmNlbGFyXCIsIHNlY3Rpb25fY29uc3RyYWludDogXCJSZXN0cmnDp8Ojb1wiLCBjb25zdHJhaW50X3R5cGU6IFwiVGlwbyBSZXN0cmnDp8Ojb1wiLCBjb25zdHJhaW50X2RhdGU6IFwiRGF0YSByZXN0cmnDp8Ojb1wiLCBhc2FwOiBcIk1haXMgYnJldmUgcG9zc8OtdmVsXCIsIGFsYXA6IFwiTWFpcyB0YXJkZSBwb3Nzw612ZWxcIiwgc25ldDogXCJOw6NvIGNvbWXDp2FyIGFudGVzIGRlXCIsIHNubHQ6IFwiTsOjbyBjb21lw6dhciBkZXBvaXMgZGVcIiwgZm5ldDogXCJOw6NvIHRlcm1pbmFyIGFudGVzIGRlXCIsIGZubHQ6IFwiTsOjbyB0ZXJtaW5hciBkZXBvaXMgZGVcIiwgbXNvOiBcIlByZWNpc2EgY29tZcOnYXIgZW1cIiwgbWZvOiBcIlByZWNpc2EgdGVybWluYXIgZW1cIiwgcmVzb3VyY2VzX2ZpbHRlcl9wbGFjZWhvbGRlcjogXCJUaXBvIGRlIGZpbHRyb3NcIiwgcmVzb3VyY2VzX2ZpbHRlcl9sYWJlbDogXCJPY3VsdGFyIHZhemlvc1wiLCBlbXB0eV9zdGF0ZV90ZXh0X2xpbms6IFwiQ2xpY2sgaGVyZVwiLCBlbXB0eV9zdGF0ZV90ZXh0X2Rlc2NyaXB0aW9uOiBcInRvIGNyZWF0ZSB5b3VyIGZpcnN0IHRhc2tcIiwgYmFzZWxpbmVzX3NlY3Rpb25fcGxhY2Vob2xkZXI6IFwiU3RhcnQgYWRkaW5nIGEgbmV3IGJhc2VsaW5lXCIsIGJhc2VsaW5lc19hZGRfYnV0dG9uOiBcIkFkZCBCYXNlbGluZVwiLCBiYXNlbGluZXNfcmVtb3ZlX2J1dHRvbjogXCJSZW1vdmVcIiwgYmFzZWxpbmVzX3JlbW92ZV9hbGxfYnV0dG9uOiBcIlJlbW92ZSBBbGxcIiwgZGVhZGxpbmVfZW5hYmxlX2J1dHRvbjogXCJTZXRcIiwgZGVhZGxpbmVfZGlzYWJsZV9idXR0b246IFwiUmVtb3ZlXCIgfSB9LCBYaSA9IHsgZGF0ZTogeyBtb250aF9mdWxsOiBbXCJJYW51YXJpZVwiLCBcIkZlYnJ1YXJpZVwiLCBcIk1hcnRpZVwiLCBcIkFwcmlsaWVcIiwgXCJNYWlcIiwgXCJJdW5pZVwiLCBcIkl1bGllXCIsIFwiQXVndXN0XCIsIFwiU2VwdGVtYnJpZVwiLCBcIk9jdG9tYnJpZVwiLCBcIk5vdmVtYmVyXCIsIFwiRGVjZW1iZXJcIl0sIG1vbnRoX3Nob3J0OiBbXCJJYW5cIiwgXCJGZWJcIiwgXCJNYXJcIiwgXCJBcHJcIiwgXCJNYWlcIiwgXCJJdW5cIiwgXCJJdWxcIiwgXCJBdWdcIiwgXCJTZXBcIiwgXCJPY3RcIiwgXCJOb3ZcIiwgXCJEZWNcIl0sIGRheV9mdWxsOiBbXCJEdW1pbmljYVwiLCBcIkx1bmlcIiwgXCJNYXJ0aVwiLCBcIk1pZXJjdXJpXCIsIFwiSm9pXCIsIFwiVmluZXJpXCIsIFwiU2FtYmF0YVwiXSwgZGF5X3Nob3J0OiBbXCJEdVwiLCBcIkx1XCIsIFwiTWFcIiwgXCJNaVwiLCBcIkpvXCIsIFwiVmlcIiwgXCJTYVwiXSB9LCBsYWJlbHM6IHsgbmV3X3Rhc2s6IFwiU2FyY2luYSBub3VhXCIsIGljb25fc2F2ZTogXCJTYWx2ZWF6YVwiLCBpY29uX2NhbmNlbDogXCJBbnVsZWF6YVwiLCBpY29uX2RldGFpbHM6IFwiRGV0YWxpaVwiLCBpY29uX2VkaXQ6IFwiRWRpdGVhemFcIiwgaWNvbl9kZWxldGU6IFwiU3RlcmdlXCIsIGNvbmZpcm1fY2xvc2luZzogXCJTY2hpbWJhcmlsZSBudSB2b3IgZmkgc2FsdmF0ZSwgZXN0aSBzaWd1cj9cIiwgY29uZmlybV9kZWxldGluZzogXCJFdmVuaW1lbnR1bCB2YSBmaSBzdGVycyBwZXJtYW5lbnQsIGVzdGkgc2lndXI/XCIsIHNlY3Rpb25fZGVzY3JpcHRpb246IFwiRGVzY3JpZXJlXCIsIHNlY3Rpb25fdGltZTogXCJJbnRlcnZhbFwiLCBzZWN0aW9uX3R5cGU6IFwiVHlwZVwiLCBzZWN0aW9uX2RlYWRsaW5lOiBcIkRlYWRsaW5lXCIsIHNlY3Rpb25fYmFzZWxpbmVzOiBcIkJhc2VsaW5lc1wiLCBjb2x1bW5fd2JzOiBcIldCU1wiLCBjb2x1bW5fdGV4dDogXCJUYXNrIG5hbWVcIiwgY29sdW1uX3N0YXJ0X2RhdGU6IFwiU3RhcnQgdGltZVwiLCBjb2x1bW5fZHVyYXRpb246IFwiRHVyYXRpb25cIiwgY29sdW1uX2FkZDogXCJcIiwgbGluazogXCJMaW5rXCIsIGNvbmZpcm1fbGlua19kZWxldGluZzogXCJ3aWxsIGJlIGRlbGV0ZWRcIiwgbGlua19zdGFydDogXCIgKHN0YXJ0KVwiLCBsaW5rX2VuZDogXCIgKGVuZClcIiwgdHlwZV90YXNrOiBcIlRhc2tcIiwgdHlwZV9wcm9qZWN0OiBcIlByb2plY3RcIiwgdHlwZV9taWxlc3RvbmU6IFwiTWlsZXN0b25lXCIsIG1pbnV0ZXM6IFwiTWludXRlc1wiLCBob3VyczogXCJIb3Vyc1wiLCBkYXlzOiBcIkRheXNcIiwgd2Vla3M6IFwiV2Vla1wiLCBtb250aHM6IFwiTW9udGhzXCIsIHllYXJzOiBcIlllYXJzXCIsIG1lc3NhZ2Vfb2s6IFwiT0tcIiwgbWVzc2FnZV9jYW5jZWw6IFwiQW51bGVhemFcIiwgc2VjdGlvbl9jb25zdHJhaW50OiBcIkNvbnN0cmFpbnRcIiwgY29uc3RyYWludF90eXBlOiBcIkNvbnN0cmFpbnQgdHlwZVwiLCBjb25zdHJhaW50X2RhdGU6IFwiQ29uc3RyYWludCBkYXRlXCIsIGFzYXA6IFwiQXMgU29vbiBBcyBQb3NzaWJsZVwiLCBhbGFwOiBcIkFzIExhdGUgQXMgUG9zc2libGVcIiwgc25ldDogXCJTdGFydCBObyBFYXJsaWVyIFRoYW5cIiwgc25sdDogXCJTdGFydCBObyBMYXRlciBUaGFuXCIsIGZuZXQ6IFwiRmluaXNoIE5vIEVhcmxpZXIgVGhhblwiLCBmbmx0OiBcIkZpbmlzaCBObyBMYXRlciBUaGFuXCIsIG1zbzogXCJNdXN0IFN0YXJ0IE9uXCIsIG1mbzogXCJNdXN0IEZpbmlzaCBPblwiLCByZXNvdXJjZXNfZmlsdGVyX3BsYWNlaG9sZGVyOiBcInR5cGUgdG8gZmlsdGVyXCIsIHJlc291cmNlc19maWx0ZXJfbGFiZWw6IFwiaGlkZSBlbXB0eVwiLCBlbXB0eV9zdGF0ZV90ZXh0X2xpbms6IFwiQ2xpY2sgaGVyZVwiLCBlbXB0eV9zdGF0ZV90ZXh0X2Rlc2NyaXB0aW9uOiBcInRvIGNyZWF0ZSB5b3VyIGZpcnN0IHRhc2tcIiwgYmFzZWxpbmVzX3NlY3Rpb25fcGxhY2Vob2xkZXI6IFwiU3RhcnQgYWRkaW5nIGEgbmV3IGJhc2VsaW5lXCIsIGJhc2VsaW5lc19hZGRfYnV0dG9uOiBcIkFkZCBCYXNlbGluZVwiLCBiYXNlbGluZXNfcmVtb3ZlX2J1dHRvbjogXCJSZW1vdmVcIiwgYmFzZWxpbmVzX3JlbW92ZV9hbGxfYnV0dG9uOiBcIlJlbW92ZSBBbGxcIiwgZGVhZGxpbmVfZW5hYmxlX2J1dHRvbjogXCJTZXRcIiwgZGVhZGxpbmVfZGlzYWJsZV9idXR0b246IFwiUmVtb3ZlXCIgfSB9LCBaaSA9IHsgZGF0ZTogeyBtb250aF9mdWxsOiBbXCLQr9C90LLQsNGA0YxcIiwgXCLQpNC10LLRgNCw0LvRjFwiLCBcItCc0LDRgNGCXCIsIFwi0JDQv9GA0LXQu9GMXCIsIFwiTWHQuVwiLCBcItCY0Y7QvdGMXCIsIFwi0JjRjtC70YxcIiwgXCLQkNCy0LPRg9GB0YJcIiwgXCLQodC10L3RgtGP0LHRgNGMXCIsIFwiT9C60YLRj9Cx0YDRjFwiLCBcItCd0L7Rj9Cx0YDRjFwiLCBcItCU0LXQutCw0LHRgNGMXCJdLCBtb250aF9zaG9ydDogW1wi0K/QvdCyXCIsIFwi0KTQtdCyXCIsIFwiTWHRgFwiLCBcIkHQv9GAXCIsIFwiTWHQuVwiLCBcItCY0Y7QvVwiLCBcItCY0Y7Qu1wiLCBcIkHQstCzXCIsIFwi0KHQtdC9XCIsIFwi0J7QutGCXCIsIFwi0J3QvtGPXCIsIFwi0JTQtdC6XCJdLCBkYXlfZnVsbDogW1wi0JLQvtGB0LrRgNC10YHQtdC90YzQtVwiLCBcItCf0L7QvdC10LTQtdC70YzQvdC40LpcIiwgXCLQktGC0L7RgNC90LjQulwiLCBcItCh0YDQtdC00LBcIiwgXCLQp9C10YLQstC10YDQs1wiLCBcItCf0Y/RgtC90LjRhtCwXCIsIFwi0KHRg9Cx0LHQvtGC0LBcIl0sIGRheV9zaG9ydDogW1wi0JLRgVwiLCBcItCf0L1cIiwgXCLQktGCXCIsIFwi0KHRgFwiLCBcItCn0YJcIiwgXCLQn9GCXCIsIFwi0KHQsVwiXSB9LCBsYWJlbHM6IHsgbmV3X3Rhc2s6IFwi0J3QvtCy0L7QtSDQt9Cw0LTQsNC90LjQtVwiLCBpY29uX3NhdmU6IFwi0KHQvtGF0YDQsNC90LjRgtGMXCIsIGljb25fY2FuY2VsOiBcItCe0YLQvNC10L3QuNGC0YxcIiwgaWNvbl9kZXRhaWxzOiBcItCU0LXRgtCw0LvQuFwiLCBpY29uX2VkaXQ6IFwi0JjQt9C80LXQvdC40YLRjFwiLCBpY29uX2RlbGV0ZTogXCLQo9C00LDQu9C40YLRjFwiLCBjb25maXJtX2Nsb3Npbmc6IFwiXCIsIGNvbmZpcm1fZGVsZXRpbmc6IFwi0KHQvtCx0YvRgtC40LUg0LHRg9C00LXRgiDRg9C00LDQu9C10L3QviDQsdC10LfQstC+0LfQstGA0LDRgtC90L4sINC/0YDQvtC00L7Qu9C20LjRgtGMP1wiLCBzZWN0aW9uX2Rlc2NyaXB0aW9uOiBcItCe0L/QuNGB0LDQvdC40LVcIiwgc2VjdGlvbl90aW1lOiBcItCf0LXRgNC40L7QtCDQstGA0LXQvNC10L3QuFwiLCBzZWN0aW9uX3R5cGU6IFwi0KLQuNC/XCIsIHNlY3Rpb25fZGVhZGxpbmU6IFwiRGVhZGxpbmVcIiwgc2VjdGlvbl9iYXNlbGluZXM6IFwiQmFzZWxpbmVzXCIsIGNvbHVtbl93YnM6IFwi0JjQodCgXCIsIGNvbHVtbl90ZXh0OiBcItCX0LDQtNCw0YfQsFwiLCBjb2x1bW5fc3RhcnRfZGF0ZTogXCLQndCw0YfQsNC70L5cIiwgY29sdW1uX2R1cmF0aW9uOiBcItCU0LvQuNGC0LXQu9GM0L3QvtGB0YLRjFwiLCBjb2x1bW5fYWRkOiBcIlwiLCBsaW5rOiBcItCh0LLRj9C30YxcIiwgY29uZmlybV9saW5rX2RlbGV0aW5nOiBcItCx0YPQtNC10YIg0YPQtNCw0LvQtdC90LBcIiwgbGlua19zdGFydDogXCIgKNC90LDRh9Cw0LvQvilcIiwgbGlua19lbmQ6IFwiICjQutC+0L3QtdGGKVwiLCB0eXBlX3Rhc2s6IFwiVGFza1wiLCB0eXBlX3Byb2plY3Q6IFwiUHJvamVjdFwiLCB0eXBlX21pbGVzdG9uZTogXCJNaWxlc3RvbmVcIiwgbWludXRlczogXCLQnNC40L3Rg9GC0LBcIiwgaG91cnM6IFwi0KfQsNGBXCIsIGRheXM6IFwi0JTQtdC90YxcIiwgd2Vla3M6IFwi0J3QtdC00LXQu9GPXCIsIG1vbnRoczogXCLQnNC10YHRj9GGXCIsIHllYXJzOiBcItCT0L7QtFwiLCBtZXNzYWdlX29rOiBcIk9LXCIsIG1lc3NhZ2VfY2FuY2VsOiBcItCe0YLQvNC10L3QuNGC0YxcIiwgc2VjdGlvbl9jb25zdHJhaW50OiBcIkNvbnN0cmFpbnRcIiwgY29uc3RyYWludF90eXBlOiBcIkNvbnN0cmFpbnQgdHlwZVwiLCBjb25zdHJhaW50X2RhdGU6IFwiQ29uc3RyYWludCBkYXRlXCIsIGFzYXA6IFwiQXMgU29vbiBBcyBQb3NzaWJsZVwiLCBhbGFwOiBcIkFzIExhdGUgQXMgUG9zc2libGVcIiwgc25ldDogXCJTdGFydCBObyBFYXJsaWVyIFRoYW5cIiwgc25sdDogXCJTdGFydCBObyBMYXRlciBUaGFuXCIsIGZuZXQ6IFwiRmluaXNoIE5vIEVhcmxpZXIgVGhhblwiLCBmbmx0OiBcIkZpbmlzaCBObyBMYXRlciBUaGFuXCIsIG1zbzogXCJNdXN0IFN0YXJ0IE9uXCIsIG1mbzogXCJNdXN0IEZpbmlzaCBPblwiLCByZXNvdXJjZXNfZmlsdGVyX3BsYWNlaG9sZGVyOiBcItC90LDRh9C90LjRgtC1INCy0LLQvtC00LjRgtGMINGB0LvQvtCy0L4g0LTQu9GPINGE0LjQu9GM0YLRgNCw0YbQuNC4XCIsIHJlc291cmNlc19maWx0ZXJfbGFiZWw6IFwi0YHQv9GA0Y/RgtCw0YLRjCDQvdC1INGD0YHRgtCw0L3QvtCy0LvQtdC90L3Ri9C1XCIsIGVtcHR5X3N0YXRlX3RleHRfbGluazogXCJDbGljayBoZXJlXCIsIGVtcHR5X3N0YXRlX3RleHRfZGVzY3JpcHRpb246IFwidG8gY3JlYXRlIHlvdXIgZmlyc3QgdGFza1wiLCBiYXNlbGluZXNfc2VjdGlvbl9wbGFjZWhvbGRlcjogXCJTdGFydCBhZGRpbmcgYSBuZXcgYmFzZWxpbmVcIiwgYmFzZWxpbmVzX2FkZF9idXR0b246IFwiQWRkIEJhc2VsaW5lXCIsIGJhc2VsaW5lc19yZW1vdmVfYnV0dG9uOiBcIlJlbW92ZVwiLCBiYXNlbGluZXNfcmVtb3ZlX2FsbF9idXR0b246IFwiUmVtb3ZlIEFsbFwiLCBkZWFkbGluZV9lbmFibGVfYnV0dG9uOiBcIlNldFwiLCBkZWFkbGluZV9kaXNhYmxlX2J1dHRvbjogXCJSZW1vdmVcIiB9IH0sIFFpID0geyBkYXRlOiB7IG1vbnRoX2Z1bGw6IFtcIkphbnVhclwiLCBcIkZlYnJ1YXJcIiwgXCJNYXJlY1wiLCBcIkFwcmlsXCIsIFwiTWFqXCIsIFwiSnVuaWpcIiwgXCJKdWxpalwiLCBcIkF2Z3VzdFwiLCBcIlNlcHRlbWJlclwiLCBcIk9rdG9iZXJcIiwgXCJOb3ZlbWJlclwiLCBcIkRlY2VtYmVyXCJdLCBtb250aF9zaG9ydDogW1wiSmFuXCIsIFwiRmViXCIsIFwiTWFyXCIsIFwiQXByXCIsIFwiTWFqXCIsIFwiSnVuXCIsIFwiSnVsXCIsIFwiQXVnXCIsIFwiU2VwXCIsIFwiT2t0XCIsIFwiTm92XCIsIFwiRGVjXCJdLCBkYXlfZnVsbDogW1wiTmVkZWxqYVwiLCBcIlBvbmVkZWxqZWtcIiwgXCJUb3Jla1wiLCBcIlNyZWRhXCIsIFwixIxldHJ0ZWtcIiwgXCJQZXRla1wiLCBcIlNvYm90YVwiXSwgZGF5X3Nob3J0OiBbXCJOZWRcIiwgXCJQb25cIiwgXCJUb3JcIiwgXCJTcmVcIiwgXCLEjGV0XCIsIFwiUGV0XCIsIFwiU29iXCJdIH0sIGxhYmVsczogeyBuZXdfdGFzazogXCJOb3ZhIG5hbG9nYVwiLCBpY29uX3NhdmU6IFwiU2hyYW5pXCIsIGljb25fY2FuY2VsOiBcIlByZWtsacSNaVwiLCBpY29uX2RldGFpbHM6IFwiUG9kcm9ibm9zdGlcIiwgaWNvbl9lZGl0OiBcIlVyZWRpXCIsIGljb25fZGVsZXRlOiBcIkl6YnJpxaFpXCIsIGNvbmZpcm1fY2xvc2luZzogXCJcIiwgY29uZmlybV9kZWxldGluZzogXCJEb2dvZGVrIGJvIGl6YnJpc2FuLiDFvWVsaXRlIG5hZGFsamV2YXRpP1wiLCBzZWN0aW9uX2Rlc2NyaXB0aW9uOiBcIk9waXNcIiwgc2VjdGlvbl90aW1lOiBcIsSMYXNvdm5pIG9rdmlyXCIsIHNlY3Rpb25fdHlwZTogXCJUeXBlXCIsIHNlY3Rpb25fZGVhZGxpbmU6IFwiRGVhZGxpbmVcIiwgc2VjdGlvbl9iYXNlbGluZXM6IFwiQmFzZWxpbmVzXCIsIGNvbHVtbl93YnM6IFwiV0JTXCIsIGNvbHVtbl90ZXh0OiBcIlRhc2sgbmFtZVwiLCBjb2x1bW5fc3RhcnRfZGF0ZTogXCJTdGFydCB0aW1lXCIsIGNvbHVtbl9kdXJhdGlvbjogXCJEdXJhdGlvblwiLCBjb2x1bW5fYWRkOiBcIlwiLCBsaW5rOiBcIkxpbmtcIiwgY29uZmlybV9saW5rX2RlbGV0aW5nOiBcIndpbGwgYmUgZGVsZXRlZFwiLCBsaW5rX3N0YXJ0OiBcIiAoc3RhcnQpXCIsIGxpbmtfZW5kOiBcIiAoZW5kKVwiLCB0eXBlX3Rhc2s6IFwiVGFza1wiLCB0eXBlX3Byb2plY3Q6IFwiUHJvamVjdFwiLCB0eXBlX21pbGVzdG9uZTogXCJNaWxlc3RvbmVcIiwgbWludXRlczogXCJNaW51dGVzXCIsIGhvdXJzOiBcIkhvdXJzXCIsIGRheXM6IFwiRGF5c1wiLCB3ZWVrczogXCJXZWVrXCIsIG1vbnRoczogXCJNb250aHNcIiwgeWVhcnM6IFwiWWVhcnNcIiwgbWVzc2FnZV9vazogXCJPS1wiLCBtZXNzYWdlX2NhbmNlbDogXCJQcmVrbGnEjWlcIiwgc2VjdGlvbl9jb25zdHJhaW50OiBcIkNvbnN0cmFpbnRcIiwgY29uc3RyYWludF90eXBlOiBcIkNvbnN0cmFpbnQgdHlwZVwiLCBjb25zdHJhaW50X2RhdGU6IFwiQ29uc3RyYWludCBkYXRlXCIsIGFzYXA6IFwiQXMgU29vbiBBcyBQb3NzaWJsZVwiLCBhbGFwOiBcIkFzIExhdGUgQXMgUG9zc2libGVcIiwgc25ldDogXCJTdGFydCBObyBFYXJsaWVyIFRoYW5cIiwgc25sdDogXCJTdGFydCBObyBMYXRlciBUaGFuXCIsIGZuZXQ6IFwiRmluaXNoIE5vIEVhcmxpZXIgVGhhblwiLCBmbmx0OiBcIkZpbmlzaCBObyBMYXRlciBUaGFuXCIsIG1zbzogXCJNdXN0IFN0YXJ0IE9uXCIsIG1mbzogXCJNdXN0IEZpbmlzaCBPblwiLCByZXNvdXJjZXNfZmlsdGVyX3BsYWNlaG9sZGVyOiBcInR5cGUgdG8gZmlsdGVyXCIsIHJlc291cmNlc19maWx0ZXJfbGFiZWw6IFwiaGlkZSBlbXB0eVwiLCBlbXB0eV9zdGF0ZV90ZXh0X2xpbms6IFwiQ2xpY2sgaGVyZVwiLCBlbXB0eV9zdGF0ZV90ZXh0X2Rlc2NyaXB0aW9uOiBcInRvIGNyZWF0ZSB5b3VyIGZpcnN0IHRhc2tcIiwgYmFzZWxpbmVzX3NlY3Rpb25fcGxhY2Vob2xkZXI6IFwiU3RhcnQgYWRkaW5nIGEgbmV3IGJhc2VsaW5lXCIsIGJhc2VsaW5lc19hZGRfYnV0dG9uOiBcIkFkZCBCYXNlbGluZVwiLCBiYXNlbGluZXNfcmVtb3ZlX2J1dHRvbjogXCJSZW1vdmVcIiwgYmFzZWxpbmVzX3JlbW92ZV9hbGxfYnV0dG9uOiBcIlJlbW92ZSBBbGxcIiwgZGVhZGxpbmVfZW5hYmxlX2J1dHRvbjogXCJTZXRcIiwgZGVhZGxpbmVfZGlzYWJsZV9idXR0b246IFwiUmVtb3ZlXCIgfSB9LCB0YSA9IHsgZGF0ZTogeyBtb250aF9mdWxsOiBbXCJKYW51w6FyXCIsIFwiRmVicnXDoXJcIiwgXCJNYXJlY1wiLCBcIkFwcsOtbFwiLCBcIk3DoWpcIiwgXCJKw7puXCIsIFwiSsO6bFwiLCBcIkF1Z3VzdFwiLCBcIlNlcHRlbWJlclwiLCBcIk9rdMOzYmVyXCIsIFwiTm92ZW1iZXJcIiwgXCJEZWNlbWJlclwiXSwgbW9udGhfc2hvcnQ6IFtcIkphblwiLCBcIkZlYlwiLCBcIk1hclwiLCBcIkFwclwiLCBcIk3DoWpcIiwgXCJKw7puXCIsIFwiSsO6bFwiLCBcIkF1Z1wiLCBcIlNlcHRcIiwgXCJPa3RcIiwgXCJOb3ZcIiwgXCJEZWNcIl0sIGRheV9mdWxsOiBbXCJOZWRlxL5hXCIsIFwiUG9uZGVsb2tcIiwgXCJVdG9yb2tcIiwgXCJTdHJlZGFcIiwgXCLFoHR2cnRva1wiLCBcIlBpYXRva1wiLCBcIlNvYm90YVwiXSwgZGF5X3Nob3J0OiBbXCJOZVwiLCBcIlBvXCIsIFwiVXRcIiwgXCJTdFwiLCBcIsWgdFwiLCBcIlBpXCIsIFwiU29cIl0gfSwgbGFiZWxzOiB7IG5ld190YXNrOiBcIk5vdsOhIMO6bG9oYVwiLCBpY29uX3NhdmU6IFwiVWxvxb5pxaVcIiwgaWNvbl9jYW5jZWw6IFwiU3DDpMWlXCIsIGljb25fZGV0YWlsczogXCJEZXRhaWxcIiwgaWNvbl9lZGl0OiBcIkVkaXR1alwiLCBpY29uX2RlbGV0ZTogXCJabWF6YcWlXCIsIGNvbmZpcm1fY2xvc2luZzogXCJWYcWhZSB6bWVueSBuZWJ1ZMO6IHVsb8W+ZW7DqS4gU2t1dG/EjW5lP1wiLCBjb25maXJtX2RlbGV0aW5nOiBcIlVkYWxvc8WlIGJ1ZGUgbmF0cnZhbG8gdnltYXphbsOhLiBTa3V0b8SNbmU/XCIsIHNlY3Rpb25fZGVzY3JpcHRpb246IFwiUG96bsOhbWt5XCIsIHNlY3Rpb25fdGltZTogXCJEb2JhIHBsYXRub3N0aVwiLCBzZWN0aW9uX3R5cGU6IFwiVHlwZVwiLCBzZWN0aW9uX2RlYWRsaW5lOiBcIkRlYWRsaW5lXCIsIHNlY3Rpb25fYmFzZWxpbmVzOiBcIkJhc2VsaW5lc1wiLCBjb2x1bW5fd2JzOiBcIldCU1wiLCBjb2x1bW5fdGV4dDogXCJUYXNrIG5hbWVcIiwgY29sdW1uX3N0YXJ0X2RhdGU6IFwiU3RhcnQgdGltZVwiLCBjb2x1bW5fZHVyYXRpb246IFwiRHVyYXRpb25cIiwgY29sdW1uX2FkZDogXCJcIiwgbGluazogXCJMaW5rXCIsIGNvbmZpcm1fbGlua19kZWxldGluZzogXCJ3aWxsIGJlIGRlbGV0ZWRcIiwgbGlua19zdGFydDogXCIgKHN0YXJ0KVwiLCBsaW5rX2VuZDogXCIgKGVuZClcIiwgdHlwZV90YXNrOiBcIlRhc2tcIiwgdHlwZV9wcm9qZWN0OiBcIlByb2plY3RcIiwgdHlwZV9taWxlc3RvbmU6IFwiTWlsZXN0b25lXCIsIG1pbnV0ZXM6IFwiTWludXRlc1wiLCBob3VyczogXCJIb3Vyc1wiLCBkYXlzOiBcIkRheXNcIiwgd2Vla3M6IFwiV2Vla1wiLCBtb250aHM6IFwiTW9udGhzXCIsIHllYXJzOiBcIlllYXJzXCIsIG1lc3NhZ2Vfb2s6IFwiT0tcIiwgbWVzc2FnZV9jYW5jZWw6IFwiU3DDpMWlXCIsIHNlY3Rpb25fY29uc3RyYWludDogXCJDb25zdHJhaW50XCIsIGNvbnN0cmFpbnRfdHlwZTogXCJDb25zdHJhaW50IHR5cGVcIiwgY29uc3RyYWludF9kYXRlOiBcIkNvbnN0cmFpbnQgZGF0ZVwiLCBhc2FwOiBcIkFzIFNvb24gQXMgUG9zc2libGVcIiwgYWxhcDogXCJBcyBMYXRlIEFzIFBvc3NpYmxlXCIsIHNuZXQ6IFwiU3RhcnQgTm8gRWFybGllciBUaGFuXCIsIHNubHQ6IFwiU3RhcnQgTm8gTGF0ZXIgVGhhblwiLCBmbmV0OiBcIkZpbmlzaCBObyBFYXJsaWVyIFRoYW5cIiwgZm5sdDogXCJGaW5pc2ggTm8gTGF0ZXIgVGhhblwiLCBtc286IFwiTXVzdCBTdGFydCBPblwiLCBtZm86IFwiTXVzdCBGaW5pc2ggT25cIiwgcmVzb3VyY2VzX2ZpbHRlcl9wbGFjZWhvbGRlcjogXCJ0eXBlIHRvIGZpbHRlclwiLCByZXNvdXJjZXNfZmlsdGVyX2xhYmVsOiBcImhpZGUgZW1wdHlcIiwgZW1wdHlfc3RhdGVfdGV4dF9saW5rOiBcIkNsaWNrIGhlcmVcIiwgZW1wdHlfc3RhdGVfdGV4dF9kZXNjcmlwdGlvbjogXCJ0byBjcmVhdGUgeW91ciBmaXJzdCB0YXNrXCIsIGJhc2VsaW5lc19zZWN0aW9uX3BsYWNlaG9sZGVyOiBcIlN0YXJ0IGFkZGluZyBhIG5ldyBiYXNlbGluZVwiLCBiYXNlbGluZXNfYWRkX2J1dHRvbjogXCJBZGQgQmFzZWxpbmVcIiwgYmFzZWxpbmVzX3JlbW92ZV9idXR0b246IFwiUmVtb3ZlXCIsIGJhc2VsaW5lc19yZW1vdmVfYWxsX2J1dHRvbjogXCJSZW1vdmUgQWxsXCIsIGRlYWRsaW5lX2VuYWJsZV9idXR0b246IFwiU2V0XCIsIGRlYWRsaW5lX2Rpc2FibGVfYnV0dG9uOiBcIlJlbW92ZVwiIH0gfSwgZWEgPSB7IGRhdGU6IHsgbW9udGhfZnVsbDogW1wiSmFudWFyaVwiLCBcIkZlYnJ1YXJpXCIsIFwiTWFyc1wiLCBcIkFwcmlsXCIsIFwiTWFqXCIsIFwiSnVuaVwiLCBcIkp1bGlcIiwgXCJBdWd1c3RpXCIsIFwiU2VwdGVtYmVyXCIsIFwiT2t0b2JlclwiLCBcIk5vdmVtYmVyXCIsIFwiRGVjZW1iZXJcIl0sIG1vbnRoX3Nob3J0OiBbXCJKYW5cIiwgXCJGZWJcIiwgXCJNYXJcIiwgXCJBcHJcIiwgXCJNYWpcIiwgXCJKdW5cIiwgXCJKdWxcIiwgXCJBdWdcIiwgXCJTZXBcIiwgXCJPa3RcIiwgXCJOb3ZcIiwgXCJEZWNcIl0sIGRheV9mdWxsOiBbXCJTw7ZuZGFnXCIsIFwiTcOlbmRhZ1wiLCBcIlRpc2RhZ1wiLCBcIk9uc2RhZ1wiLCBcIlRvcnNkYWdcIiwgXCJGcmVkYWdcIiwgXCJMw7ZyZGFnXCJdLCBkYXlfc2hvcnQ6IFtcIlPDtm5cIiwgXCJNw6VuXCIsIFwiVGlzXCIsIFwiT25zXCIsIFwiVG9yXCIsIFwiRnJlXCIsIFwiTMO2clwiXSB9LCBsYWJlbHM6IHsgbmV3X3Rhc2s6IFwiTnkgdXBwZ2lmdFwiLCBpY29uX3NhdmU6IFwiU3BhcmFcIiwgaWNvbl9jYW5jZWw6IFwiQXZicnl0XCIsIGljb25fZGV0YWlsczogXCJEZXRhamVyXCIsIGljb25fZWRpdDogXCLDhG5kcmFcIiwgaWNvbl9kZWxldGU6IFwiVGEgYm9ydFwiLCBjb25maXJtX2Nsb3Npbmc6IFwiXCIsIGNvbmZpcm1fZGVsZXRpbmc6IFwiw4RyIGR1IHPDpGtlciBww6UgYXR0IGR1IHZpbGwgdGEgYm9ydCBow6RuZGVsc2VuIHBlcm1hbmVudD9cIiwgc2VjdGlvbl9kZXNjcmlwdGlvbjogXCJCZXNrcml2bmluZ1wiLCBzZWN0aW9uX3RpbWU6IFwiVGlkXCIsIHNlY3Rpb25fdHlwZTogXCJUeXBcIiwgc2VjdGlvbl9kZWFkbGluZTogXCJEZWFkbGluZVwiLCBzZWN0aW9uX2Jhc2VsaW5lczogXCJCYXNlbGluZXNcIiwgY29sdW1uX3diczogXCJXQlNcIiwgY29sdW1uX3RleHQ6IFwiVXBwZ2lmdHNuYW1uXCIsIGNvbHVtbl9zdGFydF9kYXRlOiBcIlN0YXJ0dGlkXCIsIGNvbHVtbl9kdXJhdGlvbjogXCJWYXJha3RpZ2hldFwiLCBjb2x1bW5fYWRkOiBcIlwiLCBsaW5rOiBcIkzDpG5rXCIsIGNvbmZpcm1fbGlua19kZWxldGluZzogXCJrb21tZXIgdGFzIGJvcnRcIiwgbGlua19zdGFydDogXCIgKHN0YXJ0KVwiLCBsaW5rX2VuZDogXCIgKHNsdXQpXCIsIHR5cGVfdGFzazogXCJVcHBnaWZ0XCIsIHR5cGVfcHJvamVjdDogXCJQcm9qZWt0XCIsIHR5cGVfbWlsZXN0b25lOiBcIk1pbHN0b2xwZVwiLCBtaW51dGVzOiBcIk1pbnV0ZXJcIiwgaG91cnM6IFwiVGltbWFyXCIsIGRheXM6IFwiRGFnYXJcIiwgd2Vla3M6IFwiVmVja29yXCIsIG1vbnRoczogXCJNw6VuYWRlclwiLCB5ZWFyczogXCLDhXJcIiwgbWVzc2FnZV9vazogXCJPS1wiLCBtZXNzYWdlX2NhbmNlbDogXCJBdmJyeXRcIiwgc2VjdGlvbl9jb25zdHJhaW50OiBcIkNvbnN0cmFpbnRcIiwgY29uc3RyYWludF90eXBlOiBcIkNvbnN0cmFpbnQgdHlwZVwiLCBjb25zdHJhaW50X2RhdGU6IFwiQ29uc3RyYWludCBkYXRlXCIsIGFzYXA6IFwiQXMgU29vbiBBcyBQb3NzaWJsZVwiLCBhbGFwOiBcIkFzIExhdGUgQXMgUG9zc2libGVcIiwgc25ldDogXCJTdGFydCBObyBFYXJsaWVyIFRoYW5cIiwgc25sdDogXCJTdGFydCBObyBMYXRlciBUaGFuXCIsIGZuZXQ6IFwiRmluaXNoIE5vIEVhcmxpZXIgVGhhblwiLCBmbmx0OiBcIkZpbmlzaCBObyBMYXRlciBUaGFuXCIsIG1zbzogXCJNdXN0IFN0YXJ0IE9uXCIsIG1mbzogXCJNdXN0IEZpbmlzaCBPblwiLCByZXNvdXJjZXNfZmlsdGVyX3BsYWNlaG9sZGVyOiBcInR5cGUgdG8gZmlsdGVyXCIsIHJlc291cmNlc19maWx0ZXJfbGFiZWw6IFwiaGlkZSBlbXB0eVwiLCBlbXB0eV9zdGF0ZV90ZXh0X2xpbms6IFwiQ2xpY2sgaGVyZVwiLCBlbXB0eV9zdGF0ZV90ZXh0X2Rlc2NyaXB0aW9uOiBcInRvIGNyZWF0ZSB5b3VyIGZpcnN0IHRhc2tcIiwgYmFzZWxpbmVzX3NlY3Rpb25fcGxhY2Vob2xkZXI6IFwiU3RhcnQgYWRkaW5nIGEgbmV3IGJhc2VsaW5lXCIsIGJhc2VsaW5lc19hZGRfYnV0dG9uOiBcIkFkZCBCYXNlbGluZVwiLCBiYXNlbGluZXNfcmVtb3ZlX2J1dHRvbjogXCJSZW1vdmVcIiwgYmFzZWxpbmVzX3JlbW92ZV9hbGxfYnV0dG9uOiBcIlJlbW92ZSBBbGxcIiwgZGVhZGxpbmVfZW5hYmxlX2J1dHRvbjogXCJTZXRcIiwgZGVhZGxpbmVfZGlzYWJsZV9idXR0b246IFwiUmVtb3ZlXCIgfSB9LCBuYSA9IHsgZGF0ZTogeyBtb250aF9mdWxsOiBbXCJPY2FrXCIsIFwixZ51YmF0XCIsIFwiTWFydFwiLCBcIk5pc2FuXCIsIFwiTWF5xLFzXCIsIFwiSGF6aXJhblwiLCBcIlRlbW11elwiLCBcIkHEn3VzdG9zXCIsIFwiRXlsw7xsXCIsIFwiRWtpbVwiLCBcIkthc8SxbVwiLCBcIkFyYWzEsWtcIl0sIG1vbnRoX3Nob3J0OiBbXCJPY2FcIiwgXCLFnnViXCIsIFwiTWFyXCIsIFwiTmlzXCIsIFwiTWF5XCIsIFwiSGF6XCIsIFwiVGVtXCIsIFwiQcSfdVwiLCBcIkV5bFwiLCBcIkVraVwiLCBcIkthc1wiLCBcIkFyYVwiXSwgZGF5X2Z1bGw6IFtcIlBhemFyXCIsIFwiUGF6YXJ0ZXNpXCIsIFwiU2FsxLFcIiwgXCLDh2FyxZ9hbWJhXCIsIFwiUGVyxZ9lbWJlXCIsIFwiQ3VtYVwiLCBcIkN1bWFydGVzaVwiXSwgZGF5X3Nob3J0OiBbXCJQYXpcIiwgXCJQenRcIiwgXCJTYWxcIiwgXCLDh2FyXCIsIFwiUGVyXCIsIFwiQ3VtXCIsIFwiQ210XCJdIH0sIGxhYmVsczogeyBuZXdfdGFzazogXCJZZW5pIGfDtnJldlwiLCBpY29uX3NhdmU6IFwiS2F5ZGV0XCIsIGljb25fY2FuY2VsOiBcIsSwcHRhbFwiLCBpY29uX2RldGFpbHM6IFwiRGV0YXlsYXJcIiwgaWNvbl9lZGl0OiBcIkTDvHplbmxlXCIsIGljb25fZGVsZXRlOiBcIlNpbFwiLCBjb25maXJtX2Nsb3Npbmc6IFwiXCIsIGNvbmZpcm1fZGVsZXRpbmc6IFwiR8O2cmV2IHNpbGluZWNlaywgZW1pbiBtaXNpbml6P1wiLCBzZWN0aW9uX2Rlc2NyaXB0aW9uOiBcIkHDp8Sxa2xhbWFcIiwgc2VjdGlvbl90aW1lOiBcIlphbWFuIEFyYWzEscSfxLFcIiwgc2VjdGlvbl90eXBlOiBcIlRpcFwiLCBzZWN0aW9uX2RlYWRsaW5lOiBcIkRlYWRsaW5lXCIsIHNlY3Rpb25fYmFzZWxpbmVzOiBcIkJhc2VsaW5lc1wiLCBjb2x1bW5fd2JzOiBcIldCU1wiLCBjb2x1bW5fdGV4dDogXCJHw7ZyZXYgQWTEsVwiLCBjb2x1bW5fc3RhcnRfZGF0ZTogXCJCYcWfbGFuZ8Sxw6dcIiwgY29sdW1uX2R1cmF0aW9uOiBcIlPDvHJlXCIsIGNvbHVtbl9hZGQ6IFwiXCIsIGxpbms6IFwiQmHEn2xhbnTEsVwiLCBjb25maXJtX2xpbmtfZGVsZXRpbmc6IFwic2lsaW5lY2VrXCIsIGxpbmtfc3RhcnQ6IFwiIChiYcWfbGFuZ8Sxw6cpXCIsIGxpbmtfZW5kOiBcIiAoYml0acWfKVwiLCB0eXBlX3Rhc2s6IFwiR8O2cmV2XCIsIHR5cGVfcHJvamVjdDogXCJQcm9qZVwiLCB0eXBlX21pbGVzdG9uZTogXCJLaWxvbWV0cmV0YcWfxLFcIiwgbWludXRlczogXCJEYWtpa2FcIiwgaG91cnM6IFwiU2FhdFwiLCBkYXlzOiBcIkfDvG5cIiwgd2Vla3M6IFwiSGFmdGFcIiwgbW9udGhzOiBcIkF5XCIsIHllYXJzOiBcIlnEsWxcIiwgbWVzc2FnZV9vazogXCJPS1wiLCBtZXNzYWdlX2NhbmNlbDogXCLDnXB0YWxcIiwgc2VjdGlvbl9jb25zdHJhaW50OiBcIkNvbnN0cmFpbnRcIiwgY29uc3RyYWludF90eXBlOiBcIkNvbnN0cmFpbnQgdHlwZVwiLCBjb25zdHJhaW50X2RhdGU6IFwiQ29uc3RyYWludCBkYXRlXCIsIGFzYXA6IFwiQXMgU29vbiBBcyBQb3NzaWJsZVwiLCBhbGFwOiBcIkFzIExhdGUgQXMgUG9zc2libGVcIiwgc25ldDogXCJTdGFydCBObyBFYXJsaWVyIFRoYW5cIiwgc25sdDogXCJTdGFydCBObyBMYXRlciBUaGFuXCIsIGZuZXQ6IFwiRmluaXNoIE5vIEVhcmxpZXIgVGhhblwiLCBmbmx0OiBcIkZpbmlzaCBObyBMYXRlciBUaGFuXCIsIG1zbzogXCJNdXN0IFN0YXJ0IE9uXCIsIG1mbzogXCJNdXN0IEZpbmlzaCBPblwiLCByZXNvdXJjZXNfZmlsdGVyX3BsYWNlaG9sZGVyOiBcInR5cGUgdG8gZmlsdGVyXCIsIHJlc291cmNlc19maWx0ZXJfbGFiZWw6IFwiaGlkZSBlbXB0eVwiLCBlbXB0eV9zdGF0ZV90ZXh0X2xpbms6IFwiQ2xpY2sgaGVyZVwiLCBlbXB0eV9zdGF0ZV90ZXh0X2Rlc2NyaXB0aW9uOiBcInRvIGNyZWF0ZSB5b3VyIGZpcnN0IHRhc2tcIiwgYmFzZWxpbmVzX3NlY3Rpb25fcGxhY2Vob2xkZXI6IFwiU3RhcnQgYWRkaW5nIGEgbmV3IGJhc2VsaW5lXCIsIGJhc2VsaW5lc19hZGRfYnV0dG9uOiBcIkFkZCBCYXNlbGluZVwiLCBiYXNlbGluZXNfcmVtb3ZlX2J1dHRvbjogXCJSZW1vdmVcIiwgYmFzZWxpbmVzX3JlbW92ZV9hbGxfYnV0dG9uOiBcIlJlbW92ZSBBbGxcIiwgZGVhZGxpbmVfZW5hYmxlX2J1dHRvbjogXCJTZXRcIiwgZGVhZGxpbmVfZGlzYWJsZV9idXR0b246IFwiUmVtb3ZlXCIgfSB9LCBpYSA9IHsgZGF0ZTogeyBtb250aF9mdWxsOiBbXCLQodGW0YfQtdC90YxcIiwgXCLQm9GO0YLQuNC5XCIsIFwi0JHQtdGA0LXQt9C10L3RjFwiLCBcItCa0LLRltGC0LXQvdGMXCIsIFwi0KLRgNCw0LLQtdC90YxcIiwgXCLQp9C10YDQstC10L3RjFwiLCBcItCb0LjQv9C10L3RjFwiLCBcItCh0LXRgNC/0LXQvdGMXCIsIFwi0JLQtdGA0LXRgdC10L3RjFwiLCBcItCW0L7QstGC0LXQvdGMXCIsIFwi0JvQuNGB0YLQvtC/0LDQtFwiLCBcItCT0YDRg9C00LXQvdGMXCJdLCBtb250aF9zaG9ydDogW1wi0KHRltGHXCIsIFwi0JvRjtGCXCIsIFwi0JHQtdGAXCIsIFwi0JrQstGWXCIsIFwi0KLRgNCwXCIsIFwi0KfQtdGAXCIsIFwi0JvQuNC/XCIsIFwi0KHQtdGAXCIsIFwi0JLQtdGAXCIsIFwi0JbQvtCyXCIsIFwi0JvQuNGBXCIsIFwi0JPRgNGDXCJdLCBkYXlfZnVsbDogW1wi0J3QtdC00ZbQu9GPXCIsIFwi0J/QvtC90LXQtNGW0LvQvtC6XCIsIFwi0JLRltCy0YLQvtGA0L7QulwiLCBcItCh0LXRgNC10LTQsFwiLCBcItCn0LXRgtCy0LXRgFwiLCBcItCfJ9GP0YLQvdC40YbRj1wiLCBcItCh0YPQsdC+0YLQsFwiXSwgZGF5X3Nob3J0OiBbXCLQndC10LRcIiwgXCLQn9C+0L1cIiwgXCLQktGW0LJcIiwgXCLQodC10YBcIiwgXCLQp9C10YJcIiwgXCLQn9GC0L1cIiwgXCLQodGD0LFcIl0gfSwgbGFiZWxzOiB7IG5ld190YXNrOiBcItCd0L7QstC1INC30LDQstC00LDQvdC90Y9cIiwgaWNvbl9zYXZlOiBcItCX0LHQtdGA0LXQs9GC0LhcIiwgaWNvbl9jYW5jZWw6IFwi0JLRltC00LzRltC90LBcIiwgaWNvbl9kZXRhaWxzOiBcItCU0LXRgtCw0LvRllwiLCBpY29uX2VkaXQ6IFwi0KDQtdC00LDQs9GD0LLQsNGC0LhcIiwgaWNvbl9kZWxldGU6IFwi0JLQuNC70YPRh9C40YLQuFwiLCBjb25maXJtX2Nsb3Npbmc6IFwiXCIsIGNvbmZpcm1fZGVsZXRpbmc6IFwi0J/QvtC00ZbRjyDQstC40LvRg9GH0LjRgtGM0YHRjyDQvdCw0LfQsNCy0LbQtNC4LiDQktC4INCy0L/QtdCy0L3QtdC90ZY/XCIsIHNlY3Rpb25fZGVzY3JpcHRpb246IFwi0J7Qv9C40YFcIiwgc2VjdGlvbl90aW1lOiBcItCn0LDRgdC+0LLQuNC5INC/0YDQvtC80ZbQttC+0LpcIiwgc2VjdGlvbl90eXBlOiBcItCi0LjQv1wiLCBzZWN0aW9uX2RlYWRsaW5lOiBcIkRlYWRsaW5lXCIsIHNlY3Rpb25fYmFzZWxpbmVzOiBcIkJhc2VsaW5lc1wiLCBjb2x1bW5fd2JzOiBcIldCU1wiLCBjb2x1bW5fdGV4dDogXCJUYXNrIG5hbWVcIiwgY29sdW1uX3N0YXJ0X2RhdGU6IFwiU3RhcnQgdGltZVwiLCBjb2x1bW5fZHVyYXRpb246IFwiRHVyYXRpb25cIiwgY29sdW1uX2FkZDogXCJcIiwgbGluazogXCJMaW5rXCIsIGNvbmZpcm1fbGlua19kZWxldGluZzogXCJ3aWxsIGJlIGRlbGV0ZWRcIiwgbGlua19zdGFydDogXCIgKHN0YXJ0KVwiLCBsaW5rX2VuZDogXCIgKGVuZClcIiwgdHlwZV90YXNrOiBcIlRhc2tcIiwgdHlwZV9wcm9qZWN0OiBcIlByb2plY3RcIiwgdHlwZV9taWxlc3RvbmU6IFwiTWlsZXN0b25lXCIsIG1pbnV0ZXM6IFwiTWludXRlc1wiLCBob3VyczogXCJIb3Vyc1wiLCBkYXlzOiBcIkRheXNcIiwgd2Vla3M6IFwiV2Vla1wiLCBtb250aHM6IFwiTW9udGhzXCIsIHllYXJzOiBcIlllYXJzXCIsIG1lc3NhZ2Vfb2s6IFwiT0tcIiwgbWVzc2FnZV9jYW5jZWw6IFwi0JLRltC00LzRltC90LBcIiwgc2VjdGlvbl9jb25zdHJhaW50OiBcIkNvbnN0cmFpbnRcIiwgY29uc3RyYWludF90eXBlOiBcIkNvbnN0cmFpbnQgdHlwZVwiLCBjb25zdHJhaW50X2RhdGU6IFwiQ29uc3RyYWludCBkYXRlXCIsIGFzYXA6IFwiQXMgU29vbiBBcyBQb3NzaWJsZVwiLCBhbGFwOiBcIkFzIExhdGUgQXMgUG9zc2libGVcIiwgc25ldDogXCJTdGFydCBObyBFYXJsaWVyIFRoYW5cIiwgc25sdDogXCJTdGFydCBObyBMYXRlciBUaGFuXCIsIGZuZXQ6IFwiRmluaXNoIE5vIEVhcmxpZXIgVGhhblwiLCBmbmx0OiBcIkZpbmlzaCBObyBMYXRlciBUaGFuXCIsIG1zbzogXCJNdXN0IFN0YXJ0IE9uXCIsIG1mbzogXCJNdXN0IEZpbmlzaCBPblwiLCByZXNvdXJjZXNfZmlsdGVyX3BsYWNlaG9sZGVyOiBcInR5cGUgdG8gZmlsdGVyXCIsIHJlc291cmNlc19maWx0ZXJfbGFiZWw6IFwiaGlkZSBlbXB0eVwiLCBlbXB0eV9zdGF0ZV90ZXh0X2xpbms6IFwiQ2xpY2sgaGVyZVwiLCBlbXB0eV9zdGF0ZV90ZXh0X2Rlc2NyaXB0aW9uOiBcInRvIGNyZWF0ZSB5b3VyIGZpcnN0IHRhc2tcIiwgYmFzZWxpbmVzX3NlY3Rpb25fcGxhY2Vob2xkZXI6IFwiU3RhcnQgYWRkaW5nIGEgbmV3IGJhc2VsaW5lXCIsIGJhc2VsaW5lc19hZGRfYnV0dG9uOiBcIkFkZCBCYXNlbGluZVwiLCBiYXNlbGluZXNfcmVtb3ZlX2J1dHRvbjogXCJSZW1vdmVcIiwgYmFzZWxpbmVzX3JlbW92ZV9hbGxfYnV0dG9uOiBcIlJlbW92ZSBBbGxcIiwgZGVhZGxpbmVfZW5hYmxlX2J1dHRvbjogXCJTZXRcIiwgZGVhZGxpbmVfZGlzYWJsZV9idXR0b246IFwiUmVtb3ZlXCIgfSB9O1xuZnVuY3Rpb24gYWEoKSB7XG4gIHRoaXMuY29uc3RhbnRzID0gVW4sIHRoaXMudmVyc2lvbiA9IFwiOS4wLjEwXCIsIHRoaXMubGljZW5zZSA9IFwiZ3BsXCIsIHRoaXMudGVtcGxhdGVzID0ge30sIHRoaXMuZXh0ID0ge30sIHRoaXMua2V5cyA9IHsgZWRpdF9zYXZlOiB0aGlzLmNvbnN0YW50cy5LRVlfQ09ERVMuRU5URVIsIGVkaXRfY2FuY2VsOiB0aGlzLmNvbnN0YW50cy5LRVlfQ09ERVMuRVNDIH07XG59XG5mdW5jdGlvbiByYSh0KSB7XG4gIHZhciBlID0gbmV3IGFhKCksIG4gPSBuZXcgcW4odCksIGkgPSB7fTtcbiAgZS5wbHVnaW5zID0gZnVuY3Rpb24obCkge1xuICAgIGZvciAodmFyIGQgaW4gbCkgaWYgKGxbZF0gJiYgIWlbZF0pIHtcbiAgICAgIHZhciBjID0gbi5nZXRFeHRlbnNpb24oZCk7XG4gICAgICBjICYmIChjKGUpLCBpW2RdID0gITApO1xuICAgIH1cbiAgICByZXR1cm4gaTtcbiAgfSwgZS4kc2VydmljZXMgPSAvKiBAX19QVVJFX18gKi8gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGwgPSB7fTtcbiAgICByZXR1cm4geyBzZXJ2aWNlczoge30sIHNldFNlcnZpY2U6IGZ1bmN0aW9uKGQsIGMpIHtcbiAgICAgIGxbZF0gPSBjO1xuICAgIH0sIGdldFNlcnZpY2U6IGZ1bmN0aW9uKGQpIHtcbiAgICAgIHJldHVybiBsW2RdID8gbFtkXSgpIDogbnVsbDtcbiAgICB9LCBkcm9wU2VydmljZTogZnVuY3Rpb24oZCkge1xuICAgICAgbFtkXSAmJiBkZWxldGUgbFtkXTtcbiAgICB9LCBkZXN0cnVjdG9yOiBmdW5jdGlvbigpIHtcbiAgICAgIGZvciAodmFyIGQgaW4gbCkgaWYgKGxbZF0pIHtcbiAgICAgICAgdmFyIGMgPSBsW2RdO1xuICAgICAgICBjICYmIGMuZGVzdHJ1Y3RvciAmJiBjLmRlc3RydWN0b3IoKTtcbiAgICAgIH1cbiAgICAgIGwgPSBudWxsO1xuICAgIH0gfTtcbiAgfSgpLCBlLmNvbmZpZyA9IHsgbGF5b3V0OiB7IGNzczogXCJnYW50dF9jb250YWluZXJcIiwgcm93czogW3sgY29sczogW3sgdmlldzogXCJncmlkXCIsIHNjcm9sbFg6IFwic2Nyb2xsSG9yXCIsIHNjcm9sbFk6IFwic2Nyb2xsVmVyXCIgfSwgeyByZXNpemVyOiAhMCwgd2lkdGg6IDEgfSwgeyB2aWV3OiBcInRpbWVsaW5lXCIsIHNjcm9sbFg6IFwic2Nyb2xsSG9yXCIsIHNjcm9sbFk6IFwic2Nyb2xsVmVyXCIgfSwgeyB2aWV3OiBcInNjcm9sbGJhclwiLCBpZDogXCJzY3JvbGxWZXJcIiB9XSB9LCB7IHZpZXc6IFwic2Nyb2xsYmFyXCIsIGlkOiBcInNjcm9sbEhvclwiLCBoZWlnaHQ6IDIwIH1dIH0sIGxpbmtzOiB7IGZpbmlzaF90b19zdGFydDogXCIwXCIsIHN0YXJ0X3RvX3N0YXJ0OiBcIjFcIiwgZmluaXNoX3RvX2ZpbmlzaDogXCIyXCIsIHN0YXJ0X3RvX2ZpbmlzaDogXCIzXCIgfSwgdHlwZXM6IHsgdGFzazogXCJ0YXNrXCIsIHByb2plY3Q6IFwicHJvamVjdFwiLCBtaWxlc3RvbmU6IFwibWlsZXN0b25lXCIgfSwgYXV0b190eXBlczogITEsIGR1cmF0aW9uX3VuaXQ6IFwiZGF5XCIsIHdvcmtfdGltZTogITEsIGNvcnJlY3Rfd29ya190aW1lOiAhMSwgc2tpcF9vZmZfdGltZTogITEsIGNhc2NhZGVfZGVsZXRlOiAhMCwgYXV0b3NpemU6ICExLCBhdXRvc2l6ZV9taW5fd2lkdGg6IDAsIGF1dG9zY3JvbGw6ICEwLCBhdXRvc2Nyb2xsX3NwZWVkOiAzMCwgZGVlcGNvcHlfb25fcGFyc2U6ICExLCBzaG93X2xpbmtzOiAhMCwgc2hvd190YXNrX2NlbGxzOiAhMCwgc3RhdGljX2JhY2tncm91bmQ6ICExLCBzdGF0aWNfYmFja2dyb3VuZF9jZWxsczogITAsIGJyYW5jaF9sb2FkaW5nOiAhMSwgYnJhbmNoX2xvYWRpbmdfcHJvcGVydHk6IFwiJGhhc19jaGlsZFwiLCBzaG93X2xvYWRpbmc6ICExLCBzaG93X2NoYXJ0OiAhMCwgc2hvd19ncmlkOiAhMCwgbWluX2R1cmF0aW9uOiAzNmU1LCBkYXRlX2Zvcm1hdDogXCIlZC0lbS0lWSAlSDolaVwiLCB4bWxfZGF0ZTogdm9pZCAwLCBzdGFydF9vbl9tb25kYXk6ICEwLCBzZXJ2ZXJfdXRjOiAhMSwgc2hvd19wcm9ncmVzczogITAsIGZpdF90YXNrczogITEsIHNlbGVjdF90YXNrOiAhMCwgc2Nyb2xsX29uX2NsaWNrOiAhMCwgc21hcnRfcmVuZGVyaW5nOiAhMCwgcHJlc2VydmVfc2Nyb2xsOiAhMCwgcmVhZG9ubHk6ICExLCBjb250YWluZXJfcmVzaXplX3RpbWVvdXQ6IDIwLCBkZWFkbGluZXM6ICEwLCBkYXRlX2dyaWQ6IFwiJVktJW0tJWRcIiwgZHJhZ19saW5rczogITAsIGRyYWdfcHJvZ3Jlc3M6ICEwLCBkcmFnX3Jlc2l6ZTogITAsIGRyYWdfcHJvamVjdDogITEsIGRyYWdfbW92ZTogITAsIGRyYWdfbW9kZTogeyByZXNpemU6IFwicmVzaXplXCIsIHByb2dyZXNzOiBcInByb2dyZXNzXCIsIG1vdmU6IFwibW92ZVwiLCBpZ25vcmU6IFwiaWdub3JlXCIgfSwgcm91bmRfZG5kX2RhdGVzOiAhMCwgbGlua193cmFwcGVyX3dpZHRoOiAyMCwgbGlua19hcnJvd19zaXplOiAxMiwgcm9vdF9pZDogMCwgYXV0b2ZpdDogITEsIGNvbHVtbnM6IFt7IG5hbWU6IFwidGV4dFwiLCB0cmVlOiAhMCwgd2lkdGg6IFwiKlwiLCByZXNpemU6ICEwIH0sIHsgbmFtZTogXCJzdGFydF9kYXRlXCIsIGFsaWduOiBcImNlbnRlclwiLCByZXNpemU6ICEwIH0sIHsgbmFtZTogXCJkdXJhdGlvblwiLCBhbGlnbjogXCJjZW50ZXJcIiB9LCB7IG5hbWU6IFwiYWRkXCIsIHdpZHRoOiA0NCB9XSwgc2NhbGVfb2Zmc2V0X21pbmltYWw6ICEwLCBpbmhlcml0X3NjYWxlX2NsYXNzOiAhMSwgc2NhbGVzOiBbeyB1bml0OiBcImRheVwiLCBzdGVwOiAxLCBkYXRlOiBcIiVkICVNXCIgfV0sIHRpbWVfc3RlcDogNjAsIGR1cmF0aW9uX3N0ZXA6IDEsIHRhc2tfZGF0ZTogXCIlZCAlRiAlWVwiLCB0aW1lX3BpY2tlcjogXCIlSDolaVwiLCB0YXNrX2F0dHJpYnV0ZTogXCJkYXRhLXRhc2staWRcIiwgbGlua19hdHRyaWJ1dGU6IFwiZGF0YS1saW5rLWlkXCIsIGxheWVyX2F0dHJpYnV0ZTogXCJkYXRhLWxheWVyXCIsIGJ1dHRvbnNfbGVmdDogW1wiZ2FudHRfc2F2ZV9idG5cIiwgXCJnYW50dF9jYW5jZWxfYnRuXCJdLCBfbWlncmF0ZV9idXR0b25zOiB7IGRoeF9zYXZlX2J0bjogXCJnYW50dF9zYXZlX2J0blwiLCBkaHhfY2FuY2VsX2J0bjogXCJnYW50dF9jYW5jZWxfYnRuXCIsIGRoeF9kZWxldGVfYnRuOiBcImdhbnR0X2RlbGV0ZV9idG5cIiB9LCBidXR0b25zX3JpZ2h0OiBbXCJnYW50dF9kZWxldGVfYnRuXCJdLCBsaWdodGJveDogeyBzZWN0aW9uczogW3sgbmFtZTogXCJkZXNjcmlwdGlvblwiLCBoZWlnaHQ6IDcwLCBtYXBfdG86IFwidGV4dFwiLCB0eXBlOiBcInRleHRhcmVhXCIsIGZvY3VzOiAhMCB9LCB7IG5hbWU6IFwidGltZVwiLCB0eXBlOiBcImR1cmF0aW9uXCIsIG1hcF90bzogXCJhdXRvXCIgfV0sIHByb2plY3Rfc2VjdGlvbnM6IFt7IG5hbWU6IFwiZGVzY3JpcHRpb25cIiwgaGVpZ2h0OiA3MCwgbWFwX3RvOiBcInRleHRcIiwgdHlwZTogXCJ0ZXh0YXJlYVwiLCBmb2N1czogITAgfSwgeyBuYW1lOiBcInR5cGVcIiwgdHlwZTogXCJ0eXBlc2VsZWN0XCIsIG1hcF90bzogXCJ0eXBlXCIgfSwgeyBuYW1lOiBcInRpbWVcIiwgdHlwZTogXCJkdXJhdGlvblwiLCByZWFkb25seTogITAsIG1hcF90bzogXCJhdXRvXCIgfV0sIG1pbGVzdG9uZV9zZWN0aW9uczogW3sgbmFtZTogXCJkZXNjcmlwdGlvblwiLCBoZWlnaHQ6IDcwLCBtYXBfdG86IFwidGV4dFwiLCB0eXBlOiBcInRleHRhcmVhXCIsIGZvY3VzOiAhMCB9LCB7IG5hbWU6IFwidHlwZVwiLCB0eXBlOiBcInR5cGVzZWxlY3RcIiwgbWFwX3RvOiBcInR5cGVcIiB9LCB7IG5hbWU6IFwidGltZVwiLCB0eXBlOiBcImR1cmF0aW9uXCIsIHNpbmdsZV9kYXRlOiAhMCwgbWFwX3RvOiBcImF1dG9cIiB9XSB9LCBkcmFnX2xpZ2h0Ym94OiAhMCwgc29ydDogITEsIGRldGFpbHNfb25fY3JlYXRlOiAhMCwgZGV0YWlsc19vbl9kYmxjbGljazogITAsIGluaXRpYWxfc2Nyb2xsOiAhMCwgdGFza19zY3JvbGxfb2Zmc2V0OiAxMDAsIG9yZGVyX2JyYW5jaDogITEsIG9yZGVyX2JyYW5jaF9mcmVlOiAhMSwgdGFza19oZWlnaHQ6IHZvaWQgMCwgYmFyX2hlaWdodDogXCJmdWxsXCIsIGJhcl9oZWlnaHRfcGFkZGluZzogOSwgbWluX2NvbHVtbl93aWR0aDogNzAsIG1pbl9ncmlkX2NvbHVtbl93aWR0aDogNzAsIGdyaWRfcmVzaXplcl9jb2x1bW5fYXR0cmlidXRlOiBcImRhdGEtY29sdW1uLWluZGV4XCIsIGtlZXBfZ3JpZF93aWR0aDogITEsIGdyaWRfcmVzaXplOiAhMSwgZ3JpZF9lbGFzdGljX2NvbHVtbnM6ICExLCBzaG93X3Rhc2tzX291dHNpZGVfdGltZXNjYWxlOiAhMSwgc2hvd191bnNjaGVkdWxlZDogITAsIHJlc2l6ZV9yb3dzOiAhMSwgdGFza19ncmlkX3Jvd19yZXNpemVyX2F0dHJpYnV0ZTogXCJkYXRhLXJvdy1pbmRleFwiLCBtaW5fdGFza19ncmlkX3Jvd19oZWlnaHQ6IDMwLCByb3dfaGVpZ2h0OiAzNiwgcmVhZG9ubHlfcHJvcGVydHk6IFwicmVhZG9ubHlcIiwgZWRpdGFibGVfcHJvcGVydHk6IFwiZWRpdGFibGVcIiwgY2FsZW5kYXJfcHJvcGVydHk6IFwiY2FsZW5kYXJfaWRcIiwgcmVzb3VyY2VfY2FsZW5kYXJzOiB7fSwgZHluYW1pY19yZXNvdXJjZV9jYWxlbmRhcnM6ICExLCBpbmhlcml0X2NhbGVuZGFyOiAhMSwgdHlwZV9yZW5kZXJlcnM6IHt9LCBvcGVuX3RyZWVfaW5pdGlhbGx5OiAhMSwgb3B0aW1pemVfcmVuZGVyOiAhMCwgcHJldmVudF9kZWZhdWx0X3Njcm9sbDogITEsIHNob3dfZXJyb3JzOiAhMCwgd2FpX2FyaWFfYXR0cmlidXRlczogITAsIHNtYXJ0X3NjYWxlczogITAsIHJ0bDogITEsIHBsYWNlaG9sZGVyX3Rhc2s6ICExLCBob3Jpem9udGFsX3Njcm9sbF9rZXk6IFwic2hpZnRLZXlcIiwgZHJhZ190aW1lbGluZTogeyB1c2VLZXk6IHZvaWQgMCwgaWdub3JlOiBcIi5nYW50dF90YXNrX2xpbmUsIC5nYW50dF90YXNrX2xpbmtcIiwgcmVuZGVyOiAhMSB9LCBkcmFnX211bHRpcGxlOiAhMCwgY3NwOiBcImF1dG9cIiB9LCBlLmFqYXggPSAvKiBAX19QVVJFX18gKi8gZnVuY3Rpb24obCkge1xuICAgIHJldHVybiB7IGNhY2hlOiAhMCwgbWV0aG9kOiBcImdldFwiLCBwYXJzZTogZnVuY3Rpb24oZCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiBkICE9IFwic3RyaW5nXCIgPyBkIDogKGQgPSBkLnJlcGxhY2UoL15bXFxzXSsvLCBcIlwiKSwgdHlwZW9mIERPTVBhcnNlciA+IFwidVwiIHx8IG10LmlzSUUgPyBkdC5BY3RpdmVYT2JqZWN0ICE9PSB2b2lkIDAgJiYgKChjID0gbmV3IGR0LkFjdGl2ZVhPYmplY3QoXCJNaWNyb3NvZnQuWE1MRE9NXCIpKS5hc3luYyA9IFwiZmFsc2VcIiwgYy5sb2FkWE1MKGQpKSA6IGMgPSBuZXcgRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKGQsIFwidGV4dC94bWxcIiksIGMpO1xuICAgICAgdmFyIGM7XG4gICAgfSwgeG1sdG9wOiBmdW5jdGlvbihkLCBjLCB1KSB7XG4gICAgICBpZiAoYy5zdGF0dXMgPT09IHZvaWQgMCB8fCBjLnN0YXR1cyA8IDQwMCkge1xuICAgICAgICB2YXIgaCA9IGMucmVzcG9uc2VYTUwgPyBjLnJlc3BvbnNlWE1MIHx8IGMgOiB0aGlzLnBhcnNlKGMucmVzcG9uc2VUZXh0IHx8IGMpO1xuICAgICAgICBpZiAoaCAmJiBoLmRvY3VtZW50RWxlbWVudCAhPT0gbnVsbCAmJiAhaC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInBhcnNlcmVycm9yXCIpLmxlbmd0aCkgcmV0dXJuIGguZ2V0RWxlbWVudHNCeVRhZ05hbWUoZClbMF07XG4gICAgICB9XG4gICAgICByZXR1cm4gdSAhPT0gLTEgJiYgbC5jYWxsRXZlbnQoXCJvbkxvYWRYTUxFcnJvclwiLCBbXCJJbmNvcnJlY3QgWE1MXCIsIGFyZ3VtZW50c1sxXSwgdV0pLCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiRElWXCIpO1xuICAgIH0sIHhwYXRoOiBmdW5jdGlvbihkLCBjKSB7XG4gICAgICBpZiAoYy5ub2RlTmFtZSB8fCAoYyA9IGMucmVzcG9uc2VYTUwgfHwgYyksIG10LmlzSUUpIHJldHVybiBjLnNlbGVjdE5vZGVzKGQpIHx8IFtdO1xuICAgICAgZm9yICh2YXIgdSwgaCA9IFtdLCBnID0gKGMub3duZXJEb2N1bWVudCB8fCBjKS5ldmFsdWF0ZShkLCBjLCBudWxsLCBYUGF0aFJlc3VsdC5BTllfVFlQRSwgbnVsbCk7IHUgPSBnLml0ZXJhdGVOZXh0KCk7ICkgaC5wdXNoKHUpO1xuICAgICAgcmV0dXJuIGg7XG4gICAgfSwgcXVlcnk6IGZ1bmN0aW9uKGQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jYWxsKGQubWV0aG9kIHx8IFwiR0VUXCIsIGQudXJsLCBkLmRhdGEgfHwgXCJcIiwgZC5hc3luYyB8fCAhMCwgZC5jYWxsYmFjaywgZC5oZWFkZXJzKTtcbiAgICB9LCBnZXQ6IGZ1bmN0aW9uKGQsIGMsIHUpIHtcbiAgICAgIHZhciBoID0geHQoXCJHRVRcIiwgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiB0aGlzLnF1ZXJ5KGgpO1xuICAgIH0sIGdldFN5bmM6IGZ1bmN0aW9uKGQsIGMpIHtcbiAgICAgIHZhciB1ID0geHQoXCJHRVRcIiwgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiB1LmFzeW5jID0gITEsIHRoaXMucXVlcnkodSk7XG4gICAgfSwgcHV0OiBmdW5jdGlvbihkLCBjLCB1LCBoKSB7XG4gICAgICB2YXIgZyA9IHh0KFwiUFVUXCIsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gdGhpcy5xdWVyeShnKTtcbiAgICB9LCBkZWw6IGZ1bmN0aW9uKGQsIGMsIHUpIHtcbiAgICAgIHZhciBoID0geHQoXCJERUxFVEVcIiwgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiB0aGlzLnF1ZXJ5KGgpO1xuICAgIH0sIHBvc3Q6IGZ1bmN0aW9uKGQsIGMsIHUsIGgpIHtcbiAgICAgIGFyZ3VtZW50cy5sZW5ndGggPT0gMSA/IGMgPSBcIlwiIDogYXJndW1lbnRzLmxlbmd0aCA9PSAyICYmIHR5cGVvZiBjID09IFwiZnVuY3Rpb25cIiAmJiAodSA9IGMsIGMgPSBcIlwiKTtcbiAgICAgIHZhciBnID0geHQoXCJQT1NUXCIsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gdGhpcy5xdWVyeShnKTtcbiAgICB9LCBwb3N0U3luYzogZnVuY3Rpb24oZCwgYywgdSkge1xuICAgICAgYyA9IGMgPT09IG51bGwgPyBcIlwiIDogU3RyaW5nKGMpO1xuICAgICAgdmFyIGggPSB4dChcIlBPU1RcIiwgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBoLmFzeW5jID0gITEsIHRoaXMucXVlcnkoaCk7XG4gICAgfSwgX2NhbGw6IGZ1bmN0aW9uKGQsIGMsIHUsIGgsIGcsIHApIHtcbiAgICAgIHJldHVybiBuZXcgbC5Qcm9taXNlKGZ1bmN0aW9uKHksIHYpIHtcbiAgICAgICAgdmFyIGIgPSB0eXBlb2YgWE1MSHR0cFJlcXVlc3QgIT09IHZvaWQgMCA/IG5ldyBYTUxIdHRwUmVxdWVzdCgpIDogbmV3IGR0LkFjdGl2ZVhPYmplY3QoXCJNaWNyb3NvZnQuWE1MSFRUUFwiKSwgXyA9IG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL0FwcGxlV2ViS2l0LykgIT09IG51bGwgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvUXQvKSAhPT0gbnVsbCAmJiBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9TYWZhcmkvKSAhPT0gbnVsbDtcbiAgICAgICAgaCAmJiAoYi5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAoYi5yZWFkeVN0YXRlID09IDQgfHwgXyAmJiBiLnJlYWR5U3RhdGUgPT0gMykge1xuICAgICAgICAgICAgaWYgKChiLnN0YXR1cyAhPSAyMDAgfHwgYi5yZXNwb25zZVRleHQgPT09IFwiXCIpICYmICFsLmNhbGxFdmVudChcIm9uQWpheEVycm9yXCIsIFtiXSkpIHJldHVybjtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHR5cGVvZiBnID09IFwiZnVuY3Rpb25cIiAmJiBnLmFwcGx5KGR0LCBbeyB4bWxEb2M6IGIsIGZpbGVQYXRoOiBjIH1dKSwgeShiKSwgdHlwZW9mIGcgPT0gXCJmdW5jdGlvblwiICYmIChnID0gbnVsbCwgYiA9IG51bGwpO1xuICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIG0gPSAhdGhpcyB8fCAhdGhpcy5jYWNoZTtcbiAgICAgICAgaWYgKGQgPT0gXCJHRVRcIiAmJiBtICYmIChjICs9IChjLmluZGV4T2YoXCI/XCIpID49IDAgPyBcIiZcIiA6IFwiP1wiKSArIFwiZGh4clwiICsgKC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpKS5nZXRUaW1lKCkgKyBcIj0xXCIpLCBiLm9wZW4oZCwgYywgaCksIHApIGZvciAodmFyIGYgaW4gcCkgYi5zZXRSZXF1ZXN0SGVhZGVyKGYsIHBbZl0pO1xuICAgICAgICBlbHNlIGQudG9VcHBlckNhc2UoKSA9PSBcIlBPU1RcIiB8fCBkID09IFwiUFVUXCIgfHwgZCA9PSBcIkRFTEVURVwiID8gYi5zZXRSZXF1ZXN0SGVhZGVyKFwiQ29udGVudC1UeXBlXCIsIFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIpIDogZCA9PSBcIkdFVFwiICYmICh1ID0gbnVsbCk7XG4gICAgICAgIGlmIChiLnNldFJlcXVlc3RIZWFkZXIoXCJYLVJlcXVlc3RlZC1XaXRoXCIsIFwiWE1MSHR0cFJlcXVlc3RcIiksIGIuc2VuZCh1KSwgIWgpIHJldHVybiB7IHhtbERvYzogYiwgZmlsZVBhdGg6IGMgfTtcbiAgICAgIH0pO1xuICAgIH0sIHVybFNlcGFyYXRvcjogZnVuY3Rpb24oZCkge1xuICAgICAgcmV0dXJuIGQuaW5kZXhPZihcIj9cIikgIT0gLTEgPyBcIiZcIiA6IFwiP1wiO1xuICAgIH0gfTtcbiAgfShlKSwgZS5kYXRlID0gR24oZSksIGUuUmVtb3RlRXZlbnRzID0gSm47XG4gIHZhciBhID0gZnVuY3Rpb24obCkge1xuICAgIGZ1bmN0aW9uIGQodSkge1xuICAgICAgcmV0dXJuIHsgdGFyZ2V0OiB1LnRhcmdldCB8fCB1LnNyY0VsZW1lbnQsIHBhZ2VYOiB1LnBhZ2VYLCBwYWdlWTogdS5wYWdlWSwgY2xpZW50WDogdS5jbGllbnRYLCBjbGllbnRZOiB1LmNsaWVudFksIG1ldGFLZXk6IHUubWV0YUtleSwgc2hpZnRLZXk6IHUuc2hpZnRLZXksIGN0cmxLZXk6IHUuY3RybEtleSwgYWx0S2V5OiB1LmFsdEtleSB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjKHUsIGgpIHtcbiAgICAgIHRoaXMuX29iaiA9IHUsIHRoaXMuX3NldHRpbmdzID0gaCB8fCB7fSwgb3QodGhpcyk7XG4gICAgICB2YXIgZyA9IHRoaXMuZ2V0SW5wdXRNZXRob2RzKCk7XG4gICAgICB0aGlzLl9kcmFnX3N0YXJ0X3RpbWVyID0gbnVsbCwgbC5hdHRhY2hFdmVudChcIm9uR2FudHRTY3JvbGxcIiwgUihmdW5jdGlvbih2LCBiKSB7XG4gICAgICAgIHRoaXMuY2xlYXJEcmFnVGltZXIoKTtcbiAgICAgIH0sIHRoaXMpKTtcbiAgICAgIGZvciAodmFyIHAgPSB7IHBhc3NpdmU6ICExIH0sIHkgPSAwOyB5IDwgZy5sZW5ndGg7IHkrKykgUihmdW5jdGlvbih2KSB7XG4gICAgICAgIGwuZXZlbnQodSwgdi5kb3duLCBSKGZ1bmN0aW9uKF8pIHtcbiAgICAgICAgICB2LmFjY2Vzc29yKF8pICYmIChfLmJ1dHRvbiAhPT0gdm9pZCAwICYmIF8uYnV0dG9uICE9PSAwIHx8IChoLnByZXZlbnREZWZhdWx0ICYmIGguc2VsZWN0b3IgJiYgY3QoXy50YXJnZXQsIGguc2VsZWN0b3IpICYmIF8ucHJldmVudERlZmF1bHQoKSwgbC5jb25maWcudG91Y2ggJiYgXy50aW1lU3RhbXAgJiYgXy50aW1lU3RhbXAgLSAwIDwgMzAwIHx8ICh0aGlzLl9zZXR0aW5ncy5vcmlnaW5hbF90YXJnZXQgPSBkKF8pLCB0aGlzLl9zZXR0aW5ncy5vcmlnaW5hbF9lbGVtZW50X3NpemVzID0geyAuLi5ydChfLCBubih1KSksIHdpZHRoOiBfLnRhcmdldC5vZmZzZXRXaWR0aCwgaGVpZ2h0OiBfLnRhcmdldC5vZmZzZXRIZWlnaHQgfSwgbC5jb25maWcudG91Y2ggPyAodGhpcy5jbGVhckRyYWdUaW1lcigpLCB0aGlzLl9kcmFnX3N0YXJ0X3RpbWVyID0gc2V0VGltZW91dChSKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgbC5nZXRTdGF0ZSgpLmxpZ2h0Ym94IHx8IHRoaXMuZHJhZ1N0YXJ0KHUsIF8sIHYpO1xuICAgICAgICAgIH0sIHRoaXMpLCBsLmNvbmZpZy50b3VjaF9kcmFnKSkgOiB0aGlzLmRyYWdTdGFydCh1LCBfLCB2KSkpKTtcbiAgICAgICAgfSwgdGhpcyksIHApO1xuICAgICAgICB2YXIgYiA9IGRvY3VtZW50LmJvZHk7XG4gICAgICAgIGwuZXZlbnQoYiwgdi51cCwgUihmdW5jdGlvbihfKSB7XG4gICAgICAgICAgdi5hY2Nlc3NvcihfKSAmJiB0aGlzLmNsZWFyRHJhZ1RpbWVyKCk7XG4gICAgICAgIH0sIHRoaXMpLCBwKTtcbiAgICAgIH0sIHRoaXMpKGdbeV0pO1xuICAgIH1cbiAgICByZXR1cm4gYy5wcm90b3R5cGUgPSB7IHRyYWNlRHJhZ0V2ZW50czogZnVuY3Rpb24odSwgaCkge1xuICAgICAgdmFyIGcgPSBSKGZ1bmN0aW9uKG0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhZ01vdmUodSwgbSwgaC5hY2Nlc3Nvcik7XG4gICAgICB9LCB0aGlzKTtcbiAgICAgIFIoZnVuY3Rpb24obSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kcmFnU2Nyb2xsKHUsIG0pO1xuICAgICAgfSwgdGhpcyk7XG4gICAgICB2YXIgcCA9IFIoZnVuY3Rpb24obSkge1xuICAgICAgICBpZiAoIXRoaXMuY29uZmlnLnN0YXJ0ZWQgfHwgIVcodGhpcy5jb25maWcudXBkYXRlc19wZXJfc2Vjb25kKSB8fCBkbih0aGlzLCB0aGlzLmNvbmZpZy51cGRhdGVzX3Blcl9zZWNvbmQpKSB7XG4gICAgICAgICAgdmFyIGYgPSBnKG0pO1xuICAgICAgICAgIGlmIChmKSB0cnkge1xuICAgICAgICAgICAgbSAmJiBtLnByZXZlbnREZWZhdWx0ICYmIG0uY2FuY2VsYWJsZSAmJiBtLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmO1xuICAgICAgICB9XG4gICAgICB9LCB0aGlzKSwgeSA9IHZ0KGwuJHJvb3QpLCB2ID0gdGhpcy5jb25maWcubW91c2Vtb3ZlQ29udGFpbmVyIHx8IHZ0KGwuJHJvb3QpLCBiID0geyBwYXNzaXZlOiAhMSB9LCBfID0gUihmdW5jdGlvbihtKSB7XG4gICAgICAgIHJldHVybiBsLmV2ZW50UmVtb3ZlKHYsIGgubW92ZSwgcCksIGwuZXZlbnRSZW1vdmUoeSwgaC51cCwgXywgYiksIHRoaXMuZHJhZ0VuZCh1KTtcbiAgICAgIH0sIHRoaXMpO1xuICAgICAgbC5ldmVudCh2LCBoLm1vdmUsIHAsIGIpLCBsLmV2ZW50KHksIGgudXAsIF8sIGIpO1xuICAgIH0sIGNoZWNrUG9zaXRpb25DaGFuZ2U6IGZ1bmN0aW9uKHUpIHtcbiAgICAgIHZhciBoID0gdS54IC0gdGhpcy5jb25maWcucG9zLngsIGcgPSB1LnkgLSB0aGlzLmNvbmZpZy5wb3MueTtcbiAgICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coTWF0aC5hYnMoaCksIDIpICsgTWF0aC5wb3coTWF0aC5hYnMoZyksIDIpKSA+IHRoaXMuY29uZmlnLnNlbnNpdGl2aXR5O1xuICAgIH0sIGluaXREbkRNYXJrZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHUgPSB0aGlzLmNvbmZpZy5tYXJrZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgdS5jbGFzc05hbWUgPSBcImdhbnR0X2RyYWdfbWFya2VyXCIsIHUuaW5uZXJIVE1MID0gXCJcIiwgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh1KTtcbiAgICB9LCBiYWNrdXBFdmVudFRhcmdldDogZnVuY3Rpb24odSwgaCkge1xuICAgICAgaWYgKGwuY29uZmlnLnRvdWNoKSB7XG4gICAgICAgIHZhciBnID0gaCh1KSwgcCA9IGcudGFyZ2V0IHx8IGcuc3JjRWxlbWVudCwgeSA9IHAuY2xvbmVOb2RlKCEwKTtcbiAgICAgICAgdGhpcy5jb25maWcub3JpZ2luYWxfdGFyZ2V0ID0gZChnKSwgdGhpcy5jb25maWcub3JpZ2luYWxfdGFyZ2V0LnRhcmdldCA9IHksIHRoaXMuY29uZmlnLmJhY2t1cF9lbGVtZW50ID0gcCwgcC5wYXJlbnROb2RlLmFwcGVuZENoaWxkKHkpLCBwLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIiwgKHRoaXMuY29uZmlnLm1vdXNlbW92ZUNvbnRhaW5lciB8fCBkb2N1bWVudC5ib2R5KS5hcHBlbmRDaGlsZChwKTtcbiAgICAgIH1cbiAgICB9LCBnZXRJbnB1dE1ldGhvZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHUgPSBbXTtcbiAgICAgIGlmICh1LnB1c2goeyBtb3ZlOiBcIm1vdXNlbW92ZVwiLCBkb3duOiBcIm1vdXNlZG93blwiLCB1cDogXCJtb3VzZXVwXCIsIGFjY2Vzc29yOiBmdW5jdGlvbihnKSB7XG4gICAgICAgIHJldHVybiBnO1xuICAgICAgfSB9KSwgbC5jb25maWcudG91Y2gpIHtcbiAgICAgICAgdmFyIGggPSAhMDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBkb2N1bWVudC5jcmVhdGVFdmVudChcIlRvdWNoRXZlbnRcIik7XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIGggPSAhMTtcbiAgICAgICAgfVxuICAgICAgICBoID8gdS5wdXNoKHsgbW92ZTogXCJ0b3VjaG1vdmVcIiwgZG93bjogXCJ0b3VjaHN0YXJ0XCIsIHVwOiBcInRvdWNoZW5kXCIsIGFjY2Vzc29yOiBmdW5jdGlvbihnKSB7XG4gICAgICAgICAgcmV0dXJuIGcudG91Y2hlcyAmJiBnLnRvdWNoZXMubGVuZ3RoID4gMSA/IG51bGwgOiBnLnRvdWNoZXNbMF0gPyB7IHRhcmdldDogZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChnLnRvdWNoZXNbMF0uY2xpZW50WCwgZy50b3VjaGVzWzBdLmNsaWVudFkpLCBwYWdlWDogZy50b3VjaGVzWzBdLnBhZ2VYLCBwYWdlWTogZy50b3VjaGVzWzBdLnBhZ2VZLCBjbGllbnRYOiBnLnRvdWNoZXNbMF0uY2xpZW50WCwgY2xpZW50WTogZy50b3VjaGVzWzBdLmNsaWVudFkgfSA6IGc7XG4gICAgICAgIH0gfSkgOiBkdC5uYXZpZ2F0b3IucG9pbnRlckVuYWJsZWQgPyB1LnB1c2goeyBtb3ZlOiBcInBvaW50ZXJtb3ZlXCIsIGRvd246IFwicG9pbnRlcmRvd25cIiwgdXA6IFwicG9pbnRlcnVwXCIsIGFjY2Vzc29yOiBmdW5jdGlvbihnKSB7XG4gICAgICAgICAgcmV0dXJuIGcucG9pbnRlclR5cGUgPT0gXCJtb3VzZVwiID8gbnVsbCA6IGc7XG4gICAgICAgIH0gfSkgOiBkdC5uYXZpZ2F0b3IubXNQb2ludGVyRW5hYmxlZCAmJiB1LnB1c2goeyBtb3ZlOiBcIk1TUG9pbnRlck1vdmVcIiwgZG93bjogXCJNU1BvaW50ZXJEb3duXCIsIHVwOiBcIk1TUG9pbnRlclVwXCIsIGFjY2Vzc29yOiBmdW5jdGlvbihnKSB7XG4gICAgICAgICAgcmV0dXJuIGcucG9pbnRlclR5cGUgPT0gZy5NU1BPSU5URVJfVFlQRV9NT1VTRSA/IG51bGwgOiBnO1xuICAgICAgICB9IH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHU7XG4gICAgfSwgY2xlYXJEcmFnVGltZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fZHJhZ19zdGFydF90aW1lciAmJiAoY2xlYXJUaW1lb3V0KHRoaXMuX2RyYWdfc3RhcnRfdGltZXIpLCB0aGlzLl9kcmFnX3N0YXJ0X3RpbWVyID0gbnVsbCk7XG4gICAgfSwgZHJhZ1N0YXJ0OiBmdW5jdGlvbih1LCBoLCBnKSB7XG4gICAgICB0aGlzLmNvbmZpZyAmJiB0aGlzLmNvbmZpZy5zdGFydGVkIHx8ICh0aGlzLmNvbmZpZyA9IHsgb2JqOiB1LCBtYXJrZXI6IG51bGwsIHN0YXJ0ZWQ6ICExLCBwb3M6IHRoaXMuZ2V0UG9zaXRpb24oaCksIHNlbnNpdGl2aXR5OiA0IH0sIHRoaXMuX3NldHRpbmdzICYmIFAodGhpcy5jb25maWcsIHRoaXMuX3NldHRpbmdzLCAhMCksIHRoaXMudHJhY2VEcmFnRXZlbnRzKHUsIGcpLCBsLl9wcmV2ZW50X3RvdWNoX3Njcm9sbCA9ICEwLCBoLnRhcmdldC5jbG9zZXN0KFwiLmdhbnR0X3Jvd1wiKSAmJiAhbC5jb25maWcub3JkZXJfYnJhbmNoICYmIChsLl9wcmV2ZW50X3RvdWNoX3Njcm9sbCA9ICExKSwgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKFwiZ2FudHRfbm9zZWxlY3RcIiksIGwuY29uZmlnLnRvdWNoICYmIHRoaXMuZHJhZ01vdmUodSwgaCwgZy5hY2Nlc3NvcikpO1xuICAgIH0sIGRyYWdNb3ZlOiBmdW5jdGlvbih1LCBoLCBnKSB7XG4gICAgICB2YXIgcCA9IGcoaCk7XG4gICAgICBpZiAoIXApIHJldHVybiAhMTtcbiAgICAgIGlmICghdGhpcy5jb25maWcubWFya2VyICYmICF0aGlzLmNvbmZpZy5zdGFydGVkKSB7XG4gICAgICAgIHZhciB5ID0gdGhpcy5nZXRQb3NpdGlvbihwKTtcbiAgICAgICAgaWYgKGwuY29uZmlnLnRvdWNoIHx8IHRoaXMuY2hlY2tQb3NpdGlvbkNoYW5nZSh5KSkge1xuICAgICAgICAgIGlmICh0aGlzLmNvbmZpZy5zdGFydGVkID0gITAsIHRoaXMuY29uZmlnLmlnbm9yZSA9ICExLCBsLl90b3VjaF9kcmFnID0gITAsIHRoaXMuY2FsbEV2ZW50KFwib25CZWZvcmVEcmFnU3RhcnRcIiwgW3UsIHRoaXMuY29uZmlnLm9yaWdpbmFsX3RhcmdldF0pID09PSAhMSkgcmV0dXJuIHRoaXMuY29uZmlnLmlnbm9yZSA9ICEwLCAhMTtcbiAgICAgICAgICB0aGlzLmJhY2t1cEV2ZW50VGFyZ2V0KGgsIGcpLCB0aGlzLmluaXREbkRNYXJrZXIoKSwgbC5fdG91Y2hfZmVlZGJhY2soKSwgdGhpcy5jYWxsRXZlbnQoXCJvbkFmdGVyRHJhZ1N0YXJ0XCIsIFt1LCB0aGlzLmNvbmZpZy5vcmlnaW5hbF90YXJnZXRdKTtcbiAgICAgICAgfSBlbHNlIHRoaXMuY29uZmlnLmlnbm9yZSA9ICEwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLmlnbm9yZSA/ICExIDogaC50YXJnZXRUb3VjaGVzICYmICFwLnRhcmdldCA/IHZvaWQgMCA6IChwLnBvcyA9IHRoaXMuZ2V0UG9zaXRpb24ocCksIHRoaXMuY29uZmlnLm1hcmtlci5zdHlsZS5sZWZ0ID0gcC5wb3MueCArIFwicHhcIiwgdGhpcy5jb25maWcubWFya2VyLnN0eWxlLnRvcCA9IHAucG9zLnkgKyBcInB4XCIsIHRoaXMuY2FsbEV2ZW50KFwib25EcmFnTW92ZVwiLCBbdSwgcF0pLCAhMCk7XG4gICAgfSwgZHJhZ0VuZDogZnVuY3Rpb24odSkge1xuICAgICAgdmFyIGggPSB0aGlzLmNvbmZpZy5iYWNrdXBfZWxlbWVudDtcbiAgICAgIGggJiYgaC5wYXJlbnROb2RlICYmIGgucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChoKSwgbC5fcHJldmVudF90b3VjaF9zY3JvbGwgPSAhMSwgdGhpcy5jb25maWcubWFya2VyICYmICh0aGlzLmNvbmZpZy5tYXJrZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmNvbmZpZy5tYXJrZXIpLCB0aGlzLmNvbmZpZy5tYXJrZXIgPSBudWxsLCB0aGlzLmNhbGxFdmVudChcIm9uRHJhZ0VuZFwiLCBbXSkpLCB0aGlzLmNvbmZpZy5zdGFydGVkID0gITEsIGwuX3RvdWNoX2RyYWcgPSAhMSwgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKFwiZ2FudHRfbm9zZWxlY3RcIik7XG4gICAgfSwgZ2V0UG9zaXRpb246IGZ1bmN0aW9uKHUpIHtcbiAgICAgIHZhciBoID0gMCwgZyA9IDA7XG4gICAgICByZXR1cm4gdS5wYWdlWCB8fCB1LnBhZ2VZID8gKGggPSB1LnBhZ2VYLCBnID0gdS5wYWdlWSkgOiAodS5jbGllbnRYIHx8IHUuY2xpZW50WSkgJiYgKGggPSB1LmNsaWVudFggKyBkb2N1bWVudC5ib2R5LnNjcm9sbExlZnQgKyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCwgZyA9IHUuY2xpZW50WSArIGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wICsgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCksIHsgeDogaCwgeTogZyB9O1xuICAgIH0gfSwgYztcbiAgfShlKTtcbiAgZS4kc2VydmljZXMuc2V0U2VydmljZShcImRuZFwiLCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gYTtcbiAgfSk7XG4gIHZhciByID0gLyogQF9fUFVSRV9fICovIGZ1bmN0aW9uKGwpIHtcbiAgICB2YXIgZCA9IHt9O1xuICAgIGZ1bmN0aW9uIGModSwgaCwgZykge1xuICAgICAgZyA9IGcgfHwgdTtcbiAgICAgIHZhciBwID0gbC5jb25maWcsIHkgPSBsLnRlbXBsYXRlcztcbiAgICAgIGwuY29uZmlnW3VdICYmIGRbZ10gIT0gcFt1XSAmJiAoaCAmJiB5W2ddIHx8ICh5W2ddID0gbC5kYXRlLmRhdGVfdG9fc3RyKHBbdV0pLCBkW2ddID0gcFt1XSkpO1xuICAgIH1cbiAgICByZXR1cm4geyBpbml0VGVtcGxhdGVzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB1ID0gbC5kYXRlLCBoID0gdS5kYXRlX3RvX3N0ciwgZyA9IGwuY29uZmlnLCBwID0gaChnLnhtbF9kYXRlIHx8IGcuZGF0ZV9mb3JtYXQsIGcuc2VydmVyX3V0YyksIHkgPSB1LnN0cl90b19kYXRlKGcueG1sX2RhdGUgfHwgZy5kYXRlX2Zvcm1hdCwgZy5zZXJ2ZXJfdXRjKTtcbiAgICAgIGMoXCJkYXRlX3NjYWxlXCIsICEwLCB2b2lkIDAsIGwuY29uZmlnLCBsLnRlbXBsYXRlcyksIGMoXCJkYXRlX2dyaWRcIiwgITAsIFwiZ3JpZF9kYXRlX2Zvcm1hdFwiLCBsLmNvbmZpZywgbC50ZW1wbGF0ZXMpLCBjKFwidGFza19kYXRlXCIsICEwLCB2b2lkIDAsIGwuY29uZmlnLCBsLnRlbXBsYXRlcyksIGwubWl4aW4obC50ZW1wbGF0ZXMsIHsgeG1sX2Zvcm1hdDogdm9pZCAwLCBmb3JtYXRfZGF0ZTogcCwgeG1sX2RhdGU6IHZvaWQgMCwgcGFyc2VfZGF0ZTogeSwgcHJvZ3Jlc3NfdGV4dDogZnVuY3Rpb24odiwgYiwgXykge1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIH0sIGdyaWRfaGVhZGVyX2NsYXNzOiBmdW5jdGlvbih2LCBiKSB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgfSwgdGFza190ZXh0OiBmdW5jdGlvbih2LCBiLCBfKSB7XG4gICAgICAgIHJldHVybiBfLnRleHQ7XG4gICAgICB9LCB0YXNrX2NsYXNzOiBmdW5jdGlvbih2LCBiLCBfKSB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgfSwgdGFza19lbmRfZGF0ZTogZnVuY3Rpb24odikge1xuICAgICAgICByZXR1cm4gbC50ZW1wbGF0ZXMudGFza19kYXRlKHYpO1xuICAgICAgfSwgZ3JpZF9yb3dfY2xhc3M6IGZ1bmN0aW9uKHYsIGIsIF8pIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB9LCB0YXNrX3Jvd19jbGFzczogZnVuY3Rpb24odiwgYiwgXykge1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIH0sIHRpbWVsaW5lX2NlbGxfY2xhc3M6IGZ1bmN0aW9uKHYsIGIpIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB9LCB0aW1lbGluZV9jZWxsX2NvbnRlbnQ6IGZ1bmN0aW9uKHYsIGIpIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB9LCBzY2FsZV9jZWxsX2NsYXNzOiBmdW5jdGlvbih2KSB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgfSwgc2NhbGVfcm93X2NsYXNzOiBmdW5jdGlvbih2KSB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgfSwgZ3JpZF9pbmRlbnQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgcmV0dXJuIFwiPGRpdiBjbGFzcz0nZ2FudHRfdHJlZV9pbmRlbnQnPjwvZGl2PlwiO1xuICAgICAgfSwgZ3JpZF9mb2xkZXI6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgcmV0dXJuIFwiPGRpdiBjbGFzcz0nZ2FudHRfdHJlZV9pY29uIGdhbnR0X2ZvbGRlcl9cIiArICh2LiRvcGVuID8gXCJvcGVuXCIgOiBcImNsb3NlZFwiKSArIFwiJz48L2Rpdj5cIjtcbiAgICAgIH0sIGdyaWRfZmlsZTogZnVuY3Rpb24odikge1xuICAgICAgICByZXR1cm4gXCI8ZGl2IGNsYXNzPSdnYW50dF90cmVlX2ljb24gZ2FudHRfZmlsZSc+PC9kaXY+XCI7XG4gICAgICB9LCBncmlkX29wZW46IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgcmV0dXJuIFwiPGRpdiBjbGFzcz0nZ2FudHRfdHJlZV9pY29uIGdhbnR0X1wiICsgKHYuJG9wZW4gPyBcImNsb3NlXCIgOiBcIm9wZW5cIikgKyBcIic+PC9kaXY+XCI7XG4gICAgICB9LCBncmlkX2JsYW5rOiBmdW5jdGlvbih2KSB7XG4gICAgICAgIHJldHVybiBcIjxkaXYgY2xhc3M9J2dhbnR0X3RyZWVfaWNvbiBnYW50dF9ibGFuayc+PC9kaXY+XCI7XG4gICAgICB9LCBkYXRlX2dyaWQ6IGZ1bmN0aW9uKHYsIGIsIF8pIHtcbiAgICAgICAgcmV0dXJuIGIgJiYgbC5pc1Vuc2NoZWR1bGVkVGFzayhiKSAmJiBsLmNvbmZpZy5zaG93X3Vuc2NoZWR1bGVkID8gbC50ZW1wbGF0ZXMudGFza191bnNjaGVkdWxlZF90aW1lKGIpIDogbC50ZW1wbGF0ZXMuZ3JpZF9kYXRlX2Zvcm1hdCh2LCBfKTtcbiAgICAgIH0sIHRhc2tfdGltZTogZnVuY3Rpb24odiwgYiwgXykge1xuICAgICAgICByZXR1cm4gbC5pc1Vuc2NoZWR1bGVkVGFzayhfKSAmJiBsLmNvbmZpZy5zaG93X3Vuc2NoZWR1bGVkID8gbC50ZW1wbGF0ZXMudGFza191bnNjaGVkdWxlZF90aW1lKF8pIDogbC50ZW1wbGF0ZXMudGFza19kYXRlKHYpICsgXCIgLSBcIiArIGwudGVtcGxhdGVzLnRhc2tfZW5kX2RhdGUoYik7XG4gICAgICB9LCB0YXNrX3Vuc2NoZWR1bGVkX3RpbWU6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB9LCB0aW1lX3BpY2tlcjogaChnLnRpbWVfcGlja2VyKSwgbGlua19jbGFzczogZnVuY3Rpb24odikge1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIH0sIGxpbmtfZGVzY3JpcHRpb246IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgdmFyIGIgPSBsLmdldFRhc2sodi5zb3VyY2UpLCBfID0gbC5nZXRUYXNrKHYudGFyZ2V0KTtcbiAgICAgICAgcmV0dXJuIFwiPGI+XCIgKyBiLnRleHQgKyBcIjwvYj4gJm5kYXNoOyAgPGI+XCIgKyBfLnRleHQgKyBcIjwvYj5cIjtcbiAgICAgIH0sIGRyYWdfbGluazogZnVuY3Rpb24odiwgYiwgXywgbSkge1xuICAgICAgICB2ID0gbC5nZXRUYXNrKHYpO1xuICAgICAgICB2YXIgZiA9IGwubG9jYWxlLmxhYmVscywgayA9IFwiPGI+XCIgKyB2LnRleHQgKyBcIjwvYj4gXCIgKyAoYiA/IGYubGlua19zdGFydCA6IGYubGlua19lbmQpICsgXCI8YnIvPlwiO1xuICAgICAgICByZXR1cm4gXyAmJiAoayArPSBcIjxiPiBcIiArIChfID0gbC5nZXRUYXNrKF8pKS50ZXh0ICsgXCI8L2I+IFwiICsgKG0gPyBmLmxpbmtfc3RhcnQgOiBmLmxpbmtfZW5kKSArIFwiPGJyLz5cIiksIGs7XG4gICAgICB9LCBkcmFnX2xpbmtfY2xhc3M6IGZ1bmN0aW9uKHYsIGIsIF8sIG0pIHtcbiAgICAgICAgdmFyIGYgPSBcIlwiO1xuICAgICAgICByZXR1cm4gdiAmJiBfICYmIChmID0gXCIgXCIgKyAobC5pc0xpbmtBbGxvd2VkKHYsIF8sIGIsIG0pID8gXCJnYW50dF9saW5rX2FsbG93XCIgOiBcImdhbnR0X2xpbmtfZGVueVwiKSksIFwiZ2FudHRfbGlua190b29sdGlwXCIgKyBmO1xuICAgICAgfSwgdG9vbHRpcF9kYXRlX2Zvcm1hdDogdS5kYXRlX3RvX3N0cihcIiVZLSVtLSVkXCIpLCB0b29sdGlwX3RleHQ6IGZ1bmN0aW9uKHYsIGIsIF8pIHtcbiAgICAgICAgcmV0dXJuIGA8ZGl2PlRhc2s6ICR7Xy50ZXh0fTwvZGl2PlxuXHRcdFx0XHQ8ZGl2PlN0YXJ0IGRhdGU6ICR7bC50ZW1wbGF0ZXMudG9vbHRpcF9kYXRlX2Zvcm1hdCh2KX08L2Rpdj5cblx0XHRcdFx0PGRpdj5FbmQgZGF0ZTogJHtsLnRlbXBsYXRlcy50b29sdGlwX2RhdGVfZm9ybWF0KGIpfTwvZGl2PmA7XG4gICAgICB9LCBiYXNlbGluZV90ZXh0OiBmdW5jdGlvbih2LCBiLCBfKSB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgfSB9KTtcbiAgICB9LCBpbml0VGVtcGxhdGU6IGMgfTtcbiAgfShlKTtcbiAgZS4kc2VydmljZXMuc2V0U2VydmljZShcInRlbXBsYXRlTG9hZGVyXCIsIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiByO1xuICB9KSwgb3QoZSk7XG4gIHZhciBzID0gbmV3IEtuKCk7XG4gIHMucmVnaXN0ZXJQcm92aWRlcihcImdsb2JhbFwiLCBmdW5jdGlvbigpIHtcbiAgICB2YXIgbCA9IHsgbWluX2RhdGU6IGUuX21pbl9kYXRlLCBtYXhfZGF0ZTogZS5fbWF4X2RhdGUsIHNlbGVjdGVkX3Rhc2s6IG51bGwgfTtcbiAgICByZXR1cm4gZS4kZGF0YSAmJiBlLiRkYXRhLnRhc2tzU3RvcmUgJiYgKGwuc2VsZWN0ZWRfdGFzayA9IGUuJGRhdGEudGFza3NTdG9yZS5nZXRTZWxlY3RlZElkKCkpLCBsO1xuICB9KSwgZS5nZXRTdGF0ZSA9IHMuZ2V0U3RhdGUsIGUuJHNlcnZpY2VzLnNldFNlcnZpY2UoXCJzdGF0ZVwiLCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gcztcbiAgfSksIFAoZSwgQm4pLCBlLlByb21pc2UgPSBYbiwgZS5lbnYgPSBtdCwgZnVuY3Rpb24obCkge1xuICAgIHZhciBkID0gUW4uY3JlYXRlKCk7XG4gICAgUChsLCBkKTtcbiAgICB2YXIgYywgdSA9IGwuY3JlYXRlRGF0YXN0b3JlKHsgbmFtZTogXCJ0YXNrXCIsIHR5cGU6IFwidHJlZURhdGFzdG9yZVwiLCByb290SWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGwuY29uZmlnLnJvb3RfaWQ7XG4gICAgfSwgaW5pdEl0ZW06IFIoZnVuY3Rpb24oXykge1xuICAgICAgdGhpcy5kZWZpbmVkKF8uaWQpIHx8IChfLmlkID0gdGhpcy51aWQoKSksIF8uc3RhcnRfZGF0ZSAmJiAoXy5zdGFydF9kYXRlID0gbC5kYXRlLnBhcnNlRGF0ZShfLnN0YXJ0X2RhdGUsIFwicGFyc2VfZGF0ZVwiKSksIF8uZW5kX2RhdGUgJiYgKF8uZW5kX2RhdGUgPSBsLmRhdGUucGFyc2VEYXRlKF8uZW5kX2RhdGUsIFwicGFyc2VfZGF0ZVwiKSk7XG4gICAgICB2YXIgbSA9IG51bGw7XG4gICAgICAoXy5kdXJhdGlvbiB8fCBfLmR1cmF0aW9uID09PSAwKSAmJiAoXy5kdXJhdGlvbiA9IG0gPSAxICogXy5kdXJhdGlvbiksIG0gJiYgKF8uc3RhcnRfZGF0ZSAmJiAhXy5lbmRfZGF0ZSA/IF8uZW5kX2RhdGUgPSB0aGlzLmNhbGN1bGF0ZUVuZERhdGUoXykgOiAhXy5zdGFydF9kYXRlICYmIF8uZW5kX2RhdGUgJiYgKF8uc3RhcnRfZGF0ZSA9IHRoaXMuY2FsY3VsYXRlRW5kRGF0ZSh7IHN0YXJ0X2RhdGU6IF8uZW5kX2RhdGUsIGR1cmF0aW9uOiAtXy5kdXJhdGlvbiwgdGFzazogXyB9KSkpLCBsLmNvbmZpZy5kZWFkbGluZXMgIT09ICExICYmIF8uZGVhZGxpbmUgJiYgKF8uZGVhZGxpbmUgPSBsLmRhdGUucGFyc2VEYXRlKF8uZGVhZGxpbmUsIFwicGFyc2VfZGF0ZVwiKSksIF8ucHJvZ3Jlc3MgPSBOdW1iZXIoXy5wcm9ncmVzcykgfHwgMCwgdGhpcy5faXNBbGxvd2VkVW5zY2hlZHVsZWRUYXNrKF8pICYmIHRoaXMuX3NldF9kZWZhdWx0X3Rhc2tfdGltaW5nKF8pLCB0aGlzLl9pbml0X3Rhc2tfdGltaW5nKF8pLCBfLnN0YXJ0X2RhdGUgJiYgXy5lbmRfZGF0ZSAmJiB0aGlzLmNvcnJlY3RUYXNrV29ya1RpbWUoXyksIF8uJHNvdXJjZSA9IFtdLCBfLiR0YXJnZXQgPSBbXTtcbiAgICAgIHZhciBmID0gdGhpcy4kZGF0YS50YXNrc1N0b3JlLmdldEl0ZW0oXy5pZCk7XG4gICAgICByZXR1cm4gZiAmJiAhVyhfLm9wZW4pICYmIChfLiRvcGVuID0gZi4kb3BlbiksIF8ucGFyZW50ID09PSB2b2lkIDAgJiYgKF8ucGFyZW50ID0gdGhpcy5jb25maWcucm9vdF9pZCksIF8ub3BlbiAmJiAoXy4kb3BlbiA9ICEwKSwgXztcbiAgICB9LCBsKSwgZ2V0Q29uZmlnOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBsLmNvbmZpZztcbiAgICB9IH0pLCBoID0gbC5jcmVhdGVEYXRhc3RvcmUoeyBuYW1lOiBcImxpbmtcIiwgaW5pdEl0ZW06IFIoZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIHRoaXMuZGVmaW5lZChfLmlkKSB8fCAoXy5pZCA9IHRoaXMudWlkKCkpLCBfO1xuICAgIH0sIGwpIH0pO1xuICAgIGZ1bmN0aW9uIGcoXykge1xuICAgICAgdmFyIG0gPSBsLmlzVGFza1Zpc2libGUoXyk7XG4gICAgICBpZiAoIW0gJiYgbC5pc1Rhc2tFeGlzdHMoXykpIHtcbiAgICAgICAgdmFyIGYgPSBsLmdldFBhcmVudChfKTtcbiAgICAgICAgbC5pc1Rhc2tFeGlzdHMoZikgJiYgbC5pc1Rhc2tWaXNpYmxlKGYpICYmIChmID0gbC5nZXRUYXNrKGYpLCBsLmlzU3BsaXRUYXNrKGYpICYmIChtID0gITApKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwKF8pIHtcbiAgICAgIGlmIChsLmlzVGFza0V4aXN0cyhfLnNvdXJjZSkpIHtcbiAgICAgICAgdmFyIG0gPSBsLmdldFRhc2soXy5zb3VyY2UpO1xuICAgICAgICBtLiRzb3VyY2UgPSBtLiRzb3VyY2UgfHwgW10sIG0uJHNvdXJjZS5wdXNoKF8uaWQpO1xuICAgICAgfVxuICAgICAgaWYgKGwuaXNUYXNrRXhpc3RzKF8udGFyZ2V0KSkge1xuICAgICAgICB2YXIgZiA9IGwuZ2V0VGFzayhfLnRhcmdldCk7XG4gICAgICAgIGYuJHRhcmdldCA9IGYuJHRhcmdldCB8fCBbXSwgZi4kdGFyZ2V0LnB1c2goXy5pZCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHkoXykge1xuICAgICAgaWYgKGwuaXNUYXNrRXhpc3RzKF8uc291cmNlKSkge1xuICAgICAgICBmb3IgKHZhciBtID0gbC5nZXRUYXNrKF8uc291cmNlKSwgZiA9IDA7IGYgPCBtLiRzb3VyY2UubGVuZ3RoOyBmKyspIGlmIChtLiRzb3VyY2VbZl0gPT0gXy5pZCkge1xuICAgICAgICAgIG0uJHNvdXJjZS5zcGxpY2UoZiwgMSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChsLmlzVGFza0V4aXN0cyhfLnRhcmdldCkpIHtcbiAgICAgICAgdmFyIGsgPSBsLmdldFRhc2soXy50YXJnZXQpO1xuICAgICAgICBmb3IgKGYgPSAwOyBmIDwgay4kdGFyZ2V0Lmxlbmd0aDsgZisrKSBpZiAoay4kdGFyZ2V0W2ZdID09IF8uaWQpIHtcbiAgICAgICAgICBrLiR0YXJnZXQuc3BsaWNlKGYsIDEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHYoKSB7XG4gICAgICBmb3IgKHZhciBfID0gbnVsbCwgbSA9IGwuJGRhdGEudGFza3NTdG9yZS5nZXRJdGVtcygpLCBmID0gMCwgayA9IG0ubGVuZ3RoOyBmIDwgazsgZisrKSAoXyA9IG1bZl0pLiRzb3VyY2UgPSBbXSwgXy4kdGFyZ2V0ID0gW107XG4gICAgICB2YXIgeCA9IGwuJGRhdGEubGlua3NTdG9yZS5nZXRJdGVtcygpO1xuICAgICAgZm9yIChmID0gMCwgayA9IHgubGVuZ3RoOyBmIDwgazsgZisrKSBwKHhbZl0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBiKF8pIHtcbiAgICAgIHZhciBtID0gXy5zb3VyY2UsIGYgPSBfLnRhcmdldDtcbiAgICAgIGZvciAodmFyIGsgaW4gXy5ldmVudHMpIChmdW5jdGlvbih4LCAkKSB7XG4gICAgICAgIG0uYXR0YWNoRXZlbnQoeCwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIGYuY2FsbEV2ZW50KCQsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgICAgICB9LCAkKTtcbiAgICAgIH0pKGssIF8uZXZlbnRzW2tdKTtcbiAgICB9XG4gICAgbC5hdHRhY2hFdmVudChcIm9uRGVzdHJveVwiLCBmdW5jdGlvbigpIHtcbiAgICAgIHUuZGVzdHJ1Y3RvcigpLCBoLmRlc3RydWN0b3IoKTtcbiAgICB9KSwgbC5hdHRhY2hFdmVudChcIm9uTGlua1ZhbGlkYXRpb25cIiwgZnVuY3Rpb24oXykge1xuICAgICAgaWYgKGwuaXNMaW5rRXhpc3RzKF8uaWQpIHx8IF8uaWQgPT09IFwicHJlZGVjZXNzb3JfZ2VuZXJhdGVkXCIpIHJldHVybiAhMDtcbiAgICAgIGZvciAodmFyIG0gPSBsLmdldFRhc2soXy5zb3VyY2UpLiRzb3VyY2UsIGYgPSAwOyBmIDwgbS5sZW5ndGg7IGYrKykge1xuICAgICAgICB2YXIgayA9IGwuZ2V0TGluayhtW2ZdKSwgeCA9IF8uc291cmNlID09IGsuc291cmNlLCAkID0gXy50YXJnZXQgPT0gay50YXJnZXQsIHcgPSBfLnR5cGUgPT0gay50eXBlO1xuICAgICAgICBpZiAoeCAmJiAkICYmIHcpIHJldHVybiAhMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAhMDtcbiAgICB9KSwgdS5hdHRhY2hFdmVudChcIm9uQmVmb3JlUmVmcmVzaEFsbFwiLCBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdS5fc2tpcFRhc2tSZWNhbGN1bGF0aW9uKSBmb3IgKHZhciBfID0gdS5nZXRWaXNpYmxlSXRlbXMoKSwgbSA9IDA7IG0gPCBfLmxlbmd0aDsgbSsrKSB7XG4gICAgICAgIHZhciBmID0gX1ttXTtcbiAgICAgICAgZi4kaW5kZXggPSBtLCBmLiRsb2NhbF9pbmRleCA9IGwuZ2V0VGFza0luZGV4KGYuaWQpLCBsLnJlc2V0UHJvamVjdERhdGVzKGYpO1xuICAgICAgfVxuICAgIH0pLCB1LmF0dGFjaEV2ZW50KFwib25GaWx0ZXJJdGVtXCIsIGZ1bmN0aW9uKF8sIG0pIHtcbiAgICAgIGlmIChsLmNvbmZpZy5zaG93X3Rhc2tzX291dHNpZGVfdGltZXNjYWxlKSByZXR1cm4gITA7XG4gICAgICB2YXIgZiA9IG51bGwsIGsgPSBudWxsO1xuICAgICAgaWYgKGwuY29uZmlnLnN0YXJ0X2RhdGUgJiYgbC5jb25maWcuZW5kX2RhdGUpIHtcbiAgICAgICAgaWYgKGwuX2lzQWxsb3dlZFVuc2NoZWR1bGVkVGFzayhtKSkgcmV0dXJuICEwO1xuICAgICAgICBpZiAoZiA9IGwuY29uZmlnLnN0YXJ0X2RhdGUudmFsdWVPZigpLCBrID0gbC5jb25maWcuZW5kX2RhdGUudmFsdWVPZigpLCArbS5zdGFydF9kYXRlID4gayB8fCArbS5lbmRfZGF0ZSA8ICtmKSByZXR1cm4gITE7XG4gICAgICB9XG4gICAgICByZXR1cm4gITA7XG4gICAgfSksIHUuYXR0YWNoRXZlbnQoXCJvbklkQ2hhbmdlXCIsIGZ1bmN0aW9uKF8sIG0pIHtcbiAgICAgIGwuX3VwZGF0ZV9mbGFncyhfLCBtKTtcbiAgICAgIHZhciBmID0gbC5nZXRUYXNrKG0pO1xuICAgICAgdS5pc1NpbGVudCgpIHx8IChmLiRzcGxpdF9zdWJ0YXNrIHx8IGYucm9sbHVwKSAmJiBsLmVhY2hQYXJlbnQoZnVuY3Rpb24oaykge1xuICAgICAgICBsLnJlZnJlc2hUYXNrKGsuaWQpO1xuICAgICAgfSwgbSk7XG4gICAgfSksIHUuYXR0YWNoRXZlbnQoXCJvbkFmdGVyVXBkYXRlXCIsIGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmIChsLl91cGRhdGVfcGFyZW50cyhfKSwgbC5nZXRTdGF0ZShcImJhdGNoVXBkYXRlXCIpLmJhdGNoX3VwZGF0ZSkgcmV0dXJuICEwO1xuICAgICAgdmFyIG0gPSB1LmdldEl0ZW0oXyk7XG4gICAgICBtLiRzb3VyY2UgfHwgKG0uJHNvdXJjZSA9IFtdKTtcbiAgICAgIGZvciAodmFyIGYgPSAwOyBmIDwgbS4kc291cmNlLmxlbmd0aDsgZisrKSBoLnJlZnJlc2gobS4kc291cmNlW2ZdKTtcbiAgICAgIGZvciAobS4kdGFyZ2V0IHx8IChtLiR0YXJnZXQgPSBbXSksIGYgPSAwOyBmIDwgbS4kdGFyZ2V0Lmxlbmd0aDsgZisrKSBoLnJlZnJlc2gobS4kdGFyZ2V0W2ZdKTtcbiAgICB9KSwgdS5hdHRhY2hFdmVudChcIm9uQmVmb3JlSXRlbU1vdmVcIiwgZnVuY3Rpb24oXywgbSwgZikge1xuICAgICAgcmV0dXJuICFSdChfLCBsLCB1KSB8fCAoY29uc29sZS5sb2coXCJUaGUgcGxhY2Vob2xkZXIgdGFzayBjYW5ub3QgYmUgbW92ZWQgdG8gYW5vdGhlciBwb3NpdGlvbi5cIiksICExKTtcbiAgICB9KSwgdS5hdHRhY2hFdmVudChcIm9uQWZ0ZXJJdGVtTW92ZVwiLCBmdW5jdGlvbihfLCBtLCBmKSB7XG4gICAgICB2YXIgayA9IGwuZ2V0VGFzayhfKTtcbiAgICAgIHRoaXMuZ2V0TmV4dFNpYmxpbmcoXykgIT09IG51bGwgPyBrLiRkcm9wX3RhcmdldCA9IHRoaXMuZ2V0TmV4dFNpYmxpbmcoXykgOiB0aGlzLmdldFByZXZTaWJsaW5nKF8pICE9PSBudWxsID8gay4kZHJvcF90YXJnZXQgPSBcIm5leHQ6XCIgKyB0aGlzLmdldFByZXZTaWJsaW5nKF8pIDogay4kZHJvcF90YXJnZXQgPSBcIm5leHQ6bnVsbFwiO1xuICAgIH0pLCB1LmF0dGFjaEV2ZW50KFwib25TdG9yZVVwZGF0ZWRcIiwgZnVuY3Rpb24oXywgbSwgZikge1xuICAgICAgaWYgKGYgPT0gXCJkZWxldGVcIiAmJiBsLl91cGRhdGVfZmxhZ3MoXywgbnVsbCksICFsLiRzZXJ2aWNlcy5nZXRTZXJ2aWNlKFwic3RhdGVcIikuZ2V0U3RhdGUoXCJiYXRjaFVwZGF0ZVwiKS5iYXRjaF91cGRhdGUpIHtcbiAgICAgICAgaWYgKGwuY29uZmlnLmZpdF90YXNrcyAmJiBmICE9PSBcInBhaW50XCIpIHtcbiAgICAgICAgICB2YXIgayA9IGwuZ2V0U3RhdGUoKTtcbiAgICAgICAgICBtZShsKTtcbiAgICAgICAgICB2YXIgeCA9IGwuZ2V0U3RhdGUoKTtcbiAgICAgICAgICBpZiAoK2subWluX2RhdGUgIT0gK3gubWluX2RhdGUgfHwgK2subWF4X2RhdGUgIT0gK3gubWF4X2RhdGUpIHJldHVybiBsLnJlbmRlcigpLCBsLmNhbGxFdmVudChcIm9uU2NhbGVBZGp1c3RlZFwiLCBbXSksICEwO1xuICAgICAgICB9XG4gICAgICAgIGYgPT0gXCJhZGRcIiB8fCBmID09IFwibW92ZVwiIHx8IGYgPT0gXCJkZWxldGVcIiA/IGwuJGxheW91dCAmJiAodGhpcy4kY29uZmlnLm5hbWUgIT0gXCJ0YXNrXCIgfHwgZiAhPSBcImFkZFwiICYmIGYgIT0gXCJkZWxldGVcIiB8fCB0aGlzLl9za2lwVGFza1JlY2FsY3VsYXRpb24gIT0gXCJsaWdodGJveFwiICYmICh0aGlzLl9za2lwVGFza1JlY2FsY3VsYXRpb24gPSAhMCksIGwuJGxheW91dC5yZXNpemUoKSkgOiBfIHx8IGgucmVmcmVzaCgpO1xuICAgICAgfVxuICAgIH0pLCBoLmF0dGFjaEV2ZW50KFwib25BZnRlckFkZFwiLCBmdW5jdGlvbihfLCBtKSB7XG4gICAgICBwKG0pO1xuICAgIH0pLCBoLmF0dGFjaEV2ZW50KFwib25BZnRlclVwZGF0ZVwiLCBmdW5jdGlvbihfLCBtKSB7XG4gICAgICB2KCk7XG4gICAgfSksIGguYXR0YWNoRXZlbnQoXCJvbkFmdGVyRGVsZXRlXCIsIGZ1bmN0aW9uKF8sIG0pIHtcbiAgICAgIHkobSk7XG4gICAgfSksIGguYXR0YWNoRXZlbnQoXCJvbkFmdGVyU2lsZW50RGVsZXRlXCIsIGZ1bmN0aW9uKF8sIG0pIHtcbiAgICAgIHkobSk7XG4gICAgfSksIGguYXR0YWNoRXZlbnQoXCJvbkJlZm9yZUlkQ2hhbmdlXCIsIGZ1bmN0aW9uKF8sIG0pIHtcbiAgICAgIHkobC5taXhpbih7IGlkOiBfIH0sIGwuJGRhdGEubGlua3NTdG9yZS5nZXRJdGVtKG0pKSksIHAobC4kZGF0YS5saW5rc1N0b3JlLmdldEl0ZW0obSkpO1xuICAgIH0pLCBoLmF0dGFjaEV2ZW50KFwib25GaWx0ZXJJdGVtXCIsIGZ1bmN0aW9uKF8sIG0pIHtcbiAgICAgIGlmICghbC5jb25maWcuc2hvd19saW5rcykgcmV0dXJuICExO1xuICAgICAgdmFyIGYgPSBnKG0uc291cmNlKSwgayA9IGcobS50YXJnZXQpO1xuICAgICAgcmV0dXJuICEoIWYgfHwgIWsgfHwgbC5faXNBbGxvd2VkVW5zY2hlZHVsZWRUYXNrKGwuZ2V0VGFzayhtLnNvdXJjZSkpIHx8IGwuX2lzQWxsb3dlZFVuc2NoZWR1bGVkVGFzayhsLmdldFRhc2sobS50YXJnZXQpKSkgJiYgbC5jYWxsRXZlbnQoXCJvbkJlZm9yZUxpbmtEaXNwbGF5XCIsIFtfLCBtXSk7XG4gICAgfSksIGMgPSB7fSwgbC5hdHRhY2hFdmVudChcIm9uQmVmb3JlVGFza0RlbGV0ZVwiLCBmdW5jdGlvbihfLCBtKSB7XG4gICAgICByZXR1cm4gY1tfXSA9IHZlLmdldFN1YnRyZWVMaW5rcyhsLCBfKSwgITA7XG4gICAgfSksIGwuYXR0YWNoRXZlbnQoXCJvbkFmdGVyVGFza0RlbGV0ZVwiLCBmdW5jdGlvbihfLCBtKSB7XG4gICAgICBjW19dICYmIGwuJGRhdGEubGlua3NTdG9yZS5zaWxlbnQoZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvciAodmFyIGYgaW4gY1tfXSkgbC5pc0xpbmtFeGlzdHMoZikgJiYgbC4kZGF0YS5saW5rc1N0b3JlLnJlbW92ZUl0ZW0oZiksIHkoY1tfXVtmXSk7XG4gICAgICAgIGNbX10gPSBudWxsO1xuICAgICAgfSk7XG4gICAgfSksIGwuYXR0YWNoRXZlbnQoXCJvbkFmdGVyTGlua0RlbGV0ZVwiLCBmdW5jdGlvbihfLCBtKSB7XG4gICAgICBsLmlzVGFza0V4aXN0cyhtLnNvdXJjZSkgJiYgbC5yZWZyZXNoVGFzayhtLnNvdXJjZSksIGwuaXNUYXNrRXhpc3RzKG0udGFyZ2V0KSAmJiBsLnJlZnJlc2hUYXNrKG0udGFyZ2V0KTtcbiAgICB9KSwgbC5hdHRhY2hFdmVudChcIm9uUGFyc2VcIiwgdiksIGIoeyBzb3VyY2U6IGgsIHRhcmdldDogbCwgZXZlbnRzOiB7IG9uSXRlbUxvYWRpbmc6IFwib25MaW5rTG9hZGluZ1wiLCBvbkJlZm9yZUFkZDogXCJvbkJlZm9yZUxpbmtBZGRcIiwgb25BZnRlckFkZDogXCJvbkFmdGVyTGlua0FkZFwiLCBvbkJlZm9yZVVwZGF0ZTogXCJvbkJlZm9yZUxpbmtVcGRhdGVcIiwgb25BZnRlclVwZGF0ZTogXCJvbkFmdGVyTGlua1VwZGF0ZVwiLCBvbkJlZm9yZURlbGV0ZTogXCJvbkJlZm9yZUxpbmtEZWxldGVcIiwgb25BZnRlckRlbGV0ZTogXCJvbkFmdGVyTGlua0RlbGV0ZVwiLCBvbklkQ2hhbmdlOiBcIm9uTGlua0lkQ2hhbmdlXCIgfSB9KSwgYih7IHNvdXJjZTogdSwgdGFyZ2V0OiBsLCBldmVudHM6IHsgb25JdGVtTG9hZGluZzogXCJvblRhc2tMb2FkaW5nXCIsIG9uQmVmb3JlQWRkOiBcIm9uQmVmb3JlVGFza0FkZFwiLCBvbkFmdGVyQWRkOiBcIm9uQWZ0ZXJUYXNrQWRkXCIsIG9uQmVmb3JlVXBkYXRlOiBcIm9uQmVmb3JlVGFza1VwZGF0ZVwiLCBvbkFmdGVyVXBkYXRlOiBcIm9uQWZ0ZXJUYXNrVXBkYXRlXCIsIG9uQmVmb3JlRGVsZXRlOiBcIm9uQmVmb3JlVGFza0RlbGV0ZVwiLCBvbkFmdGVyRGVsZXRlOiBcIm9uQWZ0ZXJUYXNrRGVsZXRlXCIsIG9uSWRDaGFuZ2U6IFwib25UYXNrSWRDaGFuZ2VcIiwgb25CZWZvcmVJdGVtTW92ZTogXCJvbkJlZm9yZVRhc2tNb3ZlXCIsIG9uQWZ0ZXJJdGVtTW92ZTogXCJvbkFmdGVyVGFza01vdmVcIiwgb25GaWx0ZXJJdGVtOiBcIm9uQmVmb3JlVGFza0Rpc3BsYXlcIiwgb25JdGVtT3BlbjogXCJvblRhc2tPcGVuZWRcIiwgb25JdGVtQ2xvc2U6IFwib25UYXNrQ2xvc2VkXCIsIG9uQmVmb3JlU2VsZWN0OiBcIm9uQmVmb3JlVGFza1NlbGVjdGVkXCIsIG9uQWZ0ZXJTZWxlY3Q6IFwib25UYXNrU2VsZWN0ZWRcIiwgb25BZnRlclVuc2VsZWN0OiBcIm9uVGFza1Vuc2VsZWN0ZWRcIiB9IH0pLCBsLiRkYXRhID0geyB0YXNrc1N0b3JlOiB1LCBsaW5rc1N0b3JlOiBoIH07XG4gIH0oZSksIGUuZGF0YVByb2Nlc3NvciA9IG5pLCBlLmNyZWF0ZURhdGFQcm9jZXNzb3IgPSBpaSwgZnVuY3Rpb24obCkge1xuICAgIGwuZXh0IHx8IChsLmV4dCA9IHt9KTtcbiAgICBmb3IgKHZhciBkID0gW3JpLCBzaSwgbGksIGRpLCBjaSwgdWksIGhpLCBfaSwgZ2ldLCBjID0gMDsgYyA8IGQubGVuZ3RoOyBjKyspIGRbY10gJiYgZFtjXShsKTtcbiAgfShlKSwgZnVuY3Rpb24obCkge1xuICAgIGwuZ2V0R3JpZENvbHVtbiA9IGZ1bmN0aW9uKGQpIHtcbiAgICAgIGZvciAodmFyIGMgPSBsLmNvbmZpZy5jb2x1bW5zLCB1ID0gMDsgdSA8IGMubGVuZ3RoOyB1KyspIGlmIChjW3VdLm5hbWUgPT0gZCkgcmV0dXJuIGNbdV07XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LCBsLmdldEdyaWRDb2x1bW5zID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbC5jb25maWcuY29sdW1ucy5zbGljZSgpO1xuICAgIH07XG4gIH0oZSksIGZ1bmN0aW9uKGwpIHtcbiAgICBsLmlzUmVhZG9ubHkgPSBmdW5jdGlvbihkKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIGQgIT0gXCJudW1iZXJcIiAmJiB0eXBlb2YgZCAhPSBcInN0cmluZ1wiIHx8ICFsLmlzVGFza0V4aXN0cyhkKSB8fCAoZCA9IGwuZ2V0VGFzayhkKSksICghZCB8fCAhZFt0aGlzLmNvbmZpZy5lZGl0YWJsZV9wcm9wZXJ0eV0pICYmIChkICYmIGRbdGhpcy5jb25maWcucmVhZG9ubHlfcHJvcGVydHldIHx8IHRoaXMuY29uZmlnLnJlYWRvbmx5KTtcbiAgICB9O1xuICB9KGUpLCBmaShlKSwgZnVuY3Rpb24obCkge1xuICAgIHZhciBkID0gbmV3IGZuKGwpLCBjID0gbmV3IHBuKGQpO1xuICAgIFAobCwgeGkoZCwgYykpO1xuICB9KGUpLCAkaShlKSwgZnVuY3Rpb24obCkge1xuICAgIGwuZ2V0VGFza1R5cGUgPSBmdW5jdGlvbihkKSB7XG4gICAgICByZXR1cm4gXCJ0YXNrXCI7XG4gICAgfTtcbiAgfShlKSwgZnVuY3Rpb24obCkge1xuICAgIGZ1bmN0aW9uIGQoKSB7XG4gICAgICByZXR1cm4gbC5fY2FjaGVkX2Z1bmN0aW9ucy51cGRhdGVfaWZfY2hhbmdlZChsKSwgbC5fY2FjaGVkX2Z1bmN0aW9ucy5hY3RpdmUgfHwgbC5fY2FjaGVkX2Z1bmN0aW9ucy5hY3RpdmF0ZSgpLCAhMDtcbiAgICB9XG4gICAgbC5fY2FjaGVkX2Z1bmN0aW9ucyA9IHsgY2FjaGU6IHt9LCBtb2RlOiAhMSwgY3JpdGljYWxfcGF0aF9tb2RlOiAhMSwgd3JhcF9tZXRob2RzOiBmdW5jdGlvbih1LCBoKSB7XG4gICAgICBpZiAoaC5fcHJlZmV0Y2hfb3JpZ2luYWxzKSBmb3IgKHZhciBnIGluIGguX3ByZWZldGNoX29yaWdpbmFscykgaFtnXSA9IGguX3ByZWZldGNoX29yaWdpbmFsc1tnXTtcbiAgICAgIGZvciAoaC5fcHJlZmV0Y2hfb3JpZ2luYWxzID0ge30sIGcgPSAwOyBnIDwgdS5sZW5ndGg7IGcrKykgdGhpcy5wcmVmZXRjaCh1W2ddLCBoKTtcbiAgICB9LCBwcmVmZXRjaDogZnVuY3Rpb24odSwgaCkge1xuICAgICAgdmFyIGcgPSBoW3VdO1xuICAgICAgaWYgKGcpIHtcbiAgICAgICAgdmFyIHAgPSB0aGlzO1xuICAgICAgICBoLl9wcmVmZXRjaF9vcmlnaW5hbHNbdV0gPSBnLCBoW3VdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZm9yICh2YXIgeSA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKSwgdiA9IDAsIGIgPSBhcmd1bWVudHMubGVuZ3RoOyB2IDwgYjsgdisrKSB5W3ZdID0gYXJndW1lbnRzW3ZdO1xuICAgICAgICAgIGlmIChwLmFjdGl2ZSkge1xuICAgICAgICAgICAgdmFyIF8gPSBwLmdldF9hcmd1bWVudHNfaGFzaChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh5KSk7XG4gICAgICAgICAgICBwLmNhY2hlW3VdIHx8IChwLmNhY2hlW3VdID0ge30pO1xuICAgICAgICAgICAgdmFyIG0gPSBwLmNhY2hlW3VdO1xuICAgICAgICAgICAgaWYgKHAuaGFzX2NhY2hlZF92YWx1ZShtLCBfKSkgcmV0dXJuIHAuZ2V0X2NhY2hlZF92YWx1ZShtLCBfKTtcbiAgICAgICAgICAgIHZhciBmID0gZy5hcHBseSh0aGlzLCB5KTtcbiAgICAgICAgICAgIHJldHVybiBwLmNhY2hlX3ZhbHVlKG0sIF8sIGYpLCBmO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZy5hcHBseSh0aGlzLCB5KTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBnO1xuICAgIH0sIGNhY2hlX3ZhbHVlOiBmdW5jdGlvbih1LCBoLCBnKSB7XG4gICAgICB0aGlzLmlzX2RhdGUoZykgJiYgKGcgPSBuZXcgRGF0ZShnKSksIHVbaF0gPSBnO1xuICAgIH0sIGhhc19jYWNoZWRfdmFsdWU6IGZ1bmN0aW9uKHUsIGgpIHtcbiAgICAgIHJldHVybiB1Lmhhc093blByb3BlcnR5KGgpO1xuICAgIH0sIGdldF9jYWNoZWRfdmFsdWU6IGZ1bmN0aW9uKHUsIGgpIHtcbiAgICAgIHZhciBnID0gdVtoXTtcbiAgICAgIHJldHVybiB0aGlzLmlzX2RhdGUoZykgJiYgKGcgPSBuZXcgRGF0ZShnKSksIGc7XG4gICAgfSwgaXNfZGF0ZTogZnVuY3Rpb24odSkge1xuICAgICAgcmV0dXJuIHUgJiYgdS5nZXRVVENEYXRlO1xuICAgIH0sIGdldF9hcmd1bWVudHNfaGFzaDogZnVuY3Rpb24odSkge1xuICAgICAgZm9yICh2YXIgaCA9IFtdLCBnID0gMDsgZyA8IHUubGVuZ3RoOyBnKyspIGgucHVzaCh0aGlzLnN0cmluZ2lmeV9hcmd1bWVudCh1W2ddKSk7XG4gICAgICByZXR1cm4gXCIoXCIgKyBoLmpvaW4oXCI7XCIpICsgXCIpXCI7XG4gICAgfSwgc3RyaW5naWZ5X2FyZ3VtZW50OiBmdW5jdGlvbih1KSB7XG4gICAgICByZXR1cm4gKHUuaWQgPyB1LmlkIDogdGhpcy5pc19kYXRlKHUpID8gdS52YWx1ZU9mKCkgOiB1KSArIFwiXCI7XG4gICAgfSwgYWN0aXZhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5jbGVhcigpLCB0aGlzLmFjdGl2ZSA9ICEwO1xuICAgIH0sIGRlYWN0aXZhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5jbGVhcigpLCB0aGlzLmFjdGl2ZSA9ICExO1xuICAgIH0sIGNsZWFyOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuY2FjaGUgPSB7fTtcbiAgICB9LCBzZXR1cDogZnVuY3Rpb24odSkge1xuICAgICAgdmFyIGggPSBbXSwgZyA9IFtcIl9pc1Byb2plY3RFbmRcIiwgXCJfZ2V0UHJvamVjdEVuZFwiLCBcIl9nZXRTbGFja1wiXTtcbiAgICAgIHRoaXMubW9kZSA9PSBcImF1dG9cIiA/IHUuY29uZmlnLmhpZ2hsaWdodF9jcml0aWNhbF9wYXRoICYmIChoID0gZykgOiB0aGlzLm1vZGUgPT09ICEwICYmIChoID0gZyksIHRoaXMud3JhcF9tZXRob2RzKGgsIHUpO1xuICAgIH0sIHVwZGF0ZV9pZl9jaGFuZ2VkOiBmdW5jdGlvbih1KSB7XG4gICAgICAodGhpcy5jcml0aWNhbF9wYXRoX21vZGUgIT0gdS5jb25maWcuaGlnaGxpZ2h0X2NyaXRpY2FsX3BhdGggfHwgdGhpcy5tb2RlICE9PSB1LmNvbmZpZy5vcHRpbWl6ZV9yZW5kZXIpICYmICh0aGlzLmNyaXRpY2FsX3BhdGhfbW9kZSA9IHUuY29uZmlnLmhpZ2hsaWdodF9jcml0aWNhbF9wYXRoLCB0aGlzLm1vZGUgPSB1LmNvbmZpZy5vcHRpbWl6ZV9yZW5kZXIsIHRoaXMuc2V0dXAodSkpO1xuICAgIH0gfSwgbC5hdHRhY2hFdmVudChcIm9uQmVmb3JlR2FudHRSZW5kZXJcIiwgZCksIGwuYXR0YWNoRXZlbnQoXCJvbkJlZm9yZURhdGFSZW5kZXJcIiwgZCksIGwuYXR0YWNoRXZlbnQoXCJvbkJlZm9yZVNtYXJ0UmVuZGVyXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgZCgpO1xuICAgIH0pLCBsLmF0dGFjaEV2ZW50KFwib25CZWZvcmVQYXJzZVwiLCBkKSwgbC5hdHRhY2hFdmVudChcIm9uRGF0YVJlbmRlclwiLCBmdW5jdGlvbigpIHtcbiAgICAgIGwuX2NhY2hlZF9mdW5jdGlvbnMuZGVhY3RpdmF0ZSgpO1xuICAgIH0pO1xuICAgIHZhciBjID0gbnVsbDtcbiAgICBsLmF0dGFjaEV2ZW50KFwib25TbWFydFJlbmRlclwiLCBmdW5jdGlvbigpIHtcbiAgICAgIGMgJiYgY2xlYXJUaW1lb3V0KGMpLCBjID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgbC5fY2FjaGVkX2Z1bmN0aW9ucy5kZWFjdGl2YXRlKCk7XG4gICAgICB9LCAxZTMpO1xuICAgIH0pLCBsLmF0dGFjaEV2ZW50KFwib25CZWZvcmVHYW50dFJlYWR5XCIsIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGwuX2NhY2hlZF9mdW5jdGlvbnMudXBkYXRlX2lmX2NoYW5nZWQobCksICEwO1xuICAgIH0pO1xuICB9KGUpLCB3aShlKSwgZnVuY3Rpb24obCkge1xuICAgIGwuZGVzdHJ1Y3RvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgZm9yICh2YXIgZCBpbiB0aGlzLmNsZWFyQWxsKCksIHRoaXMuY2FsbEV2ZW50KFwib25EZXN0cm95XCIsIFtdKSwgdGhpcy5fZ2V0RGF0YXN0b3JlcygpLmZvckVhY2goZnVuY3Rpb24oYykge1xuICAgICAgICBjLmRlc3RydWN0b3IoKTtcbiAgICAgIH0pLCB0aGlzLiRyb290ICYmIGRlbGV0ZSB0aGlzLiRyb290LmdhbnR0LCB0aGlzLl9ldmVudFJlbW92ZUFsbCAmJiB0aGlzLl9ldmVudFJlbW92ZUFsbCgpLCB0aGlzLiRsYXlvdXQgJiYgdGhpcy4kbGF5b3V0LmRlc3RydWN0b3IoKSwgdGhpcy5yZXNldExpZ2h0Ym94ICYmIHRoaXMucmVzZXRMaWdodGJveCgpLCB0aGlzLmV4dC5pbmxpbmVFZGl0b3JzICYmIHRoaXMuZXh0LmlubGluZUVkaXRvcnMuZGVzdHJ1Y3RvciAmJiB0aGlzLmV4dC5pbmxpbmVFZGl0b3JzLmRlc3RydWN0b3IoKSwgdGhpcy5fZHAgJiYgdGhpcy5fZHAuZGVzdHJ1Y3RvciAmJiB0aGlzLl9kcC5kZXN0cnVjdG9yKCksIHRoaXMuJHNlcnZpY2VzLmRlc3RydWN0b3IoKSwgdGhpcy5kZXRhY2hBbGxFdmVudHMoKSwgdGhpcykgZC5pbmRleE9mKFwiJFwiKSA9PT0gMCAmJiBkZWxldGUgdGhpc1tkXTtcbiAgICAgIHRoaXMuJGRlc3Ryb3llZCA9ICEwO1xuICAgIH07XG4gIH0oZSk7XG4gIHZhciBvID0gbmV3IFVpKHsgZW46IE5pLCBhcjogU2ksIGJlOiBUaSwgY2E6IEVpLCBjbjogQ2ksIGNzOiBEaSwgZGE6IEFpLCBkZTogSWksIGVsOiBNaSwgZXM6IExpLCBmYTogUGksIGZpOiBSaSwgZnI6IEhpLCBoZTogT2ksIGhyOiBCaSwgaHU6IHppLCBpZDogV2ksIGl0OiBqaSwganA6IEZpLCBrcjogVmksIG5iOiBxaSwgbmw6IEdpLCBubzogWWksIHBsOiBKaSwgcHQ6IEtpLCBybzogWGksIHJ1OiBaaSwgc2k6IFFpLCBzazogdGEsIHN2OiBlYSwgdHI6IG5hLCB1YTogaWEgfSk7XG4gIHJldHVybiBlLmkxOG4gPSB7IGFkZExvY2FsZTogby5hZGRMb2NhbGUsIHNldExvY2FsZTogZnVuY3Rpb24obCkge1xuICAgIGlmICh0eXBlb2YgbCA9PSBcInN0cmluZ1wiKSB7XG4gICAgICB2YXIgZCA9IG8uZ2V0TG9jYWxlKGwpO1xuICAgICAgZCB8fCAoZCA9IG8uZ2V0TG9jYWxlKFwiZW5cIikpLCBlLmxvY2FsZSA9IGQ7XG4gICAgfSBlbHNlIGlmIChsKSBpZiAoZS5sb2NhbGUpIGZvciAodmFyIGMgaW4gbCkgbFtjXSAmJiB0eXBlb2YgbFtjXSA9PSBcIm9iamVjdFwiID8gKGUubG9jYWxlW2NdIHx8IChlLmxvY2FsZVtjXSA9IHt9KSwgZS5taXhpbihlLmxvY2FsZVtjXSwgbFtjXSwgITApKSA6IGUubG9jYWxlW2NdID0gbFtjXTtcbiAgICBlbHNlIGUubG9jYWxlID0gbDtcbiAgICBjb25zdCB1ID0gZS5sb2NhbGUubGFiZWxzO1xuICAgIHUuZ2FudHRfc2F2ZV9idG4gPSB1LmdhbnR0X3NhdmVfYnRuIHx8IHUuaWNvbl9zYXZlLCB1LmdhbnR0X2NhbmNlbF9idG4gPSB1LmdhbnR0X2NhbmNlbF9idG4gfHwgdS5pY29uX2NhbmNlbCwgdS5nYW50dF9kZWxldGVfYnRuID0gdS5nYW50dF9kZWxldGVfYnRuIHx8IHUuaWNvbl9kZWxldGU7XG4gIH0sIGdldExvY2FsZTogby5nZXRMb2NhbGUgfSwgZS5pMThuLnNldExvY2FsZShcImVuXCIpLCBlO1xufVxuZnVuY3Rpb24gc2EodCkge1xuICB2YXIgZSA9IFwiZGF0YS1kaHhib3hcIiwgbiA9IG51bGw7XG4gIGZ1bmN0aW9uIGkoXywgbSkge1xuICAgIHZhciBmID0gXy5jYWxsYmFjaztcbiAgICB5LmhpZGUoXy5ib3gpLCBuID0gXy5ib3ggPSBudWxsLCBmICYmIGYobSk7XG4gIH1cbiAgZnVuY3Rpb24gYShfKSB7XG4gICAgaWYgKG4pIHtcbiAgICAgIHZhciBtID0gXy53aGljaCB8fCBfLmtleUNvZGUsIGYgPSAhMTtcbiAgICAgIGlmICh2LmtleWJvYXJkKSB7XG4gICAgICAgIGlmIChtID09IDEzIHx8IG0gPT0gMzIpIHtcbiAgICAgICAgICB2YXIgayA9IF8udGFyZ2V0IHx8IF8uc3JjRWxlbWVudDtcbiAgICAgICAgICBYKGspLmluZGV4T2YoXCJnYW50dF9wb3B1cF9idXR0b25cIikgPiAtMSAmJiBrLmNsaWNrID8gay5jbGljaygpIDogKGkobiwgITApLCBmID0gITApO1xuICAgICAgICB9XG4gICAgICAgIG0gPT0gMjcgJiYgKGkobiwgITEpLCBmID0gITApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGYgPyAoXy5wcmV2ZW50RGVmYXVsdCAmJiBfLnByZXZlbnREZWZhdWx0KCksICEoXy5jYW5jZWxCdWJibGUgPSAhMCkpIDogdm9pZCAwO1xuICAgIH1cbiAgfVxuICB2YXIgciA9IHZ0KHQuJHJvb3QpIHx8IGRvY3VtZW50O1xuICBmdW5jdGlvbiBzKF8pIHtcbiAgICBzLmNvdmVyIHx8IChzLmNvdmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSwgcy5jb3Zlci5vbmtleWRvd24gPSBhLCBzLmNvdmVyLmNsYXNzTmFtZSA9IFwiZGh4X21vZGFsX2NvdmVyXCIsIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQocy5jb3ZlcikpLCBzLmNvdmVyLnN0eWxlLmRpc3BsYXkgPSBfID8gXCJpbmxpbmUtYmxvY2tcIiA6IFwibm9uZVwiO1xuICB9XG4gIGZ1bmN0aW9uIG8oXywgbSwgZikge1xuICAgIHJldHVybiBcIjxkaXYgXCIgKyB0Ll93YWlBcmlhLm1lc3NhZ2VCdXR0b25BdHRyU3RyaW5nKF8pICsgXCIgY2xhc3M9J2dhbnR0X3BvcHVwX2J1dHRvbiBcIiArIChcImdhbnR0X1wiICsgbS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoLyAvZywgXCJfXCIpICsgXCJfYnV0dG9uXCIpICsgXCInIGRhdGEtcmVzdWx0PSdcIiArIGYgKyBcIicgcmVzdWx0PSdcIiArIGYgKyBcIicgPjxkaXY+XCIgKyBfICsgXCI8L2Rpdj48L2Rpdj5cIjtcbiAgfVxuICBmdW5jdGlvbiBsKCkge1xuICAgIGZvciAodmFyIF8gPSBbXS5zbGljZS5hcHBseShhcmd1bWVudHMsIFswXSksIG0gPSAwOyBtIDwgXy5sZW5ndGg7IG0rKykgaWYgKF9bbV0pIHJldHVybiBfW21dO1xuICB9XG4gIGZ1bmN0aW9uIGQoXywgbSwgZikge1xuICAgIHZhciBrID0gXy50YWdOYW1lID8gXyA6IGZ1bmN0aW9uKHcsIFMsIFQpIHtcbiAgICAgIHZhciBFID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSwgQyA9IHN0KCk7XG4gICAgICB0Ll93YWlBcmlhLm1lc3NhZ2VNb2RhbEF0dHIoRSwgQyksIEUuY2xhc3NOYW1lID0gXCIgZ2FudHRfbW9kYWxfYm94IGdhbnR0LVwiICsgdy50eXBlLCBFLnNldEF0dHJpYnV0ZShlLCAxKTtcbiAgICAgIHZhciBEID0gXCJcIjtcbiAgICAgIGlmICh3LndpZHRoICYmIChFLnN0eWxlLndpZHRoID0gdy53aWR0aCksIHcuaGVpZ2h0ICYmIChFLnN0eWxlLmhlaWdodCA9IHcuaGVpZ2h0KSwgdy50aXRsZSAmJiAoRCArPSAnPGRpdiBjbGFzcz1cImdhbnR0X3BvcHVwX3RpdGxlXCI+JyArIHcudGl0bGUgKyBcIjwvZGl2PlwiKSwgRCArPSAnPGRpdiBjbGFzcz1cImdhbnR0X3BvcHVwX3RleHRcIiBpZD1cIicgKyBDICsgJ1wiPjxzcGFuPicgKyAody5jb250ZW50ID8gXCJcIiA6IHcudGV4dCkgKyAnPC9zcGFuPjwvZGl2PjxkaXYgIGNsYXNzPVwiZ2FudHRfcG9wdXBfY29udHJvbHNcIj4nLCBTICYmIChEICs9IG8obCh3Lm9rLCB0LmxvY2FsZS5sYWJlbHMubWVzc2FnZV9vaywgXCJPS1wiKSwgXCJva1wiLCAhMCkpLCBUICYmIChEICs9IG8obCh3LmNhbmNlbCwgdC5sb2NhbGUubGFiZWxzLm1lc3NhZ2VfY2FuY2VsLCBcIkNhbmNlbFwiKSwgXCJjYW5jZWxcIiwgITEpKSwgdy5idXR0b25zKSBmb3IgKHZhciBNID0gMDsgTSA8IHcuYnV0dG9ucy5sZW5ndGg7IE0rKykge1xuICAgICAgICB2YXIgSSA9IHcuYnV0dG9uc1tNXTtcbiAgICAgICAgRCArPSB0eXBlb2YgSSA9PSBcIm9iamVjdFwiID8gbyhJLmxhYmVsLCBJLmNzcyB8fCBcImdhbnR0X1wiICsgSS5sYWJlbC50b0xvd2VyQ2FzZSgpICsgXCJfYnV0dG9uXCIsIEkudmFsdWUgfHwgTSkgOiBvKEksIEksIE0pO1xuICAgICAgfVxuICAgICAgaWYgKEQgKz0gXCI8L2Rpdj5cIiwgRS5pbm5lckhUTUwgPSBELCB3LmNvbnRlbnQpIHtcbiAgICAgICAgdmFyIEEgPSB3LmNvbnRlbnQ7XG4gICAgICAgIHR5cGVvZiBBID09IFwic3RyaW5nXCIgJiYgKEEgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChBKSksIEEuc3R5bGUuZGlzcGxheSA9PSBcIm5vbmVcIiAmJiAoQS5zdHlsZS5kaXNwbGF5ID0gXCJcIiksIEUuY2hpbGROb2Rlc1t3LnRpdGxlID8gMSA6IDBdLmFwcGVuZENoaWxkKEEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEUub25jbGljayA9IGZ1bmN0aW9uKE4pIHtcbiAgICAgICAgdmFyIEwgPSBOLnRhcmdldCB8fCBOLnNyY0VsZW1lbnQ7XG4gICAgICAgIGlmIChMLmNsYXNzTmFtZSB8fCAoTCA9IEwucGFyZW50Tm9kZSksIGN0KEwsIFwiLmdhbnR0X3BvcHVwX2J1dHRvblwiKSkge1xuICAgICAgICAgIHZhciBPID0gTC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXJlc3VsdFwiKTtcbiAgICAgICAgICBpKHcsIE8gPSBPID09IFwidHJ1ZVwiIHx8IE8gIT0gXCJmYWxzZVwiICYmIE8pO1xuICAgICAgICB9XG4gICAgICB9LCB3LmJveCA9IEUsIChTIHx8IFQpICYmIChuID0gdyksIEU7XG4gICAgfShfLCBtLCBmKTtcbiAgICBfLmhpZGRlbiB8fCBzKCEwKSwgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChrKTtcbiAgICB2YXIgeCA9IE1hdGguYWJzKE1hdGguZmxvb3IoKCh3aW5kb3cuaW5uZXJXaWR0aCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQub2Zmc2V0V2lkdGgpIC0gay5vZmZzZXRXaWR0aCkgLyAyKSksICQgPSBNYXRoLmFicyhNYXRoLmZsb29yKCgod2luZG93LmlubmVySGVpZ2h0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5vZmZzZXRIZWlnaHQpIC0gay5vZmZzZXRIZWlnaHQpIC8gMikpO1xuICAgIHJldHVybiBfLnBvc2l0aW9uID09IFwidG9wXCIgPyBrLnN0eWxlLnRvcCA9IFwiLTNweFwiIDogay5zdHlsZS50b3AgPSAkICsgXCJweFwiLCBrLnN0eWxlLmxlZnQgPSB4ICsgXCJweFwiLCBrLm9ua2V5ZG93biA9IGEsIHkuZm9jdXMoayksIF8uaGlkZGVuICYmIHkuaGlkZShrKSwgdC5jYWxsRXZlbnQoXCJvbk1lc3NhZ2VQb3B1cFwiLCBba10pLCBrO1xuICB9XG4gIGZ1bmN0aW9uIGMoXykge1xuICAgIHJldHVybiBkKF8sICEwLCAhMSk7XG4gIH1cbiAgZnVuY3Rpb24gdShfKSB7XG4gICAgcmV0dXJuIGQoXywgITAsICEwKTtcbiAgfVxuICBmdW5jdGlvbiBoKF8pIHtcbiAgICByZXR1cm4gZChfKTtcbiAgfVxuICBmdW5jdGlvbiBnKF8sIG0sIGYpIHtcbiAgICByZXR1cm4gdHlwZW9mIF8gIT0gXCJvYmplY3RcIiAmJiAodHlwZW9mIG0gPT0gXCJmdW5jdGlvblwiICYmIChmID0gbSwgbSA9IFwiXCIpLCBfID0geyB0ZXh0OiBfLCB0eXBlOiBtLCBjYWxsYmFjazogZiB9KSwgXztcbiAgfVxuICBmdW5jdGlvbiBwKF8sIG0sIGYsIGspIHtcbiAgICByZXR1cm4gdHlwZW9mIF8gIT0gXCJvYmplY3RcIiAmJiAoXyA9IHsgdGV4dDogXywgdHlwZTogbSwgZXhwaXJlOiBmLCBpZDogayB9KSwgXy5pZCA9IF8uaWQgfHwgc3QoKSwgXy5leHBpcmUgPSBfLmV4cGlyZSB8fCB2LmV4cGlyZSwgXztcbiAgfVxuICB0LmV2ZW50KHIsIFwia2V5ZG93blwiLCBhLCAhMCk7XG4gIHZhciB5ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIF8gPSBnLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIF8udHlwZSA9IF8udHlwZSB8fCBcImFsZXJ0XCIsIGgoXyk7XG4gIH07XG4gIHkuaGlkZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICBmb3IgKDsgXyAmJiBfLmdldEF0dHJpYnV0ZSAmJiAhXy5nZXRBdHRyaWJ1dGUoZSk7ICkgXyA9IF8ucGFyZW50Tm9kZTtcbiAgICBfICYmIChfLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoXyksIHMoITEpLCB0LmNhbGxFdmVudChcIm9uQWZ0ZXJNZXNzYWdlUG9wdXBcIiwgW19dKSk7XG4gIH0sIHkuZm9jdXMgPSBmdW5jdGlvbihfKSB7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIHZhciBtID0gTHQoXyk7XG4gICAgICBtLmxlbmd0aCAmJiBtWzBdLmZvY3VzICYmIG1bMF0uZm9jdXMoKTtcbiAgICB9LCAxKTtcbiAgfTtcbiAgdmFyIHYgPSBmdW5jdGlvbihfLCBtLCBmLCBrKSB7XG4gICAgc3dpdGNoICgoXyA9IHAuYXBwbHkodGhpcywgYXJndW1lbnRzKSkudHlwZSA9IF8udHlwZSB8fCBcImluZm9cIiwgXy50eXBlLnNwbGl0KFwiLVwiKVswXSkge1xuICAgICAgY2FzZSBcImFsZXJ0XCI6XG4gICAgICAgIHJldHVybiBjKF8pO1xuICAgICAgY2FzZSBcImNvbmZpcm1cIjpcbiAgICAgICAgcmV0dXJuIHUoXyk7XG4gICAgICBjYXNlIFwibW9kYWxib3hcIjpcbiAgICAgICAgcmV0dXJuIGgoXyk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oeCkge1xuICAgICAgICAgIHYuYXJlYSB8fCAodi5hcmVhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSwgdi5hcmVhLmNsYXNzTmFtZSA9IFwiZ2FudHRfbWVzc2FnZV9hcmVhXCIsIHYuYXJlYS5zdHlsZVt2LnBvc2l0aW9uXSA9IFwiNXB4XCIsIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodi5hcmVhKSksIHYuaGlkZSh4LmlkKTtcbiAgICAgICAgICB2YXIgJCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgcmV0dXJuICQuaW5uZXJIVE1MID0gXCI8ZGl2PlwiICsgeC50ZXh0ICsgXCI8L2Rpdj5cIiwgJC5jbGFzc05hbWUgPSBcImdhbnR0LWluZm8gZ2FudHQtXCIgKyB4LnR5cGUsICQub25jbGljayA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdi5oaWRlKHguaWQpLCB4ID0gbnVsbDtcbiAgICAgICAgICB9LCB0Ll93YWlBcmlhLm1lc3NhZ2VJbmZvQXR0cigkKSwgdi5wb3NpdGlvbiA9PSBcImJvdHRvbVwiICYmIHYuYXJlYS5maXJzdENoaWxkID8gdi5hcmVhLmluc2VydEJlZm9yZSgkLCB2LmFyZWEuZmlyc3RDaGlsZCkgOiB2LmFyZWEuYXBwZW5kQ2hpbGQoJCksIHguZXhwaXJlID4gMCAmJiAodi50aW1lcnNbeC5pZF0gPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHYgJiYgdi5oaWRlKHguaWQpO1xuICAgICAgICAgIH0sIHguZXhwaXJlKSksIHYucHVsbFt4LmlkXSA9ICQsICQgPSBudWxsLCB4LmlkO1xuICAgICAgICB9KF8pO1xuICAgIH1cbiAgfTtcbiAgdi5zZWVkID0gKC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpKS52YWx1ZU9mKCksIHYudWlkID0gc3QsIHYuZXhwaXJlID0gNGUzLCB2LmtleWJvYXJkID0gITAsIHYucG9zaXRpb24gPSBcInRvcFwiLCB2LnB1bGwgPSB7fSwgdi50aW1lcnMgPSB7fSwgdi5oaWRlQWxsID0gZnVuY3Rpb24oKSB7XG4gICAgZm9yICh2YXIgXyBpbiB2LnB1bGwpIHYuaGlkZShfKTtcbiAgfSwgdi5oaWRlID0gZnVuY3Rpb24oXykge1xuICAgIHZhciBtID0gdi5wdWxsW19dO1xuICAgIG0gJiYgbS5wYXJlbnROb2RlICYmICh3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIG0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChtKSwgbSA9IG51bGw7XG4gICAgfSwgMmUzKSwgbS5jbGFzc05hbWUgKz0gXCIgaGlkZGVuXCIsIHYudGltZXJzW19dICYmIHdpbmRvdy5jbGVhclRpbWVvdXQodi50aW1lcnNbX10pLCBkZWxldGUgdi5wdWxsW19dKTtcbiAgfTtcbiAgdmFyIGIgPSBbXTtcbiAgcmV0dXJuIHQuYXR0YWNoRXZlbnQoXCJvbk1lc3NhZ2VQb3B1cFwiLCBmdW5jdGlvbihfKSB7XG4gICAgYi5wdXNoKF8pO1xuICB9KSwgdC5hdHRhY2hFdmVudChcIm9uQWZ0ZXJNZXNzYWdlUG9wdXBcIiwgZnVuY3Rpb24oXykge1xuICAgIGZvciAodmFyIG0gPSAwOyBtIDwgYi5sZW5ndGg7IG0rKykgYlttXSA9PT0gXyAmJiAoYi5zcGxpY2UobSwgMSksIG0tLSk7XG4gIH0pLCB0LmF0dGFjaEV2ZW50KFwib25EZXN0cm95XCIsIGZ1bmN0aW9uKCkge1xuICAgIHMuY292ZXIgJiYgcy5jb3Zlci5wYXJlbnROb2RlICYmIHMuY292ZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzLmNvdmVyKTtcbiAgICBmb3IgKHZhciBfID0gMDsgXyA8IGIubGVuZ3RoOyBfKyspIGJbX10ucGFyZW50Tm9kZSAmJiBiW19dLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYltfXSk7XG4gICAgYiA9IG51bGwsIHYuYXJlYSAmJiB2LmFyZWEucGFyZW50Tm9kZSAmJiB2LmFyZWEucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh2LmFyZWEpLCB2ID0gbnVsbDtcbiAgfSksIHsgYWxlcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBfID0gZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiBfLnR5cGUgPSBfLnR5cGUgfHwgXCJjb25maXJtXCIsIGMoXyk7XG4gIH0sIGNvbmZpcm06IGZ1bmN0aW9uKCkge1xuICAgIHZhciBfID0gZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiBfLnR5cGUgPSBfLnR5cGUgfHwgXCJhbGVydFwiLCB1KF8pO1xuICB9LCBtZXNzYWdlOiB2LCBtb2RhbGJveDogeSB9O1xufVxuZnVuY3Rpb24gemUodCwgZSkge1xuICB2YXIgbiA9IHRoaXMuJGNvbmZpZ1t0XTtcbiAgcmV0dXJuIG4gPyAobi4kZXh0ZW5kZWRDb25maWcgfHwgKG4uJGV4dGVuZGVkQ29uZmlnID0gITAsIE9iamVjdC5zZXRQcm90b3R5cGVPZihuLCBlKSksIG4pIDogZTtcbn1cbmZ1bmN0aW9uIG9hKHQsIGUpIHtcbiAgdmFyIG4sIGksIGE7XG4gIFAodCwgKG4gPSBlLCB7ICRnZXRDb25maWc6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBpIHx8IChpID0gbiA/IG4uJGdldENvbmZpZygpIDogdGhpcy4kZ2FudHQuY29uZmlnKSwgdGhpcy4kY29uZmlnLmNvbmZpZyA/IHplLmNhbGwodGhpcywgXCJjb25maWdcIiwgaSkgOiBpO1xuICB9LCAkZ2V0VGVtcGxhdGVzOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gYSB8fCAoYSA9IG4gPyBuLiRnZXRUZW1wbGF0ZXMoKSA6IHRoaXMuJGdhbnR0LnRlbXBsYXRlcyksIHRoaXMuJGNvbmZpZy50ZW1wbGF0ZXMgPyB6ZS5jYWxsKHRoaXMsIFwidGVtcGxhdGVzXCIsIGEpIDogYTtcbiAgfSB9KSk7XG59XG5jb25zdCBsYSA9IGZ1bmN0aW9uKHQpIHtcbiAgdmFyIGUgPSB7fSwgbiA9IHt9O1xuICBmdW5jdGlvbiBpKGEsIHIsIHMsIG8pIHtcbiAgICB2YXIgbCA9IGVbYV07XG4gICAgaWYgKCFsIHx8ICFsLmNyZWF0ZSkgcmV0dXJuICExO1xuICAgIGEgIT0gXCJyZXNpemVyXCIgfHwgcy5tb2RlIHx8IChvLiRjb25maWcuY29scyA/IHMubW9kZSA9IFwieFwiIDogcy5tb2RlID0gXCJ5XCIpLCBhICE9IFwidmlld2NlbGxcIiB8fCBzLnZpZXcgIT0gXCJzY3JvbGxiYXJcIiB8fCBzLnNjcm9sbCB8fCAoby4kY29uZmlnLmNvbHMgPyBzLnNjcm9sbCA9IFwieVwiIDogcy5zY3JvbGwgPSBcInhcIiksIChzID0gcShzKSkuaWQgfHwgbltzLnZpZXddIHx8IChzLmlkID0gcy52aWV3KSwgcy5pZCAmJiAhcy5jc3MgJiYgKHMuY3NzID0gcy5pZCArIFwiX2NlbGxcIik7XG4gICAgdmFyIGQgPSBuZXcgbC5jcmVhdGUociwgcywgdGhpcywgdCk7XG4gICAgcmV0dXJuIGwuY29uZmlndXJlICYmIGwuY29uZmlndXJlKGQpLCBvYShkLCBvKSwgZC4kaWQgfHwgKGQuJGlkID0gcy5pZCB8fCB0LnVpZCgpKSwgZC4kcGFyZW50IHx8IHR5cGVvZiByICE9IFwib2JqZWN0XCIgfHwgKGQuJHBhcmVudCA9IHIpLCBkLiRjb25maWcgfHwgKGQuJGNvbmZpZyA9IHMpLCBuW2QuJGlkXSAmJiAoZC4kaWQgPSB0LnVpZCgpKSwgbltkLiRpZF0gPSBkLCBkO1xuICB9XG4gIHJldHVybiB7IGluaXRVSTogZnVuY3Rpb24oYSwgcikge1xuICAgIHZhciBzID0gXCJjZWxsXCI7XG4gICAgcmV0dXJuIGEudmlldyA/IHMgPSBcInZpZXdjZWxsXCIgOiBhLnJlc2l6ZXIgPyBzID0gXCJyZXNpemVyXCIgOiBhLnJvd3MgfHwgYS5jb2xzID8gcyA9IFwibGF5b3V0XCIgOiBhLnZpZXdzICYmIChzID0gXCJtdWx0aXZpZXdcIiksIGkuY2FsbCh0aGlzLCBzLCBudWxsLCBhLCByKTtcbiAgfSwgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgIG4gPSB7fTtcbiAgfSwgcmVnaXN0ZXJWaWV3OiBmdW5jdGlvbihhLCByLCBzKSB7XG4gICAgZVthXSA9IHsgY3JlYXRlOiByLCBjb25maWd1cmU6IHMgfTtcbiAgfSwgY3JlYXRlVmlldzogaSwgZ2V0VmlldzogZnVuY3Rpb24oYSkge1xuICAgIHJldHVybiBuW2FdO1xuICB9IH07XG59O1xudmFyIGRhID0gLyogQF9fUFVSRV9fICovIGZ1bmN0aW9uKHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgbiA9IHsgY2xpY2s6IHt9LCBkb3VibGVjbGljazoge30sIGNvbnRleHRNZW51OiB7fSB9O1xuICAgIGZ1bmN0aW9uIGkoaCwgZywgcCwgeSkge1xuICAgICAgbltoXVtnXSB8fCAobltoXVtnXSA9IFtdKSwgbltoXVtnXS5wdXNoKHsgaGFuZGxlcjogcCwgcm9vdDogeSB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYShoKSB7XG4gICAgICBoID0gaCB8fCB3aW5kb3cuZXZlbnQ7XG4gICAgICB2YXIgZyA9IGUubG9jYXRlKGgpLCBwID0gcyhoLCBuLmNsaWNrKSwgeSA9ICEwO1xuICAgICAgaWYgKGcgIT09IG51bGwgPyB5ID0gIWUuY2hlY2tFdmVudChcIm9uVGFza0NsaWNrXCIpIHx8IGUuY2FsbEV2ZW50KFwib25UYXNrQ2xpY2tcIiwgW2csIGhdKSA6IGUuY2FsbEV2ZW50KFwib25FbXB0eUNsaWNrXCIsIFtoXSksIHkpIHtcbiAgICAgICAgaWYgKCFvKHAsIGgsIGcpKSByZXR1cm47XG4gICAgICAgIHN3aXRjaCAoaC50YXJnZXQubm9kZU5hbWUpIHtcbiAgICAgICAgICBjYXNlIFwiU0VMRUNUXCI6XG4gICAgICAgICAgY2FzZSBcIklOUFVUXCI6XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZyAmJiBlLmdldFRhc2soZykgJiYgIWUuX211bHRpc2VsZWN0ICYmIGUuY29uZmlnLnNlbGVjdF90YXNrICYmIGUuc2VsZWN0VGFzayhnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcihoKSB7XG4gICAgICB2YXIgZyA9IChoID0gaCB8fCB3aW5kb3cuZXZlbnQpLnRhcmdldCB8fCBoLnNyY0VsZW1lbnQsIHAgPSBlLmxvY2F0ZShnKSwgeSA9IGUubG9jYXRlKGcsIGUuY29uZmlnLmxpbmtfYXR0cmlidXRlKSwgdiA9ICFlLmNoZWNrRXZlbnQoXCJvbkNvbnRleHRNZW51XCIpIHx8IGUuY2FsbEV2ZW50KFwib25Db250ZXh0TWVudVwiLCBbcCwgeSwgaF0pO1xuICAgICAgcmV0dXJuIHYgfHwgKGgucHJldmVudERlZmF1bHQgPyBoLnByZXZlbnREZWZhdWx0KCkgOiBoLnJldHVyblZhbHVlID0gITEpLCB2O1xuICAgIH1cbiAgICBmdW5jdGlvbiBzKGgsIGcpIHtcbiAgICAgIGZvciAodmFyIHAgPSBoLnRhcmdldCB8fCBoLnNyY0VsZW1lbnQsIHkgPSBbXTsgcDsgKSB7XG4gICAgICAgIHZhciB2ID0gdC5nZXRDbGFzc05hbWUocCk7XG4gICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgdiA9IHYuc3BsaXQoXCIgXCIpO1xuICAgICAgICAgIGZvciAodmFyIGIgPSAwOyBiIDwgdi5sZW5ndGg7IGIrKykgaWYgKHZbYl0gJiYgZ1t2W2JdXSkgZm9yICh2YXIgXyA9IGdbdltiXV0sIG0gPSAwOyBtIDwgXy5sZW5ndGg7IG0rKykgX1ttXS5yb290ICYmICF0LmlzQ2hpbGRPZihwLCBfW21dLnJvb3QpIHx8IHkucHVzaChfW21dLmhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICAgIHAgPSBwLnBhcmVudE5vZGU7XG4gICAgICB9XG4gICAgICByZXR1cm4geTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbyhoLCBnLCBwKSB7XG4gICAgICBmb3IgKHZhciB5ID0gITAsIHYgPSAwOyB2IDwgaC5sZW5ndGg7IHYrKykge1xuICAgICAgICB2YXIgYiA9IGhbdl0uY2FsbChlLCBnLCBwLCBnLnRhcmdldCB8fCBnLnNyY0VsZW1lbnQpO1xuICAgICAgICB5ID0geSAmJiAhKGIgIT09IHZvaWQgMCAmJiBiICE9PSAhMCk7XG4gICAgICB9XG4gICAgICByZXR1cm4geTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbChoKSB7XG4gICAgICBoID0gaCB8fCB3aW5kb3cuZXZlbnQ7XG4gICAgICB2YXIgZyA9IGUubG9jYXRlKGgpLCBwID0gcyhoLCBuLmRvdWJsZWNsaWNrKSwgeSA9ICFlLmNoZWNrRXZlbnQoXCJvblRhc2tEYmxDbGlja1wiKSB8fCBnID09PSBudWxsIHx8IGUuY2FsbEV2ZW50KFwib25UYXNrRGJsQ2xpY2tcIiwgW2csIGhdKTtcbiAgICAgIGlmICh5KSB7XG4gICAgICAgIGlmICghbyhwLCBoLCBnKSkgcmV0dXJuO1xuICAgICAgICBnICE9PSBudWxsICYmIGUuZ2V0VGFzayhnKSAmJiB5ICYmIGUuY29uZmlnLmRldGFpbHNfb25fZGJsY2xpY2sgJiYgIWUuaXNSZWFkb25seShnKSAmJiBlLnNob3dMaWdodGJveChnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZChoKSB7XG4gICAgICBpZiAoZS5jaGVja0V2ZW50KFwib25Nb3VzZU1vdmVcIikpIHtcbiAgICAgICAgdmFyIGcgPSBlLmxvY2F0ZShoKTtcbiAgICAgICAgZS5fbGFzdF9tb3ZlX2V2ZW50ID0gaCwgZS5jYWxsRXZlbnQoXCJvbk1vdXNlTW92ZVwiLCBbZywgaF0pO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgYyA9IGUuX2NyZWF0ZURvbUV2ZW50U2NvcGUoKTtcbiAgICBmdW5jdGlvbiB1KGgpIHtcbiAgICAgIGMuZGV0YWNoQWxsKCksIGggJiYgKGMuYXR0YWNoKGgsIFwiY2xpY2tcIiwgYSksIGMuYXR0YWNoKGgsIFwiZGJsY2xpY2tcIiwgbCksIGMuYXR0YWNoKGgsIFwibW91c2Vtb3ZlXCIsIGQpLCBjLmF0dGFjaChoLCBcImNvbnRleHRtZW51XCIsIHIpKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgcmVzZXQ6IHUsIGdsb2JhbDogZnVuY3Rpb24oaCwgZywgcCkge1xuICAgICAgaShoLCBnLCBwLCBudWxsKTtcbiAgICB9LCBkZWxlZ2F0ZTogaSwgZGV0YWNoOiBmdW5jdGlvbihoLCBnLCBwLCB5KSB7XG4gICAgICBpZiAobltoXSAmJiBuW2hdW2ddKSB7XG4gICAgICAgIGZvciAodmFyIHYgPSBuW2hdLCBiID0gdltnXSwgXyA9IDA7IF8gPCBiLmxlbmd0aDsgXysrKSBiW19dLnJvb3QgPT0geSAmJiAoYi5zcGxpY2UoXywgMSksIF8tLSk7XG4gICAgICAgIGIubGVuZ3RoIHx8IGRlbGV0ZSB2W2ddO1xuICAgICAgfVxuICAgIH0sIGNhbGxIYW5kbGVyOiBmdW5jdGlvbihoLCBnLCBwLCB5KSB7XG4gICAgICB2YXIgdiA9IG5baF1bZ107XG4gICAgICBpZiAodikgZm9yICh2YXIgYiA9IDA7IGIgPCB2Lmxlbmd0aDsgYisrKSAocCB8fCB2W2JdLnJvb3QpICYmIHZbYl0ucm9vdCAhPT0gcCB8fCB2W2JdLmhhbmRsZXIuYXBwbHkodGhpcywgeSk7XG4gICAgfSwgb25Eb3VibGVDbGljazogbCwgb25Nb3VzZU1vdmU6IGQsIG9uQ29udGV4dE1lbnU6IHIsIG9uQ2xpY2s6IGEsIGRlc3RydWN0b3I6IGZ1bmN0aW9uKCkge1xuICAgICAgdSgpLCBuID0gbnVsbCwgYyA9IG51bGw7XG4gICAgfSB9O1xuICB9O1xufShybik7XG5jb25zdCBjYSA9IHsgaW5pdDogZGEgfTtcbmZ1bmN0aW9uIFdlKHQsIGUsIG4pIHtcbiAgcmV0dXJuICEhZSAmJiAhKGUubGVmdCA+IHQueF9lbmQgfHwgZS5sZWZ0ICsgZS53aWR0aCA8IHQueCkgJiYgIShlLnRvcCA+IHQueV9lbmQgfHwgZS50b3AgKyBlLmhlaWdodCA8IHQueSk7XG59XG5mdW5jdGlvbiBOdCh0KSB7XG4gIHJldHVybiB0LmNvbmZpZy5zbWFydF9yZW5kZXJpbmcgJiYgdC5fc21hcnRfcmVuZGVyO1xufVxuZnVuY3Rpb24gS3QodCwgZSwgbikge1xuICByZXR1cm4geyB0b3A6IGUuZ2V0SXRlbVRvcCh0LmlkKSwgaGVpZ2h0OiBlLmdldEl0ZW1IZWlnaHQodC5pZCksIGxlZnQ6IDAsIHJpZ2h0OiAxIC8gMCB9O1xufVxuZnVuY3Rpb24gZnQodCwgZSwgbiwgaSwgYSkge1xuICB2YXIgciA9IGUuZ2V0SXRlbUluZGV4QnlUb3BQb3NpdGlvbihhLnkpIHx8IDAsIHMgPSBlLmdldEl0ZW1JbmRleEJ5VG9wUG9zaXRpb24oYS55X2VuZCkgfHwgaS5jb3VudCgpLCBvID0gTWF0aC5tYXgoMCwgciAtIDEpLCBsID0gTWF0aC5taW4oaS5jb3VudCgpLCBzICsgMSk7XG4gIGNvbnN0IGQgPSBbXTtcbiAgaWYgKHQuY29uZmlnLmtleWJvYXJkX25hdmlnYXRpb24gJiYgdC5nZXRTZWxlY3RlZElkKCkgJiYgdC5nZXRUYXNrKHQuZ2V0U2VsZWN0ZWRJZCgpKS4kZXhwYW5kZWRfYnJhbmNoICYmIGQucHVzaCh0LmdldFNlbGVjdGVkSWQoKSksIHQuJHVpLmdldFZpZXcoXCJncmlkXCIpICYmIHQuZXh0LmlubGluZUVkaXRvcnMgJiYgdC5leHQuaW5saW5lRWRpdG9ycy5nZXRTdGF0ZSgpLmlkKSB7XG4gICAgbGV0IGMgPSB0LmV4dC5pbmxpbmVFZGl0b3JzLmdldFN0YXRlKCkuaWQ7XG4gICAgaS5leGlzdHMoYykgJiYgZC5wdXNoKGMpO1xuICB9XG4gIHJldHVybiB7IHN0YXJ0OiBvLCBlbmQ6IGwsIGlkczogZCB9O1xufVxudmFyIHVhID0gZnVuY3Rpb24odCkge1xuICB2YXIgZSA9IC8qIEBfX1BVUkVfXyAqLyBmdW5jdGlvbihuKSB7XG4gICAgdmFyIGkgPSB7fSwgYSA9IHt9O1xuICAgIGZ1bmN0aW9uIHIobykge1xuICAgICAgdmFyIGwgPSBudWxsO1xuICAgICAgcmV0dXJuIHR5cGVvZiBvLnZpZXcgPT0gXCJzdHJpbmdcIiA/IGwgPSBuLiR1aS5nZXRWaWV3KG8udmlldykgOiBvLnZpZXcgJiYgKGwgPSBvLnZpZXcpLCBsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzKG8sIGwsIGQpIHtcbiAgICAgIGlmIChhW29dKSByZXR1cm4gYVtvXTtcbiAgICAgIGwucmVuZGVyZXIgfHwgbi5hc3NlcnQoITEsIFwiSW52YWxpZCByZW5kZXJlciBjYWxsXCIpO1xuICAgICAgdmFyIGMgPSBudWxsLCB1ID0gbnVsbCwgaCA9IG51bGwsIGcgPSBudWxsLCBwID0gbnVsbDtcbiAgICAgIHR5cGVvZiBsLnJlbmRlcmVyID09IFwiZnVuY3Rpb25cIiA/IChjID0gbC5yZW5kZXJlciwgaCA9IEt0KSA6IChjID0gbC5yZW5kZXJlci5yZW5kZXIsIHUgPSBsLnJlbmRlcmVyLnVwZGF0ZSwgZyA9IGwucmVuZGVyZXIub25yZW5kZXIsIGwucmVuZGVyZXIuaXNJblZpZXdQb3J0ID8gcCA9IGwucmVuZGVyZXIuaXNJblZpZXdQb3J0IDogaCA9IGwucmVuZGVyZXIuZ2V0UmVjdGFuZ2xlLCBoIHx8IGggPT09IG51bGwgfHwgKGggPSBLdCkpO1xuICAgICAgdmFyIHkgPSBsLmZpbHRlcjtcbiAgICAgIHJldHVybiBkICYmIGQuc2V0QXR0cmlidXRlKG4uY29uZmlnLmxheWVyX2F0dHJpYnV0ZSwgITApLCBhW29dID0geyByZW5kZXJfaXRlbTogZnVuY3Rpb24odiwgYiwgXywgbSwgZikge1xuICAgICAgICBpZiAoYiA9IGIgfHwgZCwgIXkgfHwgeSh2KSkge1xuICAgICAgICAgIHZhciBrID0gbSB8fCByKGwpLCB4ID0gZiB8fCAoayA/IGsuJGdldENvbmZpZygpIDogbnVsbCksICQgPSBfO1xuICAgICAgICAgICEkICYmIHggJiYgeC5zbWFydF9yZW5kZXJpbmcgJiYgKCQgPSBrLmdldFZpZXdQb3J0KCkpO1xuICAgICAgICAgIHZhciB3ID0gbnVsbDtcbiAgICAgICAgICAhTnQobikgJiYgKGggfHwgcCkgJiYgJCA/IChwID8gcCh2LCAkLCBrLCB4LCBuKSA6IFdlKCQsIGgodiwgaywgeCwgbikpKSAmJiAodyA9IGMuY2FsbChuLCB2LCBrLCB4LCAkKSkgOiB3ID0gYy5jYWxsKG4sIHYsIGssIHgsICQpLCB0aGlzLmFwcGVuZCh2LCB3LCBiKTtcbiAgICAgICAgICB2YXIgUyA9IGIubm9kZVR5cGUgPT0gMTE7XG4gICAgICAgICAgZyAmJiAhUyAmJiB3ICYmIGcuY2FsbChuLCB2LCB3LCBrKTtcbiAgICAgICAgfSBlbHNlIHRoaXMucmVtb3ZlX2l0ZW0odi5pZCk7XG4gICAgICB9LCBjbGVhcjogZnVuY3Rpb24odikge1xuICAgICAgICB0aGlzLnJlbmRlcmVkID0gaVtvXSA9IHt9LCBsLmFwcGVuZCB8fCB0aGlzLmNsZWFyX2NvbnRhaW5lcih2KTtcbiAgICAgIH0sIGNsZWFyX2NvbnRhaW5lcjogZnVuY3Rpb24odikge1xuICAgICAgICAodiA9IHYgfHwgZCkgJiYgKHYuaW5uZXJIVE1MID0gXCJcIik7XG4gICAgICB9LCBnZXRfdmlzaWJsZV9yYW5nZTogZnVuY3Rpb24odikge1xuICAgICAgICB2YXIgYiwgXywgbSA9IHIobCksIGYgPSBtID8gbS4kZ2V0Q29uZmlnKCkgOiBudWxsO1xuICAgICAgICByZXR1cm4gZiAmJiBmLnNtYXJ0X3JlbmRlcmluZyAmJiAoYiA9IG0uZ2V0Vmlld1BvcnQoKSksIG0gJiYgYiAmJiAodHlwZW9mIGwucmVuZGVyZXIgPT0gXCJmdW5jdGlvblwiID8gXyA9IGZ0KG4sIG0sIDAsIHYsIGIpIDogbC5yZW5kZXJlciAmJiBsLnJlbmRlcmVyLmdldFZpc2libGVSYW5nZSAmJiAoXyA9IGwucmVuZGVyZXIuZ2V0VmlzaWJsZVJhbmdlKG4sIG0sIGYsIHYsIGIpKSksIF8gfHwgKF8gPSB7IHN0YXJ0OiAwLCBlbmQ6IHYuY291bnQoKSB9KSwgXztcbiAgICAgIH0sIHByZXBhcmVfZGF0YTogZnVuY3Rpb24odikge1xuICAgICAgICBpZiAobC5yZW5kZXJlciAmJiBsLnJlbmRlcmVyLnByZXBhcmVEYXRhKSByZXR1cm4gbC5yZW5kZXJlci5wcmVwYXJlRGF0YSh2LCBuLCBsKTtcbiAgICAgIH0sIHJlbmRlcl9pdGVtczogZnVuY3Rpb24odiwgYikge1xuICAgICAgICBiID0gYiB8fCBkO1xuICAgICAgICB2YXIgXyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgICAgdGhpcy5jbGVhcihiKTtcbiAgICAgICAgdmFyIG0gPSBudWxsLCBmID0gcihsKSwgayA9IGYgPyBmLiRnZXRDb25maWcoKSA6IG51bGw7XG4gICAgICAgIGsgJiYgay5zbWFydF9yZW5kZXJpbmcgJiYgKG0gPSBmLmdldFZpZXdQb3J0KCkpO1xuICAgICAgICBmb3IgKHZhciB4ID0gMCwgJCA9IHYubGVuZ3RoOyB4IDwgJDsgeCsrKSB0aGlzLnJlbmRlcl9pdGVtKHZbeF0sIF8sIG0sIGYsIGspO1xuICAgICAgICBiLmFwcGVuZENoaWxkKF8sIGIpO1xuICAgICAgICB2YXIgdyA9IHt9O1xuICAgICAgICB2LmZvckVhY2goZnVuY3Rpb24oRSkge1xuICAgICAgICAgIHdbRS5pZF0gPSBFO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIFMgPSB7fTtcbiAgICAgICAgaWYgKGcpIHtcbiAgICAgICAgICB2YXIgVCA9IHt9O1xuICAgICAgICAgIGZvciAodmFyIHggaW4gdGhpcy5yZW5kZXJlZCkgU1t4XSB8fCAoVFt4XSA9IHRoaXMucmVuZGVyZWRbeF0sIGcuY2FsbChuLCB3W3hdLCB0aGlzLnJlbmRlcmVkW3hdLCBmKSk7XG4gICAgICAgIH1cbiAgICAgIH0sIHVwZGF0ZV9pdGVtczogZnVuY3Rpb24odiwgYikge1xuICAgICAgICB2YXIgXyA9IHIobCksIG0gPSBfID8gXy4kZ2V0Q29uZmlnKCkgOiBudWxsO1xuICAgICAgICBpZiAoXyAmJiBfLiRnZXRDb25maWcoKS5zbWFydF9yZW5kZXJpbmcgJiYgIU50KG4pICYmIHRoaXMucmVuZGVyZWQgJiYgKGggfHwgcCkpIHtcbiAgICAgICAgICBiID0gYiB8fCBkO1xuICAgICAgICAgIHZhciBmID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLCBrID0gbnVsbDtcbiAgICAgICAgICBfICYmIChrID0gXy5nZXRWaWV3UG9ydCgpKTtcbiAgICAgICAgICB2YXIgeCA9IHt9O1xuICAgICAgICAgIHYuZm9yRWFjaChmdW5jdGlvbihJKSB7XG4gICAgICAgICAgICB4W0kuaWRdID0gSTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgJCA9IHt9LCB3ID0ge307XG4gICAgICAgICAgZm9yICh2YXIgUyBpbiB0aGlzLnJlbmRlcmVkKSB3W1NdID0gITAsICRbU10gPSAhMDtcbiAgICAgICAgICBmb3IgKHZhciBUID0ge30sIEUgPSAoUyA9IDAsIHYubGVuZ3RoKTsgUyA8IEU7IFMrKykge1xuICAgICAgICAgICAgdmFyIEMgPSB2W1NdLCBEID0gdGhpcy5yZW5kZXJlZFtDLmlkXTtcbiAgICAgICAgICAgIHdbQy5pZF0gPSAhMSwgRCAmJiBELnBhcmVudE5vZGUgPyAocCA/IHAoQywgaywgXywgbSwgbikgOiBXZShrLCBoKEMsIF8sIG0sIG4pKSkgPyAodSAmJiB1LmNhbGwobiwgQywgRCwgXywgbSwgayksIHRoaXMucmVzdG9yZShDLCBmKSkgOiB3W0MuaWRdID0gITAgOiAoVFt2W1NdLmlkXSA9ICEwLCB0aGlzLnJlbmRlcl9pdGVtKHZbU10sIGYsIGssIF8sIG0pKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yICh2YXIgUyBpbiB3KSB3W1NdICYmIHRoaXMuaGlkZShTKTtcbiAgICAgICAgICBpZiAoZi5jaGlsZE5vZGVzLmxlbmd0aCAmJiBiLmFwcGVuZENoaWxkKGYsIGIpLCBnKSB7XG4gICAgICAgICAgICB2YXIgTSA9IHt9O1xuICAgICAgICAgICAgZm9yICh2YXIgUyBpbiB0aGlzLnJlbmRlcmVkKSAkW1NdICYmICFUW1NdIHx8IChNW1NdID0gdGhpcy5yZW5kZXJlZFtTXSwgZy5jYWxsKG4sIHhbU10sIHRoaXMucmVuZGVyZWRbU10sIF8pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIGFwcGVuZDogZnVuY3Rpb24odiwgYiwgXykge1xuICAgICAgICB0aGlzLnJlbmRlcmVkICYmIChiID8gKHRoaXMucmVuZGVyZWRbdi5pZF0gJiYgdGhpcy5yZW5kZXJlZFt2LmlkXS5wYXJlbnROb2RlID8gdGhpcy5yZXBsYWNlX2l0ZW0odi5pZCwgYikgOiBfLmFwcGVuZENoaWxkKGIpLCB0aGlzLnJlbmRlcmVkW3YuaWRdID0gYikgOiB0aGlzLnJlbmRlcmVkW3YuaWRdICYmIHRoaXMucmVtb3ZlX2l0ZW0odi5pZCkpO1xuICAgICAgfSwgcmVwbGFjZV9pdGVtOiBmdW5jdGlvbih2LCBiKSB7XG4gICAgICAgIHZhciBfID0gdGhpcy5yZW5kZXJlZFt2XTtcbiAgICAgICAgXyAmJiBfLnBhcmVudE5vZGUgJiYgXy5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChiLCBfKSwgdGhpcy5yZW5kZXJlZFt2XSA9IGI7XG4gICAgICB9LCByZW1vdmVfaXRlbTogZnVuY3Rpb24odikge1xuICAgICAgICB0aGlzLmhpZGUodiksIGRlbGV0ZSB0aGlzLnJlbmRlcmVkW3ZdO1xuICAgICAgfSwgaGlkZTogZnVuY3Rpb24odikge1xuICAgICAgICB2YXIgYiA9IHRoaXMucmVuZGVyZWRbdl07XG4gICAgICAgIGIgJiYgYi5wYXJlbnROb2RlICYmIGIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChiKSwgZGVsZXRlIHRoaXMucmVuZGVyZWRbdl07XG4gICAgICB9LCByZXN0b3JlOiBmdW5jdGlvbih2LCBiKSB7XG4gICAgICAgIHZhciBfID0gdGhpcy5yZW5kZXJlZFt2LmlkXTtcbiAgICAgICAgXyA/IF8ucGFyZW50Tm9kZSB8fCB0aGlzLmFwcGVuZCh2LCBfLCBiIHx8IGQpIDogdGhpcy5yZW5kZXJfaXRlbSh2LCBiIHx8IGQpO1xuICAgICAgfSwgY2hhbmdlX2lkOiBmdW5jdGlvbih2LCBiKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZWRbYl0gPSB0aGlzLnJlbmRlcmVkW3ZdLCBkZWxldGUgdGhpcy5yZW5kZXJlZFt2XTtcbiAgICAgIH0sIHJlbmRlcmVkOiBpW29dLCBub2RlOiBkLCBkZXN0cnVjdG9yOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5jbGVhcigpLCBkZWxldGUgYVtvXSwgZGVsZXRlIGlbb107XG4gICAgICB9IH0sIGFbb107XG4gICAgfVxuICAgIHJldHVybiB7IGdldFJlbmRlcmVyOiBzLCBjbGVhclJlbmRlcmVyczogZnVuY3Rpb24oKSB7XG4gICAgICBmb3IgKHZhciBvIGluIGEpIHMobykuZGVzdHJ1Y3RvcigpO1xuICAgIH0gfTtcbiAgfSh0KTtcbiAgcmV0dXJuIHsgY3JlYXRlR3JvdXA6IGZ1bmN0aW9uKG4sIGksIGEsIHIpIHtcbiAgICB2YXIgcyA9IHsgdGVtcENvbGxlY3Rpb246IFtdLCByZW5kZXJlcnM6IHt9LCBjb250YWluZXI6IG4sIGZpbHRlcnM6IFtdLCBnZXRMYXllcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fYWRkKCk7XG4gICAgICB2YXIgbyA9IFtdO1xuICAgICAgZm9yICh2YXIgbCBpbiB0aGlzLnJlbmRlcmVycykgby5wdXNoKHRoaXMucmVuZGVyZXJzW2xdKTtcbiAgICAgIHJldHVybiBvO1xuICAgIH0sIGdldExheWVyOiBmdW5jdGlvbihvKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJlcnNbb107XG4gICAgfSwgX2FkZDogZnVuY3Rpb24obykge1xuICAgICAgbyAmJiAoby5pZCA9IG8uaWQgfHwgc3QoKSwgdGhpcy50ZW1wQ29sbGVjdGlvbi5wdXNoKG8pKTtcbiAgICAgIGZvciAodmFyIGwgPSB0aGlzLmNvbnRhaW5lcigpLCBkID0gdGhpcy50ZW1wQ29sbGVjdGlvbiwgYyA9IDA7IGMgPCBkLmxlbmd0aDsgYysrKSBpZiAobyA9IGRbY10sIHRoaXMuY29udGFpbmVyKCkgfHwgbyAmJiBvLmNvbnRhaW5lciAmJiBZKG8uY29udGFpbmVyLCBkb2N1bWVudC5ib2R5KSkge1xuICAgICAgICB2YXIgdSA9IG8uY29udGFpbmVyLCBoID0gby5pZCwgZyA9IG8udG9wbW9zdDtcbiAgICAgICAgaWYgKCF1LnBhcmVudE5vZGUpIGlmIChnKSBsLmFwcGVuZENoaWxkKHUpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB2YXIgcCA9IGkgPyBpKCkgOiBsLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgcCAmJiBwLnBhcmVudE5vZGUgPT0gbCA/IGwuaW5zZXJ0QmVmb3JlKHUsIHApIDogbC5hcHBlbmRDaGlsZCh1KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbmRlcmVyc1toXSA9IGUuZ2V0UmVuZGVyZXIoaCwgbywgdSksIHIgJiYgcihvLCB0KSwgdGhpcy50ZW1wQ29sbGVjdGlvbi5zcGxpY2UoYywgMSksIGMtLTtcbiAgICAgIH1cbiAgICB9LCBhZGRMYXllcjogZnVuY3Rpb24obykge1xuICAgICAgaWYgKG8pIHtcbiAgICAgICAgdHlwZW9mIG8gPT0gXCJmdW5jdGlvblwiICYmIChvID0geyByZW5kZXJlcjogbyB9KSwgby5maWx0ZXIgPT09IHZvaWQgMCA/IG8uZmlsdGVyID0gamUoYSB8fCBbXSkgOiBvLmZpbHRlciBpbnN0YW5jZW9mIEFycmF5ICYmIChvLmZpbHRlci5wdXNoKGEpLCBvLmZpbHRlciA9IGplKG8uZmlsdGVyKSksIG8uY29udGFpbmVyIHx8IChvLmNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpO1xuICAgICAgICB2YXIgbCA9IHRoaXM7XG4gICAgICAgIG8ucmVxdWVzdFVwZGF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHQuY29uZmlnLnNtYXJ0X3JlbmRlcmluZyAmJiAhTnQodCkgJiYgbC5yZW5kZXJlcnNbby5pZF0gJiYgbC5vblVwZGF0ZVJlcXVlc3QobC5yZW5kZXJlcnNbby5pZF0pO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX2FkZChvKSwgbyA/IG8uaWQgOiB2b2lkIDA7XG4gICAgfSwgb25VcGRhdGVSZXF1ZXN0OiBmdW5jdGlvbihvKSB7XG4gICAgfSwgZWFjaExheWVyOiBmdW5jdGlvbihvKSB7XG4gICAgICBmb3IgKHZhciBsIGluIHRoaXMucmVuZGVyZXJzKSBvKHRoaXMucmVuZGVyZXJzW2xdKTtcbiAgICB9LCByZW1vdmVMYXllcjogZnVuY3Rpb24obykge1xuICAgICAgdGhpcy5yZW5kZXJlcnNbb10gJiYgKHRoaXMucmVuZGVyZXJzW29dLmRlc3RydWN0b3IoKSwgZGVsZXRlIHRoaXMucmVuZGVyZXJzW29dKTtcbiAgICB9LCBjbGVhcjogZnVuY3Rpb24oKSB7XG4gICAgICBmb3IgKHZhciBvIGluIHRoaXMucmVuZGVyZXJzKSB0aGlzLnJlbmRlcmVyc1tvXS5kZXN0cnVjdG9yKCk7XG4gICAgICB0aGlzLnJlbmRlcmVycyA9IHt9O1xuICAgIH0gfTtcbiAgICByZXR1cm4gdC5hdHRhY2hFdmVudChcIm9uRGVzdHJveVwiLCBmdW5jdGlvbigpIHtcbiAgICAgIHMuY2xlYXIoKSwgcyA9IG51bGw7XG4gICAgfSksIHM7XG4gIH0gfTtcbn07XG5mdW5jdGlvbiBqZSh0KSB7XG4gIHJldHVybiB0IGluc3RhbmNlb2YgQXJyYXkgfHwgKHQgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApKSwgZnVuY3Rpb24oZSkge1xuICAgIGZvciAodmFyIG4gPSAhMCwgaSA9IDAsIGEgPSB0Lmxlbmd0aDsgaSA8IGE7IGkrKykge1xuICAgICAgdmFyIHIgPSB0W2ldO1xuICAgICAgciAmJiAobiA9IG4gJiYgcihlLmlkLCBlKSAhPT0gITEpO1xuICAgIH1cbiAgICByZXR1cm4gbjtcbiAgfTtcbn1cbmZ1bmN0aW9uIEZlKHQsIGUsIG4pIHtcbiAgaWYgKCF0LnN0YXJ0X2RhdGUgfHwgIXQuZW5kX2RhdGUpIHJldHVybiBudWxsO1xuICB2YXIgaSA9IGUucG9zRnJvbURhdGUodC5zdGFydF9kYXRlKSwgYSA9IGUucG9zRnJvbURhdGUodC5lbmRfZGF0ZSksIHIgPSBNYXRoLm1pbihpLCBhKSAtIDIwMCwgcyA9IE1hdGgubWF4KGksIGEpICsgMjAwO1xuICByZXR1cm4geyB0b3A6IGUuZ2V0SXRlbVRvcCh0LmlkKSwgaGVpZ2h0OiBlLmdldEl0ZW1IZWlnaHQodC5pZCksIGxlZnQ6IHIsIHdpZHRoOiBzIC0gciB9O1xufVxuZnVuY3Rpb24gbW4oKSB7XG4gIHZhciB0ID0gW10sIGUgPSAhMTtcbiAgZnVuY3Rpb24gbigpIHtcbiAgICB0ID0gW10sIGUgPSAhMTtcbiAgfVxuICBmdW5jdGlvbiBpKHIsIHMsIG8pIHtcbiAgICBzLiRnZXRDb25maWcoKSwgci5nZXRWaXNpYmxlSXRlbXMoKS5mb3JFYWNoKGZ1bmN0aW9uKGwpIHtcbiAgICAgIHZhciBkID0gZnVuY3Rpb24oYywgdSwgaCwgZykge1xuICAgICAgICBpZiAoIWcuaXNUYXNrRXhpc3RzKGMuc291cmNlKSB8fCAhZy5pc1Rhc2tFeGlzdHMoYy50YXJnZXQpKSByZXR1cm4gbnVsbDtcbiAgICAgICAgdmFyIHAgPSBGZShnLmdldFRhc2soYy5zb3VyY2UpLCB1KSwgeSA9IEZlKGcuZ2V0VGFzayhjLnRhcmdldCksIHUpO1xuICAgICAgICBpZiAoIXAgfHwgIXkpIHJldHVybiBudWxsO1xuICAgICAgICB2YXIgdiA9IDEwMCwgYiA9IE1hdGgubWluKHAubGVmdCwgeS5sZWZ0KSAtIHYsIF8gPSBNYXRoLm1heChwLmxlZnQgKyBwLndpZHRoLCB5LmxlZnQgKyB5LndpZHRoKSArIHYsIG0gPSBNYXRoLm1pbihwLnRvcCwgeS50b3ApIC0gdiwgZiA9IE1hdGgubWF4KHAudG9wICsgcC5oZWlnaHQsIHkudG9wICsgeS5oZWlnaHQpICsgdjtcbiAgICAgICAgcmV0dXJuIHsgdG9wOiBtLCBoZWlnaHQ6IGYgLSBtLCBib3R0b206IGYsIGxlZnQ6IGIsIHdpZHRoOiBfIC0gYiwgcmlnaHQ6IF8gfTtcbiAgICAgIH0obCwgcywgMCwgbyk7XG4gICAgICBkICYmIHQucHVzaCh7IGlkOiBsLmlkLCByZWM6IGQgfSk7XG4gICAgfSksIHQuc29ydChmdW5jdGlvbihsLCBkKSB7XG4gICAgICByZXR1cm4gbC5yZWMucmlnaHQgPCBkLnJlYy5yaWdodCA/IC0xIDogMTtcbiAgICB9KSwgZSA9ICEwO1xuICB9XG4gIHZhciBhID0gITE7XG4gIHJldHVybiBmdW5jdGlvbihyLCBzLCBvLCBsLCBkKSB7XG4gICAgKGZ1bmN0aW9uKHApIHtcbiAgICAgIGEgfHwgKGEgPSAhMCwgcC5hdHRhY2hFdmVudChcIm9uUHJlRmlsdGVyXCIsIG4pLCBwLmF0dGFjaEV2ZW50KFwib25TdG9yZVVwZGF0ZWRcIiwgbiksIHAuYXR0YWNoRXZlbnQoXCJvbkNsZWFyQWxsXCIsIG4pLCBwLmF0dGFjaEV2ZW50KFwib25CZWZvcmVTdG9yZVVwZGF0ZVwiLCBuKSk7XG4gICAgfSkobCksIGUgfHwgaShsLCBzLCByKTtcbiAgICBmb3IgKHZhciBjID0gW10sIHUgPSAwOyB1IDwgdC5sZW5ndGg7IHUrKykge1xuICAgICAgdmFyIGggPSB0W3VdLCBnID0gaC5yZWM7XG4gICAgICBnLnJpZ2h0IDwgZC54IHx8IGcubGVmdCA8IGQueF9lbmQgJiYgZy5yaWdodCA+IGQueCAmJiBnLnRvcCA8IGQueV9lbmQgJiYgZy5ib3R0b20gPiBkLnkgJiYgYy5wdXNoKGguaWQpO1xuICAgIH1cbiAgICByZXR1cm4geyBpZHM6IGMgfTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHZuKHQsIGUsIG4sIGksIGEpIHtcbiAgdmFyIHIgPSBuLiRnYW50dC5nZXRUYXNrKHQuc291cmNlKSwgcyA9IG4uJGdhbnR0LmdldFRhc2sodC50YXJnZXQpLCBvID0gbi5nZXRJdGVtVG9wKHIuaWQpLCBsID0gbi5nZXRJdGVtSGVpZ2h0KHIuaWQpLCBkID0gbi5nZXRJdGVtVG9wKHMuaWQpLCBjID0gbi5nZXRJdGVtSGVpZ2h0KHMuaWQpO1xuICBpZiAoZS55ID4gbyArIGwgJiYgZS55ID4gZCArIGMgfHwgZS55X2VuZCA8IGQgJiYgZS55X2VuZCA8IG8pIHJldHVybiAhMTtcbiAgdmFyIHUgPSBuLnBvc0Zyb21EYXRlKHIuc3RhcnRfZGF0ZSksIGggPSBuLnBvc0Zyb21EYXRlKHIuZW5kX2RhdGUpLCBnID0gbi5wb3NGcm9tRGF0ZShzLnN0YXJ0X2RhdGUpLCBwID0gbi5wb3NGcm9tRGF0ZShzLmVuZF9kYXRlKTtcbiAgaWYgKHUgPiBoKSB7XG4gICAgdmFyIHkgPSBoO1xuICAgIGggPSB1LCB1ID0geTtcbiAgfVxuICByZXR1cm4gZyA+IHAgJiYgKHkgPSBwLCBwID0gZywgZyA9IHkpLCB1ICs9IC0xMDAsIGggKz0gMTAwLCBnICs9IC0xMDAsIHAgKz0gMTAwLCAhKGUueCA+IGggJiYgZS54ID4gcCkgJiYgIShlLnhfZW5kIDwgdSAmJiBlLnhfZW5kIDwgZyk7XG59XG5mdW5jdGlvbiBoYSh0LCBlKSB7XG4gIGlmICh0LnZpZXcpIHtcbiAgICB2YXIgbiA9IHQudmlldztcbiAgICB0eXBlb2YgbiA9PSBcInN0cmluZ1wiICYmIChuID0gZS4kdWkuZ2V0VmlldyhuKSksIG4gJiYgbi5hdHRhY2hFdmVudCAmJiBuLmF0dGFjaEV2ZW50KFwib25TY3JvbGxcIiwgZnVuY3Rpb24oKSB7XG4gICAgICBlLiRzZXJ2aWNlcy5nZXRTZXJ2aWNlKFwic3RhdGVcIikuZ2V0U3RhdGUoXCJiYXRjaFVwZGF0ZVwiKS5iYXRjaF91cGRhdGUgfHwgbi4kY29uZmlnLiRza2lwU21hcnRSZW5kZXJPblNjcm9sbCB8fCB0LnJlcXVlc3RVcGRhdGUgJiYgdC5yZXF1ZXN0VXBkYXRlKCk7XG4gICAgfSk7XG4gIH1cbn1cbnZhciBIdCA9IGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiB0KGUsIG4sIGksIGEpIHtcbiAgICBlICYmICh0aGlzLiRjb250YWluZXIgPSB3ZShlKSwgdGhpcy4kcGFyZW50ID0gZSksIHRoaXMuJGNvbmZpZyA9IFAobiwgeyBoZWFkZXJIZWlnaHQ6IDMzIH0pLCB0aGlzLiRnYW50dCA9IGEsIHRoaXMuJGRvbUV2ZW50cyA9IGEuX2NyZWF0ZURvbUV2ZW50U2NvcGUoKSwgdGhpcy4kaWQgPSBuLmlkIHx8IFwiY1wiICsgc3QoKSwgdGhpcy4kbmFtZSA9IFwiY2VsbFwiLCB0aGlzLiRmYWN0b3J5ID0gaSwgdGhpcy4kZXh0ZXJuYWxDb21wb25lbnQgPSBudWxsLCBvdCh0aGlzKTtcbiAgfVxuICByZXR1cm4gdC5wcm90b3R5cGUuZGVzdHJ1Y3RvciA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuJHBhcmVudCA9IHRoaXMuJGNvbnRhaW5lciA9IHRoaXMuJHZpZXcgPSBudWxsLCB0aGlzLiRnYW50dC4kc2VydmljZXMuZ2V0U2VydmljZShcIm1vdXNlRXZlbnRzXCIpLmRldGFjaChcImNsaWNrXCIsIFwiZ2FudHRfaGVhZGVyX2Fycm93XCIsIHRoaXMuX2hlYWRlckNsaWNrSGFuZGxlciksIHRoaXMuJGRvbUV2ZW50cy5kZXRhY2hBbGwoKSwgdGhpcy5jYWxsRXZlbnQoXCJvbkRlc3Ryb3lcIiwgW10pLCB0aGlzLmRldGFjaEFsbEV2ZW50cygpO1xuICB9LCB0LnByb3RvdHlwZS5jZWxsID0gZnVuY3Rpb24oZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9LCB0LnByb3RvdHlwZS5zY3JvbGxUbyA9IGZ1bmN0aW9uKGUsIG4pIHtcbiAgICB2YXIgaSA9IHRoaXMuJHZpZXc7XG4gICAgdGhpcy4kY29uZmlnLmh0bWwgJiYgKGkgPSB0aGlzLiR2aWV3LmZpcnN0Q2hpbGQpLCAxICogZSA9PSBlICYmIChpLnNjcm9sbExlZnQgPSBlKSwgMSAqIG4gPT0gbiAmJiAoaS5zY3JvbGxUb3AgPSBuKTtcbiAgfSwgdC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmdldE5vZGUoKS5pbm5lckhUTUwgPSBcIlwiLCB0aGlzLmdldE5vZGUoKS5jbGFzc05hbWUgPSBcImdhbnR0X2xheW91dF9jb250ZW50XCIsIHRoaXMuZ2V0Tm9kZSgpLnN0eWxlLnBhZGRpbmcgPSBcIjBcIjtcbiAgfSwgdC5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24oZSkge1xuICAgIGlmICh0aGlzLiRwYXJlbnQpIHJldHVybiB0aGlzLiRwYXJlbnQucmVzaXplKGUpO1xuICAgIGUgPT09ICExICYmICh0aGlzLiRwcmVSZXNpemUgPSAhMCk7XG4gICAgdmFyIG4gPSB0aGlzLiRjb250YWluZXIsIGkgPSBuLm9mZnNldFdpZHRoLCBhID0gbi5vZmZzZXRIZWlnaHQsIHIgPSB0aGlzLmdldFNpemUoKTtcbiAgICBuID09PSBkb2N1bWVudC5ib2R5ICYmIChpID0gZG9jdW1lbnQuYm9keS5vZmZzZXRXaWR0aCwgYSA9IGRvY3VtZW50LmJvZHkub2Zmc2V0SGVpZ2h0KSwgaSA8IHIubWluV2lkdGggJiYgKGkgPSByLm1pbldpZHRoKSwgaSA+IHIubWF4V2lkdGggJiYgKGkgPSByLm1heFdpZHRoKSwgYSA8IHIubWluSGVpZ2h0ICYmIChhID0gci5taW5IZWlnaHQpLCBhID4gci5tYXhIZWlnaHQgJiYgKGEgPSByLm1heEhlaWdodCksIHRoaXMuc2V0U2l6ZShpLCBhKSwgdGhpcy4kcHJlUmVzaXplLCB0aGlzLiRwcmVSZXNpemUgPSAhMTtcbiAgfSwgdC5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2hpZGUoITApLCB0aGlzLnJlc2l6ZSgpO1xuICB9LCB0LnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24oZSkge1xuICAgIHRoaXMuX2hpZGUoITEpLCBlICYmIHRoaXMuJHBhcmVudCAmJiB0aGlzLiRwYXJlbnQuc2hvdygpLCB0aGlzLnJlc2l6ZSgpO1xuICB9LCB0LnByb3RvdHlwZS5faGlkZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAoZSA9PT0gITAgJiYgdGhpcy4kdmlldy5wYXJlbnROb2RlKSB0aGlzLiR2aWV3LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy4kdmlldyk7XG4gICAgZWxzZSBpZiAoZSA9PT0gITEgJiYgIXRoaXMuJHZpZXcucGFyZW50Tm9kZSkge1xuICAgICAgdmFyIG4gPSB0aGlzLiRwYXJlbnQuY2VsbEluZGV4KHRoaXMuJGlkKTtcbiAgICAgIHRoaXMuJHBhcmVudC5tb3ZlVmlldyh0aGlzLCBuKTtcbiAgICB9XG4gICAgdGhpcy4kY29uZmlnLmhpZGRlbiA9IGU7XG4gIH0sIHQucHJvdG90eXBlLiR0b0hUTUwgPSBmdW5jdGlvbihlLCBuKSB7XG4gICAgZSA9PT0gdm9pZCAwICYmIChlID0gXCJcIiksIG4gPSBbbiB8fCBcIlwiLCB0aGlzLiRjb25maWcuY3NzIHx8IFwiXCJdLmpvaW4oXCIgXCIpO1xuICAgIHZhciBpID0gdGhpcy4kY29uZmlnLCBhID0gXCJcIjtcbiAgICBpZiAoaS5yYXcpIGUgPSB0eXBlb2YgaS5yYXcgPT0gXCJzdHJpbmdcIiA/IGkucmF3IDogXCJcIjtcbiAgICBlbHNlIHtcbiAgICAgIGlmICghZSkge1xuICAgICAgICBsZXQgciA9IG51bGw7XG4gICAgICAgIHIgPSB0eXBlb2YgaS5odG1sID09IFwiZnVuY3Rpb25cIiA/IGkuaHRtbCgpIDogaS5odG1sLCB0aGlzLiRnYW50dC5jb25maWcuZXh0ZXJuYWxfcmVuZGVyICYmIHRoaXMuJGdhbnR0LmNvbmZpZy5leHRlcm5hbF9yZW5kZXIuaXNFbGVtZW50KHIpICYmICh0aGlzLiRleHRlcm5hbENvbXBvbmVudCA9IHIsIHIgPSBudWxsKSwgZSA9IFwiPGRpdiBjbGFzcz0nZ2FudHRfbGF5b3V0X2NvbnRlbnQnIFwiICsgKG4gPyBcIiBjbGFzcz0nXCIgKyBuICsgXCInIFwiIDogXCJcIikgKyBcIiA+XCIgKyAociB8fCBcIlwiKSArIFwiPC9kaXY+XCI7XG4gICAgICB9XG4gICAgICBpLmhlYWRlciAmJiAoYSA9IFwiPGRpdiBjbGFzcz0nZ2FudHRfbGF5b3V0X2hlYWRlcic+XCIgKyAoaS5jYW5Db2xsYXBzZSA/IFwiPGRpdiBjbGFzcz0nZ2FudHRfbGF5b3V0X2hlYWRlcl9hcnJvdyc+PC9kaXY+XCIgOiBcIlwiKSArIFwiPGRpdiBjbGFzcz0nZ2FudHRfbGF5b3V0X2hlYWRlcl9jb250ZW50Jz5cIiArIGkuaGVhZGVyICsgXCI8L2Rpdj48L2Rpdj5cIik7XG4gICAgfVxuICAgIHJldHVybiBcIjxkaXYgY2xhc3M9J2dhbnR0X2xheW91dF9jZWxsIFwiICsgbiArIFwiJyBkYXRhLWNlbGwtaWQ9J1wiICsgdGhpcy4kaWQgKyBcIic+XCIgKyBhICsgZSArIFwiPC9kaXY+XCI7XG4gIH0sIHQucHJvdG90eXBlLiRmaWxsID0gZnVuY3Rpb24oZSwgbikge1xuICAgIHRoaXMuJHZpZXcgPSBlLCB0aGlzLiRwYXJlbnQgPSBuLCB0aGlzLmluaXQoKTtcbiAgfSwgdC5wcm90b3R5cGUuZ2V0Tm9kZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLiR2aWV3LnF1ZXJ5U2VsZWN0b3IoXCJnYW50dF9sYXlvdXRfY2VsbFwiKSB8fCB0aGlzLiR2aWV3O1xuICB9LCB0LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGUgPSB0aGlzO1xuICAgIHRoaXMuX2hlYWRlckNsaWNrSGFuZGxlciA9IGZ1bmN0aW9uKG4pIHtcbiAgICAgIGV0KG4sIFwiZGF0YS1jZWxsLWlkXCIpID09IGUuJGlkICYmIGUudG9nZ2xlKCk7XG4gICAgfSwgdGhpcy4kZ2FudHQuJHNlcnZpY2VzLmdldFNlcnZpY2UoXCJtb3VzZUV2ZW50c1wiKS5kZWxlZ2F0ZShcImNsaWNrXCIsIFwiZ2FudHRfaGVhZGVyX2Fycm93XCIsIHRoaXMuX2hlYWRlckNsaWNrSGFuZGxlciksIHRoaXMuY2FsbEV2ZW50KFwib25SZWFkeVwiLCBbXSk7XG4gIH0sIHQucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuJGNvbmZpZy5jb2xsYXBzZWQgPSAhdGhpcy4kY29uZmlnLmNvbGxhcHNlZCwgdGhpcy5yZXNpemUoKTtcbiAgfSwgdC5wcm90b3R5cGUuZ2V0U2l6ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBlID0geyBoZWlnaHQ6IHRoaXMuJGNvbmZpZy5oZWlnaHQgfHwgMCwgd2lkdGg6IHRoaXMuJGNvbmZpZy53aWR0aCB8fCAwLCBncmF2aXR5OiB0aGlzLiRjb25maWcuZ3Jhdml0eSB8fCAxLCBtaW5IZWlnaHQ6IHRoaXMuJGNvbmZpZy5taW5IZWlnaHQgfHwgMCwgbWluV2lkdGg6IHRoaXMuJGNvbmZpZy5taW5XaWR0aCB8fCAwLCBtYXhIZWlnaHQ6IHRoaXMuJGNvbmZpZy5tYXhIZWlnaHQgfHwgMWUxMSwgbWF4V2lkdGg6IHRoaXMuJGNvbmZpZy5tYXhXaWR0aCB8fCAxZTExIH07XG4gICAgaWYgKHRoaXMuJGNvbmZpZy5jb2xsYXBzZWQpIHtcbiAgICAgIHZhciBuID0gdGhpcy4kY29uZmlnLm1vZGUgPT09IFwieFwiO1xuICAgICAgZVtuID8gXCJ3aWR0aFwiIDogXCJoZWlnaHRcIl0gPSBlW24gPyBcIm1heFdpZHRoXCIgOiBcIm1heEhlaWdodFwiXSA9IHRoaXMuJGNvbmZpZy5oZWFkZXJIZWlnaHQ7XG4gICAgfVxuICAgIHJldHVybiBlO1xuICB9LCB0LnByb3RvdHlwZS5nZXRDb250ZW50U2l6ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBlID0gdGhpcy4kbGFzdFNpemUuY29udGVudFg7XG4gICAgZSAhPT0gMSAqIGUgJiYgKGUgPSB0aGlzLiRsYXN0U2l6ZS53aWR0aCk7XG4gICAgdmFyIG4gPSB0aGlzLiRsYXN0U2l6ZS5jb250ZW50WTtcbiAgICByZXR1cm4gbiAhPT0gMSAqIG4gJiYgKG4gPSB0aGlzLiRsYXN0U2l6ZS5oZWlnaHQpLCB7IHdpZHRoOiBlLCBoZWlnaHQ6IG4gfTtcbiAgfSwgdC5wcm90b3R5cGUuX2dldEJvcmRlclNpemVzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGUgPSB7IHRvcDogMCwgcmlnaHQ6IDAsIGJvdHRvbTogMCwgbGVmdDogMCwgaG9yaXpvbnRhbDogMCwgdmVydGljYWw6IDAgfTtcbiAgICByZXR1cm4gdGhpcy5fY3VycmVudEJvcmRlcnMgJiYgKHRoaXMuX2N1cnJlbnRCb3JkZXJzW3RoaXMuX2JvcmRlcnMubGVmdF0gJiYgKGUubGVmdCA9IDEsIGUuaG9yaXpvbnRhbCsrKSwgdGhpcy5fY3VycmVudEJvcmRlcnNbdGhpcy5fYm9yZGVycy5yaWdodF0gJiYgKGUucmlnaHQgPSAxLCBlLmhvcml6b250YWwrKyksIHRoaXMuX2N1cnJlbnRCb3JkZXJzW3RoaXMuX2JvcmRlcnMudG9wXSAmJiAoZS50b3AgPSAxLCBlLnZlcnRpY2FsKyspLCB0aGlzLl9jdXJyZW50Qm9yZGVyc1t0aGlzLl9ib3JkZXJzLmJvdHRvbV0gJiYgKGUuYm90dG9tID0gMSwgZS52ZXJ0aWNhbCsrKSksIGU7XG4gIH0sIHQucHJvdG90eXBlLnNldFNpemUgPSBmdW5jdGlvbihlLCBuKSB7XG4gICAgdGhpcy4kdmlldy5zdHlsZS53aWR0aCA9IGUgKyBcInB4XCIsIHRoaXMuJHZpZXcuc3R5bGUuaGVpZ2h0ID0gbiArIFwicHhcIjtcbiAgICB2YXIgaSA9IHRoaXMuX2dldEJvcmRlclNpemVzKCksIGEgPSBuIC0gaS52ZXJ0aWNhbCwgciA9IGUgLSBpLmhvcml6b250YWw7XG4gICAgdGhpcy4kbGFzdFNpemUgPSB7IHg6IGUsIHk6IG4sIGNvbnRlbnRYOiByLCBjb250ZW50WTogYSB9LCB0aGlzLiRjb25maWcuaGVhZGVyID8gdGhpcy5fc2l6ZUhlYWRlcigpIDogdGhpcy5fc2l6ZUNvbnRlbnQoKTtcbiAgfSwgdC5wcm90b3R5cGUuX2JvcmRlcnMgPSB7IGxlZnQ6IFwiZ2FudHRfbGF5b3V0X2NlbGxfYm9yZGVyX2xlZnRcIiwgcmlnaHQ6IFwiZ2FudHRfbGF5b3V0X2NlbGxfYm9yZGVyX3JpZ2h0XCIsIHRvcDogXCJnYW50dF9sYXlvdXRfY2VsbF9ib3JkZXJfdG9wXCIsIGJvdHRvbTogXCJnYW50dF9sYXlvdXRfY2VsbF9ib3JkZXJfYm90dG9tXCIgfSwgdC5wcm90b3R5cGUuX3NldEJvcmRlcnMgPSBmdW5jdGlvbihlLCBuKSB7XG4gICAgbiB8fCAobiA9IHRoaXMpO1xuICAgIHZhciBpID0gbi4kdmlldztcbiAgICBmb3IgKHZhciBhIGluIHRoaXMuX2JvcmRlcnMpIEd0KGksIHRoaXMuX2JvcmRlcnNbYV0pO1xuICAgIHR5cGVvZiBlID09IFwic3RyaW5nXCIgJiYgKGUgPSBbZV0pO1xuICAgIHZhciByID0ge307XG4gICAgZm9yIChhID0gMDsgYSA8IGUubGVuZ3RoOyBhKyspIHd0KGksIGVbYV0pLCByW2VbYV1dID0gITA7XG4gICAgbi5fY3VycmVudEJvcmRlcnMgPSByO1xuICB9LCB0LnByb3RvdHlwZS5fc2l6ZUNvbnRlbnQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZSA9IHRoaXMuJHZpZXcuY2hpbGROb2Rlc1swXTtcbiAgICBlICYmIGUuY2xhc3NOYW1lID09IFwiZ2FudHRfbGF5b3V0X2NvbnRlbnRcIiAmJiAoZS5zdHlsZS5oZWlnaHQgPSB0aGlzLiRsYXN0U2l6ZS5jb250ZW50WSArIFwicHhcIik7XG4gIH0sIHQucHJvdG90eXBlLl9zaXplSGVhZGVyID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGUgPSB0aGlzLiRsYXN0U2l6ZTtcbiAgICBlLmNvbnRlbnRZIC09IHRoaXMuJGNvbmZpZy5oZWFkZXJIZWlnaHQ7XG4gICAgdmFyIG4gPSB0aGlzLiR2aWV3LmNoaWxkTm9kZXNbMF0sIGkgPSB0aGlzLiR2aWV3LmNoaWxkTm9kZXNbMV0sIGEgPSB0aGlzLiRjb25maWcubW9kZSA9PT0gXCJ4XCI7XG4gICAgaWYgKHRoaXMuJGNvbmZpZy5jb2xsYXBzZWQpIGlmIChpLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIiwgYSkge1xuICAgICAgbi5jbGFzc05hbWUgPSBcImdhbnR0X2xheW91dF9oZWFkZXIgY29sbGFwc2VkX3hcIiwgbi5zdHlsZS53aWR0aCA9IGUueSArIFwicHhcIjtcbiAgICAgIHZhciByID0gTWF0aC5mbG9vcihlLnkgLyAyIC0gZS54IC8gMik7XG4gICAgICBuLnN0eWxlLnRyYW5zZm9ybSA9IFwicm90YXRlKDkwZGVnKSB0cmFuc2xhdGUoXCIgKyByICsgXCJweCwgXCIgKyByICsgXCJweClcIiwgaS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgfSBlbHNlIG4uY2xhc3NOYW1lID0gXCJnYW50dF9sYXlvdXRfaGVhZGVyIGNvbGxhcHNlZF95XCI7XG4gICAgZWxzZSBuLmNsYXNzTmFtZSA9IGEgPyBcImdhbnR0X2xheW91dF9oZWFkZXJcIiA6IFwiZ2FudHRfbGF5b3V0X2hlYWRlciB2ZXJ0aWNhbFwiLCBuLnN0eWxlLndpZHRoID0gXCJhdXRvXCIsIG4uc3R5bGUudHJhbnNmb3JtID0gXCJcIiwgaS5zdHlsZS5kaXNwbGF5ID0gXCJcIiwgaS5zdHlsZS5oZWlnaHQgPSBlLmNvbnRlbnRZICsgXCJweFwiO1xuICAgIG4uc3R5bGUuaGVpZ2h0ID0gdGhpcy4kY29uZmlnLmhlYWRlckhlaWdodCArIFwicHhcIjtcbiAgfSwgdDtcbn0oKTtcbmZ1bmN0aW9uIHoodCwgZSkge1xuICBmb3IgKHZhciBuIGluIGUpIGUuaGFzT3duUHJvcGVydHkobikgJiYgKHRbbl0gPSBlW25dKTtcbiAgZnVuY3Rpb24gaSgpIHtcbiAgICB0aGlzLmNvbnN0cnVjdG9yID0gdDtcbiAgfVxuICB0LnByb3RvdHlwZSA9IGUgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGUpIDogKGkucHJvdG90eXBlID0gZS5wcm90b3R5cGUsIG5ldyBpKCkpO1xufVxudmFyIGtuID0gZnVuY3Rpb24odCkge1xuICBmdW5jdGlvbiBlKG4sIGksIGEpIHtcbiAgICB2YXIgciA9IHQuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIHJldHVybiBuICYmIChyLiRyb290ID0gITApLCByLl9wYXJzZUNvbmZpZyhpKSwgci4kbmFtZSA9IFwibGF5b3V0XCIsIHI7XG4gIH1cbiAgcmV0dXJuIHooZSwgdCksIGUucHJvdG90eXBlLmRlc3RydWN0b3IgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLiRjb250YWluZXIgJiYgdGhpcy4kdmlldyAmJiBRZSh0aGlzLiR2aWV3KTtcbiAgICBmb3IgKHZhciBuID0gMDsgbiA8IHRoaXMuJGNlbGxzLmxlbmd0aDsgbisrKVxuICAgICAgdGhpcy4kY2VsbHNbbl0uZGVzdHJ1Y3RvcigpO1xuICAgIHRoaXMuJGNlbGxzID0gW10sIHQucHJvdG90eXBlLmRlc3RydWN0b3IuY2FsbCh0aGlzKTtcbiAgfSwgZS5wcm90b3R5cGUuX3Jlc2l6ZVNjcm9sbGJhcnMgPSBmdW5jdGlvbihuLCBpKSB7XG4gICAgdmFyIGEgPSAhMSwgciA9IFtdLCBzID0gW107XG4gICAgY29uc3QgbyA9IFtdO1xuICAgIGZ1bmN0aW9uIGwocCkge1xuICAgICAgcC4kcGFyZW50LnNob3coKSwgYSA9ICEwLCByLnB1c2gocCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGQocCkge1xuICAgICAgcC4kcGFyZW50LmhpZGUoKSwgYSA9ICEwLCBzLnB1c2gocCk7XG4gICAgfVxuICAgIGZvciAodmFyIGMsIHUgPSAwOyB1IDwgaS5sZW5ndGg7IHUrKykgblsoYyA9IGlbdV0pLiRjb25maWcuc2Nyb2xsXSA/IGQoYykgOiBjLnNob3VsZEhpZGUoKSA/IG8ucHVzaChjKSA6IGMuc2hvdWxkU2hvdygpID8gbChjKSA6IGMuaXNWaXNpYmxlKCkgPyByLnB1c2goYykgOiBzLnB1c2goYyk7XG4gICAgdmFyIGggPSB7fTtcbiAgICBmb3IgKHUgPSAwOyB1IDwgci5sZW5ndGg7IHUrKykgclt1XS4kY29uZmlnLmdyb3VwICYmIChoW3JbdV0uJGNvbmZpZy5ncm91cF0gPSAhMCk7XG4gICAgZm9yIChvLmZvckVhY2goZnVuY3Rpb24ocCkge1xuICAgICAgcC4kY29uZmlnLmdyb3VwICYmIGhbcC4kY29uZmlnLmdyb3VwXSB8fCBkKHApO1xuICAgIH0pLCB1ID0gMDsgdSA8IHMubGVuZ3RoOyB1KyspIGlmICgoYyA9IHNbdV0pLiRjb25maWcuZ3JvdXAgJiYgaFtjLiRjb25maWcuZ3JvdXBdKSB7XG4gICAgICBsKGMpO1xuICAgICAgZm9yICh2YXIgZyA9IDA7IGcgPCByLmxlbmd0aDsgZysrKSBpZiAocltnXSA9PSBjKSB7XG4gICAgICAgIHRoaXMuJGdhbnR0LiRzY3JvbGxiYXJSZXBhaW50ID0gITA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYTtcbiAgfSwgZS5wcm90b3R5cGUuZ2V0U2Nyb2xsYmFyc0luZm8gPSBmdW5jdGlvbigpIHtcbiAgICBjb25zdCBuID0gdGhpcy5nZXRDZWxsc0J5VHlwZShcInNjcm9sbGVyXCIpLCBpID0gW107XG4gICAgcmV0dXJuIG4uZm9yRWFjaCgoYSkgPT4ge1xuICAgICAgbGV0IHIgPSB7fTtcbiAgICAgIGNvbnN0IHsgdmlzaWJsZTogcywgZGlyZWN0aW9uOiBvLCBzaXplOiBsLCBzY3JvbGxTaXplOiBkLCBwb3NpdGlvbjogYyB9ID0gYS5nZXRTY3JvbGxTdGF0ZSgpO1xuICAgICAgbGV0IHUgPSBhLl9nZXRMaW5rZWRWaWV3cygpLm1hcCgoaCkgPT4gaC4kY29uZmlnLmlkKTtcbiAgICAgIHIuaWQgPSBhLiRpZCwgci52aXNpYmxlID0gcywgci5ib3VuZFZpZXdzID0gdSwgbyA9PT0gXCJ4XCIgPyAoci54ID0gbCwgci54X2lubmVyID0gZCwgci54X3BvcyA9IGMgfHwgMCkgOiAoci55ID0gbCwgci55X2lubmVyID0gZCwgci55X3BvcyA9IGMgfHwgMCksIGkucHVzaChyKTtcbiAgICB9KSwgaTtcbiAgfSwgZS5wcm90b3R5cGUuX3N5bmNDZWxsU2l6ZXMgPSBmdW5jdGlvbihuLCBpKSB7XG4gICAgaWYgKG4pIHtcbiAgICAgIHZhciBhID0ge307XG4gICAgICByZXR1cm4gdGhpcy5fZWFjaENoaWxkKGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgci4kY29uZmlnLmdyb3VwICYmIHIuJG5hbWUgIT0gXCJzY3JvbGxiYXJcIiAmJiByLiRuYW1lICE9IFwicmVzaXplclwiICYmIChhW3IuJGNvbmZpZy5ncm91cF0gfHwgKGFbci4kY29uZmlnLmdyb3VwXSA9IFtdKSwgYVtyLiRjb25maWcuZ3JvdXBdLnB1c2gocikpO1xuICAgICAgfSksIGFbbl0gJiYgdGhpcy5fc3luY0dyb3VwU2l6ZShhW25dLCBpKSwgYVtuXTtcbiAgICB9XG4gIH0sIGUucHJvdG90eXBlLl9zeW5jR3JvdXBTaXplID0gZnVuY3Rpb24obiwgaSkge1xuICAgIGlmIChuLmxlbmd0aCkgZm9yICh2YXIgYSA9IG5bMF0uJHBhcmVudC5feExheW91dCA/IFwid2lkdGhcIiA6IFwiaGVpZ2h0XCIsIHIgPSBuWzBdLiRwYXJlbnQuZ2V0TmV4dFNpYmxpbmcoblswXS4kaWQpID8gMSA6IC0xLCBzID0gaS52YWx1ZSwgbyA9IGkuaXNHcmF2aXR5LCBsID0gMDsgbCA8IG4ubGVuZ3RoOyBsKyspIHtcbiAgICAgIHZhciBkID0gbltsXS5nZXRTaXplKCksIGMgPSByID4gMCA/IG5bbF0uJHBhcmVudC5nZXROZXh0U2libGluZyhuW2xdLiRpZCkgOiBuW2xdLiRwYXJlbnQuZ2V0UHJldlNpYmxpbmcobltsXS4kaWQpO1xuICAgICAgYy4kbmFtZSA9PSBcInJlc2l6ZXJcIiAmJiAoYyA9IHIgPiAwID8gYy4kcGFyZW50LmdldE5leHRTaWJsaW5nKGMuJGlkKSA6IGMuJHBhcmVudC5nZXRQcmV2U2libGluZyhjLiRpZCkpO1xuICAgICAgdmFyIHUgPSBjLmdldFNpemUoKTtcbiAgICAgIGlmIChvKSBuW2xdLiRjb25maWcuZ3Jhdml0eSA9IHM7XG4gICAgICBlbHNlIGlmIChjW2FdKSB7XG4gICAgICAgIHZhciBoID0gZC5ncmF2aXR5ICsgdS5ncmF2aXR5LCBnID0gZFthXSArIHVbYV0sIHAgPSBoIC8gZztcbiAgICAgICAgbltsXS4kY29uZmlnLmdyYXZpdHkgPSBwICogcywgYy4kY29uZmlnW2FdID0gZyAtIHMsIGMuJGNvbmZpZy5ncmF2aXR5ID0gaCAtIHAgKiBzO1xuICAgICAgfSBlbHNlIG5bbF0uJGNvbmZpZ1thXSA9IHM7XG4gICAgICB2YXIgeSA9IHRoaXMuJGdhbnR0LiR1aS5nZXRWaWV3KFwiZ3JpZFwiKTtcbiAgICAgICF5IHx8IG5bbF0uJGNvbnRlbnQgIT09IHkgfHwgeS4kY29uZmlnLnNjcm9sbGFibGUgfHwgbyB8fCAodGhpcy4kZ2FudHQuY29uZmlnLmdyaWRfd2lkdGggPSBzKTtcbiAgICB9XG4gIH0sIGUucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uKG4pIHtcbiAgICB2YXIgaSA9ICExO1xuICAgIGlmICh0aGlzLiRyb290ICYmICF0aGlzLl9yZXNpemVJblByb2dyZXNzICYmICh0aGlzLmNhbGxFdmVudChcIm9uQmVmb3JlUmVzaXplXCIsIFtdKSwgaSA9ICEwLCB0aGlzLl9yZXNpemVJblByb2dyZXNzID0gITApLCB0LnByb3RvdHlwZS5yZXNpemUuY2FsbCh0aGlzLCAhMCksIHQucHJvdG90eXBlLnJlc2l6ZS5jYWxsKHRoaXMsICExKSwgaSkge1xuICAgICAgdmFyIGEgPSBbXTtcbiAgICAgIGEgPSAoYSA9IChhID0gYS5jb25jYXQodGhpcy5nZXRDZWxsc0J5VHlwZShcInZpZXdDZWxsXCIpKSkuY29uY2F0KHRoaXMuZ2V0Q2VsbHNCeVR5cGUoXCJ2aWV3TGF5b3V0XCIpKSkuY29uY2F0KHRoaXMuZ2V0Q2VsbHNCeVR5cGUoXCJob3N0Q2VsbFwiKSk7XG4gICAgICBmb3IgKHZhciByID0gdGhpcy5nZXRDZWxsc0J5VHlwZShcInNjcm9sbGVyXCIpLCBzID0gMDsgcyA8IGEubGVuZ3RoOyBzKyspIGFbc10uJGNvbmZpZy5oaWRkZW4gfHwgYVtzXS5zZXRDb250ZW50U2l6ZSgpO1xuICAgICAgdmFyIG8gPSB0aGlzLl9nZXRBdXRvc2l6ZU1vZGUodGhpcy4kY29uZmlnLmF1dG9zaXplKSwgbCA9IHRoaXMuX3Jlc2l6ZVNjcm9sbGJhcnMobywgcik7XG4gICAgICBpZiAodGhpcy4kY29uZmlnLmF1dG9zaXplICYmICh0aGlzLmF1dG9zaXplKHRoaXMuJGNvbmZpZy5hdXRvc2l6ZSksIGEuZm9yRWFjaChmdW5jdGlvbihkKSB7XG4gICAgICAgIGNvbnN0IGMgPSBkLiRwYXJlbnQsIHUgPSBjLmdldENvbnRlbnRTaXplKG8pO1xuICAgICAgICBvLnggJiYgKGMuJGNvbmZpZy4kb3JpZ2luYWxXaWR0aFN0b3JlZCB8fCAoYy4kY29uZmlnLiRvcmlnaW5hbFdpZHRoU3RvcmVkID0gITAsIGMuJGNvbmZpZy4kb3JpZ2luYWxXaWR0aCA9IGMuJGNvbmZpZy53aWR0aCksIGMuJGNvbmZpZy53aWR0aCA9IHUud2lkdGgpLCBvLnkgJiYgKGMuJGNvbmZpZy4kb3JpZ2luYWxIZWlnaHRTdG9yZWQgfHwgKGMuJGNvbmZpZy4kb3JpZ2luYWxIZWlnaHRTdG9yZWQgPSAhMCwgYy4kY29uZmlnLiRvcmlnaW5hbEhlaWdodCA9IGMuJGNvbmZpZy5oZWlnaHQpLCBjLiRjb25maWcuaGVpZ2h0ID0gdS5oZWlnaHQpO1xuICAgICAgfSksIGwgPSAhMCksIGwpXG4gICAgICAgIGZvciAodGhpcy5yZXNpemUoKSwgcyA9IDA7IHMgPCBhLmxlbmd0aDsgcysrKSBhW3NdLiRjb25maWcuaGlkZGVuIHx8IGFbc10uc2V0Q29udGVudFNpemUoKTtcbiAgICAgIHRoaXMuY2FsbEV2ZW50KFwib25SZXNpemVcIiwgW10pO1xuICAgIH1cbiAgICBpICYmICh0aGlzLl9yZXNpemVJblByb2dyZXNzID0gITEpO1xuICB9LCBlLnByb3RvdHlwZS5fZWFjaENoaWxkID0gZnVuY3Rpb24obiwgaSkge1xuICAgIGlmIChuKGkgPSBpIHx8IHRoaXMpLCBpLiRjZWxscykgZm9yICh2YXIgYSA9IDA7IGEgPCBpLiRjZWxscy5sZW5ndGg7IGErKykgdGhpcy5fZWFjaENoaWxkKG4sIGkuJGNlbGxzW2FdKTtcbiAgfSwgZS5wcm90b3R5cGUuaXNDaGlsZCA9IGZ1bmN0aW9uKG4pIHtcbiAgICB2YXIgaSA9ICExO1xuICAgIHJldHVybiB0aGlzLl9lYWNoQ2hpbGQoZnVuY3Rpb24oYSkge1xuICAgICAgYSAhPT0gbiAmJiBhLiRjb250ZW50ICE9PSBuIHx8IChpID0gITApO1xuICAgIH0pLCBpO1xuICB9LCBlLnByb3RvdHlwZS5nZXRDZWxsc0J5VHlwZSA9IGZ1bmN0aW9uKG4pIHtcbiAgICB2YXIgaSA9IFtdO1xuICAgIGlmIChuID09PSB0aGlzLiRuYW1lICYmIGkucHVzaCh0aGlzKSwgdGhpcy4kY29udGVudCAmJiB0aGlzLiRjb250ZW50LiRuYW1lID09IG4gJiYgaS5wdXNoKHRoaXMuJGNvbnRlbnQpLCB0aGlzLiRjZWxscykgZm9yICh2YXIgYSA9IDA7IGEgPCB0aGlzLiRjZWxscy5sZW5ndGg7IGErKykge1xuICAgICAgdmFyIHIgPSBlLnByb3RvdHlwZS5nZXRDZWxsc0J5VHlwZS5jYWxsKHRoaXMuJGNlbGxzW2FdLCBuKTtcbiAgICAgIHIubGVuZ3RoICYmIGkucHVzaC5hcHBseShpLCByKTtcbiAgICB9XG4gICAgcmV0dXJuIGk7XG4gIH0sIGUucHJvdG90eXBlLmdldE5leHRTaWJsaW5nID0gZnVuY3Rpb24obikge1xuICAgIHZhciBpID0gdGhpcy5jZWxsSW5kZXgobik7XG4gICAgcmV0dXJuIGkgPj0gMCAmJiB0aGlzLiRjZWxsc1tpICsgMV0gPyB0aGlzLiRjZWxsc1tpICsgMV0gOiBudWxsO1xuICB9LCBlLnByb3RvdHlwZS5nZXRQcmV2U2libGluZyA9IGZ1bmN0aW9uKG4pIHtcbiAgICB2YXIgaSA9IHRoaXMuY2VsbEluZGV4KG4pO1xuICAgIHJldHVybiBpID49IDAgJiYgdGhpcy4kY2VsbHNbaSAtIDFdID8gdGhpcy4kY2VsbHNbaSAtIDFdIDogbnVsbDtcbiAgfSwgZS5wcm90b3R5cGUuY2VsbCA9IGZ1bmN0aW9uKG4pIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuJGNlbGxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYSA9IHRoaXMuJGNlbGxzW2ldO1xuICAgICAgaWYgKGEuJGlkID09PSBuKSByZXR1cm4gYTtcbiAgICAgIHZhciByID0gYS5jZWxsKG4pO1xuICAgICAgaWYgKHIpIHJldHVybiByO1xuICAgIH1cbiAgfSwgZS5wcm90b3R5cGUuY2VsbEluZGV4ID0gZnVuY3Rpb24obikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy4kY2VsbHMubGVuZ3RoOyBpKyspIGlmICh0aGlzLiRjZWxsc1tpXS4kaWQgPT09IG4pIHJldHVybiBpO1xuICAgIHJldHVybiAtMTtcbiAgfSwgZS5wcm90b3R5cGUubW92ZVZpZXcgPSBmdW5jdGlvbihuLCBpKSB7XG4gICAgaWYgKHRoaXMuJGNlbGxzW2ldICE9PSBuKSByZXR1cm4gd2luZG93LmFsZXJ0KFwiTm90IGltcGxlbWVudGVkXCIpO1xuICAgIGkgKz0gdGhpcy4kY29uZmlnLmhlYWRlciA/IDEgOiAwO1xuICAgIHZhciBhID0gdGhpcy4kdmlldztcbiAgICBpID49IGEuY2hpbGROb2Rlcy5sZW5ndGggPyBhLmFwcGVuZENoaWxkKG4uJHZpZXcpIDogYS5pbnNlcnRCZWZvcmUobi4kdmlldywgYS5jaGlsZE5vZGVzW2ldKTtcbiAgfSwgZS5wcm90b3R5cGUuX3BhcnNlQ29uZmlnID0gZnVuY3Rpb24obikge1xuICAgIHRoaXMuJGNlbGxzID0gW10sIHRoaXMuX3hMYXlvdXQgPSAhbi5yb3dzO1xuICAgIGZvciAodmFyIGkgPSBuLnJvd3MgfHwgbi5jb2xzIHx8IG4udmlld3MsIGEgPSAwOyBhIDwgaS5sZW5ndGg7IGErKykge1xuICAgICAgdmFyIHIgPSBpW2FdO1xuICAgICAgci5tb2RlID0gdGhpcy5feExheW91dCA/IFwieFwiIDogXCJ5XCI7XG4gICAgICB2YXIgcyA9IHRoaXMuJGZhY3RvcnkuaW5pdFVJKHIsIHRoaXMpO1xuICAgICAgcyA/IChzLiRwYXJlbnQgPSB0aGlzLCB0aGlzLiRjZWxscy5wdXNoKHMpKSA6IChpLnNwbGljZShhLCAxKSwgYS0tKTtcbiAgICB9XG4gIH0sIGUucHJvdG90eXBlLmdldENlbGxzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuJGNlbGxzO1xuICB9LCBlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbiA9IFplKHRoaXMuJGNvbnRhaW5lciwgdGhpcy4kdG9IVE1MKCkpO1xuICAgIHRoaXMuJGZpbGwobiwgbnVsbCk7XG4gICAgY29uc3QgaSA9IHRoaXMuJGdhbnR0O1xuICAgIHRoaXMuX2VhY2hDaGlsZCgoYSkgPT4ge1xuICAgICAgYS4kZXh0ZXJuYWxDb21wb25lbnQgJiYgKGkuY29uZmlnLmV4dGVybmFsX3JlbmRlci5yZW5kZXJFbGVtZW50KGEuJGV4dGVybmFsQ29tcG9uZW50LCBhLiR2aWV3LnF1ZXJ5U2VsZWN0b3IoXCIuZ2FudHRfbGF5b3V0X2NvbnRlbnRcIikpLCBhLiRleHRlcm5hbENvbXBvbmVudCA9IG51bGwpO1xuICAgIH0pLCB0aGlzLmNhbGxFdmVudChcIm9uUmVhZHlcIiwgW10pLCB0aGlzLnJlc2l6ZSgpLCB0aGlzLnJlbmRlciA9IHRoaXMucmVzaXplO1xuICB9LCBlLnByb3RvdHlwZS4kZmlsbCA9IGZ1bmN0aW9uKG4sIGkpIHtcbiAgICB0aGlzLiR2aWV3ID0gbiwgdGhpcy4kcGFyZW50ID0gaTtcbiAgICBmb3IgKHZhciBhID0gdG4obiwgXCJnYW50dF9sYXlvdXRfY2VsbFwiKSwgciA9IGEubGVuZ3RoIC0gMTsgciA+PSAwOyByLS0pIHtcbiAgICAgIHZhciBzID0gdGhpcy4kY2VsbHNbcl07XG4gICAgICBzLiRmaWxsKGFbcl0sIHRoaXMpLCBzLiRjb25maWcuaGlkZGVuICYmIHMuJHZpZXcucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzLiR2aWV3KTtcbiAgICB9XG4gIH0sIGUucHJvdG90eXBlLiR0b0hUTUwgPSBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciBuID0gdGhpcy5feExheW91dCA/IFwieFwiIDogXCJ5XCIsIGkgPSBbXSwgYSA9IDA7IGEgPCB0aGlzLiRjZWxscy5sZW5ndGg7IGErKykgaS5wdXNoKHRoaXMuJGNlbGxzW2FdLiR0b0hUTUwoKSk7XG4gICAgcmV0dXJuIHQucHJvdG90eXBlLiR0b0hUTUwuY2FsbCh0aGlzLCBpLmpvaW4oXCJcIiksICh0aGlzLiRyb290ID8gXCJnYW50dF9sYXlvdXRfcm9vdCBcIiA6IFwiXCIpICsgXCJnYW50dF9sYXlvdXQgZ2FudHRfbGF5b3V0X1wiICsgbik7XG4gIH0sIGUucHJvdG90eXBlLmdldENvbnRlbnRTaXplID0gZnVuY3Rpb24obikge1xuICAgIGZvciAodmFyIGksIGEsIHIsIHMgPSAwLCBvID0gMCwgbCA9IDA7IGwgPCB0aGlzLiRjZWxscy5sZW5ndGg7IGwrKykgKGEgPSB0aGlzLiRjZWxsc1tsXSkuJGNvbmZpZy5oaWRkZW4gfHwgKGkgPSBhLmdldENvbnRlbnRTaXplKG4pLCBhLiRjb25maWcudmlldyA9PT0gXCJzY3JvbGxiYXJcIiAmJiBuW2EuJGNvbmZpZy5zY3JvbGxdICYmIChpLmhlaWdodCA9IDAsIGkud2lkdGggPSAwKSwgYS4kY29uZmlnLnJlc2l6ZXIgJiYgKHRoaXMuX3hMYXlvdXQgPyBpLmhlaWdodCA9IDAgOiBpLndpZHRoID0gMCksIHIgPSBhLl9nZXRCb3JkZXJTaXplcygpLCB0aGlzLl94TGF5b3V0ID8gKHMgKz0gaS53aWR0aCArIHIuaG9yaXpvbnRhbCwgbyA9IE1hdGgubWF4KG8sIGkuaGVpZ2h0ICsgci52ZXJ0aWNhbCkpIDogKHMgPSBNYXRoLm1heChzLCBpLndpZHRoICsgci5ob3Jpem9udGFsKSwgbyArPSBpLmhlaWdodCArIHIudmVydGljYWwpKTtcbiAgICByZXR1cm4geyB3aWR0aDogcyArPSAociA9IHRoaXMuX2dldEJvcmRlclNpemVzKCkpLmhvcml6b250YWwsIGhlaWdodDogbyArPSByLnZlcnRpY2FsIH07XG4gIH0sIGUucHJvdG90eXBlLl9jbGVhbkVsU2l6ZSA9IGZ1bmN0aW9uKG4pIHtcbiAgICByZXR1cm4gMSAqIChuIHx8IFwiXCIpLnRvU3RyaW5nKCkucmVwbGFjZShcInB4XCIsIFwiXCIpIHx8IDA7XG4gIH0sIGUucHJvdG90eXBlLl9nZXRCb3hTdHlsZXMgPSBmdW5jdGlvbihuKSB7XG4gICAgdmFyIGkgPSBudWxsLCBhID0gW1wid2lkdGhcIiwgXCJoZWlnaHRcIiwgXCJwYWRkaW5nVG9wXCIsIFwicGFkZGluZ0JvdHRvbVwiLCBcInBhZGRpbmdMZWZ0XCIsIFwicGFkZGluZ1JpZ2h0XCIsIFwiYm9yZGVyTGVmdFdpZHRoXCIsIFwiYm9yZGVyUmlnaHRXaWR0aFwiLCBcImJvcmRlclRvcFdpZHRoXCIsIFwiYm9yZGVyQm90dG9tV2lkdGhcIl0sIHIgPSB7IGJveFNpemluZzogKGkgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSA/IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKG4sIG51bGwpIDogeyB3aWR0aDogbi5jbGllbnRXaWR0aCwgaGVpZ2h0OiBuLmNsaWVudEhlaWdodCB9KS5ib3hTaXppbmcgPT0gXCJib3JkZXItYm94XCIgfTtcbiAgICBpLk1vekJveFNpemluZyAmJiAoci5ib3hTaXppbmcgPSBpLk1vekJveFNpemluZyA9PSBcImJvcmRlci1ib3hcIik7XG4gICAgZm9yICh2YXIgcyA9IDA7IHMgPCBhLmxlbmd0aDsgcysrKSByW2Fbc11dID0gaVthW3NdXSA/IHRoaXMuX2NsZWFuRWxTaXplKGlbYVtzXV0pIDogMDtcbiAgICB2YXIgbyA9IHsgaG9yUGFkZGluZ3M6IHIucGFkZGluZ0xlZnQgKyByLnBhZGRpbmdSaWdodCArIHIuYm9yZGVyTGVmdFdpZHRoICsgci5ib3JkZXJSaWdodFdpZHRoLCB2ZXJ0UGFkZGluZ3M6IHIucGFkZGluZ1RvcCArIHIucGFkZGluZ0JvdHRvbSArIHIuYm9yZGVyVG9wV2lkdGggKyByLmJvcmRlckJvdHRvbVdpZHRoLCBib3JkZXJCb3g6IHIuYm94U2l6aW5nLCBpbm5lcldpZHRoOiByLndpZHRoLCBpbm5lckhlaWdodDogci5oZWlnaHQsIG91dGVyV2lkdGg6IHIud2lkdGgsIG91dGVySGVpZ2h0OiByLmhlaWdodCB9O1xuICAgIHJldHVybiBvLmJvcmRlckJveCA/IChvLmlubmVyV2lkdGggLT0gby5ob3JQYWRkaW5ncywgby5pbm5lckhlaWdodCAtPSBvLnZlcnRQYWRkaW5ncykgOiAoby5vdXRlcldpZHRoICs9IG8uaG9yUGFkZGluZ3MsIG8ub3V0ZXJIZWlnaHQgKz0gby52ZXJ0UGFkZGluZ3MpLCBvO1xuICB9LCBlLnByb3RvdHlwZS5fZ2V0QXV0b3NpemVNb2RlID0gZnVuY3Rpb24obikge1xuICAgIHZhciBpID0geyB4OiAhMSwgeTogITEgfTtcbiAgICByZXR1cm4gbiA9PT0gXCJ4eVwiID8gaS54ID0gaS55ID0gITAgOiBuID09PSBcInlcIiB8fCBuID09PSAhMCA/IGkueSA9ICEwIDogbiA9PT0gXCJ4XCIgJiYgKGkueCA9ICEwKSwgaTtcbiAgfSwgZS5wcm90b3R5cGUuYXV0b3NpemUgPSBmdW5jdGlvbihuKSB7XG4gICAgdmFyIGkgPSB0aGlzLl9nZXRBdXRvc2l6ZU1vZGUobiksIGEgPSB0aGlzLl9nZXRCb3hTdHlsZXModGhpcy4kY29udGFpbmVyKSwgciA9IHRoaXMuZ2V0Q29udGVudFNpemUobiksIHMgPSB0aGlzLiRjb250YWluZXI7XG4gICAgaS54ICYmIChhLmJvcmRlckJveCAmJiAoci53aWR0aCArPSBhLmhvclBhZGRpbmdzKSwgcy5zdHlsZS53aWR0aCA9IHIud2lkdGggKyBcInB4XCIpLCBpLnkgJiYgKGEuYm9yZGVyQm94ICYmIChyLmhlaWdodCArPSBhLnZlcnRQYWRkaW5ncyksIHMuc3R5bGUuaGVpZ2h0ID0gci5oZWlnaHQgKyBcInB4XCIpO1xuICB9LCBlLnByb3RvdHlwZS5nZXRTaXplID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fc2l6ZXMgPSBbXTtcbiAgICBmb3IgKHZhciBuID0gMCwgaSA9IDAsIGEgPSAxZTExLCByID0gMCwgcyA9IDFlMTEsIG8gPSAwLCBsID0gMDsgbCA8IHRoaXMuJGNlbGxzLmxlbmd0aDsgbCsrKSB7XG4gICAgICB2YXIgZCA9IHRoaXMuX3NpemVzW2xdID0gdGhpcy4kY2VsbHNbbF0uZ2V0U2l6ZSgpO1xuICAgICAgdGhpcy4kY2VsbHNbbF0uJGNvbmZpZy5oaWRkZW4gfHwgKHRoaXMuX3hMYXlvdXQgPyAoIWQud2lkdGggJiYgZC5taW5XaWR0aCA/IG4gKz0gZC5taW5XaWR0aCA6IG4gKz0gZC53aWR0aCwgYSArPSBkLm1heFdpZHRoLCBpICs9IGQubWluV2lkdGgsIHIgPSBNYXRoLm1heChyLCBkLmhlaWdodCksIHMgPSBNYXRoLm1pbihzLCBkLm1heEhlaWdodCksIG8gPSBNYXRoLm1heChvLCBkLm1pbkhlaWdodCkpIDogKCFkLmhlaWdodCAmJiBkLm1pbkhlaWdodCA/IHIgKz0gZC5taW5IZWlnaHQgOiByICs9IGQuaGVpZ2h0LCBzICs9IGQubWF4SGVpZ2h0LCBvICs9IGQubWluSGVpZ2h0LCBuID0gTWF0aC5tYXgobiwgZC53aWR0aCksIGEgPSBNYXRoLm1pbihhLCBkLm1heFdpZHRoKSwgaSA9IE1hdGgubWF4KGksIGQubWluV2lkdGgpKSk7XG4gICAgfVxuICAgIHZhciBjID0gdC5wcm90b3R5cGUuZ2V0U2l6ZS5jYWxsKHRoaXMpO1xuICAgIHJldHVybiBjLm1heFdpZHRoID49IDFlNSAmJiAoYy5tYXhXaWR0aCA9IGEpLCBjLm1heEhlaWdodCA+PSAxZTUgJiYgKGMubWF4SGVpZ2h0ID0gcyksIGMubWluV2lkdGggPSBjLm1pbldpZHRoICE9IGMubWluV2lkdGggPyAwIDogYy5taW5XaWR0aCwgYy5taW5IZWlnaHQgPSBjLm1pbkhlaWdodCAhPSBjLm1pbkhlaWdodCA/IDAgOiBjLm1pbkhlaWdodCwgdGhpcy5feExheW91dCA/IChjLm1pbldpZHRoICs9IHRoaXMuJGNvbmZpZy5tYXJnaW4gKiB0aGlzLiRjZWxscy5sZW5ndGggfHwgMCwgYy5taW5XaWR0aCArPSAyICogdGhpcy4kY29uZmlnLnBhZGRpbmcgfHwgMCwgYy5taW5IZWlnaHQgKz0gMiAqIHRoaXMuJGNvbmZpZy5wYWRkaW5nIHx8IDApIDogKGMubWluSGVpZ2h0ICs9IHRoaXMuJGNvbmZpZy5tYXJnaW4gKiB0aGlzLiRjZWxscy5sZW5ndGggfHwgMCwgYy5taW5IZWlnaHQgKz0gMiAqIHRoaXMuJGNvbmZpZy5wYWRkaW5nIHx8IDApLCBjO1xuICB9LCBlLnByb3RvdHlwZS5fY2FsY0ZyZWVTcGFjZSA9IGZ1bmN0aW9uKG4sIGksIGEpIHtcbiAgICB2YXIgciA9IGEgPyBpLm1pbldpZHRoIDogaS5taW5IZWlnaHQsIHMgPSBpLm1heFdpZHRoLCBvID0gbjtcbiAgICByZXR1cm4gbyA/IChvID4gcyAmJiAobyA9IHMpLCBvIDwgciAmJiAobyA9IHIpLCB0aGlzLl9mcmVlIC09IG8pIDogKChvID0gTWF0aC5mbG9vcih0aGlzLl9mcmVlIC8gdGhpcy5fZ3Jhdml0eSAqIGkuZ3Jhdml0eSkpID4gcyAmJiAobyA9IHMsIHRoaXMuX2ZyZWUgLT0gbywgdGhpcy5fZ3Jhdml0eSAtPSBpLmdyYXZpdHkpLCBvIDwgciAmJiAobyA9IHIsIHRoaXMuX2ZyZWUgLT0gbywgdGhpcy5fZ3Jhdml0eSAtPSBpLmdyYXZpdHkpKSwgbztcbiAgfSwgZS5wcm90b3R5cGUuX2NhbGNTaXplID0gZnVuY3Rpb24obiwgaSwgYSkge1xuICAgIHZhciByID0gbiwgcyA9IGEgPyBpLm1pbldpZHRoIDogaS5taW5IZWlnaHQsIG8gPSBhID8gaS5tYXhXaWR0aCA6IGkubWF4SGVpZ2h0O1xuICAgIHJldHVybiByIHx8IChyID0gTWF0aC5mbG9vcih0aGlzLl9mcmVlIC8gdGhpcy5fZ3Jhdml0eSAqIGkuZ3Jhdml0eSkpLCByID4gbyAmJiAociA9IG8pLCByIDwgcyAmJiAociA9IHMpLCByO1xuICB9LCBlLnByb3RvdHlwZS5fY29uZmlndXJlQm9yZGVycyA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuJHJvb3QgJiYgdGhpcy5fc2V0Qm9yZGVycyhbdGhpcy5fYm9yZGVycy5sZWZ0LCB0aGlzLl9ib3JkZXJzLnRvcCwgdGhpcy5fYm9yZGVycy5yaWdodCwgdGhpcy5fYm9yZGVycy5ib3R0b21dLCB0aGlzKTtcbiAgICBmb3IgKHZhciBuID0gdGhpcy5feExheW91dCA/IHRoaXMuX2JvcmRlcnMucmlnaHQgOiB0aGlzLl9ib3JkZXJzLmJvdHRvbSwgaSA9IHRoaXMuJGNlbGxzLCBhID0gaS5sZW5ndGggLSAxLCByID0gYTsgciA+PSAwOyByLS0pIGlmICghaVtyXS4kY29uZmlnLmhpZGRlbikge1xuICAgICAgYSA9IHI7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgZm9yIChyID0gMDsgciA8IGkubGVuZ3RoOyByKyspIGlmICghaVtyXS4kY29uZmlnLmhpZGRlbikge1xuICAgICAgdmFyIHMgPSByID49IGEsIG8gPSBcIlwiO1xuICAgICAgIXMgJiYgaVtyICsgMV0gJiYgaVtyICsgMV0uJGNvbmZpZy52aWV3ID09IFwic2Nyb2xsYmFyXCIgJiYgKHRoaXMuX3hMYXlvdXQgPyBzID0gITAgOiBvID0gXCJnYW50dF9sYXlvdXRfY2VsbF9ib3JkZXJfdHJhbnNwYXJlbnRcIiksIHRoaXMuX3NldEJvcmRlcnMocyA/IFtdIDogW24sIG9dLCBpW3JdKTtcbiAgICB9XG4gIH0sIGUucHJvdG90eXBlLl91cGRhdGVDZWxsVmlzaWJpbGl0eSA9IGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIG4gPSB0aGlzLl92aXNpYmxlQ2VsbHMgfHwge30sIGkgPSAhdGhpcy5fdmlzaWJsZUNlbGxzLCBhID0ge30sIHIgPSBudWxsLCBzID0gW10sIG8gPSAwOyBvIDwgdGhpcy5fc2l6ZXMubGVuZ3RoOyBvKyspIChyID0gdGhpcy4kY2VsbHNbb10pLiRjb25maWcuaGlkZV9lbXB0eSAmJiBzLnB1c2gociksICFpICYmIHIuJGNvbmZpZy5oaWRkZW4gJiYgbltyLiRpZF0gPyByLl9oaWRlKCEwKSA6IHIuJGNvbmZpZy5oaWRkZW4gfHwgbltyLiRpZF0gfHwgci5faGlkZSghMSksIHIuJGNvbmZpZy5oaWRkZW4gfHwgKGFbci4kaWRdID0gITApO1xuICAgIGZvciAodGhpcy5fdmlzaWJsZUNlbGxzID0gYSwgbyA9IDA7IG8gPCBzLmxlbmd0aDsgbysrKSB7XG4gICAgICB2YXIgbCA9IChyID0gc1tvXSkuJGNlbGxzLCBkID0gITA7XG4gICAgICBsLmZvckVhY2goZnVuY3Rpb24oYykge1xuICAgICAgICBjLiRjb25maWcuaGlkZGVuIHx8IGMuJGNvbmZpZy5yZXNpemVyIHx8IChkID0gITEpO1xuICAgICAgfSksIHIuJGNvbmZpZy5oaWRkZW4gPSBkO1xuICAgIH1cbiAgfSwgZS5wcm90b3R5cGUuc2V0U2l6ZSA9IGZ1bmN0aW9uKG4sIGkpIHtcbiAgICB0aGlzLl9jb25maWd1cmVCb3JkZXJzKCksIHQucHJvdG90eXBlLnNldFNpemUuY2FsbCh0aGlzLCBuLCBpKSwgaSA9IHRoaXMuJGxhc3RTaXplLmNvbnRlbnRZLCBuID0gdGhpcy4kbGFzdFNpemUuY29udGVudFg7XG4gICAgdmFyIGEsIHIsIHMgPSB0aGlzLiRjb25maWcucGFkZGluZyB8fCAwO1xuICAgIHRoaXMuJHZpZXcuc3R5bGUucGFkZGluZyA9IHMgKyBcInB4XCIsIHRoaXMuX2dyYXZpdHkgPSAwLCB0aGlzLl9mcmVlID0gdGhpcy5feExheW91dCA/IG4gOiBpLCB0aGlzLl9mcmVlIC09IDIgKiBzLCB0aGlzLl91cGRhdGVDZWxsVmlzaWJpbGl0eSgpO1xuICAgIGZvciAodmFyIG8gPSAwOyBvIDwgdGhpcy5fc2l6ZXMubGVuZ3RoOyBvKyspIGlmICghKGEgPSB0aGlzLiRjZWxsc1tvXSkuJGNvbmZpZy5oaWRkZW4pIHtcbiAgICAgIHZhciBsID0gdGhpcy4kY29uZmlnLm1hcmdpbiB8fCAwO1xuICAgICAgYS4kbmFtZSAhPSBcInJlc2l6ZXJcIiB8fCBsIHx8IChsID0gLTEpO1xuICAgICAgdmFyIGQgPSBhLiR2aWV3LCBjID0gdGhpcy5feExheW91dCA/IFwibWFyZ2luUmlnaHRcIiA6IFwibWFyZ2luQm90dG9tXCI7XG4gICAgICBvICE9PSB0aGlzLiRjZWxscy5sZW5ndGggLSAxICYmIChkLnN0eWxlW2NdID0gbCArIFwicHhcIiwgdGhpcy5fZnJlZSAtPSBsKSwgciA9IHRoaXMuX3NpemVzW29dLCB0aGlzLl94TGF5b3V0ID8gci53aWR0aCB8fCAodGhpcy5fZ3Jhdml0eSArPSByLmdyYXZpdHkpIDogci5oZWlnaHQgfHwgKHRoaXMuX2dyYXZpdHkgKz0gci5ncmF2aXR5KTtcbiAgICB9XG4gICAgZm9yIChvID0gMDsgbyA8IHRoaXMuX3NpemVzLmxlbmd0aDsgbysrKSBpZiAoIShhID0gdGhpcy4kY2VsbHNbb10pLiRjb25maWcuaGlkZGVuKSB7XG4gICAgICB2YXIgdSA9IChyID0gdGhpcy5fc2l6ZXNbb10pLndpZHRoLCBoID0gci5oZWlnaHQ7XG4gICAgICB0aGlzLl94TGF5b3V0ID8gdGhpcy5fY2FsY0ZyZWVTcGFjZSh1LCByLCAhMCkgOiB0aGlzLl9jYWxjRnJlZVNwYWNlKGgsIHIsICExKTtcbiAgICB9XG4gICAgZm9yIChvID0gMDsgbyA8IHRoaXMuJGNlbGxzLmxlbmd0aDsgbysrKSBpZiAoIShhID0gdGhpcy4kY2VsbHNbb10pLiRjb25maWcuaGlkZGVuKSB7XG4gICAgICByID0gdGhpcy5fc2l6ZXNbb107XG4gICAgICB2YXIgZyA9IHZvaWQgMCwgcCA9IHZvaWQgMDtcbiAgICAgIHRoaXMuX3hMYXlvdXQgPyAoZyA9IHRoaXMuX2NhbGNTaXplKHIud2lkdGgsIHIsICEwKSwgcCA9IGkgLSAyICogcykgOiAoZyA9IG4gLSAyICogcywgcCA9IHRoaXMuX2NhbGNTaXplKHIuaGVpZ2h0LCByLCAhMSkpLCBhLnNldFNpemUoZywgcCk7XG4gICAgfVxuICB9LCBlO1xufShIdCksIF9hID0gZnVuY3Rpb24odCkge1xuICBmdW5jdGlvbiBlKG4sIGksIGEpIHtcbiAgICBmb3IgKHZhciByID0gdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXMsIHMgPSAwOyBzIDwgci4kY2VsbHMubGVuZ3RoOyBzKyspIHIuJGNlbGxzW3NdLiRjb25maWcuaGlkZGVuID0gcyAhPT0gMDtcbiAgICByZXR1cm4gci4kY2VsbCA9IHIuJGNlbGxzWzBdLCByLiRuYW1lID0gXCJ2aWV3TGF5b3V0XCIsIHI7XG4gIH1cbiAgcmV0dXJuIHooZSwgdCksIGUucHJvdG90eXBlLmNlbGwgPSBmdW5jdGlvbihuKSB7XG4gICAgdmFyIGkgPSB0LnByb3RvdHlwZS5jZWxsLmNhbGwodGhpcywgbik7XG4gICAgcmV0dXJuIGkuJHZpZXcgfHwgdGhpcy4kZmlsbChudWxsLCB0aGlzKSwgaTtcbiAgfSwgZS5wcm90b3R5cGUubW92ZVZpZXcgPSBmdW5jdGlvbihuKSB7XG4gICAgdmFyIGkgPSB0aGlzLiR2aWV3O1xuICAgIHRoaXMuJGNlbGwgJiYgKHRoaXMuJGNlbGwuJGNvbmZpZy5oaWRkZW4gPSAhMCwgaS5yZW1vdmVDaGlsZCh0aGlzLiRjZWxsLiR2aWV3KSksIHRoaXMuJGNlbGwgPSBuLCBpLmFwcGVuZENoaWxkKG4uJHZpZXcpO1xuICB9LCBlLnByb3RvdHlwZS5zZXRTaXplID0gZnVuY3Rpb24obiwgaSkge1xuICAgIEh0LnByb3RvdHlwZS5zZXRTaXplLmNhbGwodGhpcywgbiwgaSk7XG4gIH0sIGUucHJvdG90eXBlLnNldENvbnRlbnRTaXplID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG4gPSB0aGlzLiRsYXN0U2l6ZTtcbiAgICB0aGlzLiRjZWxsLnNldFNpemUobi5jb250ZW50WCwgbi5jb250ZW50WSk7XG4gIH0sIGUucHJvdG90eXBlLmdldFNpemUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbiA9IHQucHJvdG90eXBlLmdldFNpemUuY2FsbCh0aGlzKTtcbiAgICBpZiAodGhpcy4kY2VsbCkge1xuICAgICAgdmFyIGkgPSB0aGlzLiRjZWxsLmdldFNpemUoKTtcbiAgICAgIGlmICh0aGlzLiRjb25maWcuYnlNYXhTaXplKSBmb3IgKHZhciBhID0gMDsgYSA8IHRoaXMuJGNlbGxzLmxlbmd0aDsgYSsrKSB7XG4gICAgICAgIHZhciByID0gdGhpcy4kY2VsbHNbYV0uZ2V0U2l6ZSgpO1xuICAgICAgICBmb3IgKHZhciBzIGluIGkpIGlbc10gPSBNYXRoLm1heChpW3NdLCByW3NdKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIG8gaW4gbikgbltvXSA9IG5bb10gfHwgaVtvXTtcbiAgICAgIG4uZ3Jhdml0eSA9IE1hdGgubWF4KG4uZ3Jhdml0eSwgaS5ncmF2aXR5KTtcbiAgICB9XG4gICAgcmV0dXJuIG47XG4gIH0sIGU7XG59KGtuKSwgZ2EgPSBmdW5jdGlvbih0KSB7XG4gIGZ1bmN0aW9uIGUobiwgaSwgYSkge1xuICAgIHZhciByID0gdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgaWYgKGkudmlldykge1xuICAgICAgaS5pZCAmJiAodGhpcy4kaWQgPSBzdCgpKTtcbiAgICAgIHZhciBzID0gcShpKTtcbiAgICAgIGlmIChkZWxldGUgcy5jb25maWcsIGRlbGV0ZSBzLnRlbXBsYXRlcywgdGhpcy4kY29udGVudCA9IHRoaXMuJGZhY3RvcnkuY3JlYXRlVmlldyhpLnZpZXcsIHRoaXMsIHMsIHRoaXMpLCAhdGhpcy4kY29udGVudCkgcmV0dXJuICExO1xuICAgIH1cbiAgICByZXR1cm4gci4kbmFtZSA9IFwidmlld0NlbGxcIiwgcjtcbiAgfVxuICByZXR1cm4geihlLCB0KSwgZS5wcm90b3R5cGUuZGVzdHJ1Y3RvciA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY2xlYXIoKSwgdC5wcm90b3R5cGUuZGVzdHJ1Y3Rvci5jYWxsKHRoaXMpO1xuICB9LCBlLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLiRpbml0aWFsaXplZCA9ICExLCB0aGlzLiRjb250ZW50KSB7XG4gICAgICB2YXIgbiA9IHRoaXMuJGNvbnRlbnQudW5sb2FkIHx8IHRoaXMuJGNvbnRlbnQuZGVzdHJ1Y3RvcjtcbiAgICAgIG4gJiYgbi5jYWxsKHRoaXMuJGNvbnRlbnQpO1xuICAgIH1cbiAgICB0LnByb3RvdHlwZS5jbGVhci5jYWxsKHRoaXMpO1xuICB9LCBlLnByb3RvdHlwZS5zY3JvbGxUbyA9IGZ1bmN0aW9uKG4sIGkpIHtcbiAgICB0aGlzLiRjb250ZW50ICYmIHRoaXMuJGNvbnRlbnQuc2Nyb2xsVG8gPyB0aGlzLiRjb250ZW50LnNjcm9sbFRvKG4sIGkpIDogdC5wcm90b3R5cGUuc2Nyb2xsVG8uY2FsbCh0aGlzLCBuLCBpKTtcbiAgfSwgZS5wcm90b3R5cGUuX3NldENvbnRlbnRTaXplID0gZnVuY3Rpb24obiwgaSkge1xuICAgIHZhciBhID0gdGhpcy5fZ2V0Qm9yZGVyU2l6ZXMoKTtcbiAgICBpZiAodHlwZW9mIG4gPT0gXCJudW1iZXJcIikge1xuICAgICAgdmFyIHIgPSBuICsgYS5ob3Jpem9udGFsO1xuICAgICAgdGhpcy4kY29uZmlnLndpZHRoID0gcjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpID09IFwibnVtYmVyXCIpIHtcbiAgICAgIHZhciBzID0gaSArIGEudmVydGljYWw7XG4gICAgICB0aGlzLiRjb25maWcuaGVpZ2h0ID0gcztcbiAgICB9XG4gIH0sIGUucHJvdG90eXBlLnNldFNpemUgPSBmdW5jdGlvbihuLCBpKSB7XG4gICAgaWYgKHQucHJvdG90eXBlLnNldFNpemUuY2FsbCh0aGlzLCBuLCBpKSwgIXRoaXMuJHByZVJlc2l6ZSAmJiB0aGlzLiRjb250ZW50ICYmICF0aGlzLiRpbml0aWFsaXplZCkge1xuICAgICAgdGhpcy4kaW5pdGlhbGl6ZWQgPSAhMDtcbiAgICAgIHZhciBhID0gdGhpcy4kdmlldy5jaGlsZE5vZGVzWzBdLCByID0gdGhpcy4kdmlldy5jaGlsZE5vZGVzWzFdO1xuICAgICAgciB8fCAociA9IGEpLCB0aGlzLiRjb250ZW50LmluaXQocik7XG4gICAgfVxuICB9LCBlLnByb3RvdHlwZS5zZXRDb250ZW50U2l6ZSA9IGZ1bmN0aW9uKCkge1xuICAgICF0aGlzLiRwcmVSZXNpemUgJiYgdGhpcy4kY29udGVudCAmJiB0aGlzLiRpbml0aWFsaXplZCAmJiB0aGlzLiRjb250ZW50LnNldFNpemUodGhpcy4kbGFzdFNpemUuY29udGVudFgsIHRoaXMuJGxhc3RTaXplLmNvbnRlbnRZKTtcbiAgfSwgZS5wcm90b3R5cGUuZ2V0Q29udGVudFNpemUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbiA9IHQucHJvdG90eXBlLmdldENvbnRlbnRTaXplLmNhbGwodGhpcyk7XG4gICAgaWYgKHRoaXMuJGNvbnRlbnQgJiYgdGhpcy4kaW5pdGlhbGl6ZWQpIHtcbiAgICAgIHZhciBpID0gdGhpcy4kY29udGVudC5nZXRTaXplKCk7XG4gICAgICBuLndpZHRoID0gaS5jb250ZW50WCA9PT0gdm9pZCAwID8gaS53aWR0aCA6IGkuY29udGVudFgsIG4uaGVpZ2h0ID0gaS5jb250ZW50WSA9PT0gdm9pZCAwID8gaS5oZWlnaHQgOiBpLmNvbnRlbnRZO1xuICAgIH1cbiAgICB2YXIgYSA9IHRoaXMuX2dldEJvcmRlclNpemVzKCk7XG4gICAgcmV0dXJuIG4ud2lkdGggKz0gYS5ob3Jpem9udGFsLCBuLmhlaWdodCArPSBhLnZlcnRpY2FsLCBuO1xuICB9LCBlO1xufShIdCksIGZhID0gZnVuY3Rpb24odCkge1xuICB2YXIgZSA9IFtcImFsdEtleVwiLCBcInNoaWZ0S2V5XCIsIFwibWV0YUtleVwiXTtcbiAgZnVuY3Rpb24gbihhLCByLCBzLCBvKSB7XG4gICAgdmFyIGwgPSB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB0aGlzLiRjb25maWcgPSBQKHIsIHsgc2Nyb2xsOiBcInhcIiB9KSwgbC5fc2Nyb2xsSG9yaXpvbnRhbEhhbmRsZXIgPSBSKGwuX3Njcm9sbEhvcml6b250YWxIYW5kbGVyLCBsKSwgbC5fc2Nyb2xsVmVydGljYWxIYW5kbGVyID0gUihsLl9zY3JvbGxWZXJ0aWNhbEhhbmRsZXIsIGwpLCBsLl9vdXRlclNjcm9sbFZlcnRpY2FsSGFuZGxlciA9IFIobC5fb3V0ZXJTY3JvbGxWZXJ0aWNhbEhhbmRsZXIsIGwpLCBsLl9vdXRlclNjcm9sbEhvcml6b250YWxIYW5kbGVyID0gUihsLl9vdXRlclNjcm9sbEhvcml6b250YWxIYW5kbGVyLCBsKSwgbC5fbW91c2VXaGVlbEhhbmRsZXIgPSBSKGwuX21vdXNlV2hlZWxIYW5kbGVyLCBsKSwgdGhpcy4kY29uZmlnLmhpZGRlbiA9ICEwO1xuICAgIHZhciBkID0gby5jb25maWcuc2Nyb2xsX3NpemU7XG4gICAgcmV0dXJuIG8uZW52LmlzSUUgJiYgKGQgKz0gMSksIHRoaXMuX2lzSG9yaXpvbnRhbCgpID8gKGwuJGNvbmZpZy5oZWlnaHQgPSBkLCBsLiRwYXJlbnQuJGNvbmZpZy5oZWlnaHQgPSBkKSA6IChsLiRjb25maWcud2lkdGggPSBkLCBsLiRwYXJlbnQuJGNvbmZpZy53aWR0aCA9IGQpLCB0aGlzLiRjb25maWcuc2Nyb2xsUG9zaXRpb24gPSAwLCBsLiRuYW1lID0gXCJzY3JvbGxlclwiLCBsO1xuICB9XG4gIGZ1bmN0aW9uIGkoYSwgcikge1xuICAgIGlmIChyLnB1c2goYSksIGEuJGNlbGxzKSBmb3IgKHZhciBzID0gMDsgcyA8IGEuJGNlbGxzLmxlbmd0aDsgcysrKSBpKGEuJGNlbGxzW3NdLCByKTtcbiAgfVxuICByZXR1cm4geihuLCB0KSwgbi5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKGEpIHtcbiAgICBhLmlubmVySFRNTCA9IHRoaXMuJHRvSFRNTCgpLCB0aGlzLiR2aWV3ID0gYS5maXJzdENoaWxkLCB0aGlzLiR2aWV3IHx8IHRoaXMuaW5pdCgpLCB0aGlzLl9pc1ZlcnRpY2FsKCkgPyB0aGlzLl9pbml0VmVydGljYWwoKSA6IHRoaXMuX2luaXRIb3Jpem9udGFsKCksIHRoaXMuX2luaXRNb3VzZVdoZWVsKCksIHRoaXMuX2luaXRMaW5rZWRWaWV3cygpO1xuICB9LCBuLnByb3RvdHlwZS4kdG9IVE1MID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiPGRpdiBjbGFzcz0nZ2FudHRfbGF5b3V0X2NlbGwgXCIgKyAodGhpcy5faXNIb3Jpem9udGFsKCkgPyBcImdhbnR0X2hvcl9zY3JvbGxcIiA6IFwiZ2FudHRfdmVyX3Njcm9sbFwiKSArIFwiJz48ZGl2IHN0eWxlPSdcIiArICh0aGlzLl9pc0hvcml6b250YWwoKSA/IFwid2lkdGg6MjAwMHB4XCIgOiBcImhlaWdodDoyMDAwcHhcIikgKyBcIic+PC9kaXY+PC9kaXY+XCI7XG4gIH0sIG4ucHJvdG90eXBlLl9nZXRSb290UGFyZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgZm9yICh2YXIgYSA9IHRoaXMuJHBhcmVudDsgYSAmJiBhLiRwYXJlbnQ7ICkgYSA9IGEuJHBhcmVudDtcbiAgICBpZiAoYSkgcmV0dXJuIGE7XG4gIH0sIG4ucHJvdG90eXBlLl9lYWNoVmlldyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhID0gW107XG4gICAgcmV0dXJuIGkodGhpcy5fZ2V0Um9vdFBhcmVudCgpLCBhKSwgYTtcbiAgfSwgbi5wcm90b3R5cGUuX2dldExpbmtlZFZpZXdzID0gZnVuY3Rpb24oKSB7XG4gICAgZm9yICh2YXIgYSA9IHRoaXMuX2VhY2hWaWV3KCksIHIgPSBbXSwgcyA9IDA7IHMgPCBhLmxlbmd0aDsgcysrKSBhW3NdLiRjb25maWcgJiYgKHRoaXMuX2lzVmVydGljYWwoKSAmJiBhW3NdLiRjb25maWcuc2Nyb2xsWSA9PSB0aGlzLiRpZCB8fCB0aGlzLl9pc0hvcml6b250YWwoKSAmJiBhW3NdLiRjb25maWcuc2Nyb2xsWCA9PSB0aGlzLiRpZCkgJiYgci5wdXNoKGFbc10pO1xuICAgIHJldHVybiByO1xuICB9LCBuLnByb3RvdHlwZS5faW5pdEhvcml6b250YWwgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLiRzY3JvbGxfaG9yID0gdGhpcy4kdmlldywgdGhpcy4kZG9tRXZlbnRzLmF0dGFjaCh0aGlzLiR2aWV3LCBcInNjcm9sbFwiLCB0aGlzLl9zY3JvbGxIb3Jpem9udGFsSGFuZGxlcik7XG4gIH0sIG4ucHJvdG90eXBlLl9pbml0TGlua2VkVmlld3MgPSBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciBhID0gdGhpcy5fZ2V0TGlua2VkVmlld3MoKSwgciA9IHRoaXMuX2lzVmVydGljYWwoKSA/IFwiZ2FudHRfbGF5b3V0X291dGVyX3Njcm9sbCBnYW50dF9sYXlvdXRfb3V0ZXJfc2Nyb2xsX3ZlcnRpY2FsXCIgOiBcImdhbnR0X2xheW91dF9vdXRlcl9zY3JvbGwgZ2FudHRfbGF5b3V0X291dGVyX3Njcm9sbF9ob3Jpem9udGFsXCIsIHMgPSAwOyBzIDwgYS5sZW5ndGg7IHMrKykgd3QoYVtzXS4kdmlldyB8fCBhW3NdLmdldE5vZGUoKSwgcik7XG4gIH0sIG4ucHJvdG90eXBlLl9pbml0VmVydGljYWwgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLiRzY3JvbGxfdmVyID0gdGhpcy4kdmlldywgdGhpcy4kZG9tRXZlbnRzLmF0dGFjaCh0aGlzLiR2aWV3LCBcInNjcm9sbFwiLCB0aGlzLl9zY3JvbGxWZXJ0aWNhbEhhbmRsZXIpO1xuICB9LCBuLnByb3RvdHlwZS5fdXBkYXRlTGlua2VkVmlld3MgPSBmdW5jdGlvbigpIHtcbiAgfSwgbi5wcm90b3R5cGUuX2luaXRNb3VzZVdoZWVsID0gZnVuY3Rpb24oKSB7XG4gICAgbXQuaXNGRiA/IHRoaXMuJGRvbUV2ZW50cy5hdHRhY2godGhpcy5fZ2V0Um9vdFBhcmVudCgpLiR2aWV3LCBcIndoZWVsXCIsIHRoaXMuX21vdXNlV2hlZWxIYW5kbGVyLCB7IHBhc3NpdmU6ICExIH0pIDogdGhpcy4kZG9tRXZlbnRzLmF0dGFjaCh0aGlzLl9nZXRSb290UGFyZW50KCkuJHZpZXcsIFwibW91c2V3aGVlbFwiLCB0aGlzLl9tb3VzZVdoZWVsSGFuZGxlciwgeyBwYXNzaXZlOiAhMSB9KTtcbiAgfSwgbi5wcm90b3R5cGUuc2Nyb2xsSG9yaXpvbnRhbGx5ID0gZnVuY3Rpb24oYSkge1xuICAgIGlmICghdGhpcy5fc2Nyb2xsaW5nKSB7XG4gICAgICB0aGlzLl9zY3JvbGxpbmcgPSAhMCwgdGhpcy4kc2Nyb2xsX2hvci5zY3JvbGxMZWZ0ID0gYSwgdGhpcy4kY29uZmlnLmNvZGVTY3JvbGxMZWZ0ID0gYSwgYSA9IHRoaXMuJHNjcm9sbF9ob3Iuc2Nyb2xsTGVmdDtcbiAgICAgIGZvciAodmFyIHIgPSB0aGlzLl9nZXRMaW5rZWRWaWV3cygpLCBzID0gMDsgcyA8IHIubGVuZ3RoOyBzKyspIHJbc10uc2Nyb2xsVG8gJiYgcltzXS5zY3JvbGxUbyhhLCB2b2lkIDApO1xuICAgICAgdmFyIG8gPSB0aGlzLiRjb25maWcuc2Nyb2xsUG9zaXRpb247XG4gICAgICB0aGlzLiRjb25maWcuc2Nyb2xsUG9zaXRpb24gPSBhLCB0aGlzLmNhbGxFdmVudChcIm9uU2Nyb2xsXCIsIFtvLCBhLCB0aGlzLiRjb25maWcuc2Nyb2xsXSksIHRoaXMuX3Njcm9sbGluZyA9ICExO1xuICAgIH1cbiAgfSwgbi5wcm90b3R5cGUuc2Nyb2xsVmVydGljYWxseSA9IGZ1bmN0aW9uKGEpIHtcbiAgICBpZiAoIXRoaXMuX3Njcm9sbGluZykge1xuICAgICAgdGhpcy5fc2Nyb2xsaW5nID0gITAsIHRoaXMuJHNjcm9sbF92ZXIuc2Nyb2xsVG9wID0gYSwgYSA9IHRoaXMuJHNjcm9sbF92ZXIuc2Nyb2xsVG9wO1xuICAgICAgZm9yICh2YXIgciA9IHRoaXMuX2dldExpbmtlZFZpZXdzKCksIHMgPSAwOyBzIDwgci5sZW5ndGg7IHMrKykgcltzXS5zY3JvbGxUbyAmJiByW3NdLnNjcm9sbFRvKHZvaWQgMCwgYSk7XG4gICAgICB2YXIgbyA9IHRoaXMuJGNvbmZpZy5zY3JvbGxQb3NpdGlvbjtcbiAgICAgIHRoaXMuJGNvbmZpZy5zY3JvbGxQb3NpdGlvbiA9IGEsIHRoaXMuY2FsbEV2ZW50KFwib25TY3JvbGxcIiwgW28sIGEsIHRoaXMuJGNvbmZpZy5zY3JvbGxdKSwgdGhpcy5fc2Nyb2xsaW5nID0gITE7XG4gICAgfVxuICB9LCBuLnByb3RvdHlwZS5faXNWZXJ0aWNhbCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLiRjb25maWcuc2Nyb2xsID09IFwieVwiO1xuICB9LCBuLnByb3RvdHlwZS5faXNIb3Jpem9udGFsID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuJGNvbmZpZy5zY3JvbGwgPT0gXCJ4XCI7XG4gIH0sIG4ucHJvdG90eXBlLl9zY3JvbGxIb3Jpem9udGFsSGFuZGxlciA9IGZ1bmN0aW9uKGEpIHtcbiAgICBpZiAoIXRoaXMuX2lzVmVydGljYWwoKSAmJiAhdGhpcy5fc2Nyb2xsaW5nKSB7XG4gICAgICBpZiAoLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkgLSAodGhpcy5fd2hlZWxfdGltZSB8fCAwKSA8IDEwMCkgcmV0dXJuICEwO1xuICAgICAgdmFyIHIgPSB0aGlzLiRzY3JvbGxfaG9yLnNjcm9sbExlZnQ7XG4gICAgICB0aGlzLnNjcm9sbEhvcml6b250YWxseShyKSwgdGhpcy5fb2xkTGVmdCA9IHRoaXMuJHNjcm9sbF9ob3Iuc2Nyb2xsTGVmdDtcbiAgICB9XG4gIH0sIG4ucHJvdG90eXBlLl9vdXRlclNjcm9sbEhvcml6b250YWxIYW5kbGVyID0gZnVuY3Rpb24oYSkge1xuICAgIHRoaXMuX2lzVmVydGljYWwoKTtcbiAgfSwgbi5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuJHBhcmVudC5zaG93KCk7XG4gIH0sIG4ucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLiRwYXJlbnQuaGlkZSgpO1xuICB9LCBuLnByb3RvdHlwZS5fZ2V0U2Nyb2xsU2l6ZSA9IGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIGEsIHIgPSAwLCBzID0gMCwgbyA9IHRoaXMuX2lzSG9yaXpvbnRhbCgpLCBsID0gdGhpcy5fZ2V0TGlua2VkVmlld3MoKSwgZCA9IG8gPyBcInNjcm9sbFdpZHRoXCIgOiBcInNjcm9sbEhlaWdodFwiLCBjID0gbyA/IFwiY29udGVudFhcIiA6IFwiY29udGVudFlcIiwgdSA9IG8gPyBcInhcIiA6IFwieVwiLCBoID0gdGhpcy5fZ2V0U2Nyb2xsT2Zmc2V0KCksIGcgPSAwOyBnIDwgbC5sZW5ndGg7IGcrKykgaWYgKChhID0gbFtnXSkgJiYgYS4kY29udGVudCAmJiBhLiRjb250ZW50LmdldFNpemUgJiYgIWEuJGNvbmZpZy5oaWRkZW4pIHtcbiAgICAgIHZhciBwLCB5ID0gYS4kY29udGVudC5nZXRTaXplKCk7XG4gICAgICBpZiAocCA9IHkuaGFzT3duUHJvcGVydHkoZCkgPyB5W2RdIDogeVtjXSwgaCkgeVtjXSA+IHlbdV0gJiYgeVtjXSA+IHIgJiYgcCA+IHlbdV0gLSBoICsgMiAmJiAociA9IHAgKyAobyA/IDAgOiAyKSwgcyA9IHlbdV0pO1xuICAgICAgZWxzZSB7XG4gICAgICAgIHZhciB2ID0gTWF0aC5tYXgoeVtjXSAtIHAsIDApO1xuICAgICAgICAocCArPSB2KSA+IE1hdGgubWF4KHlbdV0gLSB2LCAwKSAmJiBwID4gciAmJiAociA9IHAsIHMgPSB5W3VdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgb3V0ZXJTY3JvbGw6IHMsIGlubmVyU2Nyb2xsOiByIH07XG4gIH0sIG4ucHJvdG90eXBlLnNjcm9sbCA9IGZ1bmN0aW9uKGEpIHtcbiAgICB0aGlzLl9pc0hvcml6b250YWwoKSA/IHRoaXMuc2Nyb2xsSG9yaXpvbnRhbGx5KGEpIDogdGhpcy5zY3JvbGxWZXJ0aWNhbGx5KGEpO1xuICB9LCBuLnByb3RvdHlwZS5nZXRTY3JvbGxTdGF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7IHZpc2libGU6IHRoaXMuaXNWaXNpYmxlKCksIGRpcmVjdGlvbjogdGhpcy4kY29uZmlnLnNjcm9sbCwgc2l6ZTogdGhpcy4kY29uZmlnLm91dGVyU2l6ZSwgc2Nyb2xsU2l6ZTogdGhpcy4kY29uZmlnLnNjcm9sbFNpemUgfHwgMCwgcG9zaXRpb246IHRoaXMuJGNvbmZpZy5zY3JvbGxQb3NpdGlvbiB8fCAwIH07XG4gIH0sIG4ucHJvdG90eXBlLnNldFNpemUgPSBmdW5jdGlvbihhLCByKSB7XG4gICAgdC5wcm90b3R5cGUuc2V0U2l6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHZhciBzID0gdGhpcy5fZ2V0U2Nyb2xsU2l6ZSgpLCBvID0gKHRoaXMuX2lzVmVydGljYWwoKSA/IHIgOiBhKSAtIHRoaXMuX2dldFNjcm9sbE9mZnNldCgpICsgKHRoaXMuX2lzSG9yaXpvbnRhbCgpID8gMSA6IDApO1xuICAgIHMuaW5uZXJTY3JvbGwgJiYgbyA+IHMub3V0ZXJTY3JvbGwgJiYgKHMuaW5uZXJTY3JvbGwgKz0gbyAtIHMub3V0ZXJTY3JvbGwpLCB0aGlzLiRjb25maWcuc2Nyb2xsU2l6ZSA9IHMuaW5uZXJTY3JvbGwsIHRoaXMuJGNvbmZpZy53aWR0aCA9IGEsIHRoaXMuJGNvbmZpZy5oZWlnaHQgPSByLCB0aGlzLl9zZXRTY3JvbGxTaXplKHMuaW5uZXJTY3JvbGwpO1xuICB9LCBuLnByb3RvdHlwZS5pc1Zpc2libGUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gISghdGhpcy4kcGFyZW50IHx8ICF0aGlzLiRwYXJlbnQuJHZpZXcucGFyZW50Tm9kZSk7XG4gIH0sIG4ucHJvdG90eXBlLnNob3VsZFNob3cgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYSA9IHRoaXMuX2dldFNjcm9sbFNpemUoKTtcbiAgICByZXR1cm4gISghYS5pbm5lclNjcm9sbCAmJiB0aGlzLiRwYXJlbnQgJiYgdGhpcy4kcGFyZW50LiR2aWV3LnBhcmVudE5vZGUpICYmICEoIWEuaW5uZXJTY3JvbGwgfHwgdGhpcy4kcGFyZW50ICYmIHRoaXMuJHBhcmVudC4kdmlldy5wYXJlbnROb2RlKTtcbiAgfSwgbi5wcm90b3R5cGUuc2hvdWxkSGlkZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAhKHRoaXMuX2dldFNjcm9sbFNpemUoKS5pbm5lclNjcm9sbCB8fCAhdGhpcy4kcGFyZW50IHx8ICF0aGlzLiRwYXJlbnQuJHZpZXcucGFyZW50Tm9kZSk7XG4gIH0sIG4ucHJvdG90eXBlLnRvZ2dsZVZpc2liaWxpdHkgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnNob3VsZEhpZGUoKSA/IHRoaXMuaGlkZSgpIDogdGhpcy5zaG91bGRTaG93KCkgJiYgdGhpcy5zaG93KCk7XG4gIH0sIG4ucHJvdG90eXBlLl9nZXRTY2FsZU9mZnNldCA9IGZ1bmN0aW9uKGEpIHtcbiAgICB2YXIgciA9IDA7XG4gICAgcmV0dXJuICFhIHx8IGEuJGNvbmZpZy52aWV3ICE9IFwidGltZWxpbmVcIiAmJiBhLiRjb25maWcudmlldyAhPSBcImdyaWRcIiB8fCAociA9IGEuJGNvbnRlbnQuJGdldENvbmZpZygpLnNjYWxlX2hlaWdodCksIHI7XG4gIH0sIG4ucHJvdG90eXBlLl9nZXRTY3JvbGxPZmZzZXQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYSA9IDA7XG4gICAgaWYgKHRoaXMuX2lzVmVydGljYWwoKSkge1xuICAgICAgdmFyIHIgPSB0aGlzLiRwYXJlbnQuJHBhcmVudDtcbiAgICAgIGEgPSBNYXRoLm1heCh0aGlzLl9nZXRTY2FsZU9mZnNldChyLmdldFByZXZTaWJsaW5nKHRoaXMuJHBhcmVudC4kaWQpKSwgdGhpcy5fZ2V0U2NhbGVPZmZzZXQoci5nZXROZXh0U2libGluZyh0aGlzLiRwYXJlbnQuJGlkKSkpO1xuICAgIH0gZWxzZSBmb3IgKHZhciBzID0gdGhpcy5fZ2V0TGlua2VkVmlld3MoKSwgbyA9IDA7IG8gPCBzLmxlbmd0aDsgbysrKSB7XG4gICAgICB2YXIgbCA9IHNbb10uJHBhcmVudC4kY2VsbHMsIGQgPSBsW2wubGVuZ3RoIC0gMV07XG4gICAgICBpZiAoZCAmJiBkLiRjb25maWcudmlldyA9PSBcInNjcm9sbGJhclwiICYmIGQuJGNvbmZpZy5oaWRkZW4gPT09ICExKSB7XG4gICAgICAgIGEgPSBkLiRjb25maWcud2lkdGg7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYSB8fCAwO1xuICB9LCBuLnByb3RvdHlwZS5fc2V0U2Nyb2xsU2l6ZSA9IGZ1bmN0aW9uKGEpIHtcbiAgICB2YXIgciA9IHRoaXMuX2lzSG9yaXpvbnRhbCgpID8gXCJ3aWR0aFwiIDogXCJoZWlnaHRcIiwgcyA9IHRoaXMuX2lzSG9yaXpvbnRhbCgpID8gdGhpcy4kc2Nyb2xsX2hvciA6IHRoaXMuJHNjcm9sbF92ZXIsIG8gPSB0aGlzLl9nZXRTY3JvbGxPZmZzZXQoKSwgbCA9IHMuZmlyc3RDaGlsZDtcbiAgICBvID8gdGhpcy5faXNWZXJ0aWNhbCgpID8gKHRoaXMuJGNvbmZpZy5vdXRlclNpemUgPSB0aGlzLiRjb25maWcuaGVpZ2h0IC0gbyArIDMsIHMuc3R5bGUuaGVpZ2h0ID0gdGhpcy4kY29uZmlnLm91dGVyU2l6ZSArIFwicHhcIiwgcy5zdHlsZS50b3AgPSBvIC0gMSArIFwicHhcIiwgd3QocywgdGhpcy4kcGFyZW50Ll9ib3JkZXJzLnRvcCksIHd0KHMucGFyZW50Tm9kZSwgXCJnYW50dF90YXNrX3ZzY3JvbGxcIikpIDogKHRoaXMuJGNvbmZpZy5vdXRlclNpemUgPSB0aGlzLiRjb25maWcud2lkdGggLSBvICsgMSwgcy5zdHlsZS53aWR0aCA9IHRoaXMuJGNvbmZpZy5vdXRlclNpemUgKyBcInB4XCIpIDogKHMuc3R5bGUudG9wID0gXCJhdXRvXCIsIEd0KHMsIHRoaXMuJHBhcmVudC5fYm9yZGVycy50b3ApLCBHdChzLnBhcmVudE5vZGUsIFwiZ2FudHRfdGFza192c2Nyb2xsXCIpLCB0aGlzLiRjb25maWcub3V0ZXJTaXplID0gdGhpcy4kY29uZmlnLmhlaWdodCksIGwuc3R5bGVbcl0gPSBhICsgXCJweFwiO1xuICB9LCBuLnByb3RvdHlwZS5fc2Nyb2xsVmVydGljYWxIYW5kbGVyID0gZnVuY3Rpb24oYSkge1xuICAgIGlmICghdGhpcy5fc2Nyb2xsSG9yaXpvbnRhbEhhbmRsZXIoKSAmJiAhdGhpcy5fc2Nyb2xsaW5nKSB7XG4gICAgICB2YXIgciA9IHRoaXMuJHNjcm9sbF92ZXIuc2Nyb2xsVG9wO1xuICAgICAgciAhPSB0aGlzLl9vbGRUb3AgJiYgKHRoaXMuc2Nyb2xsVmVydGljYWxseShyKSwgdGhpcy5fb2xkVG9wID0gdGhpcy4kc2Nyb2xsX3Zlci5zY3JvbGxUb3ApO1xuICAgIH1cbiAgfSwgbi5wcm90b3R5cGUuX291dGVyU2Nyb2xsVmVydGljYWxIYW5kbGVyID0gZnVuY3Rpb24oYSkge1xuICAgIHRoaXMuX3Njcm9sbEhvcml6b250YWxIYW5kbGVyKCk7XG4gIH0sIG4ucHJvdG90eXBlLl9jaGVja1doZWVsVGFyZ2V0ID0gZnVuY3Rpb24oYSkge1xuICAgIGZvciAodmFyIHIgPSB0aGlzLl9nZXRMaW5rZWRWaWV3cygpLmNvbmNhdCh0aGlzKSwgcyA9IDA7IHMgPCByLmxlbmd0aDsgcysrKVxuICAgICAgaWYgKFkoYSwgcltzXS4kdmlldykpIHJldHVybiAhMDtcbiAgICByZXR1cm4gITE7XG4gIH0sIG4ucHJvdG90eXBlLl9tb3VzZVdoZWVsSGFuZGxlciA9IGZ1bmN0aW9uKGEpIHtcbiAgICB2YXIgciA9IGEudGFyZ2V0IHx8IGEuc3JjRWxlbWVudDtcbiAgICBpZiAodGhpcy5fY2hlY2tXaGVlbFRhcmdldChyKSkge1xuICAgICAgdGhpcy5fd2hlZWxfdGltZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICAgICAgdmFyIHMgPSB7fSwgbyA9IHsgeDogMSwgeTogMSB9LCBsID0gdGhpcy4kZ2FudHQuY29uZmlnLndoZWVsX3Njcm9sbF9zZW5zaXRpdml0eTtcbiAgICAgIHR5cGVvZiBsID09IFwibnVtYmVyXCIgJiYgbCA/IG8gPSB7IHg6IGwsIHk6IGwgfSA6IHt9LnRvU3RyaW5nLmFwcGx5KGwpID09IFwiW29iamVjdCBPYmplY3RdXCIgJiYgKG8gPSB7IHg6IGwueCwgeTogbC55IH0pO1xuICAgICAgdmFyIGQgPSBtdC5pc0ZGLCBjID0gZCA/IGEuZGVsdGFYIDogYS53aGVlbERlbHRhWCwgdSA9IGQgPyBhLmRlbHRhWSA6IGEud2hlZWxEZWx0YSwgaCA9IC0yMDtcbiAgICAgIGlmIChkKSB7XG4gICAgICAgIGNvbnN0IGsgPSBwYXJzZUludChuYXZpZ2F0b3IudXNlckFnZW50LnNwbGl0KFwiRmlyZWZveC9cIilbMV0pO1xuICAgICAgICBoID0gayA8PSA4NyA/IGEuZGVsdGFNb2RlICE9PSAwID8gLTQwIDogLTEwIDogayA8PSA5MCA/IC0zIDogayA8PSA5NiA/IC0xLjUgOiAtMTtcbiAgICAgIH1cbiAgICAgIHZhciBnID0gZCA/IGMgKiBoICogby54IDogMiAqIGMgKiBvLngsIHAgPSBkID8gdSAqIGggKiBvLnkgOiB1ICogby55LCB5ID0gdGhpcy4kZ2FudHQuY29uZmlnLmhvcml6b250YWxfc2Nyb2xsX2tleTtcbiAgICAgIGlmICh5ICE9PSAhMSAmJiBlLmluZGV4T2YoeSkgPj0gMCAmJiAoIWFbeV0gfHwgYS5kZWx0YVggfHwgYS53aGVlbERlbHRhWCB8fCAoZyA9IDIgKiBwLCBwID0gMCkpLCBnICYmIE1hdGguYWJzKGcpID4gTWF0aC5hYnMocCkpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzVmVydGljYWwoKSkgcmV0dXJuO1xuICAgICAgICBpZiAocy54IHx8ICF0aGlzLiRzY3JvbGxfaG9yIHx8ICF0aGlzLiRzY3JvbGxfaG9yLm9mZnNldFdpZHRoKSByZXR1cm4gITA7XG4gICAgICAgIHZhciB2ID0gZyAvIC00MCwgYiA9IHRoaXMuX29sZExlZnQsIF8gPSBiICsgMzAgKiB2O1xuICAgICAgICBpZiAodGhpcy5zY3JvbGxIb3Jpem9udGFsbHkoXyksIHRoaXMuJHNjcm9sbF9ob3Iuc2Nyb2xsTGVmdCA9IF8sIGIgPT0gdGhpcy4kc2Nyb2xsX2hvci5zY3JvbGxMZWZ0KSByZXR1cm4gITA7XG4gICAgICAgIHRoaXMuX29sZExlZnQgPSB0aGlzLiRzY3JvbGxfaG9yLnNjcm9sbExlZnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5faXNIb3Jpem9udGFsKCkpIHJldHVybjtcbiAgICAgICAgaWYgKHMueSB8fCAhdGhpcy4kc2Nyb2xsX3ZlciB8fCAhdGhpcy4kc2Nyb2xsX3Zlci5vZmZzZXRIZWlnaHQpIHJldHVybiAhMDtcbiAgICAgICAgdiA9IHAgLyAtNDAsIHAgPT09IHZvaWQgMCAmJiAodiA9IGEuZGV0YWlsKTtcbiAgICAgICAgdmFyIG0gPSB0aGlzLl9vbGRUb3AsIGYgPSB0aGlzLiRzY3JvbGxfdmVyLnNjcm9sbFRvcCArIDMwICogdjtcbiAgICAgICAgaWYgKHRoaXMuc2Nyb2xsVmVydGljYWxseShmKSwgdGhpcy4kc2Nyb2xsX3Zlci5zY3JvbGxUb3AgPSBmLCBtID09IHRoaXMuJHNjcm9sbF92ZXIuc2Nyb2xsVG9wKSByZXR1cm4gITA7XG4gICAgICAgIHRoaXMuX29sZFRvcCA9IHRoaXMuJHNjcm9sbF92ZXIuc2Nyb2xsVG9wO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGEucHJldmVudERlZmF1bHQgJiYgYS5wcmV2ZW50RGVmYXVsdCgpLCBhLmNhbmNlbEJ1YmJsZSA9ICEwLCAhMTtcbiAgICB9XG4gIH0sIG47XG59KEh0KTtcbmZ1bmN0aW9uIHluKHQpIHtcbiAgdmFyIGUgPSB7fSwgbiA9IHt9LCBpID0gbnVsbCwgYSA9IC0xLCByID0gbnVsbCwgcyA9IC8qIEBfX1BVUkVfXyAqLyBmdW5jdGlvbihvKSB7XG4gICAgdmFyIGwgPSAtMSwgZCA9IC0xO1xuICAgIHJldHVybiB7IHJlc2V0Q2FjaGU6IGZ1bmN0aW9uKCkge1xuICAgICAgbCA9IC0xLCBkID0gLTE7XG4gICAgfSwgX2dldFJvd0hlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbCA9PT0gLTEgJiYgKGwgPSBvLiRnZXRDb25maWcoKS5yb3dfaGVpZ2h0KSwgbDtcbiAgICB9LCBfcmVmcmVzaFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMucmVzZXRDYWNoZSgpLCBkID0gITA7XG4gICAgICB2YXIgYyA9IG8uJGNvbmZpZy5yb3dTdG9yZTtcbiAgICAgIGlmIChjKSBmb3IgKHZhciB1ID0gdGhpcy5fZ2V0Um93SGVpZ2h0KCksIGggPSAwOyBoIDwgYy5mdWxsT3JkZXIubGVuZ3RoOyBoKyspIHtcbiAgICAgICAgdmFyIGcgPSBjLmdldEl0ZW0oYy5mdWxsT3JkZXJbaF0pO1xuICAgICAgICBpZiAoZyAmJiBnLnJvd19oZWlnaHQgJiYgZy5yb3dfaGVpZ2h0ICE9PSB1KSB7XG4gICAgICAgICAgZCA9ICExO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgY2FuVXNlU2ltcGxlQ2FsY3VsYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGQgPT09IC0xICYmIHRoaXMuX3JlZnJlc2hTdGF0ZSgpLCBkO1xuICAgIH0sIGdldFJvd1RvcDogZnVuY3Rpb24oYykge1xuICAgICAgcmV0dXJuIG8uJGNvbmZpZy5yb3dTdG9yZSA/IGMgKiB0aGlzLl9nZXRSb3dIZWlnaHQoKSA6IDA7XG4gICAgfSwgZ2V0SXRlbUhlaWdodDogZnVuY3Rpb24oYykge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldFJvd0hlaWdodCgpO1xuICAgIH0sIGdldFRvdGFsSGVpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBvLiRjb25maWcucm93U3RvcmUgPyBvLiRjb25maWcucm93U3RvcmUuY291bnRWaXNpYmxlKCkgKiB0aGlzLl9nZXRSb3dIZWlnaHQoKSA6IDA7XG4gICAgfSwgZ2V0SXRlbUluZGV4QnlUb3BQb3NpdGlvbjogZnVuY3Rpb24oYykge1xuICAgICAgcmV0dXJuIG8uJGNvbmZpZy5yb3dTdG9yZSA/IE1hdGguZmxvb3IoYyAvIHRoaXMuX2dldFJvd0hlaWdodCgpKSA6IDA7XG4gICAgfSB9O1xuICB9KHQpO1xuICByZXR1cm4geyBfcmVzZXRUb3BQb3NpdGlvbkhlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgZSA9IHt9LCBuID0ge30sIHMucmVzZXRDYWNoZSgpO1xuICB9LCBfcmVzZXRIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvID0gdGhpcy4kY29uZmlnLnJvd1N0b3JlLCBsID0gdGhpcy5nZXRDYWNoZVN0YXRlVG90YWxIZWlnaHQobyk7XG4gICAgciA/IHRoaXMuc2hvdWxkQ2xlYXJIZWlnaHRDYWNoZShyLCBsKSAmJiAociA9IGwsIGkgPSBudWxsKSA6IHIgPSBsLCBhID0gLTEsIHMucmVzZXRDYWNoZSgpO1xuICB9LCBnZXRSb3dUb3A6IGZ1bmN0aW9uKG8pIHtcbiAgICBpZiAocy5jYW5Vc2VTaW1wbGVDYWxjdWxhdGlvbigpKSByZXR1cm4gcy5nZXRSb3dUb3Aobyk7XG4gICAgdmFyIGwgPSB0aGlzLiRjb25maWcucm93U3RvcmU7XG4gICAgaWYgKCFsKSByZXR1cm4gMDtcbiAgICBpZiAobltvXSAhPT0gdm9pZCAwKSByZXR1cm4gbltvXTtcbiAgICBmb3IgKHZhciBkID0gbC5nZXRJbmRleFJhbmdlKCksIGMgPSAwLCB1ID0gMCwgaCA9IDA7IGggPCBkLmxlbmd0aDsgaCsrKSBuW2hdID0gYywgYyArPSB0aGlzLmdldEl0ZW1IZWlnaHQoZFtoXS5pZCksIGggPCBvICYmICh1ID0gYyk7XG4gICAgcmV0dXJuIHU7XG4gIH0sIGdldEl0ZW1Ub3A6IGZ1bmN0aW9uKG8pIHtcbiAgICBpZiAodGhpcy4kY29uZmlnLnJvd1N0b3JlKSB7XG4gICAgICBpZiAoZVtvXSAhPT0gdm9pZCAwKSByZXR1cm4gZVtvXTtcbiAgICAgIHZhciBsID0gdGhpcy4kY29uZmlnLnJvd1N0b3JlO1xuICAgICAgaWYgKCFsKSByZXR1cm4gMDtcbiAgICAgIHZhciBkID0gbC5nZXRJbmRleEJ5SWQobyk7XG4gICAgICBpZiAoZCA9PT0gLTEgJiYgbC5nZXRQYXJlbnQgJiYgbC5leGlzdHMobykpIHtcbiAgICAgICAgdmFyIGMgPSBsLmdldFBhcmVudChvKTtcbiAgICAgICAgaWYgKGwuZXhpc3RzKGMpKSB7XG4gICAgICAgICAgdmFyIHUgPSBsLmdldEl0ZW0oYyk7XG4gICAgICAgICAgaWYgKHRoaXMuJGdhbnR0LmlzU3BsaXRUYXNrKHUpKSByZXR1cm4gdGhpcy5nZXRJdGVtVG9wKGMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZVtvXSA9IHRoaXMuZ2V0Um93VG9wKGQpLCBlW29dO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfSwgZ2V0SXRlbUhlaWdodDogZnVuY3Rpb24obykge1xuICAgIGlmIChzLmNhblVzZVNpbXBsZUNhbGN1bGF0aW9uKCkpIHJldHVybiBzLmdldEl0ZW1IZWlnaHQobyk7XG4gICAgaWYgKCFpICYmIHRoaXMuJGNvbmZpZy5yb3dTdG9yZSAmJiB0aGlzLl9maWxsSGVpZ2h0Q2FjaGUodGhpcy4kY29uZmlnLnJvd1N0b3JlKSwgaVtvXSAhPT0gdm9pZCAwKSByZXR1cm4gaVtvXTtcbiAgICB2YXIgbCA9IHRoaXMuJGdldENvbmZpZygpLnJvd19oZWlnaHQ7XG4gICAgaWYgKHRoaXMuJGNvbmZpZy5yb3dTdG9yZSkge1xuICAgICAgdmFyIGQgPSB0aGlzLiRjb25maWcucm93U3RvcmU7XG4gICAgICBpZiAoIWQpIHJldHVybiBsO1xuICAgICAgdmFyIGMgPSBkLmdldEl0ZW0obyk7XG4gICAgICByZXR1cm4gaVtvXSA9IGMgJiYgYy5yb3dfaGVpZ2h0IHx8IGw7XG4gICAgfVxuICAgIHJldHVybiBsO1xuICB9LCBfZmlsbEhlaWdodENhY2hlOiBmdW5jdGlvbihvKSB7XG4gICAgaWYgKG8pIHtcbiAgICAgIGkgPSB7fTtcbiAgICAgIHZhciBsID0gdGhpcy4kZ2V0Q29uZmlnKCkucm93X2hlaWdodDtcbiAgICAgIG8uZWFjaEl0ZW0oZnVuY3Rpb24oZCkge1xuICAgICAgICByZXR1cm4gaVtkLmlkXSA9IGQgJiYgZC5yb3dfaGVpZ2h0IHx8IGw7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIGdldENhY2hlU3RhdGVUb3RhbEhlaWdodDogZnVuY3Rpb24obykge1xuICAgIHZhciBsID0gdGhpcy4kZ2V0Q29uZmlnKCkucm93X2hlaWdodCwgZCA9IHt9LCBjID0gW10sIHUgPSAwO1xuICAgIHJldHVybiBvICYmIG8uZWFjaEl0ZW0oZnVuY3Rpb24oaCkge1xuICAgICAgYy5wdXNoKGgpLCBkW2guaWRdID0gaC5yb3dfaGVpZ2h0LCB1ICs9IGgucm93X2hlaWdodCB8fCBsO1xuICAgIH0pLCB7IGdsb2JhbEhlaWdodDogbCwgaXRlbXM6IGMsIGNvdW50OiBjLmxlbmd0aCwgc3VtSGVpZ2h0OiB1IH07XG4gIH0sIHNob3VsZENsZWFySGVpZ2h0Q2FjaGU6IGZ1bmN0aW9uKG8sIGwpIHtcbiAgICBpZiAoby5jb3VudCAhPSBsLmNvdW50IHx8IG8uZ2xvYmFsSGVpZ2h0ICE9IGwuZ2xvYmFsSGVpZ2h0IHx8IG8uc3VtSGVpZ2h0ICE9IGwuc3VtSGVpZ2h0KSByZXR1cm4gITA7XG4gICAgZm9yICh2YXIgZCBpbiBvLml0ZW1zKSB7XG4gICAgICB2YXIgYyA9IGwuaXRlbXNbZF07XG4gICAgICBpZiAoYyAhPT0gdm9pZCAwICYmIGMgIT0gby5pdGVtc1tkXSkgcmV0dXJuICEwO1xuICAgIH1cbiAgICByZXR1cm4gITE7XG4gIH0sIGdldFRvdGFsSGVpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICBpZiAocy5jYW5Vc2VTaW1wbGVDYWxjdWxhdGlvbigpKSByZXR1cm4gcy5nZXRUb3RhbEhlaWdodCgpO1xuICAgIGlmIChhICE9IC0xKSByZXR1cm4gYTtcbiAgICBpZiAodGhpcy4kY29uZmlnLnJvd1N0b3JlKSB7XG4gICAgICB2YXIgbyA9IHRoaXMuJGNvbmZpZy5yb3dTdG9yZTtcbiAgICAgIHRoaXMuX2ZpbGxIZWlnaHRDYWNoZShvKTtcbiAgICAgIHZhciBsID0gdGhpcy5nZXRJdGVtSGVpZ2h0LmJpbmQodGhpcyksIGQgPSBvLmdldFZpc2libGVJdGVtcygpLCBjID0gMDtcbiAgICAgIHJldHVybiBkLmZvckVhY2goZnVuY3Rpb24odSkge1xuICAgICAgICBjICs9IGwodS5pZCk7XG4gICAgICB9KSwgYSA9IGMsIGM7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9LCBnZXRJdGVtSW5kZXhCeVRvcFBvc2l0aW9uOiBmdW5jdGlvbihvKSB7XG4gICAgaWYgKHRoaXMuJGNvbmZpZy5yb3dTdG9yZSkge1xuICAgICAgaWYgKHMuY2FuVXNlU2ltcGxlQ2FsY3VsYXRpb24oKSkgcmV0dXJuIHMuZ2V0SXRlbUluZGV4QnlUb3BQb3NpdGlvbihvKTtcbiAgICAgIGZvciAodmFyIGwgPSB0aGlzLiRjb25maWcucm93U3RvcmUsIGQgPSAwOyBkIDwgbC5jb3VudFZpc2libGUoKTsgZCsrKSB7XG4gICAgICAgIHZhciBjID0gdGhpcy5nZXRSb3dUb3AoZCksIHUgPSB0aGlzLmdldFJvd1RvcChkICsgMSk7XG4gICAgICAgIGlmICghdSkge1xuICAgICAgICAgIHZhciBoID0gbC5nZXRJZEJ5SW5kZXgoZCk7XG4gICAgICAgICAgdSA9IGMgKyB0aGlzLmdldEl0ZW1IZWlnaHQoaCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG8gPj0gYyAmJiBvIDwgdSkgcmV0dXJuIGQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gbC5jb3VudFZpc2libGUoKSArIDI7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9IH07XG59XG5jb25zdCBwYSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4geyByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICB9LCBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgfSB9O1xufTtcbnZhciBVdCA9IGZ1bmN0aW9uKHQsIGUsIG4sIGkpIHtcbiAgdGhpcy4kY29uZmlnID0gUCh7fSwgZSB8fCB7fSksIHRoaXMuJHNjYWxlSGVscGVyID0gbmV3IHBlKGkpLCB0aGlzLiRnYW50dCA9IGksIHRoaXMuX3Bvc0Zyb21EYXRlQ2FjaGUgPSB7fSwgdGhpcy5fdGltZWxpbmVEcmFnU2Nyb2xsID0gbnVsbCwgUCh0aGlzLCB5bih0aGlzKSksIG90KHRoaXMpO1xufTtcblV0LnByb3RvdHlwZSA9IHsgaW5pdDogZnVuY3Rpb24odCkge1xuICB0LmlubmVySFRNTCArPSBcIjxkaXYgY2xhc3M9J2dhbnR0X3Rhc2snIHN0eWxlPSd3aWR0aDppbmhlcml0O2hlaWdodDppbmhlcml0Oyc+PC9kaXY+XCIsIHRoaXMuJHRhc2sgPSB0LmNoaWxkTm9kZXNbMF0sIHRoaXMuJHRhc2suaW5uZXJIVE1MID0gXCI8ZGl2IGNsYXNzPSdnYW50dF90YXNrX3NjYWxlJz48L2Rpdj48ZGl2IGNsYXNzPSdnYW50dF9kYXRhX2FyZWEnPjwvZGl2PlwiLCB0aGlzLiR0YXNrX3NjYWxlID0gdGhpcy4kdGFzay5jaGlsZE5vZGVzWzBdLCB0aGlzLiR0YXNrX2RhdGEgPSB0aGlzLiR0YXNrLmNoaWxkTm9kZXNbMV0sIHRoaXMuJHRhc2tfZGF0YS5pbm5lckhUTUwgPSBcIjxkaXYgY2xhc3M9J2dhbnR0X3Rhc2tfYmcnPjwvZGl2PjxkaXYgY2xhc3M9J2dhbnR0X3Rhc2tfYmFzZWxpbmVzJz48L2Rpdj48ZGl2IGNsYXNzPSdnYW50dF9saW5rc19hcmVhJz48L2Rpdj48ZGl2IGNsYXNzPSdnYW50dF9iYXJzX2FyZWEnPjwvZGl2PjxkaXYgY2xhc3M9J2dhbnR0X3Rhc2tfY29uc3RyYWludHMnPjwvZGl2PjxkaXYgY2xhc3M9J2dhbnR0X3Rhc2tfZGVhZGxpbmVzJz48L2Rpdj5cIiwgdGhpcy4kdGFza19iZyA9IHRoaXMuJHRhc2tfZGF0YS5jaGlsZE5vZGVzWzBdLCB0aGlzLiR0YXNrX2Jhc2VsaW5lcyA9IHRoaXMuJHRhc2tfZGF0YS5jaGlsZE5vZGVzWzFdLCB0aGlzLiR0YXNrX2xpbmtzID0gdGhpcy4kdGFza19kYXRhLmNoaWxkTm9kZXNbMl0sIHRoaXMuJHRhc2tfYmFycyA9IHRoaXMuJHRhc2tfZGF0YS5jaGlsZE5vZGVzWzNdLCB0aGlzLiR0YXNrX2NvbnN0cmFpbnRzID0gdGhpcy4kdGFza19kYXRhLmNoaWxkTm9kZXNbNF0sIHRoaXMuJHRhc2tfZGVhZGxpbmVzID0gdGhpcy4kdGFza19kYXRhLmNoaWxkTm9kZXNbNV0sIHRoaXMuX3Rhc2tzID0geyBjb2xfd2lkdGg6IDAsIHdpZHRoOiBbXSwgZnVsbF93aWR0aDogMCwgdHJhY2VfeDogW10sIHJlbmRlcmVkOiB7fSB9O1xuICB2YXIgZSA9IHRoaXMuJGdldENvbmZpZygpLCBuID0gZVt0aGlzLiRjb25maWcuYmluZCArIFwiX2F0dHJpYnV0ZVwiXSwgaSA9IGVbdGhpcy4kY29uZmlnLmJpbmRMaW5rcyArIFwiX2F0dHJpYnV0ZVwiXTtcbiAgIW4gJiYgdGhpcy4kY29uZmlnLmJpbmQgJiYgKG4gPSBcImRhdGEtXCIgKyB0aGlzLiRjb25maWcuYmluZCArIFwiLWlkXCIpLCAhaSAmJiB0aGlzLiRjb25maWcuYmluZExpbmtzICYmIChpID0gXCJkYXRhLVwiICsgdGhpcy4kY29uZmlnLmJpbmRMaW5rcyArIFwiLWlkXCIpLCB0aGlzLiRjb25maWcuaXRlbV9hdHRyaWJ1dGUgPSBuIHx8IG51bGwsIHRoaXMuJGNvbmZpZy5saW5rX2F0dHJpYnV0ZSA9IGkgfHwgbnVsbDtcbiAgdmFyIGEgPSB0aGlzLl9jcmVhdGVMYXllckNvbmZpZygpO1xuICB0aGlzLiRjb25maWcubGF5ZXJzIHx8ICh0aGlzLiRjb25maWcubGF5ZXJzID0gYS50YXNrcyksIHRoaXMuJGNvbmZpZy5saW5rTGF5ZXJzIHx8ICh0aGlzLiRjb25maWcubGlua0xheWVycyA9IGEubGlua3MpLCB0aGlzLl9hdHRhY2hMYXllcnModGhpcy4kZ2FudHQpLCB0aGlzLmNhbGxFdmVudChcIm9uUmVhZHlcIiwgW10pLCB0aGlzLiRnYW50dC5leHQuZHJhZ1RpbWVsaW5lICYmICh0aGlzLl90aW1lbGluZURyYWdTY3JvbGwgPSB0aGlzLiRnYW50dC5leHQuZHJhZ1RpbWVsaW5lLmNyZWF0ZSgpLCB0aGlzLl90aW1lbGluZURyYWdTY3JvbGwuYXR0YWNoKHRoaXMpKTtcbn0sIHNldFNpemU6IGZ1bmN0aW9uKHQsIGUpIHtcbiAgdmFyIG4gPSB0aGlzLiRnZXRDb25maWcoKTtcbiAgaWYgKDEgKiB0ID09PSB0ICYmICh0aGlzLiRjb25maWcud2lkdGggPSB0KSwgMSAqIGUgPT09IGUpIHtcbiAgICB0aGlzLiRjb25maWcuaGVpZ2h0ID0gZTtcbiAgICB2YXIgaSA9IE1hdGgubWF4KHRoaXMuJGNvbmZpZy5oZWlnaHQgLSBuLnNjYWxlX2hlaWdodCk7XG4gICAgdGhpcy4kdGFza19kYXRhLnN0eWxlLmhlaWdodCA9IGkgKyBcInB4XCI7XG4gIH1cbiAgdGhpcy5yZWZyZXNoKCksIHRoaXMuJHRhc2tfYmcuc3R5bGUuYmFja2dyb3VuZEltYWdlID0gXCJcIiwgbi5zbWFydF9yZW5kZXJpbmcgJiYgdGhpcy4kY29uZmlnLnJvd1N0b3JlID8gdGhpcy4kdGFza19iZy5zdHlsZS5oZWlnaHQgPSB0aGlzLmdldFRvdGFsSGVpZ2h0KCkgKyBcInB4XCIgOiB0aGlzLiR0YXNrX2JnLnN0eWxlLmhlaWdodCA9IFwiXCI7XG4gIGZvciAodmFyIGEgPSB0aGlzLl90YXNrcywgciA9IHRoaXMuJHRhc2tfZGF0YS5jaGlsZE5vZGVzLCBzID0gMCwgbyA9IHIubGVuZ3RoOyBzIDwgbzsgcysrKSB7XG4gICAgdmFyIGwgPSByW3NdO1xuICAgIGwuaGFzQXR0cmlidXRlKFwiZGF0YS1sYXllclwiKSAmJiBsLnN0eWxlICYmIChsLnN0eWxlLndpZHRoID0gYS5mdWxsX3dpZHRoICsgXCJweFwiKTtcbiAgfVxufSwgaXNWaXNpYmxlOiBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuJHBhcmVudCAmJiB0aGlzLiRwYXJlbnQuJGNvbmZpZyA/ICF0aGlzLiRwYXJlbnQuJGNvbmZpZy5oaWRkZW4gOiB0aGlzLiR0YXNrLm9mZnNldFdpZHRoO1xufSwgZ2V0U2l6ZTogZnVuY3Rpb24oKSB7XG4gIHZhciB0ID0gdGhpcy4kZ2V0Q29uZmlnKCksIGUgPSB0aGlzLiRjb25maWcucm93U3RvcmUgPyB0aGlzLmdldFRvdGFsSGVpZ2h0KCkgOiAwLCBuID0gdGhpcy5pc1Zpc2libGUoKSA/IHRoaXMuX3Rhc2tzLmZ1bGxfd2lkdGggOiAwO1xuICByZXR1cm4geyB4OiB0aGlzLmlzVmlzaWJsZSgpID8gdGhpcy4kY29uZmlnLndpZHRoIDogMCwgeTogdGhpcy5pc1Zpc2libGUoKSA/IHRoaXMuJGNvbmZpZy5oZWlnaHQgOiAwLCBjb250ZW50WDogdGhpcy5pc1Zpc2libGUoKSA/IG4gOiAwLCBjb250ZW50WTogdGhpcy5pc1Zpc2libGUoKSA/IHQuc2NhbGVfaGVpZ2h0ICsgZSA6IDAsIHNjcm9sbEhlaWdodDogdGhpcy5pc1Zpc2libGUoKSA/IGUgOiAwLCBzY3JvbGxXaWR0aDogdGhpcy5pc1Zpc2libGUoKSA/IG4gOiAwIH07XG59LCBzY3JvbGxUbzogZnVuY3Rpb24odCwgZSkge1xuICBpZiAodGhpcy5pc1Zpc2libGUoKSkge1xuICAgIHZhciBuID0gITE7XG4gICAgdGhpcy4kY29uZmlnLnNjcm9sbFRvcCA9IHRoaXMuJGNvbmZpZy5zY3JvbGxUb3AgfHwgMCwgdGhpcy4kY29uZmlnLnNjcm9sbExlZnQgPSB0aGlzLiRjb25maWcuc2Nyb2xsTGVmdCB8fCAwLCAxICogZSA9PT0gZSAmJiAodGhpcy4kY29uZmlnLnNjcm9sbFRvcCA9IGUsIHRoaXMuJHRhc2tfZGF0YS5zY3JvbGxUb3AgPSB0aGlzLiRjb25maWcuc2Nyb2xsVG9wLCBuID0gITApLCAxICogdCA9PT0gdCAmJiAodGhpcy4kdGFzay5zY3JvbGxMZWZ0ID0gdCwgdGhpcy4kY29uZmlnLnNjcm9sbExlZnQgPSB0aGlzLiR0YXNrLnNjcm9sbExlZnQsIHRoaXMuX3JlZnJlc2hTY2FsZXMoKSwgbiA9ICEwKSwgbiAmJiB0aGlzLmNhbGxFdmVudChcIm9uU2Nyb2xsXCIsIFt0aGlzLiRjb25maWcuc2Nyb2xsTGVmdCwgdGhpcy4kY29uZmlnLnNjcm9sbFRvcF0pO1xuICB9XG59LCBfcmVmcmVzaFNjYWxlczogZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLmlzVmlzaWJsZSgpICYmIHRoaXMuJGdldENvbmZpZygpLnNtYXJ0X3NjYWxlcykge1xuICAgIHZhciB0ID0gdGhpcy5nZXRWaWV3UG9ydCgpLCBlID0gdGhpcy5fc2NhbGVzO1xuICAgIHRoaXMuJHRhc2tfc2NhbGUuaW5uZXJIVE1MID0gdGhpcy5fZ2V0U2NhbGVDaHVua0h0bWwoZSwgdC54LCB0LnhfZW5kKTtcbiAgfVxufSwgZ2V0Vmlld1BvcnQ6IGZ1bmN0aW9uKCkge1xuICB2YXIgdCA9IHRoaXMuJGNvbmZpZy5zY3JvbGxMZWZ0IHx8IDAsIGUgPSB0aGlzLiRjb25maWcuc2Nyb2xsVG9wIHx8IDAsIG4gPSB0aGlzLiRjb25maWcuaGVpZ2h0IHx8IDAsIGkgPSB0aGlzLiRjb25maWcud2lkdGggfHwgMDtcbiAgcmV0dXJuIHsgeTogZSwgeV9lbmQ6IGUgKyBuLCB4OiB0LCB4X2VuZDogdCArIGksIGhlaWdodDogbiwgd2lkdGg6IGkgfTtcbn0sIF9jcmVhdGVMYXllckNvbmZpZzogZnVuY3Rpb24oKSB7XG4gIHZhciB0ID0gdGhpcywgZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0LmlzVmlzaWJsZSgpO1xuICB9O1xuICB0aGlzLiRnYW50dDtcbiAgdmFyIG4gPSBbeyBleHBvc2U6ICEwLCByZW5kZXJlcjogdGhpcy4kZ2FudHQuJHVpLmxheWVycy50YXNrQmFyKCksIGNvbnRhaW5lcjogdGhpcy4kdGFza19iYXJzLCBmaWx0ZXI6IFtlLCBmdW5jdGlvbihpLCBhKSB7XG4gICAgcmV0dXJuICFhLmhpZGVfYmFyO1xuICB9XSB9XTtcbiAgcmV0dXJuIG4ucHVzaCh7IHJlbmRlcmVyOiB0aGlzLiRnYW50dC4kdWkubGF5ZXJzLnRhc2tCZygpLCBjb250YWluZXI6IHRoaXMuJHRhc2tfYmcsIGZpbHRlcjogW2VdIH0pLCB7IHRhc2tzOiBuLCBsaW5rczogW3sgZXhwb3NlOiAhMCwgcmVuZGVyZXI6IHRoaXMuJGdhbnR0LiR1aS5sYXllcnMubGluaygpLCBjb250YWluZXI6IHRoaXMuJHRhc2tfbGlua3MsIGZpbHRlcjogW2VdIH1dIH07XG59LCBfYXR0YWNoTGF5ZXJzOiBmdW5jdGlvbih0KSB7XG4gIHRoaXMuX3Rhc2tMYXllcnMgPSBbXSwgdGhpcy5fbGlua0xheWVycyA9IFtdO1xuICB2YXIgZSA9IHRoaXMsIG4gPSB0aGlzLiRnYW50dC4kc2VydmljZXMuZ2V0U2VydmljZShcImxheWVyc1wiKTtcbiAgaWYgKHRoaXMuJGNvbmZpZy5iaW5kKSB7XG4gICAgdGhpcy5fYmluZFN0b3JlKCk7XG4gICAgdmFyIGkgPSBuLmdldERhdGFSZW5kZXIodGhpcy4kY29uZmlnLmJpbmQpO1xuICAgIGkgfHwgKGkgPSBuLmNyZWF0ZURhdGFSZW5kZXIoeyBuYW1lOiB0aGlzLiRjb25maWcuYmluZCwgZGVmYXVsdENvbnRhaW5lcjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZS4kdGFza19kYXRhO1xuICAgIH0gfSkpLCBpLmNvbnRhaW5lciA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGUuJHRhc2tfZGF0YTtcbiAgICB9O1xuICAgIGZvciAodmFyIGEgPSB0aGlzLiRjb25maWcubGF5ZXJzLCByID0gMDsgYSAmJiByIDwgYS5sZW5ndGg7IHIrKykge1xuICAgICAgdHlwZW9mIChkID0gYVtyXSkgPT0gXCJzdHJpbmdcIiAmJiAoZCA9IHRoaXMuJGdhbnR0LiR1aS5sYXllcnNbZF0oKSksICh0eXBlb2YgZCA9PSBcImZ1bmN0aW9uXCIgfHwgZCAmJiBkLnJlbmRlciAmJiBkLnVwZGF0ZSkgJiYgKGQgPSB7IHJlbmRlcmVyOiBkIH0pLCBkLnZpZXcgPSB0aGlzO1xuICAgICAgdmFyIHMgPSBpLmFkZExheWVyKGQpO1xuICAgICAgdGhpcy5fdGFza0xheWVycy5wdXNoKHMpLCBkLmV4cG9zZSAmJiAodGhpcy5fdGFza1JlbmRlcmVyID0gaS5nZXRMYXllcihzKSk7XG4gICAgfVxuICAgIHRoaXMuX2luaXRTdGF0aWNCYWNrZ3JvdW5kUmVuZGVyKCk7XG4gIH1cbiAgaWYgKHRoaXMuJGNvbmZpZy5iaW5kTGlua3MpIHtcbiAgICBlLiRjb25maWcubGlua1N0b3JlID0gZS4kZ2FudHQuZ2V0RGF0YXN0b3JlKGUuJGNvbmZpZy5iaW5kTGlua3MpO1xuICAgIHZhciBvID0gbi5nZXREYXRhUmVuZGVyKHRoaXMuJGNvbmZpZy5iaW5kTGlua3MpO1xuICAgIG8gfHwgKG8gPSBuLmNyZWF0ZURhdGFSZW5kZXIoeyBuYW1lOiB0aGlzLiRjb25maWcuYmluZExpbmtzLCBkZWZhdWx0Q29udGFpbmVyOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBlLiR0YXNrX2RhdGE7XG4gICAgfSB9KSk7XG4gICAgdmFyIGwgPSB0aGlzLiRjb25maWcubGlua0xheWVycztcbiAgICBmb3IgKHIgPSAwOyBsICYmIHIgPCBsLmxlbmd0aDsgcisrKSB7XG4gICAgICB2YXIgZDtcbiAgICAgIHR5cGVvZiBkID09IFwic3RyaW5nXCIgJiYgKGQgPSB0aGlzLiRnYW50dC4kdWkubGF5ZXJzW2RdKCkpLCAoZCA9IGxbcl0pLnZpZXcgPSB0aGlzO1xuICAgICAgdmFyIGMgPSBvLmFkZExheWVyKGQpO1xuICAgICAgdGhpcy5fdGFza0xheWVycy5wdXNoKGMpLCBsW3JdLmV4cG9zZSAmJiAodGhpcy5fbGlua1JlbmRlcmVyID0gby5nZXRMYXllcihjKSk7XG4gICAgfVxuICB9XG59LCBfaW5pdFN0YXRpY0JhY2tncm91bmRSZW5kZXI6IGZ1bmN0aW9uKCkge1xuICB2YXIgdCA9IHRoaXMsIGUgPSBwYSgpLCBuID0gdC4kY29uZmlnLnJvd1N0b3JlO1xuICBuICYmICh0aGlzLl9zdGF0aWNCZ0hhbmRsZXIgPSBuLmF0dGFjaEV2ZW50KFwib25TdG9yZVVwZGF0ZWRcIiwgZnVuY3Rpb24oaSwgYSwgcikge1xuICAgIGlmIChpID09PSBudWxsICYmIHQuaXNWaXNpYmxlKCkpIHtcbiAgICAgIHZhciBzID0gdC4kZ2V0Q29uZmlnKCk7XG4gICAgICBpZiAocy5zdGF0aWNfYmFja2dyb3VuZCB8fCBzLnRpbWVsaW5lX3BsYWNlaG9sZGVyKSB7XG4gICAgICAgIHZhciBvID0gdC4kZ2FudHQuZ2V0RGF0YXN0b3JlKHQuJGNvbmZpZy5iaW5kKSwgbCA9IHQuJHRhc2tfYmdfc3RhdGljO1xuICAgICAgICBpZiAobCB8fCAoKGwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKS5jbGFzc05hbWUgPSBcImdhbnR0X3Rhc2tfYmdcIiwgdC4kdGFza19iZ19zdGF0aWMgPSBsLCB0LiR0YXNrX2JnLm5leHRTaWJsaW5nID8gdC4kdGFza19kYXRhLmluc2VydEJlZm9yZShsLCB0LiR0YXNrX2JnLm5leHRTaWJsaW5nKSA6IHQuJHRhc2tfZGF0YS5hcHBlbmRDaGlsZChsKSksIG8pIHtcbiAgICAgICAgICB2YXIgZCA9IHQuZ2V0VG90YWxIZWlnaHQoKTtcbiAgICAgICAgICBzLnRpbWVsaW5lX3BsYWNlaG9sZGVyICYmIChkID0gcy50aW1lbGluZV9wbGFjZWhvbGRlci5oZWlnaHQgfHwgdC4kdGFza19kYXRhLm9mZnNldEhlaWdodCB8fCA5OTk5OSksIGUucmVuZGVyKGwsIHMsIHQuZ2V0U2NhbGUoKSwgZCwgdC5nZXRJdGVtSGVpZ2h0KGEgPyBhLmlkIDogbnVsbCkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Ugcy5zdGF0aWNfYmFja2dyb3VuZCAmJiB0LiR0YXNrX2JnX3N0YXRpYyAmJiB0LiR0YXNrX2JnX3N0YXRpYy5wYXJlbnROb2RlICYmIHQuJHRhc2tfYmdfc3RhdGljLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodC4kdGFza19iZ19zdGF0aWMpO1xuICAgIH1cbiAgfSksIHRoaXMuYXR0YWNoRXZlbnQoXCJvbkRlc3Ryb3lcIiwgZnVuY3Rpb24oKSB7XG4gIH0pLCB0aGlzLl9pbml0U3RhdGljQmFja2dyb3VuZFJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICB9KTtcbn0sIF9jbGVhckxheWVyczogZnVuY3Rpb24odCkge1xuICB2YXIgZSA9IHRoaXMuJGdhbnR0LiRzZXJ2aWNlcy5nZXRTZXJ2aWNlKFwibGF5ZXJzXCIpLCBuID0gZS5nZXREYXRhUmVuZGVyKHRoaXMuJGNvbmZpZy5iaW5kKSwgaSA9IGUuZ2V0RGF0YVJlbmRlcih0aGlzLiRjb25maWcuYmluZExpbmtzKTtcbiAgaWYgKHRoaXMuX3Rhc2tMYXllcnMpIGZvciAodmFyIGEgPSAwOyBhIDwgdGhpcy5fdGFza0xheWVycy5sZW5ndGg7IGErKykgbi5yZW1vdmVMYXllcih0aGlzLl90YXNrTGF5ZXJzW2FdKTtcbiAgaWYgKHRoaXMuX2xpbmtMYXllcnMpIGZvciAoYSA9IDA7IGEgPCB0aGlzLl9saW5rTGF5ZXJzLmxlbmd0aDsgYSsrKSBpLnJlbW92ZUxheWVyKHRoaXMuX2xpbmtMYXllcnNbYV0pO1xuICB0aGlzLl9saW5rTGF5ZXJzID0gW10sIHRoaXMuX3Rhc2tMYXllcnMgPSBbXTtcbn0sIF9yZW5kZXJfdGFza3Nfc2NhbGVzOiBmdW5jdGlvbigpIHtcbiAgdmFyIHQgPSB0aGlzLiRnZXRDb25maWcoKSwgZSA9IFwiXCIsIG4gPSAwLCBpID0gMCwgYSA9IHRoaXMuJGdhbnR0LmdldFN0YXRlKCk7XG4gIGlmICh0aGlzLmlzVmlzaWJsZSgpKSB7XG4gICAgdmFyIHIgPSB0aGlzLiRzY2FsZUhlbHBlciwgcyA9IHRoaXMuX2dldFNjYWxlcygpO1xuICAgIGkgPSB0LnNjYWxlX2hlaWdodDtcbiAgICB2YXIgbyA9IHRoaXMuJGNvbmZpZy53aWR0aDtcbiAgICB0LmF1dG9zaXplICE9IFwieFwiICYmIHQuYXV0b3NpemUgIT0gXCJ4eVwiIHx8IChvID0gTWF0aC5tYXgodC5hdXRvc2l6ZV9taW5fd2lkdGgsIDApKTtcbiAgICB2YXIgbCA9IHIucHJlcGFyZUNvbmZpZ3MocywgdC5taW5fY29sdW1uX3dpZHRoLCBvLCBpIC0gMSwgYS5taW5fZGF0ZSwgYS5tYXhfZGF0ZSwgdC5ydGwpLCBkID0gdGhpcy5fdGFza3MgPSBsW2wubGVuZ3RoIC0gMV07XG4gICAgdGhpcy5fc2NhbGVzID0gbCwgdGhpcy5fcG9zRnJvbURhdGVDYWNoZSA9IHt9LCBlID0gdGhpcy5fZ2V0U2NhbGVDaHVua0h0bWwobCwgMCwgdGhpcy4kY29uZmlnLndpZHRoKSwgbiA9IGQuZnVsbF93aWR0aCArIFwicHhcIiwgaSArPSBcInB4XCI7XG4gIH1cbiAgdGhpcy4kdGFza19zY2FsZS5zdHlsZS5oZWlnaHQgPSBpLCB0aGlzLiR0YXNrX2RhdGEuc3R5bGUud2lkdGggPSB0aGlzLiR0YXNrX3NjYWxlLnN0eWxlLndpZHRoID0gbiwgdGhpcy4kdGFza19zY2FsZS5pbm5lckhUTUwgPSBlO1xufSwgX2dldFNjYWxlQ2h1bmtIdG1sOiBmdW5jdGlvbih0LCBlLCBuKSB7XG4gIGZvciAodmFyIGkgPSBbXSwgYSA9IHRoaXMuJGdhbnR0LnRlbXBsYXRlcy5zY2FsZV9yb3dfY2xhc3MsIHIgPSAwOyByIDwgdC5sZW5ndGg7IHIrKykge1xuICAgIHZhciBzID0gXCJnYW50dF9zY2FsZV9saW5lXCIsIG8gPSBhKHRbcl0pO1xuICAgIG8gJiYgKHMgKz0gXCIgXCIgKyBvKSwgaS5wdXNoKCc8ZGl2IGNsYXNzPVwiJyArIHMgKyAnXCIgc3R5bGU9XCJoZWlnaHQ6JyArIHRbcl0uaGVpZ2h0ICsgXCJweDtwb3NpdGlvbjpyZWxhdGl2ZTtsaW5lLWhlaWdodDpcIiArIHRbcl0uaGVpZ2h0ICsgJ3B4XCI+JyArIHRoaXMuX3ByZXBhcmVTY2FsZUh0bWwodFtyXSwgZSwgbiwgcikgKyBcIjwvZGl2PlwiKTtcbiAgfVxuICByZXR1cm4gaS5qb2luKFwiXCIpO1xufSwgX3ByZXBhcmVTY2FsZUh0bWw6IGZ1bmN0aW9uKHQsIGUsIG4sIGkpIHtcbiAgdmFyIGEgPSB0aGlzLiRnZXRDb25maWcoKSwgciA9IHRoaXMuJGdhbnR0LnRlbXBsYXRlcywgcyA9IFtdLCBvID0gbnVsbCwgbCA9IG51bGwsIGQgPSB0LmZvcm1hdCB8fCB0LnRlbXBsYXRlIHx8IHQuZGF0ZTtcbiAgdHlwZW9mIGQgPT0gXCJzdHJpbmdcIiAmJiAoZCA9IHRoaXMuJGdhbnR0LmRhdGUuZGF0ZV90b19zdHIoZCkpO1xuICB2YXIgYyA9IDAsIHUgPSB0LmNvdW50O1xuICAhYS5zbWFydF9zY2FsZXMgfHwgaXNOYU4oZSkgfHwgaXNOYU4obikgfHwgKGMgPSBBdCh0LmxlZnQsIGUpLCB1ID0gQXQodC5sZWZ0LCBuKSArIDEpLCBsID0gdC5jc3MgfHwgZnVuY3Rpb24oKSB7XG4gIH0sICF0LmNzcyAmJiBhLmluaGVyaXRfc2NhbGVfY2xhc3MgJiYgKGwgPSByLnNjYWxlX2NlbGxfY2xhc3MpO1xuICBmb3IgKHZhciBoID0gYzsgaCA8IHUgJiYgdC50cmFjZV94W2hdOyBoKyspIHtcbiAgICBvID0gbmV3IERhdGUodC50cmFjZV94W2hdKTtcbiAgICB2YXIgZyA9IGQuY2FsbCh0aGlzLCBvKSwgcCA9IHQud2lkdGhbaF07XG4gICAgdC5oZWlnaHQ7XG4gICAgdmFyIHkgPSB0LmxlZnRbaF0sIHYgPSBcIlwiLCBiID0gXCJcIiwgXyA9IFwiXCI7XG4gICAgaWYgKHApIHtcbiAgICAgIHYgPSBcIndpZHRoOlwiICsgcCArIFwicHg7XCIgKyAoYS5zbWFydF9zY2FsZXMgPyBcInBvc2l0aW9uOmFic29sdXRlO2xlZnQ6XCIgKyB5ICsgXCJweFwiIDogXCJcIik7XG4gICAgICBjb25zdCBmID0gdGhpcy5nZXRWaWV3UG9ydCgpLCBrID0gKGEuc2NhbGVzW2ldIHx8IHt9KS5zdGlja3k7XG4gICAgICBsZXQgeCA9IFwiXCI7XG4gICAgICBjb25zdCAkID0gNzA7XG4gICAgICBpZiAoayAhPT0gITEgJiYgcCA+ICQgfHwgayA9PT0gITApIHtcbiAgICAgICAgaWYgKHkgPCBmLnggJiYgeSArIHAgLyAyIC0gJCAvIDIgPCBmLngpIHggPSBgIHN0eWxlPSdwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0OiAke2YueCAtIHkgKyAxMH1weDsnIGA7XG4gICAgICAgIGVsc2UgaWYgKHkgKyBwIC8gMiArICQgLyAyID4gZi54X2VuZCAmJiBwID4gJCkge1xuICAgICAgICAgIGxldCB3ID0gZi54X2VuZCAtIHkgLSAxMCwgUyA9IFwiLTEwMCVcIjtcbiAgICAgICAgICB3IDwgJCAmJiAodyA9ICQsIFMgPSBgLSR7d31weGApLCB4ID0gYCBzdHlsZT0ncG9zaXRpb246YWJzb2x1dGU7bGVmdDogJHt3fXB4O3RyYW5zZm9ybTogdHJhbnNsYXRlKCR7U30sMCk7JyBgO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBfID0gXCJnYW50dF9zY2FsZV9jZWxsXCIgKyAoaCA9PSB0LmNvdW50IC0gMSA/IFwiIGdhbnR0X2xhc3RfY2VsbFwiIDogXCJcIiksIChiID0gbC5jYWxsKHRoaXMsIG8pKSAmJiAoXyArPSBcIiBcIiArIGIpO1xuICAgICAgdmFyIG0gPSBgPGRpdiBjbGFzcz0nJHtffScgJHt0aGlzLiRnYW50dC5fd2FpQXJpYS5nZXRUaW1lbGluZUNlbGxBdHRyKGcpfSBzdHlsZT0nJHt2fSc+PHNwYW4gJHt4fT4ke2d9PC9zcGFuPjwvZGl2PmA7XG4gICAgICBzLnB1c2gobSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzLmpvaW4oXCJcIik7XG59LCBkYXRlRnJvbVBvczogZnVuY3Rpb24odCkge1xuICB2YXIgZSA9IHRoaXMuX3Rhc2tzO1xuICBpZiAodCA8IDAgfHwgdCA+IGUuZnVsbF93aWR0aCB8fCAhZS5mdWxsX3dpZHRoKSByZXR1cm4gbnVsbDtcbiAgdmFyIG4gPSBBdCh0aGlzLl90YXNrcy5sZWZ0LCB0KSwgaSA9IHRoaXMuX3Rhc2tzLmxlZnRbbl0sIGEgPSBlLndpZHRoW25dIHx8IGUuY29sX3dpZHRoLCByID0gMDtcbiAgYSAmJiAociA9ICh0IC0gaSkgLyBhLCBlLnJ0bCAmJiAociA9IDEgLSByKSk7XG4gIHZhciBzID0gMDtcbiAgcmV0dXJuIHIgJiYgKHMgPSB0aGlzLl9nZXRDb2x1bW5EdXJhdGlvbihlLCBlLnRyYWNlX3hbbl0pKSwgbmV3IERhdGUoZS50cmFjZV94W25dLnZhbHVlT2YoKSArIE1hdGgucm91bmQociAqIHMpKTtcbn0sIHBvc0Zyb21EYXRlOiBmdW5jdGlvbih0KSB7XG4gIGlmICghdGhpcy5pc1Zpc2libGUoKSB8fCAhdCkgcmV0dXJuIDA7XG4gIHZhciBlID0gU3RyaW5nKHQudmFsdWVPZigpKTtcbiAgaWYgKHRoaXMuX3Bvc0Zyb21EYXRlQ2FjaGVbZV0gIT09IHZvaWQgMCkgcmV0dXJuIHRoaXMuX3Bvc0Zyb21EYXRlQ2FjaGVbZV07XG4gIHZhciBuID0gdGhpcy5jb2x1bW5JbmRleEJ5RGF0ZSh0KTtcbiAgdGhpcy4kZ2FudHQuYXNzZXJ0KG4gPj0gMCwgXCJJbnZhbGlkIGRheSBpbmRleFwiKTtcbiAgdmFyIGkgPSBNYXRoLmZsb29yKG4pLCBhID0gbiAlIDEsIHIgPSB0aGlzLl90YXNrcy5sZWZ0W01hdGgubWluKGksIHRoaXMuX3Rhc2tzLndpZHRoLmxlbmd0aCAtIDEpXTtcbiAgaSA9PSB0aGlzLl90YXNrcy53aWR0aC5sZW5ndGggJiYgKHIgKz0gdGhpcy5fdGFza3Mud2lkdGhbdGhpcy5fdGFza3Mud2lkdGgubGVuZ3RoIC0gMV0pLCBhICYmIChpIDwgdGhpcy5fdGFza3Mud2lkdGgubGVuZ3RoID8gciArPSB0aGlzLl90YXNrcy53aWR0aFtpXSAqIChhICUgMSkgOiByICs9IDEpO1xuICB2YXIgcyA9IE1hdGgucm91bmQocik7XG4gIHJldHVybiB0aGlzLl9wb3NGcm9tRGF0ZUNhY2hlW2VdID0gcywgTWF0aC5yb3VuZChzKTtcbn0sIF9nZXROZXh0VmlzaWJsZUNvbHVtbjogZnVuY3Rpb24odCwgZSwgbikge1xuICBmb3IgKHZhciBpID0gK2VbdF0sIGEgPSB0OyBuW2ldOyApIGkgPSArZVsrK2FdO1xuICByZXR1cm4gYTtcbn0sIF9nZXRQcmV2VmlzaWJsZUNvbHVtbjogZnVuY3Rpb24odCwgZSwgbikge1xuICBmb3IgKHZhciBpID0gK2VbdF0sIGEgPSB0OyBuW2ldOyApIGkgPSArZVstLWFdO1xuICByZXR1cm4gYTtcbn0sIF9nZXRDbG9zZXN0VmlzaWJsZUNvbHVtbjogZnVuY3Rpb24odCwgZSwgbikge1xuICB2YXIgaSA9IHRoaXMuX2dldE5leHRWaXNpYmxlQ29sdW1uKHQsIGUsIG4pO1xuICByZXR1cm4gZVtpXSB8fCAoaSA9IHRoaXMuX2dldFByZXZWaXNpYmxlQ29sdW1uKHQsIGUsIG4pKSwgaTtcbn0sIGNvbHVtbkluZGV4QnlEYXRlOiBmdW5jdGlvbih0KSB7XG4gIHZhciBlID0gbmV3IERhdGUodCkudmFsdWVPZigpLCBuID0gdGhpcy5fdGFza3MudHJhY2VfeF9hc2NlbmRpbmcsIGkgPSB0aGlzLl90YXNrcy5pZ25vcmVfeCwgYSA9IHRoaXMuJGdhbnR0LmdldFN0YXRlKCk7XG4gIGlmIChlIDw9IGEubWluX2RhdGUpIHJldHVybiB0aGlzLl90YXNrcy5ydGwgPyBuLmxlbmd0aCA6IDA7XG4gIGlmIChlID49IGEubWF4X2RhdGUpIHJldHVybiB0aGlzLl90YXNrcy5ydGwgPyAwIDogbi5sZW5ndGg7XG4gIHZhciByID0gQXQobiwgZSksIHMgPSB0aGlzLl9nZXRDbG9zZXN0VmlzaWJsZUNvbHVtbihyLCBuLCBpKSwgbyA9IG5bc10sIGwgPSB0aGlzLl90YXNrcy50cmFjZV9pbmRleF90cmFuc2l0aW9uO1xuICBpZiAoIW8pIHJldHVybiBsID8gbFswXSA6IDA7XG4gIHZhciBkID0gKHQgLSBuW3NdKSAvIHRoaXMuX2dldENvbHVtbkR1cmF0aW9uKHRoaXMuX3Rhc2tzLCBuW3NdKTtcbiAgcmV0dXJuIGwgPyBsW3NdICsgKDEgLSBkKSA6IHMgKyBkO1xufSwgZ2V0SXRlbVBvc2l0aW9uOiBmdW5jdGlvbih0LCBlLCBuKSB7XG4gIHZhciBpLCBhLCByO1xuICBsZXQgcyA9IGUgfHwgdC5zdGFydF9kYXRlIHx8IHQuJGF1dG9fc3RhcnRfZGF0ZSwgbyA9IG4gfHwgdC5lbmRfZGF0ZSB8fCB0LiRhdXRvX2VuZF9kYXRlO1xuICByZXR1cm4gdGhpcy5fdGFza3MucnRsID8gKGEgPSB0aGlzLnBvc0Zyb21EYXRlKHMpLCBpID0gdGhpcy5wb3NGcm9tRGF0ZShvKSkgOiAoaSA9IHRoaXMucG9zRnJvbURhdGUocyksIGEgPSB0aGlzLnBvc0Zyb21EYXRlKG8pKSwgciA9IE1hdGgubWF4KGEgLSBpLCAwKSwgeyBsZWZ0OiBpLCB0b3A6IHRoaXMuZ2V0SXRlbVRvcCh0LmlkKSwgaGVpZ2h0OiB0aGlzLmdldEJhckhlaWdodCh0LmlkKSwgd2lkdGg6IHIsIHJvd0hlaWdodDogdGhpcy5nZXRJdGVtSGVpZ2h0KHQuaWQpIH07XG59LCBnZXRCYXJIZWlnaHQ6IGZ1bmN0aW9uKHQsIGUpIHtcbiAgdmFyIG4gPSB0aGlzLiRnZXRDb25maWcoKSwgaSA9IHRoaXMuJGNvbmZpZy5yb3dTdG9yZS5nZXRJdGVtKHQpLCBhID0gaS50YXNrX2hlaWdodCB8fCBpLmJhcl9oZWlnaHQgfHwgbi5iYXJfaGVpZ2h0IHx8IG4udGFza19oZWlnaHQsIHIgPSB0aGlzLmdldEl0ZW1IZWlnaHQodCk7XG4gIHJldHVybiBhID09IFwiZnVsbFwiICYmIChhID0gciAtIChuLmJhcl9oZWlnaHRfcGFkZGluZyB8fCAzKSksIGEgPSBNYXRoLm1pbihhLCByKSwgZSAmJiAoYSA9IE1hdGgucm91bmQoYSAvIE1hdGguc3FydCgyKSkpLCBNYXRoLm1heChhLCAwKTtcbn0sIGdldFNjYWxlOiBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3Rhc2tzO1xufSwgX2dldFNjYWxlczogZnVuY3Rpb24oKSB7XG4gIHZhciB0ID0gdGhpcy4kZ2V0Q29uZmlnKCksIGUgPSB0aGlzLiRzY2FsZUhlbHBlciwgbiA9IFtlLnByaW1hcnlTY2FsZSh0KV0uY29uY2F0KGUuZ2V0U3ViU2NhbGVzKHQpKTtcbiAgcmV0dXJuIGUuc29ydFNjYWxlcyhuKSwgbjtcbn0sIF9nZXRDb2x1bW5EdXJhdGlvbjogZnVuY3Rpb24odCwgZSkge1xuICByZXR1cm4gdGhpcy4kZ2FudHQuZGF0ZS5hZGQoZSwgdC5zdGVwLCB0LnVuaXQpIC0gZTtcbn0sIF9iaW5kU3RvcmU6IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy4kY29uZmlnLmJpbmQpIHtcbiAgICB2YXIgdCA9IHRoaXMuJGdhbnR0LmdldERhdGFzdG9yZSh0aGlzLiRjb25maWcuYmluZCk7XG4gICAgaWYgKHRoaXMuJGNvbmZpZy5yb3dTdG9yZSA9IHQsIHQgJiYgIXQuX3RpbWVsaW5lQ2FjaGVBdHRhY2hlZCkge1xuICAgICAgdmFyIGUgPSB0aGlzO1xuICAgICAgdC5fdGltZWxpbmVDYWNoZUF0dGFjaGVkID0gdC5hdHRhY2hFdmVudChcIm9uQmVmb3JlRmlsdGVyXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICBlLl9yZXNldFRvcFBvc2l0aW9uSGVpZ2h0KCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn0sIF91bmJpbmRTdG9yZTogZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLiRjb25maWcuYmluZCkge1xuICAgIHZhciB0ID0gdGhpcy4kZ2FudHQuZ2V0RGF0YXN0b3JlKHRoaXMuJGNvbmZpZy5iaW5kKTtcbiAgICB0ICYmIHQuX3RpbWVsaW5lQ2FjaGVBdHRhY2hlZCAmJiAodC5kZXRhY2hFdmVudCh0Ll90aW1lbGluZUNhY2hlQXR0YWNoZWQpLCB0Ll90aW1lbGluZUNhY2hlQXR0YWNoZWQgPSAhMSk7XG4gIH1cbn0sIHJlZnJlc2g6IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9iaW5kU3RvcmUoKSwgdGhpcy4kY29uZmlnLmJpbmRMaW5rcyAmJiAodGhpcy4kY29uZmlnLmxpbmtTdG9yZSA9IHRoaXMuJGdhbnR0LmdldERhdGFzdG9yZSh0aGlzLiRjb25maWcuYmluZExpbmtzKSksIHRoaXMuX3Jlc2V0VG9wUG9zaXRpb25IZWlnaHQoKSwgdGhpcy5fcmVzZXRIZWlnaHQoKSwgdGhpcy5faW5pdFN0YXRpY0JhY2tncm91bmRSZW5kZXIoKSwgdGhpcy5fcmVuZGVyX3Rhc2tzX3NjYWxlcygpO1xufSwgZGVzdHJ1Y3RvcjogZnVuY3Rpb24oKSB7XG4gIHZhciB0ID0gdGhpcy4kZ2FudHQ7XG4gIHRoaXMuX2NsZWFyTGF5ZXJzKHQpLCB0aGlzLl91bmJpbmRTdG9yZSgpLCB0aGlzLiR0YXNrID0gbnVsbCwgdGhpcy4kdGFza19zY2FsZSA9IG51bGwsIHRoaXMuJHRhc2tfZGF0YSA9IG51bGwsIHRoaXMuJHRhc2tfYmcgPSBudWxsLCB0aGlzLiR0YXNrX2xpbmtzID0gbnVsbCwgdGhpcy4kdGFza19iYXJzID0gbnVsbCwgdGhpcy4kZ2FudHQgPSBudWxsLCB0aGlzLiRjb25maWcucm93U3RvcmUgJiYgKHRoaXMuJGNvbmZpZy5yb3dTdG9yZS5kZXRhY2hFdmVudCh0aGlzLl9zdGF0aWNCZ0hhbmRsZXIpLCB0aGlzLiRjb25maWcucm93U3RvcmUgPSBudWxsKSwgdGhpcy4kY29uZmlnLmxpbmtTdG9yZSAmJiAodGhpcy4kY29uZmlnLmxpbmtTdG9yZSA9IG51bGwpLCB0aGlzLl90aW1lbGluZURyYWdTY3JvbGwgJiYgKHRoaXMuX3RpbWVsaW5lRHJhZ1Njcm9sbC5kZXN0cnVjdG9yKCksIHRoaXMuX3RpbWVsaW5lRHJhZ1Njcm9sbCA9IG51bGwpLCB0aGlzLmNhbGxFdmVudChcIm9uRGVzdHJveVwiLCBbXSksIHRoaXMuZGV0YWNoQWxsRXZlbnRzKCk7XG59IH07XG5jbGFzcyBtYSB7XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICB0aGlzLl9zY3JvbGxPcmRlciA9IDA7XG4gICAgY29uc3QgeyBnYW50dDogbiwgZ3JpZDogaSwgZG5kOiBhLCBnZXRDdXJyZW50WDogciB9ID0gZTtcbiAgICB0aGlzLiRnYW50dCA9IG4sIHRoaXMuJGdyaWQgPSBpLCB0aGlzLl9kbmQgPSBhLCB0aGlzLmdldEN1cnJlbnRYID0gciwgdGhpcy5fc2Nyb2xsVmlldyA9IHRoaXMuJGdhbnR0LiR1aS5nZXRWaWV3KHRoaXMuJGdyaWQuJGNvbmZpZy5zY3JvbGxYKSwgdGhpcy5hdHRhY2hFdmVudHMoKTtcbiAgfVxuICBhdHRhY2hFdmVudHMoKSB7XG4gICAgdGhpcy5pc1Njcm9sbGFibGUoKSAmJiAodGhpcy5fZG5kLmF0dGFjaEV2ZW50KFwib25EcmFnTW92ZVwiLCAoZSwgbikgPT4ge1xuICAgICAgY29uc3QgaSA9IHRoaXMuJGdyaWQuJGdyaWQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGEgPSBpLnJpZ2h0LCByID0gaS5sZWZ0LCBzID0gdGhpcy5nZXRDdXJyZW50WChuLmNsaWVudFgpO1xuICAgICAgcmV0dXJuIHMgPj0gYSAtIDIwICYmICh0aGlzLmF1dG9zY3JvbGxSaWdodCgpLCB0aGlzLmF1dG9zY3JvbGxTdGFydCgpKSwgcyA8PSByICsgMjAgJiYgKHRoaXMuYXV0b3Njcm9sbExlZnQoKSwgdGhpcy5hdXRvc2Nyb2xsU3RhcnQoKSksIHMgPCBhIC0gMjAgJiYgcyA+IHIgKyAyMCAmJiB0aGlzLmF1dG9zY3JvbGxTdG9wKCksICEwO1xuICAgIH0pLCB0aGlzLl9kbmQuYXR0YWNoRXZlbnQoXCJvbkRyYWdFbmRcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5hdXRvc2Nyb2xsU3RvcCgpO1xuICAgIH0pKTtcbiAgfVxuICBhdXRvc2Nyb2xsU3RhcnQoKSB7XG4gICAgaWYgKHRoaXMuX3Njcm9sbE9yZGVyID09PSAwKSByZXR1cm47XG4gICAgY29uc3QgZSA9IDEwICogdGhpcy5fc2Nyb2xsT3JkZXIsIG4gPSB0aGlzLl9zY3JvbGxWaWV3LmdldFNjcm9sbFN0YXRlKCk7XG4gICAgdGhpcy5fc2Nyb2xsVmlldy5zY3JvbGxUbyhuLnBvc2l0aW9uICsgZSksIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5hdXRvc2Nyb2xsU3RhcnQoKTtcbiAgICB9LCA1MCk7XG4gIH1cbiAgYXV0b3Njcm9sbFJpZ2h0KCkge1xuICAgIHRoaXMuX3Njcm9sbE9yZGVyID0gMTtcbiAgfVxuICBhdXRvc2Nyb2xsTGVmdCgpIHtcbiAgICB0aGlzLl9zY3JvbGxPcmRlciA9IC0xO1xuICB9XG4gIGF1dG9zY3JvbGxTdG9wKCkge1xuICAgIHRoaXMuX3Njcm9sbE9yZGVyID0gMDtcbiAgfVxuICBnZXRDb3JyZWN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmlzU2Nyb2xsYWJsZSgpID8gdGhpcy5fc2Nyb2xsVmlldy5nZXRTY3JvbGxTdGF0ZSgpLnBvc2l0aW9uIDogMDtcbiAgfVxuICBpc1Njcm9sbGFibGUoKSB7XG4gICAgcmV0dXJuICEhdGhpcy4kZ3JpZC4kY29uZmlnLnNjcm9sbGFibGU7XG4gIH1cbn1cbmNvbnN0IFZlID0gXCJkYXRhLWNvbHVtbi1pZFwiO1xuY2xhc3MgdmEge1xuICBjb25zdHJ1Y3RvcihlLCBuKSB7XG4gICAgdGhpcy5fdGFyZ2V0TWFya2VyID0gbnVsbCwgdGhpcy5jYWxjdWxhdGVDdXJyZW50UG9zaXRpb24gPSAoaSkgPT4ge1xuICAgICAgY29uc3QgYSA9IHRoaXMuJGdyaWQuJGdyaWQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHIgPSBhLnJpZ2h0LCBzID0gYS5sZWZ0O1xuICAgICAgbGV0IG8gPSBpO1xuICAgICAgcmV0dXJuIG8gPiByICYmIChvID0gciksIG8gPCBzICYmIChvID0gcyksIG87XG4gICAgfSwgdGhpcy4kZ2FudHQgPSBlLCB0aGlzLiRncmlkID0gbjtcbiAgfVxuICBpbml0KCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLiRnYW50dC4kc2VydmljZXMuZ2V0U2VydmljZShcImRuZFwiKTtcbiAgICB0aGlzLl9kbmQgPSBuZXcgZSh0aGlzLiRncmlkLiRncmlkX3NjYWxlLCB7IHVwZGF0ZXNfcGVyX3NlY29uZDogNjAgfSksIHRoaXMuX3Njcm9sbGFibGVHcmlkID0gbmV3IG1hKHsgZ2FudHQ6IHRoaXMuJGdhbnR0LCBncmlkOiB0aGlzLiRncmlkLCBkbmQ6IHRoaXMuX2RuZCwgZ2V0Q3VycmVudFg6IHRoaXMuY2FsY3VsYXRlQ3VycmVudFBvc2l0aW9uIH0pLCB0aGlzLmF0dGFjaEV2ZW50cygpO1xuICB9XG4gIGF0dGFjaEV2ZW50cygpIHtcbiAgICB0aGlzLl9kbmQuYXR0YWNoRXZlbnQoXCJvbkJlZm9yZURyYWdTdGFydFwiLCAoZSwgbikgPT4ge1xuICAgICAgaWYgKHRoaXMuX2RyYWdnZWRDZWxsID0gdGhpcy4kZ2FudHQudXRpbHMuZG9tLmNsb3Nlc3Qobi50YXJnZXQsIFwiLmdhbnR0X2dyaWRfaGVhZF9jZWxsXCIpLCAhdGhpcy5fZHJhZ2dlZENlbGwpIHJldHVybjtcbiAgICAgIGNvbnN0IGkgPSB0aGlzLiRncmlkLiRnZXRDb25maWcoKS5jb2x1bW5zLCBhID0gdGhpcy5fZHJhZ2dlZENlbGwuZ2V0QXR0cmlidXRlKFZlKTtcbiAgICAgIGxldCByLCBzO1xuICAgICAgcmV0dXJuIGkubWFwKGZ1bmN0aW9uKG8sIGwpIHtcbiAgICAgICAgby5uYW1lID09PSBhICYmIChyID0gbywgcyA9IGwpO1xuICAgICAgfSksIHRoaXMuJGdyaWQuY2FsbEV2ZW50KFwib25CZWZvcmVDb2x1bW5EcmFnU3RhcnRcIiwgW3sgZHJhZ2dlZENvbHVtbjogciwgZHJhZ2dlZEluZGV4OiBzIH1dKSAhPT0gITEgJiYgISghdGhpcy5fZHJhZ2dlZENlbGwgfHwgIXIpICYmICh0aGlzLl9ncmlkQ29uZmlnID0gdGhpcy4kZ3JpZC4kZ2V0Q29uZmlnKCksIHRoaXMuX29yaWdpbkF1dG9zY3JvbGwgPSB0aGlzLiRnYW50dC5jb25maWcuYXV0b3Njcm9sbCwgdGhpcy4kZ2FudHQuY29uZmlnLmF1dG9zY3JvbGwgPSAhMSwgITApO1xuICAgIH0pLCB0aGlzLl9kbmQuYXR0YWNoRXZlbnQoXCJvbkFmdGVyRHJhZ1N0YXJ0XCIsIChlLCBuKSA9PiB7XG4gICAgICB0aGlzLl9kcmFnZ2VkQ2VsbCAmJiAodGhpcy5fZG5kLmNvbmZpZy5jb2x1bW4gPSB0aGlzLl9kcmFnZ2VkQ2VsbC5nZXRBdHRyaWJ1dGUoVmUpLCB0aGlzLl9kbmQuY29uZmlnLm1hcmtlci5pbm5lckhUTUwgPSB0aGlzLl9kcmFnZ2VkQ2VsbC5vdXRlckhUTUwsIHRoaXMuX2RuZC5jb25maWcubWFya2VyLmNsYXNzTGlzdC5hZGQoXCJnYW50dF9jb2x1bW5fZHJhZ19tYXJrZXJcIiksIHRoaXMuX2RuZC5jb25maWcubWFya2VyLnN0eWxlLmhlaWdodCA9IHRoaXMuX2dyaWRDb25maWcuc2NhbGVfaGVpZ2h0ICsgXCJweFwiLCB0aGlzLl9kbmQuY29uZmlnLm1hcmtlci5zdHlsZS5saW5lSGVpZ2h0ID0gdGhpcy5fZ3JpZENvbmZpZy5zY2FsZV9oZWlnaHQgKyBcInB4XCIsIHRoaXMuX2RyYWdnZWRDZWxsLmNsYXNzTGlzdC5hZGQoXCJnYW50dF9ncmlkX2hlYWRfY2VsbF9kcmFnZ2VkXCIpKTtcbiAgICB9KSwgdGhpcy5fZG5kLmF0dGFjaEV2ZW50KFwib25EcmFnTW92ZVwiLCAoZSwgbikgPT4ge1xuICAgICAgaWYgKCF0aGlzLl9kcmFnZ2VkQ2VsbCkgcmV0dXJuO1xuICAgICAgdGhpcy5fZHJhZ1ggPSBuLmNsaWVudFg7XG4gICAgICBjb25zdCBpID0gdGhpcy5jYWxjdWxhdGVDdXJyZW50UG9zaXRpb24obi5jbGllbnRYKSwgYSA9IHRoaXMuZmluZENvbHVtbnNJbmRleGVzKCk7XG4gICAgICByZXR1cm4gdGhpcy5zZXRNYXJrZXJQb3NpdGlvbihpKSwgdGhpcy5kcmF3VGFyZ2V0TWFya2VyKGEpLCAhMDtcbiAgICB9KSwgdGhpcy5fZG5kLmF0dGFjaEV2ZW50KFwib25EcmFnRW5kXCIsICgpID0+IHtcbiAgICAgIGlmICghdGhpcy5fZHJhZ2dlZENlbGwpIHJldHVybjtcbiAgICAgIGNvbnN0IGUgPSB0aGlzLmZpbmRDb2x1bW5zSW5kZXhlcygpLCBuID0gZS50YXJnZXRJbmRleCwgaSA9IGUuZHJhZ2dlZEluZGV4LCBhID0gdGhpcy4kZ3JpZC4kZ2V0Q29uZmlnKCkuY29sdW1ucywgciA9IGFbaV0sIHMgPSBhW25dO1xuICAgICAgaWYgKHRoaXMuJGdyaWQuY2FsbEV2ZW50KFwib25Db2x1bW5EcmFnTW92ZVwiLCBbeyBkcmFnZ2VkQ29sdW1uOiByLCB0YXJnZXRDb2x1bW46IHMsIGRyYWdnZWRJbmRleDogaSwgdGFyZ2V0SW5kZXg6IG4gfV0pID09PSAhMSkgcmV0dXJuIHRoaXMuY2xlYW5UYXJnZXRNYXJrZXIoKSwgdm9pZCB0aGlzLiRnYW50dC5yZW5kZXIoKTtcbiAgICAgIHRoaXMuJGdhbnR0LmNvbmZpZy5hdXRvc2Nyb2xsID0gdGhpcy5fb3JpZ2luQXV0b3Njcm9sbCwgdGhpcy5fZHJhZ2dlZENlbGwuY2xhc3NMaXN0LnJlbW92ZShcImdhbnR0X2dyaWRfaGVhZF9jZWxsX2RyYWdnZWRcIiksIHRoaXMuY2xlYW5UYXJnZXRNYXJrZXIoKSwgdGhpcy5yZW9yZGVyQ29sdW1ucygpO1xuICAgIH0pO1xuICB9XG4gIHJlb3JkZXJDb2x1bW5zKCkge1xuICAgIGNvbnN0IHsgdGFyZ2V0SW5kZXg6IGUsIGRyYWdnZWRJbmRleDogbiB9ID0gdGhpcy5maW5kQ29sdW1uc0luZGV4ZXMoKSwgaSA9IHRoaXMuJGdyaWQuJGdldENvbmZpZygpLmNvbHVtbnMsIGEgPSBpW25dLCByID0gaVtlXTtcbiAgICB0aGlzLiRncmlkLmNhbGxFdmVudChcIm9uQmVmb3JlQ29sdW1uUmVvcmRlclwiLCBbeyBkcmFnZ2VkQ29sdW1uOiBhLCB0YXJnZXRDb2x1bW46IHIsIGRyYWdnZWRJbmRleDogbiwgdGFyZ2V0SW5kZXg6IGUgfV0pICE9PSAhMSAmJiBlICE9PSBuICYmIChpLnNwbGljZShuLCAxKSwgaS5zcGxpY2UoZSwgMCwgYSksIHRoaXMuJGdhbnR0LnJlbmRlcigpLCB0aGlzLiRncmlkLmNhbGxFdmVudChcIm9uQWZ0ZXJDb2x1bW5SZW9yZGVyXCIsIFt7IGRyYWdnZWRDb2x1bW46IGEsIHRhcmdldENvbHVtbjogciwgZHJhZ2dlZEluZGV4OiBuLCB0YXJnZXRJbmRleDogZSB9XSkpO1xuICB9XG4gIGZpbmRDb2x1bW5zSW5kZXhlcygpIHtcbiAgICBjb25zdCBlID0gdGhpcy5fZG5kLmNvbmZpZy5jb2x1bW4sIG4gPSB0aGlzLiRncmlkLiRnZXRDb25maWcoKS5jb2x1bW5zO1xuICAgIGxldCBpLCBhLCByLCBzO1xuICAgIGNvbnN0IG8gPSB7IHN0YXJ0WDogMCwgZW5kWDogMCB9O1xuICAgIGxldCBsLCBkID0gMCwgYyA9IG4ubGVuZ3RoIC0gMSwgdSA9IChwLCB5KSA9PiBwIDw9IHksIGggPSAocCkgPT4gKytwO1xuICAgIHRoaXMuJGdhbnR0LmNvbmZpZy5ydGwgJiYgKGQgPSBuLmxlbmd0aCAtIDEsIGMgPSAwLCB1ID0gKHAsIHkpID0+IHAgPj0geSwgaCA9IChwKSA9PiAtLXApO1xuICAgIGNvbnN0IGcgPSB0aGlzLl9kcmFnWCAtIHRoaXMuJGdyaWQuJGdyaWQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCArIHRoaXMuX3Njcm9sbGFibGVHcmlkLmdldENvcnJlY3Rpb24oKTtcbiAgICBmb3IgKGxldCBwID0gZDsgdShwLCBjKSAmJiAoaSA9PT0gdm9pZCAwIHx8IGEgPT09IHZvaWQgMCk7IHAgPSBoKHApKSBuW3BdLmhpZGUgfHwgKG8uc3RhcnRYID0gby5lbmRYLCBvLmVuZFggKz0gbltwXS53aWR0aCwgZyA+PSBvLnN0YXJ0WCAmJiAoZyA8PSBvLmVuZFggfHwgIXUoaChwKSwgYykpICYmIChpID0gcCwgciA9IG8uc3RhcnRYLCBzID0gby5lbmRYLCBsID0gKGcgLSBvLnN0YXJ0WCkgLyAoby5lbmRYIC0gby5zdGFydFgpKSwgZSA9PT0gbltwXS5uYW1lICYmIChhID0gcCkpO1xuICAgIHJldHVybiB7IHRhcmdldEluZGV4OiBpLCBkcmFnZ2VkSW5kZXg6IGEsIHhCZWZvcmU6IHIsIHhBZnRlcjogcywgY29sdW1uUmVsYXRpdmVQb3M6IGwgfTtcbiAgfVxuICBzZXRNYXJrZXJQb3NpdGlvbihlLCBuID0gMTApIHtcbiAgICBjb25zdCB7IG1hcmtlcjogaSB9ID0gdGhpcy5fZG5kLmNvbmZpZywgYSA9IHRoaXMuX2RuZC5fb2JqLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGkuc3R5bGUudG9wID0gYCR7YS55ICsgbn1weGAsIGkuc3R5bGUubGVmdCA9IGAke2V9cHhgO1xuICB9XG4gIGRyYXdUYXJnZXRNYXJrZXIoeyB0YXJnZXRJbmRleDogZSwgZHJhZ2dlZEluZGV4OiBuLCB4QmVmb3JlOiBpLCB4QWZ0ZXI6IGEsIGNvbHVtblJlbGF0aXZlUG9zOiByIH0pIHtcbiAgICBsZXQgcztcbiAgICB0aGlzLl90YXJnZXRNYXJrZXIgfHwgKHRoaXMuX3RhcmdldE1hcmtlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksIHd0KHRoaXMuX3RhcmdldE1hcmtlciwgXCJnYW50dF9ncmlkX3RhcmdldF9tYXJrZXJcIiksIHRoaXMuX3RhcmdldE1hcmtlci5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCIsIHRoaXMuX3RhcmdldE1hcmtlci5zdHlsZS5oZWlnaHQgPSBgJHt0aGlzLl9ncmlkQ29uZmlnLnNjYWxlX2hlaWdodH1weGApLCB0aGlzLl90YXJnZXRNYXJrZXIucGFyZW50Tm9kZSB8fCB0aGlzLiRncmlkLiRncmlkX3NjYWxlLmFwcGVuZENoaWxkKHRoaXMuX3RhcmdldE1hcmtlciksIHMgPSBlID4gbiA/IGEgOiBlIDwgbiA/IGkgOiByID4gMC41ID8gYSA6IGksIHRoaXMuX3RhcmdldE1hcmtlci5zdHlsZS5sZWZ0ID0gYCR7c31weGAsIHRoaXMuX3RhcmdldE1hcmtlci5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICB9XG4gIGNsZWFuVGFyZ2V0TWFya2VyKCkge1xuICAgIHRoaXMuX3RhcmdldE1hcmtlciAmJiB0aGlzLl90YXJnZXRNYXJrZXIucGFyZW50Tm9kZSAmJiB0aGlzLiRncmlkLiRncmlkX3NjYWxlLnJlbW92ZUNoaWxkKHRoaXMuX3RhcmdldE1hcmtlciksIHRoaXMuX3RhcmdldE1hcmtlciA9IG51bGw7XG4gIH1cbn1cbmZ1bmN0aW9uIFRlKHQpIHtcbiAgdmFyIGUgPSBbXTtcbiAgcmV0dXJuIHsgZGVsZWdhdGU6IGZ1bmN0aW9uKG4sIGksIGEsIHIpIHtcbiAgICBlLnB1c2goW24sIGksIGEsIHJdKSwgdC4kc2VydmljZXMuZ2V0U2VydmljZShcIm1vdXNlRXZlbnRzXCIpLmRlbGVnYXRlKG4sIGksIGEsIHIpO1xuICB9LCBkZXN0cnVjdG9yOiBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciBuID0gdC4kc2VydmljZXMuZ2V0U2VydmljZShcIm1vdXNlRXZlbnRzXCIpLCBpID0gMDsgaSA8IGUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBhID0gZVtpXTtcbiAgICAgIG4uZGV0YWNoKGFbMF0sIGFbMV0sIGFbMl0sIGFbM10pO1xuICAgIH1cbiAgICBlID0gW107XG4gIH0gfTtcbn1cbnZhciB4ZSA9IGZ1bmN0aW9uKHQsIGUsIG4sIGkpIHtcbiAgdGhpcy4kY29uZmlnID0gUCh7fSwgZSB8fCB7fSksIHRoaXMuJGdhbnR0ID0gaSwgdGhpcy4kcGFyZW50ID0gdCwgb3QodGhpcyksIHRoaXMuJHN0YXRlID0ge30sIFAodGhpcywgeW4odGhpcykpO1xufTtcbnhlLnByb3RvdHlwZSA9IHsgaW5pdDogZnVuY3Rpb24odCkge1xuICB2YXIgZSA9IHRoaXMuJGdhbnR0LCBuID0gZS5fd2FpQXJpYS5ncmlkQXR0clN0cmluZygpLCBpID0gZS5fd2FpQXJpYS5ncmlkRGF0YUF0dHJTdHJpbmcoKSwgYSA9IHRoaXMuJGdldENvbmZpZygpLCByID0gYS5yZW9yZGVyX2dyaWRfY29sdW1ucyB8fCAhMTtcbiAgdGhpcy4kY29uZmlnLnJlb3JkZXJfZ3JpZF9jb2x1bW5zICE9PSB2b2lkIDAgJiYgKHIgPSB0aGlzLiRjb25maWcucmVvcmRlcl9ncmlkX2NvbHVtbnMpLCB0LmlubmVySFRNTCA9IFwiPGRpdiBjbGFzcz0nZ2FudHRfZ3JpZCcgc3R5bGU9J2hlaWdodDppbmhlcml0O3dpZHRoOmluaGVyaXQ7JyBcIiArIG4gKyBcIj48L2Rpdj5cIiwgdGhpcy4kZ3JpZCA9IHQuY2hpbGROb2Rlc1swXSwgdGhpcy4kZ3JpZC5pbm5lckhUTUwgPSBcIjxkaXYgY2xhc3M9J2dhbnR0X2dyaWRfc2NhbGUnIFwiICsgZS5fd2FpQXJpYS5ncmlkU2NhbGVSb3dBdHRyU3RyaW5nKCkgKyBcIj48L2Rpdj48ZGl2IGNsYXNzPSdnYW50dF9ncmlkX2RhdGEnIFwiICsgaSArIFwiPjwvZGl2PlwiLCB0aGlzLiRncmlkX3NjYWxlID0gdGhpcy4kZ3JpZC5jaGlsZE5vZGVzWzBdLCB0aGlzLiRncmlkX2RhdGEgPSB0aGlzLiRncmlkLmNoaWxkTm9kZXNbMV07XG4gIHZhciBzID0gYVt0aGlzLiRjb25maWcuYmluZCArIFwiX2F0dHJpYnV0ZVwiXTtcbiAgaWYgKCFzICYmIHRoaXMuJGNvbmZpZy5iaW5kICYmIChzID0gXCJkYXRhLVwiICsgdGhpcy4kY29uZmlnLmJpbmQgKyBcIi1pZFwiKSwgdGhpcy4kY29uZmlnLml0ZW1fYXR0cmlidXRlID0gcyB8fCBudWxsLCAhdGhpcy4kY29uZmlnLmxheWVycykge1xuICAgIHZhciBvID0gdGhpcy5fY3JlYXRlTGF5ZXJDb25maWcoKTtcbiAgICB0aGlzLiRjb25maWcubGF5ZXJzID0gbztcbiAgfVxuICB2YXIgbCA9IHsgaW5pdDogZnVuY3Rpb24oKSB7XG4gIH0sIGRvT25SZW5kZXI6IGZ1bmN0aW9uKCkge1xuICB9IH07XG4gIHRoaXMuX3JlbmRlckhlYWRlclJlc2l6ZXJzID0gbC5kb09uUmVuZGVyLCB0aGlzLl9tb3VzZURlbGVnYXRlcyA9IFRlKGUpO1xuICB2YXIgZCA9IGZ1bmN0aW9uKGMsIHUpIHtcbiAgICB2YXIgaCA9IHsgcm93X2JlZm9yZV9zdGFydDogYy5iaW5kKGZ1bmN0aW9uKGcsIHAsIHkpIHtcbiAgICAgIHZhciB2ID0gdS4kZ2V0Q29uZmlnKCksIGIgPSB1LiRjb25maWcucm93U3RvcmU7XG4gICAgICBpZiAoIWV0KHksIHYudGFza19ncmlkX3Jvd19yZXNpemVyX2F0dHJpYnV0ZSkpIHJldHVybiAhMTtcbiAgICAgIHZhciBfID0gdGhpcy5sb2NhdGUoeSwgdi50YXNrX2dyaWRfcm93X3Jlc2l6ZXJfYXR0cmlidXRlKSwgbSA9IGIuZ2V0SXRlbShfKTtcbiAgICAgIHJldHVybiB1LmNhbGxFdmVudChcIm9uQmVmb3JlUm93UmVzaXplXCIsIFttXSkgIT09ICExICYmIHZvaWQgMDtcbiAgICB9LCBjKSwgcm93X2FmdGVyX3N0YXJ0OiBjLmJpbmQoZnVuY3Rpb24oZywgcCwgeSkge1xuICAgICAgdmFyIHYgPSB1LiRnZXRDb25maWcoKSwgYiA9IHRoaXMubG9jYXRlKHksIHYudGFza19ncmlkX3Jvd19yZXNpemVyX2F0dHJpYnV0ZSk7XG4gICAgICBnLmNvbmZpZy5tYXJrZXIuaW5uZXJIVE1MID0gXCJcIiwgZy5jb25maWcubWFya2VyLmNsYXNzTmFtZSArPSBcIiBnYW50dF9yb3dfZ3JpZF9yZXNpemVfYXJlYVwiLCBnLmNvbmZpZy5tYXJrZXIuc3R5bGUud2lkdGggPSB1LiRncmlkLm9mZnNldFdpZHRoICsgXCJweFwiLCBnLmNvbmZpZy5kcmFnX2lkID0gYjtcbiAgICB9LCBjKSwgcm93X2RyYWdfbW92ZTogYy5iaW5kKGZ1bmN0aW9uKGcsIHAsIHkpIHtcbiAgICAgIHZhciB2ID0gdS4kY29uZmlnLnJvd1N0b3JlLCBiID0gdS4kZ2V0Q29uZmlnKCksIF8gPSBnLmNvbmZpZywgbSA9IF8uZHJhZ19pZCwgZiA9IHUuZ2V0SXRlbUhlaWdodChtKSwgayA9IHUuZ2V0SXRlbVRvcChtKSAtIHAuc2Nyb2xsVG9wLCB4ID0gVih1LiRncmlkX2RhdGEpLCAkID0gcGFyc2VJbnQoXy5tYXJrZXIuc3R5bGUudG9wLCAxMCksIHcgPSBrICsgeC55LCBTID0gMCwgVCA9IGIubWluX3Rhc2tfZ3JpZF9yb3dfaGVpZ2h0O1xuICAgICAgcmV0dXJuIChTID0gJCAtIHcpIDwgVCAmJiAoUyA9IFQpLCBfLm1hcmtlci5zdHlsZS5sZWZ0ID0geC54ICsgXCJweFwiLCBfLm1hcmtlci5zdHlsZS50b3AgPSB3IC0gMSArIFwicHhcIiwgXy5tYXJrZXIuc3R5bGUuaGVpZ2h0ID0gTWF0aC5hYnMoUykgKyAxICsgXCJweFwiLCBfLm1hcmtlcl9oZWlnaHQgPSBTLCB1LmNhbGxFdmVudChcIm9uUm93UmVzaXplXCIsIFttLCB2LmdldEl0ZW0obSksIFMgKyBmXSksICEwO1xuICAgIH0sIGMpLCByb3dfZHJhZ19lbmQ6IGMuYmluZChmdW5jdGlvbihnLCBwLCB5KSB7XG4gICAgICB2YXIgdiA9IHUuJGNvbmZpZy5yb3dTdG9yZSwgYiA9IGcuY29uZmlnLCBfID0gYi5kcmFnX2lkLCBtID0gdi5nZXRJdGVtKF8pLCBmID0gdS5nZXRJdGVtSGVpZ2h0KF8pLCBrID0gYi5tYXJrZXJfaGVpZ2h0O1xuICAgICAgdS5jYWxsRXZlbnQoXCJvbkJlZm9yZVJvd1Jlc2l6ZUVuZFwiLCBbXywgbSwga10pICE9PSAhMSAmJiBtLnJvd19oZWlnaHQgIT0gayAmJiAobS5yb3dfaGVpZ2h0ID0gaywgdi51cGRhdGVJdGVtKF8pLCB1LmNhbGxFdmVudChcIm9uQWZ0ZXJSb3dSZXNpemVcIiwgW18sIG0sIGYsIGtdKSwgdGhpcy5yZW5kZXIoKSk7XG4gICAgfSwgYykgfTtcbiAgICByZXR1cm4geyBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBnID0gYy4kc2VydmljZXMuZ2V0U2VydmljZShcImRuZFwiKSwgcCA9IHUuJGdldENvbmZpZygpLCB5ID0gbmV3IGcodS4kZ3JpZF9kYXRhLCB7IHVwZGF0ZXNfcGVyX3NlY29uZDogNjAgfSk7XG4gICAgICBjLmRlZmluZWQocC5kbmRfc2Vuc2l0aXZpdHkpICYmICh5LmNvbmZpZy5zZW5zaXRpdml0eSA9IHAuZG5kX3NlbnNpdGl2aXR5KSwgeS5hdHRhY2hFdmVudChcIm9uQmVmb3JlRHJhZ1N0YXJ0XCIsIGZ1bmN0aW9uKHYsIGIpIHtcbiAgICAgICAgcmV0dXJuIGgucm93X2JlZm9yZV9zdGFydCh5LCB2LCBiKTtcbiAgICAgIH0pLCB5LmF0dGFjaEV2ZW50KFwib25BZnRlckRyYWdTdGFydFwiLCBmdW5jdGlvbih2LCBiKSB7XG4gICAgICAgIHJldHVybiBoLnJvd19hZnRlcl9zdGFydCh5LCB2LCBiKTtcbiAgICAgIH0pLCB5LmF0dGFjaEV2ZW50KFwib25EcmFnTW92ZVwiLCBmdW5jdGlvbih2LCBiKSB7XG4gICAgICAgIHJldHVybiBoLnJvd19kcmFnX21vdmUoeSwgdiwgYik7XG4gICAgICB9KSwgeS5hdHRhY2hFdmVudChcIm9uRHJhZ0VuZFwiLCBmdW5jdGlvbih2LCBiKSB7XG4gICAgICAgIHJldHVybiBoLnJvd19kcmFnX2VuZCh5LCB2LCBiKTtcbiAgICAgIH0pO1xuICAgIH0gfTtcbiAgfShlLCB0aGlzKTtcbiAgZC5pbml0KCksIHRoaXMuX2FkZExheWVycyh0aGlzLiRnYW50dCksIHRoaXMuX2luaXRFdmVudHMoKSwgciAmJiAodGhpcy5fY29sdW1uRE5EID0gbmV3IHZhKGUsIHRoaXMpLCB0aGlzLl9jb2x1bW5ETkQuaW5pdCgpKSwgdGhpcy5jYWxsRXZlbnQoXCJvblJlYWR5XCIsIFtdKTtcbn0sIF92YWxpZGF0ZUNvbHVtbldpZHRoOiBmdW5jdGlvbih0LCBlKSB7XG4gIHZhciBuID0gdFtlXTtcbiAgaWYgKG4gJiYgbiAhPSBcIipcIikge1xuICAgIHZhciBpID0gdGhpcy4kZ2FudHQsIGEgPSAxICogbjtcbiAgICBpc05hTihhKSA/IGkuYXNzZXJ0KCExLCBcIldyb25nIFwiICsgZSArIFwiIHZhbHVlIG9mIGNvbHVtbiBcIiArIHQubmFtZSkgOiB0W2VdID0gYTtcbiAgfVxufSwgc2V0U2l6ZTogZnVuY3Rpb24odCwgZSkge1xuICB0aGlzLiRjb25maWcud2lkdGggPSB0aGlzLiRzdGF0ZS53aWR0aCA9IHQsIHRoaXMuJGNvbmZpZy5oZWlnaHQgPSB0aGlzLiRzdGF0ZS5oZWlnaHQgPSBlO1xuICBmb3IgKHZhciBuLCBpID0gdGhpcy5nZXRHcmlkQ29sdW1ucygpLCBhID0gMCwgciA9IChkID0gdGhpcy4kZ2V0Q29uZmlnKCkpLmdyaWRfZWxhc3RpY19jb2x1bW5zLCBzID0gMCwgbyA9IGkubGVuZ3RoOyBzIDwgbzsgcysrKSB0aGlzLl92YWxpZGF0ZUNvbHVtbldpZHRoKGlbc10sIFwibWluX3dpZHRoXCIpLCB0aGlzLl92YWxpZGF0ZUNvbHVtbldpZHRoKGlbc10sIFwibWF4X3dpZHRoXCIpLCB0aGlzLl92YWxpZGF0ZUNvbHVtbldpZHRoKGlbc10sIFwid2lkdGhcIiksIGEgKz0gMSAqIGlbc10ud2lkdGg7XG4gIGlmICghaXNOYU4oYSkgJiYgdGhpcy4kY29uZmlnLnNjcm9sbGFibGUgfHwgKGEgPSBuID0gdGhpcy5fc2V0Q29sdW1uc1dpZHRoKHQgKyAxKSksIHRoaXMuJGNvbmZpZy5zY3JvbGxhYmxlICYmIHIgJiYgIWlzTmFOKGEpKSB7XG4gICAgbGV0IHUgPSBcIndpZHRoXCI7XG4gICAgciA9PSBcIm1pbl93aWR0aFwiICYmICh1ID0gXCJtaW5fd2lkdGhcIik7XG4gICAgbGV0IGggPSAwO1xuICAgIGkuZm9yRWFjaChmdW5jdGlvbihnKSB7XG4gICAgICBoICs9IGdbdV0gfHwgZC5taW5fZ3JpZF9jb2x1bW5fd2lkdGg7XG4gICAgfSk7XG4gICAgdmFyIGwgPSBNYXRoLm1heChoLCB0KTtcbiAgICBhID0gdGhpcy5fc2V0Q29sdW1uc1dpZHRoKGwpLCBuID0gdDtcbiAgfVxuICB0aGlzLiRjb25maWcuc2Nyb2xsYWJsZSA/ICh0aGlzLiRncmlkX3NjYWxlLnN0eWxlLndpZHRoID0gYSArIFwicHhcIiwgdGhpcy4kZ3JpZF9kYXRhLnN0eWxlLndpZHRoID0gYSArIFwicHhcIikgOiAodGhpcy4kZ3JpZF9zY2FsZS5zdHlsZS53aWR0aCA9IFwiaW5oZXJpdFwiLCB0aGlzLiRncmlkX2RhdGEuc3R5bGUud2lkdGggPSBcImluaGVyaXRcIiksIHRoaXMuJGNvbmZpZy53aWR0aCAtPSAxO1xuICB2YXIgZCA9IHRoaXMuJGdldENvbmZpZygpO1xuICBuICE9PSB0ICYmIChuICE9PSB2b2lkIDAgPyAoZC5ncmlkX3dpZHRoID0gbiwgdGhpcy4kY29uZmlnLndpZHRoID0gbiAtIDEpIDogaXNOYU4oYSkgfHwgKHRoaXMuX3NldENvbHVtbnNXaWR0aChhKSwgZC5ncmlkX3dpZHRoID0gYSwgdGhpcy4kY29uZmlnLndpZHRoID0gYSAtIDEpKTtcbiAgdmFyIGMgPSBNYXRoLm1heCh0aGlzLiRzdGF0ZS5oZWlnaHQgLSBkLnNjYWxlX2hlaWdodCwgMCk7XG4gIHRoaXMuJGdyaWRfZGF0YS5zdHlsZS5oZWlnaHQgPSBjICsgXCJweFwiLCB0aGlzLnJlZnJlc2goKTtcbn0sIGdldFNpemU6IGZ1bmN0aW9uKCkge1xuICB2YXIgdCA9IHRoaXMuJGdldENvbmZpZygpLCBlID0gdGhpcy4kY29uZmlnLnJvd1N0b3JlID8gdGhpcy5nZXRUb3RhbEhlaWdodCgpIDogMCwgbiA9IHRoaXMuX2dldEdyaWRXaWR0aCgpO1xuICByZXR1cm4geyB4OiB0aGlzLiRzdGF0ZS53aWR0aCwgeTogdGhpcy4kc3RhdGUuaGVpZ2h0LCBjb250ZW50WDogdGhpcy5pc1Zpc2libGUoKSA/IG4gOiAwLCBjb250ZW50WTogdGhpcy5pc1Zpc2libGUoKSA/IHQuc2NhbGVfaGVpZ2h0ICsgZSA6IDAsIHNjcm9sbEhlaWdodDogdGhpcy5pc1Zpc2libGUoKSA/IGUgOiAwLCBzY3JvbGxXaWR0aDogdGhpcy5pc1Zpc2libGUoKSA/IG4gOiAwIH07XG59LCBfYmluZFN0b3JlOiBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuJGNvbmZpZy5iaW5kKSB7XG4gICAgdmFyIHQgPSB0aGlzLiRnYW50dC5nZXREYXRhc3RvcmUodGhpcy4kY29uZmlnLmJpbmQpO1xuICAgIGlmICh0aGlzLiRjb25maWcucm93U3RvcmUgPSB0LCB0ICYmICF0Ll9ncmlkQ2FjaGVBdHRhY2hlZCkge1xuICAgICAgdmFyIGUgPSB0aGlzO1xuICAgICAgdC5fZ3JpZENhY2hlQXR0YWNoZWQgPSB0LmF0dGFjaEV2ZW50KFwib25CZWZvcmVGaWx0ZXJcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGUuX3Jlc2V0VG9wUG9zaXRpb25IZWlnaHQoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufSwgX3VuYmluZFN0b3JlOiBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuJGNvbmZpZy5iaW5kKSB7XG4gICAgdmFyIHQgPSB0aGlzLiRnYW50dC5nZXREYXRhc3RvcmUodGhpcy4kY29uZmlnLmJpbmQpO1xuICAgIHQgJiYgdC5fZ3JpZENhY2hlQXR0YWNoZWQgJiYgKHQuZGV0YWNoRXZlbnQodC5fZ3JpZENhY2hlQXR0YWNoZWQpLCB0Ll9ncmlkQ2FjaGVBdHRhY2hlZCA9ICExKTtcbiAgfVxufSwgcmVmcmVzaDogZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2JpbmRTdG9yZSgpLCB0aGlzLl9yZXNldFRvcFBvc2l0aW9uSGVpZ2h0KCksIHRoaXMuX3Jlc2V0SGVpZ2h0KCksIHRoaXMuX2luaXRTbWFydFJlbmRlcmluZ1BsYWNlaG9sZGVyKCksIHRoaXMuX2NhbGN1bGF0ZUdyaWRXaWR0aCgpLCB0aGlzLl9yZW5kZXJHcmlkSGVhZGVyKCk7XG59LCBnZXRWaWV3UG9ydDogZnVuY3Rpb24oKSB7XG4gIHZhciB0ID0gdGhpcy4kY29uZmlnLnNjcm9sbExlZnQgfHwgMCwgZSA9IHRoaXMuJGNvbmZpZy5zY3JvbGxUb3AgfHwgMCwgbiA9IHRoaXMuJGNvbmZpZy5oZWlnaHQgfHwgMCwgaSA9IHRoaXMuJGNvbmZpZy53aWR0aCB8fCAwO1xuICByZXR1cm4geyB5OiBlLCB5X2VuZDogZSArIG4sIHg6IHQsIHhfZW5kOiB0ICsgaSwgaGVpZ2h0OiBuLCB3aWR0aDogaSB9O1xufSwgc2Nyb2xsVG86IGZ1bmN0aW9uKHQsIGUpIHtcbiAgaWYgKHRoaXMuaXNWaXNpYmxlKCkpIHtcbiAgICB2YXIgbiA9ICExO1xuICAgIHRoaXMuJGNvbmZpZy5zY3JvbGxUb3AgPSB0aGlzLiRjb25maWcuc2Nyb2xsVG9wIHx8IDAsIHRoaXMuJGNvbmZpZy5zY3JvbGxMZWZ0ID0gdGhpcy4kY29uZmlnLnNjcm9sbExlZnQgfHwgMCwgMSAqIHQgPT0gdCAmJiAodGhpcy4kY29uZmlnLnNjcm9sbExlZnQgPSB0aGlzLiRzdGF0ZS5zY3JvbGxMZWZ0ID0gdGhpcy4kZ3JpZC5zY3JvbGxMZWZ0ID0gdCwgbiA9ICEwKSwgMSAqIGUgPT0gZSAmJiAodGhpcy4kY29uZmlnLnNjcm9sbFRvcCA9IHRoaXMuJHN0YXRlLnNjcm9sbFRvcCA9IHRoaXMuJGdyaWRfZGF0YS5zY3JvbGxUb3AgPSBlLCBuID0gITApLCBuICYmIHRoaXMuY2FsbEV2ZW50KFwib25TY3JvbGxcIiwgW3RoaXMuJGNvbmZpZy5zY3JvbGxMZWZ0LCB0aGlzLiRjb25maWcuc2Nyb2xsVG9wXSk7XG4gIH1cbn0sIGdldENvbHVtbkluZGV4OiBmdW5jdGlvbih0LCBlKSB7XG4gIGZvciAodmFyIG4gPSB0aGlzLiRnZXRDb25maWcoKS5jb2x1bW5zLCBpID0gMCwgYSA9IDA7IGEgPCBuLmxlbmd0aDsgYSsrKSBpZiAoZSAmJiBuW2FdLmhpZGUgJiYgaSsrLCBuW2FdLm5hbWUgPT0gdCkgcmV0dXJuIGEgLSBpO1xuICByZXR1cm4gbnVsbDtcbn0sIGdldENvbHVtbjogZnVuY3Rpb24odCkge1xuICB2YXIgZSA9IHRoaXMuZ2V0Q29sdW1uSW5kZXgodCk7XG4gIHJldHVybiBlID09PSBudWxsID8gbnVsbCA6IHRoaXMuJGdldENvbmZpZygpLmNvbHVtbnNbZV07XG59LCBnZXRHcmlkQ29sdW1uczogZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLiRnZXRDb25maWcoKS5jb2x1bW5zLnNsaWNlKCk7XG59LCBpc1Zpc2libGU6IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy4kcGFyZW50ICYmIHRoaXMuJHBhcmVudC4kY29uZmlnID8gIXRoaXMuJHBhcmVudC4kY29uZmlnLmhpZGRlbiA6IHRoaXMuJGdyaWQub2Zmc2V0V2lkdGg7XG59LCBfY3JlYXRlTGF5ZXJDb25maWc6IGZ1bmN0aW9uKCkge1xuICB2YXIgdCA9IHRoaXMuJGdhbnR0LCBlID0gdGhpcztcbiAgcmV0dXJuIFt7IHJlbmRlcmVyOiB0LiR1aS5sYXllcnMuZ3JpZExpbmUoKSwgY29udGFpbmVyOiB0aGlzLiRncmlkX2RhdGEsIGZpbHRlcjogW2Z1bmN0aW9uKCkge1xuICAgIHJldHVybiBlLmlzVmlzaWJsZSgpO1xuICB9XSB9LCB7IHJlbmRlcmVyOiB0LiR1aS5sYXllcnMuZ3JpZFRhc2tSb3dSZXNpemVyKCksIGNvbnRhaW5lcjogdGhpcy4kZ3JpZF9kYXRhLCBhcHBlbmQ6ICEwLCBmaWx0ZXI6IFtmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdC5jb25maWcucmVzaXplX3Jvd3M7XG4gIH1dIH1dO1xufSwgX2FkZExheWVyczogZnVuY3Rpb24odCkge1xuICBpZiAodGhpcy4kY29uZmlnLmJpbmQpIHtcbiAgICB0aGlzLl90YXNrTGF5ZXJzID0gW107XG4gICAgdmFyIGUgPSB0aGlzLCBuID0gdGhpcy4kZ2FudHQuJHNlcnZpY2VzLmdldFNlcnZpY2UoXCJsYXllcnNcIiksIGkgPSBuLmdldERhdGFSZW5kZXIodGhpcy4kY29uZmlnLmJpbmQpO1xuICAgIGkgfHwgKGkgPSBuLmNyZWF0ZURhdGFSZW5kZXIoeyBuYW1lOiB0aGlzLiRjb25maWcuYmluZCwgZGVmYXVsdENvbnRhaW5lcjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZS4kZ3JpZF9kYXRhO1xuICAgIH0gfSkpO1xuICAgIGZvciAodmFyIGEgPSB0aGlzLiRjb25maWcubGF5ZXJzLCByID0gMDsgYSAmJiByIDwgYS5sZW5ndGg7IHIrKykge1xuICAgICAgdmFyIHMgPSBhW3JdO1xuICAgICAgcy52aWV3ID0gdGhpcztcbiAgICAgIHZhciBvID0gaS5hZGRMYXllcihzKTtcbiAgICAgIHRoaXMuX3Rhc2tMYXllcnMucHVzaChvKTtcbiAgICB9XG4gICAgdGhpcy5fYmluZFN0b3JlKCksIHRoaXMuX2luaXRTbWFydFJlbmRlcmluZ1BsYWNlaG9sZGVyKCk7XG4gIH1cbn0sIF9yZWZyZXNoUGxhY2Vob2xkZXJPblN0b3JlVXBkYXRlOiBmdW5jdGlvbih0KSB7XG4gIHZhciBlID0gdGhpcy4kZ2V0Q29uZmlnKCksIG4gPSB0aGlzLiRjb25maWcucm93U3RvcmU7XG4gIGlmIChuICYmIHQgPT09IG51bGwgJiYgdGhpcy5pc1Zpc2libGUoKSAmJiBlLnNtYXJ0X3JlbmRlcmluZykge1xuICAgIHZhciBpO1xuICAgIGlmICh0aGlzLiRjb25maWcuc2Nyb2xsWSkge1xuICAgICAgdmFyIGEgPSB0aGlzLiRnYW50dC4kdWkuZ2V0Vmlldyh0aGlzLiRjb25maWcuc2Nyb2xsWSk7XG4gICAgICBhICYmIChpID0gYS5nZXRTY3JvbGxTdGF0ZSgpLnNjcm9sbFNpemUpO1xuICAgIH1cbiAgICBpZiAoaSB8fCAoaSA9IG4gPyB0aGlzLmdldFRvdGFsSGVpZ2h0KCkgOiAwKSwgaSkge1xuICAgICAgdGhpcy4kcm93c1BsYWNlaG9sZGVyICYmIHRoaXMuJHJvd3NQbGFjZWhvbGRlci5wYXJlbnROb2RlICYmIHRoaXMuJHJvd3NQbGFjZWhvbGRlci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuJHJvd3NQbGFjZWhvbGRlcik7XG4gICAgICB2YXIgciA9IHRoaXMuJHJvd3NQbGFjZWhvbGRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICByLnN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiLCByLnN0eWxlLmhlaWdodCA9IGkgKyBcInB4XCIsIHIuc3R5bGUud2lkdGggPSBcIjFweFwiLCB0aGlzLiRncmlkX2RhdGEuYXBwZW5kQ2hpbGQocik7XG4gICAgfVxuICB9XG59LCBfaW5pdFNtYXJ0UmVuZGVyaW5nUGxhY2Vob2xkZXI6IGZ1bmN0aW9uKCkge1xuICB2YXIgdCA9IHRoaXMuJGNvbmZpZy5yb3dTdG9yZTtcbiAgdCAmJiAodGhpcy5faW5pdFNtYXJ0UmVuZGVyaW5nUGxhY2Vob2xkZXIgPSBmdW5jdGlvbigpIHtcbiAgfSwgdGhpcy5fc3RhdGljQmdIYW5kbGVyID0gdC5hdHRhY2hFdmVudChcIm9uU3RvcmVVcGRhdGVkXCIsIFIodGhpcy5fcmVmcmVzaFBsYWNlaG9sZGVyT25TdG9yZVVwZGF0ZSwgdGhpcykpKTtcbn0sIF9pbml0RXZlbnRzOiBmdW5jdGlvbigpIHtcbiAgdmFyIHQgPSB0aGlzLiRnYW50dDtcbiAgdGhpcy5fbW91c2VEZWxlZ2F0ZXMuZGVsZWdhdGUoXCJjbGlja1wiLCBcImdhbnR0X2Nsb3NlXCIsIHQuYmluZChmdW5jdGlvbihlLCBuLCBpKSB7XG4gICAgdmFyIGEgPSB0aGlzLiRjb25maWcucm93U3RvcmU7XG4gICAgaWYgKCFhKSByZXR1cm4gITA7XG4gICAgdmFyIHIgPSBldChlLCB0aGlzLiRjb25maWcuaXRlbV9hdHRyaWJ1dGUpO1xuICAgIHJldHVybiByICYmIGEuY2xvc2Uoci5nZXRBdHRyaWJ1dGUodGhpcy4kY29uZmlnLml0ZW1fYXR0cmlidXRlKSksICExO1xuICB9LCB0aGlzKSwgdGhpcy4kZ3JpZCksIHRoaXMuX21vdXNlRGVsZWdhdGVzLmRlbGVnYXRlKFwiY2xpY2tcIiwgXCJnYW50dF9vcGVuXCIsIHQuYmluZChmdW5jdGlvbihlLCBuLCBpKSB7XG4gICAgdmFyIGEgPSB0aGlzLiRjb25maWcucm93U3RvcmU7XG4gICAgaWYgKCFhKSByZXR1cm4gITA7XG4gICAgdmFyIHIgPSBldChlLCB0aGlzLiRjb25maWcuaXRlbV9hdHRyaWJ1dGUpO1xuICAgIHJldHVybiByICYmIGEub3BlbihyLmdldEF0dHJpYnV0ZSh0aGlzLiRjb25maWcuaXRlbV9hdHRyaWJ1dGUpKSwgITE7XG4gIH0sIHRoaXMpLCB0aGlzLiRncmlkKTtcbn0sIF9jbGVhckxheWVyczogZnVuY3Rpb24odCkge1xuICB2YXIgZSA9IHRoaXMuJGdhbnR0LiRzZXJ2aWNlcy5nZXRTZXJ2aWNlKFwibGF5ZXJzXCIpLmdldERhdGFSZW5kZXIodGhpcy4kY29uZmlnLmJpbmQpO1xuICBpZiAodGhpcy5fdGFza0xheWVycykgZm9yICh2YXIgbiA9IDA7IG4gPCB0aGlzLl90YXNrTGF5ZXJzLmxlbmd0aDsgbisrKSBlLnJlbW92ZUxheWVyKHRoaXMuX3Rhc2tMYXllcnNbbl0pO1xuICB0aGlzLl90YXNrTGF5ZXJzID0gW107XG59LCBfZ2V0Q29sdW1uV2lkdGg6IGZ1bmN0aW9uKHQsIGUsIG4pIHtcbiAgdmFyIGkgPSB0Lm1pbl93aWR0aCB8fCBlLm1pbl9ncmlkX2NvbHVtbl93aWR0aCwgYSA9IE1hdGgubWF4KG4sIGkgfHwgMTApO1xuICByZXR1cm4gdC5tYXhfd2lkdGggJiYgKGEgPSBNYXRoLm1pbihhLCB0Lm1heF93aWR0aCkpLCBhO1xufSwgX2NoZWNrR3JpZENvbHVtbk1pbldpZHRoTGltaXRzOiBmdW5jdGlvbih0LCBlKSB7XG4gIGZvciAodmFyIG4gPSAwLCBpID0gdC5sZW5ndGg7IG4gPCBpOyBuKyspIHtcbiAgICB2YXIgYSA9IDEgKiB0W25dLndpZHRoO1xuICAgICF0W25dLm1pbl93aWR0aCAmJiBhIDwgZS5taW5fZ3JpZF9jb2x1bW5fd2lkdGggJiYgKHRbbl0ubWluX3dpZHRoID0gYSk7XG4gIH1cbn0sIF9nZXRHcmlkV2lkdGhMaW1pdHM6IGZ1bmN0aW9uKCkge1xuICBmb3IgKHZhciB0ID0gdGhpcy4kZ2V0Q29uZmlnKCksIGUgPSB0aGlzLmdldEdyaWRDb2x1bW5zKCksIG4gPSAwLCBpID0gMCwgYSA9IDA7IGEgPCBlLmxlbmd0aDsgYSsrKSBuICs9IGVbYV0ubWluX3dpZHRoID8gZVthXS5taW5fd2lkdGggOiB0Lm1pbl9ncmlkX2NvbHVtbl93aWR0aCwgaSAhPT0gdm9pZCAwICYmIChpID0gZVthXS5tYXhfd2lkdGggPyBpICsgZVthXS5tYXhfd2lkdGggOiB2b2lkIDApO1xuICByZXR1cm4gdGhpcy5fY2hlY2tHcmlkQ29sdW1uTWluV2lkdGhMaW1pdHMoZSwgdCksIFtuLCBpXTtcbn0sIF9zZXRDb2x1bW5zV2lkdGg6IGZ1bmN0aW9uKHQsIGUpIHtcbiAgdmFyIG4gPSB0aGlzLiRnZXRDb25maWcoKSwgaSA9IHRoaXMuZ2V0R3JpZENvbHVtbnMoKSwgYSA9IDAsIHIgPSB0O1xuICBlID0gd2luZG93LmlzTmFOKGUpID8gLTEgOiBlO1xuICBmb3IgKHZhciBzID0gMCwgbyA9IGkubGVuZ3RoOyBzIDwgbzsgcysrKSBhICs9IDEgKiBpW3NdLndpZHRoO1xuICBpZiAod2luZG93LmlzTmFOKGEpKVxuICAgIGZvciAodGhpcy5fY2FsY3VsYXRlR3JpZFdpZHRoKCksIGEgPSAwLCBzID0gMCwgbyA9IGkubGVuZ3RoOyBzIDwgbzsgcysrKSBhICs9IDEgKiBpW3NdLndpZHRoO1xuICB2YXIgbCA9IHIgLSBhLCBkID0gMDtcbiAgZm9yIChzID0gMDsgcyA8IGUgKyAxOyBzKyspIGQgKz0gaVtzXS53aWR0aDtcbiAgZm9yIChhIC09IGQsIHMgPSBlICsgMTsgcyA8IGkubGVuZ3RoOyBzKyspIHtcbiAgICB2YXIgYyA9IGlbc10sIHUgPSBNYXRoLnJvdW5kKGwgKiAoYy53aWR0aCAvIGEpKTtcbiAgICBsIDwgMCA/IGMubWluX3dpZHRoICYmIGMud2lkdGggKyB1IDwgYy5taW5fd2lkdGggPyB1ID0gYy5taW5fd2lkdGggLSBjLndpZHRoIDogIWMubWluX3dpZHRoICYmIG4ubWluX2dyaWRfY29sdW1uX3dpZHRoICYmIGMud2lkdGggKyB1IDwgbi5taW5fZ3JpZF9jb2x1bW5fd2lkdGggJiYgKHUgPSBuLm1pbl9ncmlkX2NvbHVtbl93aWR0aCAtIGMud2lkdGgpIDogYy5tYXhfd2lkdGggJiYgYy53aWR0aCArIHUgPiBjLm1heF93aWR0aCAmJiAodSA9IGMubWF4X3dpZHRoIC0gYy53aWR0aCksIGEgLT0gYy53aWR0aCwgYy53aWR0aCArPSB1LCBsIC09IHU7XG4gIH1cbiAgZm9yICh2YXIgaCA9IGwgPiAwID8gMSA6IC0xOyBsID4gMCAmJiBoID09PSAxIHx8IGwgPCAwICYmIGggPT09IC0xOyApIHtcbiAgICB2YXIgZyA9IGw7XG4gICAgZm9yIChzID0gZSArIDE7IHMgPCBpLmxlbmd0aDsgcysrKSB7XG4gICAgICB2YXIgcDtcbiAgICAgIGlmICgocCA9IGlbc10ud2lkdGggKyBoKSA9PSB0aGlzLl9nZXRDb2x1bW5XaWR0aChpW3NdLCBuLCBwKSAmJiAobCAtPSBoLCBpW3NdLndpZHRoID0gcCksICFsKSBicmVhaztcbiAgICB9XG4gICAgaWYgKGcgPT0gbCkgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIGwgJiYgZSA+IC0xICYmIChwID0gaVtlXS53aWR0aCArIGwpID09IHRoaXMuX2dldENvbHVtbldpZHRoKGlbZV0sIG4sIHApICYmIChpW2VdLndpZHRoID0gcCksIHRoaXMuX2dldENvbHNUb3RhbFdpZHRoKCk7XG59LCBfZ2V0Q29sc1RvdGFsV2lkdGg6IGZ1bmN0aW9uKCkge1xuICBmb3IgKHZhciB0ID0gdGhpcy5nZXRHcmlkQ29sdW1ucygpLCBlID0gMCwgbiA9IDA7IG4gPCB0Lmxlbmd0aDsgbisrKSB7XG4gICAgdmFyIGkgPSBwYXJzZUZsb2F0KHRbbl0ud2lkdGgpO1xuICAgIGlmICh3aW5kb3cuaXNOYU4oaSkpIHJldHVybiAhMTtcbiAgICBlICs9IGk7XG4gIH1cbiAgcmV0dXJuIGU7XG59LCBfY2FsY3VsYXRlR3JpZFdpZHRoOiBmdW5jdGlvbigpIHtcbiAgZm9yICh2YXIgdCA9IHRoaXMuJGdldENvbmZpZygpLCBlID0gdGhpcy5nZXRHcmlkQ29sdW1ucygpLCBuID0gMCwgaSA9IFtdLCBhID0gW10sIHIgPSAwOyByIDwgZS5sZW5ndGg7IHIrKykge1xuICAgIHZhciBzID0gcGFyc2VGbG9hdChlW3JdLndpZHRoKTtcbiAgICB3aW5kb3cuaXNOYU4ocykgJiYgKHMgPSB0Lm1pbl9ncmlkX2NvbHVtbl93aWR0aCB8fCAxMCwgaS5wdXNoKHIpKSwgYVtyXSA9IHMsIG4gKz0gcztcbiAgfVxuICB2YXIgbyA9IHRoaXMuX2dldEdyaWRXaWR0aCgpICsgMTtcbiAgaWYgKHQuYXV0b2ZpdCB8fCBpLmxlbmd0aCkge1xuICAgIHZhciBsID0gbyAtIG47XG4gICAgaWYgKHQuYXV0b2ZpdCAmJiAhdC5ncmlkX2VsYXN0aWNfY29sdW1ucykgZm9yIChyID0gMDsgciA8IGEubGVuZ3RoOyByKyspIHtcbiAgICAgIHZhciBkID0gTWF0aC5yb3VuZChsIC8gKGEubGVuZ3RoIC0gcikpO1xuICAgICAgYVtyXSArPSBkLCAoYyA9IHRoaXMuX2dldENvbHVtbldpZHRoKGVbcl0sIHQsIGFbcl0pKSAhPSBhW3JdICYmIChkID0gYyAtIGFbcl0sIGFbcl0gPSBjKSwgbCAtPSBkO1xuICAgIH1cbiAgICBlbHNlIGlmIChpLmxlbmd0aCkgZm9yIChyID0gMDsgciA8IGkubGVuZ3RoOyByKyspIHtcbiAgICAgIGQgPSBNYXRoLnJvdW5kKGwgLyAoaS5sZW5ndGggLSByKSk7XG4gICAgICB2YXIgYywgdSA9IGlbcl07XG4gICAgICBhW3VdICs9IGQsIChjID0gdGhpcy5fZ2V0Q29sdW1uV2lkdGgoZVt1XSwgdCwgYVt1XSkpICE9IGFbdV0gJiYgKGQgPSBjIC0gYVt1XSwgYVt1XSA9IGMpLCBsIC09IGQ7XG4gICAgfVxuICAgIGZvciAociA9IDA7IHIgPCBhLmxlbmd0aDsgcisrKSBlW3JdLndpZHRoID0gYVtyXTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgaCA9IG8gIT0gbjtcbiAgICB0aGlzLiRjb25maWcud2lkdGggPSBuIC0gMSwgdC5ncmlkX3dpZHRoID0gbiwgaCAmJiB0aGlzLiRwYXJlbnQuX3NldENvbnRlbnRTaXplKHRoaXMuJGNvbmZpZy53aWR0aCwgbnVsbCk7XG4gIH1cbn0sIF9yZW5kZXJHcmlkSGVhZGVyOiBmdW5jdGlvbigpIHtcbiAgdmFyIHQgPSB0aGlzLiRnYW50dCwgZSA9IHRoaXMuJGdldENvbmZpZygpLCBuID0gdGhpcy4kZ2FudHQubG9jYWxlLCBpID0gdGhpcy4kZ2FudHQudGVtcGxhdGVzLCBhID0gdGhpcy5nZXRHcmlkQ29sdW1ucygpO1xuICBlLnJ0bCAmJiAoYSA9IGEucmV2ZXJzZSgpKTtcbiAgdmFyIHIgPSBbXSwgcyA9IDAsIG8gPSBuLmxhYmVscywgbCA9IGUuc2NhbGVfaGVpZ2h0IC0gMTtcbiAgY29uc3QgZCA9IHt9O1xuICBmb3IgKHZhciBjID0gMDsgYyA8IGEubGVuZ3RoOyBjKyspIHtcbiAgICB2YXIgdSA9IGMgPT0gYS5sZW5ndGggLSAxLCBoID0gYVtjXTtcbiAgICBoLm5hbWUgfHwgKGgubmFtZSA9IHQudWlkKCkgKyBcIlwiKTtcbiAgICB2YXIgZyA9IDEgKiBoLndpZHRoLCBwID0gdGhpcy5fZ2V0R3JpZFdpZHRoKCk7XG4gICAgdSAmJiBwID4gcyArIGcgJiYgKGgud2lkdGggPSBnID0gcCAtIHMpLCBzICs9IGc7XG4gICAgdmFyIHkgPSB0Ll9zb3J0ICYmIGgubmFtZSA9PSB0Ll9zb3J0Lm5hbWUgPyBgPGRpdiBkYXRhLWNvbHVtbi1pZD1cIiR7aC5uYW1lfVwiIGNsYXNzPVwiZ2FudHRfc29ydCBnYW50dF8ke3QuX3NvcnQuZGlyZWN0aW9ufVwiPjwvZGl2PmAgOiBcIlwiLCB2ID0gW1wiZ2FudHRfZ3JpZF9oZWFkX2NlbGxcIiwgXCJnYW50dF9ncmlkX2hlYWRfXCIgKyBoLm5hbWUsIHUgPyBcImdhbnR0X2xhc3RfY2VsbFwiIDogXCJcIiwgaS5ncmlkX2hlYWRlcl9jbGFzcyhoLm5hbWUsIGgpXS5qb2luKFwiIFwiKSwgYiA9IFwid2lkdGg6XCIgKyAoZyAtICh1ID8gMSA6IDApKSArIFwicHg7XCIsIF8gPSBoLmxhYmVsIHx8IG9bXCJjb2x1bW5fXCIgKyBoLm5hbWVdIHx8IG9baC5uYW1lXTtcbiAgICB0eXBlb2YgXyA9PSBcImZ1bmN0aW9uXCIgJiYgKF8gPSBfLmNhbGwodCwgaC5uYW1lLCBoKSksIF8gPSBfIHx8IFwiXCI7XG4gICAgbGV0IGYgPSAhMTtcbiAgICB0LmNvbmZpZy5leHRlcm5hbF9yZW5kZXIgJiYgdC5jb25maWcuZXh0ZXJuYWxfcmVuZGVyLmlzRWxlbWVudChfKSAmJiAoZiA9ICEwLCBkW2gubmFtZV0gPSBfKTtcbiAgICB2YXIgbSA9IFwiPGRpdiBjbGFzcz0nXCIgKyB2ICsgXCInIHN0eWxlPSdcIiArIGIgKyBcIicgXCIgKyB0Ll93YWlBcmlhLmdyaWRTY2FsZUNlbGxBdHRyU3RyaW5nKGgsIF8pICsgXCIgZGF0YS1jb2x1bW4taWQ9J1wiICsgaC5uYW1lICsgXCInIGNvbHVtbl9pZD0nXCIgKyBoLm5hbWUgKyBcIicgZGF0YS1jb2x1bW4tbmFtZT0nXCIgKyBoLm5hbWUgKyBcIicgZGF0YS1jb2x1bW4taW5kZXg9J1wiICsgYyArIFwiJz5cIiArIChmID8gXCI8ZGl2IGRhdGEtY29tcG9uZW50LWNvbnRhaW5lcj48L2Rpdj5cIiA6IF8pICsgeSArIFwiPC9kaXY+XCI7XG4gICAgci5wdXNoKG0pO1xuICB9XG4gIHRoaXMuJGdyaWRfc2NhbGUuc3R5bGUuaGVpZ2h0ID0gZS5zY2FsZV9oZWlnaHQgKyBcInB4XCIsIHRoaXMuJGdyaWRfc2NhbGUuc3R5bGUubGluZUhlaWdodCA9IGwgKyBcInB4XCIsIHRoaXMuJGdyaWRfc2NhbGUuaW5uZXJIVE1MID0gci5qb2luKFwiXCIpO1xuICBmb3IgKGxldCBmIGluIGQpIHQuY29uZmlnLmV4dGVybmFsX3JlbmRlci5yZW5kZXJFbGVtZW50KGRbZl0sIHRoaXMuJGdyaWRfc2NhbGUucXVlcnlTZWxlY3RvcihcIltkYXRhLWNvbHVtbi1pZD0nXCIgKyBmICsgXCInXSBbZGF0YS1jb21wb25lbnQtY29udGFpbmVyXVwiKSk7XG4gIHRoaXMuX3JlbmRlckhlYWRlclJlc2l6ZXJzICYmIHRoaXMuX3JlbmRlckhlYWRlclJlc2l6ZXJzKCk7XG59LCBfZ2V0R3JpZFdpZHRoOiBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuJGNvbmZpZy53aWR0aDtcbn0sIGRlc3RydWN0b3I6IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9jbGVhckxheWVycyh0aGlzLiRnYW50dCksIHRoaXMuX21vdXNlRGVsZWdhdGVzICYmICh0aGlzLl9tb3VzZURlbGVnYXRlcy5kZXN0cnVjdG9yKCksIHRoaXMuX21vdXNlRGVsZWdhdGVzID0gbnVsbCksIHRoaXMuX3VuYmluZFN0b3JlKCksIHRoaXMuJGdyaWQgPSBudWxsLCB0aGlzLiRncmlkX3NjYWxlID0gbnVsbCwgdGhpcy4kZ3JpZF9kYXRhID0gbnVsbCwgdGhpcy4kZ2FudHQgPSBudWxsLCB0aGlzLiRjb25maWcucm93U3RvcmUgJiYgKHRoaXMuJGNvbmZpZy5yb3dTdG9yZS5kZXRhY2hFdmVudCh0aGlzLl9zdGF0aWNCZ0hhbmRsZXIpLCB0aGlzLiRjb25maWcucm93U3RvcmUgPSBudWxsKSwgdGhpcy5jYWxsRXZlbnQoXCJvbkRlc3Ryb3lcIiwgW10pLCB0aGlzLmRldGFjaEFsbEV2ZW50cygpO1xufSB9O1xuY29uc3Qga2EgPSB7IGluaXQ6IGZ1bmN0aW9uKHQsIGUpIHtcbiAgdmFyIG4gPSBlLiRnYW50dDtcbiAgbi5hdHRhY2hFdmVudChcIm9uVGFza0NsaWNrXCIsIGZ1bmN0aW9uKGksIGEpIHtcbiAgICBpZiAobi5faXNfaWNvbl9vcGVuX2NsaWNrKGEpKSByZXR1cm4gITA7XG4gICAgdmFyIHIgPSB0LmdldFN0YXRlKCksIHMgPSB0LmxvY2F0ZUNlbGwoYS50YXJnZXQpO1xuICAgIHJldHVybiAhcyB8fCAhdC5nZXRFZGl0b3JDb25maWcocy5jb2x1bW5OYW1lKSB8fCAodC5pc1Zpc2libGUoKSAmJiByLmlkID09IHMuaWQgJiYgci5jb2x1bW5OYW1lID09IHMuY29sdW1uTmFtZSB8fCB0LnN0YXJ0RWRpdChzLmlkLCBzLmNvbHVtbk5hbWUpLCAhMSk7XG4gIH0pLCBuLmF0dGFjaEV2ZW50KFwib25FbXB0eUNsaWNrXCIsIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0LmlzVmlzaWJsZSgpICYmIHQuaXNDaGFuZ2VkKCkgPyB0LnNhdmUoKSA6IHQuaGlkZSgpLCAhMDtcbiAgfSksIG4uYXR0YWNoRXZlbnQoXCJvblRhc2tEYmxDbGlja1wiLCBmdW5jdGlvbihpLCBhKSB7XG4gICAgdmFyIHIgPSB0LmdldFN0YXRlKCksIHMgPSB0LmxvY2F0ZUNlbGwoYS50YXJnZXQpO1xuICAgIHJldHVybiAhcyB8fCAhdC5pc1Zpc2libGUoKSB8fCBzLmNvbHVtbk5hbWUgIT0gci5jb2x1bW5OYW1lO1xuICB9KTtcbn0sIG9uU2hvdzogZnVuY3Rpb24odCwgZSwgbikge1xuICB2YXIgaSA9IG4uJGdhbnR0O1xuICBpLmV4dCAmJiBpLmV4dC5rZXlib2FyZE5hdmlnYXRpb24gJiYgaS5leHQua2V5Ym9hcmROYXZpZ2F0aW9uLmF0dGFjaEV2ZW50KFwib25LZXlEb3duXCIsIGZ1bmN0aW9uKGEsIHIpIHtcbiAgICB2YXIgcyA9IGkuY29uc3RhbnRzLktFWV9DT0RFUywgbyA9ICExO1xuICAgIHJldHVybiByLmtleUNvZGUgPT09IHMuU1BBQ0UgJiYgdC5pc1Zpc2libGUoKSAmJiAobyA9ICEwKSwgIW87XG4gIH0pLCBlLm9ua2V5ZG93biA9IGZ1bmN0aW9uKGEpIHtcbiAgICBhID0gYSB8fCB3aW5kb3cuZXZlbnQ7XG4gICAgdmFyIHIgPSBpLmNvbnN0YW50cy5LRVlfQ09ERVM7XG4gICAgaWYgKCEoYS5kZWZhdWx0UHJldmVudGVkIHx8IGEuc2hpZnRLZXkgJiYgYS5rZXlDb2RlICE9IHIuVEFCKSkge1xuICAgICAgdmFyIHMgPSAhMDtcbiAgICAgIHN3aXRjaCAoYS5rZXlDb2RlKSB7XG4gICAgICAgIGNhc2UgaS5rZXlzLmVkaXRfc2F2ZTpcbiAgICAgICAgICB0LnNhdmUoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBpLmtleXMuZWRpdF9jYW5jZWw6XG4gICAgICAgICAgdC5oaWRlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2Ugci5VUDpcbiAgICAgICAgY2FzZSByLkRPV046XG4gICAgICAgICAgdC5pc1Zpc2libGUoKSAmJiAodC5oaWRlKCksIHMgPSAhMSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2Ugci5UQUI6XG4gICAgICAgICAgYS5zaGlmdEtleSA/IHQuZWRpdFByZXZDZWxsKCEwKSA6IHQuZWRpdE5leHRDZWxsKCEwKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBzID0gITE7XG4gICAgICB9XG4gICAgICBzICYmIGEucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH07XG59LCBvbkhpZGU6IGZ1bmN0aW9uKCkge1xufSwgZGVzdHJveTogZnVuY3Rpb24oKSB7XG59IH0sIHlhID0geyBpbml0OiBmdW5jdGlvbih0LCBlKSB7XG4gIHZhciBuID0gdCwgaSA9IGUuJGdhbnR0LCBhID0gbnVsbCwgciA9IGkuZXh0LmtleWJvYXJkTmF2aWdhdGlvbjtcbiAgci5hdHRhY2hFdmVudChcIm9uQmVmb3JlRm9jdXNcIiwgZnVuY3Rpb24ocykge1xuICAgIHZhciBvID0gdC5sb2NhdGVDZWxsKHMpO1xuICAgIGlmIChjbGVhclRpbWVvdXQoYSksIG8pIHtcbiAgICAgIHZhciBsID0gby5jb2x1bW5OYW1lLCBkID0gby5pZCwgYyA9IG4uZ2V0U3RhdGUoKTtcbiAgICAgIGlmIChuLmlzVmlzaWJsZSgpICYmIGMuaWQgPT0gZCAmJiBjLmNvbHVtbk5hbWUgPT09IGwpIHJldHVybiAhMTtcbiAgICB9XG4gICAgcmV0dXJuICEwO1xuICB9KSwgci5hdHRhY2hFdmVudChcIm9uRm9jdXNcIiwgZnVuY3Rpb24ocykge1xuICAgIHZhciBvID0gdC5sb2NhdGVDZWxsKHMpLCBsID0gdC5nZXRTdGF0ZSgpO1xuICAgIHJldHVybiBjbGVhclRpbWVvdXQoYSksICFvIHx8IG8uaWQgPT0gbC5pZCAmJiBvLmNvbHVtbk5hbWUgPT0gbC5jb2x1bW5OYW1lIHx8IG4uaXNWaXNpYmxlKCkgJiYgbi5zYXZlKCksICEwO1xuICB9KSwgdC5hdHRhY2hFdmVudChcIm9uSGlkZVwiLCBmdW5jdGlvbigpIHtcbiAgICBjbGVhclRpbWVvdXQoYSk7XG4gIH0pLCByLmF0dGFjaEV2ZW50KFwib25CbHVyXCIsIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBhID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIG4uc2F2ZSgpO1xuICAgIH0pLCAhMDtcbiAgfSksIGkuYXR0YWNoRXZlbnQoXCJvblRhc2tEYmxDbGlja1wiLCBmdW5jdGlvbihzLCBvKSB7XG4gICAgdmFyIGwgPSB0LmdldFN0YXRlKCksIGQgPSB0LmxvY2F0ZUNlbGwoby50YXJnZXQpO1xuICAgIHJldHVybiAhZCB8fCAhdC5pc1Zpc2libGUoKSB8fCBkLmNvbHVtbk5hbWUgIT0gbC5jb2x1bW5OYW1lO1xuICB9KSwgaS5hdHRhY2hFdmVudChcIm9uVGFza0NsaWNrXCIsIGZ1bmN0aW9uKHMsIG8pIHtcbiAgICBpZiAoaS5faXNfaWNvbl9vcGVuX2NsaWNrKG8pKSByZXR1cm4gITA7XG4gICAgdmFyIGwgPSB0LmdldFN0YXRlKCksIGQgPSB0LmxvY2F0ZUNlbGwoby50YXJnZXQpO1xuICAgIHJldHVybiAhZCB8fCAhdC5nZXRFZGl0b3JDb25maWcoZC5jb2x1bW5OYW1lKSB8fCAodC5pc1Zpc2libGUoKSAmJiBsLmlkID09IGQuaWQgJiYgbC5jb2x1bW5OYW1lID09IGQuY29sdW1uTmFtZSB8fCB0LnN0YXJ0RWRpdChkLmlkLCBkLmNvbHVtbk5hbWUpLCAhMSk7XG4gIH0pLCBpLmF0dGFjaEV2ZW50KFwib25FbXB0eUNsaWNrXCIsIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuLnNhdmUoKSwgITA7XG4gIH0pLCByLmF0dGFjaEV2ZW50KFwib25LZXlEb3duXCIsIGZ1bmN0aW9uKHMsIG8pIHtcbiAgICB2YXIgbCA9IHQubG9jYXRlQ2VsbChvLnRhcmdldCksIGQgPSAhIWwgJiYgdC5nZXRFZGl0b3JDb25maWcobC5jb2x1bW5OYW1lKSwgYyA9IHQuZ2V0U3RhdGUoKSwgdSA9IGkuY29uc3RhbnRzLktFWV9DT0RFUywgaCA9IG8ua2V5Q29kZSwgZyA9ICExO1xuICAgIHN3aXRjaCAoaCkge1xuICAgICAgY2FzZSB1LkVOVEVSOlxuICAgICAgICB0LmlzVmlzaWJsZSgpID8gKHQuc2F2ZSgpLCBvLnByZXZlbnREZWZhdWx0KCksIGcgPSAhMCkgOiBkICYmICEoby5jdHJsS2V5IHx8IG8ubWV0YUtleSB8fCBvLnNoaWZ0S2V5KSAmJiAobi5zdGFydEVkaXQobC5pZCwgbC5jb2x1bW5OYW1lKSwgby5wcmV2ZW50RGVmYXVsdCgpLCBnID0gITApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdS5FU0M6XG4gICAgICAgIHQuaXNWaXNpYmxlKCkgJiYgKHQuaGlkZSgpLCBvLnByZXZlbnREZWZhdWx0KCksIGcgPSAhMCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB1LlVQOlxuICAgICAgY2FzZSB1LkRPV046XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB1LkxFRlQ6XG4gICAgICBjYXNlIHUuUklHSFQ6XG4gICAgICAgIChkICYmIHQuaXNWaXNpYmxlKCkgfHwgYy5lZGl0b3JUeXBlID09PSBcImRhdGVcIikgJiYgKGcgPSAhMCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB1LlNQQUNFOlxuICAgICAgICB0LmlzVmlzaWJsZSgpICYmIChnID0gITApLCBkICYmICF0LmlzVmlzaWJsZSgpICYmIChuLnN0YXJ0RWRpdChsLmlkLCBsLmNvbHVtbk5hbWUpLCBvLnByZXZlbnREZWZhdWx0KCksIGcgPSAhMCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB1LkRFTEVURTpcbiAgICAgICAgZCAmJiAhdC5pc1Zpc2libGUoKSA/IChuLnN0YXJ0RWRpdChsLmlkLCBsLmNvbHVtbk5hbWUpLCBnID0gITApIDogZCAmJiB0LmlzVmlzaWJsZSgpICYmIChnID0gITApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdS5UQUI6XG4gICAgICAgIGlmICh0LmlzVmlzaWJsZSgpKSB7XG4gICAgICAgICAgby5zaGlmdEtleSA/IHQuZWRpdFByZXZDZWxsKCEwKSA6IHQuZWRpdE5leHRDZWxsKCEwKTtcbiAgICAgICAgICB2YXIgcCA9IHQuZ2V0U3RhdGUoKTtcbiAgICAgICAgICBwLmlkICYmIHIuZm9jdXMoeyB0eXBlOiBcInRhc2tDZWxsXCIsIGlkOiBwLmlkLCBjb2x1bW46IHAuY29sdW1uTmFtZSB9KSwgby5wcmV2ZW50RGVmYXVsdCgpLCBnID0gITA7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAodC5pc1Zpc2libGUoKSkgZyA9ICEwO1xuICAgICAgICBlbHNlIGlmIChoID49IDQ4ICYmIGggPD0gNTcgfHwgaCA+IDk1ICYmIGggPCAxMTIgfHwgaCA+PSA2NCAmJiBoIDw9IDkxIHx8IGggPiAxODUgJiYgaCA8IDE5MyB8fCBoID4gMjE4ICYmIGggPCAyMjMpIHtcbiAgICAgICAgICB2YXIgeSA9IHMubW9kaWZpZXJzLCB2ID0geS5hbHQgfHwgeS5jdHJsIHx8IHkubWV0YSB8fCB5LnNoaWZ0O1xuICAgICAgICAgIHkuYWx0IHx8IHYgJiYgci5nZXRDb21tYW5kSGFuZGxlcihzLCBcInRhc2tDZWxsXCIpIHx8IGQgJiYgIXQuaXNWaXNpYmxlKCkgJiYgKG4uc3RhcnRFZGl0KGwuaWQsIGwuY29sdW1uTmFtZSksIGcgPSAhMCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICFnO1xuICB9KTtcbn0sIG9uU2hvdzogZnVuY3Rpb24odCwgZSwgbikge1xufSwgb25IaWRlOiBmdW5jdGlvbih0LCBlLCBuKSB7XG4gIGNvbnN0IGkgPSBuLiRnYW50dDtcbiAgaSAmJiBpLmZvY3VzKCk7XG59LCBkZXN0cm95OiBmdW5jdGlvbigpIHtcbn0gfTtcbmZ1bmN0aW9uIFN0KHQpIHtcbiAgdmFyIGUgPSBmdW5jdGlvbigpIHtcbiAgfTtcbiAgcmV0dXJuIGUucHJvdG90eXBlID0geyBzaG93OiBmdW5jdGlvbihuLCBpLCBhLCByKSB7XG4gIH0sIGhpZGU6IGZ1bmN0aW9uKCkge1xuICB9LCBzZXRfdmFsdWU6IGZ1bmN0aW9uKG4sIGksIGEsIHIpIHtcbiAgICB0aGlzLmdldF9pbnB1dChyKS52YWx1ZSA9IG47XG4gIH0sIGdldF92YWx1ZTogZnVuY3Rpb24obiwgaSwgYSkge1xuICAgIHJldHVybiB0aGlzLmdldF9pbnB1dChhKS52YWx1ZSB8fCBcIlwiO1xuICB9LCBpc19jaGFuZ2VkOiBmdW5jdGlvbihuLCBpLCBhLCByKSB7XG4gICAgdmFyIHMgPSB0aGlzLmdldF92YWx1ZShpLCBhLCByKTtcbiAgICByZXR1cm4gcyAmJiBuICYmIHMudmFsdWVPZiAmJiBuLnZhbHVlT2YgPyBzLnZhbHVlT2YoKSAhPSBuLnZhbHVlT2YoKSA6IHMgIT0gbjtcbiAgfSwgaXNfdmFsaWQ6IGZ1bmN0aW9uKG4sIGksIGEsIHIpIHtcbiAgICByZXR1cm4gITA7XG4gIH0sIHNhdmU6IGZ1bmN0aW9uKG4sIGksIGEpIHtcbiAgfSwgZ2V0X2lucHV0OiBmdW5jdGlvbihuKSB7XG4gICAgcmV0dXJuIG4ucXVlcnlTZWxlY3RvcihcImlucHV0XCIpO1xuICB9LCBmb2N1czogZnVuY3Rpb24obikge1xuICAgIHZhciBpID0gdGhpcy5nZXRfaW5wdXQobik7XG4gICAgaSAmJiAoaS5mb2N1cyAmJiBpLmZvY3VzKCksIGkuc2VsZWN0ICYmIGkuc2VsZWN0KCkpO1xuICB9IH0sIGU7XG59XG5mdW5jdGlvbiBiYSh0KSB7XG4gIHZhciBlID0gU3QoKTtcbiAgZnVuY3Rpb24gbigpIHtcbiAgICByZXR1cm4gZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cbiAgcmV0dXJuIHoobiwgZSksIFAobi5wcm90b3R5cGUsIHsgc2hvdzogZnVuY3Rpb24oaSwgYSwgciwgcykge1xuICAgIHZhciBvID0gYDxkaXYgcm9sZT0nY2VsbCc+PGlucHV0IHR5cGU9J3RleHQnIG5hbWU9JyR7YS5uYW1lfScgdGl0bGU9JyR7YS5uYW1lfSc+PC9kaXY+YDtcbiAgICBzLmlubmVySFRNTCA9IG87XG4gIH0gfSwgITApLCBuO1xufVxuZnVuY3Rpb24geGEodCkge1xuICB2YXIgZSA9IFN0KCk7XG4gIGZ1bmN0aW9uIG4oKSB7XG4gICAgcmV0dXJuIGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG4gIHJldHVybiB6KG4sIGUpLCBQKG4ucHJvdG90eXBlLCB7IHNob3c6IGZ1bmN0aW9uKGksIGEsIHIsIHMpIHtcbiAgICB2YXIgbyA9IHIubWluIHx8IDAsIGwgPSByLm1heCB8fCAxMDAsIGQgPSBgPGRpdiByb2xlPSdjZWxsJz48aW5wdXQgdHlwZT0nbnVtYmVyJyBtaW49JyR7b30nIG1heD0nJHtsfScgbmFtZT0nJHthLm5hbWV9JyB0aXRsZT0nJHthLm5hbWV9Jz48L2Rpdj5gO1xuICAgIHMuaW5uZXJIVE1MID0gZCwgcy5vbmlucHV0ID0gZnVuY3Rpb24oYykge1xuICAgICAgK2MudGFyZ2V0LnZhbHVlIDwgbyAmJiAoYy50YXJnZXQudmFsdWUgPSBvKSwgK2MudGFyZ2V0LnZhbHVlID4gbCAmJiAoYy50YXJnZXQudmFsdWUgPSBsKTtcbiAgICB9O1xuICB9LCBnZXRfdmFsdWU6IGZ1bmN0aW9uKGksIGEsIHIpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRfaW5wdXQocikudmFsdWUgfHwgXCJcIjtcbiAgfSwgaXNfdmFsaWQ6IGZ1bmN0aW9uKGksIGEsIHIsIHMpIHtcbiAgICByZXR1cm4gIWlzTmFOKHBhcnNlSW50KGksIDEwKSk7XG4gIH0gfSwgITApLCBuO1xufVxuZnVuY3Rpb24gJGEodCkge1xuICB2YXIgZSA9IFN0KCk7XG4gIGZ1bmN0aW9uIG4oKSB7XG4gICAgcmV0dXJuIGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG4gIHJldHVybiB6KG4sIGUpLCBQKG4ucHJvdG90eXBlLCB7IHNob3c6IGZ1bmN0aW9uKGksIGEsIHIsIHMpIHtcbiAgICBmb3IgKHZhciBvID0gYDxkaXYgcm9sZT0nY2VsbCc+PHNlbGVjdCBuYW1lPScke2EubmFtZX0nIHRpdGxlPScke2EubmFtZX0nPmAsIGwgPSBbXSwgZCA9IHIub3B0aW9ucyB8fCBbXSwgYyA9IDA7IGMgPCBkLmxlbmd0aDsgYysrKSBsLnB1c2goXCI8b3B0aW9uIHZhbHVlPSdcIiArIHIub3B0aW9uc1tjXS5rZXkgKyBcIic+XCIgKyBkW2NdLmxhYmVsICsgXCI8L29wdGlvbj5cIik7XG4gICAgbyArPSBsLmpvaW4oXCJcIikgKyBcIjwvc2VsZWN0PjwvZGl2PlwiLCBzLmlubmVySFRNTCA9IG87XG4gIH0sIGdldF9pbnB1dDogZnVuY3Rpb24oaSkge1xuICAgIHJldHVybiBpLnF1ZXJ5U2VsZWN0b3IoXCJzZWxlY3RcIik7XG4gIH0gfSwgITApLCBuO1xufVxuZnVuY3Rpb24gd2EodCkge1xuICB2YXIgZSA9IFN0KCksIG4gPSBcIiVZLSVtLSVkXCIsIGkgPSBudWxsLCBhID0gbnVsbDtcbiAgZnVuY3Rpb24gcigpIHtcbiAgICByZXR1cm4gZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cbiAgcmV0dXJuIHoociwgZSksIFAoci5wcm90b3R5cGUsIHsgc2hvdzogZnVuY3Rpb24ocywgbywgbCwgZCkge1xuICAgIGkgfHwgKGkgPSB0LmRhdGUuZGF0ZV90b19zdHIobikpLCBhIHx8IChhID0gdC5kYXRlLnN0cl90b19kYXRlKG4pKTtcbiAgICB2YXIgYyA9IG51bGwsIHUgPSBudWxsO1xuICAgIGMgPSB0eXBlb2YgbC5taW4gPT0gXCJmdW5jdGlvblwiID8gbC5taW4ocywgbykgOiBsLm1pbiwgdSA9IHR5cGVvZiBsLm1heCA9PSBcImZ1bmN0aW9uXCIgPyBsLm1heChzLCBvKSA6IGwubWF4O1xuICAgIHZhciBoID0gYDxkaXYgc3R5bGU9J3dpZHRoOjE0MHB4JyByb2xlPSdjZWxsJz48aW5wdXQgdHlwZT0nZGF0ZScgJHtjID8gXCIgbWluPSdcIiArIGkoYykgKyBcIicgXCIgOiBcIlwifSAke3UgPyBcIiBtYXg9J1wiICsgaSh1KSArIFwiJyBcIiA6IFwiXCJ9IG5hbWU9JyR7by5uYW1lfScgdGl0bGU9JyR7by5uYW1lfSc+PC9kaXY+YDtcbiAgICBkLmlubmVySFRNTCA9IGgsIGQub25pbnB1dCA9IGZ1bmN0aW9uKGcpIHtcbiAgICAgIGcudGFyZ2V0LnZhbHVlICYmIChjIHx8IHUpICYmICgrdC5kYXRlLnN0cl90b19kYXRlKFwiJVktJW0tJWRcIikoZy50YXJnZXQudmFsdWUpIDwgK2MgJiYgKGcudGFyZ2V0LnZhbHVlID0gdC5kYXRlLmRhdGVfdG9fc3RyKFwiJVktJW0tJWRcIikoYykpLCArdC5kYXRlLnN0cl90b19kYXRlKFwiJVktJW0tJWRcIikoZy50YXJnZXQudmFsdWUpID4gK3UgJiYgKGcudGFyZ2V0LnZhbHVlID0gdC5kYXRlLmRhdGVfdG9fc3RyKFwiJVktJW0tJWRcIikodSkpKTtcbiAgICB9O1xuICB9LCBzZXRfdmFsdWU6IGZ1bmN0aW9uKHMsIG8sIGwsIGQpIHtcbiAgICBzICYmIHMuZ2V0RnVsbFllYXIgPyB0aGlzLmdldF9pbnB1dChkKS52YWx1ZSA9IGkocykgOiB0aGlzLmdldF9pbnB1dChkKS52YWx1ZSA9IHM7XG4gIH0sIGlzX3ZhbGlkOiBmdW5jdGlvbihzLCBvLCBsLCBkKSB7XG4gICAgcmV0dXJuICEoIXMgfHwgaXNOYU4ocy5nZXRUaW1lKCkpKTtcbiAgfSwgZ2V0X3ZhbHVlOiBmdW5jdGlvbihzLCBvLCBsKSB7XG4gICAgdmFyIGQ7XG4gICAgdHJ5IHtcbiAgICAgIGQgPSBhKHRoaXMuZ2V0X2lucHV0KGwpLnZhbHVlIHx8IFwiXCIpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgZCA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBkO1xuICB9IH0sICEwKSwgcjtcbn1cbmZ1bmN0aW9uIFNhKHQpIHtcbiAgdmFyIGUgPSBTdCgpO1xuICBmdW5jdGlvbiBuKCkge1xuICAgIHJldHVybiBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuICBmdW5jdGlvbiBpKGwpIHtcbiAgICByZXR1cm4gbC5mb3JtYXR0ZXIgfHwgdC5leHQuZm9ybWF0dGVycy5saW5rRm9ybWF0dGVyKCk7XG4gIH1cbiAgZnVuY3Rpb24gYShsLCBkKSB7XG4gICAgZm9yICh2YXIgYyA9IChsIHx8IFwiXCIpLnNwbGl0KGQuZGVsaW1pdGVyIHx8IFwiLFwiKSwgdSA9IDA7IHUgPCBjLmxlbmd0aDsgdSsrKSB7XG4gICAgICB2YXIgaCA9IGNbdV0udHJpbSgpO1xuICAgICAgaCA/IGNbdV0gPSBoIDogKGMuc3BsaWNlKHUsIDEpLCB1LS0pO1xuICAgIH1cbiAgICByZXR1cm4gYy5zb3J0KCksIGM7XG4gIH1cbiAgZnVuY3Rpb24gcihsLCBkLCBjKSB7XG4gICAgZm9yICh2YXIgdSA9IGwuJHRhcmdldCwgaCA9IFtdLCBnID0gMDsgZyA8IHUubGVuZ3RoOyBnKyspIHtcbiAgICAgIHZhciBwID0gYy5nZXRMaW5rKHVbZ10pO1xuICAgICAgaC5wdXNoKGkoZCkuZm9ybWF0KHApKTtcbiAgICB9XG4gICAgcmV0dXJuIGguam9pbigoZC5kZWxpbWl0ZXIgfHwgXCIsXCIpICsgXCIgXCIpO1xuICB9XG4gIGZ1bmN0aW9uIHMobCkge1xuICAgIHJldHVybiBsLnNvdXJjZSArIFwiX1wiICsgbC50YXJnZXQgKyBcIl9cIiArIGwudHlwZSArIFwiX1wiICsgKGwubGFnIHx8IDApO1xuICB9XG4gIGZ1bmN0aW9uIG8obCwgZCwgYykge1xuICAgIHZhciB1ID0gZnVuY3Rpb24odiwgYiwgXykge1xuICAgICAgdmFyIG0gPSBbXTtcbiAgICAgIHJldHVybiBbLi4ubmV3IFNldChiKV0uZm9yRWFjaChmdW5jdGlvbihmKSB7XG4gICAgICAgIHZhciBrID0gaShfKS5wYXJzZShmKTtcbiAgICAgICAgayAmJiAoay50YXJnZXQgPSB2LCBrLmlkID0gXCJwcmVkZWNlc3Nvcl9nZW5lcmF0ZWRcIiwgdC5pc0xpbmtBbGxvd2VkKGspICYmIChrLmlkID0gdm9pZCAwLCBtLnB1c2goaykpKTtcbiAgICAgIH0pLCBtO1xuICAgIH0obC5pZCwgZCwgYyksIGggPSB7fTtcbiAgICBsLiR0YXJnZXQuZm9yRWFjaChmdW5jdGlvbih2KSB7XG4gICAgICB2YXIgYiA9IHQuZ2V0TGluayh2KTtcbiAgICAgIGhbcyhiKV0gPSBiLmlkO1xuICAgIH0pO1xuICAgIHZhciBnID0gW107XG4gICAgdS5mb3JFYWNoKGZ1bmN0aW9uKHYpIHtcbiAgICAgIHZhciBiID0gcyh2KTtcbiAgICAgIGhbYl0gPyBkZWxldGUgaFtiXSA6IGcucHVzaCh2KTtcbiAgICB9KTtcbiAgICB2YXIgcCA9IFtdO1xuICAgIGZvciAodmFyIHkgaW4gaCkgcC5wdXNoKGhbeV0pO1xuICAgIHJldHVybiB7IGFkZDogZywgcmVtb3ZlOiBwIH07XG4gIH1cbiAgcmV0dXJuIHoobiwgZSksIFAobi5wcm90b3R5cGUsIHsgc2hvdzogZnVuY3Rpb24obCwgZCwgYywgdSkge1xuICAgIHZhciBoID0gYDxkaXYgcm9sZT0nY2VsbCc+PGlucHV0IHR5cGU9J3RleHQnIG5hbWU9JyR7ZC5uYW1lfScgdGl0bGU9JyR7ZC5uYW1lfSc+PC9kaXY+YDtcbiAgICB1LmlubmVySFRNTCA9IGg7XG4gIH0sIGhpZGU6IGZ1bmN0aW9uKCkge1xuICB9LCBzZXRfdmFsdWU6IGZ1bmN0aW9uKGwsIGQsIGMsIHUpIHtcbiAgICB0aGlzLmdldF9pbnB1dCh1KS52YWx1ZSA9IHIobCwgYy5lZGl0b3IsIHQpO1xuICB9LCBnZXRfdmFsdWU6IGZ1bmN0aW9uKGwsIGQsIGMpIHtcbiAgICByZXR1cm4gYSh0aGlzLmdldF9pbnB1dChjKS52YWx1ZSB8fCBcIlwiLCBkLmVkaXRvcik7XG4gIH0sIHNhdmU6IGZ1bmN0aW9uKGwsIGQsIGMpIHtcbiAgICB2YXIgdSA9IG8odC5nZXRUYXNrKGwpLCB0aGlzLmdldF92YWx1ZShsLCBkLCBjKSwgZC5lZGl0b3IpO1xuICAgICh1LmFkZC5sZW5ndGggfHwgdS5yZW1vdmUubGVuZ3RoKSAmJiB0LmJhdGNoVXBkYXRlKGZ1bmN0aW9uKCkge1xuICAgICAgdS5hZGQuZm9yRWFjaChmdW5jdGlvbihoKSB7XG4gICAgICAgIHQuYWRkTGluayhoKTtcbiAgICAgIH0pLCB1LnJlbW92ZS5mb3JFYWNoKGZ1bmN0aW9uKGgpIHtcbiAgICAgICAgdC5kZWxldGVMaW5rKGgpO1xuICAgICAgfSksIHQuYXV0b1NjaGVkdWxlICYmIHQuYXV0b1NjaGVkdWxlKCk7XG4gICAgfSk7XG4gIH0sIGlzX2NoYW5nZWQ6IGZ1bmN0aW9uKGwsIGQsIGMsIHUpIHtcbiAgICB2YXIgaCA9IHRoaXMuZ2V0X3ZhbHVlKGQsIGMsIHUpLCBnID0gYShyKGwsIGMuZWRpdG9yLCB0KSwgYy5lZGl0b3IpO1xuICAgIHJldHVybiBoLmpvaW4oKSAhPT0gZy5qb2luKCk7XG4gIH0gfSwgITApLCBuO1xufVxuZnVuY3Rpb24gVGEodCkge1xuICB2YXIgZSA9IFN0KCk7XG4gIGZ1bmN0aW9uIG4oKSB7XG4gICAgcmV0dXJuIGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG4gIGZ1bmN0aW9uIGkoYSkge1xuICAgIHJldHVybiBhLmZvcm1hdHRlciB8fCB0LmV4dC5mb3JtYXR0ZXJzLmR1cmF0aW9uRm9ybWF0dGVyKCk7XG4gIH1cbiAgcmV0dXJuIHoobiwgZSksIFAobi5wcm90b3R5cGUsIHsgc2hvdzogZnVuY3Rpb24oYSwgciwgcywgbykge1xuICAgIHZhciBsID0gYDxkaXYgcm9sZT0nY2VsbCc+PGlucHV0IHR5cGU9J3RleHQnIG5hbWU9JyR7ci5uYW1lfScgdGl0bGU9JyR7ci5uYW1lfSc+PC9kaXY+YDtcbiAgICBvLmlubmVySFRNTCA9IGw7XG4gIH0sIHNldF92YWx1ZTogZnVuY3Rpb24oYSwgciwgcywgbykge1xuICAgIHRoaXMuZ2V0X2lucHV0KG8pLnZhbHVlID0gaShzLmVkaXRvcikuZm9ybWF0KGEpO1xuICB9LCBnZXRfdmFsdWU6IGZ1bmN0aW9uKGEsIHIsIHMpIHtcbiAgICByZXR1cm4gaShyLmVkaXRvcikucGFyc2UodGhpcy5nZXRfaW5wdXQocykudmFsdWUgfHwgXCJcIik7XG4gIH0gfSwgITApLCBuO1xufVxuZnVuY3Rpb24gRWEodCkge1xuICByZXR1cm4gZnVuY3Rpb24obiwgaSwgYSkge1xuICAgIGEgPT0gXCJrZWVwRGF0ZXNcIiA/IGZ1bmN0aW9uKHIsIHMpIHtcbiAgICAgIHMgPT0gXCJkdXJhdGlvblwiID8gci5lbmRfZGF0ZSA9IHQuY2FsY3VsYXRlRW5kRGF0ZShyKSA6IHMgIT0gXCJlbmRfZGF0ZVwiICYmIHMgIT0gXCJzdGFydF9kYXRlXCIgfHwgKHIuZHVyYXRpb24gPSB0LmNhbGN1bGF0ZUR1cmF0aW9uKHIpKTtcbiAgICB9KG4sIGkpIDogYSA9PSBcImtlZXBEdXJhdGlvblwiID8gZnVuY3Rpb24ociwgcykge1xuICAgICAgcyA9PSBcImVuZF9kYXRlXCIgPyByLnN0YXJ0X2RhdGUgPSBlKHIpIDogcyAhPSBcInN0YXJ0X2RhdGVcIiAmJiBzICE9IFwiZHVyYXRpb25cIiB8fCAoci5lbmRfZGF0ZSA9IHQuY2FsY3VsYXRlRW5kRGF0ZShyKSk7XG4gICAgfShuLCBpKSA6IGZ1bmN0aW9uKHIsIHMpIHtcbiAgICAgIHQuY29uZmlnLnNjaGVkdWxlX2Zyb21fZW5kID8gcyA9PSBcImVuZF9kYXRlXCIgfHwgcyA9PSBcImR1cmF0aW9uXCIgPyByLnN0YXJ0X2RhdGUgPSBlKHIpIDogcyA9PSBcInN0YXJ0X2RhdGVcIiAmJiAoci5kdXJhdGlvbiA9IHQuY2FsY3VsYXRlRHVyYXRpb24ocikpIDogcyA9PSBcInN0YXJ0X2RhdGVcIiB8fCBzID09IFwiZHVyYXRpb25cIiA/IHIuZW5kX2RhdGUgPSB0LmNhbGN1bGF0ZUVuZERhdGUocikgOiBzID09IFwiZW5kX2RhdGVcIiAmJiAoci5kdXJhdGlvbiA9IHQuY2FsY3VsYXRlRHVyYXRpb24ocikpO1xuICAgIH0obiwgaSk7XG4gIH07XG4gIGZ1bmN0aW9uIGUobikge1xuICAgIHJldHVybiB0LmNhbGN1bGF0ZUVuZERhdGUoeyBzdGFydF9kYXRlOiBuLmVuZF9kYXRlLCBkdXJhdGlvbjogLW4uZHVyYXRpb24sIHRhc2s6IG4gfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIENhKHQpIHtcbiAgdC5jb25maWcuZWRpdG9yX3R5cGVzID0geyB0ZXh0OiBuZXcgKGJhKCkpKCksIG51bWJlcjogbmV3ICh4YSgpKSgpLCBzZWxlY3Q6IG5ldyAoJGEoKSkoKSwgZGF0ZTogbmV3ICh3YSh0KSkoKSwgcHJlZGVjZXNzb3I6IG5ldyAoU2EodCkpKCksIGR1cmF0aW9uOiBuZXcgKFRhKHQpKSgpIH07XG59XG5mdW5jdGlvbiBEYSh0KSB7XG4gIHZhciBlID0gLyogQF9fUFVSRV9fICovIGZ1bmN0aW9uKGEpIHtcbiAgICB2YXIgciA9IG51bGw7XG4gICAgcmV0dXJuIHsgc2V0TWFwcGluZzogZnVuY3Rpb24ocykge1xuICAgICAgciA9IHM7XG4gICAgfSwgZ2V0TWFwcGluZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gciB8fCAoYS5jb25maWcua2V5Ym9hcmRfbmF2aWdhdGlvbl9jZWxscyAmJiBhLmV4dC5rZXlib2FyZE5hdmlnYXRpb24gPyB5YSA6IGthKTtcbiAgICB9IH07XG4gIH0odCksIG4gPSB7fTtcbiAgb3Qobik7XG4gIHZhciBpID0geyBpbml0OiBDYSwgY3JlYXRlRWRpdG9yczogZnVuY3Rpb24oYSkge1xuICAgIGZ1bmN0aW9uIHIodSwgaCkge1xuICAgICAgdmFyIGcgPSBhLiRnZXRDb25maWcoKSwgcCA9IGZ1bmN0aW9uKGIsIF8pIHtcbiAgICAgICAgZm9yICh2YXIgbSA9IGEuJGdldENvbmZpZygpLCBmID0gYS5nZXRJdGVtVG9wKGIpLCBrID0gYS5nZXRJdGVtSGVpZ2h0KGIpLCB4ID0gYS5nZXRHcmlkQ29sdW1ucygpLCAkID0gMCwgdyA9IDAsIFMgPSAwLCBUID0gMDsgVCA8IHgubGVuZ3RoOyBUKyspIHtcbiAgICAgICAgICBpZiAoeFtUXS5uYW1lID09IF8pIHtcbiAgICAgICAgICAgIFMgPSB4W1RdLndpZHRoO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIG0ucnRsID8gdyArPSB4W1RdLndpZHRoIDogJCArPSB4W1RdLndpZHRoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtLnJ0bCA/IHsgdG9wOiBmLCByaWdodDogdywgaGVpZ2h0OiBrLCB3aWR0aDogUyB9IDogeyB0b3A6IGYsIGxlZnQ6ICQsIGhlaWdodDogaywgd2lkdGg6IFMgfTtcbiAgICAgIH0odSwgaCksIHkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgeS5jbGFzc05hbWUgPSBcImdhbnR0X2dyaWRfZWRpdG9yX3BsYWNlaG9sZGVyXCIsIHkuc2V0QXR0cmlidXRlKGEuJGNvbmZpZy5pdGVtX2F0dHJpYnV0ZSwgdSksIHkuc2V0QXR0cmlidXRlKGEuJGNvbmZpZy5iaW5kICsgXCJfaWRcIiwgdSksIHkuc2V0QXR0cmlidXRlKFwiZGF0YS1jb2x1bW4tbmFtZVwiLCBoKTtcbiAgICAgIHZhciB2ID0gZnVuY3Rpb24oYiwgXykge1xuICAgICAgICBmb3IgKHZhciBtID0gYi5nZXRHcmlkQ29sdW1ucygpLCBmID0gMDsgZiA8IG0ubGVuZ3RoOyBmKyspIGlmIChtW2ZdLm5hbWUgPT0gXykgcmV0dXJuIGY7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfShhLCBoKTtcbiAgICAgIHJldHVybiB5LnNldEF0dHJpYnV0ZShcImRhdGEtY29sdW1uLWluZGV4XCIsIHYpLCB0Ll93YWlBcmlhLmlubGluZUVkaXRvckF0dHIoeSksIGcucnRsID8geS5zdHlsZS5jc3NUZXh0ID0gW1widG9wOlwiICsgcC50b3AgKyBcInB4XCIsIFwicmlnaHQ6XCIgKyBwLnJpZ2h0ICsgXCJweFwiLCBcIndpZHRoOlwiICsgcC53aWR0aCArIFwicHhcIiwgXCJoZWlnaHQ6XCIgKyBwLmhlaWdodCArIFwicHhcIl0uam9pbihcIjtcIikgOiB5LnN0eWxlLmNzc1RleHQgPSBbXCJ0b3A6XCIgKyBwLnRvcCArIFwicHhcIiwgXCJsZWZ0OlwiICsgcC5sZWZ0ICsgXCJweFwiLCBcIndpZHRoOlwiICsgcC53aWR0aCArIFwicHhcIiwgXCJoZWlnaHQ6XCIgKyBwLmhlaWdodCArIFwicHhcIl0uam9pbihcIjtcIiksIHk7XG4gICAgfVxuICAgIHZhciBzID0gRWEodCksIG8gPSBbXSwgbCA9IFtdLCBkID0gbnVsbCwgYyA9IHsgX2l0ZW1JZDogbnVsbCwgX2NvbHVtbk5hbWU6IG51bGwsIF9lZGl0b3I6IG51bGwsIF9lZGl0b3JUeXBlOiBudWxsLCBfcGxhY2Vob2xkZXI6IG51bGwsIGxvY2F0ZUNlbGw6IGZ1bmN0aW9uKHUpIHtcbiAgICAgIGlmICghWSh1LCBhLiRncmlkKSkgcmV0dXJuIG51bGw7XG4gICAgICB2YXIgaCA9IGV0KHUsIGEuJGNvbmZpZy5pdGVtX2F0dHJpYnV0ZSksIGcgPSBldCh1LCBcImRhdGEtY29sdW1uLW5hbWVcIik7XG4gICAgICBpZiAoaCAmJiBnKSB7XG4gICAgICAgIHZhciBwID0gZy5nZXRBdHRyaWJ1dGUoXCJkYXRhLWNvbHVtbi1uYW1lXCIpO1xuICAgICAgICByZXR1cm4geyBpZDogaC5nZXRBdHRyaWJ1dGUoYS4kY29uZmlnLml0ZW1fYXR0cmlidXRlKSwgY29sdW1uTmFtZTogcCB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSwgZ2V0RWRpdG9yQ29uZmlnOiBmdW5jdGlvbih1KSB7XG4gICAgICByZXR1cm4gYS5nZXRDb2x1bW4odSkuZWRpdG9yO1xuICAgIH0sIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHUgPSBlLmdldE1hcHBpbmcoKTtcbiAgICAgIHUuaW5pdCAmJiB1LmluaXQodGhpcywgYSksIGQgPSBhLiRnYW50dC5nZXREYXRhc3RvcmUoYS4kY29uZmlnLmJpbmQpO1xuICAgICAgdmFyIGggPSB0aGlzO1xuICAgICAgby5wdXNoKGQuYXR0YWNoRXZlbnQoXCJvbklkQ2hhbmdlXCIsIGZ1bmN0aW9uKGcsIHApIHtcbiAgICAgICAgaC5faXRlbUlkID09IGcgJiYgKGguX2l0ZW1JZCA9IHApO1xuICAgICAgfSkpLCBvLnB1c2goZC5hdHRhY2hFdmVudChcIm9uU3RvcmVVcGRhdGVkXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICBhLiRnYW50dC5nZXRTdGF0ZShcImJhdGNoVXBkYXRlXCIpLmJhdGNoX3VwZGF0ZSB8fCBoLmlzVmlzaWJsZSgpICYmICFkLmlzVmlzaWJsZShoLl9pdGVtSWQpICYmIGguaGlkZSgpO1xuICAgICAgfSkpLCBsLnB1c2godC5hdHRhY2hFdmVudChcIm9uRGF0YVJlbmRlclwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgaC5fZWRpdG9yICYmIGguX3BsYWNlaG9sZGVyICYmICFZKGguX3BsYWNlaG9sZGVyLCB0LiRyb290KSAmJiBhLiRncmlkX2RhdGEuYXBwZW5kQ2hpbGQoaC5fcGxhY2Vob2xkZXIpO1xuICAgICAgfSkpLCB0aGlzLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgICAgIH07XG4gICAgfSwgZ2V0U3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHsgZWRpdG9yOiB0aGlzLl9lZGl0b3IsIGVkaXRvclR5cGU6IHRoaXMuX2VkaXRvclR5cGUsIHBsYWNlaG9sZGVyOiB0aGlzLl9wbGFjZWhvbGRlciwgaWQ6IHRoaXMuX2l0ZW1JZCwgY29sdW1uTmFtZTogdGhpcy5fY29sdW1uTmFtZSB9O1xuICAgIH0sIHN0YXJ0RWRpdDogZnVuY3Rpb24odSwgaCkge1xuICAgICAgaWYgKHRoaXMuaXNWaXNpYmxlKCkgJiYgdGhpcy5zYXZlKCksICFkLmV4aXN0cyh1KSkgcmV0dXJuO1xuICAgICAgdmFyIGcgPSB7IGlkOiB1LCBjb2x1bW5OYW1lOiBoIH07XG4gICAgICBpZiAodC5pc1JlYWRvbmx5KGQuZ2V0SXRlbSh1KSkpIHJldHVybiB2b2lkIHRoaXMuY2FsbEV2ZW50KFwib25FZGl0UHJldmVudFwiLCBbZ10pO1xuICAgICAgaWYgKHRoaXMuY2FsbEV2ZW50KFwib25CZWZvcmVFZGl0U3RhcnRcIiwgW2ddKSA9PT0gITEpIHJldHVybiB2b2lkIHRoaXMuY2FsbEV2ZW50KFwib25FZGl0UHJldmVudFwiLCBbZ10pO1xuICAgICAgY29uc3QgcCA9IHRoaXMuc2hvdyhnLmlkLCBnLmNvbHVtbk5hbWUpO1xuICAgICAgcCAmJiBwLnRoZW4gPyBwLnRoZW4oKGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnNldFZhbHVlKCksIHRoaXMuY2FsbEV2ZW50KFwib25FZGl0U3RhcnRcIiwgW2ddKTtcbiAgICAgIH0pLmJpbmQodGhpcykpIDogKHRoaXMuc2V0VmFsdWUoKSwgdGhpcy5jYWxsRXZlbnQoXCJvbkVkaXRTdGFydFwiLCBbZ10pKTtcbiAgICB9LCBpc1Zpc2libGU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICEoIXRoaXMuX2VkaXRvciB8fCAhWSh0aGlzLl9wbGFjZWhvbGRlciwgdC4kcm9vdCkpO1xuICAgIH0sIHNob3c6IGZ1bmN0aW9uKHUsIGgpIHtcbiAgICAgIHRoaXMuaXNWaXNpYmxlKCkgJiYgdGhpcy5zYXZlKCk7XG4gICAgICB2YXIgZyA9IHsgaWQ6IHUsIGNvbHVtbk5hbWU6IGggfSwgcCA9IGEuZ2V0Q29sdW1uKGcuY29sdW1uTmFtZSksIHkgPSB0aGlzLmdldEVkaXRvckNvbmZpZyhwLm5hbWUpO1xuICAgICAgaWYgKCF5KSByZXR1cm47XG4gICAgICB2YXIgdiA9IGEuJGdldENvbmZpZygpLmVkaXRvcl90eXBlc1t5LnR5cGVdLCBiID0gcihnLmlkLCBnLmNvbHVtbk5hbWUpO1xuICAgICAgYS4kZ3JpZF9kYXRhLmFwcGVuZENoaWxkKGIpO1xuICAgICAgY29uc3QgXyA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fZWRpdG9yID0gdiwgdGhpcy5fcGxhY2Vob2xkZXIgPSBiLCB0aGlzLl9pdGVtSWQgPSBnLmlkLCB0aGlzLl9jb2x1bW5OYW1lID0gZy5jb2x1bW5OYW1lLCB0aGlzLl9lZGl0b3JUeXBlID0geS50eXBlO1xuICAgICAgICB2YXIgZiA9IGUuZ2V0TWFwcGluZygpO1xuICAgICAgICBmLm9uU2hvdyAmJiBmLm9uU2hvdyh0aGlzLCBiLCBhKSwgYi5fb25SZU1vdW50ID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRoaXMuc2V0VmFsdWUoKTtcbiAgICAgICAgfSkuYmluZCh0aGlzKTtcbiAgICAgIH0pLmJpbmQodGhpcyksIG0gPSB2LnNob3coZy5pZCwgcCwgeSwgYik7XG4gICAgICBpZiAobSAmJiBtLnRoZW4pIHJldHVybiBtLnRoZW4oKCkgPT4ge1xuICAgICAgICBfKCk7XG4gICAgICB9KTtcbiAgICAgIF8oKTtcbiAgICB9LCBzZXRWYWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdSA9IHRoaXMuZ2V0U3RhdGUoKSwgaCA9IHUuaWQsIGcgPSB1LmNvbHVtbk5hbWUsIHAgPSBhLmdldENvbHVtbihnKSwgeSA9IGQuZ2V0SXRlbShoKSwgdiA9IHRoaXMuZ2V0RWRpdG9yQ29uZmlnKGcpO1xuICAgICAgaWYgKHYpIHtcbiAgICAgICAgdmFyIGIgPSB5W3YubWFwX3RvXTtcbiAgICAgICAgdi5tYXBfdG8gPT0gXCJhdXRvXCIgJiYgKGIgPSBkLmdldEl0ZW0oaCkpLCB0aGlzLl9lZGl0b3Iuc2V0X3ZhbHVlKGIsIGgsIHAsIHRoaXMuX3BsYWNlaG9sZGVyKSwgdGhpcy5mb2N1cygpO1xuICAgICAgfVxuICAgIH0sIGZvY3VzOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX2VkaXRvci5mb2N1cyh0aGlzLl9wbGFjZWhvbGRlcik7XG4gICAgfSwgZ2V0VmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHUgPSBhLmdldENvbHVtbih0aGlzLl9jb2x1bW5OYW1lKTtcbiAgICAgIHJldHVybiB0aGlzLl9lZGl0b3IuZ2V0X3ZhbHVlKHRoaXMuX2l0ZW1JZCwgdSwgdGhpcy5fcGxhY2Vob2xkZXIpO1xuICAgIH0sIF9nZXRJdGVtVmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHUgPSB0aGlzLmdldEVkaXRvckNvbmZpZyh0aGlzLl9jb2x1bW5OYW1lKTtcbiAgICAgIGlmICh1KSB7XG4gICAgICAgIHZhciBoID0gdC5nZXRUYXNrKHRoaXMuX2l0ZW1JZClbdS5tYXBfdG9dO1xuICAgICAgICByZXR1cm4gdS5tYXBfdG8gPT0gXCJhdXRvXCIgJiYgKGggPSBkLmdldEl0ZW0odGhpcy5faXRlbUlkKSksIGg7XG4gICAgICB9XG4gICAgfSwgaXNDaGFuZ2VkOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB1ID0gYS5nZXRDb2x1bW4odGhpcy5fY29sdW1uTmFtZSksIGggPSB0aGlzLl9nZXRJdGVtVmFsdWUoKTtcbiAgICAgIHJldHVybiB0aGlzLl9lZGl0b3IuaXNfY2hhbmdlZChoLCB0aGlzLl9pdGVtSWQsIHUsIHRoaXMuX3BsYWNlaG9sZGVyKTtcbiAgICB9LCBoaWRlOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLl9pdGVtSWQpIHtcbiAgICAgICAgdmFyIHUgPSB0aGlzLl9pdGVtSWQsIGggPSB0aGlzLl9jb2x1bW5OYW1lLCBnID0gZS5nZXRNYXBwaW5nKCk7XG4gICAgICAgIGcub25IaWRlICYmIGcub25IaWRlKHRoaXMsIHRoaXMuX3BsYWNlaG9sZGVyLCBhKSwgdGhpcy5faXRlbUlkID0gbnVsbCwgdGhpcy5fY29sdW1uTmFtZSA9IG51bGwsIHRoaXMuX2VkaXRvclR5cGUgPSBudWxsLCB0aGlzLl9wbGFjZWhvbGRlciAmJiAodGhpcy5fZWRpdG9yICYmIHRoaXMuX2VkaXRvci5oaWRlICYmIHRoaXMuX2VkaXRvci5oaWRlKHRoaXMuX3BsYWNlaG9sZGVyKSwgdGhpcy5fZWRpdG9yID0gbnVsbCwgdGhpcy5fcGxhY2Vob2xkZXIucGFyZW50Tm9kZSAmJiB0aGlzLl9wbGFjZWhvbGRlci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuX3BsYWNlaG9sZGVyKSwgdGhpcy5fcGxhY2Vob2xkZXIgPSBudWxsLCB0aGlzLmNhbGxFdmVudChcIm9uRWRpdEVuZFwiLCBbeyBpZDogdSwgY29sdW1uTmFtZTogaCB9XSkpO1xuICAgICAgfVxuICAgIH0sIHNhdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuaXNWaXNpYmxlKCkgJiYgZC5leGlzdHModGhpcy5faXRlbUlkKSAmJiB0aGlzLmlzQ2hhbmdlZCgpKSB7XG4gICAgICAgIHZhciB1ID0gdGhpcy5faXRlbUlkLCBoID0gdGhpcy5fY29sdW1uTmFtZTtcbiAgICAgICAgaWYgKGQuZXhpc3RzKHUpKSB7XG4gICAgICAgICAgdmFyIGcgPSBkLmdldEl0ZW0odSksIHAgPSB0aGlzLmdldEVkaXRvckNvbmZpZyhoKSwgeSA9IHsgaWQ6IHUsIGNvbHVtbk5hbWU6IGgsIG5ld1ZhbHVlOiB0aGlzLmdldFZhbHVlKCksIG9sZFZhbHVlOiB0aGlzLl9nZXRJdGVtVmFsdWUoKSB9O1xuICAgICAgICAgIGlmICh0aGlzLmNhbGxFdmVudChcIm9uQmVmb3JlU2F2ZVwiLCBbeV0pICE9PSAhMSAmJiAoIXRoaXMuX2VkaXRvci5pc192YWxpZCB8fCB0aGlzLl9lZGl0b3IuaXNfdmFsaWQoeS5uZXdWYWx1ZSwgeS5pZCwgYS5nZXRDb2x1bW4oaCksIHRoaXMuX3BsYWNlaG9sZGVyKSkpIHtcbiAgICAgICAgICAgIHZhciB2ID0gcC5tYXBfdG8sIGIgPSB5Lm5ld1ZhbHVlO1xuICAgICAgICAgICAgdiAhPSBcImF1dG9cIiA/IChnW3ZdID0gYiwgcyhnLCB2LCB0LmNvbmZpZy5pbmxpbmVfZWRpdG9yc19kYXRlX3Byb2Nlc3NpbmcpLCBkLnVwZGF0ZUl0ZW0odSkpIDogdGhpcy5fZWRpdG9yLnNhdmUodSwgYS5nZXRDb2x1bW4oaCksIHRoaXMuX3BsYWNlaG9sZGVyKSwgdGhpcy5jYWxsRXZlbnQoXCJvblNhdmVcIiwgW3ldKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB0aGlzLmhpZGUoKTtcbiAgICB9LCBfZmluZEVkaXRhYmxlQ2VsbDogZnVuY3Rpb24odSwgaCkge1xuICAgICAgdmFyIGcgPSB1LCBwID0gYS5nZXRHcmlkQ29sdW1ucygpW2ddLCB5ID0gcCA/IHAubmFtZSA6IG51bGw7XG4gICAgICBpZiAoeSkge1xuICAgICAgICBmb3IgKDsgeSAmJiAhdGhpcy5nZXRFZGl0b3JDb25maWcoeSk7ICkgeSA9IHRoaXMuX2ZpbmRFZGl0YWJsZUNlbGwodSArIGgsIGgpO1xuICAgICAgICByZXR1cm4geTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sIGdldE5leHRDZWxsOiBmdW5jdGlvbih1KSB7XG4gICAgICByZXR1cm4gdGhpcy5fZmluZEVkaXRhYmxlQ2VsbChhLmdldENvbHVtbkluZGV4KHRoaXMuX2NvbHVtbk5hbWUsICEwKSArIHUsIHUpO1xuICAgIH0sIGdldEZpcnN0Q2VsbDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZmluZEVkaXRhYmxlQ2VsbCgwLCAxKTtcbiAgICB9LCBnZXRMYXN0Q2VsbDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZmluZEVkaXRhYmxlQ2VsbChhLmdldEdyaWRDb2x1bW5zKCkubGVuZ3RoIC0gMSwgLTEpO1xuICAgIH0sIGVkaXROZXh0Q2VsbDogZnVuY3Rpb24odSkge1xuICAgICAgdmFyIGggPSB0aGlzLmdldE5leHRDZWxsKDEpO1xuICAgICAgaWYgKGgpIHtcbiAgICAgICAgdmFyIGcgPSB0aGlzLmdldE5leHRDZWxsKDEpO1xuICAgICAgICBnICYmIHRoaXMuZ2V0RWRpdG9yQ29uZmlnKGcpICYmIHRoaXMuc3RhcnRFZGl0KHRoaXMuX2l0ZW1JZCwgZyk7XG4gICAgICB9IGVsc2UgaWYgKHUgJiYgdGhpcy5tb3ZlUm93KDEpKSB7XG4gICAgICAgIHZhciBwID0gdGhpcy5tb3ZlUm93KDEpO1xuICAgICAgICAoaCA9IHRoaXMuZ2V0Rmlyc3RDZWxsKCkpICYmIHRoaXMuZ2V0RWRpdG9yQ29uZmlnKGgpICYmIHRoaXMuc3RhcnRFZGl0KHAsIGgpO1xuICAgICAgfVxuICAgIH0sIGVkaXRQcmV2Q2VsbDogZnVuY3Rpb24odSkge1xuICAgICAgdmFyIGggPSB0aGlzLmdldE5leHRDZWxsKC0xKTtcbiAgICAgIGlmIChoKSB7XG4gICAgICAgIHZhciBnID0gdGhpcy5nZXROZXh0Q2VsbCgtMSk7XG4gICAgICAgIGcgJiYgdGhpcy5nZXRFZGl0b3JDb25maWcoZykgJiYgdGhpcy5zdGFydEVkaXQodGhpcy5faXRlbUlkLCBnKTtcbiAgICAgIH0gZWxzZSBpZiAodSAmJiB0aGlzLm1vdmVSb3coLTEpKSB7XG4gICAgICAgIHZhciBwID0gdGhpcy5tb3ZlUm93KC0xKTtcbiAgICAgICAgKGggPSB0aGlzLmdldExhc3RDZWxsKCkpICYmIHRoaXMuZ2V0RWRpdG9yQ29uZmlnKGgpICYmIHRoaXMuc3RhcnRFZGl0KHAsIGgpO1xuICAgICAgfVxuICAgIH0sIG1vdmVSb3c6IGZ1bmN0aW9uKHUpIHtcbiAgICAgIGZvciAodmFyIGggPSB1ID4gMCA/IHQuZ2V0TmV4dCA6IHQuZ2V0UHJldiwgZyA9IChoID0gdC5iaW5kKGgsIHQpKSh0aGlzLl9pdGVtSWQpOyB0LmlzVGFza0V4aXN0cyhnKSAmJiB0LmlzUmVhZG9ubHkodC5nZXRUYXNrKGcpKTsgKSBnID0gaChnKTtcbiAgICAgIHJldHVybiBnO1xuICAgIH0sIGVkaXROZXh0Um93OiBmdW5jdGlvbih1KSB7XG4gICAgICB2YXIgaCA9IHRoaXMuZ2V0U3RhdGUoKS5pZDtcbiAgICAgIGlmICh0LmlzVGFza0V4aXN0cyhoKSkge1xuICAgICAgICB2YXIgZyA9IG51bGw7XG4gICAgICAgIGcgPSB1ID8gdGhpcy5tb3ZlUm93KDEpIDogdC5nZXROZXh0KGgpLCB0LmlzVGFza0V4aXN0cyhnKSAmJiB0aGlzLnN0YXJ0RWRpdChnLCB0aGlzLl9jb2x1bW5OYW1lKTtcbiAgICAgIH1cbiAgICB9LCBlZGl0UHJldlJvdzogZnVuY3Rpb24odSkge1xuICAgICAgdmFyIGggPSB0aGlzLmdldFN0YXRlKCkuaWQ7XG4gICAgICBpZiAodC5pc1Rhc2tFeGlzdHMoaCkpIHtcbiAgICAgICAgdmFyIGcgPSBudWxsO1xuICAgICAgICBnID0gdSA/IHRoaXMubW92ZVJvdygtMSkgOiB0LmdldFByZXYoaCksIHQuaXNUYXNrRXhpc3RzKGcpICYmIHRoaXMuc3RhcnRFZGl0KGcsIHRoaXMuX2NvbHVtbk5hbWUpO1xuICAgICAgfVxuICAgIH0sIGRldGFjaFN0b3JlOiBmdW5jdGlvbigpIHtcbiAgICAgIG8uZm9yRWFjaChmdW5jdGlvbih1KSB7XG4gICAgICAgIGQuZGV0YWNoRXZlbnQodSk7XG4gICAgICB9KSwgbC5mb3JFYWNoKGZ1bmN0aW9uKHUpIHtcbiAgICAgICAgdC5kZXRhY2hFdmVudCh1KTtcbiAgICAgIH0pLCBvID0gW10sIGwgPSBbXSwgZCA9IG51bGwsIHRoaXMuaGlkZSgpO1xuICAgIH0sIGRlc3RydWN0b3I6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5kZXRhY2hTdG9yZSgpLCB0aGlzLmRldGFjaEFsbEV2ZW50cygpO1xuICAgIH0gfTtcbiAgICByZXR1cm4gUChjLCBlKSwgUChjLCBuKSwgYztcbiAgfSB9O1xuICByZXR1cm4gUChpLCBlKSwgUChpLCBuKSwgaTtcbn1cbmZ1bmN0aW9uICRlKHQsIGUsIG4sIGksIGEpIHtcbiAgaWYgKCF0LnN0YXJ0X2RhdGUgfHwgIXQuZW5kX2RhdGUpIHJldHVybiBudWxsO1xuICB2YXIgciA9IG4uZ2V0SXRlbVRvcCh0LmlkKSwgcyA9IG4uZ2V0SXRlbUhlaWdodCh0LmlkKTtcbiAgaWYgKHIgPiBlLnlfZW5kIHx8IHIgKyBzIDwgZS55KSByZXR1cm4gITE7XG4gIHZhciBvID0gbi5wb3NGcm9tRGF0ZSh0LnN0YXJ0X2RhdGUpLCBsID0gbi5wb3NGcm9tRGF0ZSh0LmVuZF9kYXRlKSwgZCA9IE1hdGgubWluKG8sIGwpIC0gMjAwLCBjID0gTWF0aC5tYXgobywgbCkgKyAyMDA7XG4gIHJldHVybiAhKGQgPiBlLnhfZW5kIHx8IGMgPCBlLngpO1xufVxuZnVuY3Rpb24gYm4odCkge1xuICBmdW5jdGlvbiBlKHIsIHMsIG8pIHtcbiAgICBpZiAodC5faXNBbGxvd2VkVW5zY2hlZHVsZWRUYXNrKHIpIHx8ICF0Ll9pc1Rhc2tJblRpbWVsaW5lTGltaXRzKHIpKSByZXR1cm47XG4gICAgdmFyIGwgPSBzLmdldEl0ZW1Qb3NpdGlvbihyKSwgZCA9IG8sIGMgPSBzLiRnZXRUZW1wbGF0ZXMoKSwgdSA9IHQuZ2V0VGFza1R5cGUoci50eXBlKSwgaCA9IHMuZ2V0QmFySGVpZ2h0KHIuaWQsIHUgPT0gZC50eXBlcy5taWxlc3RvbmUpLCBnID0gMDtcbiAgICB1ID09IGQudHlwZXMubWlsZXN0b25lICYmIChnID0gKGggLSBsLmhlaWdodCkgLyAyKTtcbiAgICB2YXIgcCA9IE1hdGguZmxvb3IoKHMuZ2V0SXRlbUhlaWdodChyLmlkKSAtIGgpIC8gMik7XG4gICAgY29uc3QgeSA9IHQuY29uZmlnLmJhc2VsaW5lcyAmJiByLmJhc2VsaW5lcyAmJiByLmJhc2VsaW5lcy5sZW5ndGgsIHYgPSB0LmNvbmZpZy5iYXNlbGluZXMgJiYgKHQuY29uZmlnLmJhc2VsaW5lcy5yZW5kZXJfbW9kZSA9PSBcInNlcGFyYXRlUm93XCIgfHwgdC5jb25maWcuYmFzZWxpbmVzLnJlbmRlcl9tb2RlID09IFwiaW5kaXZpZHVhbFJvd1wiKTtcbiAgICBpZiAoeSAmJiB2ICYmIHIuYmFyX2hlaWdodCAhPT0gXCJmdWxsXCIgJiYgci5iYXJfaGVpZ2h0IDwgci5yb3dfaGVpZ2h0KSBpZiAodSA9PT0gZC50eXBlcy5taWxlc3RvbmUpIHtcbiAgICAgIGxldCBUID0gcy5nZXRCYXJIZWlnaHQoci5pZCwgITApLCBFID0gTWF0aC5zcXJ0KDIgKiBUICogVCk7XG4gICAgICBwID0gTWF0aC5mbG9vcigoRSAtIGgpIC8gMikgKyAyO1xuICAgIH0gZWxzZSBwID0gMjtcbiAgICB1ID09IGQudHlwZXMubWlsZXN0b25lICYmIChsLmxlZnQgLT0gTWF0aC5yb3VuZChoIC8gMiksIGwud2lkdGggPSBoKTtcbiAgICB2YXIgYiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksIF8gPSBNYXRoLnJvdW5kKGwud2lkdGgpO1xuICAgIHMuJGNvbmZpZy5pdGVtX2F0dHJpYnV0ZSAmJiAoYi5zZXRBdHRyaWJ1dGUocy4kY29uZmlnLml0ZW1fYXR0cmlidXRlLCByLmlkKSwgYi5zZXRBdHRyaWJ1dGUocy4kY29uZmlnLmJpbmQgKyBcIl9pZFwiLCByLmlkKSksIGQuc2hvd19wcm9ncmVzcyAmJiB1ICE9IGQudHlwZXMubWlsZXN0b25lICYmIGZ1bmN0aW9uKFQsIEUsIEMsIEQsIE0pIHtcbiAgICAgIHZhciBJID0gMSAqIFQucHJvZ3Jlc3MgfHwgMDtcbiAgICAgIEMgPSBNYXRoLm1heChDLCAwKTtcbiAgICAgIHZhciBBID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSwgTiA9IE1hdGgucm91bmQoQyAqIEkpO1xuICAgICAgTiA9IE1hdGgubWluKEMsIE4pLCBBLnN0eWxlLndpZHRoID0gTiArIFwicHhcIiwgQS5jbGFzc05hbWUgPSBcImdhbnR0X3Rhc2tfcHJvZ3Jlc3NcIiwgQS5pbm5lckhUTUwgPSBNLnByb2dyZXNzX3RleHQoVC5zdGFydF9kYXRlLCBULmVuZF9kYXRlLCBUKSwgRC5ydGwgJiYgKEEuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCIsIEEuc3R5bGUucmlnaHQgPSBcIjBweFwiKTtcbiAgICAgIHZhciBMID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIEwuY2xhc3NOYW1lID0gXCJnYW50dF90YXNrX3Byb2dyZXNzX3dyYXBwZXJcIiwgTC5hcHBlbmRDaGlsZChBKSwgRS5hcHBlbmRDaGlsZChMKTtcbiAgICAgIGNvbnN0IE8gPSAhdC5pc1JlYWRvbmx5KFQpLCBHID0gdC5leHQuZHJhZ1RpbWVsaW5lICYmIHQuZXh0LmRyYWdUaW1lbGluZS5faXNEcmFnSW5Qcm9ncmVzcygpO1xuICAgICAgaWYgKHQuY29uZmlnLmRyYWdfcHJvZ3Jlc3MgJiYgKE8gfHwgRykpIHtcbiAgICAgICAgdmFyIGogPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLCBIID0gTjtcbiAgICAgICAgRC5ydGwgJiYgKEggPSBDIC0gTiksIGouc3R5bGUubGVmdCA9IEggKyBcInB4XCIsIGouY2xhc3NOYW1lID0gXCJnYW50dF90YXNrX3Byb2dyZXNzX2RyYWdcIiwgai5pbm5lckhUTUwgPSBgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIxMlwiIGhlaWdodD1cIjlcIiB2aWV3Qm94PVwiMCAwIDEyIDlcIiBmaWxsPVwibm9uZVwiPlxuPHBhdGggZD1cIk01LjU4Mzk3IDEuNTI1NDNDNS43ODE4OSAxLjIyODU2IDYuMjE4MTEgMS4yMjg1NiA2LjQxNjAyIDEuNTI1NDNMMTAuNTQ3NSA3LjcyMjY1QzEwLjc2OSA4LjA1NDkzIDEwLjUzMDggOC41IDEwLjEzMTUgOC41TDEuODY4NTIgOC41QzEuNDY5MTcgOC41IDEuMjMwOTcgOC4wNTQ5MyAxLjQ1MjQ5IDcuNzIyNjVMNS41ODM5NyAxLjUyNTQzWlwiIGZpbGw9XCJ2YXIoLS1kaHgtZ2FudHQtcHJvZ3Jlc3MtaGFuZGxlLWJhY2tncm91bmQpXCIgc3Ryb2tlPVwidmFyKC0tZGh4LWdhbnR0LXByb2dyZXNzLWhhbmRsZS1ib3JkZXIpXCIvPlxuPC9zdmc+YCwgQS5hcHBlbmRDaGlsZChqKSwgRS5hcHBlbmRDaGlsZChqKTtcbiAgICAgIH1cbiAgICB9KHIsIGIsIF8sIGQsIGMpO1xuICAgIHZhciBtID0gZnVuY3Rpb24oVCwgRSwgQykge1xuICAgICAgdmFyIEQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgcmV0dXJuIHQuZ2V0VGFza1R5cGUoVC50eXBlKSAhPSB0LmNvbmZpZy50eXBlcy5taWxlc3RvbmUgPyBELmlubmVySFRNTCA9IEMudGFza190ZXh0KFQuc3RhcnRfZGF0ZSwgVC5lbmRfZGF0ZSwgVCkgOiB0LmdldFRhc2tUeXBlKFQudHlwZSkgPT0gdC5jb25maWcudHlwZXMubWlsZXN0b25lICYmIEUgJiYgKEQuc3R5bGUuaGVpZ2h0ID0gRC5zdHlsZS53aWR0aCA9IEUgKyBcInB4XCIpLCBELmNsYXNzTmFtZSA9IFwiZ2FudHRfdGFza19jb250ZW50XCIsIEQ7XG4gICAgfShyLCBfLCBjKTtcbiAgICBiLmFwcGVuZENoaWxkKG0pO1xuICAgIHZhciBmID0gZnVuY3Rpb24oVCwgRSwgQywgRCkge1xuICAgICAgdmFyIE0gPSBELiRnZXRDb25maWcoKSwgSSA9IFtUXTtcbiAgICAgIEUgJiYgSS5wdXNoKEUpO1xuICAgICAgdmFyIEEgPSB0LmdldFN0YXRlKCksIE4gPSB0LmdldFRhc2soQyk7XG4gICAgICBpZiAodC5nZXRUYXNrVHlwZShOLnR5cGUpID09IE0udHlwZXMubWlsZXN0b25lID8gSS5wdXNoKFwiZ2FudHRfbWlsZXN0b25lXCIpIDogdC5nZXRUYXNrVHlwZShOLnR5cGUpID09IE0udHlwZXMucHJvamVjdCAmJiBJLnB1c2goXCJnYW50dF9wcm9qZWN0XCIpLCBJLnB1c2goXCJnYW50dF9iYXJfXCIgKyB0LmdldFRhc2tUeXBlKE4udHlwZSkpLCB0LmlzU3VtbWFyeVRhc2soTikgJiYgSS5wdXNoKFwiZ2FudHRfZGVwZW5kZW50X3Rhc2tcIiksIHQuaXNTcGxpdFRhc2soTikgJiYgKE0ub3Blbl9zcGxpdF90YXNrcyAmJiAhTi4kb3BlbiB8fCAhTS5vcGVuX3NwbGl0X3Rhc2tzKSAmJiBJLnB1c2goXCJnYW50dF9zcGxpdF9wYXJlbnRcIiksIE0uc2VsZWN0X3Rhc2sgJiYgdC5pc1NlbGVjdGVkVGFzayhDKSAmJiBJLnB1c2goXCJnYW50dF9zZWxlY3RlZFwiKSwgQyA9PSBBLmRyYWdfaWQgJiYgKEkucHVzaChcImdhbnR0X2RyYWdfXCIgKyBBLmRyYWdfbW9kZSksIEEudG91Y2hfZHJhZyAmJiBJLnB1c2goXCJnYW50dF90b3VjaF9cIiArIEEuZHJhZ19tb2RlKSksIEEubGlua19zb3VyY2VfaWQgPT0gQyAmJiAoSS5wdXNoKFwiZ2FudHRfbGlua19zb3VyY2VcIiksIEEubGlua19mcm9tX3N0YXJ0ID8gSS5wdXNoKFwiZ2FudHRfbGlua19mcm9tX3N0YXJ0XCIpIDogSS5wdXNoKFwiZ2FudHRfbGlua19mcm9tX2VuZFwiKSksIEEubGlua190YXJnZXRfaWQgPT0gQyAmJiBJLnB1c2goXCJnYW50dF9saW5rX3RhcmdldFwiKSwgTS5oaWdobGlnaHRfY3JpdGljYWxfcGF0aCAmJiB0LmlzQ3JpdGljYWxUYXNrICYmIHQuaXNDcml0aWNhbFRhc2soTikgJiYgSS5wdXNoKFwiZ2FudHRfY3JpdGljYWxfdGFza1wiKSwgQS5saW5rX2xhbmRpbmdfYXJlYSAmJiBBLmxpbmtfdGFyZ2V0X2lkICYmIEEubGlua19zb3VyY2VfaWQgJiYgQS5saW5rX3RhcmdldF9pZCAhPSBBLmxpbmtfc291cmNlX2lkICYmIChBLmxpbmtfdGFyZ2V0X2lkID09IEMgfHwgQS5saW5rX3NvdXJjZV9pZCA9PSBDKSkge1xuICAgICAgICB2YXIgTCA9IEEubGlua19zb3VyY2VfaWQsIE8gPSBBLmxpbmtfZnJvbV9zdGFydCwgRyA9IEEubGlua190b19zdGFydCwgaiA9IFwiXCI7XG4gICAgICAgIGogPSB0LmlzTGlua0FsbG93ZWQoTCwgQywgTywgRykgPyBHID8gXCJsaW5rX3N0YXJ0X2FsbG93XCIgOiBcImxpbmtfZmluaXNoX2FsbG93XCIgOiBHID8gXCJsaW5rX3N0YXJ0X2RlbnlcIiA6IFwibGlua19maW5pc2hfZGVueVwiLCBJLnB1c2goaik7XG4gICAgICB9XG4gICAgICByZXR1cm4gSS5qb2luKFwiIFwiKTtcbiAgICB9KFwiZ2FudHRfdGFza19saW5lXCIsIGMudGFza19jbGFzcyhyLnN0YXJ0X2RhdGUsIHIuZW5kX2RhdGUsIHIpLCByLmlkLCBzKTtcbiAgICAoci5jb2xvciB8fCByLnByb2dyZXNzQ29sb3IgfHwgci50ZXh0Q29sb3IpICYmIChmICs9IFwiIGdhbnR0X3Rhc2tfaW5saW5lX2NvbG9yXCIpLCBsLndpZHRoIDwgMjAgJiYgKGYgKz0gXCIgZ2FudHRfdGhpbl90YXNrXCIpLCBiLmNsYXNzTmFtZSA9IGY7XG4gICAgdmFyIGsgPSBbXCJsZWZ0OlwiICsgbC5sZWZ0ICsgXCJweFwiLCBcInRvcDpcIiArIChwICsgbC50b3ApICsgXCJweFwiLCBcImhlaWdodDpcIiArIGggKyBcInB4XCIsIFwibGluZS1oZWlnaHQ6XCIgKyBNYXRoLm1heChoIDwgMzAgPyBoIC0gMiA6IGgsIDApICsgXCJweFwiLCBcIndpZHRoOlwiICsgXyArIFwicHhcIl07XG4gICAgYi5zdHlsZS5jc3NUZXh0ID0gay5qb2luKFwiO1wiKSwgci5jb2xvciAmJiBiLnN0eWxlLnNldFByb3BlcnR5KFwiLS1kaHgtZ2FudHQtdGFzay1iYWNrZ3JvdW5kXCIsIHIuY29sb3IpLCByLnRleHRDb2xvciAmJiBiLnN0eWxlLnNldFByb3BlcnR5KFwiLS1kaHgtZ2FudHQtdGFzay1jb2xvclwiLCByLnRleHRDb2xvciksIHIucHJvZ3Jlc3NDb2xvciAmJiBiLnN0eWxlLnNldFByb3BlcnR5KFwiLS1kaHgtZ2FudHQtdGFzay1wcm9ncmVzcy1jb2xvclwiLCByLnByb2dyZXNzQ29sb3IpO1xuICAgIHZhciB4ID0gZnVuY3Rpb24oVCwgRSwgQywgRCkge1xuICAgICAgdmFyIE0gPSBcImdhbnR0X2xlZnQgXCIgKyBpKCFFLnJ0bCwgVCksIEkgPSBudWxsO1xuICAgICAgcmV0dXJuIEQgJiYgKEkgPSB7IHR5cGU6IFwibWFyZ2luUmlnaHRcIiwgdmFsdWU6IEQgfSksIG4oVCwgQy5sZWZ0c2lkZV90ZXh0LCBNLCBJKTtcbiAgICB9KHIsIGQsIGMsIGcpO1xuICAgIHggJiYgYi5hcHBlbmRDaGlsZCh4KSwgeCA9IGZ1bmN0aW9uKFQsIEUsIEMsIEQpIHtcbiAgICAgIHZhciBNID0gXCJnYW50dF9yaWdodCBcIiArIGkoISFFLnJ0bCwgVCksIEkgPSBudWxsO1xuICAgICAgcmV0dXJuIEQgJiYgKEkgPSB7IHR5cGU6IFwibWFyZ2luTGVmdFwiLCB2YWx1ZTogRCB9KSwgbihULCBDLnJpZ2h0c2lkZV90ZXh0LCBNLCBJKTtcbiAgICB9KHIsIGQsIGMsIGcpLCB4ICYmIGIuYXBwZW5kQ2hpbGQoeCksIHQuX3dhaUFyaWEuc2V0VGFza0JhckF0dHIociwgYik7XG4gICAgdmFyICQgPSB0LmdldFN0YXRlKCk7XG4gICAgY29uc3QgdyA9ICF0LmlzUmVhZG9ubHkociksIFMgPSB0LmV4dC5kcmFnVGltZWxpbmUgJiYgdC5leHQuZHJhZ1RpbWVsaW5lLl9pc0RyYWdJblByb2dyZXNzKCk7XG4gICAgcmV0dXJuICh3IHx8IFMpICYmIChkLmRyYWdfcmVzaXplICYmICF0LmlzU3VtbWFyeVRhc2socikgJiYgdSAhPSBkLnR5cGVzLm1pbGVzdG9uZSAmJiBhKGIsIFwiZ2FudHRfdGFza19kcmFnXCIsIHIsIGZ1bmN0aW9uKFQpIHtcbiAgICAgIHZhciBFID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIHJldHVybiBFLmNsYXNzTmFtZSA9IFQsIEU7XG4gICAgfSwgZCksIGQuZHJhZ19saW5rcyAmJiBkLnNob3dfbGlua3MgJiYgYShiLCBcImdhbnR0X2xpbmtfY29udHJvbFwiLCByLCBmdW5jdGlvbihUKSB7XG4gICAgICB2YXIgRSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBFLmNsYXNzTmFtZSA9IFQsIEUuc3R5bGUuY3NzVGV4dCA9IFtcImhlaWdodDpcIiArIGggKyBcInB4XCIsIFwibGluZS1oZWlnaHQ6XCIgKyBoICsgXCJweFwiXS5qb2luKFwiO1wiKTtcbiAgICAgIHZhciBDID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIEMuY2xhc3NOYW1lID0gXCJnYW50dF9saW5rX3BvaW50XCI7XG4gICAgICB2YXIgRCA9ICExO1xuICAgICAgcmV0dXJuICQubGlua19zb3VyY2VfaWQgJiYgZC50b3VjaCAmJiAoRCA9ICEwKSwgQy5zdHlsZS5kaXNwbGF5ID0gRCA/IFwiYmxvY2tcIiA6IFwiXCIsIEUuYXBwZW5kQ2hpbGQoQyksIEU7XG4gICAgfSwgZCwgZykpLCBiO1xuICB9XG4gIGZ1bmN0aW9uIG4ociwgcywgbywgbCkge1xuICAgIGlmICghcykgcmV0dXJuIG51bGw7XG4gICAgdmFyIGQgPSBzKHIuc3RhcnRfZGF0ZSwgci5lbmRfZGF0ZSwgcik7XG4gICAgaWYgKCFkKSByZXR1cm4gbnVsbDtcbiAgICB2YXIgYyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgcmV0dXJuIGMuY2xhc3NOYW1lID0gXCJnYW50dF9zaWRlX2NvbnRlbnQgXCIgKyBvLCBjLmlubmVySFRNTCA9IGQsIGwgJiYgKGMuc3R5bGVbbC50eXBlXSA9IE1hdGguYWJzKGwudmFsdWUpICsgXCJweFwiKSwgYztcbiAgfVxuICBmdW5jdGlvbiBpKHIsIHMpIHtcbiAgICB2YXIgbyA9IHIgPyB7ICRzb3VyY2U6IFt0LmNvbmZpZy5saW5rcy5zdGFydF90b19zdGFydF0sICR0YXJnZXQ6IFt0LmNvbmZpZy5saW5rcy5zdGFydF90b19zdGFydCwgdC5jb25maWcubGlua3MuZmluaXNoX3RvX3N0YXJ0XSB9IDogeyAkc291cmNlOiBbdC5jb25maWcubGlua3MuZmluaXNoX3RvX3N0YXJ0LCB0LmNvbmZpZy5saW5rcy5maW5pc2hfdG9fZmluaXNoXSwgJHRhcmdldDogW3QuY29uZmlnLmxpbmtzLmZpbmlzaF90b19maW5pc2hdIH07XG4gICAgZm9yICh2YXIgbCBpbiBvKSBmb3IgKHZhciBkID0gc1tsXSwgYyA9IDA7IGMgPCBkLmxlbmd0aDsgYysrKSBmb3IgKHZhciB1ID0gdC5nZXRMaW5rKGRbY10pLCBoID0gMDsgaCA8IG9bbF0ubGVuZ3RoOyBoKyspIGlmICh1LnR5cGUgPT0gb1tsXVtoXSkgcmV0dXJuIFwiZ2FudHRfbGlua19jcm9zc2luZ1wiO1xuICAgIHJldHVybiBcIlwiO1xuICB9XG4gIGZ1bmN0aW9uIGEociwgcywgbywgbCwgZCwgYykge1xuICAgIHZhciB1LCBoID0gdC5nZXRTdGF0ZSgpO1xuICAgICtvLnN0YXJ0X2RhdGUgPj0gK2gubWluX2RhdGUgJiYgKCh1ID0gbChbcywgZC5ydGwgPyBcInRhc2tfcmlnaHRcIiA6IFwidGFza19sZWZ0XCIsIFwidGFza19zdGFydF9kYXRlXCJdLmpvaW4oXCIgXCIpKSkuc2V0QXR0cmlidXRlKFwiZGF0YS1iaW5kLXByb3BlcnR5XCIsIFwic3RhcnRfZGF0ZVwiKSwgYyAmJiAodS5zdHlsZS5tYXJnaW5MZWZ0ID0gYyArIFwicHhcIiksIHIuYXBwZW5kQ2hpbGQodSkpLCArby5lbmRfZGF0ZSA8PSAraC5tYXhfZGF0ZSAmJiAoKHUgPSBsKFtzLCBkLnJ0bCA/IFwidGFza19sZWZ0XCIgOiBcInRhc2tfcmlnaHRcIiwgXCJ0YXNrX2VuZF9kYXRlXCJdLmpvaW4oXCIgXCIpKSkuc2V0QXR0cmlidXRlKFwiZGF0YS1iaW5kLXByb3BlcnR5XCIsIFwiZW5kX2RhdGVcIiksIGMgJiYgKHUuc3R5bGUubWFyZ2luUmlnaHQgPSBjICsgXCJweFwiKSwgci5hcHBlbmRDaGlsZCh1KSk7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKHIsIHMsIG8pIHtcbiAgICB2YXIgbCA9IChvID0gcy4kZ2V0Q29uZmlnKCkpLnR5cGVfcmVuZGVyZXJzW3QuZ2V0VGFza1R5cGUoci50eXBlKV0sIGQgPSBlO1xuICAgIHJldHVybiBsID8gbC5jYWxsKHQsIHIsIGZ1bmN0aW9uKGMpIHtcbiAgICAgIHJldHVybiBkLmNhbGwodCwgYywgcywgbyk7XG4gICAgfSwgcykgOiBkLmNhbGwodCwgciwgcywgbyk7XG4gIH07XG59XG5mdW5jdGlvbiBVZSh0KSB7XG4gIHJldHVybiB7IHJlbmRlcjogYm4odCksIHVwZGF0ZTogbnVsbCwgaXNJblZpZXdQb3J0OiAkZSwgZ2V0VmlzaWJsZVJhbmdlOiBmdCB9O1xufVxuZnVuY3Rpb24gQ3QoKSB7XG4gIHJldHVybiBjb25zb2xlLmVycm9yKFwiWW91IGFyZSB0cnlpbmcgdG8gdXNlIGEgUHJvIGZlYXR1cmUgdGhhdCBpcyBub3QgYXZhaWxhYmxlIGluIHRoZSBHUEwgdmVyc2lvbi5cIiksIHsgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgfSwgaXNJblZpZXdQb3J0OiBmdW5jdGlvbigpIHtcbiAgfSwgZ2V0VmlzaWJsZVJhbmdlOiBmdW5jdGlvbigpIHtcbiAgfSB9O1xufVxuZnVuY3Rpb24gcWUodCwgZSwgbikge1xuICByZXR1cm4geyB0b3A6IGUuZ2V0SXRlbVRvcCh0LmlkKSwgaGVpZ2h0OiBlLmdldEl0ZW1IZWlnaHQodC5pZCksIGxlZnQ6IDAsIHJpZ2h0OiAxIC8gMCB9O1xufVxuZnVuY3Rpb24ganQodCwgZSkge1xuICB2YXIgbiA9IDAsIGkgPSB0LmxlZnQubGVuZ3RoIC0gMTtcbiAgaWYgKGUpIGZvciAodmFyIGEgPSAwOyBhIDwgdC5sZWZ0Lmxlbmd0aDsgYSsrKSB7XG4gICAgdmFyIHIgPSB0LmxlZnRbYV07XG4gICAgaWYgKHIgPCBlLnggJiYgKG4gPSBhKSwgciA+IGUueF9lbmQpIHtcbiAgICAgIGkgPSBhO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiB7IHN0YXJ0OiBuLCBlbmQ6IGkgfTtcbn1cbmZ1bmN0aW9uIG9lKHQsIGUsIG4sIGkpIHtcbiAgdmFyIGEgPSBlLndpZHRoW3RdO1xuICBpZiAoYSA8PSAwKSByZXR1cm4gITE7XG4gIGlmICghaS5jb25maWcuc21hcnRfcmVuZGVyaW5nIHx8IE50KGkpKSByZXR1cm4gITA7XG4gIHZhciByID0gZS5sZWZ0W3RdIC0gYSwgcyA9IGUubGVmdFt0XSArIGE7XG4gIHJldHVybiByIDw9IG4ueF9lbmQgJiYgcyA+PSBuLng7XG59XG5mdW5jdGlvbiBBYSh0LCBlKSB7XG4gIHZhciBuID0gZS5jb25maWcudGltZWxpbmVfcGxhY2Vob2xkZXI7XG4gIGlmICh0ID0gdCB8fCBbXSwgbiAmJiB0LmZpbHRlcigobCkgPT4gbC5pZCA9PT0gXCJ0aW1lbGluZV9wbGFjZWhvbGRlcl90YXNrXCIpLmxlbmd0aCA9PT0gMCkge1xuICAgIHZhciBpID0gZS5nZXRTdGF0ZSgpLCBhID0gbnVsbCwgciA9IGkubWluX2RhdGUsIHMgPSBpLm1heF9kYXRlO1xuICAgIHQubGVuZ3RoICYmIChhID0gdFt0Lmxlbmd0aCAtIDFdLmlkKTtcbiAgICB2YXIgbyA9IHsgc3RhcnRfZGF0ZTogciwgZW5kX2RhdGU6IHMsIHJvd19oZWlnaHQ6IG4uaGVpZ2h0IHx8IDAsIGlkOiBcInRpbWVsaW5lX3BsYWNlaG9sZGVyX3Rhc2tcIiwgdW5zY2hlZHVsZWQ6ICEwLCBsYXN0VGFza0lkOiBhLCBjYWxlbmRhcl9pZDogbi5jYWxlbmRhciB8fCBcImdsb2JhbFwiLCAkc291cmNlOiBbXSwgJHRhcmdldDogW10gfTtcbiAgICB0LnB1c2gobyk7XG4gIH1cbn1cbmZ1bmN0aW9uIElhKHQpIHtcbiAgdmFyIGUgPSB7IGN1cnJlbnRfcG9zOiBudWxsLCBkaXJzOiB7IGxlZnQ6IFwibGVmdFwiLCByaWdodDogXCJyaWdodFwiLCB1cDogXCJ1cFwiLCBkb3duOiBcImRvd25cIiB9LCBwYXRoOiBbXSwgY2xlYXI6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY3VycmVudF9wb3MgPSBudWxsLCB0aGlzLnBhdGggPSBbXTtcbiAgfSwgcG9pbnQ6IGZ1bmN0aW9uKGEpIHtcbiAgICB0aGlzLmN1cnJlbnRfcG9zID0gdC5jb3B5KGEpO1xuICB9LCBnZXRfbGluZXM6IGZ1bmN0aW9uKGEpIHtcbiAgICB0aGlzLmNsZWFyKCksIHRoaXMucG9pbnQoYVswXSk7XG4gICAgZm9yICh2YXIgciA9IDE7IHIgPCBhLmxlbmd0aDsgcisrKSB0aGlzLmxpbmVfdG8oYVtyXSk7XG4gICAgcmV0dXJuIHRoaXMuZ2V0X3BhdGgoKTtcbiAgfSwgbGluZV90bzogZnVuY3Rpb24oYSkge1xuICAgIHZhciByID0gdC5jb3B5KGEpLCBzID0gdGhpcy5jdXJyZW50X3BvcywgbyA9IHRoaXMuX2dldF9saW5lKHMsIHIpO1xuICAgIHRoaXMucGF0aC5wdXNoKG8pLCB0aGlzLmN1cnJlbnRfcG9zID0gcjtcbiAgfSwgZ2V0X3BhdGg6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnBhdGg7XG4gIH0sIGdldF93cmFwcGVyX3NpemVzOiBmdW5jdGlvbihhLCByLCBzKSB7XG4gICAgdmFyIG8sIGwgPSByLiRnZXRDb25maWcoKS5saW5rX3dyYXBwZXJfd2lkdGgsIGQgPSBhLnkgLSBsIC8gMjtcbiAgICBzd2l0Y2ggKGEuZGlyZWN0aW9uKSB7XG4gICAgICBjYXNlIHRoaXMuZGlycy5sZWZ0OlxuICAgICAgICBvID0geyB0b3A6IGQsIGhlaWdodDogbCwgbGluZUhlaWdodDogbCwgbGVmdDogYS54IC0gYS5zaXplIC0gbCAvIDIsIHdpZHRoOiBhLnNpemUgKyBsIH07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0aGlzLmRpcnMucmlnaHQ6XG4gICAgICAgIG8gPSB7IHRvcDogZCwgbGluZUhlaWdodDogbCwgaGVpZ2h0OiBsLCBsZWZ0OiBhLnggLSBsIC8gMiwgd2lkdGg6IGEuc2l6ZSArIGwgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRoaXMuZGlycy51cDpcbiAgICAgICAgbyA9IHsgdG9wOiBkIC0gYS5zaXplLCBsaW5lSGVpZ2h0OiBhLnNpemUgKyBsLCBoZWlnaHQ6IGEuc2l6ZSArIGwsIGxlZnQ6IGEueCAtIGwgLyAyLCB3aWR0aDogbCB9O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdGhpcy5kaXJzLmRvd246XG4gICAgICAgIG8gPSB7IHRvcDogZCwgbGluZUhlaWdodDogYS5zaXplICsgbCwgaGVpZ2h0OiBhLnNpemUgKyBsLCBsZWZ0OiBhLnggLSBsIC8gMiwgd2lkdGg6IGwgfTtcbiAgICB9XG4gICAgcmV0dXJuIG87XG4gIH0sIGdldF9saW5lX3NpemVzOiBmdW5jdGlvbihhLCByKSB7XG4gICAgdmFyIHMsIG8gPSByLiRnZXRDb25maWcoKSwgbCA9IG8ubGlua19saW5lX3dpZHRoLCBkID0gby5saW5rX3dyYXBwZXJfd2lkdGgsIGMgPSBhLnNpemUgKyBsO1xuICAgIHN3aXRjaCAoYS5kaXJlY3Rpb24pIHtcbiAgICAgIGNhc2UgdGhpcy5kaXJzLmxlZnQ6XG4gICAgICBjYXNlIHRoaXMuZGlycy5yaWdodDpcbiAgICAgICAgcyA9IHsgaGVpZ2h0OiBsLCB3aWR0aDogYywgbWFyZ2luVG9wOiAoZCAtIGwpIC8gMiwgbWFyZ2luTGVmdDogKGQgLSBsKSAvIDIgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRoaXMuZGlycy51cDpcbiAgICAgIGNhc2UgdGhpcy5kaXJzLmRvd246XG4gICAgICAgIHMgPSB7IGhlaWdodDogYywgd2lkdGg6IGwsIG1hcmdpblRvcDogKGQgLSBsKSAvIDIsIG1hcmdpbkxlZnQ6IChkIC0gbCkgLyAyIH07XG4gICAgfVxuICAgIHJldHVybiBzO1xuICB9LCByZW5kZXJfbGluZTogZnVuY3Rpb24oYSwgciwgcywgbykge1xuICAgIHZhciBsID0gdGhpcy5nZXRfd3JhcHBlcl9zaXplcyhhLCBzLCBvKSwgZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgZC5zdHlsZS5jc3NUZXh0ID0gW1widG9wOlwiICsgbC50b3AgKyBcInB4XCIsIFwibGVmdDpcIiArIGwubGVmdCArIFwicHhcIiwgXCJoZWlnaHQ6XCIgKyBsLmhlaWdodCArIFwicHhcIiwgXCJ3aWR0aDpcIiArIGwud2lkdGggKyBcInB4XCJdLmpvaW4oXCI7XCIpLCBkLmNsYXNzTmFtZSA9IFwiZ2FudHRfbGluZV93cmFwcGVyXCI7XG4gICAgdmFyIGMgPSB0aGlzLmdldF9saW5lX3NpemVzKGEsIHMpLCB1ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICByZXR1cm4gdS5zdHlsZS5jc3NUZXh0ID0gW1wiaGVpZ2h0OlwiICsgYy5oZWlnaHQgKyBcInB4XCIsIFwid2lkdGg6XCIgKyBjLndpZHRoICsgXCJweFwiLCBcIm1hcmdpbi10b3A6XCIgKyBjLm1hcmdpblRvcCArIFwicHhcIiwgXCJtYXJnaW4tbGVmdDpcIiArIGMubWFyZ2luTGVmdCArIFwicHhcIl0uam9pbihcIjtcIiksIHUuY2xhc3NOYW1lID0gXCJnYW50dF9saW5rX2xpbmVfXCIgKyBhLmRpcmVjdGlvbiwgZC5hcHBlbmRDaGlsZCh1KSwgZDtcbiAgfSwgcmVuZGVyX2Nvcm5lcjogZnVuY3Rpb24oYSwgcikge1xuICAgIGNvbnN0IHMgPSBhLnJhZGl1cywgbyA9IHIuJGdldENvbmZpZygpLCBsID0gby5saW5rX2xpbmVfd2lkdGggfHwgMiwgZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgbGV0IGMsIHU7XG4gICAgcmV0dXJuIGQuY2xhc3NMaXN0LmFkZChcImdhbnR0X2xpbmtfY29ybmVyXCIpLCBkLmNsYXNzTGlzdC5hZGQoYGdhbnR0X2xpbmtfY29ybmVyXyR7YS5kaXJlY3Rpb24uZnJvbX1fJHthLmRpcmVjdGlvbi50b31gKSwgZC5zdHlsZS53aWR0aCA9IGAke3N9cHhgLCBkLnN0eWxlLmhlaWdodCA9IGAke3N9cHhgLCBhLmRpcmVjdGlvbi5mcm9tID09PSBcInJpZ2h0XCIgJiYgYS5kaXJlY3Rpb24udG8gPT09IFwiZG93blwiID8gKGMgPSBcIlJpZ2h0XCIsIHUgPSBcIlRvcFwiLCBkLnN0eWxlLmxlZnQgPSBhLnggLSBvLmxpbmtfbGluZV93aWR0aCAvIDIgKyBcInB4XCIsIGQuc3R5bGUudG9wID0gYCR7YS55fXB4YCkgOiBhLmRpcmVjdGlvbi5mcm9tID09PSBcImRvd25cIiAmJiBhLmRpcmVjdGlvbi50byA9PT0gXCJyaWdodFwiID8gKGMgPSBcIkxlZnRcIiwgdSA9IFwiQm90dG9tXCIsIGQuc3R5bGUubGVmdCA9IGEueCAtIG8ubGlua19saW5lX3dpZHRoIC8gMiArIFwicHhcIiwgZC5zdHlsZS50b3AgPSBgJHthLnl9cHhgKSA6IGEuZGlyZWN0aW9uLmZyb20gPT09IFwicmlnaHRcIiAmJiBhLmRpcmVjdGlvbi50byA9PT0gXCJ1cFwiID8gKGMgPSBcIlJpZ2h0XCIsIHUgPSBcIkJvdHRvbVwiLCBkLnN0eWxlLmxlZnQgPSBhLnggLSBvLmxpbmtfbGluZV93aWR0aCAvIDIgKyBcInB4XCIsIGQuc3R5bGUudG9wID0gYS55IC0gcyArIFwicHhcIikgOiBhLmRpcmVjdGlvbi5mcm9tID09PSBcInVwXCIgJiYgYS5kaXJlY3Rpb24udG8gPT09IFwicmlnaHRcIiA/IChjID0gXCJMZWZ0XCIsIHUgPSBcIlRvcFwiLCBkLnN0eWxlLmxlZnQgPSBhLnggLSBvLmxpbmtfbGluZV93aWR0aCAvIDIgKyBcInB4XCIsIGQuc3R5bGUudG9wID0gYS55IC0gcyArIFwicHhcIikgOiBhLmRpcmVjdGlvbi5mcm9tID09PSBcImxlZnRcIiAmJiBhLmRpcmVjdGlvbi50byA9PT0gXCJkb3duXCIgPyAoYyA9IFwiTGVmdFwiLCB1ID0gXCJUb3BcIiwgZC5zdHlsZS5sZWZ0ID0gYS54IC0gcyAtIG8ubGlua19saW5lX3dpZHRoIC8gMiArIFwicHhcIiwgZC5zdHlsZS50b3AgPSBgJHthLnl9cHhgKSA6IGEuZGlyZWN0aW9uLmZyb20gPT09IFwiZG93blwiICYmIGEuZGlyZWN0aW9uLnRvID09PSBcImxlZnRcIiA/IChjID0gXCJSaWdodFwiLCB1ID0gXCJCb3R0b21cIiwgZC5zdHlsZS5sZWZ0ID0gYS54IC0gcyAtIG8ubGlua19saW5lX3dpZHRoIC8gMiArIFwicHhcIiwgZC5zdHlsZS50b3AgPSBgJHthLnl9cHhgKSA6IGEuZGlyZWN0aW9uLmZyb20gPT09IFwibGVmdFwiICYmIGEuZGlyZWN0aW9uLnRvID09PSBcInVwXCIgPyAoYyA9IFwiTGVmdFwiLCB1ID0gXCJCb3R0b21cIiwgZC5zdHlsZS5sZWZ0ID0gYS54IC0gcyAtIG8ubGlua19saW5lX3dpZHRoIC8gMiArIFwicHhcIiwgZC5zdHlsZS50b3AgPSBhLnkgLSBzICsgXCJweFwiKSA6IGEuZGlyZWN0aW9uLmZyb20gPT09IFwidXBcIiAmJiBhLmRpcmVjdGlvbi50byA9PT0gXCJsZWZ0XCIgJiYgKGMgPSBcIlJpZ2h0XCIsIHUgPSBcIlRvcFwiLCBkLnN0eWxlLmxlZnQgPSBhLnggLSBzIC0gby5saW5rX2xpbmVfd2lkdGggLyAyICsgXCJweFwiLCBkLnN0eWxlLnRvcCA9IGEueSAtIHMgKyBcInB4XCIpLCBkLnN0eWxlW2Bib3JkZXIke3V9V2lkdGhgXSA9IGAke2x9cHhgLCBkLnN0eWxlW2Bib3JkZXIke2N9V2lkdGhgXSA9IGAke2x9cHhgLCBkLnN0eWxlW2Bib3JkZXIke2N9U3R5bGVgXSA9IFwic29saWRcIiwgZC5zdHlsZVtgYm9yZGVyJHt1fVN0eWxlYF0gPSBcInNvbGlkXCIsIGQuc3R5bGVbYGJvcmRlciR7dX0ke2N9UmFkaXVzYF0gPSBgJHtzfXB4YCwgZDtcbiAgfSwgcmVuZGVyX2Fycm93KGEsIHIpIHtcbiAgICB2YXIgcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksIG8gPSBhLnksIGwgPSBhLngsIGQgPSByLmxpbmtfYXJyb3dfc2l6ZTtcbiAgICBzLnN0eWxlLnNldFByb3BlcnR5KFwiLS1kaHgtZ2FudHQtaWNvbi1zaXplXCIsIGAke2R9cHhgKTtcbiAgICB2YXIgYyA9IFwiZ2FudHRfbGlua19hcnJvdyBnYW50dF9saW5rX2Fycm93X1wiICsgYS5kaXJlY3Rpb247XG4gICAgcmV0dXJuIHMuc3R5bGUudG9wID0gbyArIFwicHhcIiwgcy5zdHlsZS5sZWZ0ID0gbCArIFwicHhcIiwgcy5jbGFzc05hbWUgPSBjLCBzO1xuICB9LCBfZ2V0X2xpbmU6IGZ1bmN0aW9uKGEsIHIpIHtcbiAgICB2YXIgcyA9IHRoaXMuZ2V0X2RpcmVjdGlvbihhLCByKSwgbyA9IHsgeDogYS54LCB5OiBhLnksIGRpcmVjdGlvbjogdGhpcy5nZXRfZGlyZWN0aW9uKGEsIHIpIH07XG4gICAgcmV0dXJuIHMgPT0gdGhpcy5kaXJzLmxlZnQgfHwgcyA9PSB0aGlzLmRpcnMucmlnaHQgPyBvLnNpemUgPSBNYXRoLmFicyhhLnggLSByLngpIDogby5zaXplID0gTWF0aC5hYnMoYS55IC0gci55KSwgbztcbiAgfSwgZ2V0X2RpcmVjdGlvbjogZnVuY3Rpb24oYSwgcikge1xuICAgIHJldHVybiByLnggPCBhLnggPyB0aGlzLmRpcnMubGVmdCA6IHIueCA+IGEueCA/IHRoaXMuZGlycy5yaWdodCA6IHIueSA+IGEueSA/IHRoaXMuZGlycy5kb3duIDogdGhpcy5kaXJzLnVwO1xuICB9IH0sIG4gPSB7IHBhdGg6IFtdLCBjbGVhcjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5wYXRoID0gW107XG4gIH0sIGN1cnJlbnQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnBhdGhbdGhpcy5wYXRoLmxlbmd0aCAtIDFdO1xuICB9LCBwb2ludDogZnVuY3Rpb24oYSkge1xuICAgIHJldHVybiBhID8gKHRoaXMucGF0aC5wdXNoKHQuY29weShhKSksIGEpIDogdGhpcy5jdXJyZW50KCk7XG4gIH0sIHBvaW50X3RvOiBmdW5jdGlvbihhLCByLCBzKSB7XG4gICAgcyA9IHMgPyB7IHg6IHMueCwgeTogcy55IH0gOiB0LmNvcHkodGhpcy5wb2ludCgpKTtcbiAgICB2YXIgbyA9IGUuZGlycztcbiAgICBzd2l0Y2ggKGEpIHtcbiAgICAgIGNhc2Ugby5sZWZ0OlxuICAgICAgICBzLnggLT0gcjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG8ucmlnaHQ6XG4gICAgICAgIHMueCArPSByO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugby51cDpcbiAgICAgICAgcy55IC09IHI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvLmRvd246XG4gICAgICAgIHMueSArPSByO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wb2ludChzKTtcbiAgfSwgZ2V0X3BvaW50czogZnVuY3Rpb24oYSwgciwgcywgbykge1xuICAgIHZhciBsID0gdGhpcy5nZXRfZW5kcG9pbnQoYSwgciwgcywgbyksIGQgPSB0LmNvbmZpZywgYyA9IGwuZV95IC0gbC55LCB1ID0gbC5lX3ggLSBsLngsIGggPSBlLmRpcnMsIGcgPSByLmdldEl0ZW1IZWlnaHQoYS5zb3VyY2UpO1xuICAgIHRoaXMuY2xlYXIoKSwgdGhpcy5wb2ludCh7IHg6IGwueCwgeTogbC55IH0pO1xuICAgIHZhciBwID0gMiAqIGQubGlua19hcnJvd19zaXplLCB5ID0gdGhpcy5nZXRfbGluZV90eXBlKGEsIHIuJGdldENvbmZpZygpKSwgdiA9IGwuZV94ID4gbC54O1xuICAgIGlmICh5LmZyb21fc3RhcnQgJiYgeS50b19zdGFydCkgdGhpcy5wb2ludF90byhoLmxlZnQsIHApLCB2ID8gKHRoaXMucG9pbnRfdG8oaC5kb3duLCBjKSwgdGhpcy5wb2ludF90byhoLnJpZ2h0LCB1KSkgOiAodGhpcy5wb2ludF90byhoLnJpZ2h0LCB1KSwgdGhpcy5wb2ludF90byhoLmRvd24sIGMpKSwgdGhpcy5wb2ludF90byhoLnJpZ2h0LCBwKTtcbiAgICBlbHNlIGlmICgheS5mcm9tX3N0YXJ0ICYmIHkudG9fc3RhcnQpIGlmIChjICE9PSAwICYmICh2ID0gbC5lX3ggPiBsLnggKyAyICogcCksIHRoaXMucG9pbnRfdG8oaC5yaWdodCwgcCksIHYpIHUgLT0gcCwgdGhpcy5wb2ludF90byhoLmRvd24sIGMpLCB0aGlzLnBvaW50X3RvKGgucmlnaHQsIHUpO1xuICAgIGVsc2Uge1xuICAgICAgdSAtPSAyICogcDtcbiAgICAgIHZhciBiID0gYyA+IDAgPyAxIDogLTE7XG4gICAgICB0aGlzLnBvaW50X3RvKGguZG93biwgYiAqIChnIC8gMikpLCB0aGlzLnBvaW50X3RvKGgucmlnaHQsIHUpLCB0aGlzLnBvaW50X3RvKGguZG93biwgYiAqIChNYXRoLmFicyhjKSAtIGcgLyAyKSksIHRoaXMucG9pbnRfdG8oaC5yaWdodCwgcCk7XG4gICAgfVxuICAgIGVsc2UgeS5mcm9tX3N0YXJ0IHx8IHkudG9fc3RhcnQgPyB5LmZyb21fc3RhcnQgJiYgIXkudG9fc3RhcnQgJiYgKGMgIT09IDAgJiYgKHYgPSBsLmVfeCA+IGwueCAtIDIgKiBwKSwgdGhpcy5wb2ludF90byhoLmxlZnQsIHApLCB2ID8gKHUgKz0gMiAqIHAsIGIgPSBjID4gMCA/IDEgOiAtMSwgdGhpcy5wb2ludF90byhoLmRvd24sIGIgKiAoZyAvIDIpKSwgdGhpcy5wb2ludF90byhoLnJpZ2h0LCB1KSwgdGhpcy5wb2ludF90byhoLmRvd24sIGIgKiAoTWF0aC5hYnMoYykgLSBnIC8gMikpLCB0aGlzLnBvaW50X3RvKGgubGVmdCwgcCkpIDogKHUgKz0gcCwgdGhpcy5wb2ludF90byhoLmRvd24sIGMpLCB0aGlzLnBvaW50X3RvKGgucmlnaHQsIHUpKSkgOiAodGhpcy5wb2ludF90byhoLnJpZ2h0LCBwKSwgdiA/ICh0aGlzLnBvaW50X3RvKGgucmlnaHQsIHUpLCB0aGlzLnBvaW50X3RvKGguZG93biwgYykpIDogKHRoaXMucG9pbnRfdG8oaC5kb3duLCBjKSwgdGhpcy5wb2ludF90byhoLnJpZ2h0LCB1KSksIHRoaXMucG9pbnRfdG8oaC5sZWZ0LCBwKSk7XG4gICAgcmV0dXJuIHRoaXMucGF0aDtcbiAgfSwgZ2V0X2xpbmVfdHlwZTogZnVuY3Rpb24oYSwgcikge1xuICAgIHZhciBzID0gci5saW5rcywgbyA9ICExLCBsID0gITE7XG4gICAgcmV0dXJuIGEudHlwZSA9PSBzLnN0YXJ0X3RvX3N0YXJ0ID8gbyA9IGwgPSAhMCA6IGEudHlwZSA9PSBzLmZpbmlzaF90b19maW5pc2ggPyBvID0gbCA9ICExIDogYS50eXBlID09IHMuZmluaXNoX3RvX3N0YXJ0ID8gKG8gPSAhMSwgbCA9ICEwKSA6IGEudHlwZSA9PSBzLnN0YXJ0X3RvX2ZpbmlzaCA/IChvID0gITAsIGwgPSAhMSkgOiB0LmFzc2VydCghMSwgXCJJbnZhbGlkIGxpbmsgdHlwZVwiKSwgci5ydGwgJiYgKG8gPSAhbywgbCA9ICFsKSwgeyBmcm9tX3N0YXJ0OiBvLCB0b19zdGFydDogbCB9O1xuICB9LCBnZXRfZW5kcG9pbnQ6IGZ1bmN0aW9uKGEsIHIsIHMsIG8pIHtcbiAgICB2YXIgbCA9IHIuJGdldENvbmZpZygpLCBkID0gdGhpcy5nZXRfbGluZV90eXBlKGEsIGwpLCBjID0gZC5mcm9tX3N0YXJ0LCB1ID0gZC50b19zdGFydCwgaCA9IGkocywgciwgbCksIGcgPSBpKG8sIHIsIGwpO1xuICAgIHJldHVybiB7IHg6IGMgPyBoLmxlZnQgOiBoLmxlZnQgKyBoLndpZHRoLCBlX3g6IHUgPyBnLmxlZnQgOiBnLmxlZnQgKyBnLndpZHRoLCB5OiBoLnRvcCArIGgucm93SGVpZ2h0IC8gMiAtIDEsIGVfeTogZy50b3AgKyBnLnJvd0hlaWdodCAvIDIgLSAxIH07XG4gIH0gfTtcbiAgZnVuY3Rpb24gaShhLCByLCBzKSB7XG4gICAgdmFyIG8gPSByLmdldEl0ZW1Qb3NpdGlvbihhKTtcbiAgICBsZXQgbCA9IGZ1bmN0aW9uKHAsIHksIHYsIGIpIHtcbiAgICAgIGxldCBfID0gYiB8fCB5LiR0YXNrX2RhdGEuc2Nyb2xsSGVpZ2h0LCBtID0gITEsIGYgPSAhMTtcbiAgICAgIHJldHVybiBwLmVhY2hQYXJlbnQoZnVuY3Rpb24oaykge1xuICAgICAgICBpZiAoJHQoaykpIHtcbiAgICAgICAgICBmID0gITA7XG4gICAgICAgICAgY29uc3QgeCA9IHkuZ2V0SXRlbVBvc2l0aW9uKGspLnJvd0hlaWdodDtcbiAgICAgICAgICB4IDwgXyAmJiAoXyA9IHgsIG0gPSAhMCk7XG4gICAgICAgIH1cbiAgICAgIH0sIHYuaWQpLCB7IG1heEhlaWdodDogXywgc2hyaW5rSGVpZ2h0OiBtLCBzcGxpdENoaWxkOiBmIH07XG4gICAgfSh0LCByLCBhKSwgZCA9IGwubWF4SGVpZ2h0LCBjID0gbC5zcGxpdENoaWxkO1xuICAgIGNvbnN0IHUgPSB0LmNvbmZpZy5iYXNlbGluZXMgJiYgKHQuY29uZmlnLmJhc2VsaW5lcy5yZW5kZXJfbW9kZSA9PSBcInNlcGFyYXRlUm93XCIgfHwgdC5jb25maWcuYmFzZWxpbmVzLnJlbmRlcl9tb2RlID09IFwiaW5kaXZpZHVhbFJvd1wiKSAmJiBhLmJhc2VsaW5lcyAmJiBhLmJhc2VsaW5lcy5sZW5ndGg7XG4gICAgbGV0IGg7XG4gICAgbC5zaHJpbmtIZWlnaHQgJiYgKG8ucm93SGVpZ2h0ID0gZCk7XG4gICAgbGV0IGcgPSB0LmdldFRhc2tUeXBlKGEudHlwZSkgPT0gcy50eXBlcy5taWxlc3RvbmU7XG4gICAgaWYgKGcpIHtcbiAgICAgIGxldCBwID0gci5nZXRCYXJIZWlnaHQoYS5pZCwgITApO1xuICAgICAgaCA9IE1hdGguc3FydCgyICogcCAqIHApLCBsLnNocmlua0hlaWdodCAmJiBkIDwgcCAmJiAocCA9IGQsIGggPSBkKSwgby5sZWZ0IC09IGggLyAyLCBvLndpZHRoID0gaDtcbiAgICB9XG4gICAgaWYgKGMpIGlmIChkID49IG8uaGVpZ2h0KSB7XG4gICAgICBjb25zdCBwID0gZnVuY3Rpb24oeSwgdikge1xuICAgICAgICBsZXQgYiA9ICExO1xuICAgICAgICByZXR1cm4geS5lYWNoVGFzayhmdW5jdGlvbihfKSB7XG4gICAgICAgICAgYiB8fCAoYiA9IGhuKHksIF8pKTtcbiAgICAgICAgfSwgdiksIGI7XG4gICAgICB9KHQsIGEucGFyZW50KTtcbiAgICAgIHUgfHwgcCA/IGcgPyAoby5yb3dIZWlnaHQgPSBvLmhlaWdodCArIDQsIG8ubGVmdCArPSAoby53aWR0aCAtIG8ucm93SGVpZ2h0ICsgNCkgLyAyLCBvLndpZHRoID0gby5yb3dIZWlnaHQgLSAzKSA6IG8ucm93SGVpZ2h0ID0gby5oZWlnaHQgKyA2IDogZyAmJiAoby5sZWZ0ICs9IChoIC0gby5oZWlnaHQpIC8gMik7XG4gICAgfSBlbHNlIG8ucm93SGVpZ2h0ID0gZCArIDIsIGcgJiYgKG8ubGVmdCArPSAoby53aWR0aCAtIG8ucm93SGVpZ2h0ICsgNCkgLyAyLCBvLndpZHRoID0gby5yb3dIZWlnaHQgLSAzKTtcbiAgICBlbHNlIHUgJiYgKG8ucm93SGVpZ2h0ID0gby5oZWlnaHQgKyA0KTtcbiAgICByZXR1cm4gbztcbiAgfVxuICByZXR1cm4geyByZW5kZXI6IGZ1bmN0aW9uKGEsIHIsIHMpIHtcbiAgICB2YXIgbyA9IHQuZ2V0VGFzayhhLnNvdXJjZSk7XG4gICAgaWYgKG8uaGlkZV9iYXIpIHJldHVybjtcbiAgICB2YXIgbCA9IHQuZ2V0VGFzayhhLnRhcmdldCk7XG4gICAgaWYgKGwuaGlkZV9iYXIpIHJldHVybjtcbiAgICB2YXIgZCA9IG4uZ2V0X2VuZHBvaW50KGEsIHIsIG8sIGwpLCBjID0gZC5lX3kgLSBkLnk7XG4gICAgaWYgKCEoZC5lX3ggLSBkLngpICYmICFjKSByZXR1cm4gbnVsbDtcbiAgICB2YXIgdSA9IG4uZ2V0X3BvaW50cyhhLCByLCBvLCBsKTtcbiAgICBjb25zdCBoID0gZnVuY3Rpb24odiwgYikge1xuICAgICAgY29uc3QgXyA9IGIubGlua19yYWRpdXMgfHwgNCwgbSA9IGIubGlua19hcnJvd19zaXplIHx8IDYsIGYgPSBbXTtcbiAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgdi5sZW5ndGg7IHgrKykge1xuICAgICAgICBjb25zdCAkID0gdlt4XSwgdyA9IHZbeCArIDFdO1xuICAgICAgICBpZiAoIXcgfHwgYi5saW5rX3JhZGl1cyA8PSAxKSBmLnB1c2goeyB0eXBlOiBcImxpbmVcIiwgZGF0YTogJCB9KTtcbiAgICAgICAgZWxzZSBpZiAoJC5kaXJlY3Rpb24gIT09IHcuZGlyZWN0aW9uKSB7XG4gICAgICAgICAgaWYgKCQuc2l6ZSA8IF8gfHwgdy5zaXplIDwgXykge1xuICAgICAgICAgICAgZi5wdXNoKHsgdHlwZTogXCJsaW5lXCIsIGRhdGE6ICQgfSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgJC5zaXplIC09IF8sIGYucHVzaCh7IHR5cGU6IFwibGluZVwiLCBkYXRhOiAkIH0pO1xuICAgICAgICAgIGxldCBTID0gJC54LCBUID0gJC55IC0gYi5saW5rX2xpbmVfd2lkdGggLyAyO1xuICAgICAgICAgIHN3aXRjaCAoJC5kaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIGNhc2UgXCJyaWdodFwiOlxuICAgICAgICAgICAgICBTICs9ICQuc2l6ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwibGVmdFwiOlxuICAgICAgICAgICAgICBTIC09ICQuc2l6ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZG93blwiOlxuICAgICAgICAgICAgICBUICs9ICQuc2l6ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwidXBcIjpcbiAgICAgICAgICAgICAgVCAtPSAkLnNpemU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IEUgPSB7IHg6IFMsIHk6IFQsIGRpcmVjdGlvbjogeyBmcm9tOiAkLmRpcmVjdGlvbiwgdG86IHcuZGlyZWN0aW9uIH0sIHJhZGl1czogXyB9O1xuICAgICAgICAgIHN3aXRjaCAoZi5wdXNoKHsgdHlwZTogXCJjb3JuZXJcIiwgZGF0YTogRSB9KSwgdy5kaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIGNhc2UgXCJyaWdodFwiOlxuICAgICAgICAgICAgICB3LnggKz0gXywgdy5zaXplIC09IF87XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImxlZnRcIjpcbiAgICAgICAgICAgICAgdy54IC09IF8sIHcuc2l6ZSAtPSBfO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJkb3duXCI6XG4gICAgICAgICAgICAgIHcueSArPSBfLCB3LnNpemUgLT0gXztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwidXBcIjpcbiAgICAgICAgICAgICAgdy55IC09IF8sIHcuc2l6ZSAtPSBfO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGYucHVzaCh7IHR5cGU6IFwibGluZVwiLCBkYXRhOiAkIH0pO1xuICAgICAgfVxuICAgICAgY29uc3QgayA9IHZbdi5sZW5ndGggLSAxXTtcbiAgICAgIGlmIChrLmRpcmVjdGlvbiA9PT0gXCJyaWdodFwiIHx8IGsuZGlyZWN0aW9uID09PSBcImxlZnRcIikge1xuICAgICAgICBrLnNpemUgLT0gMyAqIG0gLyA0O1xuICAgICAgICBsZXQgeCA9IGsuZGlyZWN0aW9uID09PSBcInJpZ2h0XCIgPyBrLnggKyBrLnNpemUgOiBrLnggLSBrLnNpemUgLSBtIC8gMiwgJCA9IGsueSAtIGIubGlua19saW5lX3dpZHRoIC8gMiAtIG0gLyAyICsgMTtcbiAgICAgICAgay5kaXJlY3Rpb24gPT09IFwibGVmdFwiID8gKCQgLT0gMSwgeCAtPSAyKSA6IHggLT0gMTtcbiAgICAgICAgY29uc3QgdyA9IHsgeCwgeTogJCwgc2l6ZTogbSwgZGlyZWN0aW9uOiBrLmRpcmVjdGlvbiB9O1xuICAgICAgICBmLnB1c2goeyB0eXBlOiBcImxpbmVcIiwgZGF0YTogayB9KSwgZi5wdXNoKHsgdHlwZTogXCJhcnJvd1wiLCBkYXRhOiB3IH0pO1xuICAgICAgfSBlbHNlIGYucHVzaCh7IHR5cGU6IFwibGluZVwiLCBkYXRhOiBrIH0pO1xuICAgICAgcmV0dXJuIGY7XG4gICAgfShlLmdldF9saW5lcyh1LCByKS5maWx0ZXIoKHYpID0+IHYuc2l6ZSA+IDApLCBzKSwgZyA9IGZ1bmN0aW9uKHYsIGIsIF8sIG0pIHtcbiAgICAgIGNvbnN0IGYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgcmV0dXJuIHYuZm9yRWFjaCgoaykgPT4ge1xuICAgICAgICBsZXQgeDtcbiAgICAgICAgay50eXBlID09PSBcImxpbmVcIiA/IHggPSBlLnJlbmRlcl9saW5lKGsuZGF0YSwgbnVsbCwgYiwgXy5zb3VyY2UpIDogay50eXBlID09PSBcImNvcm5lclwiID8geCA9IGUucmVuZGVyX2Nvcm5lcihrLmRhdGEsIGIpIDogay50eXBlID09PSBcImFycm93XCIgJiYgKHggPSBlLnJlbmRlcl9hcnJvdyhrLmRhdGEsIG0pKSwgZi5hcHBlbmRDaGlsZCh4KTtcbiAgICAgIH0pLCBmO1xuICAgIH0oaCwgciwgYSwgcyk7XG4gICAgdmFyIHAgPSBcImdhbnR0X3Rhc2tfbGlua1wiO1xuICAgIGEuY29sb3IgJiYgKHAgKz0gXCIgZ2FudHRfbGlua19pbmxpbmVfY29sb3JcIik7XG4gICAgdmFyIHkgPSB0LnRlbXBsYXRlcy5saW5rX2NsYXNzID8gdC50ZW1wbGF0ZXMubGlua19jbGFzcyhhKSA6IFwiXCI7XG4gICAgcmV0dXJuIHkgJiYgKHAgKz0gXCIgXCIgKyB5KSwgcy5oaWdobGlnaHRfY3JpdGljYWxfcGF0aCAmJiB0LmlzQ3JpdGljYWxMaW5rICYmIHQuaXNDcml0aWNhbExpbmsoYSkgJiYgKHAgKz0gXCIgZ2FudHRfY3JpdGljYWxfbGlua1wiKSwgZy5jbGFzc05hbWUgPSBwLCByLiRjb25maWcubGlua19hdHRyaWJ1dGUgJiYgKGcuc2V0QXR0cmlidXRlKHIuJGNvbmZpZy5saW5rX2F0dHJpYnV0ZSwgYS5pZCksIGcuc2V0QXR0cmlidXRlKFwibGlua19pZFwiLCBhLmlkKSksIGEuY29sb3IgJiYgZy5zdHlsZS5zZXRQcm9wZXJ0eShcIi0tZGh4LWdhbnR0LWxpbmstYmFja2dyb3VuZFwiLCBhLmNvbG9yKSwgdC5fd2FpQXJpYS5saW5rQXR0cihhLCBnKSwgZztcbiAgfSwgdXBkYXRlOiBudWxsLCBpc0luVmlld1BvcnQ6IHZuLCBnZXRWaXNpYmxlUmFuZ2U6IG1uKCkgfTtcbn1cbmZ1bmN0aW9uIE1hKHQsIGUsIG4sIGksIGEpIHtcbiAgaWYgKGEuJHVpLmdldFZpZXcoXCJncmlkXCIpICYmIChhLmNvbmZpZy5rZXlib2FyZF9uYXZpZ2F0aW9uICYmIGEuZ2V0U2VsZWN0ZWRJZCgpIHx8IGEuZXh0LmlubGluZUVkaXRvcnMgJiYgYS5leHQuaW5saW5lRWRpdG9ycy5nZXRTdGF0ZSgpLmlkKSkgcmV0dXJuICEhdC4kZXhwYW5kZWRfYnJhbmNoO1xuICB2YXIgciA9IG4uZ2V0SXRlbVRvcCh0LmlkKSwgcyA9IG4uZ2V0SXRlbUhlaWdodCh0LmlkKTtcbiAgcmV0dXJuICEociA+IGUueV9lbmQgfHwgciArIHMgPCBlLnkpO1xufVxuZnVuY3Rpb24gTmEodCkge1xuICBsZXQgZSA9IHt9O1xuICByZXR1cm4gdC4kZGF0YS50YXNrc1N0b3JlLmF0dGFjaEV2ZW50KFwib25TdG9yZVVwZGF0ZWRcIiwgZnVuY3Rpb24oKSB7XG4gICAgZSA9IHt9O1xuICB9KSwgZnVuY3Rpb24obiwgaSwgYSwgcikge1xuICAgIGNvbnN0IHMgPSBuLmlkICsgXCJfXCIgKyBpICsgXCJfXCIgKyBhLnVuaXQgKyBcIl9cIiArIGEuc3RlcDtcbiAgICBsZXQgbztcbiAgICByZXR1cm4gbyA9IGVbc10gPyBlW3NdIDogZVtzXSA9IGZ1bmN0aW9uKGwsIGQsIGMsIHUpIHtcbiAgICAgIGxldCBoLCBnID0gITEsIHAgPSB7fTtcbiAgICAgIHQuY29uZmlnLnByb2Nlc3NfcmVzb3VyY2VfYXNzaWdubWVudHMgJiYgZCA9PT0gdC5jb25maWcucmVzb3VyY2VfcHJvcGVydHkgPyAoaCA9IGwuJHJvbGUgPT0gXCJ0YXNrXCIgPyB0LmdldFJlc291cmNlQXNzaWdubWVudHMobC4kcmVzb3VyY2VfaWQsIGwuJHRhc2tfaWQpIDogdC5nZXRSZXNvdXJjZUFzc2lnbm1lbnRzKGwuaWQpLCBnID0gITApIDogaCA9IGwuJHJvbGUgPT0gXCJ0YXNrXCIgPyBbXSA6IHQuZ2V0VGFza0J5KGQsIGwuaWQpLCBwID0gZnVuY3Rpb24odywgUywgVCkge1xuICAgICAgICBjb25zdCBFID0gUy51bml0LCBDID0gUy5zdGVwLCBEID0ge30sIE0gPSB7fTtcbiAgICAgICAgZm9yIChsZXQgSSA9IDA7IEkgPCB3Lmxlbmd0aDsgSSsrKSB7XG4gICAgICAgICAgY29uc3QgQSA9IHdbSV07XG4gICAgICAgICAgbGV0IE4gPSBBO1xuICAgICAgICAgIGlmIChUICYmIChOID0gdC5nZXRUYXNrKEEudGFza19pZCkpLCBOLnVuc2NoZWR1bGVkKSBjb250aW51ZTtcbiAgICAgICAgICBsZXQgTCA9IEEuc3RhcnRfZGF0ZSB8fCBOLnN0YXJ0X2RhdGUsIE8gPSBBLmVuZF9kYXRlIHx8IE4uZW5kX2RhdGU7XG4gICAgICAgICAgVCAmJiAoQS5zdGFydF9kYXRlICYmIChMID0gbmV3IERhdGUoTWF0aC5tYXgoQS5zdGFydF9kYXRlLnZhbHVlT2YoKSwgTi5zdGFydF9kYXRlLnZhbHVlT2YoKSkpKSwgQS5lbmRfZGF0ZSAmJiAoTyA9IG5ldyBEYXRlKE1hdGgubWluKEEuZW5kX2RhdGUudmFsdWVPZigpLCBOLmVuZF9kYXRlLnZhbHVlT2YoKSkpKSwgQS5tb2RlICYmIEEubW9kZSA9PSBcImZpeGVkRGF0ZXNcIiAmJiAoTCA9IEEuc3RhcnRfZGF0ZSwgTyA9IEEuZW5kX2RhdGUpKTtcbiAgICAgICAgICBsZXQgRyA9IEF0KFMudHJhY2VfeCwgTC52YWx1ZU9mKCkpLCBqID0gbmV3IERhdGUoUy50cmFjZV94W0ddIHx8IHQuZGF0ZVtFICsgXCJfc3RhcnRcIl0obmV3IERhdGUoTCkpKSwgSCA9IG5ldyBEYXRlKE1hdGgubWluKEwudmFsdWVPZigpLCBqLnZhbHVlT2YoKSkpLCBRID0gdC5jb25maWcud29ya190aW1lID8gdC5nZXRUYXNrQ2FsZW5kYXIoTikgOiB0O1xuICAgICAgICAgIGZvciAoTVtRLmlkXSA9IHt9OyBIIDwgTzsgKSB7XG4gICAgICAgICAgICBjb25zdCBKID0gTVtRLmlkXSwgQiA9IEgudmFsdWVPZigpO1xuICAgICAgICAgICAgSCA9IHQuZGF0ZS5hZGQoSCwgQywgRSksIEpbQl0gIT09ICExICYmIChEW0JdIHx8IChEW0JdID0geyB0YXNrczogW10sIGFzc2lnbm1lbnRzOiBbXSB9KSwgRFtCXS50YXNrcy5wdXNoKE4pLCBUICYmIERbQl0uYXNzaWdubWVudHMucHVzaChBKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBEO1xuICAgICAgfShoLCBjLCBnKTtcbiAgICAgIGNvbnN0IHkgPSBjLnVuaXQsIHYgPSBjLnN0ZXAsIGIgPSBbXTtcbiAgICAgIGxldCBfLCBtLCBmLCBrLCB4O1xuICAgICAgY29uc3QgJCA9IHUuJGdldENvbmZpZygpO1xuICAgICAgZm9yIChsZXQgdyA9IDA7IHcgPCBjLnRyYWNlX3gubGVuZ3RoOyB3KyspIF8gPSBuZXcgRGF0ZShjLnRyYWNlX3hbd10pLCBtID0gdC5kYXRlLmFkZChfLCB2LCB5KSwgeCA9IHBbXy52YWx1ZU9mKCldIHx8IHt9LCBmID0geC50YXNrcyB8fCBbXSwgayA9IHguYXNzaWdubWVudHMgfHwgW10sIGYubGVuZ3RoIHx8ICQucmVzb3VyY2VfcmVuZGVyX2VtcHR5X2NlbGxzID8gYi5wdXNoKHsgc3RhcnRfZGF0ZTogXywgZW5kX2RhdGU6IG0sIHRhc2tzOiBmLCBhc3NpZ25tZW50czogayB9KSA6IGIucHVzaChudWxsKTtcbiAgICAgIHJldHVybiBiO1xuICAgIH0obiwgaSwgYSwgciksIG87XG4gIH07XG59XG5jb25zdCBMYSA9IHsgaW5pdDogZnVuY3Rpb24odCwgZSkge1xuICB2YXIgbiA9IHQuJHNlcnZpY2VzLmdldFNlcnZpY2UoXCJkbmRcIik7XG4gIGlmIChlLiRjb25maWcuYmluZCAmJiB0LmdldERhdGFzdG9yZShlLiRjb25maWcuYmluZCkpIHtcbiAgICB2YXIgaSA9IG5ldyBuKGUuJGdyaWRfZGF0YSwgeyB1cGRhdGVzX3Blcl9zZWNvbmQ6IDYwIH0pO1xuICAgIHQuZGVmaW5lZChlLiRnZXRDb25maWcoKS5kbmRfc2Vuc2l0aXZpdHkpICYmIChpLmNvbmZpZy5zZW5zaXRpdml0eSA9IGUuJGdldENvbmZpZygpLmRuZF9zZW5zaXRpdml0eSksIGkuYXR0YWNoRXZlbnQoXCJvbkJlZm9yZURyYWdTdGFydFwiLCB0LmJpbmQoZnVuY3Rpb24obywgbCkge1xuICAgICAgdmFyIGQgPSBhKGwpO1xuICAgICAgaWYgKCFkIHx8ICh0LmhpZGVRdWlja0luZm8gJiYgdC5oaWRlUXVpY2tJbmZvKCksIGN0KGwudGFyZ2V0LCBcIi5nYW50dF9ncmlkX2VkaXRvcl9wbGFjZWhvbGRlclwiKSkpIHJldHVybiAhMTtcbiAgICAgIHZhciBjID0gZC5nZXRBdHRyaWJ1dGUoZS4kY29uZmlnLml0ZW1fYXR0cmlidXRlKTtcbiAgICAgIGlmIChzKGMpKSByZXR1cm4gITE7XG4gICAgICB2YXIgdSA9IHIoKS5nZXRJdGVtKGMpO1xuICAgICAgcmV0dXJuICF0LmlzUmVhZG9ubHkodSkgJiYgKGkuY29uZmlnLmluaXRpYWxfb3Blbl9zdGF0ZSA9IHUuJG9wZW4sICEhdC5jYWxsRXZlbnQoXCJvblJvd0RyYWdTdGFydFwiLCBbYywgbC50YXJnZXQgfHwgbC5zcmNFbGVtZW50LCBsXSkgJiYgdm9pZCAwKTtcbiAgICB9LCB0KSksIGkuYXR0YWNoRXZlbnQoXCJvbkFmdGVyRHJhZ1N0YXJ0XCIsIHQuYmluZChmdW5jdGlvbihvLCBsKSB7XG4gICAgICB2YXIgZCA9IGEobCk7XG4gICAgICBpLmNvbmZpZy5tYXJrZXIuaW5uZXJIVE1MID0gZC5vdXRlckhUTUw7XG4gICAgICB2YXIgYyA9IGkuY29uZmlnLm1hcmtlci5maXJzdENoaWxkO1xuICAgICAgYyAmJiAoYy5zdHlsZS5wb3NpdGlvbiA9IFwic3RhdGljXCIpLCBpLmNvbmZpZy5pZCA9IGQuZ2V0QXR0cmlidXRlKGUuJGNvbmZpZy5pdGVtX2F0dHJpYnV0ZSk7XG4gICAgICB2YXIgdSA9IHIoKSwgaCA9IHUuZ2V0SXRlbShpLmNvbmZpZy5pZCk7XG4gICAgICBpLmNvbmZpZy5pbmRleCA9IHUuZ2V0QnJhbmNoSW5kZXgoaS5jb25maWcuaWQpLCBpLmNvbmZpZy5wYXJlbnQgPSBoLnBhcmVudCwgaC4kb3BlbiA9ICExLCBoLiR0cmFuc3BhcmVudCA9ICEwLCB0aGlzLnJlZnJlc2hEYXRhKCk7XG4gICAgfSwgdCkpLCBpLmxhc3RUYXNrT2ZMZXZlbCA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgIGZvciAodmFyIGwgPSBudWxsLCBkID0gcigpLmdldEl0ZW1zKCksIGMgPSAwLCB1ID0gZC5sZW5ndGg7IGMgPCB1OyBjKyspIGRbY10uJGxldmVsID09IG8gJiYgKGwgPSBkW2NdKTtcbiAgICAgIHJldHVybiBsID8gbC5pZCA6IG51bGw7XG4gICAgfSwgaS5fZ2V0R3JpZFBvcyA9IHQuYmluZChmdW5jdGlvbihvKSB7XG4gICAgICB2YXIgbCA9IFYoZS4kZ3JpZF9kYXRhKSwgZCA9IGwueCArIGUuJGdyaWQuc2Nyb2xsTGVmdCwgYyA9IG8ucG9zLnkgLSAxMCwgdSA9IGUuZ2V0SXRlbUhlaWdodChpLmNvbmZpZy5pZCk7XG4gICAgICBjIDwgbC55ICYmIChjID0gbC55KTtcbiAgICAgIHZhciBoID0gZS5nZXRUb3RhbEhlaWdodCgpO1xuICAgICAgYyA+IGwueSArIGggLSB1ICYmIChjID0gbC55ICsgaCAtIHUpO1xuICAgICAgY29uc3QgZyA9IGwueSArIGwuaGVpZ2h0O1xuICAgICAgcmV0dXJuIGMgPiBnIC0gdSAmJiAoYyA9IGcgLSB1KSwgbC54ID0gZCwgbC55ID0gYywgbDtcbiAgICB9LCB0KSwgaS5fZ2V0VGFyZ2V0WSA9IHQuYmluZChmdW5jdGlvbihvKSB7XG4gICAgICB2YXIgbCA9IFYoZS4kZ3JpZF9kYXRhKSwgZCA9IGUuJHN0YXRlLnNjcm9sbFRvcCB8fCAwLCBjID0gdC4kZ3JpZF9kYXRhLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCArIGQsIHUgPSBvLnBhZ2VZIC0gbC55ICsgZDtcbiAgICAgIHJldHVybiB1ID4gYyA/IHUgPSBjIDogdSA8IGQgJiYgKHUgPSBkKSwgdTtcbiAgICB9LCB0KSwgaS5fZ2V0VGFza0J5WSA9IHQuYmluZChmdW5jdGlvbihvLCBsKSB7XG4gICAgICB2YXIgZCA9IHIoKTtcbiAgICAgIG8gPSBvIHx8IDA7XG4gICAgICB2YXIgYyA9IGUuZ2V0SXRlbUluZGV4QnlUb3BQb3NpdGlvbihvKTtcbiAgICAgIHJldHVybiAoYyA9IGwgPCBjID8gYyAtIDEgOiBjKSA+IGQuY291bnRWaXNpYmxlKCkgLSAxID8gbnVsbCA6IGQuZ2V0SWRCeUluZGV4KGMpO1xuICAgIH0sIHQpLCBpLmF0dGFjaEV2ZW50KFwib25EcmFnTW92ZVwiLCB0LmJpbmQoZnVuY3Rpb24obywgbCkge1xuICAgICAgdmFyIGQgPSB0LiRncmlkX2RhdGEuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGMgPSBkLmhlaWdodCArIGQueSArIChlLiRzdGF0ZS5zY3JvbGxUb3AgfHwgMCkgKyB3aW5kb3cuc2Nyb2xsWSwgdSA9IGkuY29uZmlnLCBoID0gaS5fZ2V0R3JpZFBvcyhsKTtcbiAgICAgIHQuX3dhaUFyaWEucmVvcmRlck1hcmtlckF0dHIodS5tYXJrZXIpO1xuICAgICAgdmFyIGcgPSBlLiRnZXRDb25maWcoKSwgcCA9IHIoKTtcbiAgICAgIGgueSA8IGMgPyB1Lm1hcmtlci5zdHlsZS50b3AgPSBoLnkgKyBcInB4XCIgOiB1Lm1hcmtlci5zdHlsZS50b3AgPSBjICsgXCJweFwiLCB1Lm1hcmtlci5zdHlsZS5sZWZ0ID0gaC54ICsgMTAgKyBcInB4XCI7XG4gICAgICBjb25zdCB5ID0gVih0LiRyb290KTtcbiAgICAgIGgud2lkdGggPiB5LndpZHRoICYmICh1Lm1hcmtlci5zdHlsZS53aWR0aCA9IHkud2lkdGggLSAxMCAtIDIgKyBcInB4XCIsIHUubWFya2VyLnN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIik7XG4gICAgICB2YXIgdiA9IHAuZ2V0SXRlbShpLmNvbmZpZy5pZCksIGIgPSBpLl9nZXRUYXJnZXRZKGwpLCBfID0gaS5fZ2V0VGFza0J5WShiLCBwLmdldEluZGV4QnlJZCh2LmlkKSk7XG4gICAgICBmdW5jdGlvbiBtKEQsIE0pIHtcbiAgICAgICAgcmV0dXJuICFwLmlzQ2hpbGRPZihmLmlkLCBNLmlkKSAmJiAoRC4kbGV2ZWwgPT0gTS4kbGV2ZWwgfHwgZy5vcmRlcl9icmFuY2hfZnJlZSk7XG4gICAgICB9XG4gICAgICBpZiAocC5leGlzdHMoXykgfHwgKF8gPSBpLmxhc3RUYXNrT2ZMZXZlbChnLm9yZGVyX2JyYW5jaF9mcmVlID8gdi4kbGV2ZWwgOiAwKSkgPT0gaS5jb25maWcuaWQgJiYgKF8gPSBudWxsKSwgcC5leGlzdHMoXykpIHtcbiAgICAgICAgdmFyIGYgPSBwLmdldEl0ZW0oXyksIGsgPSBlLmdldEl0ZW1Ub3AoZi5pZCksIHggPSBlLmdldEl0ZW1IZWlnaHQoZi5pZCk7XG4gICAgICAgIGlmIChrICsgeCAvIDIgPCBiKSB7XG4gICAgICAgICAgdmFyICQgPSBwLmdldEluZGV4QnlJZChmLmlkKSwgdyA9IHAuZ2V0TmV4dChmLmlkKSwgUyA9IHAuZ2V0SXRlbSh3KTtcbiAgICAgICAgICBpZiAocyh3KSkge1xuICAgICAgICAgICAgdmFyIFQgPSBwLmdldFByZXYoUy5pZCk7XG4gICAgICAgICAgICBTID0gcC5nZXRJdGVtKFQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoUykge1xuICAgICAgICAgICAgaWYgKFMuaWQgPT0gdi5pZCkgcmV0dXJuIGcub3JkZXJfYnJhbmNoX2ZyZWUgJiYgcC5pc0NoaWxkT2Yodi5pZCwgZi5pZCkgJiYgcC5nZXRDaGlsZHJlbihmLmlkKS5sZW5ndGggPT0gMSA/IHZvaWQgcC5tb3ZlKHYuaWQsIHAuZ2V0QnJhbmNoSW5kZXgoZi5pZCkgKyAxLCBwLmdldFBhcmVudChmLmlkKSkgOiB2b2lkIDA7XG4gICAgICAgICAgICBmID0gUztcbiAgICAgICAgICB9IGVsc2UgaWYgKHcgPSBwLmdldElkQnlJbmRleCgkKSwgUyA9IHAuZ2V0SXRlbSh3KSwgcyh3KSAmJiAoVCA9IHAuZ2V0UHJldihTLmlkKSwgUyA9IHAuZ2V0SXRlbShUKSksIG0oUywgdikgJiYgUy5pZCAhPSB2LmlkKSByZXR1cm4gdm9pZCBwLm1vdmUodi5pZCwgLTEsIHAuZ2V0UGFyZW50KFMuaWQpKTtcbiAgICAgICAgfSBlbHNlIGlmIChnLm9yZGVyX2JyYW5jaF9mcmVlICYmIGYuaWQgIT0gdi5pZCAmJiBtKGYsIHYpICYmICFzKGYuaWQpKSB7XG4gICAgICAgICAgaWYgKCFwLmhhc0NoaWxkKGYuaWQpKSByZXR1cm4gZi4kb3BlbiA9ICEwLCB2b2lkIHAubW92ZSh2LmlkLCAtMSwgZi5pZCk7XG4gICAgICAgICAgaWYgKHAuZ2V0SW5kZXhCeUlkKGYuaWQpIHx8IHggLyAzIDwgYikgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgICQgPSBwLmdldEluZGV4QnlJZChmLmlkKSwgVCA9IHAuZ2V0SWRCeUluZGV4KCQgLSAxKTtcbiAgICAgICAgZm9yICh2YXIgRSA9IHAuZ2V0SXRlbShUKSwgQyA9IDE7ICghRSB8fCBFLmlkID09IGYuaWQpICYmICQgLSBDID49IDA7ICkgVCA9IHAuZ2V0SWRCeUluZGV4KCQgLSBDKSwgRSA9IHAuZ2V0SXRlbShUKSwgQysrO1xuICAgICAgICBpZiAodi5pZCA9PSBmLmlkIHx8IHMoZi5pZCkpIHJldHVybjtcbiAgICAgICAgbShmLCB2KSAmJiB2LmlkICE9IGYuaWQgPyBwLm1vdmUodi5pZCwgMCwgMCwgZi5pZCkgOiBmLiRsZXZlbCAhPSB2LiRsZXZlbCAtIDEgfHwgcC5nZXRDaGlsZHJlbihmLmlkKS5sZW5ndGggPyBFICYmIG0oRSwgdikgJiYgdi5pZCAhPSBFLmlkICYmIHAubW92ZSh2LmlkLCAtMSwgcC5nZXRQYXJlbnQoRS5pZCkpIDogcC5tb3ZlKHYuaWQsIDAsIGYuaWQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuICEwO1xuICAgIH0sIHQpKSwgaS5hdHRhY2hFdmVudChcIm9uRHJhZ0VuZFwiLCB0LmJpbmQoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbyA9IHIoKSwgbCA9IG8uZ2V0SXRlbShpLmNvbmZpZy5pZCk7XG4gICAgICBsLiR0cmFuc3BhcmVudCA9ICExLCBsLiRvcGVuID0gaS5jb25maWcuaW5pdGlhbF9vcGVuX3N0YXRlLCB0aGlzLmNhbGxFdmVudChcIm9uQmVmb3JlUm93RHJhZ0VuZFwiLCBbaS5jb25maWcuaWQsIGkuY29uZmlnLnBhcmVudCwgaS5jb25maWcuaW5kZXhdKSA9PT0gITEgPyAoby5tb3ZlKGkuY29uZmlnLmlkLCBpLmNvbmZpZy5pbmRleCwgaS5jb25maWcucGFyZW50KSwgbC4kZHJvcF90YXJnZXQgPSBudWxsKSA6IHRoaXMuY2FsbEV2ZW50KFwib25Sb3dEcmFnRW5kXCIsIFtpLmNvbmZpZy5pZCwgbC4kZHJvcF90YXJnZXRdKSwgdC5yZW5kZXIoKSwgdGhpcy5yZWZyZXNoRGF0YSgpO1xuICAgIH0sIHQpKTtcbiAgfVxuICBmdW5jdGlvbiBhKG8pIHtcbiAgICByZXR1cm4gZXQobywgZS4kY29uZmlnLml0ZW1fYXR0cmlidXRlKTtcbiAgfVxuICBmdW5jdGlvbiByKCkge1xuICAgIHJldHVybiB0LmdldERhdGFzdG9yZShlLiRjb25maWcuYmluZCk7XG4gIH1cbiAgZnVuY3Rpb24gcyhvKSB7XG4gICAgcmV0dXJuIFJ0KG8sIHQsIHIoKSk7XG4gIH1cbn0gfSwgSyA9IHsgY3JlYXRlRHJvcFRhcmdldE9iamVjdDogZnVuY3Rpb24odCkge1xuICB2YXIgZSA9IHsgdGFyZ2V0UGFyZW50OiBudWxsLCB0YXJnZXRJbmRleDogMCwgdGFyZ2V0SWQ6IG51bGwsIGNoaWxkOiAhMSwgbmV4dFNpYmxpbmc6ICExLCBwcmV2U2libGluZzogITEgfTtcbiAgcmV0dXJuIHQgJiYgUChlLCB0LCAhMCksIGU7XG59LCBuZXh0U2libGluZ1RhcmdldDogZnVuY3Rpb24odCwgZSwgbikge1xuICB2YXIgaSA9IHRoaXMuY3JlYXRlRHJvcFRhcmdldE9iamVjdCgpO1xuICByZXR1cm4gaS50YXJnZXRJZCA9IGUsIGkubmV4dFNpYmxpbmcgPSAhMCwgaS50YXJnZXRQYXJlbnQgPSBuLmdldFBhcmVudChpLnRhcmdldElkKSwgaS50YXJnZXRJbmRleCA9IG4uZ2V0QnJhbmNoSW5kZXgoaS50YXJnZXRJZCksIChuLmdldFBhcmVudCh0KSAhPSBpLnRhcmdldFBhcmVudCB8fCBpLnRhcmdldEluZGV4IDwgbi5nZXRCcmFuY2hJbmRleCh0KSkgJiYgKGkudGFyZ2V0SW5kZXggKz0gMSksIGk7XG59LCBwcmV2U2libGluZ1RhcmdldDogZnVuY3Rpb24odCwgZSwgbikge1xuICB2YXIgaSA9IHRoaXMuY3JlYXRlRHJvcFRhcmdldE9iamVjdCgpO1xuICByZXR1cm4gaS50YXJnZXRJZCA9IGUsIGkucHJldlNpYmxpbmcgPSAhMCwgaS50YXJnZXRQYXJlbnQgPSBuLmdldFBhcmVudChpLnRhcmdldElkKSwgaS50YXJnZXRJbmRleCA9IG4uZ2V0QnJhbmNoSW5kZXgoaS50YXJnZXRJZCksIG4uZ2V0UGFyZW50KHQpID09IGkudGFyZ2V0UGFyZW50ICYmIGkudGFyZ2V0SW5kZXggPiBuLmdldEJyYW5jaEluZGV4KHQpICYmIChpLnRhcmdldEluZGV4IC09IDEpLCBpO1xufSwgZmlyc3RDaGlsZFRhcmdldDogZnVuY3Rpb24odCwgZSwgbikge1xuICB2YXIgaSA9IHRoaXMuY3JlYXRlRHJvcFRhcmdldE9iamVjdCgpO1xuICByZXR1cm4gaS50YXJnZXRJZCA9IGUsIGkudGFyZ2V0UGFyZW50ID0gaS50YXJnZXRJZCwgaS50YXJnZXRJbmRleCA9IDAsIGkuY2hpbGQgPSAhMCwgaTtcbn0sIGxhc3RDaGlsZFRhcmdldDogZnVuY3Rpb24odCwgZSwgbikge1xuICB2YXIgaSA9IG4uZ2V0Q2hpbGRyZW4oZSksIGEgPSB0aGlzLmNyZWF0ZURyb3BUYXJnZXRPYmplY3QoKTtcbiAgcmV0dXJuIGEudGFyZ2V0SWQgPSBpW2kubGVuZ3RoIC0gMV0sIGEudGFyZ2V0UGFyZW50ID0gZSwgYS50YXJnZXRJbmRleCA9IGkubGVuZ3RoLCBhLm5leHRTaWJsaW5nID0gITAsIGE7XG59IH07XG5mdW5jdGlvbiB4bih0LCBlLCBuLCBpLCBhKSB7XG4gIGZvciAodmFyIHIgPSBlOyBpLmV4aXN0cyhyKTsgKSB7XG4gICAgdmFyIHMgPSBpLmNhbGN1bGF0ZUl0ZW1MZXZlbChpLmdldEl0ZW0ocikpO1xuICAgIGlmICgocyA9PT0gbiB8fCBzID09PSBuIC0gMSkgJiYgaS5nZXRCcmFuY2hJbmRleChyKSA+IC0xKSBicmVhaztcbiAgICByID0gYSA/IGkuZ2V0UHJldihyKSA6IGkuZ2V0TmV4dChyKTtcbiAgfVxuICByZXR1cm4gaS5leGlzdHMocikgPyBpLmNhbGN1bGF0ZUl0ZW1MZXZlbChpLmdldEl0ZW0ocikpID09PSBuID8gYSA/IEsubmV4dFNpYmxpbmdUYXJnZXQodCwgciwgaSkgOiBLLnByZXZTaWJsaW5nVGFyZ2V0KHQsIHIsIGkpIDogSy5maXJzdENoaWxkVGFyZ2V0KHQsIHIsIGkpIDogbnVsbDtcbn1cbmZ1bmN0aW9uIGxlKHQsIGUsIG4sIGkpIHtcbiAgcmV0dXJuIHhuKHQsIGUsIG4sIGksICEwKTtcbn1cbmZ1bmN0aW9uIEdlKHQsIGUsIG4sIGkpIHtcbiAgcmV0dXJuIHhuKHQsIGUsIG4sIGksICExKTtcbn1cbmZ1bmN0aW9uIFllKHQsIGUsIG4sIGksIGEsIHIpIHtcbiAgdmFyIHM7XG4gIGlmIChlICE9PSBhLiRnZXRSb290SWQoKSkge1xuICAgIHZhciBvID0gYS5nZXRJdGVtKGUpLCBsID0gYS5jYWxjdWxhdGVJdGVtTGV2ZWwobyk7XG4gICAgaWYgKGwgPT09IHIpIHtcbiAgICAgIHZhciBkID0gYS5nZXRQcmV2U2libGluZyhlKTtcbiAgICAgIG4gPCAwLjUgJiYgIWQgPyBzID0gSy5wcmV2U2libGluZ1RhcmdldCh0LCBlLCBhKSA6IChuIDwgMC41ICYmIChlID0gZCksIHMgPSBLLm5leHRTaWJsaW5nVGFyZ2V0KHQsIGUsIGEpKTtcbiAgICB9IGVsc2UgaWYgKGwgPiByKSBhLmVhY2hQYXJlbnQoZnVuY3Rpb24ocCkge1xuICAgICAgYS5jYWxjdWxhdGVJdGVtTGV2ZWwocCkgPT09IHIgJiYgKGUgPSBwLmlkKTtcbiAgICB9LCBvKSwgcyA9IGxlKHQsIGUsIHIsIGEpO1xuICAgIGVsc2Uge1xuICAgICAgdmFyIGMgPSBsZSh0LCBlLCByLCBhKSwgdSA9IEdlKHQsIGUsIHIsIGEpO1xuICAgICAgcyA9IG4gPCAwLjUgPyBjIDogdTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGggPSBhLiRnZXRSb290SWQoKSwgZyA9IGEuZ2V0Q2hpbGRyZW4oaCk7XG4gICAgcyA9IEsuY3JlYXRlRHJvcFRhcmdldE9iamVjdCgpLCBzID0gZy5sZW5ndGggJiYgaSA+PSAwID8gbGUodCwgZnVuY3Rpb24ocCkge1xuICAgICAgZm9yICh2YXIgeSA9IHAuZ2V0TmV4dCgpOyBwLmV4aXN0cyh5KTsgKSB7XG4gICAgICAgIHZhciB2ID0gcC5nZXROZXh0KHkpO1xuICAgICAgICBpZiAoIXAuZXhpc3RzKHYpKSByZXR1cm4geTtcbiAgICAgICAgeSA9IHY7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9KGEpLCByLCBhKSA6IEdlKHQsIGgsIHIsIGEpO1xuICB9XG4gIHJldHVybiBzO1xufVxuZnVuY3Rpb24gSmUodCwgZSkge1xuICB2YXIgbiA9IFYoZS4kZ3JpZF9kYXRhKTtcbiAgcmV0dXJuIHQueCArPSBuLnggKyBlLiRncmlkLnNjcm9sbExlZnQsIHQueSArPSBuLnkgLSBlLiRncmlkX2RhdGEuc2Nyb2xsVG9wLCB0O1xufVxuZnVuY3Rpb24gZGUodCwgZSwgbiA9IDApIHtcbiAgY29uc3QgaSA9IFYodC4kcm9vdCk7XG4gIHJldHVybiBlID4gaS53aWR0aCAmJiAoZSA9IGkud2lkdGggLSBuIC0gMiksIGU7XG59XG5jb25zdCBLZSA9IHsgcmVtb3ZlTGluZUhpZ2hsaWdodDogZnVuY3Rpb24odCkge1xuICB0Lm1hcmtlckxpbmUgJiYgdC5tYXJrZXJMaW5lLnBhcmVudE5vZGUgJiYgdC5tYXJrZXJMaW5lLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodC5tYXJrZXJMaW5lKSwgdC5tYXJrZXJMaW5lID0gbnVsbDtcbn0sIGhpZ2hsaWdodFBvc2l0aW9uOiBmdW5jdGlvbih0LCBlLCBuKSB7XG4gIHZhciBpID0gZnVuY3Rpb24ociwgcykge1xuICAgIHZhciBvID0gVihzLiRncmlkX2RhdGEpLCBsID0gcnQociwgcy4kZ3JpZF9kYXRhKSwgZCA9IG8ueCArIHMuJGdyaWQuc2Nyb2xsTGVmdCwgYyA9IGwueSAtIDEwLCB1ID0gcy5nZXRJdGVtSGVpZ2h0KHIudGFyZ2V0SWQpO1xuICAgIGMgPCBvLnkgJiYgKGMgPSBvLnkpO1xuICAgIHZhciBoID0gcy5nZXRUb3RhbEhlaWdodCgpO1xuICAgIHJldHVybiBjID4gby55ICsgaCAtIHUgJiYgKGMgPSBvLnkgKyBoIC0gdSksIG8ueCA9IGQsIG8ueSA9IGMsIG8ud2lkdGggPSBkZShzLiRnYW50dCwgby53aWR0aCwgOSksIG87XG4gIH0odCwgbik7XG4gIGUubWFya2VyLnN0eWxlLmxlZnQgPSBpLnggKyA5ICsgXCJweFwiLCBlLm1hcmtlci5zdHlsZS53aWR0aCA9IGkud2lkdGggKyBcInB4XCIsIGUubWFya2VyLnN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcbiAgdmFyIGEgPSBlLm1hcmtlckxpbmU7XG4gIGEgfHwgKChhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSkuY2xhc3NOYW1lID0gXCJnYW50dF9kcmFnX21hcmtlciBnYW50dF9ncmlkX2RuZF9tYXJrZXJcIiwgYS5pbm5lckhUTUwgPSBcIjxkaXYgY2xhc3M9J2dhbnR0X2dyaWRfZG5kX21hcmtlcl9saW5lJz48L2Rpdj5cIiwgYS5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJub25lXCIpLCB0LmNoaWxkID8gZnVuY3Rpb24ociwgcywgbykge1xuICAgIHZhciBsID0gci50YXJnZXRQYXJlbnQsIGQgPSBKZSh7IHg6IDAsIHk6IG8uZ2V0SXRlbVRvcChsKSB9LCBvKSwgYyA9IG8uJGdyaWRfZGF0YS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5ib3R0b20gKyB3aW5kb3cuc2Nyb2xsWTtcbiAgICBsZXQgdSA9IGRlKG8uJGdhbnR0LCBvLiRncmlkX2RhdGEub2Zmc2V0V2lkdGgpO1xuICAgIHMuaW5uZXJIVE1MID0gXCI8ZGl2IGNsYXNzPSdnYW50dF9ncmlkX2RuZF9tYXJrZXJfZm9sZGVyJz48L2Rpdj5cIiwgcy5zdHlsZS53aWR0aCA9IHUgKyBcInB4XCIsIHMuc3R5bGUudG9wID0gZC55ICsgXCJweFwiLCBzLnN0eWxlLmxlZnQgPSBkLnggKyBcInB4XCIsIHMuc3R5bGUuaGVpZ2h0ID0gby5nZXRJdGVtSGVpZ2h0KGwpICsgXCJweFwiLCBkLnkgPiBjICYmIChzLnN0eWxlLnRvcCA9IGMgKyBcInB4XCIpO1xuICB9KHQsIGEsIG4pIDogZnVuY3Rpb24ociwgcywgbykge1xuICAgIHZhciBsID0gZnVuY3Rpb24odSwgaCkge1xuICAgICAgdmFyIGcgPSBoLiRjb25maWcucm93U3RvcmUsIHAgPSB7IHg6IDAsIHk6IDAgfSwgeSA9IGguJGdyaWRfZGF0YS5xdWVyeVNlbGVjdG9yKFwiLmdhbnR0X3RyZWVfaW5kZW50XCIpLCB2ID0gMTUsIGIgPSAwO1xuICAgICAgeSAmJiAodiA9IHkub2Zmc2V0V2lkdGgpO1xuICAgICAgdmFyIF8gPSA0MDtcbiAgICAgIGlmICh1LnRhcmdldElkICE9PSBnLiRnZXRSb290SWQoKSkge1xuICAgICAgICB2YXIgbSA9IGguZ2V0SXRlbVRvcCh1LnRhcmdldElkKSwgZiA9IGguZ2V0SXRlbUhlaWdodCh1LnRhcmdldElkKTtcbiAgICAgICAgaWYgKGIgPSBnLmV4aXN0cyh1LnRhcmdldElkKSA/IGcuY2FsY3VsYXRlSXRlbUxldmVsKGcuZ2V0SXRlbSh1LnRhcmdldElkKSkgOiAwLCB1LnByZXZTaWJsaW5nKSBwLnkgPSBtO1xuICAgICAgICBlbHNlIGlmICh1Lm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgdmFyIGsgPSAwO1xuICAgICAgICAgIGcuZWFjaEl0ZW0oZnVuY3Rpb24oeCkge1xuICAgICAgICAgICAgZy5nZXRJbmRleEJ5SWQoeC5pZCkgIT09IC0xICYmIGsrKztcbiAgICAgICAgICB9LCB1LnRhcmdldElkKSwgcC55ID0gbSArIGYgKyBrICogZjtcbiAgICAgICAgfSBlbHNlIHAueSA9IG0gKyBmLCBiICs9IDE7XG4gICAgICB9XG4gICAgICByZXR1cm4gcC54ID0gXyArIGIgKiB2LCBwLndpZHRoID0gZGUoaC4kZ2FudHQsIE1hdGgubWF4KGguJGdyaWRfZGF0YS5vZmZzZXRXaWR0aCAtIHAueCwgMCksIHAueCksIEplKHAsIGgpO1xuICAgIH0ociwgbyksIGQgPSBvLiRncmlkX2RhdGEuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuYm90dG9tICsgd2luZG93LnNjcm9sbFk7XG4gICAgcy5pbm5lckhUTUwgPSBcIjxkaXYgY2xhc3M9J2dhbnR0X2dyaWRfZG5kX21hcmtlcl9saW5lJz48L2Rpdj5cIiwgcy5zdHlsZS5sZWZ0ID0gbC54ICsgXCJweFwiLCBzLnN0eWxlLmhlaWdodCA9IFwiNHB4XCI7XG4gICAgdmFyIGMgPSBsLnkgLSAyO1xuICAgIHMuc3R5bGUudG9wID0gYyArIFwicHhcIiwgcy5zdHlsZS53aWR0aCA9IGwud2lkdGggKyBcInB4XCIsIGMgPiBkICYmIChzLnN0eWxlLnRvcCA9IGQgKyBcInB4XCIpO1xuICB9KHQsIGEsIG4pLCBlLm1hcmtlckxpbmUgfHwgKGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoYSksIGUubWFya2VyTGluZSA9IGEpO1xufSB9LCBQYSA9IHsgaW5pdDogZnVuY3Rpb24odCwgZSkge1xuICB2YXIgbiA9IHQuJHNlcnZpY2VzLmdldFNlcnZpY2UoXCJkbmRcIik7XG4gIGlmIChlLiRjb25maWcuYmluZCAmJiB0LmdldERhdGFzdG9yZShlLiRjb25maWcuYmluZCkpIHtcbiAgICB2YXIgaSA9IG5ldyBuKGUuJGdyaWRfZGF0YSwgeyB1cGRhdGVzX3Blcl9zZWNvbmQ6IDYwIH0pO1xuICAgIHQuZGVmaW5lZChlLiRnZXRDb25maWcoKS5kbmRfc2Vuc2l0aXZpdHkpICYmIChpLmNvbmZpZy5zZW5zaXRpdml0eSA9IGUuJGdldENvbmZpZygpLmRuZF9zZW5zaXRpdml0eSksIGkuYXR0YWNoRXZlbnQoXCJvbkJlZm9yZURyYWdTdGFydFwiLCB0LmJpbmQoZnVuY3Rpb24obywgbCkge1xuICAgICAgdmFyIGQgPSBhKGwpO1xuICAgICAgaWYgKCFkIHx8ICh0LmhpZGVRdWlja0luZm8gJiYgdC5oaWRlUXVpY2tJbmZvKCksIGN0KGwudGFyZ2V0LCBcIi5nYW50dF9ncmlkX2VkaXRvcl9wbGFjZWhvbGRlclwiKSkpIHJldHVybiAhMTtcbiAgICAgIHZhciBjID0gZC5nZXRBdHRyaWJ1dGUoZS4kY29uZmlnLml0ZW1fYXR0cmlidXRlKSwgdSA9IGUuJGNvbmZpZy5yb3dTdG9yZS5nZXRJdGVtKGMpO1xuICAgICAgcmV0dXJuICF0LmlzUmVhZG9ubHkodSkgJiYgIXIoYykgJiYgKGkuY29uZmlnLmluaXRpYWxfb3Blbl9zdGF0ZSA9IHUuJG9wZW4sICEhdC5jYWxsRXZlbnQoXCJvblJvd0RyYWdTdGFydFwiLCBbYywgbC50YXJnZXQgfHwgbC5zcmNFbGVtZW50LCBsXSkgJiYgdm9pZCAwKTtcbiAgICB9LCB0KSksIGkuYXR0YWNoRXZlbnQoXCJvbkFmdGVyRHJhZ1N0YXJ0XCIsIHQuYmluZChmdW5jdGlvbihvLCBsKSB7XG4gICAgICB2YXIgZCA9IGEobCk7XG4gICAgICBpLmNvbmZpZy5tYXJrZXIuaW5uZXJIVE1MID0gZC5vdXRlckhUTUw7XG4gICAgICB2YXIgYyA9IGkuY29uZmlnLm1hcmtlci5maXJzdENoaWxkO1xuICAgICAgYyAmJiAoaS5jb25maWcubWFya2VyLnN0eWxlLm9wYWNpdHkgPSAwLjQsIGMuc3R5bGUucG9zaXRpb24gPSBcInN0YXRpY1wiLCBjLnN0eWxlLnBvaW50ZXJFdmVudHMgPSBcIm5vbmVcIiksIGkuY29uZmlnLmlkID0gZC5nZXRBdHRyaWJ1dGUoZS4kY29uZmlnLml0ZW1fYXR0cmlidXRlKTtcbiAgICAgIHZhciB1ID0gZS4kY29uZmlnLnJvd1N0b3JlLCBoID0gdS5nZXRJdGVtKGkuY29uZmlnLmlkKTtcbiAgICAgIGkuY29uZmlnLmxldmVsID0gdS5jYWxjdWxhdGVJdGVtTGV2ZWwoaCksIGkuY29uZmlnLmRyb3BfdGFyZ2V0ID0gSy5jcmVhdGVEcm9wVGFyZ2V0T2JqZWN0KHsgdGFyZ2V0UGFyZW50OiB1LmdldFBhcmVudChoLmlkKSwgdGFyZ2V0SW5kZXg6IHUuZ2V0QnJhbmNoSW5kZXgoaC5pZCksIHRhcmdldElkOiBoLmlkLCBuZXh0U2libGluZzogITAgfSksIGguJG9wZW4gPSAhMSwgaC4kdHJhbnNwYXJlbnQgPSAhMCwgdGhpcy5yZWZyZXNoRGF0YSgpO1xuICAgIH0sIHQpKSwgaS5hdHRhY2hFdmVudChcIm9uRHJhZ01vdmVcIiwgdC5iaW5kKGZ1bmN0aW9uKG8sIGwpIHtcbiAgICAgIHZhciBkID0gcyhsKTtcbiAgICAgIHJldHVybiBkICYmIHQuY2FsbEV2ZW50KFwib25CZWZvcmVSb3dEcmFnTW92ZVwiLCBbaS5jb25maWcuaWQsIGQudGFyZ2V0UGFyZW50LCBkLnRhcmdldEluZGV4XSkgIT09ICExIHx8IChkID0gSy5jcmVhdGVEcm9wVGFyZ2V0T2JqZWN0KGkuY29uZmlnLmRyb3BfdGFyZ2V0KSksIEtlLmhpZ2hsaWdodFBvc2l0aW9uKGQsIGkuY29uZmlnLCBlKSwgaS5jb25maWcuZHJvcF90YXJnZXQgPSBkLCB0Ll93YWlBcmlhLnJlb3JkZXJNYXJrZXJBdHRyKGkuY29uZmlnLm1hcmtlciksIHRoaXMuY2FsbEV2ZW50KFwib25Sb3dEcmFnTW92ZVwiLCBbaS5jb25maWcuaWQsIGQudGFyZ2V0UGFyZW50LCBkLnRhcmdldEluZGV4XSksICEwO1xuICAgIH0sIHQpKSwgaS5hdHRhY2hFdmVudChcIm9uRHJhZ0VuZFwiLCB0LmJpbmQoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbyA9IGUuJGNvbmZpZy5yb3dTdG9yZSwgbCA9IG8uZ2V0SXRlbShpLmNvbmZpZy5pZCk7XG4gICAgICBLZS5yZW1vdmVMaW5lSGlnaGxpZ2h0KGkuY29uZmlnKSwgbC4kdHJhbnNwYXJlbnQgPSAhMSwgbC4kb3BlbiA9IGkuY29uZmlnLmluaXRpYWxfb3Blbl9zdGF0ZTtcbiAgICAgIHZhciBkID0gaS5jb25maWcuZHJvcF90YXJnZXQ7XG4gICAgICB0aGlzLmNhbGxFdmVudChcIm9uQmVmb3JlUm93RHJhZ0VuZFwiLCBbaS5jb25maWcuaWQsIGQudGFyZ2V0UGFyZW50LCBkLnRhcmdldEluZGV4XSkgPT09ICExID8gbC4kZHJvcF90YXJnZXQgPSBudWxsIDogKG8ubW92ZShpLmNvbmZpZy5pZCwgZC50YXJnZXRJbmRleCwgZC50YXJnZXRQYXJlbnQpLCB0LnJlbmRlcigpLCB0aGlzLmNhbGxFdmVudChcIm9uUm93RHJhZ0VuZFwiLCBbaS5jb25maWcuaWQsIGQudGFyZ2V0UGFyZW50LCBkLnRhcmdldEluZGV4XSkpLCBvLnJlZnJlc2gobC5pZCk7XG4gICAgfSwgdCkpO1xuICB9XG4gIGZ1bmN0aW9uIGEobykge1xuICAgIHJldHVybiBldChvLCBlLiRjb25maWcuaXRlbV9hdHRyaWJ1dGUpO1xuICB9XG4gIGZ1bmN0aW9uIHIobykge1xuICAgIHJldHVybiBSdChvLCB0LCB0LmdldERhdGFzdG9yZShlLiRjb25maWcuYmluZCkpO1xuICB9XG4gIGZ1bmN0aW9uIHMobykge1xuICAgIHZhciBsLCBkID0gZnVuY3Rpb24ocCkge1xuICAgICAgdmFyIHkgPSBydChwLCBlLiRncmlkX2RhdGEpLnksIHYgPSBlLiRjb25maWcucm93U3RvcmU7XG4gICAgICBkb2N1bWVudC5kb2N0eXBlIHx8ICh5ICs9IHdpbmRvdy5zY3JvbGxZKSwgeSA9IHkgfHwgMDtcbiAgICAgIHZhciBiID0gZS4kc3RhdGUuc2Nyb2xsVG9wIHx8IDAsIF8gPSB0LiRncmlkX2RhdGEuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0ICsgYiArIHdpbmRvdy5zY3JvbGxZLCBtID0gYiwgZiA9IGUuZ2V0SXRlbUluZGV4QnlUb3BQb3NpdGlvbihlLiRzdGF0ZS5zY3JvbGxUb3ApO1xuICAgICAgaWYgKHYuZXhpc3RzKGYpIHx8IChmID0gdi5jb3VudFZpc2libGUoKSAtIDEpLCBmIDwgMCkgcmV0dXJuIHYuJGdldFJvb3RJZCgpO1xuICAgICAgdmFyIGsgPSB2LmdldElkQnlJbmRleChmKSwgeCA9IGUuJHN0YXRlLnNjcm9sbFRvcCAvIGUuZ2V0SXRlbUhlaWdodChrKSwgJCA9IHggLSBNYXRoLmZsb29yKHgpO1xuICAgICAgJCA+IDAuMSAmJiAkIDwgMC45ICYmIChfIC09IGUuZ2V0SXRlbUhlaWdodChrKSAqICQsIG0gKz0gZS5nZXRJdGVtSGVpZ2h0KGspICogKDEgLSAkKSk7XG4gICAgICBjb25zdCB3ID0gVihlLiRncmlkX2RhdGEpLCBTID0gdy55ICsgdy5oZWlnaHQsIFQgPSBpLmNvbmZpZy5tYXJrZXIub2Zmc2V0SGVpZ2h0O1xuICAgICAgeSArIFQgKyB3aW5kb3cuc2Nyb2xsWSA+PSBfICYmIChpLmNvbmZpZy5tYXJrZXIuc3R5bGUudG9wID0gUyAtIFQgKyBcInB4XCIpLCB5ID49IF8gPyB5ID0gXyA6IHkgPD0gbSAmJiAoeSA9IG0sIGkuY29uZmlnLm1hcmtlci5zdHlsZS50b3AgPSB3LnkgKyBcInB4XCIpO1xuICAgICAgdmFyIEUgPSBlLmdldEl0ZW1JbmRleEJ5VG9wUG9zaXRpb24oeSk7XG4gICAgICBpZiAoRSA+IHYuY291bnRWaXNpYmxlKCkgLSAxIHx8IEUgPCAwKSByZXR1cm4gdi4kZ2V0Um9vdElkKCk7XG4gICAgICB2YXIgQyA9IHYuZ2V0SWRCeUluZGV4KEUpO1xuICAgICAgcmV0dXJuIHIoQykgPyB2LmdldFByZXZTaWJsaW5nKEMpIDogdi5nZXRJZEJ5SW5kZXgoRSk7XG4gICAgfShvKSwgYyA9IG51bGwsIHUgPSBlLiRjb25maWcucm93U3RvcmUsIGggPSAhZS4kZ2V0Q29uZmlnKCkub3JkZXJfYnJhbmNoX2ZyZWUsIGcgPSBydChvLCBlLiRncmlkX2RhdGEpLnk7XG4gICAgcmV0dXJuIGRvY3VtZW50LmRvY3R5cGUgfHwgKGcgKz0gd2luZG93LnNjcm9sbFkpLCBkICE9PSB1LiRnZXRSb290SWQoKSAmJiAoYyA9IChnIC0gZS5nZXRJdGVtVG9wKGQpKSAvIGUuZ2V0SXRlbUhlaWdodChkKSksIGggPyAobCA9IFllKGkuY29uZmlnLmlkLCBkLCBjLCBnLCB1LCBpLmNvbmZpZy5sZXZlbCkpICYmIGwudGFyZ2V0UGFyZW50ICYmIHIobC50YXJnZXRQYXJlbnQpICYmIChkID0gdS5nZXRQcmV2U2libGluZyhsLnRhcmdldFBhcmVudCksIGwgPSBZZShpLmNvbmZpZy5pZCwgZCwgYywgZywgdSwgaS5jb25maWcubGV2ZWwpKSA6IGwgPSBmdW5jdGlvbihwLCB5LCB2LCBiLCBfKSB7XG4gICAgICB2YXIgbTtcbiAgICAgIGlmICh5ICE9PSBfLiRnZXRSb290SWQoKSkgbSA9IHYgPCAwLjI1ID8gSy5wcmV2U2libGluZ1RhcmdldChwLCB5LCBfKSA6ICEodiA+IDAuNikgfHwgXy5oYXNDaGlsZCh5KSAmJiBfLmdldEl0ZW0oeSkuJG9wZW4gPyBLLmZpcnN0Q2hpbGRUYXJnZXQocCwgeSwgXykgOiBLLm5leHRTaWJsaW5nVGFyZ2V0KHAsIHksIF8pO1xuICAgICAgZWxzZSB7XG4gICAgICAgIHZhciBmID0gXy4kZ2V0Um9vdElkKCk7XG4gICAgICAgIG0gPSBfLmhhc0NoaWxkKGYpICYmIGIgPj0gMCA/IEsubGFzdENoaWxkVGFyZ2V0KHAsIGYsIF8pIDogSy5maXJzdENoaWxkVGFyZ2V0KHAsIGYsIF8pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG07XG4gICAgfShpLmNvbmZpZy5pZCwgZCwgYywgZywgdSksIGw7XG4gIH1cbn0gfTtcbnZhciBSYSA9IGZ1bmN0aW9uKHQpIHtcbiAgcmV0dXJuIHsgb25DcmVhdGVkOiBmdW5jdGlvbihlKSB7XG4gICAgZS4kY29uZmlnID0gUChlLiRjb25maWcsIHsgYmluZDogXCJ0YXNrXCIgfSksIGUuJGNvbmZpZy5pZCA9PSBcImdyaWRcIiAmJiAodGhpcy5leHRlbmRHYW50dChlKSwgdC5leHQuaW5saW5lRWRpdG9ycyA9IHQuZXh0Ll9pbmxpbmVFZGl0b3JzLmNyZWF0ZUVkaXRvcnMoZSksIHQuZXh0LmlubGluZUVkaXRvcnMuaW5pdCgpKSwgdGhpcy5fbW91c2VEZWxlZ2F0ZXMgPSBUZSh0KTtcbiAgfSwgb25Jbml0aWFsaXplZDogZnVuY3Rpb24oZSkge1xuICAgIHZhciBuID0gZS4kZ2V0Q29uZmlnKCk7XG4gICAgbi5vcmRlcl9icmFuY2ggJiYgKG4ub3JkZXJfYnJhbmNoID09IFwibWFya2VyXCIgPyBQYS5pbml0KGUuJGdhbnR0LCBlKSA6IExhLmluaXQoZS4kZ2FudHQsIGUpKSwgdGhpcy5pbml0RXZlbnRzKGUsIHQpLCBlLiRjb25maWcuaWQgPT0gXCJncmlkXCIgJiYgdGhpcy5leHRlbmREb20oZSk7XG4gIH0sIG9uRGVzdHJveWVkOiBmdW5jdGlvbihlKSB7XG4gICAgZS4kY29uZmlnLmlkID09IFwiZ3JpZFwiICYmIHQuZXh0LmlubGluZUVkaXRvcnMuZGV0YWNoU3RvcmUoKSwgdGhpcy5jbGVhckV2ZW50cyhlLCB0KTtcbiAgfSwgaW5pdEV2ZW50czogZnVuY3Rpb24oZSwgbikge1xuICAgIHRoaXMuX21vdXNlRGVsZWdhdGVzLmRlbGVnYXRlKFwiY2xpY2tcIiwgXCJnYW50dF9yb3dcIiwgbi5iaW5kKGZ1bmN0aW9uKGksIGEsIHIpIHtcbiAgICAgIGNvbnN0IHMgPSBlLiRnZXRDb25maWcoKTtcbiAgICAgIGlmIChhICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IG8gPSB0aGlzLmdldFRhc2soYSk7XG4gICAgICAgIGlmIChzLnNjcm9sbF9vbl9jbGljaykge1xuICAgICAgICAgIGNvbnN0IGwgPSAhbi5faXNfaWNvbl9vcGVuX2NsaWNrKGkpLCBkID0gbi4kdWkuZ2V0VmlldyhcInRpbWVsaW5lXCIpO1xuICAgICAgICAgIGwgJiYgZCAmJiB0aGlzLnNob3dEYXRlKG8uc3RhcnRfZGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgbi5jYWxsRXZlbnQoXCJvblRhc2tSb3dDbGlja1wiLCBbYSwgcl0pO1xuICAgICAgfVxuICAgIH0sIG4pLCBlLiRncmlkKSwgdGhpcy5fbW91c2VEZWxlZ2F0ZXMuZGVsZWdhdGUoXCJjbGlja1wiLCBcImdhbnR0X2dyaWRfaGVhZF9jZWxsXCIsIG4uYmluZChmdW5jdGlvbihpLCBhLCByKSB7XG4gICAgICB2YXIgcyA9IHIuZ2V0QXR0cmlidXRlKFwiZGF0YS1jb2x1bW4taWRcIik7XG4gICAgICBpZiAobi5jYWxsRXZlbnQoXCJvbkdyaWRIZWFkZXJDbGlja1wiLCBbcywgaV0pKSB7XG4gICAgICAgIHZhciBvID0gZS4kZ2V0Q29uZmlnKCk7XG4gICAgICAgIGlmIChzICE9IFwiYWRkXCIpIHtcbiAgICAgICAgICBpZiAoby5zb3J0ICYmIHMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGwsIGQgPSBzLCBjID0gMDsgYyA8IG8uY29sdW1ucy5sZW5ndGg7IGMrKykgaWYgKG8uY29sdW1uc1tjXS5uYW1lID09IHMpIHtcbiAgICAgICAgICAgICAgbCA9IG8uY29sdW1uc1tjXTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobCAmJiBsLnNvcnQgIT09IHZvaWQgMCAmJiBsLnNvcnQgIT09ICEwICYmICEoZCA9IGwuc29ydCkpIHJldHVybjtcbiAgICAgICAgICAgIHZhciB1ID0gdGhpcy5fc29ydCAmJiB0aGlzLl9zb3J0LmRpcmVjdGlvbiAmJiB0aGlzLl9zb3J0Lm5hbWUgPT0gcyA/IHRoaXMuX3NvcnQuZGlyZWN0aW9uIDogXCJkZXNjXCI7XG4gICAgICAgICAgICB1ID0gdSA9PSBcImRlc2NcIiA/IFwiYXNjXCIgOiBcImRlc2NcIiwgdGhpcy5fc29ydCA9IHsgbmFtZTogcywgZGlyZWN0aW9uOiB1IH0sIHRoaXMuc29ydChkLCB1ID09IFwiZGVzY1wiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBuLiRzZXJ2aWNlcy5nZXRTZXJ2aWNlKFwibW91c2VFdmVudHNcIikuY2FsbEhhbmRsZXIoXCJjbGlja1wiLCBcImdhbnR0X2FkZFwiLCBlLiRncmlkLCBbaSwgby5yb290X2lkXSk7XG4gICAgICB9XG4gICAgfSwgbiksIGUuJGdyaWQpLCB0aGlzLl9tb3VzZURlbGVnYXRlcy5kZWxlZ2F0ZShcImNsaWNrXCIsIFwiZ2FudHRfYWRkXCIsIG4uYmluZChmdW5jdGlvbihpLCBhLCByKSB7XG4gICAgICBpZiAoIWUuJGdldENvbmZpZygpLnJlYWRvbmx5KSByZXR1cm4gdGhpcy5jcmVhdGVUYXNrKHt9LCBhIHx8IG4uY29uZmlnLnJvb3RfaWQpLCAhMTtcbiAgICB9LCBuKSwgZS4kZ3JpZCk7XG4gIH0sIGNsZWFyRXZlbnRzOiBmdW5jdGlvbihlLCBuKSB7XG4gICAgdGhpcy5fbW91c2VEZWxlZ2F0ZXMuZGVzdHJ1Y3RvcigpLCB0aGlzLl9tb3VzZURlbGVnYXRlcyA9IG51bGw7XG4gIH0sIGV4dGVuZERvbTogZnVuY3Rpb24oZSkge1xuICAgIHQuJGdyaWQgPSBlLiRncmlkLCB0LiRncmlkX3NjYWxlID0gZS4kZ3JpZF9zY2FsZSwgdC4kZ3JpZF9kYXRhID0gZS4kZ3JpZF9kYXRhO1xuICB9LCBleHRlbmRHYW50dDogZnVuY3Rpb24oZSkge1xuICAgIHQuZ2V0R3JpZENvbHVtbnMgPSB0LmJpbmQoZS5nZXRHcmlkQ29sdW1ucywgZSksIGUuYXR0YWNoRXZlbnQoXCJvbkNvbHVtblJlc2l6ZVN0YXJ0XCIsIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHQuY2FsbEV2ZW50KFwib25Db2x1bW5SZXNpemVTdGFydFwiLCBhcmd1bWVudHMpO1xuICAgIH0pLCBlLmF0dGFjaEV2ZW50KFwib25Db2x1bW5SZXNpemVcIiwgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdC5jYWxsRXZlbnQoXCJvbkNvbHVtblJlc2l6ZVwiLCBhcmd1bWVudHMpO1xuICAgIH0pLCBlLmF0dGFjaEV2ZW50KFwib25Db2x1bW5SZXNpemVFbmRcIiwgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdC5jYWxsRXZlbnQoXCJvbkNvbHVtblJlc2l6ZUVuZFwiLCBhcmd1bWVudHMpO1xuICAgIH0pLCBlLmF0dGFjaEV2ZW50KFwib25Db2x1bW5SZXNpemVDb21wbGV0ZVwiLCBmdW5jdGlvbihuLCBpKSB7XG4gICAgICB0LmNvbmZpZy5ncmlkX3dpZHRoID0gaTtcbiAgICB9KSwgZS5hdHRhY2hFdmVudChcIm9uQmVmb3JlUm93UmVzaXplXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHQuY2FsbEV2ZW50KFwib25CZWZvcmVSb3dSZXNpemVcIiwgYXJndW1lbnRzKTtcbiAgICB9KSwgZS5hdHRhY2hFdmVudChcIm9uUm93UmVzaXplXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHQuY2FsbEV2ZW50KFwib25Sb3dSZXNpemVcIiwgYXJndW1lbnRzKTtcbiAgICB9KSwgZS5hdHRhY2hFdmVudChcIm9uQmVmb3JlUm93UmVzaXplRW5kXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHQuY2FsbEV2ZW50KFwib25CZWZvcmVSb3dSZXNpemVFbmRcIiwgYXJndW1lbnRzKTtcbiAgICB9KSwgZS5hdHRhY2hFdmVudChcIm9uQWZ0ZXJSb3dSZXNpemVcIiwgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdC5jYWxsRXZlbnQoXCJvbkFmdGVyUm93UmVzaXplXCIsIGFyZ3VtZW50cyk7XG4gICAgfSk7XG4gIH0gfTtcbn07XG5jb25zdCBIYSA9IHsgY3JlYXRlVGFza0RORDogZnVuY3Rpb24oKSB7XG4gIHZhciB0O1xuICByZXR1cm4geyBleHRlbmQ6IGZ1bmN0aW9uKGUpIHtcbiAgICBlLnJvdW5kVGFza0RhdGVzID0gZnVuY3Rpb24obikge1xuICAgICAgdC5yb3VuZF90YXNrX2RhdGVzKG4pO1xuICAgIH07XG4gIH0sIGluaXQ6IGZ1bmN0aW9uKGUsIG4pIHtcbiAgICByZXR1cm4gdCA9IGZ1bmN0aW9uKGksIGEpIHtcbiAgICAgIHZhciByID0gYS4kc2VydmljZXM7XG4gICAgICByZXR1cm4geyBkcmFnOiBudWxsLCBkcmFnTXVsdGlwbGU6IHt9LCBfZXZlbnRzOiB7IGJlZm9yZV9zdGFydDoge30sIGJlZm9yZV9maW5pc2g6IHt9LCBhZnRlcl9maW5pc2g6IHt9IH0sIF9oYW5kbGVyczoge30sIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9kb21FdmVudHMgPSBhLl9jcmVhdGVEb21FdmVudFNjb3BlKCksIHRoaXMuY2xlYXJfZHJhZ19zdGF0ZSgpO1xuICAgICAgICB2YXIgcyA9IGEuY29uZmlnLmRyYWdfbW9kZTtcbiAgICAgICAgdGhpcy5zZXRfYWN0aW9ucygpLCByLmdldFNlcnZpY2UoXCJzdGF0ZVwiKS5yZWdpc3RlclByb3ZpZGVyKFwidGFza3NEbmRcIiwgUihmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4geyBkcmFnX2lkOiB0aGlzLmRyYWcgPyB0aGlzLmRyYWcuaWQgOiB2b2lkIDAsIGRyYWdfbW9kZTogdGhpcy5kcmFnID8gdGhpcy5kcmFnLm1vZGUgOiB2b2lkIDAsIGRyYWdfZnJvbV9zdGFydDogdGhpcy5kcmFnID8gdGhpcy5kcmFnLmxlZnQgOiB2b2lkIDAgfTtcbiAgICAgICAgfSwgdGhpcykpO1xuICAgICAgICB2YXIgbyA9IHsgYmVmb3JlX3N0YXJ0OiBcIm9uQmVmb3JlVGFza0RyYWdcIiwgYmVmb3JlX2ZpbmlzaDogXCJvbkJlZm9yZVRhc2tDaGFuZ2VkXCIsIGFmdGVyX2ZpbmlzaDogXCJvbkFmdGVyVGFza0RyYWdcIiB9O1xuICAgICAgICBmb3IgKHZhciBsIGluIHRoaXMuX2V2ZW50cykgZm9yICh2YXIgZCBpbiBzKSB0aGlzLl9ldmVudHNbbF1bZF0gPSBvW2xdO1xuICAgICAgICB0aGlzLl9oYW5kbGVyc1tzLm1vdmVdID0gdGhpcy5fbW92ZSwgdGhpcy5faGFuZGxlcnNbcy5yZXNpemVdID0gdGhpcy5fcmVzaXplLCB0aGlzLl9oYW5kbGVyc1tzLnByb2dyZXNzXSA9IHRoaXMuX3Jlc2l6ZV9wcm9ncmVzcztcbiAgICAgIH0sIHNldF9hY3Rpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHMgPSBpLiR0YXNrX2RhdGE7XG4gICAgICAgIHRoaXMuX2RvbUV2ZW50cy5hdHRhY2gocywgXCJtb3VzZW1vdmVcIiwgYS5iaW5kKGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgICB0aGlzLm9uX21vdXNlX21vdmUobyk7XG4gICAgICAgIH0sIHRoaXMpKSwgdGhpcy5fZG9tRXZlbnRzLmF0dGFjaChzLCBcIm1vdXNlZG93blwiLCBhLmJpbmQoZnVuY3Rpb24obykge1xuICAgICAgICAgIHRoaXMub25fbW91c2VfZG93bihvKTtcbiAgICAgICAgfSwgdGhpcykpLCB0aGlzLl9kb21FdmVudHMuYXR0YWNoKGRvY3VtZW50LmJvZHksIFwibW91c2V1cFwiLCBhLmJpbmQoZnVuY3Rpb24obykge1xuICAgICAgICAgIHRoaXMub25fbW91c2VfdXAobyk7XG4gICAgICAgIH0sIHRoaXMpKTtcbiAgICAgIH0sIGNsZWFyX2RyYWdfc3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmRyYWcgPSB7IGlkOiBudWxsLCBtb2RlOiBudWxsLCBwb3M6IG51bGwsIHN0YXJ0X3g6IG51bGwsIHN0YXJ0X3k6IG51bGwsIG9iajogbnVsbCwgbGVmdDogbnVsbCB9LCB0aGlzLmRyYWdNdWx0aXBsZSA9IHt9O1xuICAgICAgfSwgX3Jlc2l6ZTogZnVuY3Rpb24ocywgbywgbCkge1xuICAgICAgICB2YXIgZCA9IGkuJGdldENvbmZpZygpLCBjID0gdGhpcy5fZHJhZ190YXNrX2Nvb3JkcyhzLCBsKTtcbiAgICAgICAgbC5sZWZ0ID8gKHMuc3RhcnRfZGF0ZSA9IGEuZGF0ZUZyb21Qb3MoYy5zdGFydCArIG8pLCBzLnN0YXJ0X2RhdGUgfHwgKHMuc3RhcnRfZGF0ZSA9IG5ldyBEYXRlKGEuZ2V0U3RhdGUoKS5taW5fZGF0ZSkpKSA6IChzLmVuZF9kYXRlID0gYS5kYXRlRnJvbVBvcyhjLmVuZCArIG8pLCBzLmVuZF9kYXRlIHx8IChzLmVuZF9kYXRlID0gbmV3IERhdGUoYS5nZXRTdGF0ZSgpLm1heF9kYXRlKSkpO1xuICAgICAgICB2YXIgdSA9IHRoaXMuX2NhbGN1bGF0ZU1pbkR1cmF0aW9uKGQubWluX2R1cmF0aW9uLCBkLmR1cmF0aW9uX3VuaXQpO1xuICAgICAgICBzLmVuZF9kYXRlIC0gcy5zdGFydF9kYXRlIDwgZC5taW5fZHVyYXRpb24gJiYgKGwubGVmdCA/IHMuc3RhcnRfZGF0ZSA9IGEuY2FsY3VsYXRlRW5kRGF0ZShzLmVuZF9kYXRlLCAtdSwgZC5kdXJhdGlvbl91bml0LCBzKSA6IHMuZW5kX2RhdGUgPSBhLmNhbGN1bGF0ZUVuZERhdGUocy5zdGFydF9kYXRlLCB1LCBkLmR1cmF0aW9uX3VuaXQsIHMpKSwgYS5faW5pdF90YXNrX3RpbWluZyhzKTtcbiAgICAgIH0sIF9jYWxjdWxhdGVNaW5EdXJhdGlvbjogZnVuY3Rpb24ocywgbykge1xuICAgICAgICByZXR1cm4gTWF0aC5jZWlsKHMgLyB7IG1pbnV0ZTogNmU0LCBob3VyOiAzNmU1LCBkYXk6IDg2NGU1LCB3ZWVrOiA2MDQ4ZTUsIG1vbnRoOiAyNDE5MmU1LCB5ZWFyOiAzMTM1NmU2IH1bb10pO1xuICAgICAgfSwgX3Jlc2l6ZV9wcm9ncmVzczogZnVuY3Rpb24ocywgbywgbCkge1xuICAgICAgICB2YXIgZCA9IHRoaXMuX2RyYWdfdGFza19jb29yZHMocywgbCksIGMgPSBpLiRnZXRDb25maWcoKS5ydGwgPyBkLnN0YXJ0IC0gbC5wb3MueCA6IGwucG9zLnggLSBkLnN0YXJ0LCB1ID0gTWF0aC5tYXgoMCwgYyk7XG4gICAgICAgIHMucHJvZ3Jlc3MgPSBNYXRoLm1pbigxLCB1IC8gTWF0aC5hYnMoZC5lbmQgLSBkLnN0YXJ0KSk7XG4gICAgICB9LCBfZmluZF9tYXhfc2hpZnQ6IGZ1bmN0aW9uKHMsIG8pIHtcbiAgICAgICAgdmFyIGw7XG4gICAgICAgIGZvciAodmFyIGQgaW4gcykge1xuICAgICAgICAgIHZhciBjID0gc1tkXSwgdSA9IGEuZ2V0VGFzayhjLmlkKTtcbiAgICAgICAgICBpZiAoIXUudW5zY2hlZHVsZWQpIHtcbiAgICAgICAgICAgIHZhciBoID0gdGhpcy5fZHJhZ190YXNrX2Nvb3Jkcyh1LCBjKSwgZyA9IGEucG9zRnJvbURhdGUobmV3IERhdGUoYS5nZXRTdGF0ZSgpLm1pbl9kYXRlKSksIHAgPSBhLnBvc0Zyb21EYXRlKG5ldyBEYXRlKGEuZ2V0U3RhdGUoKS5tYXhfZGF0ZSkpO1xuICAgICAgICAgICAgaWYgKGguZW5kICsgbyA+IHApIHtcbiAgICAgICAgICAgICAgdmFyIHkgPSBwIC0gaC5lbmQ7XG4gICAgICAgICAgICAgICh5IDwgbCB8fCBsID09PSB2b2lkIDApICYmIChsID0geSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGguc3RhcnQgKyBvIDwgZykge1xuICAgICAgICAgICAgICB2YXIgdiA9IGcgLSBoLnN0YXJ0O1xuICAgICAgICAgICAgICAodiA+IGwgfHwgbCA9PT0gdm9pZCAwKSAmJiAobCA9IHYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbDtcbiAgICAgIH0sIF9tb3ZlOiBmdW5jdGlvbihzLCBvLCBsLCBkKSB7XG4gICAgICAgIHZhciBjID0gdGhpcy5fZHJhZ190YXNrX2Nvb3JkcyhzLCBsKSwgdSA9IG51bGwsIGggPSBudWxsO1xuICAgICAgICBkID8gKHUgPSBuZXcgRGF0ZSgrbC5vYmouc3RhcnRfZGF0ZSArIGQpLCBoID0gbmV3IERhdGUoK2wub2JqLmVuZF9kYXRlICsgZCkpIDogKHUgPSBhLmRhdGVGcm9tUG9zKGMuc3RhcnQgKyBvKSwgaCA9IGEuZGF0ZUZyb21Qb3MoYy5lbmQgKyBvKSksIHUgPyBoID8gKHMuc3RhcnRfZGF0ZSA9IHUsIHMuZW5kX2RhdGUgPSBoKSA6IChzLmVuZF9kYXRlID0gbmV3IERhdGUoYS5nZXRTdGF0ZSgpLm1heF9kYXRlKSwgcy5zdGFydF9kYXRlID0gYS5kYXRlRnJvbVBvcyhhLnBvc0Zyb21EYXRlKHMuZW5kX2RhdGUpIC0gKGMuZW5kIC0gYy5zdGFydCkpKSA6IChzLnN0YXJ0X2RhdGUgPSBuZXcgRGF0ZShhLmdldFN0YXRlKCkubWluX2RhdGUpLCBzLmVuZF9kYXRlID0gYS5kYXRlRnJvbVBvcyhhLnBvc0Zyb21EYXRlKHMuc3RhcnRfZGF0ZSkgKyAoYy5lbmQgLSBjLnN0YXJ0KSkpO1xuICAgICAgfSwgX2RyYWdfdGFza19jb29yZHM6IGZ1bmN0aW9uKHMsIG8pIHtcbiAgICAgICAgcmV0dXJuIHsgc3RhcnQ6IG8ub2JqX3NfeCA9IG8ub2JqX3NfeCB8fCBhLnBvc0Zyb21EYXRlKHMuc3RhcnRfZGF0ZSksIGVuZDogby5vYmpfZV94ID0gby5vYmpfZV94IHx8IGEucG9zRnJvbURhdGUocy5lbmRfZGF0ZSkgfTtcbiAgICAgIH0sIF9tb3VzZV9wb3NpdGlvbl9jaGFuZ2U6IGZ1bmN0aW9uKHMsIG8pIHtcbiAgICAgICAgdmFyIGwgPSBzLnggLSBvLngsIGQgPSBzLnkgLSBvLnk7XG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQobCAqIGwgKyBkICogZCk7XG4gICAgICB9LCBfaXNfbnVtYmVyOiBmdW5jdGlvbihzKSB7XG4gICAgICAgIHJldHVybiAhaXNOYU4ocGFyc2VGbG9hdChzKSkgJiYgaXNGaW5pdGUocyk7XG4gICAgICB9LCBvbl9tb3VzZV9tb3ZlOiBmdW5jdGlvbihzKSB7XG4gICAgICAgIGlmICh0aGlzLmRyYWcuc3RhcnRfZHJhZykge1xuICAgICAgICAgIHZhciBvID0gcnQocywgYS4kdGFza19kYXRhKSwgbCA9IHRoaXMuZHJhZy5zdGFydF9kcmFnLnN0YXJ0X3gsIGQgPSB0aGlzLmRyYWcuc3RhcnRfZHJhZy5zdGFydF95O1xuICAgICAgICAgIChEYXRlLm5vdygpIC0gdGhpcy5kcmFnLnRpbWVzdGFtcCA+IDUwIHx8IHRoaXMuX2lzX251bWJlcihsKSAmJiB0aGlzLl9pc19udW1iZXIoZCkgJiYgdGhpcy5fbW91c2VfcG9zaXRpb25fY2hhbmdlKHsgeDogbCwgeTogZCB9LCBvKSA+IDIwKSAmJiB0aGlzLl9zdGFydF9kbmQocyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZHJhZy5tb2RlKSB7XG4gICAgICAgICAgaWYgKCFkbih0aGlzLCA0MCkpIHJldHVybjtcbiAgICAgICAgICB0aGlzLl91cGRhdGVfb25fbW92ZShzKTtcbiAgICAgICAgfVxuICAgICAgfSwgX3VwZGF0ZV9pdGVtX29uX21vdmU6IGZ1bmN0aW9uKHMsIG8sIGwsIGQsIGMsIHUpIHtcbiAgICAgICAgdmFyIGggPSBhLmdldFRhc2sobyksIGcgPSBhLm1peGluKHt9LCBoKSwgcCA9IGEubWl4aW4oe30sIGgpO1xuICAgICAgICB0aGlzLl9oYW5kbGVyc1tsXS5hcHBseSh0aGlzLCBbcCwgcywgZCwgdV0pLCBhLm1peGluKGgsIHAsICEwKSwgYS5jYWxsRXZlbnQoXCJvblRhc2tEcmFnXCIsIFtoLmlkLCBsLCBwLCBnLCBjXSksIGEubWl4aW4oaCwgcCwgITApLCBhLnJlZnJlc2hUYXNrKG8pO1xuICAgICAgfSwgX3VwZGF0ZV9vbl9tb3ZlOiBmdW5jdGlvbihzKSB7XG4gICAgICAgIHZhciBvID0gdGhpcy5kcmFnLCBsID0gaS4kZ2V0Q29uZmlnKCk7XG4gICAgICAgIGlmIChvLm1vZGUpIHtcbiAgICAgICAgICB2YXIgZCA9IHJ0KHMsIGkuJHRhc2tfZGF0YSk7XG4gICAgICAgICAgaWYgKG8ucG9zICYmIG8ucG9zLnggPT0gZC54KSByZXR1cm47XG4gICAgICAgICAgby5wb3MgPSBkO1xuICAgICAgICAgIHZhciBjID0gYS5kYXRlRnJvbVBvcyhkLngpO1xuICAgICAgICAgIGlmICghYyB8fCBpc05hTihjLmdldFRpbWUoKSkpIHJldHVybjtcbiAgICAgICAgICB2YXIgdSA9IGQueCAtIG8uc3RhcnRfeCwgaCA9IGEuZ2V0VGFzayhvLmlkKTtcbiAgICAgICAgICBpZiAodGhpcy5faGFuZGxlcnNbby5tb2RlXSkge1xuICAgICAgICAgICAgaWYgKG8ubW9kZSA9PT0gbC5kcmFnX21vZGUubW92ZSkge1xuICAgICAgICAgICAgICB2YXIgZyA9IHt9O1xuICAgICAgICAgICAgICB0aGlzLl9pc011bHRpc2VsZWN0KCkgJiYgYS5nZXRTZWxlY3RlZFRhc2tzKCkuaW5kZXhPZihvLmlkKSA+PSAwICYmIChnID0gdGhpcy5kcmFnTXVsdGlwbGUpO1xuICAgICAgICAgICAgICB2YXIgcCA9ICExO1xuICAgICAgICAgICAgICBpZiAoYS5pc1N1bW1hcnlUYXNrKGgpICYmIGEuY29uZmlnLmRyYWdfcHJvamVjdCkge1xuICAgICAgICAgICAgICAgIHZhciB5ID0ge307XG4gICAgICAgICAgICAgICAgeVtvLmlkXSA9IHEobyksIHAgPSAhMCwgZyA9IFAoeSwgdGhpcy5kcmFnTXVsdGlwbGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciB2ID0gdGhpcy5fZmluZF9tYXhfc2hpZnQoZywgdSk7XG4gICAgICAgICAgICAgIGxldCBtO1xuICAgICAgICAgICAgICBpZiAodiAhPT0gdm9pZCAwICYmICh1ID0gdiksIHRoaXMuX3VwZGF0ZV9pdGVtX29uX21vdmUodSwgby5pZCwgby5tb2RlLCBvLCBzKSwgdiA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZiA9IGEucG9zRnJvbURhdGUoby5vYmouc3RhcnRfZGF0ZSksIGsgPSBhLnBvc0Zyb21EYXRlKG8ub2JqLmVuZF9kYXRlKTtcbiAgICAgICAgICAgICAgICBpZiAoby5oYW5kbGVfb2Zmc2V0ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0ICQgPSBrIC0gZiwgdyA9IG8uc3RhcnRfeCAtIGY7XG4gICAgICAgICAgICAgICAgICBvLmhhbmRsZV9vZmZzZXQgPSB3IC8gJDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHggPSBmICsgTWF0aC5hYnMoayAtIGYpICogby5oYW5kbGVfb2Zmc2V0O1xuICAgICAgICAgICAgICAgIG0gPSBjIC0gYS5kYXRlRnJvbVBvcyh4KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmb3IgKHZhciBiIGluIGcpIHtcbiAgICAgICAgICAgICAgICB2YXIgXyA9IGdbYl07XG4gICAgICAgICAgICAgICAgcCAmJiBfLmlkICE9IG8uaWQgJiYgKGEuX2J1bGtfZG5kID0gITApLCB0aGlzLl91cGRhdGVfaXRlbV9vbl9tb3ZlKHUsIF8uaWQsIF8ubW9kZSwgXywgcywgbSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYS5fYnVsa19kbmQgPSAhMTtcbiAgICAgICAgICAgIH0gZWxzZSB0aGlzLl91cGRhdGVfaXRlbV9vbl9tb3ZlKHUsIG8uaWQsIG8ubW9kZSwgbywgcyk7XG4gICAgICAgICAgICBhLl91cGRhdGVfcGFyZW50cyhvLmlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIG9uX21vdXNlX2Rvd246IGZ1bmN0aW9uKHMsIG8pIHtcbiAgICAgICAgaWYgKHMuYnV0dG9uICE9IDIgfHwgcy5idXR0b24gPT09IHZvaWQgMCkge1xuICAgICAgICAgIHZhciBsID0gaS4kZ2V0Q29uZmlnKCksIGQgPSBhLmxvY2F0ZShzKSwgYyA9IG51bGw7XG4gICAgICAgICAgaWYgKGEuaXNUYXNrRXhpc3RzKGQpICYmIChjID0gYS5nZXRUYXNrKGQpKSwgIWEuaXNSZWFkb25seShjKSAmJiAhdGhpcy5kcmFnLm1vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJfZHJhZ19zdGF0ZSgpO1xuICAgICAgICAgICAgdmFyIHUgPSBYKG8gPSBvIHx8IHMudGFyZ2V0IHx8IHMuc3JjRWxlbWVudCksIGggPSB0aGlzLl9nZXRfZHJhZ19tb2RlKHUsIG8pO1xuICAgICAgICAgICAgaWYgKCF1IHx8ICFoKSByZXR1cm4gby5wYXJlbnROb2RlID8gdGhpcy5vbl9tb3VzZV9kb3duKHMsIG8ucGFyZW50Tm9kZSkgOiB2b2lkIDA7XG4gICAgICAgICAgICBpZiAoaCkgaWYgKGgubW9kZSAmJiBoLm1vZGUgIT0gbC5kcmFnX21vZGUuaWdub3JlICYmIGxbXCJkcmFnX1wiICsgaC5tb2RlXSkge1xuICAgICAgICAgICAgICBpZiAoZCA9IGEubG9jYXRlKG8pLCBjID0gYS5jb3B5KGEuZ2V0VGFzayhkKSB8fCB7fSksIGEuaXNSZWFkb25seShjKSkgcmV0dXJuIHRoaXMuY2xlYXJfZHJhZ19zdGF0ZSgpLCAhMTtcbiAgICAgICAgICAgICAgaWYgKGEuaXNTdW1tYXJ5VGFzayhjKSAmJiBjLmF1dG9fc2NoZWR1bGluZyAhPT0gITEgJiYgIWwuZHJhZ19wcm9qZWN0ICYmIGgubW9kZSAhPSBsLmRyYWdfbW9kZS5wcm9ncmVzcykgcmV0dXJuIHZvaWQgdGhpcy5jbGVhcl9kcmFnX3N0YXRlKCk7XG4gICAgICAgICAgICAgIGguaWQgPSBkO1xuICAgICAgICAgICAgICB2YXIgZyA9IHJ0KHMsIGEuJHRhc2tfZGF0YSk7XG4gICAgICAgICAgICAgIGguc3RhcnRfeCA9IGcueCwgaC5zdGFydF95ID0gZy55LCBoLm9iaiA9IGMsIHRoaXMuZHJhZy5zdGFydF9kcmFnID0gaCwgdGhpcy5kcmFnLnRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgICAgICAgICB9IGVsc2UgdGhpcy5jbGVhcl9kcmFnX3N0YXRlKCk7XG4gICAgICAgICAgICBlbHNlIGlmIChhLmNoZWNrRXZlbnQoXCJvbk1vdXNlRG93blwiKSAmJiBhLmNhbGxFdmVudChcIm9uTW91c2VEb3duXCIsIFt1LnNwbGl0KFwiIFwiKVswXV0pICYmIG8ucGFyZW50Tm9kZSkgcmV0dXJuIHRoaXMub25fbW91c2VfZG93bihzLCBvLnBhcmVudE5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgX2ZpeF9kbmRfc2NhbGVfdGltZTogZnVuY3Rpb24ocywgbykge1xuICAgICAgICB2YXIgbCA9IGkuJGdldENvbmZpZygpLCBkID0gYS5nZXRTY2FsZSgpLnVuaXQsIGMgPSBhLmdldFNjYWxlKCkuc3RlcDtcbiAgICAgICAgZnVuY3Rpb24gdShoKSB7XG4gICAgICAgICAgaWYgKGEuY29uZmlnLmNvcnJlY3Rfd29ya190aW1lKSB7XG4gICAgICAgICAgICB2YXIgZyA9IGkuJGdldENvbmZpZygpO1xuICAgICAgICAgICAgYS5pc1dvcmtUaW1lKGguc3RhcnRfZGF0ZSwgdm9pZCAwLCBoKSB8fCAoaC5zdGFydF9kYXRlID0gYS5jYWxjdWxhdGVFbmREYXRlKHsgc3RhcnRfZGF0ZTogaC5zdGFydF9kYXRlLCBkdXJhdGlvbjogLTEsIHVuaXQ6IGcuZHVyYXRpb25fdW5pdCwgdGFzazogaCB9KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGwucm91bmRfZG5kX2RhdGVzIHx8IChkID0gXCJtaW51dGVcIiwgYyA9IGwudGltZV9zdGVwKSwgby5tb2RlID09IGwuZHJhZ19tb2RlLnJlc2l6ZSA/IG8ubGVmdCA/IChzLnN0YXJ0X2RhdGUgPSBhLnJvdW5kRGF0ZSh7IGRhdGU6IHMuc3RhcnRfZGF0ZSwgdW5pdDogZCwgc3RlcDogYyB9KSwgdShzKSkgOiAocy5lbmRfZGF0ZSA9IGEucm91bmREYXRlKHsgZGF0ZTogcy5lbmRfZGF0ZSwgdW5pdDogZCwgc3RlcDogYyB9KSwgZnVuY3Rpb24oaCkge1xuICAgICAgICAgIGlmIChhLmNvbmZpZy5jb3JyZWN0X3dvcmtfdGltZSkge1xuICAgICAgICAgICAgdmFyIGcgPSBpLiRnZXRDb25maWcoKTtcbiAgICAgICAgICAgIGEuaXNXb3JrVGltZShuZXcgRGF0ZShoLmVuZF9kYXRlIC0gMSksIHZvaWQgMCwgaCkgfHwgKGguZW5kX2RhdGUgPSBhLmNhbGN1bGF0ZUVuZERhdGUoeyBzdGFydF9kYXRlOiBoLmVuZF9kYXRlLCBkdXJhdGlvbjogMSwgdW5pdDogZy5kdXJhdGlvbl91bml0LCB0YXNrOiBoIH0pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0ocykpIDogby5tb2RlID09IGwuZHJhZ19tb2RlLm1vdmUgJiYgKHMuc3RhcnRfZGF0ZSA9IGEucm91bmREYXRlKHsgZGF0ZTogcy5zdGFydF9kYXRlLCB1bml0OiBkLCBzdGVwOiBjIH0pLCB1KHMpLCBzLmVuZF9kYXRlID0gYS5jYWxjdWxhdGVFbmREYXRlKHMpKTtcbiAgICAgIH0sIF9maXhfd29ya2luZ190aW1lczogZnVuY3Rpb24ocywgbykge1xuICAgICAgICB2YXIgbCA9IGkuJGdldENvbmZpZygpO1xuICAgICAgICAobyA9IG8gfHwgeyBtb2RlOiBsLmRyYWdfbW9kZS5tb3ZlIH0pLm1vZGUgPT0gbC5kcmFnX21vZGUucmVzaXplID8gby5sZWZ0ID8gcy5zdGFydF9kYXRlID0gYS5nZXRDbG9zZXN0V29ya1RpbWUoeyBkYXRlOiBzLnN0YXJ0X2RhdGUsIGRpcjogXCJmdXR1cmVcIiwgdGFzazogcyB9KSA6IHMuZW5kX2RhdGUgPSBhLmdldENsb3Nlc3RXb3JrVGltZSh7IGRhdGU6IHMuZW5kX2RhdGUsIGRpcjogXCJwYXN0XCIsIHRhc2s6IHMgfSkgOiBvLm1vZGUgPT0gbC5kcmFnX21vZGUubW92ZSAmJiBhLmNvcnJlY3RUYXNrV29ya1RpbWUocyk7XG4gICAgICB9LCBfZmluYWxpemVfbW91c2VfdXA6IGZ1bmN0aW9uKHMsIG8sIGwsIGQpIHtcbiAgICAgICAgdmFyIGMgPSBhLmdldFRhc2socyk7XG4gICAgICAgIGlmIChvLndvcmtfdGltZSAmJiBvLmNvcnJlY3Rfd29ya190aW1lICYmIHRoaXMuX2ZpeF93b3JraW5nX3RpbWVzKGMsIGwpLCB0aGlzLl9maXhfZG5kX3NjYWxlX3RpbWUoYywgbCksIHRoaXMuX2ZpcmVFdmVudChcImJlZm9yZV9maW5pc2hcIiwgbC5tb2RlLCBbcywgbC5tb2RlLCBhLmNvcHkobC5vYmopLCBkXSkpIHtcbiAgICAgICAgICB2YXIgdSA9IHM7XG4gICAgICAgICAgYS5faW5pdF90YXNrX3RpbWluZyhjKSwgdGhpcy5jbGVhcl9kcmFnX3N0YXRlKCksIGEudXBkYXRlVGFzayhjLmlkKSwgdGhpcy5fZmlyZUV2ZW50KFwiYWZ0ZXJfZmluaXNoXCIsIGwubW9kZSwgW3UsIGwubW9kZSwgZF0pO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuY2xlYXJfZHJhZ19zdGF0ZSgpLCBzID09IGwuaWQgJiYgKGwub2JqLl9kaHhfY2hhbmdlZCA9ICExLCBhLm1peGluKGMsIGwub2JqLCAhMCkpLCBhLnJlZnJlc2hUYXNrKGMuaWQpLCBjLiRsZXZlbCA+IDEwMCkge1xuICAgICAgICAgIGxldCBoID0gITE7XG4gICAgICAgICAgYS5lYWNoUGFyZW50KGZ1bmN0aW9uKGcpIHtcbiAgICAgICAgICAgIGlmICghaCAmJiBnLnR5cGUgPT09IGEuY29uZmlnLnR5cGVzLnByb2plY3QpIHtcbiAgICAgICAgICAgICAgY29uc3QgcCA9IHsgc3RhcnRfZGF0ZTogZy5zdGFydF9kYXRlLCBlbmRfZGF0ZTogZy5lbmRfZGF0ZSB9O1xuICAgICAgICAgICAgICBhLnJlc2V0UHJvamVjdERhdGVzKGcpLCArcC5zdGFydF9kYXRlID09ICtnLnN0YXJ0X2RhdGUgJiYgK3AuZW5kX2RhdGUgPT0gK2cuZW5kX2RhdGUgfHwgKGggPSAhMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgYy5pZCksIGggJiYgYS5yZWZyZXNoRGF0YSgpO1xuICAgICAgICB9IGVsc2UgYS5lYWNoUGFyZW50KGZ1bmN0aW9uKGgpIHtcbiAgICAgICAgICBpZiAoaC50eXBlID09PSBhLmNvbmZpZy50eXBlcy5wcm9qZWN0KSB7XG4gICAgICAgICAgICBjb25zdCBnID0geyBzdGFydF9kYXRlOiBoLnN0YXJ0X2RhdGUsIGVuZF9kYXRlOiBoLmVuZF9kYXRlIH07XG4gICAgICAgICAgICBhLnJlc2V0UHJvamVjdERhdGVzKGgpLCArZy5zdGFydF9kYXRlID09ICtoLnN0YXJ0X2RhdGUgJiYgK2cuZW5kX2RhdGUgPT0gK2guZW5kX2RhdGUgfHwgYS5yZWZyZXNoVGFzayhoLmlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIGMuaWQpO1xuICAgICAgfSwgb25fbW91c2VfdXA6IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgdmFyIG8gPSB0aGlzLmRyYWc7XG4gICAgICAgIGlmIChvLm1vZGUgJiYgby5pZCkge1xuICAgICAgICAgIHZhciBsID0gaS4kZ2V0Q29uZmlnKCksIGQgPSBhLmdldFRhc2soby5pZCksIGMgPSB0aGlzLmRyYWdNdWx0aXBsZSwgdSA9ICExLCBoID0gMDtcbiAgICAgICAgICBvLm1vZGUgPT09IGwuZHJhZ19tb2RlLm1vdmUgJiYgKGEuaXNTdW1tYXJ5VGFzayhkKSAmJiBsLmRyYWdfcHJvamVjdCB8fCB0aGlzLl9pc011bHRpc2VsZWN0KCkpICYmICh1ID0gITAsIGggPSBPYmplY3Qua2V5cyhjKS5sZW5ndGgpO1xuICAgICAgICAgIHZhciBnID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAodSkgZm9yICh2YXIgcCBpbiBjKSBjW3BdLmlkICE9IG8uaWQgJiYgdGhpcy5fZmluYWxpemVfbW91c2VfdXAoY1twXS5pZCwgbCwgY1twXSwgcyk7XG4gICAgICAgICAgICB0aGlzLl9maW5hbGl6ZV9tb3VzZV91cChvLmlkLCBsLCBvLCBzKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHUgJiYgaCA+IDEwID8gYS5iYXRjaFVwZGF0ZSgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBnLmNhbGwodGhpcyk7XG4gICAgICAgICAgfSkuYmluZCh0aGlzKSkgOiBnLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbGVhcl9kcmFnX3N0YXRlKCk7XG4gICAgICB9LCBfZ2V0X2RyYWdfbW9kZTogZnVuY3Rpb24ocywgbykge1xuICAgICAgICB2YXIgbCA9IGkuJGdldENvbmZpZygpLmRyYWdfbW9kZSwgZCA9IHsgbW9kZTogbnVsbCwgbGVmdDogbnVsbCB9O1xuICAgICAgICBzd2l0Y2ggKChzIHx8IFwiXCIpLnNwbGl0KFwiIFwiKVswXSkge1xuICAgICAgICAgIGNhc2UgXCJnYW50dF90YXNrX2xpbmVcIjpcbiAgICAgICAgICBjYXNlIFwiZ2FudHRfdGFza19jb250ZW50XCI6XG4gICAgICAgICAgICBkLm1vZGUgPSBsLm1vdmU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiZ2FudHRfdGFza19kcmFnXCI6XG4gICAgICAgICAgICBkLm1vZGUgPSBsLnJlc2l6ZTtcbiAgICAgICAgICAgIHZhciBjID0gby5nZXRBdHRyaWJ1dGUoXCJkYXRhLWJpbmQtcHJvcGVydHlcIik7XG4gICAgICAgICAgICBkLmxlZnQgPSBjID09IFwic3RhcnRfZGF0ZVwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImdhbnR0X3Rhc2tfcHJvZ3Jlc3NfZHJhZ1wiOlxuICAgICAgICAgICAgZC5tb2RlID0gbC5wcm9ncmVzcztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJnYW50dF9saW5rX2NvbnRyb2xcIjpcbiAgICAgICAgICBjYXNlIFwiZ2FudHRfbGlua19wb2ludFwiOlxuICAgICAgICAgICAgZC5tb2RlID0gbC5pZ25vcmU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGQ7XG4gICAgICB9LCBfc3RhcnRfZG5kOiBmdW5jdGlvbihzKSB7XG4gICAgICAgIHZhciBvID0gdGhpcy5kcmFnID0gdGhpcy5kcmFnLnN0YXJ0X2RyYWc7XG4gICAgICAgIGRlbGV0ZSBvLnN0YXJ0X2RyYWc7XG4gICAgICAgIHZhciBsID0gaS4kZ2V0Q29uZmlnKCksIGQgPSBvLmlkO1xuICAgICAgICBpZiAobFtcImRyYWdfXCIgKyBvLm1vZGVdICYmIGEuY2FsbEV2ZW50KFwib25CZWZvcmVEcmFnXCIsIFtkLCBvLm1vZGUsIHNdKSAmJiB0aGlzLl9maXJlRXZlbnQoXCJiZWZvcmVfc3RhcnRcIiwgby5tb2RlLCBbZCwgby5tb2RlLCBzXSkpIHtcbiAgICAgICAgICBkZWxldGUgby5zdGFydF9kcmFnO1xuICAgICAgICAgIHZhciBjID0gYS5nZXRUYXNrKGQpO1xuICAgICAgICAgIGlmIChhLmlzUmVhZG9ubHkoYykpIHJldHVybiB2b2lkIHRoaXMuY2xlYXJfZHJhZ19zdGF0ZSgpO1xuICAgICAgICAgIGlmICh0aGlzLl9pc011bHRpc2VsZWN0KCkpIHtcbiAgICAgICAgICAgIHZhciB1ID0gYS5nZXRTZWxlY3RlZFRhc2tzKCk7XG4gICAgICAgICAgICB1LmluZGV4T2Yoby5pZCkgPj0gMCAmJiBrdCh1LCBhLmJpbmQoZnVuY3Rpb24oaCkge1xuICAgICAgICAgICAgICB2YXIgZyA9IGEuZ2V0VGFzayhoKTtcbiAgICAgICAgICAgICAgYS5pc1N1bW1hcnlUYXNrKGcpICYmIGEuY29uZmlnLmRyYWdfcHJvamVjdCAmJiBvLm1vZGUgPT0gbC5kcmFnX21vZGUubW92ZSAmJiB0aGlzLl9hZGRTdWJ0YXNrc1RvRHJhZ011bHRpcGxlKGcuaWQpLCB0aGlzLmRyYWdNdWx0aXBsZVtoXSA9IGEubWl4aW4oeyBpZDogZy5pZCwgb2JqOiBhLmNvcHkoZykgfSwgdGhpcy5kcmFnKTtcbiAgICAgICAgICAgIH0sIHRoaXMpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYS5pc1N1bW1hcnlUYXNrKGMpICYmIGEuY29uZmlnLmRyYWdfcHJvamVjdCAmJiBvLm1vZGUgPT0gbC5kcmFnX21vZGUubW92ZSAmJiB0aGlzLl9hZGRTdWJ0YXNrc1RvRHJhZ011bHRpcGxlKGMuaWQpLCBhLmNhbGxFdmVudChcIm9uVGFza0RyYWdTdGFydFwiLCBbXSk7XG4gICAgICAgIH0gZWxzZSB0aGlzLmNsZWFyX2RyYWdfc3RhdGUoKTtcbiAgICAgIH0sIF9maXJlRXZlbnQ6IGZ1bmN0aW9uKHMsIG8sIGwpIHtcbiAgICAgICAgYS5hc3NlcnQodGhpcy5fZXZlbnRzW3NdLCBcIkludmFsaWQgc3RhZ2U6e1wiICsgcyArIFwifVwiKTtcbiAgICAgICAgdmFyIGQgPSB0aGlzLl9ldmVudHNbc11bb107XG4gICAgICAgIHJldHVybiBhLmFzc2VydChkLCBcIlVua25vd24gYWZ0ZXIgZHJvcCBtb2RlOntcIiArIG8gKyBcIn1cIiksIGEuYXNzZXJ0KGwsIFwiSW52YWxpZCBldmVudCBhcmd1bWVudHNcIiksICFhLmNoZWNrRXZlbnQoZCkgfHwgYS5jYWxsRXZlbnQoZCwgbCk7XG4gICAgICB9LCByb3VuZF90YXNrX2RhdGVzOiBmdW5jdGlvbihzKSB7XG4gICAgICAgIHZhciBvID0gdGhpcy5kcmFnLCBsID0gaS4kZ2V0Q29uZmlnKCk7XG4gICAgICAgIG8gfHwgKG8gPSB7IG1vZGU6IGwuZHJhZ19tb2RlLm1vdmUgfSksIHRoaXMuX2ZpeF9kbmRfc2NhbGVfdGltZShzLCBvKTtcbiAgICAgIH0sIGRlc3RydWN0b3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9kb21FdmVudHMuZGV0YWNoQWxsKCk7XG4gICAgICB9LCBfaXNNdWx0aXNlbGVjdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBhLmNvbmZpZy5kcmFnX211bHRpcGxlICYmICEhKGEuZ2V0U2VsZWN0ZWRUYXNrcyAmJiBhLmdldFNlbGVjdGVkVGFza3MoKS5sZW5ndGggPiAwKTtcbiAgICAgIH0sIF9hZGRTdWJ0YXNrc1RvRHJhZ011bHRpcGxlOiBmdW5jdGlvbihzKSB7XG4gICAgICAgIGEuZWFjaFRhc2soZnVuY3Rpb24obykge1xuICAgICAgICAgIHRoaXMuZHJhZ011bHRpcGxlW28uaWRdID0gYS5taXhpbih7IGlkOiBvLmlkLCBvYmo6IGEuY29weShvKSB9LCB0aGlzLmRyYWcpO1xuICAgICAgICB9LCBzLCB0aGlzKTtcbiAgICAgIH0gfTtcbiAgICB9KGUsIG4pLCBlLl90YXNrc19kbmQgPSB0LCB0LmluaXQobik7XG4gIH0sIGRlc3RydWN0b3I6IGZ1bmN0aW9uKCkge1xuICAgIHQgJiYgKHQuZGVzdHJ1Y3RvcigpLCB0ID0gbnVsbCk7XG4gIH0gfTtcbn0gfTtcbnZhciBPYSA9IGZ1bmN0aW9uKHQsIGUpIHtcbiAgdmFyIG4sIGksIGEsIHIsIHM7XG4gIGZ1bmN0aW9uIG8oKSB7XG4gICAgcmV0dXJuIHsgbGlua19zb3VyY2VfaWQ6IHIsIGxpbmtfdGFyZ2V0X2lkOiBpLCBsaW5rX2Zyb21fc3RhcnQ6IHMsIGxpbmtfdG9fc3RhcnQ6IGEsIGxpbmtfbGFuZGluZ19hcmVhOiBuIH07XG4gIH1cbiAgdmFyIGwgPSBlLiRzZXJ2aWNlcywgZCA9IGwuZ2V0U2VydmljZShcInN0YXRlXCIpLCBjID0gbC5nZXRTZXJ2aWNlKFwiZG5kXCIpO1xuICBkLnJlZ2lzdGVyUHJvdmlkZXIoXCJsaW5rc0RuRFwiLCBvKTtcbiAgdmFyIHUgPSBcImdhbnR0X2xpbmtfcG9pbnRcIiwgaCA9IFwiZ2FudHRfbGlua19jb250cm9sXCIsIGcgPSBuZXcgYyh0LiR0YXNrX2JhcnMsIHsgc2Vuc2l0aXZpdHk6IDAsIHVwZGF0ZXNfcGVyX3NlY29uZDogNjAsIG1vdXNlbW92ZUNvbnRhaW5lcjogZS4kcm9vdCwgc2VsZWN0b3I6IFwiLlwiICsgdSwgcHJldmVudERlZmF1bHQ6ICEwIH0pO1xuICBmdW5jdGlvbiBwKG0sIGYpIHtcbiAgICB2YXIgaywgeCA9IGcuZ2V0UG9zaXRpb24obSksICQgPSBmdW5jdGlvbihNKSB7XG4gICAgICB2YXIgSSA9IDAsIEEgPSAwO1xuICAgICAgcmV0dXJuIE0gJiYgKEkgPSBNLm9mZnNldFdpZHRoIHx8IDAsIEEgPSBNLm9mZnNldEhlaWdodCB8fCAwKSwgeyB3aWR0aDogSSwgaGVpZ2h0OiBBIH07XG4gICAgfShmKSwgdyA9IHsgcmlnaHQ6IChrID0gZS4kcm9vdCkub2Zmc2V0V2lkdGgsIGJvdHRvbTogay5vZmZzZXRIZWlnaHQgfSwgUyA9IGUuY29uZmlnLnRvb2x0aXBfb2Zmc2V0X3ggfHwgMTAsIFQgPSBlLmNvbmZpZy50b29sdGlwX29mZnNldF95IHx8IDEwLCBFID0gZS5jb25maWcuc2Nyb2xsX3NpemUgfHwgMTgsIEMgPSBlLiRjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkueSArIHdpbmRvdy5zY3JvbGxZLCBEID0geyB5OiB4LnkgKyBULCB4OiB4LnggKyBTLCBib3R0b206IHgueSArICQuaGVpZ2h0ICsgVCArIEUsIHJpZ2h0OiB4LnggKyAkLndpZHRoICsgUyArIEUgfTtcbiAgICByZXR1cm4gRC5ib3R0b20gPiB3LmJvdHRvbSArIEMgJiYgKEQueSA9IHcuYm90dG9tICsgQyAtICQuaGVpZ2h0IC0gVCksIEQucmlnaHQgPiB3LnJpZ2h0ICYmIChELnggPSB3LnJpZ2h0IC0gJC53aWR0aCAtIFMpLCBEO1xuICB9XG4gIGZ1bmN0aW9uIHkobSkge1xuICAgIHZhciBmID0gbygpO1xuICAgIGYubGlua19zb3VyY2VfaWQgJiYgZi5saW5rX3RhcmdldF9pZCAmJiBlLmlzTGlua0FsbG93ZWQoZi5saW5rX3NvdXJjZV9pZCwgZi5saW5rX3RhcmdldF9pZCwgZi5saW5rX2Zyb21fc3RhcnQsIGYubGlua190b19zdGFydCk7XG4gICAgdmFyIGsgPSBcIjxkaXYgY2xhc3M9J1wiICsgZS50ZW1wbGF0ZXMuZHJhZ19saW5rX2NsYXNzKGYubGlua19zb3VyY2VfaWQsIGYubGlua19mcm9tX3N0YXJ0LCBmLmxpbmtfdGFyZ2V0X2lkLCBmLmxpbmtfdG9fc3RhcnQpICsgXCInPlwiICsgZS50ZW1wbGF0ZXMuZHJhZ19saW5rKGYubGlua19zb3VyY2VfaWQsIGYubGlua19mcm9tX3N0YXJ0LCBmLmxpbmtfdGFyZ2V0X2lkLCBmLmxpbmtfdG9fc3RhcnQpICsgXCI8L2Rpdj5cIjtcbiAgICBtLmlubmVySFRNTCA9IGs7XG4gIH1cbiAgZnVuY3Rpb24gdigpIHtcbiAgICByID0gcyA9IGkgPSBudWxsLCBhID0gITA7XG4gIH1cbiAgZnVuY3Rpb24gYihtLCBmLCBrLCB4KSB7XG4gICAgdmFyICQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBnLl9kaXJlY3Rpb24gJiYgZy5fZGlyZWN0aW9uLnBhcmVudE5vZGUgfHwgKGcuX2RpcmVjdGlvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksIHQuJHRhc2tfbGlua3MuYXBwZW5kQ2hpbGQoZy5fZGlyZWN0aW9uKSksIGcuX2RpcmVjdGlvbjtcbiAgICB9KCksIHcgPSBvKCksIFMgPSBbXCJnYW50dF9saW5rX2RpcmVjdGlvblwiXTtcbiAgICBlLnRlbXBsYXRlcy5saW5rX2RpcmVjdGlvbl9jbGFzcyAmJiBTLnB1c2goZS50ZW1wbGF0ZXMubGlua19kaXJlY3Rpb25fY2xhc3Mody5saW5rX3NvdXJjZV9pZCwgdy5saW5rX2Zyb21fc3RhcnQsIHcubGlua190YXJnZXRfaWQsIHcubGlua190b19zdGFydCkpO1xuICAgIHZhciBUID0gTWF0aC5zcXJ0KE1hdGgucG93KGsgLSBtLCAyKSArIE1hdGgucG93KHggLSBmLCAyKSk7XG4gICAgaWYgKFQgPSBNYXRoLm1heCgwLCBUIC0gMykpIHtcbiAgICAgICQuY2xhc3NOYW1lID0gUy5qb2luKFwiIFwiKTtcbiAgICAgIHZhciBFID0gKHggLSBmKSAvIChrIC0gbSksIEMgPSBNYXRoLmF0YW4oRSk7XG4gICAgICBfKG0sIGssIGYsIHgpID09IDIgPyBDICs9IE1hdGguUEkgOiBfKG0sIGssIGYsIHgpID09IDMgJiYgKEMgLT0gTWF0aC5QSSk7XG4gICAgICB2YXIgRCA9IE1hdGguc2luKEMpLCBNID0gTWF0aC5jb3MoQyksIEkgPSBNYXRoLnJvdW5kKGYpLCBBID0gTWF0aC5yb3VuZChtKSwgTiA9IFtcIi13ZWJraXQtdHJhbnNmb3JtOiByb3RhdGUoXCIgKyBDICsgXCJyYWQpXCIsIFwiLW1vei10cmFuc2Zvcm06IHJvdGF0ZShcIiArIEMgKyBcInJhZClcIiwgXCItbXMtdHJhbnNmb3JtOiByb3RhdGUoXCIgKyBDICsgXCJyYWQpXCIsIFwiLW8tdHJhbnNmb3JtOiByb3RhdGUoXCIgKyBDICsgXCJyYWQpXCIsIFwidHJhbnNmb3JtOiByb3RhdGUoXCIgKyBDICsgXCJyYWQpXCIsIFwid2lkdGg6XCIgKyBNYXRoLnJvdW5kKFQpICsgXCJweFwiXTtcbiAgICAgIGlmICh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKFwiTVNJRSA4LjBcIikgIT0gLTEpIHtcbiAgICAgICAgTi5wdXNoKCctbXMtZmlsdGVyOiBcIicgKyBmdW5jdGlvbihHLCBqKSB7XG4gICAgICAgICAgcmV0dXJuIFwicHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0Lk1hdHJpeChNMTEgPSBcIiArIGogKyBcIixNMTIgPSAtXCIgKyBHICsgXCIsTTIxID0gXCIgKyBHICsgXCIsTTIyID0gXCIgKyBqICsgXCIsU2l6aW5nTWV0aG9kID0gJ2F1dG8gZXhwYW5kJylcIjtcbiAgICAgICAgfShELCBNKSArICdcIicpO1xuICAgICAgICB2YXIgTCA9IE1hdGguYWJzKE1hdGgucm91bmQobSAtIGspKSwgTyA9IE1hdGguYWJzKE1hdGgucm91bmQoeCAtIGYpKTtcbiAgICAgICAgc3dpdGNoIChfKG0sIGssIGYsIHgpKSB7XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgSSAtPSBPO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgQSAtPSBMLCBJIC09IE87XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBBIC09IEw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIE4ucHVzaChcInRvcDpcIiArIEkgKyBcInB4XCIpLCBOLnB1c2goXCJsZWZ0OlwiICsgQSArIFwicHhcIiksICQuc3R5bGUuY3NzVGV4dCA9IE4uam9pbihcIjtcIik7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIF8obSwgZiwgaywgeCkge1xuICAgIHJldHVybiBmID49IG0gPyB4IDw9IGsgPyAxIDogNCA6IHggPD0gayA/IDIgOiAzO1xuICB9XG4gIGcuYXR0YWNoRXZlbnQoXCJvbkJlZm9yZURyYWdTdGFydFwiLCBlLmJpbmQoZnVuY3Rpb24obSwgZikge1xuICAgIHZhciBrID0gZi50YXJnZXQgfHwgZi5zcmNFbGVtZW50O1xuICAgIGlmICh2KCksIGUuZ2V0U3RhdGUoXCJ0YXNrc0RuZFwiKS5kcmFnX2lkKSByZXR1cm4gITE7XG4gICAgaWYgKHB0KGssIHUpKSB7XG4gICAgICBwdChrLCBcInRhc2tfc3RhcnRfZGF0ZVwiKSAmJiAocyA9ICEwKTtcbiAgICAgIHZhciB4ID0gZS5sb2NhdGUoZik7XG4gICAgICByID0geDtcbiAgICAgIHZhciAkID0gZS5nZXRUYXNrKHgpO1xuICAgICAgcmV0dXJuIGUuaXNSZWFkb25seSgkKSA/ICh2KCksICExKSA6ICh0aGlzLl9kaXJfc3RhcnQgPSB7IHg6IGcuY29uZmlnLm9yaWdpbmFsX2VsZW1lbnRfc2l6ZXMueCArIGcuY29uZmlnLm9yaWdpbmFsX2VsZW1lbnRfc2l6ZXMud2lkdGggLyAyLCB5OiBnLmNvbmZpZy5vcmlnaW5hbF9lbGVtZW50X3NpemVzLnkgKyBnLmNvbmZpZy5vcmlnaW5hbF9lbGVtZW50X3NpemVzLmhlaWdodCAvIDIgfSwgITApO1xuICAgIH1cbiAgICByZXR1cm4gITE7XG4gIH0sIHRoaXMpKSwgZy5hdHRhY2hFdmVudChcIm9uQWZ0ZXJEcmFnU3RhcnRcIiwgZS5iaW5kKGZ1bmN0aW9uKG0sIGYpIHtcbiAgICBlLmNvbmZpZy50b3VjaCAmJiBlLnJlZnJlc2hEYXRhKCksIHkoZy5jb25maWcubWFya2VyKTtcbiAgfSwgdGhpcykpLCBnLmF0dGFjaEV2ZW50KFwib25EcmFnTW92ZVwiLCBlLmJpbmQoZnVuY3Rpb24obSwgZikge1xuICAgIHZhciBrID0gZy5jb25maWcsIHggPSBwKGYsIGsubWFya2VyKTtcbiAgICAoZnVuY3Rpb24oTSwgSSkge1xuICAgICAgTS5zdHlsZS5sZWZ0ID0gSS54ICsgXCJweFwiLCBNLnN0eWxlLnRvcCA9IEkueSArIFwicHhcIjtcbiAgICB9KShrLm1hcmtlciwgeCk7XG4gICAgdmFyICQgPSAhIXB0KGYsIGgpLCB3ID0gaSwgUyA9IG4sIFQgPSBhLCBFID0gZS5sb2NhdGUoZiksIEMgPSAhMDtcbiAgICBpZiAoWSh5dChmKSwgZS4kcm9vdCkgfHwgKCQgPSAhMSwgRSA9IG51bGwpLCAkICYmIChDID0gIXB0KGYsIFwidGFza19lbmRfZGF0ZVwiKSwgJCA9ICEhRSksIGkgPSBFLCBuID0gJCwgYSA9IEMsICQpIHtcbiAgICAgIGNvbnN0IE0gPSBwdChmLCBoKS5xdWVyeVNlbGVjdG9yKGAuJHt1fWApO1xuICAgICAgaWYgKE0pIHtcbiAgICAgICAgY29uc3QgSSA9IGVuKE0sIHQuJHRhc2tfYmcpO1xuICAgICAgICB0aGlzLl9kaXJfZW5kID0geyB4OiBJLnggKyBNLm9mZnNldFdpZHRoIC8gMiwgeTogSS55ICsgTS5vZmZzZXRIZWlnaHQgLyAyIH07XG4gICAgICB9XG4gICAgfSBlbHNlIHRoaXMuX2Rpcl9lbmQgPSBydChmLCB0LiR0YXNrX2RhdGEpLCBlLmVudi5pc0VkZ2UgJiYgKHRoaXMuX2Rpcl9lbmQueSArPSB3aW5kb3cuc2Nyb2xsWSk7XG4gICAgdmFyIEQgPSAhKFMgPT0gJCAmJiB3ID09IEUgJiYgVCA9PSBDKTtcbiAgICByZXR1cm4gRCAmJiAodyAmJiBlLnJlZnJlc2hUYXNrKHcsICExKSwgRSAmJiBlLnJlZnJlc2hUYXNrKEUsICExKSksIEQgJiYgeShrLm1hcmtlciksIGIodGhpcy5fZGlyX3N0YXJ0LngsIHRoaXMuX2Rpcl9zdGFydC55LCB0aGlzLl9kaXJfZW5kLngsIHRoaXMuX2Rpcl9lbmQueSksICEwO1xuICB9LCB0aGlzKSksIGcuYXR0YWNoRXZlbnQoXCJvbkRyYWdFbmRcIiwgZS5iaW5kKGZ1bmN0aW9uKCkge1xuICAgIHZhciBtID0gbygpO1xuICAgIGlmIChtLmxpbmtfc291cmNlX2lkICYmIG0ubGlua190YXJnZXRfaWQgJiYgbS5saW5rX3NvdXJjZV9pZCAhPSBtLmxpbmtfdGFyZ2V0X2lkKSB7XG4gICAgICB2YXIgZiA9IGUuX2dldF9saW5rX3R5cGUobS5saW5rX2Zyb21fc3RhcnQsIG0ubGlua190b19zdGFydCksIGsgPSB7IHNvdXJjZTogbS5saW5rX3NvdXJjZV9pZCwgdGFyZ2V0OiBtLmxpbmtfdGFyZ2V0X2lkLCB0eXBlOiBmIH07XG4gICAgICBrLnR5cGUgJiYgZS5pc0xpbmtBbGxvd2VkKGspICYmIGUuY2FsbEV2ZW50KFwib25MaW5rQ3JlYXRlZFwiLCBba10pICYmIGUuYWRkTGluayhrKTtcbiAgICB9XG4gICAgdigpLCBlLmNvbmZpZy50b3VjaCA/IGUucmVmcmVzaERhdGEoKSA6IChtLmxpbmtfc291cmNlX2lkICYmIGUucmVmcmVzaFRhc2sobS5saW5rX3NvdXJjZV9pZCwgITEpLCBtLmxpbmtfdGFyZ2V0X2lkICYmIGUucmVmcmVzaFRhc2sobS5saW5rX3RhcmdldF9pZCwgITEpKSwgZy5fZGlyZWN0aW9uICYmIChnLl9kaXJlY3Rpb24ucGFyZW50Tm9kZSAmJiBnLl9kaXJlY3Rpb24ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChnLl9kaXJlY3Rpb24pLCBnLl9kaXJlY3Rpb24gPSBudWxsKTtcbiAgfSwgdGhpcykpLCBlLmF0dGFjaEV2ZW50KFwib25HYW50dFJlbmRlclwiLCBlLmJpbmQoZnVuY3Rpb24oKSB7XG4gICAgZy5fZGlyZWN0aW9uICYmIGIodGhpcy5fZGlyX3N0YXJ0LngsIHRoaXMuX2Rpcl9zdGFydC55LCB0aGlzLl9kaXJfZW5kLngsIHRoaXMuX2Rpcl9lbmQueSk7XG4gIH0sIHRoaXMpKTtcbn07XG5jb25zdCBCYSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4geyBpbml0OiBPYSB9O1xufTtcbnZhciB6YSA9IGZ1bmN0aW9uKHQpIHtcbiAgdmFyIGUgPSB0LiRzZXJ2aWNlcztcbiAgcmV0dXJuIHsgb25DcmVhdGVkOiBmdW5jdGlvbihuKSB7XG4gICAgdmFyIGkgPSBuLiRjb25maWc7XG4gICAgaS5iaW5kID0gVyhpLmJpbmQpID8gaS5iaW5kIDogXCJ0YXNrXCIsIGkuYmluZExpbmtzID0gVyhpLmJpbmRMaW5rcykgPyBpLmJpbmRMaW5rcyA6IFwibGlua1wiLCBuLl9saW5rc0RuRCA9IEJhKCksIG4uX3Rhc2tzRG5EID0gSGEuY3JlYXRlVGFza0RORCgpLCBuLl90YXNrc0RuRC5leHRlbmQobiksIHRoaXMuX21vdXNlRGVsZWdhdGVzID0gVGUodCk7XG4gIH0sIG9uSW5pdGlhbGl6ZWQ6IGZ1bmN0aW9uKG4pIHtcbiAgICB0aGlzLl9hdHRhY2hEb21FdmVudHModCksIHRoaXMuX2F0dGFjaFN0YXRlUHJvdmlkZXIodCwgbiksIG4uX3Rhc2tzRG5ELmluaXQobiwgdCksIG4uX2xpbmtzRG5ELmluaXQobiwgdCksIG4uJGNvbmZpZy5pZCA9PSBcInRpbWVsaW5lXCIgJiYgdGhpcy5leHRlbmREb20obik7XG4gIH0sIG9uRGVzdHJveWVkOiBmdW5jdGlvbihuKSB7XG4gICAgdGhpcy5fY2xlYXJEb21FdmVudHModCksIHRoaXMuX2NsZWFyU3RhdGVQcm92aWRlcih0KSwgbi5fdGFza3NEbkQgJiYgbi5fdGFza3NEbkQuZGVzdHJ1Y3RvcigpO1xuICB9LCBleHRlbmREb206IGZ1bmN0aW9uKG4pIHtcbiAgICB0LiR0YXNrID0gbi4kdGFzaywgdC4kdGFza19zY2FsZSA9IG4uJHRhc2tfc2NhbGUsIHQuJHRhc2tfZGF0YSA9IG4uJHRhc2tfZGF0YSwgdC4kdGFza19iZyA9IG4uJHRhc2tfYmcsIHQuJHRhc2tfbGlua3MgPSBuLiR0YXNrX2xpbmtzLCB0LiR0YXNrX2JhcnMgPSBuLiR0YXNrX2JhcnM7XG4gIH0sIF9jbGVhckRvbUV2ZW50czogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbW91c2VEZWxlZ2F0ZXMuZGVzdHJ1Y3RvcigpLCB0aGlzLl9tb3VzZURlbGVnYXRlcyA9IG51bGw7XG4gIH0sIF9hdHRhY2hEb21FdmVudHM6IGZ1bmN0aW9uKG4pIHtcbiAgICBmdW5jdGlvbiBpKGEsIHIpIHtcbiAgICAgIGlmIChhICYmIHRoaXMuY2FsbEV2ZW50KFwib25MaW5rRGJsQ2xpY2tcIiwgW2EsIHJdKSkge1xuICAgICAgICB2YXIgcyA9IHRoaXMuZ2V0TGluayhhKTtcbiAgICAgICAgaWYgKHRoaXMuaXNSZWFkb25seShzKSkgcmV0dXJuO1xuICAgICAgICB2YXIgbyA9IHRoaXMubG9jYWxlLmxhYmVscy5saW5rICsgXCIgXCIgKyB0aGlzLnRlbXBsYXRlcy5saW5rX2Rlc2NyaXB0aW9uKHRoaXMuZ2V0TGluayhhKSkgKyBcIiBcIiArIHRoaXMubG9jYWxlLmxhYmVscy5jb25maXJtX2xpbmtfZGVsZXRpbmc7XG4gICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIG4uX2RlbGV0ZV9saW5rX2NvbmZpcm0oeyBsaW5rOiBzLCBtZXNzYWdlOiBvLCB0aXRsZTogXCJcIiwgY2FsbGJhY2s6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgbi5kZWxldGVMaW5rKGEpO1xuICAgICAgICAgIH0gfSk7XG4gICAgICAgIH0sIHRoaXMuY29uZmlnLnRvdWNoID8gMzAwIDogMSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX21vdXNlRGVsZWdhdGVzLmRlbGVnYXRlKFwiY2xpY2tcIiwgXCJnYW50dF90YXNrX2xpbmtcIiwgbi5iaW5kKGZ1bmN0aW9uKGEsIHIpIHtcbiAgICAgIHZhciBzID0gdGhpcy5sb2NhdGUoYSwgdGhpcy5jb25maWcubGlua19hdHRyaWJ1dGUpO1xuICAgICAgcyAmJiB0aGlzLmNhbGxFdmVudChcIm9uTGlua0NsaWNrXCIsIFtzLCBhXSk7XG4gICAgfSwgbiksIHRoaXMuJHRhc2spLCB0aGlzLl9tb3VzZURlbGVnYXRlcy5kZWxlZ2F0ZShcImNsaWNrXCIsIFwiZ2FudHRfc2NhbGVfY2VsbFwiLCBuLmJpbmQoZnVuY3Rpb24oYSwgcikge1xuICAgICAgdmFyIHMgPSBydChhLCBuLiR0YXNrX2RhdGEpLCBvID0gbi5kYXRlRnJvbVBvcyhzLngpLCBsID0gTWF0aC5mbG9vcihuLmNvbHVtbkluZGV4QnlEYXRlKG8pKSwgZCA9IG4uZ2V0U2NhbGUoKS50cmFjZV94W2xdO1xuICAgICAgbi5jYWxsRXZlbnQoXCJvblNjYWxlQ2xpY2tcIiwgW2EsIGRdKTtcbiAgICB9LCBuKSwgdGhpcy4kdGFzayksIHRoaXMuX21vdXNlRGVsZWdhdGVzLmRlbGVnYXRlKFwiZG91YmxlY2xpY2tcIiwgXCJnYW50dF90YXNrX2xpbmtcIiwgbi5iaW5kKGZ1bmN0aW9uKGEsIHIsIHMpIHtcbiAgICAgIHIgPSB0aGlzLmxvY2F0ZShhLCBuLmNvbmZpZy5saW5rX2F0dHJpYnV0ZSksIGkuY2FsbCh0aGlzLCByLCBhKTtcbiAgICB9LCBuKSwgdGhpcy4kdGFzayksIHRoaXMuX21vdXNlRGVsZWdhdGVzLmRlbGVnYXRlKFwiZG91YmxlY2xpY2tcIiwgXCJnYW50dF9saW5rX3BvaW50XCIsIG4uYmluZChmdW5jdGlvbihhLCByLCBzKSB7XG4gICAgICByID0gdGhpcy5sb2NhdGUoYSk7XG4gICAgICB2YXIgbyA9IHRoaXMuZ2V0VGFzayhyKSwgbCA9IG51bGw7XG4gICAgICByZXR1cm4gcy5wYXJlbnROb2RlICYmIFgocy5wYXJlbnROb2RlKSAmJiAobCA9IFgocy5wYXJlbnROb2RlKS5pbmRleE9mKFwiX2xlZnRcIikgPiAtMSA/IG8uJHRhcmdldFswXSA6IG8uJHNvdXJjZVswXSksIGwgJiYgaS5jYWxsKHRoaXMsIGwsIGEpLCAhMTtcbiAgICB9LCBuKSwgdGhpcy4kdGFzayk7XG4gIH0sIF9hdHRhY2hTdGF0ZVByb3ZpZGVyOiBmdW5jdGlvbihuLCBpKSB7XG4gICAgdmFyIGEgPSBpO1xuICAgIGUuZ2V0U2VydmljZShcInN0YXRlXCIpLnJlZ2lzdGVyUHJvdmlkZXIoXCJ0YXNrc1RpbWVsaW5lXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHsgc2NhbGVfdW5pdDogYS5fdGFza3MgPyBhLl90YXNrcy51bml0IDogdm9pZCAwLCBzY2FsZV9zdGVwOiBhLl90YXNrcyA/IGEuX3Rhc2tzLnN0ZXAgOiB2b2lkIDAgfTtcbiAgICB9KTtcbiAgfSwgX2NsZWFyU3RhdGVQcm92aWRlcjogZnVuY3Rpb24oKSB7XG4gICAgZS5nZXRTZXJ2aWNlKFwic3RhdGVcIikudW5yZWdpc3RlclByb3ZpZGVyKFwidGFza3NUaW1lbGluZVwiKTtcbiAgfSB9O1xufSwgV2EgPSBmdW5jdGlvbih0KSB7XG4gIHJldHVybiB7IGdldFZlcnRpY2FsU2Nyb2xsYmFyOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdC4kdWkuZ2V0VmlldyhcInNjcm9sbFZlclwiKTtcbiAgfSwgZ2V0SG9yaXpvbnRhbFNjcm9sbGJhcjogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHQuJHVpLmdldFZpZXcoXCJzY3JvbGxIb3JcIik7XG4gIH0sIF9sZWdhY3lHcmlkUmVzaXplckNsYXNzOiBmdW5jdGlvbihlKSB7XG4gICAgZm9yICh2YXIgbiA9IGUuZ2V0Q2VsbHNCeVR5cGUoXCJyZXNpemVyXCIpLCBpID0gMDsgaSA8IG4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBhID0gbltpXSwgciA9ICExLCBzID0gYS4kcGFyZW50LmdldFByZXZTaWJsaW5nKGEuJGlkKTtcbiAgICAgIGlmIChzICYmIHMuJGNvbmZpZyAmJiBzLiRjb25maWcuaWQgPT09IFwiZ3JpZFwiKSByID0gITA7XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIG8gPSBhLiRwYXJlbnQuZ2V0TmV4dFNpYmxpbmcoYS4kaWQpO1xuICAgICAgICBvICYmIG8uJGNvbmZpZyAmJiBvLiRjb25maWcuaWQgPT09IFwiZ3JpZFwiICYmIChyID0gITApO1xuICAgICAgfVxuICAgICAgciAmJiAoYS4kY29uZmlnLmNzcyA9IChhLiRjb25maWcuY3NzID8gYS4kY29uZmlnLmNzcyArIFwiIFwiIDogXCJcIikgKyBcImdhbnR0X2dyaWRfcmVzaXplX3dyYXBcIik7XG4gICAgfVxuICB9LCBvbkNyZWF0ZWQ6IGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgbiA9ICEwO1xuICAgIHRoaXMuX2xlZ2FjeUdyaWRSZXNpemVyQ2xhc3MoZSksIGUuYXR0YWNoRXZlbnQoXCJvbkJlZm9yZVJlc2l6ZVwiLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpID0gdC4kdWkuZ2V0VmlldyhcInRpbWVsaW5lXCIpO1xuICAgICAgaSAmJiAoaS4kY29uZmlnLmhpZGRlbiA9IGkuJHBhcmVudC4kY29uZmlnLmhpZGRlbiA9ICF0LmNvbmZpZy5zaG93X2NoYXJ0KTtcbiAgICAgIHZhciBhID0gdC4kdWkuZ2V0VmlldyhcImdyaWRcIik7XG4gICAgICBpZiAoYSkge1xuICAgICAgICB2YXIgciA9IGEuX2dldENvbHNUb3RhbFdpZHRoKCksIHMgPSAhdC5jb25maWcuc2hvd19ncmlkIHx8ICF0LmNvbmZpZy5ncmlkX3dpZHRoIHx8IHIgPT09IDA7XG4gICAgICAgIGlmIChuICYmICFzICYmIHIgIT09ICExICYmICh0LmNvbmZpZy5ncmlkX3dpZHRoID0gciksIGEuJGNvbmZpZy5oaWRkZW4gPSBhLiRwYXJlbnQuJGNvbmZpZy5oaWRkZW4gPSBzLCAhYS4kY29uZmlnLmhpZGRlbikge1xuICAgICAgICAgIHZhciBvID0gYS5fZ2V0R3JpZFdpZHRoTGltaXRzKCk7XG4gICAgICAgICAgaWYgKG9bMF0gJiYgdC5jb25maWcuZ3JpZF93aWR0aCA8IG9bMF0gJiYgKHQuY29uZmlnLmdyaWRfd2lkdGggPSBvWzBdKSwgb1sxXSAmJiB0LmNvbmZpZy5ncmlkX3dpZHRoID4gb1sxXSAmJiAodC5jb25maWcuZ3JpZF93aWR0aCA9IG9bMV0pLCBpICYmIHQuY29uZmlnLnNob3dfY2hhcnQpIHtcbiAgICAgICAgICAgIGlmIChhLiRjb25maWcud2lkdGggPSB0LmNvbmZpZy5ncmlkX3dpZHRoIC0gMSwgIWEuJGNvbmZpZy5zY3JvbGxhYmxlICYmIGEuJGNvbmZpZy5zY3JvbGxZICYmIHQuJHJvb3Qub2Zmc2V0V2lkdGgpIHtcbiAgICAgICAgICAgICAgdmFyIGwgPSBhLiRnYW50dC4kbGF5b3V0LiRjb250YWluZXIub2Zmc2V0V2lkdGgsIGQgPSB0LiR1aS5nZXRWaWV3KGEuJGNvbmZpZy5zY3JvbGxZKS4kY29uZmlnLndpZHRoLCBjID0gbCAtIChhLiRjb25maWcud2lkdGggKyBkKSAtIDQ7XG4gICAgICAgICAgICAgIGMgPCAwICYmIChhLiRjb25maWcud2lkdGggKz0gYywgdC5jb25maWcuZ3JpZF93aWR0aCArPSBjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuKSBhLiRwYXJlbnQuJGNvbmZpZy53aWR0aCA9IHQuY29uZmlnLmdyaWRfd2lkdGgsIGEuJHBhcmVudC4kY29uZmlnLmdyb3VwICYmIHQuJGxheW91dC5fc3luY0NlbGxTaXplcyhhLiRwYXJlbnQuJGNvbmZpZy5ncm91cCwgeyB2YWx1ZTogYS4kcGFyZW50LiRjb25maWcud2lkdGgsIGlzR3Jhdml0eTogITEgfSk7XG4gICAgICAgICAgICBlbHNlIGlmIChpICYmICFZKGkuJHRhc2ssIGUuJHZpZXcpKSB7XG4gICAgICAgICAgICAgIGlmICghYS4kY29uZmlnLm9yaWdpbmFsX2dyaWRfd2lkdGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgdSA9IHQuc2tpbnNbdC5za2luXTtcbiAgICAgICAgICAgICAgICB1ICYmIHUuY29uZmlnICYmIHUuY29uZmlnLmdyaWRfd2lkdGggPyBhLiRjb25maWcub3JpZ2luYWxfZ3JpZF93aWR0aCA9IHUuY29uZmlnLmdyaWRfd2lkdGggOiBhLiRjb25maWcub3JpZ2luYWxfZ3JpZF93aWR0aCA9IDA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdC5jb25maWcuZ3JpZF93aWR0aCA9IGEuJGNvbmZpZy5vcmlnaW5hbF9ncmlkX3dpZHRoLCBhLiRwYXJlbnQuJGNvbmZpZy53aWR0aCA9IHQuY29uZmlnLmdyaWRfd2lkdGg7XG4gICAgICAgICAgICB9IGVsc2UgYS4kcGFyZW50Ll9zZXRDb250ZW50U2l6ZShhLiRjb25maWcud2lkdGgsIG51bGwpLCB0LiRsYXlvdXQuX3N5bmNDZWxsU2l6ZXMoYS4kcGFyZW50LiRjb25maWcuZ3JvdXAsIHsgdmFsdWU6IHQuY29uZmlnLmdyaWRfd2lkdGgsIGlzR3Jhdml0eTogITEgfSk7XG4gICAgICAgICAgfSBlbHNlIGkgJiYgWShpLiR0YXNrLCBlLiR2aWV3KSAmJiAoYS4kY29uZmlnLm9yaWdpbmFsX2dyaWRfd2lkdGggPSB0LmNvbmZpZy5ncmlkX3dpZHRoKSwgbiB8fCAoYS4kcGFyZW50LiRjb25maWcud2lkdGggPSAwKTtcbiAgICAgICAgfVxuICAgICAgICBuID0gITE7XG4gICAgICB9XG4gICAgfSksIHRoaXMuX2luaXRTY3JvbGxTdGF0ZUV2ZW50cyhlKTtcbiAgfSwgX2luaXRTY3JvbGxTdGF0ZUV2ZW50czogZnVuY3Rpb24oZSkge1xuICAgIHQuX2dldFZlcnRpY2FsU2Nyb2xsYmFyID0gdGhpcy5nZXRWZXJ0aWNhbFNjcm9sbGJhciwgdC5fZ2V0SG9yaXpvbnRhbFNjcm9sbGJhciA9IHRoaXMuZ2V0SG9yaXpvbnRhbFNjcm9sbGJhcjtcbiAgICB2YXIgbiA9IHRoaXMuZ2V0VmVydGljYWxTY3JvbGxiYXIoKSwgaSA9IHRoaXMuZ2V0SG9yaXpvbnRhbFNjcm9sbGJhcigpO1xuICAgIG4gJiYgbi5hdHRhY2hFdmVudChcIm9uU2Nyb2xsXCIsIGZ1bmN0aW9uKGEsIHIsIHMpIHtcbiAgICAgIHZhciBvID0gdC5nZXRTY3JvbGxTdGF0ZSgpO1xuICAgICAgdC5jYWxsRXZlbnQoXCJvbkdhbnR0U2Nyb2xsXCIsIFtvLngsIGEsIG8ueCwgcl0pO1xuICAgIH0pLCBpICYmIGkuYXR0YWNoRXZlbnQoXCJvblNjcm9sbFwiLCBmdW5jdGlvbihhLCByLCBzKSB7XG4gICAgICB2YXIgbyA9IHQuZ2V0U2Nyb2xsU3RhdGUoKTtcbiAgICAgIHQuY2FsbEV2ZW50KFwib25HYW50dFNjcm9sbFwiLCBbYSwgby55LCByLCBvLnldKTtcbiAgICAgIHZhciBsID0gdC4kdWkuZ2V0VmlldyhcImdyaWRcIik7XG4gICAgICBsICYmIGwuJGdyaWRfZGF0YSAmJiAhbC4kY29uZmlnLnNjcm9sbGFibGUgJiYgKGwuJGdyaWRfZGF0YS5zdHlsZS5sZWZ0ID0gbC4kZ3JpZC5zY3JvbGxMZWZ0ICsgXCJweFwiLCBsLiRncmlkX2RhdGEuc2Nyb2xsTGVmdCA9IGwuJGdyaWQuc2Nyb2xsTGVmdCk7XG4gICAgfSksIGUuYXR0YWNoRXZlbnQoXCJvblJlc2l6ZVwiLCBmdW5jdGlvbigpIHtcbiAgICAgIG4gJiYgIXQuJHNjcm9sbF92ZXIgJiYgKHQuJHNjcm9sbF92ZXIgPSBuLiRzY3JvbGxfdmVyKSwgaSAmJiAhdC4kc2Nyb2xsX2hvciAmJiAodC4kc2Nyb2xsX2hvciA9IGkuJHNjcm9sbF9ob3IpO1xuICAgIH0pO1xuICB9LCBfZmluZEdyaWRSZXNpemVyOiBmdW5jdGlvbihlLCBuKSB7XG4gICAgZm9yICh2YXIgaSwgYSA9IGUuZ2V0Q2VsbHNCeVR5cGUoXCJyZXNpemVyXCIpLCByID0gITAsIHMgPSAwOyBzIDwgYS5sZW5ndGg7IHMrKykge1xuICAgICAgdmFyIG8gPSBhW3NdO1xuICAgICAgby5fZ2V0U2libGluZ3MoKTtcbiAgICAgIHZhciBsID0gby5fYmVoaW5kLCBkID0gby5fZnJvbnQ7XG4gICAgICBpZiAobCAmJiBsLiRjb250ZW50ID09PSBuIHx8IGwuaXNDaGlsZCAmJiBsLmlzQ2hpbGQobikpIHtcbiAgICAgICAgaSA9IG8sIHIgPSAhMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoZCAmJiBkLiRjb250ZW50ID09PSBuIHx8IGQuaXNDaGlsZCAmJiBkLmlzQ2hpbGQobikpIHtcbiAgICAgICAgaSA9IG8sIHIgPSAhMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IHJlc2l6ZXI6IGksIGdyaWRGaXJzdDogciB9O1xuICB9LCBvbkluaXRpYWxpemVkOiBmdW5jdGlvbihlKSB7XG4gICAgdmFyIG4gPSB0LiR1aS5nZXRWaWV3KFwiZ3JpZFwiKSwgaSA9IHRoaXMuX2ZpbmRHcmlkUmVzaXplcihlLCBuKTtcbiAgICBpZiAoaS5yZXNpemVyKSB7XG4gICAgICB2YXIgYSwgciA9IGkuZ3JpZEZpcnN0LCBzID0gaS5yZXNpemVyO1xuICAgICAgaWYgKHMuJGNvbmZpZy5tb2RlICE9PSBcInhcIikgcmV0dXJuO1xuICAgICAgcy5hdHRhY2hFdmVudChcIm9uUmVzaXplU3RhcnRcIiwgZnVuY3Rpb24obywgbCkge1xuICAgICAgICB2YXIgZCA9IHQuJHVpLmdldFZpZXcoXCJncmlkXCIpLCBjID0gZCA/IGQuJHBhcmVudCA6IG51bGw7XG4gICAgICAgIGlmIChjKSB7XG4gICAgICAgICAgdmFyIHUgPSBkLl9nZXRHcmlkV2lkdGhMaW1pdHMoKTtcbiAgICAgICAgICBkLiRjb25maWcuc2Nyb2xsYWJsZSB8fCAoYy4kY29uZmlnLm1pbldpZHRoID0gdVswXSksIGMuJGNvbmZpZy5tYXhXaWR0aCA9IHVbMV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGEgPSByID8gbyA6IGwsIHQuY2FsbEV2ZW50KFwib25HcmlkUmVzaXplU3RhcnRcIiwgW2FdKTtcbiAgICAgIH0pLCBzLmF0dGFjaEV2ZW50KFwib25SZXNpemVcIiwgZnVuY3Rpb24obywgbCkge1xuICAgICAgICB2YXIgZCA9IHIgPyBvIDogbDtcbiAgICAgICAgcmV0dXJuIHQuY2FsbEV2ZW50KFwib25HcmlkUmVzaXplXCIsIFthLCBkXSk7XG4gICAgICB9KSwgcy5hdHRhY2hFdmVudChcIm9uUmVzaXplRW5kXCIsIGZ1bmN0aW9uKG8sIGwsIGQsIGMpIHtcbiAgICAgICAgdmFyIHUgPSByID8gbyA6IGwsIGggPSByID8gZCA6IGMsIGcgPSB0LiR1aS5nZXRWaWV3KFwiZ3JpZFwiKSwgcCA9IGcgPyBnLiRwYXJlbnQgOiBudWxsO1xuICAgICAgICBwICYmIChwLiRjb25maWcubWluV2lkdGggPSB2b2lkIDApO1xuICAgICAgICB2YXIgeSA9IHQuY2FsbEV2ZW50KFwib25HcmlkUmVzaXplRW5kXCIsIFt1LCBoXSk7XG4gICAgICAgIHJldHVybiB5ICYmIGggIT09IDAgJiYgKHQuY29uZmlnLmdyaWRfd2lkdGggPSBoKSwgeTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwgb25EZXN0cm95ZWQ6IGZ1bmN0aW9uKGUpIHtcbiAgfSB9O1xufTtcbmNvbnN0IGphID0geyBpbml0OiBmdW5jdGlvbih0KSB7XG4gIGZ1bmN0aW9uIGUociwgcykge1xuICAgIHZhciBvID0gcyh0KTtcbiAgICBvLm9uQ3JlYXRlZCAmJiBvLm9uQ3JlYXRlZChyKSwgci5hdHRhY2hFdmVudChcIm9uUmVhZHlcIiwgZnVuY3Rpb24oKSB7XG4gICAgICBvLm9uSW5pdGlhbGl6ZWQgJiYgby5vbkluaXRpYWxpemVkKHIpO1xuICAgIH0pLCByLmF0dGFjaEV2ZW50KFwib25EZXN0cm95XCIsIGZ1bmN0aW9uKCkge1xuICAgICAgby5vbkRlc3Ryb3llZCAmJiBvLm9uRGVzdHJveWVkKHIpO1xuICAgIH0pO1xuICB9XG4gIHZhciBuID0gbGEodCk7XG4gIG4ucmVnaXN0ZXJWaWV3KFwiY2VsbFwiLCBIdCksIG4ucmVnaXN0ZXJWaWV3KFwicmVzaXplclwiLCBudWxsKSwgbi5yZWdpc3RlclZpZXcoXCJzY3JvbGxiYXJcIiwgZmEpLCBuLnJlZ2lzdGVyVmlldyhcImxheW91dFwiLCBrbiwgZnVuY3Rpb24ocikge1xuICAgIChyLiRjb25maWcgPyByLiRjb25maWcuaWQgOiBudWxsKSA9PT0gXCJtYWluXCIgJiYgZShyLCBXYSk7XG4gIH0pLCBuLnJlZ2lzdGVyVmlldyhcInZpZXdjZWxsXCIsIGdhKSwgbi5yZWdpc3RlclZpZXcoXCJtdWx0aXZpZXdcIiwgX2EpLCBuLnJlZ2lzdGVyVmlldyhcInRpbWVsaW5lXCIsIFV0LCBmdW5jdGlvbihyKSB7XG4gICAgKHIuJGNvbmZpZyA/IHIuJGNvbmZpZy5pZCA6IG51bGwpICE9PSBcInRpbWVsaW5lXCIgJiYgci4kY29uZmlnLmJpbmQgIT0gXCJ0YXNrXCIgfHwgZShyLCB6YSk7XG4gIH0pLCBuLnJlZ2lzdGVyVmlldyhcImdyaWRcIiwgeGUsIGZ1bmN0aW9uKHIpIHtcbiAgICAoci4kY29uZmlnID8gci4kY29uZmlnLmlkIDogbnVsbCkgIT09IFwiZ3JpZFwiICYmIHIuJGNvbmZpZy5iaW5kICE9IFwidGFza1wiIHx8IGUociwgUmEpO1xuICB9KSwgbi5yZWdpc3RlclZpZXcoXCJyZXNvdXJjZUdyaWRcIiwgeGUpLCBuLnJlZ2lzdGVyVmlldyhcInJlc291cmNlVGltZWxpbmVcIiwgVXQpLCBuLnJlZ2lzdGVyVmlldyhcInJlc291cmNlSGlzdG9ncmFtXCIsIFV0KTtcbiAgdmFyIGkgPSBmdW5jdGlvbihyKSB7XG4gICAgdmFyIHMgPSB1YShyKTtcbiAgICByZXR1cm4geyBnZXREYXRhUmVuZGVyOiBmdW5jdGlvbihvKSB7XG4gICAgICByZXR1cm4gci4kc2VydmljZXMuZ2V0U2VydmljZShcImxheWVyOlwiICsgbykgfHwgbnVsbDtcbiAgICB9LCBjcmVhdGVEYXRhUmVuZGVyOiBmdW5jdGlvbihvKSB7XG4gICAgICB2YXIgbCA9IG8ubmFtZSwgZCA9IG8uZGVmYXVsdENvbnRhaW5lciwgYyA9IG8uZGVmYXVsdENvbnRhaW5lclNpYmxpbmcsIHUgPSBzLmNyZWF0ZUdyb3VwKGQsIGMsIGZ1bmN0aW9uKGgsIGcpIHtcbiAgICAgICAgaWYgKCF1LmZpbHRlcnMpIHJldHVybiAhMDtcbiAgICAgICAgZm9yICh2YXIgcCA9IDA7IHAgPCB1LmZpbHRlcnMubGVuZ3RoOyBwKyspIGlmICh1LmZpbHRlcnNbcF0oaCwgZykgPT09ICExKSByZXR1cm4gITE7XG4gICAgICB9LCBoYSk7XG4gICAgICByZXR1cm4gci4kc2VydmljZXMuc2V0U2VydmljZShcImxheWVyOlwiICsgbCwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB1O1xuICAgICAgfSksIHIuYXR0YWNoRXZlbnQoXCJvbkdhbnR0UmVhZHlcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHUuYWRkTGF5ZXIoKTtcbiAgICAgIH0pLCB1O1xuICAgIH0sIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG8gPSB0aGlzLmNyZWF0ZURhdGFSZW5kZXIoeyBuYW1lOiBcInRhc2tcIiwgZGVmYXVsdENvbnRhaW5lcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiByLiR0YXNrX2RhdGEgPyByLiR0YXNrX2RhdGEgOiByLiR1aS5nZXRWaWV3KFwidGltZWxpbmVcIikgPyByLiR1aS5nZXRWaWV3KFwidGltZWxpbmVcIikuJHRhc2tfZGF0YSA6IHZvaWQgMDtcbiAgICAgIH0sIGRlZmF1bHRDb250YWluZXJTaWJsaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHIuJHRhc2tfbGlua3MgPyByLiR0YXNrX2xpbmtzIDogci4kdWkuZ2V0VmlldyhcInRpbWVsaW5lXCIpID8gci4kdWkuZ2V0VmlldyhcInRpbWVsaW5lXCIpLiR0YXNrX2xpbmtzIDogdm9pZCAwO1xuICAgICAgfSwgZmlsdGVyOiBmdW5jdGlvbihkKSB7XG4gICAgICB9IH0sIHIpLCBsID0gdGhpcy5jcmVhdGVEYXRhUmVuZGVyKHsgbmFtZTogXCJsaW5rXCIsIGRlZmF1bHRDb250YWluZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gci4kdGFza19kYXRhID8gci4kdGFza19kYXRhIDogci4kdWkuZ2V0VmlldyhcInRpbWVsaW5lXCIpID8gci4kdWkuZ2V0VmlldyhcInRpbWVsaW5lXCIpLiR0YXNrX2RhdGEgOiB2b2lkIDA7XG4gICAgICB9IH0sIHIpO1xuICAgICAgcmV0dXJuIHsgYWRkVGFza0xheWVyOiBmdW5jdGlvbihkKSB7XG4gICAgICAgIGNvbnN0IGMgPSBmdDtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBkID09IFwiZnVuY3Rpb25cIiA/IGQgPSB7IHJlbmRlcmVyOiB7IHJlbmRlcjogZCwgZ2V0VmlzaWJsZVJhbmdlOiBjIH0gfSA6IGQucmVuZGVyZXIgJiYgIWQucmVuZGVyZXIuZ2V0VmlzaWJsZVJhbmdlICYmIChkLnJlbmRlcmVyLmdldFZpc2libGVSYW5nZSA9IGMpLCBkLnZpZXcgPSBcInRpbWVsaW5lXCIsIG8uYWRkTGF5ZXIoZCk7XG4gICAgICB9LCBfZ2V0VGFza0xheWVyczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBvLmdldExheWVycygpO1xuICAgICAgfSwgcmVtb3ZlVGFza0xheWVyOiBmdW5jdGlvbihkKSB7XG4gICAgICAgIG8ucmVtb3ZlTGF5ZXIoZCk7XG4gICAgICB9LCBfY2xlYXJUYXNrTGF5ZXJzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgby5jbGVhcigpO1xuICAgICAgfSwgYWRkTGlua0xheWVyOiBmdW5jdGlvbihkKSB7XG4gICAgICAgIGNvbnN0IGMgPSBtbigpO1xuICAgICAgICByZXR1cm4gdHlwZW9mIGQgPT0gXCJmdW5jdGlvblwiID8gZCA9IHsgcmVuZGVyZXI6IHsgcmVuZGVyOiBkLCBnZXRWaXNpYmxlUmFuZ2U6IGMgfSB9IDogZC5yZW5kZXJlciAmJiAhZC5yZW5kZXJlci5nZXRWaXNpYmxlUmFuZ2UgJiYgKGQucmVuZGVyZXIuZ2V0VmlzaWJsZVJhbmdlID0gYyksIGQudmlldyA9IFwidGltZWxpbmVcIiwgZCAmJiBkLnJlbmRlcmVyICYmIChkLnJlbmRlcmVyLmdldFJlY3RhbmdsZSB8fCBkLnJlbmRlcmVyLmlzSW5WaWV3UG9ydCB8fCAoZC5yZW5kZXJlci5pc0luVmlld1BvcnQgPSB2bikpLCBsLmFkZExheWVyKGQpO1xuICAgICAgfSwgX2dldExpbmtMYXllcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbC5nZXRMYXllcnMoKTtcbiAgICAgIH0sIHJlbW92ZUxpbmtMYXllcjogZnVuY3Rpb24oZCkge1xuICAgICAgICBsLnJlbW92ZUxheWVyKGQpO1xuICAgICAgfSwgX2NsZWFyTGlua0xheWVyczogZnVuY3Rpb24oKSB7XG4gICAgICAgIGwuY2xlYXIoKTtcbiAgICAgIH0gfTtcbiAgICB9IH07XG4gIH0odCksIGEgPSBEYSh0KTtcbiAgcmV0dXJuIHQuZXh0LmlubGluZUVkaXRvcnMgPSBhLCB0LmV4dC5faW5saW5lRWRpdG9ycyA9IGEsIGEuaW5pdCh0KSwgeyBmYWN0b3J5OiBuLCBtb3VzZUV2ZW50czogY2EuaW5pdCh0KSwgbGF5ZXJzQXBpOiBpLmluaXQoKSwgcmVuZGVyOiB7IGdyaWRMaW5lOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGZ1bmN0aW9uKHIpIHtcbiAgICAgIHJldHVybiB7IHJlbmRlcjogZnVuY3Rpb24ocywgbywgbCwgZCkge1xuICAgICAgICBmb3IgKHZhciBjID0gby5nZXRHcmlkQ29sdW1ucygpLCB1ID0gby4kZ2V0VGVtcGxhdGVzKCksIGggPSBvLiRjb25maWcucm93U3RvcmUsIGcgPSBbXSwgcCA9IDA7IHAgPCBjLmxlbmd0aDsgcCsrKSB7XG4gICAgICAgICAgdmFyIHksIHYsIGIsIF8gPSBwID09IGMubGVuZ3RoIC0gMSwgbSA9IGNbcF07XG4gICAgICAgICAgbS5uYW1lID09IFwiYWRkXCIgPyAodiA9IFwiPGRpdiBcIiArIChTID0gci5fd2FpQXJpYS5ncmlkQWRkQnV0dG9uQXR0clN0cmluZyhtKSkgKyBcIiBjbGFzcz0nZ2FudHRfYWRkJz48L2Rpdj5cIiwgYiA9IFwiXCIpIDogKFoodiA9IG0udGVtcGxhdGUgPyBtLnRlbXBsYXRlKHMpIDogc1ttLm5hbWVdKSAmJiAodiA9IHUuZGF0ZV9ncmlkKHYsIHMsIG0ubmFtZSkpLCB2ID09IG51bGwgJiYgKHYgPSBcIlwiKSwgYiA9IHYsIHYgPSBcIjxkaXYgY2xhc3M9J2dhbnR0X3RyZWVfY29udGVudCc+XCIgKyB2ICsgXCI8L2Rpdj5cIik7XG4gICAgICAgICAgdmFyIGYgPSBcImdhbnR0X2NlbGxcIiArIChfID8gXCIgZ2FudHRfbGFzdF9jZWxsXCIgOiBcIlwiKSwgayA9IFtdO1xuICAgICAgICAgIGlmIChtLnRyZWUpIHtcbiAgICAgICAgICAgIGYgKz0gXCIgZ2FudHRfY2VsbF90cmVlXCI7XG4gICAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHMuJGxldmVsOyB4KyspIGsucHVzaCh1LmdyaWRfaW5kZW50KHMpKTtcbiAgICAgICAgICAgICFoLmhhc0NoaWxkKHMuaWQpIHx8IHIuaXNTcGxpdFRhc2socykgJiYgIXIuY29uZmlnLm9wZW5fc3BsaXRfdGFza3MgPyAoay5wdXNoKHUuZ3JpZF9ibGFuayhzKSksIGsucHVzaCh1LmdyaWRfZmlsZShzKSkpIDogKGsucHVzaCh1LmdyaWRfb3BlbihzKSksIGsucHVzaCh1LmdyaWRfZm9sZGVyKHMpKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciAkID0gXCJ3aWR0aDpcIiArIChtLndpZHRoIC0gKF8gPyAxIDogMCkpICsgXCJweDtcIjtcbiAgICAgICAgICBpZiAodGhpcy5kZWZpbmVkKG0uYWxpZ24pKSB7XG4gICAgICAgICAgICB2YXIgdyA9IHsgcmlnaHQ6IFwiZmxleC1lbmRcIiwgbGVmdDogXCJmbGV4LXN0YXJ0XCIsIGNlbnRlcjogXCJjZW50ZXJcIiB9W20uYWxpZ25dO1xuICAgICAgICAgICAgJCArPSBcInRleHQtYWxpZ246XCIgKyBtLmFsaWduICsgXCI7anVzdGlmeS1jb250ZW50OlwiICsgdyArIFwiO1wiO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgUyA9IHIuX3dhaUFyaWEuZ3JpZENlbGxBdHRyU3RyaW5nKG0sIGIsIHMpO1xuICAgICAgICAgIGsucHVzaCh2KSwgeSA9IFwiPGRpdiBjbGFzcz0nXCIgKyBmICsgXCInIGRhdGEtY29sdW1uLWluZGV4PSdcIiArIHAgKyBcIicgZGF0YS1jb2x1bW4tbmFtZT0nXCIgKyBtLm5hbWUgKyBcIicgc3R5bGU9J1wiICsgJCArIFwiJyBcIiArIFMgKyBcIj5cIiArIGsuam9pbihcIlwiKSArIFwiPC9kaXY+XCIsIGcucHVzaCh5KTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGYgPSBcIlwiLCBoLiRjb25maWcubmFtZSkge1xuICAgICAgICAgIGNhc2UgXCJ0YXNrXCI6XG4gICAgICAgICAgICBmID0gci5nZXRHbG9iYWxUYXNrSW5kZXgocy5pZCkgJSAyID09IDAgPyBcIlwiIDogXCIgb2RkXCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwicmVzb3VyY2VcIjpcbiAgICAgICAgICAgIGYgPSBoLnZpc2libGVPcmRlci5pbmRleE9mKHMuaWQpICUgMiA9PSAwID8gXCJcIiA6IFwiIG9kZFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmICs9IHMuJHRyYW5zcGFyZW50ID8gXCIgZ2FudHRfdHJhbnNwYXJlbnRcIiA6IFwiXCIsIGYgKz0gcy4kZGF0YXByb2Nlc3Nvcl9jbGFzcyA/IFwiIFwiICsgcy4kZGF0YXByb2Nlc3Nvcl9jbGFzcyA6IFwiXCIsIHUuZ3JpZF9yb3dfY2xhc3MpIHtcbiAgICAgICAgICB2YXIgVCA9IHUuZ3JpZF9yb3dfY2xhc3MuY2FsbChyLCBzLnN0YXJ0X2RhdGUsIHMuZW5kX2RhdGUsIHMpO1xuICAgICAgICAgIFQgJiYgKGYgKz0gXCIgXCIgKyBUKTtcbiAgICAgICAgfVxuICAgICAgICBoLmlzU2VsZWN0ZWQocy5pZCkgJiYgKGYgKz0gXCIgZ2FudHRfc2VsZWN0ZWRcIik7XG4gICAgICAgIHZhciBFID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgRS5jbGFzc05hbWUgPSBcImdhbnR0X3Jvd1wiICsgZiArIFwiIGdhbnR0X3Jvd19cIiArIHIuZ2V0VGFza1R5cGUocy50eXBlKTtcbiAgICAgICAgdmFyIEMgPSBvLmdldEl0ZW1IZWlnaHQocy5pZCk7XG4gICAgICAgIHJldHVybiBFLnN0eWxlLmhlaWdodCA9IEMgKyBcInB4XCIsIEUuc3R5bGUubGluZUhlaWdodCA9IEMgKyBcInB4XCIsIGwuc21hcnRfcmVuZGVyaW5nICYmIChFLnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiLCBFLnN0eWxlLmxlZnQgPSBcIjBweFwiLCBFLnN0eWxlLnRvcCA9IG8uZ2V0SXRlbVRvcChzLmlkKSArIFwicHhcIiksIG8uJGNvbmZpZy5pdGVtX2F0dHJpYnV0ZSAmJiAoRS5zZXRBdHRyaWJ1dGUoby4kY29uZmlnLml0ZW1fYXR0cmlidXRlLCBzLmlkKSwgRS5zZXRBdHRyaWJ1dGUoby4kY29uZmlnLmJpbmQgKyBcIl9pZFwiLCBzLmlkKSksIHIuX3dhaUFyaWEudGFza1Jvd0F0dHIocywgRSksIEUuaW5uZXJIVE1MID0gZy5qb2luKFwiXCIpLCBFO1xuICAgICAgfSwgdXBkYXRlOiBudWxsLCBnZXRSZWN0YW5nbGU6IEt0LCBpc0luVmlld1BvcnQ6IE1hLCBnZXRWaXNpYmxlUmFuZ2U6IGZ0LCBvbnJlbmRlcjogZnVuY3Rpb24ocywgbywgbCkge1xuICAgICAgICBmb3IgKHZhciBkID0gbC5nZXRHcmlkQ29sdW1ucygpLCBjID0gMDsgYyA8IGQubGVuZ3RoOyBjKyspIHtcbiAgICAgICAgICB2YXIgdSA9IGRbY107XG4gICAgICAgICAgaWYgKHUub25yZW5kZXIpIHtcbiAgICAgICAgICAgIHZhciBoID0gby5xdWVyeVNlbGVjdG9yKFwiW2RhdGEtY29sdW1uLW5hbWU9XCIgKyB1Lm5hbWUgKyBcIl1cIik7XG4gICAgICAgICAgICBpZiAoaCkge1xuICAgICAgICAgICAgICB2YXIgZyA9IHUub25yZW5kZXIocywgaCk7XG4gICAgICAgICAgICAgIGlmIChnICYmIHR5cGVvZiBnID09IFwic3RyaW5nXCIpIGguaW5uZXJIVE1MID0gZztcbiAgICAgICAgICAgICAgZWxzZSBpZiAoZyAmJiB0eXBlb2YgZyA9PSBcIm9iamVjdFwiICYmIHIuY29uZmlnLmV4dGVybmFsX3JlbmRlcikge1xuICAgICAgICAgICAgICAgIHZhciBwID0gci5jb25maWcuZXh0ZXJuYWxfcmVuZGVyO1xuICAgICAgICAgICAgICAgIHAuaXNFbGVtZW50KGcpICYmIHAucmVuZGVyRWxlbWVudChnLCBoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSB9O1xuICAgIH0odCk7XG4gIH0sIHRhc2tCZzogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBmdW5jdGlvbihyKSB7XG4gICAgICB2YXIgcyA9IHt9LCBvID0ge307XG4gICAgICBmdW5jdGlvbiBsKGcsIHApIHtcbiAgICAgICAgcmV0dXJuICEoIXNbZy5pZF1bcF0gfHwgIXNbZy5pZF1bcF0ucGFyZW50Tm9kZSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBkKGcsIHApIHtcbiAgICAgICAgc1tnXSAmJiBzW2ddW3BdICYmIHNbZ11bcF0ucGFyZW50Tm9kZSAmJiBzW2ddW3BdLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc1tnXVtwXSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBjKGcpIHtcbiAgICAgICAgdmFyIHAsIHkgPSBnLiRnZXRUZW1wbGF0ZXMoKTtcbiAgICAgICAgcmV0dXJuIHkudGFza19jZWxsX2NsYXNzICE9PSB2b2lkIDAgPyAocCA9IHkudGFza19jZWxsX2NsYXNzLCAoY29uc29sZS53YXJuIHx8IGNvbnNvbGUubG9nKShcImdhbnR0LnRlbXBsYXRlcy50YXNrX2NlbGxfY2xhc3MgdGVtcGxhdGUgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIHNvb24uIFBsZWFzZSB1c2UgZ2FudHQudGVtcGxhdGVzLnRpbWVsaW5lX2NlbGxfY2xhc3MgaW5zdGVhZC5cIikpIDogcCA9IHkudGltZWxpbmVfY2VsbF9jbGFzcywgcDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHUoZykge1xuICAgICAgICByZXR1cm4gZy4kZ2V0VGVtcGxhdGVzKCkudGltZWxpbmVfY2VsbF9jb250ZW50O1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gaChnLCBwLCB5LCB2LCBiLCBfLCBtLCBmKSB7XG4gICAgICAgIHZhciBrID0gZy53aWR0aFtwXSwgeCA9IFwiXCI7XG4gICAgICAgIGlmIChvZShwLCBnLCB2LCByKSkge1xuICAgICAgICAgIHZhciAkID0gXyh5LCBnLnRyYWNlX3hbcF0pLCB3ID0gXCJcIjtcbiAgICAgICAgICBpZiAobSAmJiAodyA9IG0oeSwgZy50cmFjZV94W3BdKSksIGYuc3RhdGljX2JhY2tncm91bmQpIHtcbiAgICAgICAgICAgIHZhciBTID0gISghJCAmJiAhdyk7XG4gICAgICAgICAgICBpZiAoIWYuc3RhdGljX2JhY2tncm91bmRfY2VsbHMgfHwgIVMpIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc1t5LmlkXVtwXSkgcmV0dXJuIG9beS5pZF1bcF0gPSBwLCBzW3kuaWRdW3BdO1xuICAgICAgICAgIHZhciBUID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICByZXR1cm4gVC5zdHlsZS53aWR0aCA9IGsgKyBcInB4XCIsIHggPSBcImdhbnR0X3Rhc2tfY2VsbFwiICsgKHAgPT0gYiAtIDEgPyBcIiBnYW50dF9sYXN0X2NlbGxcIiA6IFwiXCIpLCAkICYmICh4ICs9IFwiIFwiICsgJCksIFQuY2xhc3NOYW1lID0geCwgdyAmJiAoVC5pbm5lckhUTUwgPSB3KSwgVC5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIiwgVC5zdHlsZS5sZWZ0ID0gZy5sZWZ0W3BdICsgXCJweFwiLCBzW3kuaWRdW3BdID0gVCwgb1t5LmlkXVtwXSA9IHAsIFQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4geyByZW5kZXI6IGZ1bmN0aW9uKGcsIHAsIHksIHYpIHtcbiAgICAgICAgdmFyIGIgPSBwLiRnZXRUZW1wbGF0ZXMoKSwgXyA9IHAuZ2V0U2NhbGUoKSwgbSA9IF8uY291bnQ7XG4gICAgICAgIGlmICh5LnN0YXRpY19iYWNrZ3JvdW5kICYmICF5LnN0YXRpY19iYWNrZ3JvdW5kX2NlbGxzKSByZXR1cm4gbnVsbDtcbiAgICAgICAgdmFyIGYsIGsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLCB4ID0gYyhwKSwgJCA9IHUocCk7XG4gICAgICAgIGlmIChmID0gdiAmJiB5LnNtYXJ0X3JlbmRlcmluZyAmJiAhTnQocikgPyBqdChfLCB2LngpIDogeyBzdGFydDogMCwgZW5kOiBtIC0gMSB9LCB5LnNob3dfdGFza19jZWxscykge1xuICAgICAgICAgIHNbZy5pZF0gPSB7fSwgb1tnLmlkXSA9IHt9O1xuICAgICAgICAgIGZvciAodmFyIHcgPSBmLnN0YXJ0OyB3IDw9IGYuZW5kOyB3KyspIHtcbiAgICAgICAgICAgIHZhciBTID0gaChfLCB3LCBnLCB2LCBtLCB4LCAkLCB5KTtcbiAgICAgICAgICAgIFMgJiYgay5hcHBlbmRDaGlsZChTKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgVCA9IHAuJGNvbmZpZy5yb3dTdG9yZSwgRSA9IFQuZ2V0SW5kZXhCeUlkKGcuaWQpICUgMiAhPSAwO1xuICAgICAgICB2YXIgQyA9IGIudGFza19yb3dfY2xhc3MoZy5zdGFydF9kYXRlLCBnLmVuZF9kYXRlLCBnKSwgRCA9IFwiZ2FudHRfdGFza19yb3dcIiArIChFID8gXCIgb2RkXCIgOiBcIlwiKSArIChDID8gXCIgXCIgKyBDIDogXCJcIik7XG4gICAgICAgIGlmIChULmlzU2VsZWN0ZWQoZy5pZCkgJiYgKEQgKz0gXCIgZ2FudHRfc2VsZWN0ZWRcIiksIGsuY2xhc3NOYW1lID0gRCwgeS5zbWFydF9yZW5kZXJpbmcgPyAoay5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIiwgay5zdHlsZS50b3AgPSBwLmdldEl0ZW1Ub3AoZy5pZCkgKyBcInB4XCIsIGsuc3R5bGUud2lkdGggPSBcIjEwMCVcIikgOiBrLnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiLCBrLnN0eWxlLmhlaWdodCA9IHAuZ2V0SXRlbUhlaWdodChnLmlkKSArIFwicHhcIiwgZy5pZCA9PSBcInRpbWVsaW5lX3BsYWNlaG9sZGVyX3Rhc2tcIikge1xuICAgICAgICAgIHZhciBNID0gMDtcbiAgICAgICAgICBnLmxhc3RUYXNrSWQgJiYgKE0gPSBwLmdldEl0ZW1Ub3AoZy5sYXN0VGFza0lkKSArIHAuZ2V0SXRlbUhlaWdodChnLmxhc3RUYXNrSWQpKTtcbiAgICAgICAgICB2YXIgSSA9IChnLnJvd19oZWlnaHQgfHwgcC4kdGFza19kYXRhLm9mZnNldEhlaWdodCkgLSBNO1xuICAgICAgICAgIEkgPCAwICYmIChJID0gMCksIHkuc21hcnRfcmVuZGVyaW5nICYmIChrLnN0eWxlLnRvcCA9IE0gKyBcInB4XCIpLCBrLnN0eWxlLmhlaWdodCA9IEkgKyBcInB4XCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHAuJGNvbmZpZy5pdGVtX2F0dHJpYnV0ZSAmJiAoay5zZXRBdHRyaWJ1dGUocC4kY29uZmlnLml0ZW1fYXR0cmlidXRlLCBnLmlkKSwgay5zZXRBdHRyaWJ1dGUocC4kY29uZmlnLmJpbmQgKyBcIl9pZFwiLCBnLmlkKSksIGs7XG4gICAgICB9LCB1cGRhdGU6IGZ1bmN0aW9uKGcsIHAsIHksIHYsIGIpIHtcbiAgICAgICAgdmFyIF8gPSB5LmdldFNjYWxlKCksIG0gPSBfLmNvdW50LCBmID0gYyh5KSwgayA9IHUoeSk7XG4gICAgICAgIGlmICh2LnNob3dfdGFza19jZWxscykge1xuICAgICAgICAgIHNbZy5pZF0gfHwgKHNbZy5pZF0gPSB7fSksIG9bZy5pZF0gfHwgKG9bZy5pZF0gPSB7fSk7XG4gICAgICAgICAgdmFyIHggPSBqdChfLCBiKTtcbiAgICAgICAgICBmb3IgKHZhciAkIGluIG9bZy5pZF0pIHtcbiAgICAgICAgICAgIHZhciB3ID0gb1tnLmlkXVskXTtcbiAgICAgICAgICAgIChOdW1iZXIodykgPCB4LnN0YXJ0IHx8IE51bWJlcih3KSA+IHguZW5kKSAmJiBkKGcuaWQsIHcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvW2cuaWRdID0ge307XG4gICAgICAgICAgZm9yICh2YXIgUyA9IHguc3RhcnQ7IFMgPD0geC5lbmQ7IFMrKykge1xuICAgICAgICAgICAgdmFyIFQgPSBoKF8sIFMsIGcsIGIsIG0sIGYsIGssIHYpO1xuICAgICAgICAgICAgIVQgJiYgbChnLCBTKSA/IGQoZy5pZCwgUykgOiBUICYmICFULnBhcmVudE5vZGUgJiYgcC5hcHBlbmRDaGlsZChUKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIGdldFJlY3RhbmdsZTogcWUsIGdldFZpc2libGVSYW5nZTogZnQsIHByZXBhcmVEYXRhOiBBYSB9O1xuICAgIH0odCk7XG4gIH0sIHRhc2tCYXI6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBVZSh0KTtcbiAgfSwgdGltZWRQcm9qZWN0QmFyOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gVWUodCk7XG4gIH0sIHRhc2tSb2xsdXBCYXI6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBmdW5jdGlvbihyKSB7XG4gICAgICBjb25zdCBzID0gYm4ociksIG8gPSB7fTtcbiAgICAgIGZ1bmN0aW9uIGwodSwgaCwgZywgcCwgeSkge1xuICAgICAgICBsZXQgdiA9ICEwO1xuICAgICAgICByZXR1cm4gcC5zbWFydF9yZW5kZXJpbmcgJiYgKHYgPSAkZSh1LCBoLCBnKSksIHY7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBkKHUsIGgsIGcsIHApIHtcbiAgICAgICAgY29uc3QgeSA9IHIuY29weShyLmdldFRhc2soaC5pZCkpO1xuICAgICAgICBpZiAoeS4kcmVuZGVyZWRfYXQgPSB1LmlkLCByLmNhbGxFdmVudChcIm9uQmVmb3JlUm9sbHVwVGFza0Rpc3BsYXlcIiwgW3kuaWQsIHksIHUuaWRdKSA9PT0gITEpIHJldHVybjtcbiAgICAgICAgY29uc3QgdiA9IHMoeSwgZyk7XG4gICAgICAgIGlmICghdikgcmV0dXJuO1xuICAgICAgICBjb25zdCBiID0gZy5nZXRCYXJIZWlnaHQodS5pZCwgaC50eXBlID09IHIuY29uZmlnLnR5cGVzLm1pbGVzdG9uZSksIF8gPSBNYXRoLmZsb29yKChnLmdldEl0ZW1IZWlnaHQodS5pZCkgLSBiKSAvIDIpO1xuICAgICAgICByZXR1cm4gdi5zdHlsZS50b3AgPSBwLnRvcCArIF8gKyBcInB4XCIsIHYuY2xhc3NMaXN0LmFkZChcImdhbnR0X3JvbGx1cF9jaGlsZFwiKSwgdi5zZXRBdHRyaWJ1dGUoXCJkYXRhLXJvbGx1cC1wYXJlbnQtaWRcIiwgdS5pZCksIHY7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBjKHUsIGgpIHtcbiAgICAgICAgcmV0dXJuIHUgKyBcIl9cIiArIGg7XG4gICAgICB9XG4gICAgICByZXR1cm4geyByZW5kZXI6IGZ1bmN0aW9uKHUsIGgsIGcsIHApIHtcbiAgICAgICAgaWYgKHUucm9sbHVwICE9PSAhMSAmJiB1LiRyb2xsdXAgJiYgdS4kcm9sbHVwLmxlbmd0aCkge1xuICAgICAgICAgIGNvbnN0IHkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLCB2ID0gci5nZXRUYXNrUG9zaXRpb24odSk7XG4gICAgICAgICAgcmV0dXJuIHAgJiYgKHAueSA9IDAsIHAueV9lbmQgPSByLiR0YXNrX2JnLnNjcm9sbEhlaWdodCksIHUuJHJvbGx1cC5mb3JFYWNoKGZ1bmN0aW9uKGIpIHtcbiAgICAgICAgICAgIGlmICghci5pc1Rhc2tFeGlzdHMoYikpIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IF8gPSByLmdldFRhc2soYik7XG4gICAgICAgICAgICBpZiAoIWwoXywgcCwgaCwgZykpIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IG0gPSBkKHUsIF8sIGgsIHYpO1xuICAgICAgICAgICAgbSA/IChvW2MoXy5pZCwgdS5pZCldID0gbSwgeS5hcHBlbmRDaGlsZChtKSkgOiBvW2MoXy5pZCwgdS5pZCldID0gITE7XG4gICAgICAgICAgfSksIHk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgfSwgdXBkYXRlOiBmdW5jdGlvbih1LCBoLCBnLCBwLCB5KSB7XG4gICAgICAgIGNvbnN0IHYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLCBiID0gci5nZXRUYXNrUG9zaXRpb24odSk7XG4gICAgICAgIHkueSA9IDAsIHkueV9lbmQgPSByLiR0YXNrX2JnLnNjcm9sbEhlaWdodCwgdS4kcm9sbHVwLmZvckVhY2goZnVuY3Rpb24oXykge1xuICAgICAgICAgIGNvbnN0IG0gPSByLmdldFRhc2soXyksIGYgPSBjKG0uaWQsIHUuaWQpO1xuICAgICAgICAgIGxldCBrID0gbChtLCB5LCBnLCBwKTtcbiAgICAgICAgICBpZiAoayAhPT0gISFvW2ZdKSBpZiAoaykge1xuICAgICAgICAgICAgY29uc3QgeCA9IGQodSwgbSwgZywgYik7XG4gICAgICAgICAgICBvW2ZdID0geCB8fCAhMTtcbiAgICAgICAgICB9IGVsc2Ugb1tmXSA9ICExO1xuICAgICAgICAgIG9bZl0gJiYgdi5hcHBlbmRDaGlsZChvW2ZdKSwgaC5pbm5lckhUTUwgPSBcIlwiLCBoLmFwcGVuZENoaWxkKHYpO1xuICAgICAgICB9KTtcbiAgICAgIH0sIGlzSW5WaWV3UG9ydDogJGUsIGdldFZpc2libGVSYW5nZTogZnQgfTtcbiAgICB9KHQpO1xuICB9LCB0YXNrU3BsaXRCYXI6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBDdCgpO1xuICB9LCB0YXNrQ29uc3RyYWludHM6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBDdCgpO1xuICB9LCB0YXNrRGVhZGxpbmU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBDdCgpO1xuICB9LCB0YXNrQmFzZWxpbmVzOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gQ3QoKTtcbiAgfSwgbGluazogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIElhKHQpO1xuICB9LCByZXNvdXJjZVJvdzogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHIpIHtcbiAgICAgIHZhciBzID0gTmEociksIG8gPSB7fTtcbiAgICAgIGZ1bmN0aW9uIGwoYywgdSwgaCwgZywgcCkge1xuICAgICAgICB2YXIgeSA9IGgucmVzb3VyY2VfY2VsbF9jbGFzcyh1LnN0YXJ0X2RhdGUsIHUuZW5kX2RhdGUsIGMsIHUudGFza3MsIHUuYXNzaWdubWVudHMpLCB2ID0gaC5yZXNvdXJjZV9jZWxsX3ZhbHVlKHUuc3RhcnRfZGF0ZSwgdS5lbmRfZGF0ZSwgYywgdS50YXNrcywgdS5hc3NpZ25tZW50cyksIGIgPSBwLmdldEl0ZW1IZWlnaHQoYy5pZCkgLSAxO1xuICAgICAgICBpZiAoeSB8fCB2KSB7XG4gICAgICAgICAgdmFyIF8gPSBwLmdldEl0ZW1Qb3NpdGlvbihjLCB1LnN0YXJ0X2RhdGUsIHUuZW5kX2RhdGUpLCBtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICByZXR1cm4gbS5zZXRBdHRyaWJ1dGUocC4kY29uZmlnLml0ZW1fYXR0cmlidXRlLCBjLmlkKSwgbS5jbGFzc05hbWUgPSBbXCJnYW50dF9yZXNvdXJjZV9tYXJrZXJcIiwgeV0uam9pbihcIiBcIiksIG0uc3R5bGUuY3NzVGV4dCA9IFtcImxlZnQ6XCIgKyBfLmxlZnQgKyBcInB4XCIsIFwid2lkdGg6XCIgKyBfLndpZHRoICsgXCJweFwiLCBcImhlaWdodDpcIiArIGIgKyBcInB4XCIsIFwibGluZS1oZWlnaHQ6XCIgKyBiICsgXCJweFwiLCBcInRvcDpcIiArIF8udG9wICsgXCJweFwiXS5qb2luKFwiO1wiKSwgdiAmJiAobS5pbm5lckhUTUwgPSB2KSwgbTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGQoYywgdSkge1xuICAgICAgICBvW2NdICYmIG9bY11bdV0gJiYgb1tjXVt1XS5wYXJlbnROb2RlICYmIG9bY11bdV0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChvW2NdW3VdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IHJlbmRlcjogZnVuY3Rpb24oYywgdSwgaCwgZykge1xuICAgICAgICB2YXIgcCA9IHUuJGdldFRlbXBsYXRlcygpLCB5ID0gdS5nZXRTY2FsZSgpLCB2ID0gcyhjLCBoLnJlc291cmNlX3Byb3BlcnR5LCB1LmdldFNjYWxlKCksIHUpLCBiID0gISFnLCBfID0gW107XG4gICAgICAgIG9bYy5pZF0gPSB7fTtcbiAgICAgICAgZm9yICh2YXIgbSA9IGp0KHksIGcpLCBmID0gbS5zdGFydDsgZiA8PSBtLmVuZDsgZisrKSB7XG4gICAgICAgICAgdmFyIGsgPSB2W2ZdO1xuICAgICAgICAgIGlmIChrICYmICghYiB8fCBvZShmLCB5LCBnLCByKSkpIHtcbiAgICAgICAgICAgIHZhciB4ID0gbChjLCBrLCBwLCAwLCB1KTtcbiAgICAgICAgICAgIHggJiYgKF8ucHVzaCh4KSwgb1tjLmlkXVtmXSA9IHgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgJCA9IG51bGw7XG4gICAgICAgIGlmIChfLmxlbmd0aCkge1xuICAgICAgICAgICQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgIGZvciAodmFyIHcgPSAwOyB3IDwgXy5sZW5ndGg7IHcrKykgJC5hcHBlbmRDaGlsZChfW3ddKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJDtcbiAgICAgIH0sIHVwZGF0ZTogZnVuY3Rpb24oYywgdSwgaCwgZywgcCkge1xuICAgICAgICB2YXIgeSA9IGguJGdldFRlbXBsYXRlcygpLCB2ID0gaC5nZXRTY2FsZSgpLCBiID0gcyhjLCBnLnJlc291cmNlX3Byb3BlcnR5LCBoLmdldFNjYWxlKCksIGgpLCBfID0ganQodiwgcCksIG0gPSB7fTtcbiAgICAgICAgaWYgKG8gJiYgb1tjLmlkXSkgZm9yICh2YXIgZiBpbiBvW2MuaWRdKSBtW2ZdID0gZjtcbiAgICAgICAgZm9yICh2YXIgayA9IF8uc3RhcnQ7IGsgPD0gXy5lbmQ7IGsrKykge1xuICAgICAgICAgIHZhciB4ID0gYltrXTtcbiAgICAgICAgICBpZiAobVtrXSA9ICExLCB4KSBpZiAob2UoaywgdiwgcCwgcikpIGlmIChvW2MuaWRdICYmIG9bYy5pZF1ba10pIG9bYy5pZF0gJiYgb1tjLmlkXVtrXSAmJiAhb1tjLmlkXVtrXS5wYXJlbnROb2RlICYmIHUuYXBwZW5kQ2hpbGQob1tjLmlkXVtrXSk7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgJCA9IGwoYywgeCwgeSwgMCwgaCk7XG4gICAgICAgICAgICAkICYmICh1LmFwcGVuZENoaWxkKCQpLCBvW2MuaWRdW2tdID0gJCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgZChjLmlkLCBrKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBmIGluIG0pIG1bZl0gIT09ICExICYmIGQoYy5pZCwgZik7XG4gICAgICB9LCBnZXRSZWN0YW5nbGU6IHFlLCBnZXRWaXNpYmxlUmFuZ2U6IGZ0IH07XG4gICAgfSh0KTtcbiAgfSwgcmVzb3VyY2VIaXN0b2dyYW06IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBDdCgpO1xuICB9LCBncmlkVGFza1Jvd1Jlc2l6ZXI6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gZnVuY3Rpb24ocikge1xuICAgICAgcmV0dXJuIHsgcmVuZGVyOiBmdW5jdGlvbihzLCBvLCBsKSB7XG4gICAgICAgIHZhciBkID0gby4kZ2V0Q29uZmlnKCksIGMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICByZXR1cm4gYy5jbGFzc05hbWUgPSBcImdhbnR0X3Rhc2tfZ3JpZF9yb3dfcmVzaXplX3dyYXBcIiwgYy5zdHlsZS50b3AgPSBvLmdldEl0ZW1Ub3Aocy5pZCkgKyBvLmdldEl0ZW1IZWlnaHQocy5pZCkgKyBcInB4XCIsIGMuaW5uZXJIVE1MID0gXCI8ZGl2IGNsYXNzPSdnYW50dF90YXNrX2dyaWRfcm93X3Jlc2l6ZScgcm9sZT0nY2VsbCc+PC9kaXY+XCIsIGMuc2V0QXR0cmlidXRlKGQudGFza19ncmlkX3Jvd19yZXNpemVyX2F0dHJpYnV0ZSwgcy5pZCksIHIuX3dhaUFyaWEucm93UmVzaXplckF0dHIoYyksIGM7XG4gICAgICB9LCB1cGRhdGU6IG51bGwsIGdldFJlY3RhbmdsZTogS3QsIGdldFZpc2libGVSYW5nZTogZnQgfTtcbiAgICB9KHQpO1xuICB9IH0sIGxheWVyc1NlcnZpY2U6IHsgZ2V0RGF0YVJlbmRlcjogZnVuY3Rpb24ocikge1xuICAgIHJldHVybiBpLmdldERhdGFSZW5kZXIociwgdCk7XG4gIH0sIGNyZWF0ZURhdGFSZW5kZXI6IGZ1bmN0aW9uKHIpIHtcbiAgICByZXR1cm4gaS5jcmVhdGVEYXRhUmVuZGVyKHIsIHQpO1xuICB9IH0gfTtcbn0gfTtcbmZ1bmN0aW9uIGNlKHQsIGUpIHtcbiAgY29uc3QgbiA9IGdldENvbXB1dGVkU3R5bGUoZS4kcm9vdCkuZ2V0UHJvcGVydHlWYWx1ZShcIi0tZGh4LWdhbnR0LXRoZW1lXCIpO1xuICBsZXQgaSwgYSA9ICEhbjtcbiAgaWYgKGEpIGkgPSBuO1xuICBlbHNlIHtcbiAgICB2YXIgciA9IGUuc2tpbjtcbiAgICBpZiAoaSA9IHIsICFyIHx8IHQpIGZvciAodmFyIHMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImxpbmtcIiksIG8gPSAwOyBvIDwgcy5sZW5ndGg7IG8rKykge1xuICAgICAgdmFyIGwgPSBzW29dLmhyZWYubWF0Y2goXCJkaHRtbHhnYW50dF8oW2Etel9dKykuY3NzXCIpO1xuICAgICAgaWYgKGwgJiYgKGUuc2tpbnNbbFsxXV0gfHwgIXIpKSB7XG4gICAgICAgIGkgPSBsWzFdO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZS5fdGhlbWVfaW5mbyA9IHsgdGhlbWU6IGksIGNzc1ZhclRoZW1lOiBhIH0sIGUuc2tpbiA9IGkgfHwgXCJ0ZXJyYWNlXCI7XG4gIHZhciBkID0gZS5za2luc1tlLnNraW5dIHx8IGUuc2tpbnMudGVycmFjZTtcbiAgKGZ1bmN0aW9uKGgsIGcsIHApIHtcbiAgICBmb3IgKHZhciB5IGluIGcpIChoW3ldID09PSB2b2lkIDAgfHwgcCkgJiYgKGhbeV0gPSBnW3ldKTtcbiAgfSkoZS5jb25maWcsIGQuY29uZmlnLCB0KSwgYSB8fCAoZS5jb25maWcubGlua19yYWRpdXMgPSAxKTtcbiAgdmFyIGMgPSBlLmdldEdyaWRDb2x1bW5zKCk7XG4gIGZvciAoY1sxXSAmJiAhZS5kZWZpbmVkKGNbMV0ud2lkdGgpICYmIChjWzFdLndpZHRoID0gZC5fc2Vjb25kX2NvbHVtbl93aWR0aCksIGNbMl0gJiYgIWUuZGVmaW5lZChjWzJdLndpZHRoKSAmJiAoY1syXS53aWR0aCA9IGQuX3RoaXJkX2NvbHVtbl93aWR0aCksIG8gPSAwOyBvIDwgYy5sZW5ndGg7IG8rKykge1xuICAgIHZhciB1ID0gY1tvXTtcbiAgICB1Lm5hbWUgPT0gXCJhZGRcIiAmJiAodS53aWR0aCB8fCAodS53aWR0aCA9IDQ0KSwgZS5kZWZpbmVkKHUubWluX3dpZHRoKSAmJiBlLmRlZmluZWQodS5tYXhfd2lkdGgpIHx8ICh1Lm1pbl93aWR0aCA9IHUubWluX3dpZHRoIHx8IHUud2lkdGgsIHUubWF4X3dpZHRoID0gdS5tYXhfd2lkdGggfHwgdS53aWR0aCksIHUubWluX3dpZHRoICYmICh1Lm1pbl93aWR0aCA9ICt1Lm1pbl93aWR0aCksIHUubWF4X3dpZHRoICYmICh1Lm1heF93aWR0aCA9ICt1Lm1heF93aWR0aCksIHUud2lkdGggJiYgKHUud2lkdGggPSArdS53aWR0aCwgdS53aWR0aCA9IHUubWluX3dpZHRoICYmIHUubWluX3dpZHRoID4gdS53aWR0aCA/IHUubWluX3dpZHRoIDogdS53aWR0aCwgdS53aWR0aCA9IHUubWF4X3dpZHRoICYmIHUubWF4X3dpZHRoIDwgdS53aWR0aCA/IHUubWF4X3dpZHRoIDogdS53aWR0aCkpO1xuICB9XG4gIGQuY29uZmlnLnRhc2tfaGVpZ2h0ICYmIChlLmNvbmZpZy50YXNrX2hlaWdodCA9IGQuY29uZmlnLnRhc2tfaGVpZ2h0IHx8IFwiZnVsbFwiKSwgZC5jb25maWcuYmFyX2hlaWdodCAmJiAoZS5jb25maWcuYmFyX2hlaWdodCA9IGQuY29uZmlnLmJhcl9oZWlnaHQgfHwgXCJmdWxsXCIpLCBkLl9saWdodGJveF90ZW1wbGF0ZSAmJiAoZS5fbGlnaHRib3hfdGVtcGxhdGUgPSBkLl9saWdodGJveF90ZW1wbGF0ZSksIGQuX3JlZGVmaW5lX2xpZ2h0Ym94X2J1dHRvbnMgJiYgKGUuY29uZmlnLmJ1dHRvbnNfcmlnaHQgPSBkLl9yZWRlZmluZV9saWdodGJveF9idXR0b25zLmJ1dHRvbnNfcmlnaHQsIGUuY29uZmlnLmJ1dHRvbnNfbGVmdCA9IGQuX3JlZGVmaW5lX2xpZ2h0Ym94X2J1dHRvbnMuYnV0dG9uc19sZWZ0KSwgZS5yZXNldExpZ2h0Ym94KCk7XG59XG5mdW5jdGlvbiBGYSh0KSB7XG4gIHZhciBlID0gbnVsbCwgbiA9ICExLCBpID0gbnVsbCwgYSA9IHsgc3RhcnRlZDogITEgfSwgciA9IHt9O1xuICBmdW5jdGlvbiBzKGcpIHtcbiAgICByZXR1cm4gZyAmJiBZKGcsIHQuJHJvb3QpICYmIGcub2Zmc2V0SGVpZ2h0O1xuICB9XG4gIGZ1bmN0aW9uIG8oKSB7XG4gICAgdmFyIGcgPSAhIWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIuZ2FudHRfZHJhZ19tYXJrZXJcIiksIHAgPSAhIWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIuZ2FudHRfZHJhZ19tYXJrZXIuZ2FudHRfZ3JpZF9yZXNpemVfYXJlYVwiKSB8fCAhIWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIuZ2FudHRfZHJhZ19tYXJrZXIuZ2FudHRfcm93X2dyaWRfcmVzaXplX2FyZWFcIiksIHkgPSAhIWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIuZ2FudHRfbGlua19kaXJlY3Rpb25cIiksIHYgPSB0LmdldFN0YXRlKCksIGIgPSB2LmF1dG9zY3JvbGw7XG4gICAgcmV0dXJuIG4gPSBnICYmICFwICYmICF5LCAhKCF2LmRyYWdfbW9kZSAmJiAhZyB8fCBwKSB8fCBiO1xuICB9XG4gIGZ1bmN0aW9uIGwoZykge1xuICAgIGlmIChpICYmIChjbGVhclRpbWVvdXQoaSksIGkgPSBudWxsKSwgZykge1xuICAgICAgdmFyIHAgPSB0LmNvbmZpZy5hdXRvc2Nyb2xsX3NwZWVkO1xuICAgICAgcCAmJiBwIDwgMTAgJiYgKHAgPSAxMCksIGkgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBlID0gc2V0SW50ZXJ2YWwodSwgcCB8fCA1MCk7XG4gICAgICB9LCB0LmNvbmZpZy5hdXRvc2Nyb2xsX2RlbGF5IHx8IDEwKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZChnKSB7XG4gICAgZyA/IChsKCEwKSwgYS5zdGFydGVkIHx8IChhLnggPSByLngsIGEueSA9IHIueSwgYS5zdGFydGVkID0gITApKSA6IChlICYmIChjbGVhckludGVydmFsKGUpLCBlID0gbnVsbCksIGwoITEpLCBhLnN0YXJ0ZWQgPSAhMSk7XG4gIH1cbiAgZnVuY3Rpb24gYyhnKSB7XG4gICAgdmFyIHAgPSBvKCk7XG4gICAgaWYgKCFlICYmICFpIHx8IHAgfHwgZCghMSksICF0LmNvbmZpZy5hdXRvc2Nyb2xsIHx8ICFwKSByZXR1cm4gITE7XG4gICAgciA9IHsgeDogZy5jbGllbnRYLCB5OiBnLmNsaWVudFkgfSwgZy50eXBlID09IFwidG91Y2htb3ZlXCIgJiYgKHIueCA9IGcudGFyZ2V0VG91Y2hlc1swXS5jbGllbnRYLCByLnkgPSBnLnRhcmdldFRvdWNoZXNbMF0uY2xpZW50WSksICFlICYmIHAgJiYgZCghMCk7XG4gIH1cbiAgZnVuY3Rpb24gdSgpIHtcbiAgICBpZiAoIW8oKSkgcmV0dXJuIGQoITEpLCAhMTtcbiAgICB2YXIgZyA9IHModC4kdGFzaykgPyB0LiR0YXNrIDogcyh0LiRncmlkKSA/IHQuJGdyaWQgOiB0LiRyb290O1xuICAgIGlmIChnKSB7XG4gICAgICB2YXIgcCA9ICExO1xuICAgICAgW1wiLmdhbnR0X2RyYWdfbWFya2VyLmdhbnR0X2dyaWRfcmVzaXplX2FyZWFcIiwgXCIuZ2FudHRfZHJhZ19tYXJrZXIgLmdhbnR0X3Jvdy5nYW50dF9yb3dfdGFza1wiLCBcIi5nYW50dF9kcmFnX21hcmtlci5nYW50dF9ncmlkX2RuZF9tYXJrZXJcIl0uZm9yRWFjaChmdW5jdGlvbihDKSB7XG4gICAgICAgIHAgPSBwIHx8ICEhZG9jdW1lbnQucXVlcnlTZWxlY3RvcihDKTtcbiAgICAgIH0pLCBwICYmIChnID0gdC4kZ3JpZCk7XG4gICAgICB2YXIgeSA9IFYoZyksIHYgPSByLnggLSB5LngsIGIgPSByLnkgLSB5LnkgKyB3aW5kb3cuc2Nyb2xsWSwgXyA9IG4gPyAwIDogaCh2LCB5LndpZHRoLCBhLnggLSB5LngpLCBtID0gaChiLCB5LmhlaWdodCwgYS55IC0geS55ICsgd2luZG93LnNjcm9sbFkpLCBmID0gdC5nZXRTY3JvbGxTdGF0ZSgpLCBrID0gZi55LCB4ID0gZi5pbm5lcl9oZWlnaHQsICQgPSBmLmhlaWdodCwgdyA9IGYueCwgUyA9IGYuaW5uZXJfd2lkdGgsIFQgPSBmLndpZHRoO1xuICAgICAgKG0gJiYgIXggfHwgbSA8IDAgJiYgIWsgfHwgbSA+IDAgJiYgayArIHggPj0gJCArIDIpICYmIChtID0gMCksIChfICYmICFTIHx8IF8gPCAwICYmICF3IHx8IF8gPiAwICYmIHcgKyBTID49IFQpICYmIChfID0gMCk7XG4gICAgICB2YXIgRSA9IHQuY29uZmlnLmF1dG9zY3JvbGxfc3RlcDtcbiAgICAgIEUgJiYgRSA8IDIgJiYgKEUgPSAyKSwgbSAqPSBFIHx8IDMwLCAoKF8gKj0gRSB8fCAzMCkgfHwgbSkgJiYgZnVuY3Rpb24oQywgRCkge1xuICAgICAgICB2YXIgTSA9IHQuZ2V0U2Nyb2xsU3RhdGUoKSwgSSA9IG51bGwsIEEgPSBudWxsO1xuICAgICAgICBDICYmIChJID0gTS54ICsgQywgSSA9IE1hdGgubWluKE0ud2lkdGgsIEkpLCBJID0gTWF0aC5tYXgoMCwgSSkpLCBEICYmIChBID0gTS55ICsgRCwgQSA9IE1hdGgubWluKE0uaGVpZ2h0LCBBKSwgQSA9IE1hdGgubWF4KDAsIEEpKSwgdC5zY3JvbGxUbyhJLCBBKTtcbiAgICAgIH0oXywgbSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGgoZywgcCwgeSkge1xuICAgIHJldHVybiBnIC0gNTAgPCAwICYmIGcgPCB5ID8gLTEgOiBnID4gcCAtIDUwICYmIGcgPiB5ID8gMSA6IDA7XG4gIH1cbiAgdC5hdHRhY2hFdmVudChcIm9uR2FudHRSZWFkeVwiLCBmdW5jdGlvbigpIHtcbiAgICBpZiAoIUYodCkpIHtcbiAgICAgIHZhciBnID0gdnQodC4kcm9vdCkgfHwgZG9jdW1lbnQuYm9keTtcbiAgICAgIHQuZXZlbnRSZW1vdmUoZywgXCJtb3VzZW1vdmVcIiwgYyksIHQuZXZlbnQoZywgXCJtb3VzZW1vdmVcIiwgYyksIHQuZXZlbnRSZW1vdmUoZywgXCJ0b3VjaG1vdmVcIiwgYyksIHQuZXZlbnQoZywgXCJ0b3VjaG1vdmVcIiwgYyksIHQuZXZlbnRSZW1vdmUoZywgXCJwb2ludGVybW92ZVwiLCBjKSwgdC5ldmVudChnLCBcInBvaW50ZXJtb3ZlXCIsIGMpO1xuICAgIH1cbiAgfSksIHQuYXR0YWNoRXZlbnQoXCJvbkRlc3Ryb3lcIiwgZnVuY3Rpb24oKSB7XG4gICAgZCghMSk7XG4gIH0pO1xufVxudmFyIHVlLCBoZTtcbndpbmRvdy5qUXVlcnkgJiYgKHVlID0gd2luZG93LmpRdWVyeSwgaGUgPSBbXSwgdWUuZm4uZGh4X2dhbnR0ID0gZnVuY3Rpb24odCkge1xuICBpZiAodHlwZW9mICh0ID0gdCB8fCB7fSkgIT0gXCJzdHJpbmdcIikge1xuICAgIHZhciBlID0gW107XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzICYmIHRoaXMuZ2V0QXR0cmlidXRlKSBpZiAodGhpcy5nYW50dCB8fCB3aW5kb3cuZ2FudHQuJHJvb3QgPT0gdGhpcykgZS5wdXNoKHR5cGVvZiB0aGlzLmdhbnR0ID09IFwib2JqZWN0XCIgPyB0aGlzLmdhbnR0IDogd2luZG93LmdhbnR0KTtcbiAgICAgIGVsc2Uge1xuICAgICAgICB2YXIgbiA9IHdpbmRvdy5nYW50dC4kY29udGFpbmVyICYmIHdpbmRvdy5HYW50dCA/IHdpbmRvdy5HYW50dC5nZXRHYW50dEluc3RhbmNlKCkgOiB3aW5kb3cuZ2FudHQ7XG4gICAgICAgIGZvciAodmFyIGkgaW4gdCkgaSAhPSBcImRhdGFcIiAmJiAobi5jb25maWdbaV0gPSB0W2ldKTtcbiAgICAgICAgbi5pbml0KHRoaXMpLCB0LmRhdGEgJiYgbi5wYXJzZSh0LmRhdGEpLCBlLnB1c2gobik7XG4gICAgICB9XG4gICAgfSksIGUubGVuZ3RoID09PSAxID8gZVswXSA6IGU7XG4gIH1cbiAgaWYgKGhlW3RdKSByZXR1cm4gaGVbdF0uYXBwbHkodGhpcywgW10pO1xuICB1ZS5lcnJvcihcIk1ldGhvZCBcIiArIHQgKyBcIiBkb2VzIG5vdCBleGlzdCBvbiBqUXVlcnkuZGh4X2dhbnR0XCIpO1xufSk7XG53aW5kb3cuZGh0bWx4ICYmICh3aW5kb3cuZGh0bWx4LmF0dGFjaGVzIHx8ICh3aW5kb3cuZGh0bWx4LmF0dGFjaGVzID0ge30pLCB3aW5kb3cuZGh0bWx4LmF0dGFjaGVzLmF0dGFjaEdhbnR0ID0gZnVuY3Rpb24odCwgZSwgbikge1xuICB2YXIgaSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJESVZcIik7XG4gIG4gPSBuIHx8IHdpbmRvdy5nYW50dCwgaS5pZCA9IFwiZ2FudHRfXCIgKyBuLnVpZCgpLCBpLnN0eWxlLndpZHRoID0gXCIxMDAlXCIsIGkuc3R5bGUuaGVpZ2h0ID0gXCIxMDAlXCIsIGkuY21wID0gXCJncmlkXCIsIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaSksIHRoaXMuYXR0YWNoT2JqZWN0KGkuaWQpLCB0aGlzLmRhdGFUeXBlID0gXCJnYW50dFwiLCB0aGlzLmRhdGFPYmogPSBuO1xuICB2YXIgYSA9IHRoaXMudnNbdGhpcy5hdl07XG4gIHJldHVybiBhLmdyaWQgPSBuLCBuLmluaXQoaS5pZCwgdCwgZSksIGkuZmlyc3RDaGlsZC5zdHlsZS5ib3JkZXIgPSBcIm5vbmVcIiwgYS5ncmlkSWQgPSBpLmlkLCBhLmdyaWRPYmogPSBpLCB0aGlzLnZzW3RoaXMuX3ZpZXdSZXN0b3JlKCldLmdyaWQ7XG59KSwgd2luZG93LmRodG1sWENlbGxPYmplY3QgIT09IHZvaWQgMCAmJiAod2luZG93LmRodG1sWENlbGxPYmplY3QucHJvdG90eXBlLmF0dGFjaEdhbnR0ID0gZnVuY3Rpb24odCwgZSwgbikge1xuICBuID0gbiB8fCB3aW5kb3cuZ2FudHQ7XG4gIHZhciBpID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIkRJVlwiKTtcbiAgcmV0dXJuIGkuaWQgPSBcImdhbnR0X1wiICsgbi51aWQoKSwgaS5zdHlsZS53aWR0aCA9IFwiMTAwJVwiLCBpLnN0eWxlLmhlaWdodCA9IFwiMTAwJVwiLCBpLmNtcCA9IFwiZ3JpZFwiLCBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGkpLCB0aGlzLmF0dGFjaE9iamVjdChpLmlkKSwgdGhpcy5kYXRhVHlwZSA9IFwiZ2FudHRcIiwgdGhpcy5kYXRhT2JqID0gbiwgbi5pbml0KGkuaWQsIHQsIGUpLCBpLmZpcnN0Q2hpbGQuc3R5bGUuYm9yZGVyID0gXCJub25lXCIsIGkgPSBudWxsLCB0aGlzLmNhbGxFdmVudChcIl9vbkNvbnRlbnRBdHRhY2hcIiwgW10pLCB0aGlzLmRhdGFPYmo7XG59KTtcbmNvbnN0IFZhID0gW1wiY3RybEtleVwiLCBcImFsdEtleVwiLCBcInNoaWZ0S2V5XCIsIFwibWV0YUtleVwiXSwgVWEgPSBbW3sgdW5pdDogXCJtb250aFwiLCBkYXRlOiBcIiVNXCIsIHN0ZXA6IDEgfSwgeyB1bml0OiBcImRheVwiLCBkYXRlOiBcIiVkXCIsIHN0ZXA6IDEgfV0sIFt7IHVuaXQ6IFwiZGF5XCIsIGRhdGU6IFwiJWQgJU1cIiwgc3RlcDogMSB9XSwgW3sgdW5pdDogXCJkYXlcIiwgZGF0ZTogXCIlZCAlTVwiLCBzdGVwOiAxIH0sIHsgdW5pdDogXCJob3VyXCIsIGRhdGU6IFwiJUg6MDBcIiwgc3RlcDogOCB9XSwgW3sgdW5pdDogXCJkYXlcIiwgZGF0ZTogXCIlZCAlTVwiLCBzdGVwOiAxIH0sIHsgdW5pdDogXCJob3VyXCIsIGRhdGU6IFwiJUg6MDBcIiwgc3RlcDogMSB9XV07XG5jbGFzcyBxYSB7XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICB0aGlzLnpvb21JbiA9ICgpID0+IHtcbiAgICAgIGNvbnN0IG4gPSB0aGlzLmdldEN1cnJlbnRMZXZlbCgpIC0gMTtcbiAgICAgIG4gPCAwIHx8IHRoaXMuc2V0TGV2ZWwobik7XG4gICAgfSwgdGhpcy56b29tT3V0ID0gKCkgPT4ge1xuICAgICAgY29uc3QgbiA9IHRoaXMuZ2V0Q3VycmVudExldmVsKCkgKyAxO1xuICAgICAgbiA+IHRoaXMuX2xldmVscy5sZW5ndGggLSAxIHx8IHRoaXMuc2V0TGV2ZWwobik7XG4gICAgfSwgdGhpcy5nZXRDdXJyZW50TGV2ZWwgPSAoKSA9PiB0aGlzLl9hY3RpdmVMZXZlbEluZGV4LCB0aGlzLmdldExldmVscyA9ICgpID0+IHRoaXMuX2xldmVscywgdGhpcy5zZXRMZXZlbCA9IChuKSA9PiB7XG4gICAgICBjb25zdCBpID0gdGhpcy5fZ2V0Wm9vbUluZGV4QnlOYW1lKG4pO1xuICAgICAgaSA9PT0gLTEgJiYgdGhpcy4kZ2FudHQuYXNzZXJ0KGkgIT09IC0xLCBcIkludmFsaWQgem9vbSBsZXZlbCBmb3IgZ2FudHQuZXh0Lnpvb20uc2V0TGV2ZWwuIFwiICsgbiArIFwiIGlzIG5vdCBhbiBleHBlY3RlZCB2YWx1ZS5cIiksIHRoaXMuX3NldExldmVsKGksIDApO1xuICAgIH0sIHRoaXMuX2dldFpvb21JbmRleEJ5TmFtZSA9IChuKSA9PiB7XG4gICAgICBsZXQgaSA9IC0xO1xuICAgICAgaWYgKHR5cGVvZiBuID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKCFpc05hTihOdW1iZXIobikpICYmIHRoaXMuX2xldmVsc1tOdW1iZXIobildKSBpID0gTnVtYmVyKG4pO1xuICAgICAgICBlbHNlIGZvciAobGV0IGEgPSAwOyBhIDwgdGhpcy5fbGV2ZWxzLmxlbmd0aDsgYSsrKSBpZiAodGhpcy5fbGV2ZWxzW2FdLm5hbWUgPT09IG4pIHtcbiAgICAgICAgICBpID0gYTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGkgPSBuO1xuICAgICAgcmV0dXJuIGk7XG4gICAgfSwgdGhpcy5fZ2V0VmlzaWJsZURhdGUgPSAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuJGdhbnR0LiR0YXNrKSByZXR1cm4gbnVsbDtcbiAgICAgIGNvbnN0IG4gPSB0aGlzLiRnYW50dC5nZXRTY3JvbGxTdGF0ZSgpLngsIGkgPSB0aGlzLiRnYW50dC4kdGFzay5vZmZzZXRXaWR0aDtcbiAgICAgIHRoaXMuX3Zpc2libGVEYXRlID0gdGhpcy4kZ2FudHQuZGF0ZUZyb21Qb3MobiArIGkgLyAyKTtcbiAgICB9LCB0aGlzLl9zZXRMZXZlbCA9IChuLCBpKSA9PiB7XG4gICAgICB0aGlzLl9hY3RpdmVMZXZlbEluZGV4ID0gbjtcbiAgICAgIGNvbnN0IGEgPSB0aGlzLiRnYW50dCwgciA9IGEuY29weSh0aGlzLl9sZXZlbHNbdGhpcy5fYWN0aXZlTGV2ZWxJbmRleF0pLCBzID0gYS5jb3B5KHIpO1xuICAgICAgaWYgKGRlbGV0ZSBzLm5hbWUsIGEubWl4aW4oYS5jb25maWcsIHMsICEwKSwgW1wicmVzb3VyY2VUaW1lbGluZVwiLCBcInJlc291cmNlSGlzdG9ncmFtXCJdLmZvckVhY2goZnVuY3Rpb24obykge1xuICAgICAgICBjb25zdCBsID0gYS4kdWkuZ2V0VmlldyhvKTtcbiAgICAgICAgaWYgKGwpIHtcbiAgICAgICAgICBjb25zdCBkID0gbC4kZ2V0Q29uZmlnKCk7XG4gICAgICAgICAgZC5maXhlZF9zY2FsZXMgfHwgYS5taXhpbihkLCBzLCAhMCk7XG4gICAgICAgIH1cbiAgICAgIH0pLCBhLiRyb290ICYmIGEuJHRhc2spIHtcbiAgICAgICAgaWYgKGkpIHtcbiAgICAgICAgICBjb25zdCBvID0gdGhpcy4kZ2FudHQuZGF0ZUZyb21Qb3MoaSArIHRoaXMuJGdhbnR0LmdldFNjcm9sbFN0YXRlKCkueCk7XG4gICAgICAgICAgdGhpcy4kZ2FudHQucmVuZGVyKCk7XG4gICAgICAgICAgY29uc3QgbCA9IHRoaXMuJGdhbnR0LnBvc0Zyb21EYXRlKG8pO1xuICAgICAgICAgIHRoaXMuJGdhbnR0LnNjcm9sbFRvKGwgLSBpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBvID0gdGhpcy4kZ2FudHQuJHRhc2sub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgdGhpcy5fdmlzaWJsZURhdGUgfHwgdGhpcy5fZ2V0VmlzaWJsZURhdGUoKTtcbiAgICAgICAgICBjb25zdCBsID0gdGhpcy5fdmlzaWJsZURhdGU7XG4gICAgICAgICAgdGhpcy4kZ2FudHQucmVuZGVyKCk7XG4gICAgICAgICAgY29uc3QgZCA9IHRoaXMuJGdhbnR0LnBvc0Zyb21EYXRlKGwpO1xuICAgICAgICAgIHRoaXMuJGdhbnR0LnNjcm9sbFRvKGQgLSBvIC8gMik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYWxsRXZlbnQoXCJvbkFmdGVyWm9vbVwiLCBbdGhpcy5fYWN0aXZlTGV2ZWxJbmRleCwgcl0pO1xuICAgICAgfVxuICAgIH0sIHRoaXMuX2F0dGFjaFdoZWVsRXZlbnQgPSAobikgPT4ge1xuICAgICAgY29uc3QgaSA9IG10LmlzRkYgPyBcIndoZWVsXCIgOiBcIm1vdXNld2hlZWxcIjtcbiAgICAgIGxldCBhO1xuICAgICAgYSA9IHR5cGVvZiBuLmVsZW1lbnQgPT0gXCJmdW5jdGlvblwiID8gbi5lbGVtZW50KCkgOiBuLmVsZW1lbnQsIGEgJiYgdGhpcy5fZG9tRXZlbnRzLmF0dGFjaChhLCBpLCB0aGlzLiRnYW50dC5iaW5kKGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgaWYgKHRoaXMuX3VzZUtleSAmJiAoVmEuaW5kZXhPZih0aGlzLl91c2VLZXkpIDwgMCB8fCAhclt0aGlzLl91c2VLZXldKSlcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5faGFuZGxlciA9PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0aGlzLl9oYW5kbGVyLmFwcGx5KHRoaXMsIFtyXSksICEwO1xuICAgICAgfSwgdGhpcyksIHsgcGFzc2l2ZTogITEgfSk7XG4gICAgfSwgdGhpcy5fZGVmYXVsdEhhbmRsZXIgPSAobikgPT4ge1xuICAgICAgY29uc3QgaSA9IHRoaXMuJGdhbnR0LiR0YXNrLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLngsIGEgPSBuLmNsaWVudFggLSBpO1xuICAgICAgbGV0IHIgPSAhMTtcbiAgICAgICh0aGlzLiRnYW50dC5lbnYuaXNGRiA/IC00MCAqIG4uZGVsdGFZIDogbi53aGVlbERlbHRhKSA+IDAgJiYgKHIgPSAhMCksIG4ucHJldmVudERlZmF1bHQoKSwgbi5zdG9wUHJvcGFnYXRpb24oKSwgdGhpcy5fc2V0U2NhbGVTZXR0aW5ncyhyLCBhKTtcbiAgICB9LCB0aGlzLl9zZXRTY2FsZURhdGVzID0gKCkgPT4ge1xuICAgICAgdGhpcy5faW5pdGlhbFN0YXJ0RGF0ZSAmJiB0aGlzLl9pbml0aWFsRW5kRGF0ZSAmJiAodGhpcy4kZ2FudHQuY29uZmlnLnN0YXJ0X2RhdGUgPSB0aGlzLl9pbml0aWFsU3RhcnREYXRlLCB0aGlzLiRnYW50dC5jb25maWcuZW5kX2RhdGUgPSB0aGlzLl9pbml0aWFsRW5kRGF0ZSk7XG4gICAgfSwgdGhpcy4kZ2FudHQgPSBlLCB0aGlzLl9kb21FdmVudHMgPSB0aGlzLiRnYW50dC5fY3JlYXRlRG9tRXZlbnRTY29wZSgpO1xuICB9XG4gIGluaXQoZSkge1xuICAgIHRoaXMuJGdhbnR0LmVudi5pc05vZGUgfHwgKHRoaXMuX2luaXRpYWxTdGFydERhdGUgPSBlLnN0YXJ0RGF0ZSwgdGhpcy5faW5pdGlhbEVuZERhdGUgPSBlLmVuZERhdGUsIHRoaXMuX2FjdGl2ZUxldmVsSW5kZXggPSBlLmFjdGl2ZUxldmVsSW5kZXggPyBlLmFjdGl2ZUxldmVsSW5kZXggOiAwLCB0aGlzLl9sZXZlbHMgPSB0aGlzLl9tYXBTY2FsZXMoZS5sZXZlbHMgfHwgVWEpLCB0aGlzLl9oYW5kbGVyID0gZS5oYW5kbGVyIHx8IHRoaXMuX2RlZmF1bHRIYW5kbGVyLCB0aGlzLl9taW5Db2x1bW5XaWR0aCA9IGUubWluQ29sdW1uV2lkdGggfHwgNjAsIHRoaXMuX21heENvbHVtbldpZHRoID0gZS5tYXhDb2x1bW5XaWR0aCB8fCAyNDAsIHRoaXMuX3dpZHRoU3RlcCA9IGUud2lkdGhTdGVwIHx8IDMgLyA4ICogZS5taW5Db2x1bW5XaWR0aCwgdGhpcy5fdXNlS2V5ID0gZS51c2VLZXksIHRoaXMuX2luaXRpYWxpemVkIHx8IChvdCh0aGlzKSwgdGhpcy4kZ2FudHQuYXR0YWNoRXZlbnQoXCJvbkdhbnR0U2Nyb2xsXCIsICgpID0+IHtcbiAgICAgIHRoaXMuX2dldFZpc2libGVEYXRlKCk7XG4gICAgfSkpLCB0aGlzLl9kb21FdmVudHMuZGV0YWNoQWxsKCksIGUudHJpZ2dlciA9PT0gXCJ3aGVlbFwiICYmICh0aGlzLiRnYW50dC4kcm9vdCA/IHRoaXMuX2F0dGFjaFdoZWVsRXZlbnQoZSkgOiB0aGlzLiRnYW50dC5hdHRhY2hFdmVudChcIm9uR2FudHRMYXlvdXRSZWFkeVwiLCAoKSA9PiB7XG4gICAgICB0aGlzLiRnYW50dC5hdHRhY2hFdmVudChcIm9uR2FudHRSZW5kZXJcIiwgKCkgPT4ge1xuICAgICAgICB0aGlzLl9hdHRhY2hXaGVlbEV2ZW50KGUpO1xuICAgICAgfSwgeyBvbmNlOiAhMCB9KTtcbiAgICB9KSksIHRoaXMuX2luaXRpYWxpemVkID0gITAsIHRoaXMuc2V0TGV2ZWwodGhpcy5fYWN0aXZlTGV2ZWxJbmRleCkpO1xuICB9XG4gIF9tYXBTY2FsZXMoZSkge1xuICAgIHJldHVybiBlLm1hcCgobikgPT4gQXJyYXkuaXNBcnJheShuKSA/IHsgc2NhbGVzOiBuIH0gOiBuKTtcbiAgfVxuICBfc2V0U2NhbGVTZXR0aW5ncyhlLCBuKSB7XG4gICAgZSA/IHRoaXMuX3N0ZXBVcChuKSA6IHRoaXMuX3N0ZXBEb3duKG4pO1xuICB9XG4gIF9zdGVwVXAoZSkge1xuICAgIGlmICh0aGlzLl9hY3RpdmVMZXZlbEluZGV4ID49IHRoaXMuX2xldmVscy5sZW5ndGggLSAxKSByZXR1cm47XG4gICAgbGV0IG4gPSB0aGlzLl9hY3RpdmVMZXZlbEluZGV4O1xuICAgIGlmICh0aGlzLl9zZXRTY2FsZURhdGVzKCksIHRoaXMuX3dpZHRoU3RlcCkge1xuICAgICAgbGV0IGkgPSB0aGlzLiRnYW50dC5jb25maWcubWluX2NvbHVtbl93aWR0aCArIHRoaXMuX3dpZHRoU3RlcDtcbiAgICAgIGkgPiB0aGlzLl9tYXhDb2x1bW5XaWR0aCAmJiAoaSA9IHRoaXMuX21pbkNvbHVtbldpZHRoLCBuKyspLCB0aGlzLiRnYW50dC5jb25maWcubWluX2NvbHVtbl93aWR0aCA9IGk7XG4gICAgfSBlbHNlIG4rKztcbiAgICB0aGlzLl9zZXRMZXZlbChuLCBlKTtcbiAgfVxuICBfc3RlcERvd24oZSkge1xuICAgIGlmICh0aGlzLl9hY3RpdmVMZXZlbEluZGV4IDwgMSkgcmV0dXJuO1xuICAgIGxldCBuID0gdGhpcy5fYWN0aXZlTGV2ZWxJbmRleDtcbiAgICBpZiAodGhpcy5fc2V0U2NhbGVEYXRlcygpLCB0aGlzLl93aWR0aFN0ZXApIHtcbiAgICAgIGxldCBpID0gdGhpcy4kZ2FudHQuY29uZmlnLm1pbl9jb2x1bW5fd2lkdGggLSB0aGlzLl93aWR0aFN0ZXA7XG4gICAgICBpIDwgdGhpcy5fbWluQ29sdW1uV2lkdGggJiYgKGkgPSB0aGlzLl9tYXhDb2x1bW5XaWR0aCwgbi0tKSwgdGhpcy4kZ2FudHQuY29uZmlnLm1pbl9jb2x1bW5fd2lkdGggPSBpO1xuICAgIH0gZWxzZSBuLS07XG4gICAgdGhpcy5fc2V0TGV2ZWwobiwgZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIEdhKHQpIHtcbiAgZnVuY3Rpb24gZSgpIHtcbiAgICBpZiAodC5jb25maWcudG91Y2ggIT0gXCJmb3JjZVwiICYmICh0LmNvbmZpZy50b3VjaCA9IHQuY29uZmlnLnRvdWNoICYmIChuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoXCJNb2JpbGVcIikgIT0gLTEgfHwgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKFwiaVBhZFwiKSAhPSAtMSB8fCBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoXCJBbmRyb2lkXCIpICE9IC0xIHx8IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihcIlRvdWNoXCIpICE9IC0xKSB8fCBuYXZpZ2F0b3IucGxhdGZvcm0gPT09IFwiTWFjSW50ZWxcIiAmJiBuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgPiAxKSwgdC5jb25maWcudG91Y2gpIHtcbiAgICAgIHZhciByID0gITA7XG4gICAgICB0cnkge1xuICAgICAgICBkb2N1bWVudC5jcmVhdGVFdmVudChcIlRvdWNoRXZlbnRcIik7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgciA9ICExO1xuICAgICAgfVxuICAgICAgciA/IHQuX3RvdWNoX2V2ZW50cyhbXCJ0b3VjaG1vdmVcIiwgXCJ0b3VjaHN0YXJ0XCIsIFwidG91Y2hlbmRcIl0sIGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgcmV0dXJuIHMudG91Y2hlcyAmJiBzLnRvdWNoZXMubGVuZ3RoID4gMSA/IG51bGwgOiBzLnRvdWNoZXNbMF0gPyB7IHRhcmdldDogcy50YXJnZXQsIHBhZ2VYOiBzLnRvdWNoZXNbMF0ucGFnZVgsIHBhZ2VZOiBzLnRvdWNoZXNbMF0ucGFnZVksIGNsaWVudFg6IHMudG91Y2hlc1swXS5jbGllbnRYLCBjbGllbnRZOiBzLnRvdWNoZXNbMF0uY2xpZW50WSB9IDogcztcbiAgICAgIH0sIGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgcmV0dXJuIHMuZGVmYXVsdFByZXZlbnRlZDtcbiAgICAgIH0pIDogd2luZG93Lm5hdmlnYXRvci5wb2ludGVyRW5hYmxlZCA/IHQuX3RvdWNoX2V2ZW50cyhbXCJwb2ludGVybW92ZVwiLCBcInBvaW50ZXJkb3duXCIsIFwicG9pbnRlcnVwXCJdLCBmdW5jdGlvbihzKSB7XG4gICAgICAgIHJldHVybiBzLnBvaW50ZXJUeXBlID09IFwibW91c2VcIiA/IG51bGwgOiBzO1xuICAgICAgfSwgZnVuY3Rpb24ocykge1xuICAgICAgICByZXR1cm4gIXMgfHwgcy5wb2ludGVyVHlwZSA9PSBcIm1vdXNlXCI7XG4gICAgICB9KSA6IHdpbmRvdy5uYXZpZ2F0b3IubXNQb2ludGVyRW5hYmxlZCAmJiB0Ll90b3VjaF9ldmVudHMoW1wiTVNQb2ludGVyTW92ZVwiLCBcIk1TUG9pbnRlckRvd25cIiwgXCJNU1BvaW50ZXJVcFwiXSwgZnVuY3Rpb24ocykge1xuICAgICAgICByZXR1cm4gcy5wb2ludGVyVHlwZSA9PSBzLk1TUE9JTlRFUl9UWVBFX01PVVNFID8gbnVsbCA6IHM7XG4gICAgICB9LCBmdW5jdGlvbihzKSB7XG4gICAgICAgIHJldHVybiAhcyB8fCBzLnBvaW50ZXJUeXBlID09IHMuTVNQT0lOVEVSX1RZUEVfTU9VU0U7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gbihyKSB7XG4gICAgdmFyIHMgPSByLiRjb25maWcuc2Nyb2xsWCA/IHQuJHVpLmdldFZpZXcoci4kY29uZmlnLnNjcm9sbFgpIDogbnVsbCwgbyA9IHIuJGNvbmZpZy5zY3JvbGxZID8gdC4kdWkuZ2V0VmlldyhyLiRjb25maWcuc2Nyb2xsWSkgOiBudWxsLCBsID0geyB4OiBudWxsLCB5OiBudWxsIH07XG4gICAgcmV0dXJuIHMgJiYgcy5nZXRTY3JvbGxTdGF0ZSgpLnZpc2libGUgJiYgKGwueCA9IHMuJHZpZXcuc2Nyb2xsTGVmdCksIG8gJiYgby5nZXRTY3JvbGxTdGF0ZSgpLnZpc2libGUgJiYgKGwueSA9IG8uJHZpZXcuc2Nyb2xsVG9wKSwgbDtcbiAgfVxuICBmdW5jdGlvbiBpKCkge1xuICAgIHZhciByO1xuICAgIHJldHVybiB0LiR1aS5nZXRWaWV3KFwidGltZWxpbmVcIikgJiYgKHIgPSB0LiR1aS5nZXRWaWV3KFwidGltZWxpbmVcIikuX3Rhc2tzX2RuZCksIHI7XG4gIH1cbiAgdC5jb25maWcudG91Y2hfZHJhZyA9IDc1LCB0LmNvbmZpZy50b3VjaCA9ICEwLCB0LmNvbmZpZy50b3VjaF9mZWVkYmFjayA9ICEwLCB0LmNvbmZpZy50b3VjaF9mZWVkYmFja19kdXJhdGlvbiA9IDEsIHQuX3ByZXZlbnRfdG91Y2hfc2Nyb2xsID0gITEsIHQuX3RvdWNoX2ZlZWRiYWNrID0gZnVuY3Rpb24oKSB7XG4gICAgdC5jb25maWcudG91Y2hfZmVlZGJhY2sgJiYgbmF2aWdhdG9yLnZpYnJhdGUgJiYgbmF2aWdhdG9yLnZpYnJhdGUodC5jb25maWcudG91Y2hfZmVlZGJhY2tfZHVyYXRpb24pO1xuICB9LCB0LmF0dGFjaEV2ZW50KFwib25HYW50dFJlYWR5XCIsIGZ1bmN0aW9uKCkge1xuICAgIHQuJGNvbnRhaW5lciAmJiBlKCk7XG4gIH0pLCB0LmF0dGFjaEV2ZW50KFwib25HYW50dExheW91dFJlYWR5XCIsIGZ1bmN0aW9uKCkge1xuICAgIHQuJGNvbnRhaW5lciAmJiB0LmF0dGFjaEV2ZW50KFwib25HYW50dFJlbmRlclwiLCBlLCB7IG9uY2U6ICEwIH0pO1xuICB9KTtcbiAgdmFyIGEgPSBbXTtcbiAgdC5fdG91Y2hfZXZlbnRzID0gZnVuY3Rpb24ociwgcywgbykge1xuICAgIHZhciBsLCBkID0gMCwgYyA9ICExLCB1ID0gITEsIGggPSBudWxsLCBnID0gbnVsbCwgcCA9IG51bGwsIHkgPSBbXSwgdiA9IG51bGw7XG4gICAgbGV0IGIgPSB7fTtcbiAgICBmb3IgKHZhciBfID0gMDsgXyA8IGEubGVuZ3RoOyBfKyspIHQuZXZlbnRSZW1vdmUoYVtfXVswXSwgYVtfXVsxXSwgYVtfXVsyXSk7XG4gICAgKGEgPSBbXSkucHVzaChbdC4kY29udGFpbmVyLCByWzBdLCBmdW5jdGlvbihmKSB7XG4gICAgICB2YXIgayA9IGkoKTtcbiAgICAgIGlmICghbyhmKSAmJiBjKSB7XG4gICAgICAgIGcgJiYgY2xlYXJUaW1lb3V0KGcpO1xuICAgICAgICB2YXIgeCA9IHMoZik7XG4gICAgICAgIGlmIChrICYmIChrLmRyYWcuaWQgfHwgay5kcmFnLnN0YXJ0X2RyYWcpKSByZXR1cm4gay5vbl9tb3VzZV9tb3ZlKHgpLCBmLnByZXZlbnREZWZhdWx0ICYmIGYucHJldmVudERlZmF1bHQoKSwgZi5jYW5jZWxCdWJibGUgPSAhMCwgITE7XG4gICAgICAgIGlmICghdC5fcHJldmVudF90b3VjaF9zY3JvbGwpIHtcbiAgICAgICAgICBpZiAoeCAmJiBoKSB7XG4gICAgICAgICAgICB2YXIgJCA9IGgucGFnZVggLSB4LnBhZ2VYLCB3ID0gaC5wYWdlWSAtIHgucGFnZVk7XG4gICAgICAgICAgICBpZiAoIXUgJiYgKE1hdGguYWJzKCQpID4gNSB8fCBNYXRoLmFicyh3KSA+IDUpICYmICh1ID0gITAsIGQgPSAwLCBsID0gdiA/IG4odikgOiB0LmdldFNjcm9sbFN0YXRlKCkpLCB1KSB7XG4gICAgICAgICAgICAgIHZhciBTLCBUID0gbC54ICsgJCwgRSA9IGwueSArIHc7XG4gICAgICAgICAgICAgIGlmICh2ID8gKGZ1bmN0aW9uKEMsIEQsIE0pIHtcbiAgICAgICAgICAgICAgICB2YXIgSSA9IEMuJGNvbmZpZy5zY3JvbGxYID8gdC4kdWkuZ2V0VmlldyhDLiRjb25maWcuc2Nyb2xsWCkgOiBudWxsLCBBID0gQy4kY29uZmlnLnNjcm9sbFkgPyB0LiR1aS5nZXRWaWV3KEMuJGNvbmZpZy5zY3JvbGxZKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgSSAmJiBJLnNjcm9sbFRvKEQsIG51bGwpLCBBICYmIEEuc2Nyb2xsVG8obnVsbCwgTSk7XG4gICAgICAgICAgICAgIH0odiwgVCwgRSksIFMgPSBuKHYpKSA6ICh0LnNjcm9sbFRvKFQsIEUpLCBTID0gdC5nZXRTY3JvbGxTdGF0ZSgpKSwgbC54ICE9IFMueCAmJiB3ID4gMiAqICQgfHwgbC55ICE9IFMueSAmJiAkID4gMiAqIHcpIHJldHVybiBtKGYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbShmKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gITA7XG4gICAgICB9XG4gICAgfV0pO1xuICAgIHRyeSB7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgdC5fdG91Y2hfZHJhZyAmJiBtKGYpO1xuICAgICAgfSwgeyBwYXNzaXZlOiAhMSB9KTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIGNvbnNvbGUud2FybihcIkNhbm5vdCBwcmV2ZW50IHRvdWNoIGV2ZW50IGZvciB0aGUgcGFnZSBkcmFnXCIpO1xuICAgIH1cbiAgICBmb3IgKGEucHVzaChbdGhpcy4kY29udGFpbmVyLCBcImNvbnRleHRtZW51XCIsIGZ1bmN0aW9uKGYpIHtcbiAgICAgIGlmIChjKSByZXR1cm4gbShmKTtcbiAgICB9XSksIGEucHVzaChbdGhpcy4kY29udGFpbmVyLCByWzFdLCBmdW5jdGlvbihmKSB7XG4gICAgICBpZiAoYiA9IGYudG91Y2hlcy5sZW5ndGgsIGRvY3VtZW50ICYmIGRvY3VtZW50LmJvZHkgJiYgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKFwiZ2FudHRfdG91Y2hfYWN0aXZlXCIpLCAhbyhmKSkgaWYgKGYudG91Y2hlcyAmJiBmLnRvdWNoZXMubGVuZ3RoID4gMSkgYyA9ICExO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGggPSBzKGYpLCB2ID0gZnVuY3Rpb24oeCkge1xuICAgICAgICAgIGZvciAodmFyICQgPSB0LiRsYXlvdXQuZ2V0Q2VsbHNCeVR5cGUoXCJ2aWV3Q2VsbFwiKSwgdyA9IDA7IHcgPCAkLmxlbmd0aDsgdysrKSB7XG4gICAgICAgICAgICB2YXIgUyA9ICRbd10uJHZpZXcuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICBpZiAoeC5jbGllbnRYID49IFMubGVmdCAmJiB4LmNsaWVudFggPD0gUy5yaWdodCAmJiB4LmNsaWVudFkgPD0gUy5ib3R0b20gJiYgeC5jbGllbnRZID49IFMudG9wKSByZXR1cm4gJFt3XTtcbiAgICAgICAgICB9XG4gICAgICAgIH0oaCksIHQuX2xvY2F0ZV9jc3MoaCwgXCJnYW50dF9ob3Jfc2Nyb2xsXCIpIHx8IHQuX2xvY2F0ZV9jc3MoaCwgXCJnYW50dF92ZXJfc2Nyb2xsXCIpIHx8IChjID0gITApO1xuICAgICAgICB2YXIgayA9IGkoKTtcbiAgICAgICAgZyA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIHggPSB0LmxvY2F0ZShoKTtcbiAgICAgICAgICBrICYmIHggJiYgIXQuX2xvY2F0ZV9jc3MoaCwgXCJnYW50dF9saW5rX2NvbnRyb2xcIikgJiYgIXQuX2xvY2F0ZV9jc3MoaCwgXCJnYW50dF9ncmlkX2RhdGFcIikgJiYgKGsub25fbW91c2VfZG93bihoKSwgay5kcmFnICYmIGsuZHJhZy5zdGFydF9kcmFnICYmIChmdW5jdGlvbigkKSB7XG4gICAgICAgICAgICBjb25zdCB3ID0gdC5fZ2V0VGFza0xheWVycygpO1xuICAgICAgICAgICAgbGV0IFMgPSB0LmdldFRhc2soJCk7XG4gICAgICAgICAgICBpZiAoUykge1xuICAgICAgICAgICAgICBsZXQgVCA9IHQuaXNUYXNrVmlzaWJsZSgkKTtcbiAgICAgICAgICAgICAgaWYgKFQpIHtcbiAgICAgICAgICAgICAgICBwID0gJDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBFID0gMDsgRSA8IHcubGVuZ3RoOyBFKyspIGlmIChTID0gd1tFXS5yZW5kZXJlZFskXSwgUyAmJiBTLmdldEF0dHJpYnV0ZSh0LmNvbmZpZy50YXNrX2F0dHJpYnV0ZSkgJiYgUy5nZXRBdHRyaWJ1dGUodC5jb25maWcudGFza19hdHRyaWJ1dGUpID09ICQpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IEMgPSBTLmNsb25lTm9kZSghMCk7XG4gICAgICAgICAgICAgICAgICB5LnB1c2goUyksIHdbRV0ucmVuZGVyZWRbJF0gPSBDLCBTLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIiwgQy5jbGFzc05hbWUgKz0gXCIgZ2FudHRfZHJhZ19tb3ZlIFwiLCBTLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoQyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKFMuJHNwbGl0X3N1YnRhc2spIHtcbiAgICAgICAgICAgICAgICBsZXQgRSA9IFMuJHJlbmRlcmVkX3BhcmVudDtcbiAgICAgICAgICAgICAgICBpZiAoVCA9IHQuaXNUYXNrVmlzaWJsZShFKSwgIVQpIHJldHVybjtcbiAgICAgICAgICAgICAgICBwID0gJDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBDID0gMDsgQyA8IHcubGVuZ3RoOyBDKyspIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IEQgPSB3W0NdLnJlbmRlcmVkW0VdO1xuICAgICAgICAgICAgICAgICAgbGV0IE07XG4gICAgICAgICAgICAgICAgICBpZiAoRCAmJiBELmNoaWxkTm9kZXMgJiYgKE0gPSBELnF1ZXJ5U2VsZWN0b3IoYFske3QuY29uZmlnLnRhc2tfYXR0cmlidXRlfT1cIiR7Uy5pZH1cIl1gKSksIE0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgSSA9IE0uY2xvbmVOb2RlKCEwKTtcbiAgICAgICAgICAgICAgICAgICAgTS5wYXJlbnROb2RlLmFwcGVuZENoaWxkKEkpLCB0LiR0YXNrX2JhcnMuYXBwZW5kQ2hpbGQoTSksIE0uc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiLCB5LnB1c2goTSksIE0gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0oeCksIGsuX3N0YXJ0X2RuZChoKSwgdC5fdG91Y2hfZHJhZyA9ICEwLCB0LnJlZnJlc2hUYXNrKHgpLCB0Ll90b3VjaF9mZWVkYmFjaygpKSksIGcgPSBudWxsO1xuICAgICAgICB9LCB0LmNvbmZpZy50b3VjaF9kcmFnKTtcbiAgICAgIH1cbiAgICB9XSksIGEucHVzaChbdGhpcy4kY29udGFpbmVyLCByWzJdLCBmdW5jdGlvbihmKSB7XG4gICAgICBpZiAoZG9jdW1lbnQgJiYgZG9jdW1lbnQuYm9keSAmJiBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5yZW1vdmUoXCJnYW50dF90b3VjaF9hY3RpdmVcIiksICFvKGYpKSB7XG4gICAgICAgIGcgJiYgY2xlYXJUaW1lb3V0KGcpLCB0Ll90b3VjaF9kcmFnID0gITEsIGMgPSAhMTtcbiAgICAgICAgdmFyIGsgPSBzKGYpLCB4ID0gaSgpO1xuICAgICAgICBpZiAoeCAmJiB4Lm9uX21vdXNlX3VwKGspLCBwICYmIHQuaXNUYXNrRXhpc3RzKHApICYmICh0LnJlZnJlc2hUYXNrKHApLCB5Lmxlbmd0aCAmJiAoeS5mb3JFYWNoKGZ1bmN0aW9uKHcpIHtcbiAgICAgICAgICB3LnBhcmVudE5vZGUgJiYgdy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHcpO1xuICAgICAgICB9KSwgdC5fdG91Y2hfZmVlZGJhY2soKSkpLCBjID0gdSA9ICExLCB5ID0gW10sIHAgPSBudWxsLCBoICYmIGQpIHtcbiAgICAgICAgICB2YXIgJCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICAgICAgICAgICQgLSBkIDwgNTAwICYmIGIgPD0gMSA/ICh0LiRzZXJ2aWNlcy5nZXRTZXJ2aWNlKFwibW91c2VFdmVudHNcIikub25Eb3VibGVDbGljayhoKSwgbShmKSkgOiBkID0gJDtcbiAgICAgICAgfSBlbHNlIGQgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgICAgIH1cbiAgICB9XSksIF8gPSAwOyBfIDwgYS5sZW5ndGg7IF8rKykgdC5ldmVudChhW19dWzBdLCBhW19dWzFdLCBhW19dWzJdKTtcbiAgICBmdW5jdGlvbiBtKGYpIHtcbiAgICAgIHJldHVybiBmICYmIGYucHJldmVudERlZmF1bHQgJiYgZi5jYW5jZWxhYmxlICYmIGYucHJldmVudERlZmF1bHQoKSwgZi5jYW5jZWxCdWJibGUgPSAhMCwgITE7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gRnQoKSB7XG4gIGNvbnNvbGUubG9nKFwiTWV0aG9kIGlzIG5vdCBpbXBsZW1lbnRlZC5cIik7XG59XG5mdW5jdGlvbiBNdCgpIHtcbn1cbmZ1bmN0aW9uIGh0KHQpIHtcbiAgcmV0dXJuIE10O1xufVxuTXQucHJvdG90eXBlLnJlbmRlciA9IEZ0LCBNdC5wcm90b3R5cGUuc2V0X3ZhbHVlID0gRnQsIE10LnByb3RvdHlwZS5nZXRfdmFsdWUgPSBGdCwgTXQucHJvdG90eXBlLmZvY3VzID0gRnQ7XG52YXIgJG4gPSB7IGdldEh0bWxTZWxlY3Q6IGZ1bmN0aW9uKHQsIGUsIG4pIHtcbiAgdmFyIGkgPSBcIlwiLCBhID0gdGhpcztcbiAgcmV0dXJuIGt0KHQgPSB0IHx8IFtdLCBmdW5jdGlvbihyKSB7XG4gICAgdmFyIHMgPSBbeyBrZXk6IFwidmFsdWVcIiwgdmFsdWU6IHIua2V5IH1dO1xuICAgIG4gPT0gci5rZXkgJiYgKHNbcy5sZW5ndGhdID0geyBrZXk6IFwic2VsZWN0ZWRcIiwgdmFsdWU6IFwic2VsZWN0ZWRcIiB9KSwgci5hdHRyaWJ1dGVzICYmIChzID0gcy5jb25jYXQoci5hdHRyaWJ1dGVzKSksIGkgKz0gYS5nZXRIdG1sT3B0aW9uKHsgaW5uZXJIVE1MOiByLmxhYmVsIH0sIHMpO1xuICB9KSwgRHQoXCJzZWxlY3RcIiwgeyBpbm5lckhUTUw6IGkgfSwgZSk7XG59LCBnZXRIdG1sT3B0aW9uOiBmdW5jdGlvbih0LCBlKSB7XG4gIHJldHVybiBEdChcIm9wdGlvblwiLCB0LCBlKTtcbn0sIGdldEh0bWxCdXR0b246IGZ1bmN0aW9uKHQsIGUpIHtcbiAgcmV0dXJuIER0KFwiYnV0dG9uXCIsIHQsIGUpO1xufSwgZ2V0SHRtbERpdjogZnVuY3Rpb24odCwgZSkge1xuICByZXR1cm4gRHQoXCJkaXZcIiwgdCwgZSk7XG59LCBnZXRIdG1sTGFiZWw6IGZ1bmN0aW9uKHQsIGUpIHtcbiAgcmV0dXJuIER0KFwibGFiZWxcIiwgdCwgZSk7XG59LCBnZXRIdG1sSW5wdXQ6IGZ1bmN0aW9uKHQpIHtcbiAgcmV0dXJuIFwiPGlucHV0XCIgKyB3bih0IHx8IFtdKSArIFwiPlwiO1xufSB9O1xuZnVuY3Rpb24gRHQodCwgZSwgbikge1xuICByZXR1cm4gZSA9IGUgfHwgW10sIFwiPFwiICsgdCArIHduKG4gfHwgW10pICsgXCI+XCIgKyAoZS5pbm5lckhUTUwgfHwgXCJcIikgKyBcIjwvXCIgKyB0ICsgXCI+XCI7XG59XG5mdW5jdGlvbiB3bih0KSB7XG4gIHZhciBlID0gXCJcIjtcbiAgcmV0dXJuIGt0KHQsIGZ1bmN0aW9uKG4pIHtcbiAgICBlICs9IFwiIFwiICsgbi5rZXkgKyBcIj0nXCIgKyBuLnZhbHVlICsgXCInXCI7XG4gIH0pLCBlO1xufVxuZnVuY3Rpb24gcXQodCkge1xuICBjb25zdCBlID0gaHQoKTtcbiAgZnVuY3Rpb24gbigpIHtcbiAgICByZXR1cm4gZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cbiAgcmV0dXJuIHoobiwgZSksIG4ucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKGkpIHtcbiAgICBjb25zdCBhID0gaS5oZWlnaHQgPyBgaGVpZ2h0OiR7aS5oZWlnaHR9cHg7YCA6IFwiXCI7XG4gICAgbGV0IHIgPSBgPGRpdiBjbGFzcz0nZ2FudHRfY2FsX2x0ZXh0IGdhbnR0X3NlY3Rpb25fJHtpLm5hbWV9JyAke2EgPyBgc3R5bGU9JyR7YX0nYCA6IFwiXCJ9PmA7XG4gICAgcmV0dXJuIHIgKz0gJG4uZ2V0SHRtbFNlbGVjdChpLm9wdGlvbnMsIFt7IGtleTogXCJzdHlsZVwiLCB2YWx1ZTogXCJ3aWR0aDoxMDAlO1wiIH0sIHsga2V5OiBcInRpdGxlXCIsIHZhbHVlOiBpLm5hbWUgfV0pLCByICs9IFwiPC9kaXY+XCIsIHI7XG4gIH0sIG4ucHJvdG90eXBlLnNldF92YWx1ZSA9IGZ1bmN0aW9uKGksIGEsIHIsIHMpIHtcbiAgICB2YXIgbyA9IGkuZmlyc3RDaGlsZDtcbiAgICAhby5fZGh4X29uY2hhbmdlICYmIHMub25jaGFuZ2UgJiYgKG8ub25jaGFuZ2UgPSBzLm9uY2hhbmdlLCBvLl9kaHhfb25jaGFuZ2UgPSAhMCksIGEgPT09IHZvaWQgMCAmJiAoYSA9IChvLm9wdGlvbnNbMF0gfHwge30pLnZhbHVlKSwgby52YWx1ZSA9IGEgfHwgXCJcIjtcbiAgfSwgbi5wcm90b3R5cGUuZ2V0X3ZhbHVlID0gZnVuY3Rpb24oaSkge1xuICAgIHJldHVybiBpLmZpcnN0Q2hpbGQudmFsdWU7XG4gIH0sIG4ucHJvdG90eXBlLmZvY3VzID0gZnVuY3Rpb24oaSkge1xuICAgIHZhciBhID0gaS5maXJzdENoaWxkO1xuICAgIHQuX2ZvY3VzKGEsICEwKTtcbiAgfSwgbjtcbn1cbmZ1bmN0aW9uIFlhKHQpIHtcbiAgdmFyIGUgPSBxdCh0KTtcbiAgZnVuY3Rpb24gbigpIHtcbiAgICByZXR1cm4gZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cbiAgZnVuY3Rpb24gaShhLCByKSB7XG4gICAgdmFyIHMgPSBbXSwgbyA9IFtdO1xuICAgIHIgJiYgKHMgPSB0LmdldFRhc2tCeVRpbWUoKSwgYS5hbGxvd19yb290ICYmIHMudW5zaGlmdCh7IGlkOiB0LmNvbmZpZy5yb290X2lkLCB0ZXh0OiBhLnJvb3RfbGFiZWwgfHwgXCJcIiB9KSwgcyA9IGZ1bmN0aW9uKHUsIGgsIGcpIHtcbiAgICAgIHZhciBwID0gaC5maWx0ZXIgfHwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAhMDtcbiAgICAgIH07XG4gICAgICB1ID0gdS5zbGljZSgwKTtcbiAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgdS5sZW5ndGg7IHkrKykge1xuICAgICAgICB2YXIgdiA9IHVbeV07XG4gICAgICAgICh2LmlkID09IGcgfHwgdC5pc0NoaWxkT2Yodi5pZCwgZykgfHwgcCh2LmlkLCB2KSA9PT0gITEpICYmICh1LnNwbGljZSh5LCAxKSwgeS0tKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB1O1xuICAgIH0ocywgYSwgciksIGEuc29ydCAmJiBzLnNvcnQoYS5zb3J0KSk7XG4gICAgZm9yICh2YXIgbCA9IGEudGVtcGxhdGUgfHwgdC50ZW1wbGF0ZXMudGFza190ZXh0LCBkID0gMDsgZCA8IHMubGVuZ3RoOyBkKyspIHtcbiAgICAgIHZhciBjID0gbC5hcHBseSh0LCBbc1tkXS5zdGFydF9kYXRlLCBzW2RdLmVuZF9kYXRlLCBzW2RdXSk7XG4gICAgICBjID09PSB2b2lkIDAgJiYgKGMgPSBcIlwiKSwgby5wdXNoKHsga2V5OiBzW2RdLmlkLCBsYWJlbDogYyB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGEub3B0aW9ucyA9IG8sIGEubWFwX3RvID0gYS5tYXBfdG8gfHwgXCJwYXJlbnRcIiwgdC5mb3JtX2Jsb2Nrcy5zZWxlY3QucmVuZGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cbiAgcmV0dXJuIHoobiwgZSksIG4ucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKGEpIHtcbiAgICByZXR1cm4gaShhLCAhMSk7XG4gIH0sIG4ucHJvdG90eXBlLnNldF92YWx1ZSA9IGZ1bmN0aW9uKGEsIHIsIHMsIG8pIHtcbiAgICByID09PSAwICYmIChyID0gXCIwXCIpLCAhcy5pZCAmJiB0LmdldFN0YXRlKCkubGlnaHRib3ggJiYgKHMuaWQgPSB0LmdldExpZ2h0Ym94VmFsdWVzKCkuaWQpO1xuICAgIHZhciBsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBsLmlubmVySFRNTCA9IGkobywgcy5pZCk7XG4gICAgdmFyIGQgPSBsLnJlbW92ZUNoaWxkKGwuZmlyc3RDaGlsZCk7XG4gICAgcmV0dXJuIGEub25zZWxlY3QgPSBudWxsLCBhLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKGQsIGEpLCB0LmZvcm1fYmxvY2tzLnNlbGVjdC5zZXRfdmFsdWUuYXBwbHkodCwgW2QsIHIsIHMsIG9dKTtcbiAgfSwgbjtcbn1cbmZ1bmN0aW9uIEphKHQpIHtcbiAgdmFyIGUgPSBmdW5jdGlvbigpIHtcbiAgICBjb25zdCBfID0gaHQoKTtcbiAgICBmdW5jdGlvbiBtKCkge1xuICAgICAgcmV0dXJuIF8uYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4geihtLCBfKSwgbS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24oZikge1xuICAgICAgbGV0IGsgPSBmLmhlaWdodCA/IGAke2YuaGVpZ2h0fXB4YCA6IFwiXCI7XG4gICAgICByZXR1cm4gYDxkaXYgY2xhc3M9J2dhbnR0X2NhbF9sdGV4dCBnYW50dF9jYWxfdGVtcGxhdGUgZ2FudHRfc2VjdGlvbl8ke2YubmFtZX0nICR7ayA/IGBzdHlsZT0naGVpZ2h0OiR7a307J2AgOiBcIlwifT48L2Rpdj5gO1xuICAgIH0sIG0ucHJvdG90eXBlLnNldF92YWx1ZSA9IGZ1bmN0aW9uKGYsIGspIHtcbiAgICAgIGYuaW5uZXJIVE1MID0gayB8fCBcIlwiO1xuICAgIH0sIG0ucHJvdG90eXBlLmdldF92YWx1ZSA9IGZ1bmN0aW9uKGYpIHtcbiAgICAgIHJldHVybiBmLmlubmVySFRNTCB8fCBcIlwiO1xuICAgIH0sIG0ucHJvdG90eXBlLmZvY3VzID0gZnVuY3Rpb24oKSB7XG4gICAgfSwgbTtcbiAgfSgpLCBuID0gZnVuY3Rpb24oXykge1xuICAgIGNvbnN0IG0gPSBodCgpO1xuICAgIGZ1bmN0aW9uIGYoKSB7XG4gICAgICByZXR1cm4gbS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiB6KGYsIG0pLCBmLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihrKSB7XG4gICAgICBjb25zdCB4ID0gKGsuaGVpZ2h0IHx8IFwiMTMwXCIpICsgXCJweFwiLCAkID0gay5wbGFjZWhvbGRlciA/IGBwbGFjZWhvbGRlcj0nJHtrLnBsYWNlaG9sZGVyfSdgIDogXCJcIjtcbiAgICAgIHJldHVybiBgPGRpdiBjbGFzcz0nZ2FudHRfY2FsX2x0ZXh0IGdhbnR0X3NlY3Rpb25fJHtrLm5hbWV9JyBzdHlsZT0naGVpZ2h0OiR7eH07JyAkeyR9Pjx0ZXh0YXJlYT48L3RleHRhcmVhPjwvZGl2PmA7XG4gICAgfSwgZi5wcm90b3R5cGUuc2V0X3ZhbHVlID0gZnVuY3Rpb24oaywgeCkge1xuICAgICAgXy5mb3JtX2Jsb2Nrcy50ZXh0YXJlYS5fZ2V0X2lucHV0KGspLnZhbHVlID0geCB8fCBcIlwiO1xuICAgIH0sIGYucHJvdG90eXBlLmdldF92YWx1ZSA9IGZ1bmN0aW9uKGspIHtcbiAgICAgIHJldHVybiBfLmZvcm1fYmxvY2tzLnRleHRhcmVhLl9nZXRfaW5wdXQoaykudmFsdWU7XG4gICAgfSwgZi5wcm90b3R5cGUuZm9jdXMgPSBmdW5jdGlvbihrKSB7XG4gICAgICB2YXIgeCA9IF8uZm9ybV9ibG9ja3MudGV4dGFyZWEuX2dldF9pbnB1dChrKTtcbiAgICAgIF8uX2ZvY3VzKHgsICEwKTtcbiAgICB9LCBmLnByb3RvdHlwZS5fZ2V0X2lucHV0ID0gZnVuY3Rpb24oaykge1xuICAgICAgcmV0dXJuIGsucXVlcnlTZWxlY3RvcihcInRleHRhcmVhXCIpO1xuICAgIH0sIGY7XG4gIH0odCksIGkgPSBmdW5jdGlvbihfKSB7XG4gICAgY29uc3QgbSA9IGh0KCk7XG4gICAgZnVuY3Rpb24gZigpIHtcbiAgICAgIHJldHVybiBtLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIHooZiwgbSksIGYucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKGspIHtcbiAgICAgIHZhciB4ID0gXy5mb3JtX2Jsb2Nrcy5nZXRUaW1lUGlja2VyLmNhbGwodGhpcywgayk7XG4gICAgICBsZXQgJCA9IFwiZ2FudHRfc2VjdGlvbl90aW1lXCI7XG4gICAgICBrLm5hbWUgIT09IFwidGltZVwiICYmICgkICs9IFwiIGdhbnR0X3NlY3Rpb25fXCIgKyBrLm5hbWUpO1xuICAgICAgdmFyIHcgPSBcIjxkaXYgc3R5bGU9J3BhZGRpbmctdG9wOjBweDtmb250LXNpemU6aW5oZXJpdDt0ZXh0LWFsaWduOmNlbnRlcjsnIGNsYXNzPSdcIiArICQgKyBcIic+XCI7XG4gICAgICByZXR1cm4gdyArPSB4LCBrLnNpbmdsZV9kYXRlID8gKHggPSBfLmZvcm1fYmxvY2tzLmdldFRpbWVQaWNrZXIuY2FsbCh0aGlzLCBrLCAhMCksIHcgKz0gXCI8c3Bhbj48L3NwYW4+XCIpIDogdyArPSBcIjxzcGFuIGNsYXNzPSdnYW50dF9zZWN0aW9uX3RpbWVfc3BhY2VyJz4gJm5ic3A7Jm5kYXNoOyZuYnNwOyA8L3NwYW4+XCIsICh3ICs9IHgpICsgXCI8L2Rpdj5cIjtcbiAgICB9LCBmLnByb3RvdHlwZS5zZXRfdmFsdWUgPSBmdW5jdGlvbihrLCB4LCAkLCB3KSB7XG4gICAgICB2YXIgUyA9IHcsIFQgPSBrLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic2VsZWN0XCIpLCBFID0gdy5fdGltZV9mb3JtYXRfb3JkZXI7XG4gICAgICBpZiAoUy5hdXRvX2VuZF9kYXRlKSBmb3IgKHZhciBDID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIEkgPSBuZXcgRGF0ZShUW0VbMl1dLnZhbHVlLCBUW0VbMV1dLnZhbHVlLCBUW0VbMF1dLnZhbHVlLCAwLCAwKSwgQSA9IF8uY2FsY3VsYXRlRW5kRGF0ZSh7IHN0YXJ0X2RhdGU6IEksIGR1cmF0aW9uOiAxLCB0YXNrOiAkIH0pLCBfLmZvcm1fYmxvY2tzLl9maWxsX2xpZ2h0Ym94X3NlbGVjdChULCBFLnNpemUsIEEsIEUsIFMpO1xuICAgICAgfSwgRCA9IDA7IEQgPCA0OyBEKyspIFRbRF0ub25jaGFuZ2UgPSBDO1xuICAgICAgdmFyIE0gPSBfLl9yZXNvbHZlX2RlZmF1bHRfbWFwcGluZyh3KTtcbiAgICAgIHR5cGVvZiBNID09IFwic3RyaW5nXCIgJiYgKE0gPSB7IHN0YXJ0X2RhdGU6IE0gfSk7XG4gICAgICB2YXIgSSA9ICRbTS5zdGFydF9kYXRlXSB8fCAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSwgQSA9ICRbTS5lbmRfZGF0ZV0gfHwgXy5jYWxjdWxhdGVFbmREYXRlKHsgc3RhcnRfZGF0ZTogSSwgZHVyYXRpb246IDEsIHRhc2s6ICQgfSk7XG4gICAgICBfLmZvcm1fYmxvY2tzLl9maWxsX2xpZ2h0Ym94X3NlbGVjdChULCAwLCBJLCBFLCBTKSwgXy5mb3JtX2Jsb2Nrcy5fZmlsbF9saWdodGJveF9zZWxlY3QoVCwgRS5zaXplLCBBLCBFLCBTKTtcbiAgICB9LCBmLnByb3RvdHlwZS5nZXRfdmFsdWUgPSBmdW5jdGlvbihrLCB4LCAkKSB7XG4gICAgICB2YXIgdywgUyA9IGsuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJzZWxlY3RcIiksIFQgPSAkLl90aW1lX2Zvcm1hdF9vcmRlcjtcbiAgICAgIHJldHVybiB3ID0gXy5mb3JtX2Jsb2Nrcy5nZXRUaW1lUGlja2VyVmFsdWUoUywgJCksIHR5cGVvZiBfLl9yZXNvbHZlX2RlZmF1bHRfbWFwcGluZygkKSA9PSBcInN0cmluZ1wiID8gdyA6IHsgc3RhcnRfZGF0ZTogdywgZW5kX2RhdGU6IGZ1bmN0aW9uKEUsIEMsIEQpIHtcbiAgICAgICAgdmFyIE0gPSBfLmZvcm1fYmxvY2tzLmdldFRpbWVQaWNrZXJWYWx1ZShFLCAkLCBDLnNpemUpO1xuICAgICAgICByZXR1cm4gTSA8PSBEICYmICgkLmF1dG9maXhfZW5kICE9PSAhMSB8fCAkLnNpbmdsZV9kYXRlKSA/IF8uZGF0ZS5hZGQoRCwgXy5fZ2V0X3RpbWVwaWNrZXJfc3RlcCgpLCBcIm1pbnV0ZVwiKSA6IE07XG4gICAgICB9KFMsIFQsIHcpIH07XG4gICAgfSwgZi5wcm90b3R5cGUuZm9jdXMgPSBmdW5jdGlvbihrKSB7XG4gICAgICBfLl9mb2N1cyhrLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic2VsZWN0XCIpWzBdKTtcbiAgICB9LCBmO1xuICB9KHQpLCBhID0gcXQodCksIHIgPSBmdW5jdGlvbihfKSB7XG4gICAgdmFyIG0gPSBodCgpO1xuICAgIGZ1bmN0aW9uIGYoKSB7XG4gICAgICByZXR1cm4gbS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiB6KGYsIG0pLCBmLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihrKSB7XG4gICAgICBjb25zdCB4ID0gay5oZWlnaHQgPyBgaGVpZ2h0OiR7ay5oZWlnaHR9cHg7YCA6IFwiXCI7XG4gICAgICBsZXQgJCA9IGA8ZGl2IGNsYXNzPSdnYW50dF9jYWxfbHRleHQgZ2FudHRfY2FsX2xjaGVja2JveCBnYW50dF9zZWN0aW9uXyR7ay5uYW1lfScgJHt4ID8gYHN0eWxlPScke3h9J2AgOiBcIlwifT5gO1xuICAgICAgaWYgKGsub3B0aW9ucyAmJiBrLm9wdGlvbnMubGVuZ3RoKSBmb3IgKHZhciB3ID0gMDsgdyA8IGsub3B0aW9ucy5sZW5ndGg7IHcrKykgJCArPSBcIjxsYWJlbD48aW5wdXQgdHlwZT0nY2hlY2tib3gnIHZhbHVlPSdcIiArIGsub3B0aW9uc1t3XS5rZXkgKyBcIicgbmFtZT0nXCIgKyBrLm5hbWUgKyBcIic+XCIgKyBrLm9wdGlvbnNbd10ubGFiZWwgKyBcIjwvbGFiZWw+XCI7XG4gICAgICBlbHNlIGsuc2luZ2xlX3ZhbHVlID0gITAsICQgKz0gXCI8bGFiZWw+PGlucHV0IHR5cGU9J2NoZWNrYm94JyBuYW1lPSdcIiArIGsubmFtZSArIFwiJz48L2xhYmVsPlwiO1xuICAgICAgcmV0dXJuICQgKz0gXCI8L2Rpdj5cIiwgJDtcbiAgICB9LCBmLnByb3RvdHlwZS5zZXRfdmFsdWUgPSBmdW5jdGlvbihrLCB4LCAkLCB3KSB7XG4gICAgICB2YXIgUyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGsucXVlcnlTZWxlY3RvckFsbChcImlucHV0W3R5cGU9Y2hlY2tib3hdXCIpKTtcbiAgICAgICFrLl9kaHhfb25jaGFuZ2UgJiYgdy5vbmNoYW5nZSAmJiAoay5vbmNoYW5nZSA9IHcub25jaGFuZ2UsIGsuX2RoeF9vbmNoYW5nZSA9ICEwKSwgdy5zaW5nbGVfdmFsdWUgPyBTWzBdLmNoZWNrZWQgPSAhIXggOiBrdChTLCBmdW5jdGlvbihUKSB7XG4gICAgICAgIFQuY2hlY2tlZCA9ICEheCAmJiB4LmluZGV4T2YoVC52YWx1ZSkgPj0gMDtcbiAgICAgIH0pO1xuICAgIH0sIGYucHJvdG90eXBlLmdldF92YWx1ZSA9IGZ1bmN0aW9uKGssIHgsICQpIHtcbiAgICAgIHJldHVybiAkLnNpbmdsZV92YWx1ZSA/IGsucXVlcnlTZWxlY3RvcihcImlucHV0W3R5cGU9Y2hlY2tib3hdXCIpLmNoZWNrZWQgOiBmdW5jdGlvbih3LCBTKSB7XG4gICAgICAgIGlmICh3Lm1hcCkgcmV0dXJuIHcubWFwKFMpO1xuICAgICAgICBmb3IgKHZhciBUID0gdy5zbGljZSgpLCBFID0gW10sIEMgPSAwOyBDIDwgVC5sZW5ndGg7IEMrKykgRS5wdXNoKFMoVFtDXSwgQykpO1xuICAgICAgICByZXR1cm4gRTtcbiAgICAgIH0oQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoay5xdWVyeVNlbGVjdG9yQWxsKFwiaW5wdXRbdHlwZT1jaGVja2JveF06Y2hlY2tlZFwiKSksIGZ1bmN0aW9uKHcpIHtcbiAgICAgICAgcmV0dXJuIHcudmFsdWU7XG4gICAgICB9KTtcbiAgICB9LCBmLnByb3RvdHlwZS5mb2N1cyA9IGZ1bmN0aW9uKGspIHtcbiAgICAgIF8uX2ZvY3VzKGsucXVlcnlTZWxlY3RvcihcImlucHV0W3R5cGU9Y2hlY2tib3hdXCIpKTtcbiAgICB9LCBmO1xuICB9KHQpLCBzID0gZnVuY3Rpb24oXykge1xuICAgIGNvbnN0IG0gPSBodCgpO1xuICAgIGZ1bmN0aW9uIGYoKSB7XG4gICAgICByZXR1cm4gbS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiB6KGYsIG0pLCBmLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihrKSB7XG4gICAgICBjb25zdCB4ID0gay5oZWlnaHQgPyBgJHtrLmhlaWdodH1weGAgOiBcIlwiO1xuICAgICAgbGV0ICQgPSBgPGRpdiBjbGFzcz0nZ2FudHRfY2FsX2x0ZXh0IGdhbnR0X2NhbF9scmFkaW8gZ2FudHRfc2VjdGlvbl8ke2submFtZX0nICR7eCA/IGBzdHlsZT0naGVpZ2h0OiR7eH07J2AgOiBcIlwifT5gO1xuICAgICAgaWYgKGsub3B0aW9ucyAmJiBrLm9wdGlvbnMubGVuZ3RoKSBmb3IgKHZhciB3ID0gMDsgdyA8IGsub3B0aW9ucy5sZW5ndGg7IHcrKykgJCArPSBcIjxsYWJlbD48aW5wdXQgdHlwZT0ncmFkaW8nIHZhbHVlPSdcIiArIGsub3B0aW9uc1t3XS5rZXkgKyBcIicgbmFtZT0nXCIgKyBrLm5hbWUgKyBcIic+XCIgKyBrLm9wdGlvbnNbd10ubGFiZWwgKyBcIjwvbGFiZWw+XCI7XG4gICAgICByZXR1cm4gJCArPSBcIjwvZGl2PlwiLCAkO1xuICAgIH0sIGYucHJvdG90eXBlLnNldF92YWx1ZSA9IGZ1bmN0aW9uKGssIHgsICQsIHcpIHtcbiAgICAgIHZhciBTO1xuICAgICAgdy5vcHRpb25zICYmIHcub3B0aW9ucy5sZW5ndGggJiYgKFMgPSBrLnF1ZXJ5U2VsZWN0b3IoXCJpbnB1dFt0eXBlPXJhZGlvXVt2YWx1ZT0nXCIgKyB4ICsgXCInXVwiKSB8fCBrLnF1ZXJ5U2VsZWN0b3IoXCJpbnB1dFt0eXBlPXJhZGlvXVt2YWx1ZT0nXCIgKyB3LmRlZmF1bHRfdmFsdWUgKyBcIiddXCIpKSAmJiAoIWsuX2RoeF9vbmNoYW5nZSAmJiB3Lm9uY2hhbmdlICYmIChrLm9uY2hhbmdlID0gdy5vbmNoYW5nZSwgay5fZGh4X29uY2hhbmdlID0gITApLCBTLmNoZWNrZWQgPSAhMCk7XG4gICAgfSwgZi5wcm90b3R5cGUuZ2V0X3ZhbHVlID0gZnVuY3Rpb24oaywgeCkge1xuICAgICAgdmFyICQgPSBrLnF1ZXJ5U2VsZWN0b3IoXCJpbnB1dFt0eXBlPXJhZGlvXTpjaGVja2VkXCIpO1xuICAgICAgcmV0dXJuICQgPyAkLnZhbHVlIDogXCJcIjtcbiAgICB9LCBmLnByb3RvdHlwZS5mb2N1cyA9IGZ1bmN0aW9uKGspIHtcbiAgICAgIF8uX2ZvY3VzKGsucXVlcnlTZWxlY3RvcihcImlucHV0W3R5cGU9cmFkaW9dXCIpKTtcbiAgICB9LCBmO1xuICB9KHQpLCBvID0gZnVuY3Rpb24oXykge1xuICAgIHZhciBtID0gaHQoKTtcbiAgICBmdW5jdGlvbiBmKCkge1xuICAgICAgcmV0dXJuIG0uYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBrKHcpIHtcbiAgICAgIHJldHVybiB3LmZvcm1hdHRlciB8fCBuZXcgUHQoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24geCh3LCBTKSB7XG4gICAgICB2YXIgVCA9IHcuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJzZWxlY3RcIiksIEUgPSBTLl90aW1lX2Zvcm1hdF9vcmRlciwgQyA9IDAsIEQgPSAwO1xuICAgICAgaWYgKF8uZGVmaW5lZChFWzNdKSkge1xuICAgICAgICB2YXIgTSA9IFRbRVszXV0sIEkgPSBwYXJzZUludChNLnZhbHVlLCAxMCk7XG4gICAgICAgIGlzTmFOKEkpICYmIE0uaGFzQXR0cmlidXRlKFwiZGF0YS12YWx1ZVwiKSAmJiAoSSA9IHBhcnNlSW50KE0uZ2V0QXR0cmlidXRlKFwiZGF0YS12YWx1ZVwiKSwgMTApKSwgQyA9IE1hdGguZmxvb3IoSSAvIDYwKSwgRCA9IEkgJSA2MDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgRGF0ZShUW0VbMl1dLnZhbHVlLCBUW0VbMV1dLnZhbHVlLCBUW0VbMF1dLnZhbHVlLCBDLCBEKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gJCh3LCBTKSB7XG4gICAgICB2YXIgVCA9IHcuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJpbnB1dFwiKVsxXTtcbiAgICAgIHJldHVybiAoVCA9IGsoUykucGFyc2UoVC52YWx1ZSkpICYmICF3aW5kb3cuaXNOYU4oVCkgfHwgKFQgPSAxKSwgVCA8IDAgJiYgKFQgKj0gLTEpLCBUO1xuICAgIH1cbiAgICByZXR1cm4geihmLCBtKSwgZi5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24odykge1xuICAgICAgdmFyIFMgPSBcIjxkaXYgY2xhc3M9J2dhbnR0X3RpbWVfc2VsZWN0cyc+XCIgKyBfLmZvcm1fYmxvY2tzLmdldFRpbWVQaWNrZXIuY2FsbCh0aGlzLCB3KSArIFwiPC9kaXY+XCIsIFQgPSBcIiBcIiArIF8ubG9jYWxlLmxhYmVsc1tfLmNvbmZpZy5kdXJhdGlvbl91bml0ICsgXCJzXCJdICsgXCIgXCIsIEUgPSB3LnNpbmdsZV9kYXRlID8gXCIgc3R5bGU9J2Rpc3BsYXk6bm9uZSdcIiA6IFwiXCIsIEMgPSB3LnJlYWRvbmx5ID8gXCIgZGlzYWJsZWQ9J2Rpc2FibGVkJ1wiIDogXCJcIiwgRCA9IF8uX3dhaUFyaWEubGlnaHRib3hEdXJhdGlvbklucHV0QXR0clN0cmluZyh3KSwgTSA9IFwiZ2FudHRfZHVyYXRpb25fdmFsdWVcIjtcbiAgICAgIHcuZm9ybWF0dGVyICYmIChUID0gXCJcIiwgTSArPSBcIiBnYW50dF9kdXJhdGlvbl92YWx1ZV9mb3JtYXR0ZWRcIik7XG4gICAgICB2YXIgSSA9IFwiPGRpdiBjbGFzcz0nZ2FudHRfZHVyYXRpb24nIFwiICsgRSArIFwiPjxkaXYgY2xhc3M9J2dhbnR0X2R1cmF0aW9uX2lucHV0cyc+PGlucHV0IHR5cGU9J2J1dHRvbicgY2xhc3M9J2dhbnR0X2R1cmF0aW9uX2RlYycgdmFsdWU9J+KIkidcIiArIEMgKyBcIj48aW5wdXQgdHlwZT0ndGV4dCcgdmFsdWU9JzVkYXlzJyBjbGFzcz0nXCIgKyBNICsgXCInXCIgKyBDICsgXCIgXCIgKyBEICsgXCI+PGlucHV0IHR5cGU9J2J1dHRvbicgY2xhc3M9J2dhbnR0X2R1cmF0aW9uX2luYycgdmFsdWU9JysnXCIgKyBDICsgXCI+PC9kaXY+PGRpdiBjbGFzcz0nZ2FudHRfZHVyYXRpb25fZW5kX2RhdGUnPlwiICsgVCArIFwiPHNwYW4+PC9zcGFuPjwvZGl2PjwvZGl2PjwvZGl2PlwiO1xuICAgICAgbGV0IEEgPSBcImdhbnR0X3NlY3Rpb25fdGltZSBnYW50dF9zZWN0aW9uX2R1cmF0aW9uXCI7XG4gICAgICByZXR1cm4gdy5uYW1lICE9PSBcInRpbWVcIiAmJiAoQSArPSBcIiBnYW50dF9zZWN0aW9uX1wiICsgdy5uYW1lKSwgXCI8ZGl2IHN0eWxlPSdwYWRkaW5nLXRvcDowcHg7Zm9udC1zaXplOmluaGVyaXQ7JyBjbGFzcz0nXCIgKyBBICsgXCInPlwiICsgUyArIFwiIFwiICsgSSArIFwiPC9kaXY+XCI7XG4gICAgfSwgZi5wcm90b3R5cGUuc2V0X3ZhbHVlID0gZnVuY3Rpb24odywgUywgVCwgRSkge1xuICAgICAgdmFyIEMsIEQsIE0sIEksIEEgPSB3LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic2VsZWN0XCIpLCBOID0gdy5nZXRFbGVtZW50c0J5VGFnTmFtZShcImlucHV0XCIpLCBMID0gTlsxXSwgTyA9IFtOWzBdLCBOWzJdXSwgRyA9IHcuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJzcGFuXCIpWzBdLCBqID0gRS5fdGltZV9mb3JtYXRfb3JkZXI7XG4gICAgICBmdW5jdGlvbiBIKCkge1xuICAgICAgICB2YXIgSiA9IHguY2FsbChfLCB3LCBFKSwgQiA9ICQuY2FsbChfLCB3LCBFKSwgX3QgPSBfLmNhbGN1bGF0ZUVuZERhdGUoeyBzdGFydF9kYXRlOiBKLCBkdXJhdGlvbjogQiwgdGFzazogVCB9KSwgVHQgPSBfLnRlbXBsYXRlcy50YXNrX2VuZF9kYXRlIHx8IF8udGVtcGxhdGVzLnRhc2tfZGF0ZTtcbiAgICAgICAgRy5pbm5lckhUTUwgPSBUdChfdCk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBRKEopIHtcbiAgICAgICAgdmFyIEIgPSBMLnZhbHVlO1xuICAgICAgICBCID0gayhFKS5wYXJzZShCKSwgd2luZG93LmlzTmFOKEIpICYmIChCID0gMCksIChCICs9IEopIDwgMSAmJiAoQiA9IDEpLCBMLnZhbHVlID0gayhFKS5mb3JtYXQoQiksIEgoKTtcbiAgICAgIH1cbiAgICAgIE9bMF0ub25jbGljayA9IF8uYmluZChmdW5jdGlvbigpIHtcbiAgICAgICAgUSgtMSAqIF8uY29uZmlnLmR1cmF0aW9uX3N0ZXApO1xuICAgICAgfSwgdGhpcyksIE9bMV0ub25jbGljayA9IF8uYmluZChmdW5jdGlvbigpIHtcbiAgICAgICAgUSgxICogXy5jb25maWcuZHVyYXRpb25fc3RlcCk7XG4gICAgICB9LCB0aGlzKSwgQVswXS5vbmNoYW5nZSA9IEgsIEFbMV0ub25jaGFuZ2UgPSBILCBBWzJdLm9uY2hhbmdlID0gSCwgQVszXSAmJiAoQVszXS5vbmNoYW5nZSA9IEgpLCBMLm9ua2V5ZG93biA9IF8uYmluZChmdW5jdGlvbihKKSB7XG4gICAgICAgIHZhciBCO1xuICAgICAgICByZXR1cm4gKEIgPSAoSiA9IEogfHwgd2luZG93LmV2ZW50KS5jaGFyQ29kZSB8fCBKLmtleUNvZGUgfHwgSi53aGljaCkgPT0gXy5jb25zdGFudHMuS0VZX0NPREVTLkRPV04gPyAoUSgtMSAqIF8uY29uZmlnLmR1cmF0aW9uX3N0ZXApLCAhMSkgOiBCID09IF8uY29uc3RhbnRzLktFWV9DT0RFUy5VUCA/IChRKDEgKiBfLmNvbmZpZy5kdXJhdGlvbl9zdGVwKSwgITEpIDogdm9pZCB3aW5kb3cuc2V0VGltZW91dChILCAxKTtcbiAgICAgIH0sIHRoaXMpLCBMLm9uY2hhbmdlID0gXy5iaW5kKEgsIHRoaXMpLCB0eXBlb2YgKEMgPSBfLl9yZXNvbHZlX2RlZmF1bHRfbWFwcGluZyhFKSkgPT0gXCJzdHJpbmdcIiAmJiAoQyA9IHsgc3RhcnRfZGF0ZTogQyB9KSwgRCA9IFRbQy5zdGFydF9kYXRlXSB8fCAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSwgTSA9IFRbQy5lbmRfZGF0ZV0gfHwgXy5jYWxjdWxhdGVFbmREYXRlKHsgc3RhcnRfZGF0ZTogRCwgZHVyYXRpb246IDEsIHRhc2s6IFQgfSksIEkgPSBNYXRoLnJvdW5kKFRbQy5kdXJhdGlvbl0pIHx8IF8uY2FsY3VsYXRlRHVyYXRpb24oeyBzdGFydF9kYXRlOiBELCBlbmRfZGF0ZTogTSwgdGFzazogVCB9KSwgSSA9IGsoRSkuZm9ybWF0KEkpLCBfLmZvcm1fYmxvY2tzLl9maWxsX2xpZ2h0Ym94X3NlbGVjdChBLCAwLCBELCBqLCBFKSwgTC52YWx1ZSA9IEksIEgoKTtcbiAgICB9LCBmLnByb3RvdHlwZS5nZXRfdmFsdWUgPSBmdW5jdGlvbih3LCBTLCBUKSB7XG4gICAgICB2YXIgRSA9IHgodywgVCksIEMgPSAkKHcsIFQpLCBEID0gXy5jYWxjdWxhdGVFbmREYXRlKHsgc3RhcnRfZGF0ZTogRSwgZHVyYXRpb246IEMsIHRhc2s6IFMgfSk7XG4gICAgICByZXR1cm4gdHlwZW9mIF8uX3Jlc29sdmVfZGVmYXVsdF9tYXBwaW5nKFQpID09IFwic3RyaW5nXCIgPyBFIDogeyBzdGFydF9kYXRlOiBFLCBlbmRfZGF0ZTogRCwgZHVyYXRpb246IEMgfTtcbiAgICB9LCBmLnByb3RvdHlwZS5mb2N1cyA9IGZ1bmN0aW9uKHcpIHtcbiAgICAgIF8uX2ZvY3VzKHcuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJzZWxlY3RcIilbMF0pO1xuICAgIH0sIGY7XG4gIH0odCksIGwgPSBZYSh0KSwgZCA9IHF0KHQpLCBjID0gZnVuY3Rpb24oXykge1xuICAgIHZhciBtID0gaHQoKTtcbiAgICBmdW5jdGlvbiBmKCkge1xuICAgICAgcmV0dXJuIG0uYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBrKCQpIHtcbiAgICAgIHJldHVybiAhJCB8fCAkID09PSBfLmNvbmZpZy5jb25zdHJhaW50X3R5cGVzLkFTQVAgfHwgJCA9PT0gXy5jb25maWcuY29uc3RyYWludF90eXBlcy5BTEFQO1xuICAgIH1cbiAgICBmdW5jdGlvbiB4KCQsIHcpIHtcbiAgICAgIGZvciAodmFyIFMgPSBrKHcpLCBUID0gMDsgVCA8ICQubGVuZ3RoOyBUKyspICRbVF0uZGlzYWJsZWQgPSBTO1xuICAgIH1cbiAgICByZXR1cm4geihmLCBtKSwgZi5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24oJCkge1xuICAgICAgY29uc3QgdyA9ICQuaGVpZ2h0ID8gYGhlaWdodDokeyQuaGVpZ2h0fXB4O2AgOiBcIlwiO1xuICAgICAgbGV0IFMgPSBgPGRpdiBjbGFzcz0nZ2FudHRfY2FsX2x0ZXh0IGdhbnR0X3NlY3Rpb25fJHskLm5hbWV9JyAke3cgPyBgc3R5bGU9JyR7d30nYCA6IFwiXCJ9PmA7XG4gICAgICB2YXIgVCA9IFtdO1xuICAgICAgZm9yICh2YXIgRSBpbiBfLmNvbmZpZy5jb25zdHJhaW50X3R5cGVzKSBULnB1c2goeyBrZXk6IF8uY29uZmlnLmNvbnN0cmFpbnRfdHlwZXNbRV0sIGxhYmVsOiBfLmxvY2FsZS5sYWJlbHNbXy5jb25maWcuY29uc3RyYWludF90eXBlc1tFXV0gfSk7XG4gICAgICByZXR1cm4gJC5vcHRpb25zID0gJC5vcHRpb25zIHx8IFQsIFMgKz0gXCI8c3BhbiBkYXRhLWNvbnN0cmFpbnQtdHlwZS1zZWxlY3Q+XCIgKyAkbi5nZXRIdG1sU2VsZWN0KCQub3B0aW9ucywgW3sga2V5OiBcImRhdGEtdHlwZVwiLCB2YWx1ZTogXCJjb25zdHJhaW50LXR5cGVcIiB9XSkgKyBcIjwvc3Bhbj5cIiwgUyArPSBcIjxsYWJlbCBkYXRhLWNvbnN0cmFpbnQtdGltZS1zZWxlY3Q+XCIgKyAoXy5sb2NhbGUubGFiZWxzLmNvbnN0cmFpbnRfZGF0ZSB8fCBcIkNvbnN0cmFpbnQgZGF0ZVwiKSArIFwiOiBcIiArIF8uZm9ybV9ibG9ja3MuZ2V0VGltZVBpY2tlci5jYWxsKHRoaXMsICQpICsgXCI8L2xhYmVsPlwiLCBTICs9IFwiPC9kaXY+XCIsIFM7XG4gICAgfSwgZi5wcm90b3R5cGUuc2V0X3ZhbHVlID0gZnVuY3Rpb24oJCwgdywgUywgVCkge1xuICAgICAgdmFyIEUgPSAkLnF1ZXJ5U2VsZWN0b3IoXCJbZGF0YS1jb25zdHJhaW50LXR5cGUtc2VsZWN0XSBzZWxlY3RcIiksIEMgPSAkLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbZGF0YS1jb25zdHJhaW50LXRpbWUtc2VsZWN0XSBzZWxlY3RcIiksIEQgPSBULl90aW1lX2Zvcm1hdF9vcmRlciwgTSA9IF8uX3Jlc29sdmVfZGVmYXVsdF9tYXBwaW5nKFQpO1xuICAgICAgRS5fZXZlbnRzSW5pdGlhbGl6ZWQgfHwgKEUuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBmdW5jdGlvbihOKSB7XG4gICAgICAgIHgoQywgTi50YXJnZXQudmFsdWUpO1xuICAgICAgfSksIEUuX2V2ZW50c0luaXRpYWxpemVkID0gITApO1xuICAgICAgdmFyIEkgPSBTW00uY29uc3RyYWludF9kYXRlXSB8fCAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgICAgIF8uZm9ybV9ibG9ja3MuX2ZpbGxfbGlnaHRib3hfc2VsZWN0KEMsIDAsIEksIEQsIFQpO1xuICAgICAgdmFyIEEgPSBTW00uY29uc3RyYWludF90eXBlXSB8fCBfLmdldENvbnN0cmFpbnRUeXBlKFMpO1xuICAgICAgRS52YWx1ZSA9IEEsIHgoQywgQSk7XG4gICAgfSwgZi5wcm90b3R5cGUuZ2V0X3ZhbHVlID0gZnVuY3Rpb24oJCwgdywgUykge1xuICAgICAgdmFyIFQgPSAkLnF1ZXJ5U2VsZWN0b3IoXCJbZGF0YS1jb25zdHJhaW50LXR5cGUtc2VsZWN0XSBzZWxlY3RcIiksIEUgPSAkLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbZGF0YS1jb25zdHJhaW50LXRpbWUtc2VsZWN0XSBzZWxlY3RcIiksIEMgPSBULnZhbHVlLCBEID0gbnVsbDtcbiAgICAgIHJldHVybiBrKEMpIHx8IChEID0gXy5mb3JtX2Jsb2Nrcy5nZXRUaW1lUGlja2VyVmFsdWUoRSwgUykpLCB7IGNvbnN0cmFpbnRfdHlwZTogQywgY29uc3RyYWludF9kYXRlOiBEIH07XG4gICAgfSwgZi5wcm90b3R5cGUuZm9jdXMgPSBmdW5jdGlvbigkKSB7XG4gICAgICBfLl9mb2N1cygkLnF1ZXJ5U2VsZWN0b3IoXCJzZWxlY3RcIikpO1xuICAgIH0sIGY7XG4gIH0odCksIHUgPSBmdW5jdGlvbihfKSB7XG4gICAgY29uc3QgbSA9IHF0KF8pO1xuICAgIGZ1bmN0aW9uIGYoKSB7XG4gICAgICByZXR1cm4gbS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiB6KGYsIG0pLCBmLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihrKSB7XG4gICAgICB2YXIgeCA9IF8uY29uZmlnLnR5cGVzLCAkID0gXy5sb2NhbGUubGFiZWxzLCB3ID0gW10sIFMgPSBrLmZpbHRlciB8fCBmdW5jdGlvbihDLCBEKSB7XG4gICAgICAgIHJldHVybiAheC5wbGFjZWhvbGRlciB8fCBEICE9PSB4LnBsYWNlaG9sZGVyO1xuICAgICAgfTtcbiAgICAgIGZvciAodmFyIFQgaW4geCkgIVMoVCwgeFtUXSkgPT0gMCAmJiB3LnB1c2goeyBrZXk6IHhbVF0sIGxhYmVsOiAkW1widHlwZV9cIiArIFRdIH0pO1xuICAgICAgay5vcHRpb25zID0gdztcbiAgICAgIHZhciBFID0gay5vbmNoYW5nZTtcbiAgICAgIHJldHVybiBrLm9uY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIF8uX2xpZ2h0Ym94X2N1cnJlbnRfdHlwZSA9IHRoaXMudmFsdWUsIF8uY2hhbmdlTGlnaHRib3hUeXBlKHRoaXMudmFsdWUpLCB0eXBlb2YgRSA9PSBcImZ1bmN0aW9uXCIgJiYgRS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfSwgbS5wcm90b3R5cGUucmVuZGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSwgZjtcbiAgfSh0KSwgaCA9IGZ1bmN0aW9uKF8pIHtcbiAgICB2YXIgbSA9IGh0KCk7XG4gICAgZnVuY3Rpb24gZigpIHtcbiAgICAgIHJldHVybiBtLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgZnVuY3Rpb24gayhTKSB7XG4gICAgICByZXR1cm4gUy5mb3JtYXR0ZXIgfHwgbmV3IFB0KCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHgoUywgVCwgRSwgQykge1xuICAgICAgY29uc3QgRCA9IFwiPGRpdiBjbGFzcz0nZ2FudHRfdGltZV9zZWxlY3RzJz5cIiArIF8uZm9ybV9ibG9ja3MuZ2V0VGltZVBpY2tlci5jYWxsKF8sIEMpICsgXCI8L2Rpdj5cIjtcbiAgICAgIGxldCBNID0gXCIgXCIgKyBfLmxvY2FsZS5sYWJlbHNbXy5jb25maWcuZHVyYXRpb25fdW5pdCArIFwic1wiXSArIFwiIFwiO1xuICAgICAgY29uc3QgSSA9IEMuc2luZ2xlX2RhdGUgPyBcIiBzdHlsZT0nZGlzcGxheTpub25lJ1wiIDogXCJcIiwgQSA9IEMucmVhZG9ubHkgPyBcIiBkaXNhYmxlZD0nZGlzYWJsZWQnXCIgOiBcIlwiLCBOID0gXy5fd2FpQXJpYS5saWdodGJveER1cmF0aW9uSW5wdXRBdHRyU3RyaW5nKEMpLCBMID0gXy5sb2NhbGUubGFiZWxzLmJhc2VsaW5lc19yZW1vdmVfYnV0dG9uO1xuICAgICAgbGV0IE8gPSBcImdhbnR0X2R1cmF0aW9uX3ZhbHVlXCI7XG4gICAgICBDLmZvcm1hdHRlciAmJiAoTSA9IFwiXCIsIE8gKz0gXCIgZ2FudHRfZHVyYXRpb25fdmFsdWVfZm9ybWF0dGVkXCIpO1xuICAgICAgY29uc3QgRyA9IFwiPGRpdiBjbGFzcz0nZ2FudHRfZHVyYXRpb24nIFwiICsgSSArIFwiPjxkaXYgY2xhc3M9J2dhbnR0X2R1cmF0aW9uX2lucHV0cyc+PGlucHV0IHR5cGU9J2J1dHRvbicgY2xhc3M9J2dhbnR0X2R1cmF0aW9uX2RlYycgdmFsdWU9J+KIkidcIiArIEEgKyBcIj48aW5wdXQgdHlwZT0ndGV4dCcgdmFsdWU9JzVkYXlzJyBjbGFzcz0nXCIgKyBPICsgXCInXCIgKyBBICsgXCIgXCIgKyBOICsgXCI+PGlucHV0IHR5cGU9J2J1dHRvbicgY2xhc3M9J2dhbnR0X2R1cmF0aW9uX2luYycgdmFsdWU9JysnXCIgKyBBICsgXCI+PC9kaXY+PGRpdiBjbGFzcz0nZ2FudHRfZHVyYXRpb25fZW5kX2RhdGUnPlwiICsgTSArIFwiPHNwYW4+PC9zcGFuPjwvZGl2PjwvZGl2PjwvZGl2PlwiLCBqID0gYDxkaXY+PGRpdiBjbGFzcz0nYmFzZWxpbmVfZGVsZXRlX2J1dHRvbiBnYW50dF9jdXN0b21fYnV0dG9uJz4ke0x9PC9kaXY+PC9kaXY+YCwgSCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBILmNsYXNzTmFtZSA9IFwiZ2FudHRfc2VjdGlvbl90aW1lIGdhbnR0X3NlY3Rpb25fZHVyYXRpb25cIiwgSC5zZXRBdHRyaWJ1dGUoXCJkYXRhLWJhc2VsaW5lLWlkXCIsIFQuaWQpLCBILmlubmVySFRNTCA9IEQgKyBHICsgaiArIFwiPGJyPlwiLCBTLmFwcGVuZENoaWxkKEgpO1xuICAgICAgdmFyIFEsIEosIEIsIF90ID0gSC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInNlbGVjdFwiKSwgVHQgPSBILmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaW5wdXRcIiksIEV0ID0gVHRbMV0sIEVlID0gW1R0WzBdLCBUdFsyXV0sIFNuID0gSC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInNwYW5cIilbMF0sIFRuID0gQy5fdGltZV9mb3JtYXRfb3JkZXI7XG4gICAgICBmdW5jdGlvbiBndCgpIHtcbiAgICAgICAgdmFyIHV0ID0gJC5jYWxsKF8sIEgsIEMpLCBVID0gdy5jYWxsKF8sIEgsIEMpLCBFbiA9IF8uY2FsY3VsYXRlRW5kRGF0ZSh7IHN0YXJ0X2RhdGU6IHV0LCBkdXJhdGlvbjogVSwgdGFzazogRSB9KSwgQ24gPSBfLnRlbXBsYXRlcy50YXNrX2VuZF9kYXRlIHx8IF8udGVtcGxhdGVzLnRhc2tfZGF0ZTtcbiAgICAgICAgU24uaW5uZXJIVE1MID0gQ24oRW4pO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gT3QodXQpIHtcbiAgICAgICAgdmFyIFUgPSBFdC52YWx1ZTtcbiAgICAgICAgVSA9IGsoQykucGFyc2UoVSksIHdpbmRvdy5pc05hTihVKSAmJiAoVSA9IDApLCAoVSArPSB1dCkgPCAxICYmIChVID0gMSksIEV0LnZhbHVlID0gayhDKS5mb3JtYXQoVSksIGd0KCk7XG4gICAgICB9XG4gICAgICBILnF1ZXJ5U2VsZWN0b3IoXCIuYmFzZWxpbmVfZGVsZXRlX2J1dHRvblwiKS5vbmNsaWNrID0gZnVuY3Rpb24odXQpIHtcbiAgICAgICAgY29uc3QgVSA9IEgucGFyZW50Tm9kZTtcbiAgICAgICAgSC5pbm5lckhUTUwgPSBcIlwiLCBILnJlbW92ZSgpLCBVLmlubmVySFRNTCA9PT0gXCJcIiAmJiAoVS5pbm5lckhUTUwgPSBfLmxvY2FsZS5sYWJlbHMuYmFzZWxpbmVzX3NlY3Rpb25fcGxhY2Vob2xkZXIpO1xuICAgICAgfSwgRWVbMF0ub25jbGljayA9IF8uYmluZChmdW5jdGlvbigpIHtcbiAgICAgICAgT3QoLTEgKiBfLmNvbmZpZy5kdXJhdGlvbl9zdGVwKTtcbiAgICAgIH0sIF8pLCBFZVsxXS5vbmNsaWNrID0gXy5iaW5kKGZ1bmN0aW9uKCkge1xuICAgICAgICBPdCgxICogXy5jb25maWcuZHVyYXRpb25fc3RlcCk7XG4gICAgICB9LCBfKSwgX3RbMF0ub25jaGFuZ2UgPSBndCwgX3RbMV0ub25jaGFuZ2UgPSBndCwgX3RbMl0ub25jaGFuZ2UgPSBndCwgX3RbM10gJiYgKF90WzNdLm9uY2hhbmdlID0gZ3QpLCBFdC5vbmtleWRvd24gPSBfLmJpbmQoZnVuY3Rpb24odXQpIHtcbiAgICAgICAgdmFyIFU7XG4gICAgICAgIHJldHVybiAoVSA9ICh1dCA9IHV0IHx8IHdpbmRvdy5ldmVudCkuY2hhckNvZGUgfHwgdXQua2V5Q29kZSB8fCB1dC53aGljaCkgPT0gXy5jb25zdGFudHMuS0VZX0NPREVTLkRPV04gPyAoT3QoLTEgKiBfLmNvbmZpZy5kdXJhdGlvbl9zdGVwKSwgITEpIDogVSA9PSBfLmNvbnN0YW50cy5LRVlfQ09ERVMuVVAgPyAoT3QoMSAqIF8uY29uZmlnLmR1cmF0aW9uX3N0ZXApLCAhMSkgOiB2b2lkIHdpbmRvdy5zZXRUaW1lb3V0KGd0LCAxKTtcbiAgICAgIH0sIF8pLCBFdC5vbmNoYW5nZSA9IF8uYmluZChndCwgXyksIF8uX3Jlc29sdmVfZGVmYXVsdF9tYXBwaW5nKEMpLCBRID0gVC5zdGFydF9kYXRlIHx8IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpLCBKID0gVC5lbmRfZGF0ZSB8fCBfLmNhbGN1bGF0ZUVuZERhdGUoeyBzdGFydF9kYXRlOiBRLCBkdXJhdGlvbjogMSwgdGFzazogRSB9KSwgQiA9IF8uY2FsY3VsYXRlRHVyYXRpb24oeyBzdGFydF9kYXRlOiBRLCBlbmRfZGF0ZTogSiwgdGFzazogRSB9KSwgQiA9IGsoQykuZm9ybWF0KEIpLCBfLmZvcm1fYmxvY2tzLl9maWxsX2xpZ2h0Ym94X3NlbGVjdChfdCwgMCwgUSwgVG4sIEMpLCBFdC52YWx1ZSA9IEIsIGd0KCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uICQoUywgVCkge1xuICAgICAgdmFyIEUgPSBTLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic2VsZWN0XCIpLCBDID0gVC5fdGltZV9mb3JtYXRfb3JkZXIsIEQgPSAwLCBNID0gMDtcbiAgICAgIGlmIChfLmRlZmluZWQoQ1szXSkpIHtcbiAgICAgICAgdmFyIEkgPSBFW0NbM11dLCBBID0gcGFyc2VJbnQoSS52YWx1ZSwgMTApO1xuICAgICAgICBpc05hTihBKSAmJiBJLmhhc0F0dHJpYnV0ZShcImRhdGEtdmFsdWVcIikgJiYgKEEgPSBwYXJzZUludChJLmdldEF0dHJpYnV0ZShcImRhdGEtdmFsdWVcIiksIDEwKSksIEQgPSBNYXRoLmZsb29yKEEgLyA2MCksIE0gPSBBICUgNjA7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IERhdGUoRVtDWzJdXS52YWx1ZSwgRVtDWzFdXS52YWx1ZSwgRVtDWzBdXS52YWx1ZSwgRCwgTSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHcoUywgVCkge1xuICAgICAgdmFyIEUgPSBTLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaW5wdXRcIilbMV07XG4gICAgICByZXR1cm4gKEUgPSBrKFQpLnBhcnNlKEUudmFsdWUpKSAmJiAhd2luZG93LmlzTmFOKEUpIHx8IChFID0gMSksIEUgPCAwICYmIChFICo9IC0xKSwgRTtcbiAgICB9XG4gICAgcmV0dXJuIHooZiwgbSksIGYucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKFMpIHtcbiAgICAgIHJldHVybiBgPGRpdiBzdHlsZT0naGVpZ2h0OiAke1MuaGVpZ2h0IHx8IDEwMH1weDsgcGFkZGluZy10b3A6MHB4OyBmb250LXNpemU6aW5oZXJpdDsnIGNsYXNzPSdnYW50dF9zZWN0aW9uX2Jhc2VsaW5lcyc+PC9kaXY+YDtcbiAgICB9LCBmLnByb3RvdHlwZS5zZXRfdmFsdWUgPSBmdW5jdGlvbihTLCBULCBFLCBDKSB7XG4gICAgICBFLmJhc2VsaW5lcyA/IChTLmlubmVySFRNTCA9IFwiXCIsIEUuYmFzZWxpbmVzLmZvckVhY2goKEQpID0+IHtcbiAgICAgICAgeChTLCBELCBFLCBDKTtcbiAgICAgIH0pKSA6IFMuaW5uZXJIVE1MID0gXy5sb2NhbGUubGFiZWxzLmJhc2VsaW5lc19zZWN0aW9uX3BsYWNlaG9sZGVyO1xuICAgIH0sIGYucHJvdG90eXBlLmdldF92YWx1ZSA9IGZ1bmN0aW9uKFMsIFQsIEUpIHtcbiAgICAgIGNvbnN0IEMgPSBbXTtcbiAgICAgIHJldHVybiBTLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbZGF0YS1iYXNlbGluZS1pZF1cIikuZm9yRWFjaCgoRCkgPT4ge1xuICAgICAgICBjb25zdCBNID0gRC5kYXRhc2V0LmJhc2VsaW5lSWQ7XG4gICAgICAgIGxldCBJLCBBID0gXy5nZXREYXRhc3RvcmUoXCJiYXNlbGluZXNcIikuZ2V0SXRlbShNKTtcbiAgICAgICAgSSA9IEEgPyBfLmNvcHkoQSkgOiB7IGlkOiBfLnVpZCgpLCB0YXNrX2lkOiBULmlkLCB0ZXh0OiBcIkJhc2VsaW5lIDFcIiB9LCBJLnN0YXJ0X2RhdGUgPSAkKEQsIEUpLCBJLmR1cmF0aW9uID0gdyhELCBFKSwgSS5lbmRfZGF0ZSA9IF8uY2FsY3VsYXRlRW5kRGF0ZSh7IHN0YXJ0X2RhdGU6IEkuc3RhcnRfZGF0ZSwgZHVyYXRpb246IEkuZHVyYXRpb24sIHRhc2s6IFQgfSksIEMucHVzaChJKTtcbiAgICAgIH0pLCBDO1xuICAgIH0sIGYucHJvdG90eXBlLmJ1dHRvbl9jbGljayA9IGZ1bmN0aW9uKFMsIFQsIEUsIEMpIHtcbiAgICAgIGlmIChfLmNhbGxFdmVudChcIm9uU2VjdGlvbkJ1dHRvblwiLCBbXy5fbGlnaHRib3hfaWQsIEVdKSAhPT0gITEgJiYgKFQuY2xvc2VzdChcIi5nYW50dF9jdXN0b21fYnV0dG9uLmdhbnR0X3JlbW92ZV9iYXNlbGluZXNcIikgJiYgKEMuaW5uZXJIVE1MID0gXy5sb2NhbGUubGFiZWxzLmJhc2VsaW5lc19zZWN0aW9uX3BsYWNlaG9sZGVyKSwgVC5jbG9zZXN0KFwiLmdhbnR0X2N1c3RvbV9idXR0b24uZ2FudHRfYWRkX2Jhc2VsaW5lc1wiKSkpIHtcbiAgICAgICAgQy5pbm5lckhUTUwgPT0gXy5sb2NhbGUubGFiZWxzLmJhc2VsaW5lc19zZWN0aW9uX3BsYWNlaG9sZGVyICYmIChDLmlubmVySFRNTCA9IFwiXCIpO1xuICAgICAgICBjb25zdCBEID0gXy5nZXRUYXNrKF8uX2xpZ2h0Ym94X2lkKTtcbiAgICAgICAgeChDLCB7IGlkOiBfLnVpZCgpLCB0YXNrX2lkOiBELmlkLCBzdGFydF9kYXRlOiBELnN0YXJ0X2RhdGUsIGVuZF9kYXRlOiBELmVuZF9kYXRlIH0sIEQsIF8uX2dldF90eXBlZF9saWdodGJveF9jb25maWcoKVtTXSk7XG4gICAgICB9XG4gICAgfSwgZi5wcm90b3R5cGUuZm9jdXMgPSBmdW5jdGlvbihTKSB7XG4gICAgICBfLl9mb2N1cyhTLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic2VsZWN0XCIpWzBdKTtcbiAgICB9LCBmO1xuICB9KHQpO1xuICB0Ll9saWdodGJveF9tZXRob2RzID0ge30sIHQuX2xpZ2h0Ym94X3RlbXBsYXRlID0gXCI8ZGl2IGNsYXNzPSdnYW50dF9jYWxfbHRpdGxlJz48c3BhbiBjbGFzcz0nZ2FudHRfbWFyayc+Jm5ic3A7PC9zcGFuPjxzcGFuIGNsYXNzPSdnYW50dF90aW1lJz48L3NwYW4+PHNwYW4gY2xhc3M9J2dhbnR0X3RpdGxlJz48L3NwYW4+PC9kaXY+PGRpdiBjbGFzcz0nZ2FudHRfY2FsX2xhcmVhJz48L2Rpdj5cIiwgdC5fbGlnaHRib3hfdGVtcGxhdGUgPSBgPGRpdiBjbGFzcz0nZ2FudHRfY2FsX2x0aXRsZSc+PGRpdiBjbGFzcz1cImRoeF9jYWxfbHRpdGxlX2Rlc2NyXCI+PHNwYW4gY2xhc3M9J2dhbnR0X21hcmsnPiZuYnNwOzwvc3Bhbj48c3BhbiBjbGFzcz0nZ2FudHRfdGltZSc+PC9zcGFuPjxzcGFuIGNsYXNzPSdkaHhfdGl0bGUnPjwvc3Bhbj5cbjwvZGl2PlxuPGRpdiBjbGFzcz1cImdhbnR0X2NhbF9sdGl0bGVfY29udHJvbHNcIj5cblx0PGEgY2xhc3M9XCJnYW50dF9jYWxfbHRpdGxlX2Nsb3NlX2J0biBkaHhfZ2FudHRfaWNvbiBkaHhfZ2FudHRfaWNvbl9jbG9zZVwiPjwvYT5cblxuPC9kaXY+PC9kaXY+PGRpdiBjbGFzcz0nZ2FudHRfY2FsX2xhcmVhJz48L2Rpdj5gLCB0Ll9saWdodGJveF9yb290ID0gdC4kcm9vdCwgdC4kc2VydmljZXMuZ2V0U2VydmljZShcInN0YXRlXCIpLnJlZ2lzdGVyUHJvdmlkZXIoXCJsaWdodGJveFwiLCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4geyBsaWdodGJveDogdC5fbGlnaHRib3hfaWQgfTtcbiAgfSksIHQuc2hvd0xpZ2h0Ym94ID0gZnVuY3Rpb24oXykge1xuICAgIHZhciBtID0gdGhpcy5nZXRUYXNrKF8pO1xuICAgIGlmICh0aGlzLmNhbGxFdmVudChcIm9uQmVmb3JlTGlnaHRib3hcIiwgW19dKSkge1xuICAgICAgdmFyIGYgPSB0aGlzLmdldExpZ2h0Ym94KHRoaXMuZ2V0VGFza1R5cGUobS50eXBlKSk7XG4gICAgICB0aGlzLnNob3dDb3ZlcihmKSwgdGhpcy5fZmlsbF9saWdodGJveChfLCBmKSwgdGhpcy5fc2V0TGJQb3NpdGlvbihmKSwgdGhpcy5fd2FpQXJpYS5saWdodGJveFZpc2libGVBdHRyKGYpLCB0aGlzLmNhbGxFdmVudChcIm9uTGlnaHRib3hcIiwgW19dKTtcbiAgICB9IGVsc2UgdC5pc1Rhc2tFeGlzdHMoXykgJiYgdC5nZXRUYXNrKF8pLiRuZXcgJiYgdGhpcy4kZGF0YS50YXNrc1N0b3JlLl91cGRhdGVPcmRlcigpO1xuICB9LCB0Ll9nZXRfdGltZXBpY2tlcl9zdGVwID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuY29uZmlnLnJvdW5kX2RuZF9kYXRlcykge1xuICAgICAgdmFyIF87XG4gICAgICBpZiAoZnVuY3Rpb24oZikge1xuICAgICAgICB2YXIgayA9IGYuJHVpLmdldFZpZXcoXCJ0aW1lbGluZVwiKTtcbiAgICAgICAgcmV0dXJuICEoIWsgfHwgIWsuaXNWaXNpYmxlKCkpO1xuICAgICAgfSh0aGlzKSkge1xuICAgICAgICB2YXIgbSA9IHQuZ2V0U2NhbGUoKTtcbiAgICAgICAgXyA9IFZ0KG0udW5pdCkgKiBtLnN0ZXAgLyA2MDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoIV8gfHwgXyA+PSAxNDQwKSAmJiAoXyA9IHRoaXMuY29uZmlnLnRpbWVfc3RlcCksIF87XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbmZpZy50aW1lX3N0ZXA7XG4gIH0sIHQuZ2V0TGFiZWwgPSBmdW5jdGlvbihfLCBtKSB7XG4gICAgZm9yICh2YXIgZiA9IHRoaXMuX2dldF90eXBlZF9saWdodGJveF9jb25maWcoKSwgayA9IDA7IGsgPCBmLmxlbmd0aDsgaysrKSBpZiAoZltrXS5tYXBfdG8gPT0gXykge1xuICAgICAgZm9yICh2YXIgeCA9IGZba10ub3B0aW9ucywgJCA9IDA7ICQgPCB4Lmxlbmd0aDsgJCsrKSBpZiAoeFskXS5rZXkgPT0gbSkgcmV0dXJuIHhbJF0ubGFiZWw7XG4gICAgfVxuICAgIHJldHVybiBcIlwiO1xuICB9LCB0LnVwZGF0ZUNvbGxlY3Rpb24gPSBmdW5jdGlvbihfLCBtKSB7XG4gICAgbSA9IG0uc2xpY2UoMCk7XG4gICAgdmFyIGYgPSB0LnNlcnZlckxpc3QoXyk7XG4gICAgaWYgKCFmKSByZXR1cm4gITE7XG4gICAgZi5zcGxpY2UoMCwgZi5sZW5ndGgpLCBmLnB1c2guYXBwbHkoZiwgbSB8fCBbXSksIHQucmVzZXRMaWdodGJveCgpO1xuICB9LCB0LmdldExpZ2h0Ym94VHlwZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmdldFRhc2tUeXBlKHRoaXMuX2xpZ2h0Ym94X3R5cGUpO1xuICB9LCB0LmdldExpZ2h0Ym94ID0gZnVuY3Rpb24oXykge1xuICAgIHZhciBtLCBmLCBrLCB4LCAkLCB3ID0gXCJcIjtcbiAgICBpZiAoZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBUID0gdC5jb25maWcuY3NwID09PSAhMCwgRSA9ICEhd2luZG93LlNmZGMgfHwgISF3aW5kb3cuJEEgfHwgd2luZG93LkF1cmEgfHwgXCIkc2hhZG93UmVzb2x2ZXIkXCIgaW4gZG9jdW1lbnQuYm9keTtcbiAgICAgIHQuX2xpZ2h0Ym94X3Jvb3QgPSBUIHx8IEUgPyB0LiRyb290IDogZG9jdW1lbnQuYm9keTtcbiAgICB9KCksIF8gPT09IHZvaWQgMCAmJiAoXyA9IHRoaXMuZ2V0TGlnaHRib3hUeXBlKCkpLCAhdGhpcy5fbGlnaHRib3ggfHwgdGhpcy5nZXRMaWdodGJveFR5cGUoKSAhPSB0aGlzLmdldFRhc2tUeXBlKF8pKSB7XG4gICAgICB0aGlzLl9saWdodGJveF90eXBlID0gdGhpcy5nZXRUYXNrVHlwZShfKSwgbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksIHcgPSBcImdhbnR0X2NhbF9saWdodFwiLCBmID0gdGhpcy5faXNfbGlnaHRib3hfdGltZXBpY2tlcigpLCB0LmNvbmZpZy53aWRlX2Zvcm0gJiYgKHcgKz0gXCIgZ2FudHRfY2FsX2xpZ2h0X3dpZGVcIiksIGYgJiYgKHcgKz0gXCIgZ2FudHRfY2FsX2xpZ2h0X2Z1bGxcIiksIG0uY2xhc3NOYW1lID0gdywgbS5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIiwgayA9IHRoaXMuX2xpZ2h0Ym94X3RlbXBsYXRlLCBrICs9IFwiPGRpdiBjbGFzcz0nZ2FudHRfY2FsX2xjb250cm9scyc+XCIsIGsgKz0geSh0aGlzLmNvbmZpZy5idXR0b25zX2xlZnQpLCBrICs9IFwiPGRpdiBjbGFzcz0nZ2FudHRfY2FsX2xjb250cm9sc19wdXNoX3JpZ2h0Jz48L2Rpdj5cIiwgayArPSB5KHRoaXMuY29uZmlnLmJ1dHRvbnNfcmlnaHQpLCBrICs9IFwiPC9kaXY+XCIsIG0uaW5uZXJIVE1MID0gaywgdC5fd2FpQXJpYS5saWdodGJveEF0dHIobSksIHQuY29uZmlnLmRyYWdfbGlnaHRib3ggJiYgKG0uZmlyc3RDaGlsZC5vbm1vdXNlZG93biA9IHQuX3JlYWR5X3RvX2RuZCwgbS5maXJzdENoaWxkLm9udG91Y2hzdGFydCA9IGZ1bmN0aW9uKFQpIHtcbiAgICAgICAgdC5fcmVhZHlfdG9fZG5kKFQudG91Y2hlc1swXSk7XG4gICAgICB9LCBtLmZpcnN0Q2hpbGQub25zZWxlY3RzdGFydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gITE7XG4gICAgICB9LCBtLmZpcnN0Q2hpbGQuc3R5bGUuY3Vyc29yID0gXCJwb2ludGVyXCIsIHQuX2luaXRfZG5kX2V2ZW50cygpKSwgdGhpcy5fbGlnaHRib3ggJiYgdGhpcy5yZXNldExpZ2h0Ym94KCksIGcoKSwgdGhpcy5fY292ZXIuaW5zZXJ0QmVmb3JlKG0sIHRoaXMuX2NvdmVyLmZpcnN0Q2hpbGQpLCB0aGlzLl9saWdodGJveCA9IG0sIHggPSB0aGlzLl9nZXRfdHlwZWRfbGlnaHRib3hfY29uZmlnKF8pLCBrID0gdGhpcy5fcmVuZGVyX3NlY3Rpb25zKHgpO1xuICAgICAgdmFyIFMgPSAoJCA9IG0ucXVlcnlTZWxlY3RvcihcImRpdi5nYW50dF9jYWxfbGFyZWFcIikpLnN0eWxlLm92ZXJmbG93O1xuICAgICAgJC5zdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCIsICQuaW5uZXJIVE1MID0gaywgZnVuY3Rpb24oVCkge1xuICAgICAgICB2YXIgRSwgQywgRCwgTSwgSSwgQTtcbiAgICAgICAgZm9yIChBID0gMDsgQSA8IFQubGVuZ3RoOyBBKyspIEUgPSBUW0FdLCBEID0gdC5fbGlnaHRib3hfcm9vdC5xdWVyeVNlbGVjdG9yKFwiI1wiICsgRS5pZCksIEUuaWQgJiYgRCAmJiAoQyA9IEQucXVlcnlTZWxlY3RvcihcImxhYmVsXCIpLCAoTSA9IEQubmV4dFNpYmxpbmcpICYmIChJID0gTS5xdWVyeVNlbGVjdG9yKFwiaW5wdXQsIHNlbGVjdCwgdGV4dGFyZWFcIikpICYmIChJLmlkID0gSS5pZCB8fCBcImlucHV0X1wiICsgdC51aWQoKSwgRS5pbnB1dElkID0gSS5pZCwgQy5zZXRBdHRyaWJ1dGUoXCJmb3JcIiwgRS5pbnB1dElkKSkpO1xuICAgICAgfSh4KSwgJC5zdHlsZS5vdmVyZmxvdyA9IFMsIHRoaXMuX2luaXRfbGlnaHRib3hfZXZlbnRzKHRoaXMpLCBtLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIiwgbS5zdHlsZS52aXNpYmlsaXR5ID0gXCJ2aXNpYmxlXCI7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9saWdodGJveDtcbiAgfSwgdC5fcmVuZGVyX3NlY3Rpb25zID0gZnVuY3Rpb24oXykge1xuICAgIGZvciAodmFyIG0gPSBcIlwiLCBmID0gMDsgZiA8IF8ubGVuZ3RoOyBmKyspIHtcbiAgICAgIHZhciBrID0gdGhpcy5mb3JtX2Jsb2Nrc1tfW2ZdLnR5cGVdO1xuICAgICAgaWYgKGspIHtcbiAgICAgICAgX1tmXS5pZCA9IFwiYXJlYV9cIiArIHRoaXMudWlkKCk7XG4gICAgICAgIHZhciB4ID0gX1tmXS5oaWRkZW4gPyBcIiBzdHlsZT0nZGlzcGxheTpub25lJ1wiIDogXCJcIiwgJCA9IFwiXCI7XG4gICAgICAgIF9bZl0uYnV0dG9uICYmICgkID0gXCI8ZGl2IGNsYXNzPSdnYW50dF9jdXN0b21fYnV0dG9uJyBkYXRhLWluZGV4PSdcIiArIGYgKyBcIic+PGRpdiBjbGFzcz0nZ2FudHRfY3VzdG9tX2J1dHRvbl9cIiArIF9bZl0uYnV0dG9uICsgXCInPjwvZGl2PjxkaXYgY2xhc3M9J2dhbnR0X2N1c3RvbV9idXR0b25fbGFiZWwnPlwiICsgdGhpcy5sb2NhbGUubGFiZWxzW1wiYnV0dG9uX1wiICsgX1tmXS5idXR0b25dICsgXCI8L2Rpdj48L2Rpdj5cIiksIF9bZl0udHlwZSA9PSBcImJhc2VsaW5lc1wiICYmICgkID0gXCI8ZGl2IGNsYXNzPSdnYW50dF9jdXN0b21fYnV0dG9uIGdhbnR0X3JlbW92ZV9iYXNlbGluZXMnIGRhdGEtaW5kZXg9J1wiICsgZiArIFwiJz48ZGl2IGNsYXNzPSdnYW50dF9jdXN0b21fYnV0dG9uX2RlbGV0ZV9iYXNlbGluZXMnPjwvZGl2PjxkaXYgY2xhc3M9J2dhbnR0X2N1c3RvbV9idXR0b25fbGFiZWwnPlwiICsgdGhpcy5sb2NhbGUubGFiZWxzLmJhc2VsaW5lc19yZW1vdmVfYWxsX2J1dHRvbiArIFwiPC9kaXY+PC9kaXY+PGRpdiBjbGFzcz0nZ2FudHRfY3VzdG9tX2J1dHRvbiBnYW50dF9hZGRfYmFzZWxpbmVzJyBkYXRhLWluZGV4PSdcIiArIGYgKyBcIic+PGRpdiBjbGFzcz0nZ2FudHRfY3VzdG9tX2J1dHRvbl9hZGRfYmFzZWxpbmUnPjwvZGl2PjxkaXYgY2xhc3M9J2dhbnR0X2N1c3RvbV9idXR0b25fbGFiZWwnPlwiICsgdGhpcy5sb2NhbGUubGFiZWxzLmJhc2VsaW5lc19hZGRfYnV0dG9uICsgXCI8L2Rpdj48L2Rpdj5cIiksIHRoaXMuY29uZmlnLndpZGVfZm9ybSAmJiAobSArPSBcIjxkaXYgY2xhc3M9J2dhbnR0X3dyYXBfc2VjdGlvbicgXCIgKyB4ICsgXCI+XCIpLCBtICs9IFwiPGRpdiBpZD0nXCIgKyBfW2ZdLmlkICsgXCInIGNsYXNzPSdnYW50dF9jYWxfbHNlY3Rpb24nPjxsYWJlbD5cIiArICQgKyAoX1tmXS5sYWJlbCB8fCB0aGlzLmxvY2FsZS5sYWJlbHNbXCJzZWN0aW9uX1wiICsgX1tmXS5uYW1lXSB8fCBfW2ZdLm5hbWUpICsgXCI8L2xhYmVsPjwvZGl2PlwiICsgay5yZW5kZXIuY2FsbCh0aGlzLCBfW2ZdKSwgbSArPSBcIjwvZGl2PlwiO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbTtcbiAgfSwgdC5fY2VudGVyX2xpZ2h0Ym94ID0gZnVuY3Rpb24oXykge1xuICAgIHQuX3NldExiUG9zaXRpb24oXyk7XG4gIH0sIHQuX3NldExiUG9zaXRpb24gPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFfKSByZXR1cm47XG4gICAgY29uc3QgbSA9IHQuX2xpZ2h0Ym94X3Jvb3QgfHwgdC4kcm9vdDtcbiAgICBfLnN0eWxlLnRvcCA9IE1hdGgubWF4KG0ub2Zmc2V0SGVpZ2h0IC8gMiAtIF8ub2Zmc2V0SGVpZ2h0IC8gMiwgMCkgKyBcInB4XCIsIF8uc3R5bGUubGVmdCA9IE1hdGgubWF4KG0ub2Zmc2V0V2lkdGggLyAyIC0gXy5vZmZzZXRXaWR0aCAvIDIsIDApICsgXCJweFwiO1xuICB9LCB0LnNob3dDb3ZlciA9IGZ1bmN0aW9uKF8pIHtcbiAgICBfICYmIChfLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCIsIHRoaXMuX3NldExiUG9zaXRpb24oXykpLCBnKCksIHRoaXMuX2NvdmVyLnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xuICB9O1xuICBjb25zdCBnID0gZnVuY3Rpb24oKSB7XG4gICAgdC5fY292ZXIgfHwgKHQuX2NvdmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSwgdC5fY292ZXIuY2xhc3NOYW1lID0gXCJnYW50dF9jYWxfY292ZXJcIiwgdC5fY292ZXIuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiLCB0LmV2ZW50KHQuX2NvdmVyLCBcIm1vdXNlbW92ZVwiLCB0Ll9tb3ZlX3doaWxlX2RuZCksIHQuZXZlbnQodC5fY292ZXIsIFwibW91c2V1cFwiLCB0Ll9maW5pc2hfZG5kKSwgKHQuX2xpZ2h0Ym94X3Jvb3QgfHwgdC4kcm9vdCkuYXBwZW5kQ2hpbGQodC5fY292ZXIpKTtcbiAgfTtcbiAgZnVuY3Rpb24gcChfKSB7XG4gICAgZm9yICh2YXIgbSBpbiB0aGlzLmNvbmZpZy50eXBlcykgaWYgKHRoaXMuY29uZmlnLnR5cGVzW21dID09IF8pIHJldHVybiBtO1xuICAgIHJldHVybiBcInRhc2tcIjtcbiAgfVxuICBmdW5jdGlvbiB5KF8sIG0pIHtcbiAgICB2YXIgZiwgaywgeCA9IFwiXCI7XG4gICAgZm9yIChrID0gMDsgayA8IF8ubGVuZ3RoOyBrKyspIGYgPSB0LmNvbmZpZy5fbWlncmF0ZV9idXR0b25zW19ba11dID8gdC5jb25maWcuX21pZ3JhdGVfYnV0dG9uc1tfW2tdXSA6IF9ba10sIHggKz0gXCI8ZGl2IFwiICsgdC5fd2FpQXJpYS5saWdodGJveEJ1dHRvbkF0dHJTdHJpbmcoZikgKyBcIiBjbGFzcz0nZ2FudHRfYnRuX3NldCBnYW50dF9sZWZ0X2J0bl9zZXQgXCIgKyBmICsgXCJfc2V0Jz48ZGl2IGRoeF9idXR0b249JzEnIGRhdGEtZGh4LWJ1dHRvbj0nMScgY2xhc3M9J1wiICsgZiArIFwiJz48L2Rpdj48ZGl2PlwiICsgdC5sb2NhbGUubGFiZWxzW2ZdICsgXCI8L2Rpdj48L2Rpdj5cIjtcbiAgICByZXR1cm4geDtcbiAgfVxuICBmdW5jdGlvbiB2KF8pIHtcbiAgICB2YXIgbSwgZjtcbiAgICByZXR1cm4gXy50aW1lX2Zvcm1hdCA/IF8udGltZV9mb3JtYXQgOiAoZiA9IFtcIiVkXCIsIFwiJW1cIiwgXCIlWVwiXSwgVnQoKG0gPSB0LmdldFNjYWxlKCkpID8gbS51bml0IDogdC5jb25maWcuZHVyYXRpb25fdW5pdCkgPCBWdChcImRheVwiKSAmJiBmLnB1c2goXCIlSDolaVwiKSwgZik7XG4gIH1cbiAgZnVuY3Rpb24gYihfLCBtLCBmKSB7XG4gICAgdmFyIGssIHgsICQsIHcsIFMsIFQsIEUgPSBcIlwiO1xuICAgIHN3aXRjaCAoZi50aW1lRm9ybWF0W21dKSB7XG4gICAgICBjYXNlIFwiJVlcIjpcbiAgICAgICAgZm9yIChfLl90aW1lX2Zvcm1hdF9vcmRlclsyXSA9IG0sIF8uX3RpbWVfZm9ybWF0X29yZGVyLnNpemUrKywgXy55ZWFyX3JhbmdlICYmIChpc05hTihfLnllYXJfcmFuZ2UpID8gXy55ZWFyX3JhbmdlLnB1c2ggJiYgKCQgPSBfLnllYXJfcmFuZ2VbMF0sIHcgPSBfLnllYXJfcmFuZ2VbMV0pIDogayA9IF8ueWVhcl9yYW5nZSksIGsgPSBrIHx8IDEwLCB4ID0geCB8fCBNYXRoLmZsb29yKGsgLyAyKSwgJCA9ICQgfHwgZi5kYXRlLmdldEZ1bGxZZWFyKCkgLSB4LCB3ID0gdyB8fCB0LmdldFN0YXRlKCkubWF4X2RhdGUuZ2V0RnVsbFllYXIoKSArIHgsIFMgPSAkOyBTIDw9IHc7IFMrKykgRSArPSBcIjxvcHRpb24gdmFsdWU9J1wiICsgUyArIFwiJz5cIiArIFMgKyBcIjwvb3B0aW9uPlwiO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCIlbVwiOlxuICAgICAgICBmb3IgKF8uX3RpbWVfZm9ybWF0X29yZGVyWzFdID0gbSwgXy5fdGltZV9mb3JtYXRfb3JkZXIuc2l6ZSsrLCBTID0gMDsgUyA8IDEyOyBTKyspIEUgKz0gXCI8b3B0aW9uIHZhbHVlPSdcIiArIFMgKyBcIic+XCIgKyB0LmxvY2FsZS5kYXRlLm1vbnRoX2Z1bGxbU10gKyBcIjwvb3B0aW9uPlwiO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCIlZFwiOlxuICAgICAgICBmb3IgKF8uX3RpbWVfZm9ybWF0X29yZGVyWzBdID0gbSwgXy5fdGltZV9mb3JtYXRfb3JkZXIuc2l6ZSsrLCBTID0gMTsgUyA8IDMyOyBTKyspIEUgKz0gXCI8b3B0aW9uIHZhbHVlPSdcIiArIFMgKyBcIic+XCIgKyBTICsgXCI8L29wdGlvbj5cIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiJUg6JWlcIjpcbiAgICAgICAgZm9yIChfLl90aW1lX2Zvcm1hdF9vcmRlclszXSA9IG0sIF8uX3RpbWVfZm9ybWF0X29yZGVyLnNpemUrKywgUyA9IGYuZmlyc3QsIFQgPSBmLmRhdGUuZ2V0RGF0ZSgpLCBfLl90aW1lX3ZhbHVlcyA9IFtdOyBTIDwgZi5sYXN0OyApIEUgKz0gXCI8b3B0aW9uIHZhbHVlPSdcIiArIFMgKyBcIic+XCIgKyB0LnRlbXBsYXRlcy50aW1lX3BpY2tlcihmLmRhdGUpICsgXCI8L29wdGlvbj5cIiwgXy5fdGltZV92YWx1ZXMucHVzaChTKSwgZi5kYXRlLnNldFRpbWUoZi5kYXRlLnZhbHVlT2YoKSArIDYwICogdC5fZ2V0X3RpbWVwaWNrZXJfc3RlcCgpICogMWUzKSwgUyA9IDI0ICogKGYuZGF0ZS5nZXREYXRlKCkgIT0gVCA/IDEgOiAwKSAqIDYwICsgNjAgKiBmLmRhdGUuZ2V0SG91cnMoKSArIGYuZGF0ZS5nZXRNaW51dGVzKCk7XG4gICAgfVxuICAgIHJldHVybiBFO1xuICB9XG4gIHQuX2luaXRfbGlnaHRib3hfZXZlbnRzID0gZnVuY3Rpb24oKSB7XG4gICAgdC5saWdodGJveF9ldmVudHMgPSB7fSwgdC5saWdodGJveF9ldmVudHMuZ2FudHRfc2F2ZV9idG4gPSBmdW5jdGlvbigpIHtcbiAgICAgIHQuX3NhdmVfbGlnaHRib3goKTtcbiAgICB9LCB0LmxpZ2h0Ym94X2V2ZW50cy5nYW50dF9kZWxldGVfYnRuID0gZnVuY3Rpb24oKSB7XG4gICAgICB0Ll9saWdodGJveF9jdXJyZW50X3R5cGUgPSBudWxsLCB0LmNhbGxFdmVudChcIm9uTGlnaHRib3hEZWxldGVcIiwgW3QuX2xpZ2h0Ym94X2lkXSkgJiYgKHQuaXNUYXNrRXhpc3RzKHQuX2xpZ2h0Ym94X2lkKSA/IHQuJGNsaWNrLmJ1dHRvbnMuZGVsZXRlKHQuX2xpZ2h0Ym94X2lkKSA6IHQuaGlkZUxpZ2h0Ym94KCkpO1xuICAgIH0sIHQubGlnaHRib3hfZXZlbnRzLmdhbnR0X2NhbmNlbF9idG4gPSBmdW5jdGlvbigpIHtcbiAgICAgIHQuX2NhbmNlbF9saWdodGJveCgpO1xuICAgIH0sIHQubGlnaHRib3hfZXZlbnRzLmRlZmF1bHQgPSBmdW5jdGlvbihfLCBtKSB7XG4gICAgICBpZiAobS5nZXRBdHRyaWJ1dGUoXCJkYXRhLWRoeC1idXR0b25cIikpIHQuY2FsbEV2ZW50KFwib25MaWdodGJveEJ1dHRvblwiLCBbbS5jbGFzc05hbWUsIG0sIF9dKTtcbiAgICAgIGVsc2Uge1xuICAgICAgICB2YXIgZiwgaywgeCA9IFgobSk7XG4gICAgICAgIGlmICh4LmluZGV4T2YoXCJnYW50dF9jdXN0b21fYnV0dG9uXCIpICE9IC0xKSBpZiAoeC5pbmRleE9mKFwiZ2FudHRfY3VzdG9tX2J1dHRvbl9cIikgIT0gLTEpIGZvciAoZiA9IG0ucGFyZW50Tm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLWluZGV4XCIpLCBrID0gbTsgayAmJiBYKGspLmluZGV4T2YoXCJnYW50dF9jYWxfbHNlY3Rpb25cIikgPT0gLTE7ICkgayA9IGsucGFyZW50Tm9kZTtcbiAgICAgICAgZWxzZSBmID0gbS5nZXRBdHRyaWJ1dGUoXCJkYXRhLWluZGV4XCIpLCBrID0gbS5jbG9zZXN0KFwiLmdhbnR0X2NhbF9sc2VjdGlvblwiKSwgbSA9IG0uZmlyc3RDaGlsZDtcbiAgICAgICAgdmFyICQgPSB0Ll9nZXRfdHlwZWRfbGlnaHRib3hfY29uZmlnKCk7XG4gICAgICAgIGYgJiYgKGYgKj0gMSwgdC5mb3JtX2Jsb2Nrc1skWzEgKiBmXS50eXBlXS5idXR0b25fY2xpY2soZiwgbSwgaywgay5uZXh0U2libGluZykpO1xuICAgICAgfVxuICAgIH0sIHRoaXMuZXZlbnQodC5nZXRMaWdodGJveCgpLCBcImNsaWNrXCIsIGZ1bmN0aW9uKF8pIHtcbiAgICAgIF8udGFyZ2V0LmNsb3Nlc3QoXCIuZ2FudHRfY2FsX2x0aXRsZV9jbG9zZV9idG5cIikgJiYgdC5fY2FuY2VsX2xpZ2h0Ym94KCk7XG4gICAgICB2YXIgbSA9IHl0KF8pLCBmID0gWChtKTtcbiAgICAgIHJldHVybiBmIHx8IChmID0gWChtID0gbS5wcmV2aW91c1NpYmxpbmcpKSwgbSAmJiBmICYmIGYuaW5kZXhPZihcImdhbnR0X2J0bl9zZXRcIikgPT09IDAgJiYgKGYgPSBYKG0gPSBtLmZpcnN0Q2hpbGQpKSwgISghbSB8fCAhZikgJiYgKHQuZGVmaW5lZCh0LmxpZ2h0Ym94X2V2ZW50c1ttLmNsYXNzTmFtZV0pID8gdC5saWdodGJveF9ldmVudHNbbS5jbGFzc05hbWVdIDogdC5saWdodGJveF9ldmVudHMuZGVmYXVsdCkoXywgbSk7XG4gICAgfSksIHQuZ2V0TGlnaHRib3goKS5vbmtleWRvd24gPSBmdW5jdGlvbihfKSB7XG4gICAgICB2YXIgbSA9IF8gfHwgd2luZG93LmV2ZW50LCBmID0gXy50YXJnZXQgfHwgXy5zcmNFbGVtZW50LCBrID0gWChmKS5pbmRleE9mKFwiZ2FudHRfYnRuX3NldFwiKSA+IC0xO1xuICAgICAgc3dpdGNoICgoXyB8fCBtKS5rZXlDb2RlKSB7XG4gICAgICAgIGNhc2UgdC5jb25zdGFudHMuS0VZX0NPREVTLlNQQUNFOlxuICAgICAgICAgIGlmICgoXyB8fCBtKS5zaGlmdEtleSkgcmV0dXJuO1xuICAgICAgICAgIGsgJiYgZi5jbGljayAmJiBmLmNsaWNrKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgdC5rZXlzLmVkaXRfc2F2ZTpcbiAgICAgICAgICBpZiAoKF8gfHwgbSkuc2hpZnRLZXkpIHJldHVybjtcbiAgICAgICAgICBrICYmIGYuY2xpY2sgPyBmLmNsaWNrKCkgOiB0Ll9zYXZlX2xpZ2h0Ym94KCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgdC5rZXlzLmVkaXRfY2FuY2VsOlxuICAgICAgICAgIHQuX2NhbmNlbF9saWdodGJveCgpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIHQuX2NhbmNlbF9saWdodGJveCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBfID0gdGhpcy5nZXRMaWdodGJveFZhbHVlcygpO1xuICAgIHQuX2xpZ2h0Ym94X2N1cnJlbnRfdHlwZSA9IG51bGwsIHRoaXMuY2FsbEV2ZW50KFwib25MaWdodGJveENhbmNlbFwiLCBbdGhpcy5fbGlnaHRib3hfaWQsIF8uJG5ld10pLCB0LmlzVGFza0V4aXN0cyhfLmlkKSAmJiBfLiRuZXcgJiYgKHRoaXMuc2lsZW50KGZ1bmN0aW9uKCkge1xuICAgICAgdC4kZGF0YS50YXNrc1N0b3JlLnJlbW92ZUl0ZW0oXy5pZCksIHQuX3VwZGF0ZV9mbGFncyhfLmlkLCBudWxsKTtcbiAgICB9KSwgdGhpcy5yZWZyZXNoRGF0YSgpKSwgdGhpcy5oaWRlTGlnaHRib3goKTtcbiAgfSwgdC5fc2F2ZV9saWdodGJveCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBfID0gdGhpcy5nZXRMaWdodGJveFZhbHVlcygpO1xuICAgIHQuX2xpZ2h0Ym94X2N1cnJlbnRfdHlwZSA9IG51bGwsIHRoaXMuY2FsbEV2ZW50KFwib25MaWdodGJveFNhdmVcIiwgW3RoaXMuX2xpZ2h0Ym94X2lkLCBfLCAhIV8uJG5ld10pICYmICh0LiRkYXRhLnRhc2tzU3RvcmUuX3NraXBUYXNrUmVjYWxjdWxhdGlvbiA9IFwibGlnaHRib3hcIiwgXy4kbmV3ID8gKGRlbGV0ZSBfLiRuZXcsIHRoaXMuYWRkVGFzayhfLCBfLnBhcmVudCwgdGhpcy5nZXRUYXNrSW5kZXgoXy5pZCkpKSA6IHRoaXMuaXNUYXNrRXhpc3RzKF8uaWQpICYmICh0aGlzLm1peGluKHRoaXMuZ2V0VGFzayhfLmlkKSwgXywgITApLCB0aGlzLnJlZnJlc2hUYXNrKF8uaWQpLCB0aGlzLnVwZGF0ZVRhc2soXy5pZCkpLCB0LiRkYXRhLnRhc2tzU3RvcmUuX3NraXBUYXNrUmVjYWxjdWxhdGlvbiA9ICExLCB0aGlzLnJlZnJlc2hEYXRhKCksIHRoaXMuaGlkZUxpZ2h0Ym94KCkpO1xuICB9LCB0Ll9yZXNvbHZlX2RlZmF1bHRfbWFwcGluZyA9IGZ1bmN0aW9uKF8pIHtcbiAgICB2YXIgbSA9IF8ubWFwX3RvO1xuICAgIHJldHVybiB7IHRpbWU6ICEwLCB0aW1lX29wdGlvbmFsOiAhMCwgZHVyYXRpb246ICEwLCBkdXJhdGlvbl9vcHRpb25hbDogITAgfVtfLnR5cGVdID8gXy5tYXBfdG8gPT0gXCJhdXRvXCIgPyBtID0geyBzdGFydF9kYXRlOiBcInN0YXJ0X2RhdGVcIiwgZW5kX2RhdGU6IFwiZW5kX2RhdGVcIiwgZHVyYXRpb246IFwiZHVyYXRpb25cIiB9IDogdHlwZW9mIF8ubWFwX3RvID09IFwic3RyaW5nXCIgJiYgKG0gPSB7IHN0YXJ0X2RhdGU6IF8ubWFwX3RvIH0pIDogXy50eXBlID09PSBcImNvbnN0cmFpbnRcIiAmJiAoXy5tYXBfdG8gJiYgdHlwZW9mIF8ubWFwX3RvICE9IFwic3RyaW5nXCIgfHwgKG0gPSB7IGNvbnN0cmFpbnRfdHlwZTogXCJjb25zdHJhaW50X3R5cGVcIiwgY29uc3RyYWludF9kYXRlOiBcImNvbnN0cmFpbnRfZGF0ZVwiIH0pKSwgbTtcbiAgfSwgdC5nZXRMaWdodGJveFZhbHVlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBfID0ge307XG4gICAgdC5pc1Rhc2tFeGlzdHModGhpcy5fbGlnaHRib3hfaWQpICYmIChfID0gdGhpcy5taXhpbih7fSwgdGhpcy5nZXRUYXNrKHRoaXMuX2xpZ2h0Ym94X2lkKSkpO1xuICAgIGZvciAodmFyIG0gPSB0aGlzLl9nZXRfdHlwZWRfbGlnaHRib3hfY29uZmlnKCksIGYgPSAwOyBmIDwgbS5sZW5ndGg7IGYrKykge1xuICAgICAgdmFyIGsgPSB0Ll9saWdodGJveF9yb290LnF1ZXJ5U2VsZWN0b3IoXCIjXCIgKyBtW2ZdLmlkKTtcbiAgICAgIGsgPSBrICYmIGsubmV4dFNpYmxpbmc7XG4gICAgICB2YXIgeCA9IHRoaXMuZm9ybV9ibG9ja3NbbVtmXS50eXBlXTtcbiAgICAgIGlmICh4KSB7XG4gICAgICAgIHZhciAkID0geC5nZXRfdmFsdWUuY2FsbCh0aGlzLCBrLCBfLCBtW2ZdKSwgdyA9IHQuX3Jlc29sdmVfZGVmYXVsdF9tYXBwaW5nKG1bZl0pO1xuICAgICAgICBpZiAodHlwZW9mIHcgPT0gXCJzdHJpbmdcIiAmJiB3ICE9IFwiYXV0b1wiKSBfW3ddID0gJDtcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHcgPT0gXCJvYmplY3RcIikgZm9yICh2YXIgUyBpbiB3KSB3W1NdICYmIChfW3dbU11dID0gJFtTXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0Ll9saWdodGJveF9jdXJyZW50X3R5cGUgJiYgKF8udHlwZSA9IHQuX2xpZ2h0Ym94X2N1cnJlbnRfdHlwZSksIF87XG4gIH0sIHQuaGlkZUxpZ2h0Ym94ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIF8gPSB0aGlzLmdldExpZ2h0Ym94KCk7XG4gICAgXyAmJiAoXy5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCIpLCB0aGlzLl93YWlBcmlhLmxpZ2h0Ym94SGlkZGVuQXR0cihfKSwgdGhpcy5fbGlnaHRib3hfaWQgPSBudWxsLCB0aGlzLmhpZGVDb3ZlcihfKSwgdGhpcy5yZXNldExpZ2h0Ym94KCksIHRoaXMuY2FsbEV2ZW50KFwib25BZnRlckxpZ2h0Ym94XCIsIFtdKTtcbiAgfSwgdC5oaWRlQ292ZXIgPSBmdW5jdGlvbihfKSB7XG4gICAgXyAmJiAoXy5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCIpLCB0aGlzLl9jb3ZlciAmJiB0aGlzLl9jb3Zlci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuX2NvdmVyKSwgdGhpcy5fY292ZXIgPSBudWxsO1xuICB9LCB0LnJlc2V0TGlnaHRib3ggPSBmdW5jdGlvbigpIHtcbiAgICB0Ll9saWdodGJveCAmJiAhdC5fY3VzdG9tX2xpZ2h0Ym94ICYmIHQuX2xpZ2h0Ym94LnJlbW92ZSgpLCB0Ll9saWdodGJveCA9IG51bGw7XG4gIH0sIHQuX3NldF9saWdodGJveF92YWx1ZXMgPSBmdW5jdGlvbihfLCBtKSB7XG4gICAgdmFyIGYgPSBfLCBrID0gbS5nZXRFbGVtZW50c0J5VGFnTmFtZShcInNwYW5cIiksIHggPSBbXTtcbiAgICB0LnRlbXBsYXRlcy5saWdodGJveF9oZWFkZXIgPyAoeC5wdXNoKFwiXCIpLCB4LnB1c2godC50ZW1wbGF0ZXMubGlnaHRib3hfaGVhZGVyKGYuc3RhcnRfZGF0ZSwgZi5lbmRfZGF0ZSwgZikpLCBrWzFdLmlubmVySFRNTCA9IFwiXCIsIGtbMl0uaW5uZXJIVE1MID0gdC50ZW1wbGF0ZXMubGlnaHRib3hfaGVhZGVyKGYuc3RhcnRfZGF0ZSwgZi5lbmRfZGF0ZSwgZikpIDogKHgucHVzaCh0aGlzLnRlbXBsYXRlcy50YXNrX3RpbWUoZi5zdGFydF9kYXRlLCBmLmVuZF9kYXRlLCBmKSksIHgucHVzaChTdHJpbmcodGhpcy50ZW1wbGF0ZXMudGFza190ZXh0KGYuc3RhcnRfZGF0ZSwgZi5lbmRfZGF0ZSwgZikgfHwgXCJcIikuc3Vic3RyKDAsIDcwKSksIGtbMV0uaW5uZXJIVE1MID0gdGhpcy50ZW1wbGF0ZXMudGFza190aW1lKGYuc3RhcnRfZGF0ZSwgZi5lbmRfZGF0ZSwgZiksIGtbMl0uaW5uZXJIVE1MID0gU3RyaW5nKHRoaXMudGVtcGxhdGVzLnRhc2tfdGV4dChmLnN0YXJ0X2RhdGUsIGYuZW5kX2RhdGUsIGYpIHx8IFwiXCIpLnN1YnN0cigwLCA3MCkpLCBrWzFdLmlubmVySFRNTCA9IHhbMF0sIGtbMl0uaW5uZXJIVE1MID0geFsxXSwgdC5fd2FpQXJpYS5saWdodGJveEhlYWRlcihtLCB4LmpvaW4oXCIgXCIpKTtcbiAgICBmb3IgKHZhciAkID0gdGhpcy5fZ2V0X3R5cGVkX2xpZ2h0Ym94X2NvbmZpZyh0aGlzLmdldExpZ2h0Ym94VHlwZSgpKSwgdyA9IDA7IHcgPCAkLmxlbmd0aDsgdysrKSB7XG4gICAgICB2YXIgUyA9ICRbd107XG4gICAgICBpZiAodGhpcy5mb3JtX2Jsb2Nrc1tTLnR5cGVdKSB7XG4gICAgICAgIHZhciBUID0gdC5fbGlnaHRib3hfcm9vdC5xdWVyeVNlbGVjdG9yKFwiI1wiICsgUy5pZCkubmV4dFNpYmxpbmcsIEUgPSB0aGlzLmZvcm1fYmxvY2tzW1MudHlwZV0sIEMgPSB0Ll9yZXNvbHZlX2RlZmF1bHRfbWFwcGluZygkW3ddKSwgRCA9IHRoaXMuZGVmaW5lZChmW0NdKSA/IGZbQ10gOiBTLmRlZmF1bHRfdmFsdWU7XG4gICAgICAgIEUuc2V0X3ZhbHVlLmNhbGwodCwgVCwgRCwgZiwgUyksIFMuZm9jdXMgJiYgRS5mb2N1cy5jYWxsKHQsIFQpO1xuICAgICAgfVxuICAgIH1cbiAgICB0LmlzVGFza0V4aXN0cyhfLmlkKSAmJiAodC5fbGlnaHRib3hfaWQgPSBfLmlkKTtcbiAgfSwgdC5fZmlsbF9saWdodGJveCA9IGZ1bmN0aW9uKF8sIG0pIHtcbiAgICB2YXIgZiA9IHRoaXMuZ2V0VGFzayhfKTtcbiAgICB0aGlzLl9zZXRfbGlnaHRib3hfdmFsdWVzKGYsIG0pO1xuICB9LCB0LmdldExpZ2h0Ym94U2VjdGlvbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICBmb3IgKHZhciBtID0gdGhpcy5fZ2V0X3R5cGVkX2xpZ2h0Ym94X2NvbmZpZygpLCBmID0gMDsgZiA8IG0ubGVuZ3RoICYmIG1bZl0ubmFtZSAhPSBfOyBmKyspIDtcbiAgICB2YXIgayA9IG1bZl07XG4gICAgaWYgKCFrKSByZXR1cm4gbnVsbDtcbiAgICB0aGlzLl9saWdodGJveCB8fCB0aGlzLmdldExpZ2h0Ym94KCk7XG4gICAgdmFyIHggPSB0Ll9saWdodGJveF9yb290LnF1ZXJ5U2VsZWN0b3IoXCIjXCIgKyBrLmlkKSwgJCA9IHgubmV4dFNpYmxpbmcsIHcgPSB7IHNlY3Rpb246IGssIGhlYWRlcjogeCwgbm9kZTogJCwgZ2V0VmFsdWU6IGZ1bmN0aW9uKFQpIHtcbiAgICAgIHJldHVybiB0LmZvcm1fYmxvY2tzW2sudHlwZV0uZ2V0X3ZhbHVlLmNhbGwodCwgJCwgVCB8fCB7fSwgayk7XG4gICAgfSwgc2V0VmFsdWU6IGZ1bmN0aW9uKFQsIEUpIHtcbiAgICAgIHJldHVybiB0LmZvcm1fYmxvY2tzW2sudHlwZV0uc2V0X3ZhbHVlLmNhbGwodCwgJCwgVCwgRSB8fCB7fSwgayk7XG4gICAgfSB9LCBTID0gdGhpcy5fbGlnaHRib3hfbWV0aG9kc1tcImdldF9cIiArIGsudHlwZSArIFwiX2NvbnRyb2xcIl07XG4gICAgcmV0dXJuIFMgPyBTKHcpIDogdztcbiAgfSwgdC5fbGlnaHRib3hfbWV0aG9kcy5nZXRfdGVtcGxhdGVfY29udHJvbCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gXy5jb250cm9sID0gXy5ub2RlLCBfO1xuICB9LCB0Ll9saWdodGJveF9tZXRob2RzLmdldF9zZWxlY3RfY29udHJvbCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gXy5jb250cm9sID0gXy5ub2RlLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic2VsZWN0XCIpWzBdLCBfO1xuICB9LCB0Ll9saWdodGJveF9tZXRob2RzLmdldF90ZXh0YXJlYV9jb250cm9sID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBfLmNvbnRyb2wgPSBfLm5vZGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJ0ZXh0YXJlYVwiKVswXSwgXztcbiAgfSwgdC5fbGlnaHRib3hfbWV0aG9kcy5nZXRfdGltZV9jb250cm9sID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBfLmNvbnRyb2wgPSBfLm5vZGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJzZWxlY3RcIiksIF87XG4gIH0sIHQuX2luaXRfZG5kX2V2ZW50cyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBfID0gdC5fbGlnaHRib3hfcm9vdDtcbiAgICB0aGlzLmV2ZW50KF8sIFwibW91c2Vtb3ZlXCIsIHQuX21vdmVfd2hpbGVfZG5kKSwgdGhpcy5ldmVudChfLCBcIm1vdXNldXBcIiwgdC5fZmluaXNoX2RuZCksIHRoaXMuZXZlbnQoXywgXCJ0b3VjaG1vdmVcIiwgZnVuY3Rpb24obSkge1xuICAgICAgdC5fbW92ZV93aGlsZV9kbmQobS50b3VjaGVzWzBdKTtcbiAgICB9KSwgdGhpcy5ldmVudChfLCBcInRvdWNoZW5kXCIsIGZ1bmN0aW9uKG0pIHtcbiAgICAgIHQuX2ZpbmlzaF9kbmQobS50b3VjaGVzWzBdKTtcbiAgICB9KTtcbiAgfSwgdC5fbW92ZV93aGlsZV9kbmQgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKHQuX2RuZF9zdGFydF9sYikge1xuICAgICAgZG9jdW1lbnQuZ2FudHRfdW5zZWxlY3RhYmxlIHx8ICh0Ll9saWdodGJveF9yb290LmNsYXNzTmFtZSArPSBcIiBnYW50dF91bnNlbGVjdGFibGVcIiwgZG9jdW1lbnQuZ2FudHRfdW5zZWxlY3RhYmxlID0gITApO1xuICAgICAgdmFyIG0gPSB0LmdldExpZ2h0Ym94KCksIGYgPSBbXy5wYWdlWCwgXy5wYWdlWV07XG4gICAgICBtLnN0eWxlLnRvcCA9IHQuX2xiX3N0YXJ0WzFdICsgZlsxXSAtIHQuX2RuZF9zdGFydF9sYlsxXSArIFwicHhcIiwgbS5zdHlsZS5sZWZ0ID0gdC5fbGJfc3RhcnRbMF0gKyBmWzBdIC0gdC5fZG5kX3N0YXJ0X2xiWzBdICsgXCJweFwiO1xuICAgIH1cbiAgfSwgdC5fcmVhZHlfdG9fZG5kID0gZnVuY3Rpb24oXykge1xuICAgIHZhciBtID0gdC5nZXRMaWdodGJveCgpO1xuICAgIHQuX2xiX3N0YXJ0ID0gW20ub2Zmc2V0TGVmdCwgbS5vZmZzZXRUb3BdLCB0Ll9kbmRfc3RhcnRfbGIgPSBbXy5wYWdlWCwgXy5wYWdlWV07XG4gIH0sIHQuX2ZpbmlzaF9kbmQgPSBmdW5jdGlvbigpIHtcbiAgICB0Ll9sYl9zdGFydCAmJiAodC5fbGJfc3RhcnQgPSB0Ll9kbmRfc3RhcnRfbGIgPSAhMSwgdC5fbGlnaHRib3hfcm9vdC5jbGFzc05hbWUgPSB0Ll9saWdodGJveF9yb290LmNsYXNzTmFtZS5yZXBsYWNlKFwiIGdhbnR0X3Vuc2VsZWN0YWJsZVwiLCBcIlwiKSwgZG9jdW1lbnQuZ2FudHRfdW5zZWxlY3RhYmxlID0gITEpO1xuICB9LCB0Ll9mb2N1cyA9IGZ1bmN0aW9uKF8sIG0pIHtcbiAgICBpZiAoXyAmJiBfLmZvY3VzICYmICF0LmNvbmZpZy50b3VjaCkgdHJ5IHtcbiAgICAgIG0gJiYgXy5zZWxlY3QgJiYgXy5zZWxlY3QoKSwgXy5mb2N1cygpO1xuICAgIH0gY2F0Y2gge1xuICAgIH1cbiAgfSwgdC5mb3JtX2Jsb2NrcyA9IHsgZ2V0VGltZVBpY2tlcjogZnVuY3Rpb24oXywgbSkge1xuICAgIHZhciBmLCBrLCB4LCAkID0gXCJcIiwgdyA9IHRoaXMuY29uZmlnLCBTID0geyBmaXJzdDogMCwgbGFzdDogMTQ0MCwgZGF0ZTogdGhpcy5kYXRlLmRhdGVfcGFydChuZXcgRGF0ZSh0Ll9taW5fZGF0ZS52YWx1ZU9mKCkpKSwgdGltZUZvcm1hdDogdihfKSB9O1xuICAgIGZvciAoXy5fdGltZV9mb3JtYXRfb3JkZXIgPSB7IHNpemU6IDAgfSwgdC5jb25maWcubGltaXRfdGltZV9zZWxlY3QgJiYgKFMuZmlyc3QgPSA2MCAqIHcuZmlyc3RfaG91ciwgUy5sYXN0ID0gNjAgKiB3Lmxhc3RfaG91ciArIDEsIFMuZGF0ZS5zZXRIb3Vycyh3LmZpcnN0X2hvdXIpKSwgZiA9IDA7IGYgPCBTLnRpbWVGb3JtYXQubGVuZ3RoOyBmKyspIGYgPiAwICYmICgkICs9IFwiIFwiKSwgKGsgPSBiKF8sIGYsIFMpKSAmJiAoeCA9IHQuX3dhaUFyaWEubGlnaHRib3hTZWxlY3RBdHRyU3RyaW5nKFMudGltZUZvcm1hdFtmXSksICQgKz0gXCI8c2VsZWN0IFwiICsgKF8ucmVhZG9ubHkgPyBcImRpc2FibGVkPSdkaXNhYmxlZCdcIiA6IFwiXCIpICsgKG0gPyBcIiBzdHlsZT0nZGlzcGxheTpub25lJyBcIiA6IFwiXCIpICsgeCArIFwiPlwiICsgayArIFwiPC9zZWxlY3Q+XCIpO1xuICAgIHJldHVybiAkO1xuICB9LCBnZXRUaW1lUGlja2VyVmFsdWU6IGZ1bmN0aW9uKF8sIG0sIGYpIHtcbiAgICB2YXIgaywgeCA9IG0uX3RpbWVfZm9ybWF0X29yZGVyLCAkID0gMCwgdyA9IDAsIFMgPSBmIHx8IDA7XG4gICAgcmV0dXJuIHQuZGVmaW5lZCh4WzNdKSAmJiAoayA9IHBhcnNlSW50KF9beFszXSArIFNdLnZhbHVlLCAxMCksICQgPSBNYXRoLmZsb29yKGsgLyA2MCksIHcgPSBrICUgNjApLCBuZXcgRGF0ZShfW3hbMl0gKyBTXS52YWx1ZSwgX1t4WzFdICsgU10udmFsdWUsIF9beFswXSArIFNdLnZhbHVlLCAkLCB3KTtcbiAgfSwgX2ZpbGxfbGlnaHRib3hfc2VsZWN0OiBmdW5jdGlvbihfLCBtLCBmLCBrKSB7XG4gICAgaWYgKF9bbSArIGtbMF1dLnZhbHVlID0gZi5nZXREYXRlKCksIF9bbSArIGtbMV1dLnZhbHVlID0gZi5nZXRNb250aCgpLCBfW20gKyBrWzJdXS52YWx1ZSA9IGYuZ2V0RnVsbFllYXIoKSwgdC5kZWZpbmVkKGtbM10pKSB7XG4gICAgICB2YXIgeCA9IDYwICogZi5nZXRIb3VycygpICsgZi5nZXRNaW51dGVzKCk7XG4gICAgICB4ID0gTWF0aC5yb3VuZCh4IC8gdC5fZ2V0X3RpbWVwaWNrZXJfc3RlcCgpKSAqIHQuX2dldF90aW1lcGlja2VyX3N0ZXAoKTtcbiAgICAgIHZhciAkID0gX1ttICsga1szXV07XG4gICAgICAkLnZhbHVlID0geCwgJC5zZXRBdHRyaWJ1dGUoXCJkYXRhLXZhbHVlXCIsIHgpO1xuICAgIH1cbiAgfSwgdGVtcGxhdGU6IG5ldyBlKCksIHRleHRhcmVhOiBuZXcgbigpLCBzZWxlY3Q6IG5ldyBhKCksIHRpbWU6IG5ldyBpKCksIGR1cmF0aW9uOiBuZXcgbygpLCBwYXJlbnQ6IG5ldyBsKCksIHJhZGlvOiBuZXcgcygpLCBjaGVja2JveDogbmV3IHIoKSwgcmVzb3VyY2VzOiBuZXcgZCgpLCBjb25zdHJhaW50OiBuZXcgYygpLCBiYXNlbGluZXM6IG5ldyBoKCksIHR5cGVzZWxlY3Q6IG5ldyB1KCkgfSwgdC5faXNfbGlnaHRib3hfdGltZXBpY2tlciA9IGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIF8gPSB0aGlzLl9nZXRfdHlwZWRfbGlnaHRib3hfY29uZmlnKCksIG0gPSAwOyBtIDwgXy5sZW5ndGg7IG0rKykgaWYgKF9bbV0ubmFtZSA9PSBcInRpbWVcIiAmJiBfW21dLnR5cGUgPT0gXCJ0aW1lXCIpIHJldHVybiAhMDtcbiAgICByZXR1cm4gITE7XG4gIH0sIHQuX2RlbGV0ZV90YXNrX2NvbmZpcm0gPSBmdW5jdGlvbih7IHRhc2s6IF8sIG1lc3NhZ2U6IG0sIHRpdGxlOiBmLCBjYWxsYmFjazogaywgb2s6IHggfSkge1xuICAgIHQuX3NpbXBsZV9jb25maXJtKG0sIGYsIGssIHgpO1xuICB9LCB0Ll9kZWxldGVfbGlua19jb25maXJtID0gZnVuY3Rpb24oeyBsaW5rOiBfLCBtZXNzYWdlOiBtLCB0aXRsZTogZiwgY2FsbGJhY2s6IGssIG9rOiB4IH0pIHtcbiAgICB0Ll9zaW1wbGVfY29uZmlybShtLCBmLCBrLCB4KTtcbiAgfSwgdC5fc2ltcGxlX2NvbmZpcm0gPSBmdW5jdGlvbihfLCBtLCBmLCBrKSB7XG4gICAgaWYgKCFfKSByZXR1cm4gZigpO1xuICAgIHZhciB4ID0geyB0ZXh0OiBfIH07XG4gICAgbSAmJiAoeC50aXRsZSA9IG0pLCBrICYmICh4Lm9rID0gayksIGYgJiYgKHguY2FsbGJhY2sgPSBmdW5jdGlvbigkKSB7XG4gICAgICAkICYmIGYoKTtcbiAgICB9KSwgdC5jb25maXJtKHgpO1xuICB9LCB0Ll9nZXRfdHlwZWRfbGlnaHRib3hfY29uZmlnID0gZnVuY3Rpb24oXykge1xuICAgIF8gPT09IHZvaWQgMCAmJiAoXyA9IHRoaXMuZ2V0TGlnaHRib3hUeXBlKCkpO1xuICAgIHZhciBtID0gcC5jYWxsKHRoaXMsIF8pO1xuICAgIHJldHVybiB0LmNvbmZpZy5saWdodGJveFttICsgXCJfc2VjdGlvbnNcIl0gPyB0LmNvbmZpZy5saWdodGJveFttICsgXCJfc2VjdGlvbnNcIl0gOiB0LmNvbmZpZy5saWdodGJveC5zZWN0aW9ucztcbiAgfSwgdC5fc2lsZW50X3JlZHJhd19saWdodGJveCA9IGZ1bmN0aW9uKF8pIHtcbiAgICB2YXIgbSA9IHRoaXMuZ2V0TGlnaHRib3hUeXBlKCk7XG4gICAgaWYgKHRoaXMuZ2V0U3RhdGUoKS5saWdodGJveCkge1xuICAgICAgdmFyIGYgPSB0aGlzLmdldFN0YXRlKCkubGlnaHRib3gsIGsgPSB0aGlzLmdldExpZ2h0Ym94VmFsdWVzKCksIHggPSB0aGlzLmNvcHkodGhpcy5nZXRUYXNrKGYpKTtcbiAgICAgIHRoaXMucmVzZXRMaWdodGJveCgpO1xuICAgICAgdmFyICQgPSB0aGlzLm1peGluKHgsIGssICEwKSwgdyA9IHRoaXMuZ2V0TGlnaHRib3goXyB8fCB2b2lkIDApO1xuICAgICAgdGhpcy5fc2V0X2xpZ2h0Ym94X3ZhbHVlcygkLCB3KSwgdGhpcy5zaG93Q292ZXIodyk7XG4gICAgfSBlbHNlIHRoaXMucmVzZXRMaWdodGJveCgpLCB0aGlzLmdldExpZ2h0Ym94KF8gfHwgdm9pZCAwKTtcbiAgICB0aGlzLmNhbGxFdmVudChcIm9uTGlnaHRib3hDaGFuZ2VcIiwgW20sIHRoaXMuZ2V0TGlnaHRib3hUeXBlKCldKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIEthKHQpIHtcbiAgaWYgKCFtdC5pc05vZGUpIHtcbiAgICB0LnV0aWxzID0geyBhcnJheUZpbmQ6IExuLCBkb206IHJuIH07XG4gICAgdmFyIGUgPSBTZSgpO1xuICAgIHQuZXZlbnQgPSBlLmF0dGFjaCwgdC5ldmVudFJlbW92ZSA9IGUuZGV0YWNoLCB0Ll9ldmVudFJlbW92ZUFsbCA9IGUuZGV0YWNoQWxsLCB0Ll9jcmVhdGVEb21FdmVudFNjb3BlID0gZS5leHRlbmQsIFAodCwgc2EodCkpO1xuICAgIHZhciBuID0gamEuaW5pdCh0KTtcbiAgICB0LiR1aSA9IG4uZmFjdG9yeSwgdC4kdWkubGF5ZXJzID0gbi5yZW5kZXIsIHQuJG1vdXNlRXZlbnRzID0gbi5tb3VzZUV2ZW50cywgdC4kc2VydmljZXMuc2V0U2VydmljZShcIm1vdXNlRXZlbnRzXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHQuJG1vdXNlRXZlbnRzO1xuICAgIH0pLCB0Lm1peGluKHQsIG4ubGF5ZXJzQXBpKSwgZnVuY3Rpb24oaSkge1xuICAgICAgZGVsZXRlIGkuYWRkVGFza0xheWVyLCBkZWxldGUgaS5hZGRMaW5rTGF5ZXI7XG4gICAgfSh0KSwgdC4kc2VydmljZXMuc2V0U2VydmljZShcImxheWVyc1wiLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuLmxheWVyc1NlcnZpY2U7XG4gICAgfSksIHQubWl4aW4odCwgLyogQF9fUFVSRV9fICovIGZ1bmN0aW9uKCkge1xuICAgICAgZnVuY3Rpb24gaSh1KSB7XG4gICAgICAgIHJldHVybiB1LiR1aS5nZXRWaWV3KFwidGltZWxpbmVcIik7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBhKHUpIHtcbiAgICAgICAgcmV0dXJuIHUuJHVpLmdldFZpZXcoXCJncmlkXCIpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcih1KSB7XG4gICAgICAgIHZhciBoID0gaSh1KTtcbiAgICAgICAgaWYgKGggJiYgIWguJGNvbmZpZy5oaWRkZW4pIHJldHVybiBoO1xuICAgICAgICB2YXIgZyA9IGEodSk7XG4gICAgICAgIHJldHVybiBnICYmICFnLiRjb25maWcuaGlkZGVuID8gZyA6IG51bGw7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBzKHUpIHtcbiAgICAgICAgdmFyIGggPSBudWxsLCBnID0gITE7XG4gICAgICAgIHJldHVybiBbXCIuZ2FudHRfZHJhZ19tYXJrZXIuZ2FudHRfZ3JpZF9yZXNpemVfYXJlYVwiLCBcIi5nYW50dF9kcmFnX21hcmtlciAuZ2FudHRfcm93LmdhbnR0X3Jvd190YXNrXCIsIFwiLmdhbnR0X2RyYWdfbWFya2VyLmdhbnR0X2dyaWRfZG5kX21hcmtlclwiXS5mb3JFYWNoKGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICBnID0gZyB8fCAhIWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IocCk7XG4gICAgICAgIH0pLCAoaCA9IGcgPyBhKHUpIDogcih1KSkgPyBsKHUsIGgsIFwic2Nyb2xsWVwiKSA6IG51bGw7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBvKHUpIHtcbiAgICAgICAgdmFyIGggPSByKHUpO1xuICAgICAgICByZXR1cm4gaCAmJiBoLmlkICE9IFwiZ3JpZFwiID8gbCh1LCBoLCBcInNjcm9sbFhcIikgOiBudWxsO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gbCh1LCBoLCBnKSB7XG4gICAgICAgIHZhciBwID0gaC4kY29uZmlnW2ddO1xuICAgICAgICByZXR1cm4gdS4kdWkuZ2V0VmlldyhwKTtcbiAgICAgIH1cbiAgICAgIHZhciBkID0gXCJERUZBVUxUX1ZBTFVFXCI7XG4gICAgICBmdW5jdGlvbiBjKHUsIGgsIGcsIHApIHtcbiAgICAgICAgdmFyIHkgPSB1KHRoaXMpO1xuICAgICAgICByZXR1cm4geSAmJiB5LmlzVmlzaWJsZSgpID8geVtoXS5hcHBseSh5LCBnKSA6IHAgPyBwKCkgOiBkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgZ2V0Q29sdW1uSW5kZXg6IGZ1bmN0aW9uKHUpIHtcbiAgICAgICAgdmFyIGggPSBjLmNhbGwodGhpcywgYSwgXCJnZXRDb2x1bW5JbmRleFwiLCBbdV0pO1xuICAgICAgICByZXR1cm4gaCA9PT0gZCA/IDAgOiBoO1xuICAgICAgfSwgZGF0ZUZyb21Qb3M6IGZ1bmN0aW9uKHUpIHtcbiAgICAgICAgdmFyIGggPSBjLmNhbGwodGhpcywgaSwgXCJkYXRlRnJvbVBvc1wiLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICAgICAgcmV0dXJuIGggPT09IGQgPyB0aGlzLmdldFN0YXRlKCkubWluX2RhdGUgOiBoO1xuICAgICAgfSwgcG9zRnJvbURhdGU6IGZ1bmN0aW9uKHUpIHtcbiAgICAgICAgdmFyIGggPSBjLmNhbGwodGhpcywgaSwgXCJwb3NGcm9tRGF0ZVwiLCBbdV0pO1xuICAgICAgICByZXR1cm4gaCA9PT0gZCA/IDAgOiBoO1xuICAgICAgfSwgZ2V0Um93VG9wOiBmdW5jdGlvbih1KSB7XG4gICAgICAgIHZhciBoID0gdGhpcywgZyA9IGMuY2FsbChoLCBpLCBcImdldFJvd1RvcFwiLCBbdV0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBjLmNhbGwoaCwgYSwgXCJnZXRSb3dUb3BcIiwgW3VdKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBnID09PSBkID8gMCA6IGc7XG4gICAgICB9LCBnZXRUYXNrVG9wOiBmdW5jdGlvbih1KSB7XG4gICAgICAgIHZhciBoID0gdGhpcywgZyA9IGMuY2FsbChoLCBpLCBcImdldEl0ZW1Ub3BcIiwgW3VdLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gYy5jYWxsKGgsIGEsIFwiZ2V0SXRlbVRvcFwiLCBbdV0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGcgPT09IGQgPyAwIDogZztcbiAgICAgIH0sIGdldFRhc2tQb3NpdGlvbjogZnVuY3Rpb24odSwgaCwgZykge1xuICAgICAgICB2YXIgcCA9IGMuY2FsbCh0aGlzLCBpLCBcImdldEl0ZW1Qb3NpdGlvblwiLCBbdSwgaCwgZ10pO1xuICAgICAgICByZXR1cm4gcCA9PT0gZCA/IHsgbGVmdDogMCwgdG9wOiB0aGlzLmdldFRhc2tUb3AodS5pZCksIGhlaWdodDogdGhpcy5nZXRUYXNrQmFySGVpZ2h0KHUuaWQpLCB3aWR0aDogMCB9IDogcDtcbiAgICAgIH0sIGdldFRhc2tCYXJIZWlnaHQ6IGZ1bmN0aW9uKHUsIGgpIHtcbiAgICAgICAgdmFyIGcgPSB0aGlzLCBwID0gYy5jYWxsKGcsIGksIFwiZ2V0QmFySGVpZ2h0XCIsIFt1LCBoXSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIGMuY2FsbChnLCBhLCBcImdldEl0ZW1IZWlnaHRcIiwgW3VdKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwID09PSBkID8gMCA6IHA7XG4gICAgICB9LCBnZXRUYXNrSGVpZ2h0OiBmdW5jdGlvbih1KSB7XG4gICAgICAgIHZhciBoID0gdGhpcywgZyA9IGMuY2FsbChoLCBpLCBcImdldEl0ZW1IZWlnaHRcIiwgW3VdLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gYy5jYWxsKGgsIGEsIFwiZ2V0SXRlbUhlaWdodFwiLCBbdV0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGcgPT09IGQgPyAwIDogZztcbiAgICAgIH0sIGNvbHVtbkluZGV4QnlEYXRlOiBmdW5jdGlvbih1KSB7XG4gICAgICAgIHZhciBoID0gYy5jYWxsKHRoaXMsIGksIFwiY29sdW1uSW5kZXhCeURhdGVcIiwgW3VdKTtcbiAgICAgICAgcmV0dXJuIGggPT09IGQgPyAwIDogaDtcbiAgICAgIH0sIHJvdW5kVGFza0RhdGVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgYy5jYWxsKHRoaXMsIGksIFwicm91bmRUYXNrRGF0ZXNcIiwgW10pO1xuICAgICAgfSwgZ2V0U2NhbGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdSA9IGMuY2FsbCh0aGlzLCBpLCBcImdldFNjYWxlXCIsIFtdKTtcbiAgICAgICAgcmV0dXJuIHUgPT09IGQgPyBudWxsIDogdTtcbiAgICAgIH0sIGdldFRhc2tOb2RlOiBmdW5jdGlvbih1KSB7XG4gICAgICAgIHZhciBoID0gaSh0aGlzKTtcbiAgICAgICAgaWYgKGggJiYgaC5pc1Zpc2libGUoKSkge1xuICAgICAgICAgIHZhciBnID0gaC5fdGFza1JlbmRlcmVyLnJlbmRlcmVkW3VdO1xuICAgICAgICAgIGlmICghZykge1xuICAgICAgICAgICAgdmFyIHAgPSBoLiRjb25maWcuaXRlbV9hdHRyaWJ1dGU7XG4gICAgICAgICAgICBnID0gaC4kdGFza19iYXJzLnF1ZXJ5U2VsZWN0b3IoXCJbXCIgKyBwICsgXCI9J1wiICsgdSArIFwiJ11cIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBnIHx8IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9LCBnZXRMaW5rTm9kZTogZnVuY3Rpb24odSkge1xuICAgICAgICB2YXIgaCA9IGkodGhpcyk7XG4gICAgICAgIHJldHVybiBoLmlzVmlzaWJsZSgpID8gaC5fbGlua1JlbmRlcmVyLnJlbmRlcmVkW3VdIDogbnVsbDtcbiAgICAgIH0sIHNjcm9sbFRvOiBmdW5jdGlvbih1LCBoKSB7XG4gICAgICAgIHZhciBnID0gcyh0aGlzKSwgcCA9IG8odGhpcyksIHkgPSB7IHBvc2l0aW9uOiAwIH0sIHYgPSB7IHBvc2l0aW9uOiAwIH07XG4gICAgICAgIGcgJiYgKHYgPSBnLmdldFNjcm9sbFN0YXRlKCkpLCBwICYmICh5ID0gcC5nZXRTY3JvbGxTdGF0ZSgpKTtcbiAgICAgICAgdmFyIGIgPSBwICYmIDEgKiB1ID09IHUsIF8gPSBnICYmIDEgKiBoID09IGg7XG4gICAgICAgIGlmIChiICYmIF8pIGZvciAodmFyIG0gPSBnLl9nZXRMaW5rZWRWaWV3cygpLCBmID0gcC5fZ2V0TGlua2VkVmlld3MoKSwgayA9IFtdLCB4ID0gMDsgeCA8IG0ubGVuZ3RoOyB4KyspIGZvciAodmFyICQgPSAwOyAkIDwgZi5sZW5ndGg7ICQrKykgbVt4XS4kY29uZmlnLmlkICYmIGZbJF0uJGNvbmZpZy5pZCAmJiBtW3hdLiRjb25maWcuaWQgPT09IGZbJF0uJGNvbmZpZy5pZCAmJiBrLnB1c2gobVt4XS4kY29uZmlnLmlkKTtcbiAgICAgICAgYiAmJiAoayAmJiBrLmZvckVhY2goKGZ1bmN0aW9uKFQpIHtcbiAgICAgICAgICB0aGlzLiR1aS5nZXRWaWV3KFQpLiRjb25maWcuJHNraXBTbWFydFJlbmRlck9uU2Nyb2xsID0gITA7XG4gICAgICAgIH0pLmJpbmQodGhpcykpLCBwLnNjcm9sbCh1KSwgayAmJiBrLmZvckVhY2goKGZ1bmN0aW9uKFQpIHtcbiAgICAgICAgICB0aGlzLiR1aS5nZXRWaWV3KFQpLiRjb25maWcuJHNraXBTbWFydFJlbmRlck9uU2Nyb2xsID0gITE7XG4gICAgICAgIH0pLmJpbmQodGhpcykpKSwgXyAmJiBnLnNjcm9sbChoKTtcbiAgICAgICAgdmFyIHcgPSB7IHBvc2l0aW9uOiAwIH0sIFMgPSB7IHBvc2l0aW9uOiAwIH07XG4gICAgICAgIGcgJiYgKHcgPSBnLmdldFNjcm9sbFN0YXRlKCkpLCBwICYmIChTID0gcC5nZXRTY3JvbGxTdGF0ZSgpKSwgdGhpcy5jYWxsRXZlbnQoXCJvbkdhbnR0U2Nyb2xsXCIsIFt5LnBvc2l0aW9uLCB2LnBvc2l0aW9uLCBTLnBvc2l0aW9uLCB3LnBvc2l0aW9uXSk7XG4gICAgICB9LCBzaG93RGF0ZTogZnVuY3Rpb24odSkge1xuICAgICAgICB2YXIgaCA9IHRoaXMucG9zRnJvbURhdGUodSksIGcgPSBNYXRoLm1heChoIC0gdGhpcy5jb25maWcudGFza19zY3JvbGxfb2Zmc2V0LCAwKTtcbiAgICAgICAgdGhpcy5zY3JvbGxUbyhnKTtcbiAgICAgIH0sIHNob3dUYXNrOiBmdW5jdGlvbih1KSB7XG4gICAgICAgIHZhciBoID0gdGhpcy5nZXRUYXNrUG9zaXRpb24odGhpcy5nZXRUYXNrKHUpKSwgZyA9IGgubGVmdDtcbiAgICAgICAgdGhpcy5jb25maWcucnRsICYmIChnID0gaC5sZWZ0ICsgaC53aWR0aCk7XG4gICAgICAgIHZhciBwLCB5ID0gTWF0aC5tYXgoZyAtIHRoaXMuY29uZmlnLnRhc2tfc2Nyb2xsX29mZnNldCwgMCksIHYgPSB0aGlzLl9zY3JvbGxfc3RhdGUoKS55O1xuICAgICAgICBwID0gdiA/IGgudG9wIC0gKHYgLSB0aGlzLmdldFRhc2tCYXJIZWlnaHQodSkpIC8gMiA6IGgudG9wLCB0aGlzLnNjcm9sbFRvKHksIHApO1xuICAgICAgICB2YXIgYiA9IGEodGhpcyksIF8gPSBpKHRoaXMpO1xuICAgICAgICBiICYmIF8gJiYgYi4kY29uZmlnLnNjcm9sbFkgIT0gXy4kY29uZmlnLnNjcm9sbFkgJiYgbCh0aGlzLCBiLCBcInNjcm9sbFlcIikuc2Nyb2xsVG8obnVsbCwgcCk7XG4gICAgICB9LCBfc2Nyb2xsX3N0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHUgPSB7IHg6ICExLCB5OiAhMSwgeF9wb3M6IDAsIHlfcG9zOiAwLCBzY3JvbGxfc2l6ZTogdGhpcy5jb25maWcuc2Nyb2xsX3NpemUgKyAxLCB4X2lubmVyOiAwLCB5X2lubmVyOiAwIH0sIGggPSBzKHRoaXMpLCBnID0gbyh0aGlzKTtcbiAgICAgICAgaWYgKGcpIHtcbiAgICAgICAgICB2YXIgcCA9IGcuZ2V0U2Nyb2xsU3RhdGUoKTtcbiAgICAgICAgICBwLnZpc2libGUgJiYgKHUueCA9IHAuc2l6ZSwgdS54X2lubmVyID0gcC5zY3JvbGxTaXplKSwgdS54X3BvcyA9IHAucG9zaXRpb24gfHwgMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaCkge1xuICAgICAgICAgIHZhciB5ID0gaC5nZXRTY3JvbGxTdGF0ZSgpO1xuICAgICAgICAgIHkudmlzaWJsZSAmJiAodS55ID0geS5zaXplLCB1LnlfaW5uZXIgPSB5LnNjcm9sbFNpemUpLCB1LnlfcG9zID0geS5wb3NpdGlvbiB8fCAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1O1xuICAgICAgfSwgZ2V0U2Nyb2xsU3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdSA9IHRoaXMuX3Njcm9sbF9zdGF0ZSgpO1xuICAgICAgICByZXR1cm4geyB4OiB1LnhfcG9zLCB5OiB1LnlfcG9zLCBpbm5lcl93aWR0aDogdS54LCBpbm5lcl9oZWlnaHQ6IHUueSwgd2lkdGg6IHUueF9pbm5lciwgaGVpZ2h0OiB1LnlfaW5uZXIgfTtcbiAgICAgIH0sIGdldExheW91dFZpZXc6IGZ1bmN0aW9uKHUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHVpLmdldFZpZXcodSk7XG4gICAgICB9LCBzY3JvbGxMYXlvdXRDZWxsOiBmdW5jdGlvbih1LCBoLCBnKSB7XG4gICAgICAgIGNvbnN0IHAgPSB0aGlzLiR1aS5nZXRWaWV3KHUpO1xuICAgICAgICBpZiAoIXApIHJldHVybiAhMTtcbiAgICAgICAgaWYgKGggIT09IG51bGwpIHtcbiAgICAgICAgICBjb25zdCB5ID0gdGhpcy4kdWkuZ2V0VmlldyhwLiRjb25maWcuc2Nyb2xsWCk7XG4gICAgICAgICAgeSAmJiB5LnNjcm9sbFRvKGgsIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChnICE9PSBudWxsKSB7XG4gICAgICAgICAgY29uc3QgeSA9IHRoaXMuJHVpLmdldFZpZXcocC4kY29uZmlnLnNjcm9sbFkpO1xuICAgICAgICAgIHkgJiYgeS5zY3JvbGxUbyhudWxsLCBnKTtcbiAgICAgICAgfVxuICAgICAgfSB9O1xuICAgIH0oKSksIGZ1bmN0aW9uKGkpIHtcbiAgICAgIGkucmVzZXRTa2luIHx8IChpLnJlc2V0U2tpbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnNraW4gPSBcIlwiLCBjZSghMCwgdGhpcyk7XG4gICAgICB9LCBpLnNraW5zID0ge30sIGkuYXR0YWNoRXZlbnQoXCJvbkdhbnR0TGF5b3V0UmVhZHlcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGNlKCExLCB0aGlzKSwgcigpO1xuICAgICAgfSkpLCBpLl9hZGRUaGVtZUNsYXNzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJkYXRhLWdhbnR0LXRoZW1lXCIsIGkuc2tpbik7XG4gICAgICB9LCBpLnNldFNraW4gPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIGNvbnN0IG8gPSB0aGlzLnNraW4gIT09IHM7XG4gICAgICAgIHRoaXMuc2tpbiA9IHMsIGkuX2FkZFRoZW1lQ2xhc3MoKSwgcigpLCBpLiRyb290ICYmIChjZSghbywgaSksIHRoaXMucmVuZGVyKCkpO1xuICAgICAgfTtcbiAgICAgIGxldCBhID0gbnVsbDtcbiAgICAgIGZ1bmN0aW9uIHIoKSB7XG4gICAgICAgIGNvbnN0IHMgPSBpLiRyb290O1xuICAgICAgICBhICYmIGNsZWFySW50ZXJ2YWwoYSksIHMgJiYgKGEgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgY29uc3QgbyA9IGdldENvbXB1dGVkU3R5bGUocykuZ2V0UHJvcGVydHlWYWx1ZShcIi0tZGh4LWdhbnR0LXRoZW1lXCIpO1xuICAgICAgICAgIG8gJiYgbyAhPT0gaS5za2luICYmIGkuc2V0U2tpbihvKTtcbiAgICAgICAgfSwgMTAwKSk7XG4gICAgICB9XG4gICAgICBpLmF0dGFjaEV2ZW50KFwib25EZXN0cm95XCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICBjbGVhckludGVydmFsKGEpO1xuICAgICAgfSk7XG4gICAgfSh0KSwgZnVuY3Rpb24oaSkge1xuICAgICAgaS5za2lucy5za3libHVlID0geyBjb25maWc6IHsgZ3JpZF93aWR0aDogMzcwLCByb3dfaGVpZ2h0OiAyNywgYmFyX2hlaWdodF9wYWRkaW5nOiA0LCBzY2FsZV9oZWlnaHQ6IDI3LCBsaW5rX2xpbmVfd2lkdGg6IDEsIGxpbmtfYXJyb3dfc2l6ZTogOCwgbGlua19yYWRpdXM6IDIsIGxpZ2h0Ym94X2FkZGl0aW9uYWxfaGVpZ2h0OiA3NSB9LCBfc2Vjb25kX2NvbHVtbl93aWR0aDogOTUsIF90aGlyZF9jb2x1bW5fd2lkdGg6IDgwIH07XG4gICAgfSh0KSwgZnVuY3Rpb24oaSkge1xuICAgICAgaS5za2lucy5kYXJrID0geyBjb25maWc6IHsgZ3JpZF93aWR0aDogMzkwLCByb3dfaGVpZ2h0OiAzNiwgc2NhbGVfaGVpZ2h0OiAzNiwgbGlua19saW5lX3dpZHRoOiAyLCBsaW5rX2Fycm93X3NpemU6IDEyLCBiYXJfaGVpZ2h0X3BhZGRpbmc6IDksIGxpZ2h0Ym94X2FkZGl0aW9uYWxfaGVpZ2h0OiA3NSB9LCBfc2Vjb25kX2NvbHVtbl93aWR0aDogMTAwLCBfdGhpcmRfY29sdW1uX3dpZHRoOiA3MCB9O1xuICAgIH0odCksIGZ1bmN0aW9uKGkpIHtcbiAgICAgIGkuc2tpbnMubWVhZG93ID0geyBjb25maWc6IHsgZ3JpZF93aWR0aDogMzgwLCByb3dfaGVpZ2h0OiAyNywgc2NhbGVfaGVpZ2h0OiAzMCwgbGlua19saW5lX3dpZHRoOiAyLCBsaW5rX2Fycm93X3NpemU6IDEwLCBiYXJfaGVpZ2h0X3BhZGRpbmc6IDQsIGxpZ2h0Ym94X2FkZGl0aW9uYWxfaGVpZ2h0OiA3MiB9LCBfc2Vjb25kX2NvbHVtbl93aWR0aDogOTUsIF90aGlyZF9jb2x1bW5fd2lkdGg6IDgwIH07XG4gICAgfSh0KSwgZnVuY3Rpb24oaSkge1xuICAgICAgaS5za2lucy50ZXJyYWNlID0geyBjb25maWc6IHsgZ3JpZF93aWR0aDogMzkwLCByb3dfaGVpZ2h0OiAzNiwgc2NhbGVfaGVpZ2h0OiAzNiwgbGlua19saW5lX3dpZHRoOiAyLCBsaW5rX2Fycm93X3NpemU6IDEyLCBiYXJfaGVpZ2h0X3BhZGRpbmc6IDksIGxpZ2h0Ym94X2FkZGl0aW9uYWxfaGVpZ2h0OiA3NSB9LCBfc2Vjb25kX2NvbHVtbl93aWR0aDogMTAwLCBfdGhpcmRfY29sdW1uX3dpZHRoOiA3MCB9O1xuICAgIH0odCksIGZ1bmN0aW9uKGkpIHtcbiAgICAgIGkuc2tpbnMuYnJvYWR3YXkgPSB7IGNvbmZpZzogeyBncmlkX3dpZHRoOiAzOTAsIHJvd19oZWlnaHQ6IDM1LCBzY2FsZV9oZWlnaHQ6IDM1LCBsaW5rX2xpbmVfd2lkdGg6IDEsIGxpbmtfYXJyb3dfc2l6ZTogOSwgYmFyX2hlaWdodF9wYWRkaW5nOiA0LCBsaWdodGJveF9hZGRpdGlvbmFsX2hlaWdodDogODYgfSwgX3NlY29uZF9jb2x1bW5fd2lkdGg6IDEwMCwgX3RoaXJkX2NvbHVtbl93aWR0aDogODAsIF9saWdodGJveF90ZW1wbGF0ZTogXCI8ZGl2IGNsYXNzPSdnYW50dF9jYWxfbHRpdGxlJz48c3BhbiBjbGFzcz0nZ2FudHRfbWFyayc+Jm5ic3A7PC9zcGFuPjxzcGFuIGNsYXNzPSdnYW50dF90aW1lJz48L3NwYW4+PHNwYW4gY2xhc3M9J2dhbnR0X3RpdGxlJz48L3NwYW4+PGRpdiBjbGFzcz0nZ2FudHRfY2FuY2VsX2J0bic+PC9kaXY+PC9kaXY+PGRpdiBjbGFzcz0nZ2FudHRfY2FsX2xhcmVhJz48L2Rpdj5cIiwgX2NvbmZpZ19idXR0b25zX2xlZnQ6IHt9LCBfY29uZmlnX2J1dHRvbnNfcmlnaHQ6IHsgZ2FudHRfZGVsZXRlX2J0bjogXCJpY29uX2RlbGV0ZVwiLCBnYW50dF9zYXZlX2J0bjogXCJpY29uX3NhdmVcIiB9IH07XG4gICAgfSh0KSwgZnVuY3Rpb24oaSkge1xuICAgICAgaS5za2lucy5tYXRlcmlhbCA9IHsgY29uZmlnOiB7IGdyaWRfd2lkdGg6IDQxMSwgcm93X2hlaWdodDogMzQsIHNjYWxlX2hlaWdodDogMzYsIGxpbmtfbGluZV93aWR0aDogMiwgbGlua19hcnJvd19zaXplOiAxMiwgYmFyX2hlaWdodF9wYWRkaW5nOiA5LCBsaWdodGJveF9hZGRpdGlvbmFsX2hlaWdodDogODAgfSwgX3NlY29uZF9jb2x1bW5fd2lkdGg6IDExMCwgX3RoaXJkX2NvbHVtbl93aWR0aDogNzUsIF9yZWRlZmluZV9saWdodGJveF9idXR0b25zOiB7IGJ1dHRvbnNfbGVmdDogW1wiZGh4X2RlbGV0ZV9idG5cIl0sIGJ1dHRvbnNfcmlnaHQ6IFtcImRoeF9jYW5jZWxfYnRuXCIsIFwiZGh4X3NhdmVfYnRuXCJdIH0gfSwgaS5hdHRhY2hFdmVudChcIm9uQWZ0ZXJUYXNrRHJhZ1wiLCBmdW5jdGlvbihhKSB7XG4gICAgICAgIHZhciByID0gaS5nZXRUYXNrTm9kZShhKTtcbiAgICAgICAgciAmJiAoci5jbGFzc05hbWUgKz0gXCIgZ2FudHRfZHJhZ19hbmltYXRpb25cIiwgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgcyA9IHIuY2xhc3NOYW1lLmluZGV4T2YoXCIgZ2FudHRfZHJhZ19hbmltYXRpb25cIik7XG4gICAgICAgICAgcyA+IC0xICYmIChyLmNsYXNzTmFtZSA9IHIuY2xhc3NOYW1lLnNsaWNlKDAsIHMpKTtcbiAgICAgICAgfSwgMjAwKSk7XG4gICAgICB9KTtcbiAgICB9KHQpLCBmdW5jdGlvbihpKSB7XG4gICAgICBpLnNraW5zLmNvbnRyYXN0X2JsYWNrID0geyBjb25maWc6IHsgZ3JpZF93aWR0aDogMzkwLCByb3dfaGVpZ2h0OiAzNSwgc2NhbGVfaGVpZ2h0OiAzNSwgbGlua19saW5lX3dpZHRoOiAyLCBsaW5rX2Fycm93X3NpemU6IDEyLCBsaWdodGJveF9hZGRpdGlvbmFsX2hlaWdodDogNzUgfSwgX3NlY29uZF9jb2x1bW5fd2lkdGg6IDEwMCwgX3RoaXJkX2NvbHVtbl93aWR0aDogODAgfTtcbiAgICB9KHQpLCBmdW5jdGlvbihpKSB7XG4gICAgICBpLnNraW5zLmNvbnRyYXN0X3doaXRlID0geyBjb25maWc6IHsgZ3JpZF93aWR0aDogMzkwLCByb3dfaGVpZ2h0OiAzNSwgc2NhbGVfaGVpZ2h0OiAzNSwgbGlua19saW5lX3dpZHRoOiAyLCBsaW5rX2Fycm93X3NpemU6IDEyLCBsaWdodGJveF9hZGRpdGlvbmFsX2hlaWdodDogNzUgfSwgX3NlY29uZF9jb2x1bW5fd2lkdGg6IDEwMCwgX3RoaXJkX2NvbHVtbl93aWR0aDogODAgfTtcbiAgICB9KHQpLCBmdW5jdGlvbihpKSB7XG4gICAgICBpLmV4dCB8fCAoaS5leHQgPSB7fSk7XG4gICAgICBmb3IgKHZhciBhID0gW0ZhLCBudWxsLCBudWxsXSwgciA9IDA7IHIgPCBhLmxlbmd0aDsgcisrKSBhW3JdICYmIGFbcl0oaSk7XG4gICAgICBpLmV4dC56b29tID0gbmV3IHFhKGkpO1xuICAgIH0odCksIEdhKHQpLCBKYSh0KSwgZnVuY3Rpb24oaSkge1xuICAgICAgaS5fZXh0ZW5kX3RvX29wdGlvbmFsID0gZnVuY3Rpb24oYSkge1xuICAgICAgICB2YXIgciA9IGEsIHMgPSB7IHJlbmRlcjogci5yZW5kZXIsIGZvY3VzOiByLmZvY3VzLCBzZXRfdmFsdWU6IGZ1bmN0aW9uKG8sIGwsIGQsIGMpIHtcbiAgICAgICAgICB2YXIgdSA9IGkuX3Jlc29sdmVfZGVmYXVsdF9tYXBwaW5nKGMpO1xuICAgICAgICAgIGlmICghZFt1LnN0YXJ0X2RhdGVdIHx8IHUuc3RhcnRfZGF0ZSA9PSBcInN0YXJ0X2RhdGVcIiAmJiB0aGlzLl9pc0FsbG93ZWRVbnNjaGVkdWxlZFRhc2soZCkpIHtcbiAgICAgICAgICAgIHMuZGlzYWJsZShvLCBjKTtcbiAgICAgICAgICAgIHZhciBoID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBnIGluIHUpIGhbdVtnXV0gPSBkW2ddO1xuICAgICAgICAgICAgcmV0dXJuIHIuc2V0X3ZhbHVlLmNhbGwoaSwgbywgbCwgaCwgYyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzLmVuYWJsZShvLCBjKSwgci5zZXRfdmFsdWUuY2FsbChpLCBvLCBsLCBkLCBjKTtcbiAgICAgICAgfSwgZ2V0X3ZhbHVlOiBmdW5jdGlvbihvLCBsLCBkKSB7XG4gICAgICAgICAgcmV0dXJuIGQuZGlzYWJsZWQgPyB7IHN0YXJ0X2RhdGU6IG51bGwgfSA6IHIuZ2V0X3ZhbHVlLmNhbGwoaSwgbywgbCwgZCk7XG4gICAgICAgIH0sIHVwZGF0ZV9ibG9jazogZnVuY3Rpb24obywgbCkge1xuICAgICAgICAgIGlmIChpLmNhbGxFdmVudChcIm9uU2VjdGlvblRvZ2dsZVwiLCBbaS5fbGlnaHRib3hfaWQsIGxdKSwgby5zdHlsZS5kaXNwbGF5ID0gbC5kaXNhYmxlZCA/IFwibm9uZVwiIDogXCJcIiwgbC5idXR0b24pIHtcbiAgICAgICAgICAgIHZhciBkID0gby5wcmV2aW91c1NpYmxpbmcucXVlcnlTZWxlY3RvcihcIi5nYW50dF9jdXN0b21fYnV0dG9uX2xhYmVsXCIpLCBjID0gaS5sb2NhbGUubGFiZWxzLCB1ID0gbC5kaXNhYmxlZCA/IGNbbC5uYW1lICsgXCJfZW5hYmxlX2J1dHRvblwiXSA6IGNbbC5uYW1lICsgXCJfZGlzYWJsZV9idXR0b25cIl07XG4gICAgICAgICAgICBkLmlubmVySFRNTCA9IHU7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBkaXNhYmxlOiBmdW5jdGlvbihvLCBsKSB7XG4gICAgICAgICAgbC5kaXNhYmxlZCA9ICEwLCBzLnVwZGF0ZV9ibG9jayhvLCBsKTtcbiAgICAgICAgfSwgZW5hYmxlOiBmdW5jdGlvbihvLCBsKSB7XG4gICAgICAgICAgbC5kaXNhYmxlZCA9ICExLCBzLnVwZGF0ZV9ibG9jayhvLCBsKTtcbiAgICAgICAgfSwgYnV0dG9uX2NsaWNrOiBmdW5jdGlvbihvLCBsLCBkLCBjKSB7XG4gICAgICAgICAgaWYgKGkuY2FsbEV2ZW50KFwib25TZWN0aW9uQnV0dG9uXCIsIFtpLl9saWdodGJveF9pZCwgZF0pICE9PSAhMSkge1xuICAgICAgICAgICAgdmFyIHUgPSBpLl9nZXRfdHlwZWRfbGlnaHRib3hfY29uZmlnKClbb107XG4gICAgICAgICAgICB1LmRpc2FibGVkID8gcy5lbmFibGUoYywgdSkgOiBzLmRpc2FibGUoYywgdSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IH07XG4gICAgICAgIHJldHVybiBzO1xuICAgICAgfSwgaS5mb3JtX2Jsb2Nrcy5kdXJhdGlvbl9vcHRpb25hbCA9IGkuX2V4dGVuZF90b19vcHRpb25hbChpLmZvcm1fYmxvY2tzLmR1cmF0aW9uKSwgaS5mb3JtX2Jsb2Nrcy50aW1lX29wdGlvbmFsID0gaS5fZXh0ZW5kX3RvX29wdGlvbmFsKGkuZm9ybV9ibG9ja3MudGltZSk7XG4gICAgfSh0KSwgZnVuY3Rpb24oaSkge1xuICAgICAgdmFyIGEgPSBuZXcgUmVnRXhwKGA8KD86LnxcbikqPz5gLCBcImdtXCIpLCByID0gbmV3IFJlZ0V4cChcIiArXCIsIFwiZ21cIik7XG4gICAgICBmdW5jdGlvbiBzKGMpIHtcbiAgICAgICAgcmV0dXJuIChjICsgXCJcIikucmVwbGFjZShhLCBcIiBcIikucmVwbGFjZShyLCBcIiBcIik7XG4gICAgICB9XG4gICAgICB2YXIgbyA9IG5ldyBSZWdFeHAoXCInXCIsIFwiZ21cIik7XG4gICAgICBmdW5jdGlvbiBsKGMpIHtcbiAgICAgICAgcmV0dXJuIChjICsgXCJcIikucmVwbGFjZShvLCBcIiYjMzk7XCIpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgZCBpbiBpLl93YWlBcmlhID0geyBnZXRBdHRyaWJ1dGVTdHJpbmc6IGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgdmFyIHUgPSBbXCIgXCJdO1xuICAgICAgICBmb3IgKHZhciBoIGluIGMpIHtcbiAgICAgICAgICB2YXIgZyA9IGwocyhjW2hdKSk7XG4gICAgICAgICAgdS5wdXNoKGggKyBcIj0nXCIgKyBnICsgXCInXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1LnB1c2goXCIgXCIpLCB1LmpvaW4oXCIgXCIpO1xuICAgICAgfSwgZ2V0VGltZWxpbmVDZWxsQXR0cjogZnVuY3Rpb24oYykge1xuICAgICAgICByZXR1cm4gaS5fd2FpQXJpYS5nZXRBdHRyaWJ1dGVTdHJpbmcoeyBcImFyaWEtbGFiZWxcIjogYyB9KTtcbiAgICAgIH0sIF90YXNrQ29tbW9uQXR0cjogZnVuY3Rpb24oYywgdSkge1xuICAgICAgICBjLnN0YXJ0X2RhdGUgJiYgYy5lbmRfZGF0ZSAmJiAodS5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIHMoaS50ZW1wbGF0ZXMudG9vbHRpcF90ZXh0KGMuc3RhcnRfZGF0ZSwgYy5lbmRfZGF0ZSwgYykpKSwgYy4kZGF0YXByb2Nlc3Nvcl9jbGFzcyAmJiB1LnNldEF0dHJpYnV0ZShcImFyaWEtYnVzeVwiLCAhMCkpO1xuICAgICAgfSwgc2V0VGFza0JhckF0dHI6IGZ1bmN0aW9uKGMsIHUpIHtcbiAgICAgICAgdGhpcy5fdGFza0NvbW1vbkF0dHIoYywgdSksIHUuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcImltZ1wiKSwgIWkuaXNSZWFkb25seShjKSAmJiBpLmNvbmZpZy5kcmFnX21vdmUgJiYgKGMuaWQgIT0gaS5nZXRTdGF0ZShcInRhc2tzRG5kXCIpLmRyYWdfaWQgPyB1LnNldEF0dHJpYnV0ZShcImFyaWEtZ3JhYmJlZFwiLCAhMSkgOiB1LnNldEF0dHJpYnV0ZShcImFyaWEtZ3JhYmJlZFwiLCAhMCkpO1xuICAgICAgfSwgdGFza1Jvd0F0dHI6IGZ1bmN0aW9uKGMsIHUpIHtcbiAgICAgICAgdGhpcy5fdGFza0NvbW1vbkF0dHIoYywgdSksICFpLmlzUmVhZG9ubHkoYykgJiYgaS5jb25maWcub3JkZXJfYnJhbmNoICYmIHUuc2V0QXR0cmlidXRlKFwiYXJpYS1ncmFiYmVkXCIsICExKSwgdS5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwicm93XCIpLCB1LnNldEF0dHJpYnV0ZShcImFyaWEtc2VsZWN0ZWRcIiwgaS5pc1NlbGVjdGVkVGFzayhjLmlkKSA/IFwidHJ1ZVwiIDogXCJmYWxzZVwiKSwgdS5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxldmVsXCIsIGMuJGxldmVsICsgMSB8fCAxKSwgaS5oYXNDaGlsZChjLmlkKSAmJiB1LnNldEF0dHJpYnV0ZShcImFyaWEtZXhwYW5kZWRcIiwgYy4kb3BlbiA/IFwidHJ1ZVwiIDogXCJmYWxzZVwiKTtcbiAgICAgIH0sIGxpbmtBdHRyOiBmdW5jdGlvbihjLCB1KSB7XG4gICAgICAgIHZhciBoID0gaS5jb25maWcubGlua3MsIGcgPSBjLnR5cGUgPT0gaC5maW5pc2hfdG9fc3RhcnQgfHwgYy50eXBlID09IGguc3RhcnRfdG9fc3RhcnQsIHAgPSBjLnR5cGUgPT0gaC5zdGFydF90b19zdGFydCB8fCBjLnR5cGUgPT0gaC5zdGFydF90b19maW5pc2gsIHkgPSBpLmxvY2FsZS5sYWJlbHMubGluayArIFwiIFwiICsgaS50ZW1wbGF0ZXMuZHJhZ19saW5rKGMuc291cmNlLCBwLCBjLnRhcmdldCwgZyk7XG4gICAgICAgIHUuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcImltZ1wiKSwgdS5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIHMoeSkpO1xuICAgICAgfSwgZ3JpZFNlcGFyYXRvckF0dHI6IGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgYy5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwiY29sdW1uaGVhZGVyXCIpO1xuICAgICAgfSwgcm93UmVzaXplckF0dHI6IGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgYy5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwicm93XCIpO1xuICAgICAgfSwgbGlnaHRib3hIaWRkZW5BdHRyOiBmdW5jdGlvbihjKSB7XG4gICAgICAgIGMuc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgXCJ0cnVlXCIpO1xuICAgICAgfSwgbGlnaHRib3hWaXNpYmxlQXR0cjogZnVuY3Rpb24oYykge1xuICAgICAgICBjLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsIFwiZmFsc2VcIik7XG4gICAgICB9LCBsaWdodGJveEF0dHI6IGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgYy5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwiZGlhbG9nXCIpLCBjLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsIFwidHJ1ZVwiKSwgYy5maXJzdENoaWxkLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJoZWFkaW5nXCIpLCBjLmZpcnN0Q2hpbGQuc2V0QXR0cmlidXRlKFwiYXJpYS1sZXZlbFwiLCBcIjFcIik7XG4gICAgICB9LCBsaWdodGJveEJ1dHRvbkF0dHJTdHJpbmc6IGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlU3RyaW5nKHsgcm9sZTogXCJidXR0b25cIiwgXCJhcmlhLWxhYmVsXCI6IGkubG9jYWxlLmxhYmVsc1tjXSwgdGFiaW5kZXg6IFwiMFwiIH0pO1xuICAgICAgfSwgbGlnaHRib3hIZWFkZXI6IGZ1bmN0aW9uKGMsIHUpIHtcbiAgICAgICAgYy5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIHUpO1xuICAgICAgfSwgbGlnaHRib3hTZWxlY3RBdHRyU3RyaW5nOiBmdW5jdGlvbihjKSB7XG4gICAgICAgIHZhciB1ID0gXCJcIjtcbiAgICAgICAgc3dpdGNoIChjKSB7XG4gICAgICAgICAgY2FzZSBcIiVZXCI6XG4gICAgICAgICAgICB1ID0gaS5sb2NhbGUubGFiZWxzLnllYXJzO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIiVtXCI6XG4gICAgICAgICAgICB1ID0gaS5sb2NhbGUubGFiZWxzLm1vbnRocztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCIlZFwiOlxuICAgICAgICAgICAgdSA9IGkubG9jYWxlLmxhYmVscy5kYXlzO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIiVIOiVpXCI6XG4gICAgICAgICAgICB1ID0gaS5sb2NhbGUubGFiZWxzLmhvdXJzICsgaS5sb2NhbGUubGFiZWxzLm1pbnV0ZXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGkuX3dhaUFyaWEuZ2V0QXR0cmlidXRlU3RyaW5nKHsgXCJhcmlhLWxhYmVsXCI6IHUgfSk7XG4gICAgICB9LCBsaWdodGJveER1cmF0aW9uSW5wdXRBdHRyU3RyaW5nOiBmdW5jdGlvbihjKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZVN0cmluZyh7IFwiYXJpYS1sYWJlbFwiOiBpLmxvY2FsZS5sYWJlbHMuY29sdW1uX2R1cmF0aW9uLCBcImFyaWEtdmFsdWVtaW5cIjogXCIwXCIsIHJvbGU6IFwic3BpbmJ1dHRvblwiIH0pO1xuICAgICAgfSwgaW5saW5lRWRpdG9yQXR0cjogZnVuY3Rpb24oYykge1xuICAgICAgICBjLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJyb3dcIik7XG4gICAgICB9LCBncmlkQXR0clN0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBbXCIgcm9sZT0ndHJlZWdyaWQnXCIsIGkuY29uZmlnLm11bHRpc2VsZWN0ID8gXCJhcmlhLW11bHRpc2VsZWN0YWJsZT0ndHJ1ZSdcIiA6IFwiYXJpYS1tdWx0aXNlbGVjdGFibGU9J2ZhbHNlJ1wiLCBcIiBcIl0uam9pbihcIiBcIik7XG4gICAgICB9LCBncmlkU2NhbGVSb3dBdHRyU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFwicm9sZT0ncm93J1wiO1xuICAgICAgfSwgZ3JpZFNjYWxlQ2VsbEF0dHJTdHJpbmc6IGZ1bmN0aW9uKGMsIHUpIHtcbiAgICAgICAgdmFyIGggPSBcIlwiO1xuICAgICAgICBpZiAoYy5uYW1lID09IFwiYWRkXCIpIGggPSB0aGlzLmdldEF0dHJpYnV0ZVN0cmluZyh7IHJvbGU6IFwiY29sdW1uaGVhZGVyXCIsIFwiYXJpYS1sYWJlbFwiOiBpLmxvY2FsZS5sYWJlbHMubmV3X3Rhc2sgfSk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciBnID0geyByb2xlOiBcImNvbHVtbmhlYWRlclwiLCBcImFyaWEtbGFiZWxcIjogaS5jb25maWcuZXh0ZXJuYWxfcmVuZGVyICYmIGkuY29uZmlnLmV4dGVybmFsX3JlbmRlci5pc0VsZW1lbnQodSkgPyBcIlwiIDogdSB9O1xuICAgICAgICAgIGkuX3NvcnQgJiYgaS5fc29ydC5uYW1lID09IGMubmFtZSAmJiAoaS5fc29ydC5kaXJlY3Rpb24gPT0gXCJhc2NcIiA/IGdbXCJhcmlhLXNvcnRcIl0gPSBcImFzY2VuZGluZ1wiIDogZ1tcImFyaWEtc29ydFwiXSA9IFwiZGVzY2VuZGluZ1wiKSwgaCA9IHRoaXMuZ2V0QXR0cmlidXRlU3RyaW5nKGcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoO1xuICAgICAgfSwgZ3JpZERhdGFBdHRyU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFwicm9sZT0ncm93Z3JvdXAnXCI7XG4gICAgICB9LCByZW9yZGVyTWFya2VyQXR0cjogZnVuY3Rpb24oYykge1xuICAgICAgICBjLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJncmlkXCIpLCBjLmZpcnN0Q2hpbGQucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1sZXZlbFwiKSwgYy5maXJzdENoaWxkLnNldEF0dHJpYnV0ZShcImFyaWEtZ3JhYmJlZFwiLCBcInRydWVcIik7XG4gICAgICB9LCBncmlkQ2VsbEF0dHJTdHJpbmc6IGZ1bmN0aW9uKGMsIHUsIGgpIHtcbiAgICAgICAgdmFyIGcgPSB7IHJvbGU6IFwiZ3JpZGNlbGxcIiwgXCJhcmlhLWxhYmVsXCI6IHUgfTtcbiAgICAgICAgcmV0dXJuIGMuZWRpdG9yICYmICFpLmlzUmVhZG9ubHkoaCkgfHwgKGdbXCJhcmlhLXJlYWRvbmx5XCJdID0gITApLCB0aGlzLmdldEF0dHJpYnV0ZVN0cmluZyhnKTtcbiAgICAgIH0sIGdyaWRBZGRCdXR0b25BdHRyU3RyaW5nOiBmdW5jdGlvbihjKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZVN0cmluZyh7IHJvbGU6IFwiYnV0dG9uXCIsIFwiYXJpYS1sYWJlbFwiOiBpLmxvY2FsZS5sYWJlbHMubmV3X3Rhc2sgfSk7XG4gICAgICB9LCBtZXNzYWdlQnV0dG9uQXR0clN0cmluZzogZnVuY3Rpb24oYykge1xuICAgICAgICByZXR1cm4gXCJ0YWJpbmRleD0nMCcgcm9sZT0nYnV0dG9uJyBhcmlhLWxhYmVsPSdcIiArIGMgKyBcIidcIjtcbiAgICAgIH0sIG1lc3NhZ2VJbmZvQXR0cjogZnVuY3Rpb24oYykge1xuICAgICAgICBjLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJhbGVydFwiKTtcbiAgICAgIH0sIG1lc3NhZ2VNb2RhbEF0dHI6IGZ1bmN0aW9uKGMsIHUpIHtcbiAgICAgICAgYy5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwiZGlhbG9nXCIpLCB1ICYmIGMuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbGxlZGJ5XCIsIHUpO1xuICAgICAgfSwgcXVpY2tJbmZvQXR0cjogZnVuY3Rpb24oYykge1xuICAgICAgICBjLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJkaWFsb2dcIik7XG4gICAgICB9LCBxdWlja0luZm9IZWFkZXJBdHRyU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFwiIHJvbGU9J2hlYWRpbmcnIGFyaWEtbGV2ZWw9JzEnIFwiO1xuICAgICAgfSwgcXVpY2tJbmZvSGVhZGVyOiBmdW5jdGlvbihjLCB1KSB7XG4gICAgICAgIGMuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCB1KTtcbiAgICAgIH0sIHF1aWNrSW5mb0J1dHRvbkF0dHJTdHJpbmc6IGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgcmV0dXJuIGkuX3dhaUFyaWEuZ2V0QXR0cmlidXRlU3RyaW5nKHsgcm9sZTogXCJidXR0b25cIiwgXCJhcmlhLWxhYmVsXCI6IGMsIHRhYmluZGV4OiBcIjBcIiB9KTtcbiAgICAgIH0sIHRvb2x0aXBBdHRyOiBmdW5jdGlvbihjKSB7XG4gICAgICAgIGMuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcInRvb2x0aXBcIik7XG4gICAgICB9LCB0b29sdGlwVmlzaWJsZUF0dHI6IGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgYy5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCBcImZhbHNlXCIpO1xuICAgICAgfSwgdG9vbHRpcEhpZGRlbkF0dHI6IGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgYy5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCBcInRydWVcIik7XG4gICAgICB9IH0sIGkuX3dhaUFyaWEpIGkuX3dhaUFyaWFbZF0gPSAvKiBAX19QVVJFX18gKi8gZnVuY3Rpb24oYykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIGkuY29uZmlnLndhaV9hcmlhX2F0dHJpYnV0ZXMgPyBjLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBcIlwiO1xuICAgICAgICB9O1xuICAgICAgfShpLl93YWlBcmlhW2RdKTtcbiAgICB9KHQpLCB0LmxvY2F0ZSA9IGZ1bmN0aW9uKGkpIHtcbiAgICAgIHZhciBhID0geXQoaSk7XG4gICAgICBpZiAoY3QoYSwgXCIuZ2FudHRfdGFza19yb3dcIikpIHJldHVybiBudWxsO1xuICAgICAgdmFyIHIgPSBhcmd1bWVudHNbMV0gfHwgdGhpcy5jb25maWcudGFza19hdHRyaWJ1dGUsIHMgPSBldChhLCByKTtcbiAgICAgIHJldHVybiBzID8gcy5nZXRBdHRyaWJ1dGUocikgOiBudWxsO1xuICAgIH0sIHQuX2xvY2F0ZV9jc3MgPSBmdW5jdGlvbihpLCBhLCByKSB7XG4gICAgICByZXR1cm4gcHQoaSwgYSwgcik7XG4gICAgfSwgdC5fbG9jYXRlSFRNTCA9IGZ1bmN0aW9uKGksIGEpIHtcbiAgICAgIHJldHVybiBldChpLCBhIHx8IHRoaXMuY29uZmlnLnRhc2tfYXR0cmlidXRlKTtcbiAgICB9O1xuICB9XG4gIHQuYXR0YWNoRXZlbnQoXCJvblBhcnNlXCIsIGZ1bmN0aW9uKCkge1xuICAgIEYodCkgfHwgdC5hdHRhY2hFdmVudChcIm9uR2FudHRSZW5kZXJcIiwgZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodC5jb25maWcuaW5pdGlhbF9zY3JvbGwpIHtcbiAgICAgICAgdmFyIGkgPSB0LmdldFRhc2tCeUluZGV4KDApLCBhID0gaSA/IGkuaWQgOiB0LmNvbmZpZy5yb290X2lkO1xuICAgICAgICB0LmlzVGFza0V4aXN0cyhhKSAmJiB0LiR0YXNrICYmIHQudXRpbHMuZG9tLmlzQ2hpbGRPZih0LiR0YXNrLCB0LiRjb250YWluZXIpICYmIHQuc2hvd1Rhc2soYSk7XG4gICAgICB9XG4gICAgfSwgeyBvbmNlOiAhMCB9KTtcbiAgfSksIHQuYXR0YWNoRXZlbnQoXCJvbkJlZm9yZUdhbnR0UmVhZHlcIiwgZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5jb25maWcuc2Nyb2xsX3NpemUgfHwgKHRoaXMuY29uZmlnLnNjcm9sbF9zaXplID0gWGUoKSB8fCAxNSksIEYodCkgfHwgKHRoaXMuX2V2ZW50UmVtb3ZlQWxsKCksIHRoaXMuJG1vdXNlRXZlbnRzLnJlc2V0KCksIHRoaXMucmVzZXRMaWdodGJveCgpKTtcbiAgfSksIHQuYXR0YWNoRXZlbnQoXCJvbkdhbnR0UmVhZHlcIiwgZnVuY3Rpb24oKSB7XG4gICAgIUYodCkgJiYgdC5jb25maWcucnRsICYmIHQuJGxheW91dC5nZXRDZWxsc0J5VHlwZShcInZpZXdDZWxsXCIpLmZvckVhY2goZnVuY3Rpb24oaSkge1xuICAgICAgdmFyIGEgPSBpLiRjb25maWcuc2Nyb2xsWDtcbiAgICAgIGlmIChhKSB7XG4gICAgICAgIHZhciByID0gdC4kdWkuZ2V0VmlldyhhKTtcbiAgICAgICAgciAmJiByLnNjcm9sbFRvKHIuJGNvbmZpZy5zY3JvbGxTaXplLCAwKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSksIHQuYXR0YWNoRXZlbnQoXCJvbkdhbnR0UmVhZHlcIiwgZnVuY3Rpb24oKSB7XG4gICAgaWYgKCFGKHQpKSB7XG4gICAgICB2YXIgaSA9IHQucGx1Z2lucygpLCBhID0geyBhdXRvX3NjaGVkdWxpbmc6IHQuYXV0b1NjaGVkdWxlLCBjbGlja19kcmFnOiB0LmV4dC5jbGlja0RyYWcsIGNyaXRpY2FsX3BhdGg6IHQuaXNDcml0aWNhbFRhc2ssIGRyYWdfdGltZWxpbmU6IHQuZXh0LmRyYWdUaW1lbGluZSwgZXhwb3J0X2FwaTogdC5leHBvcnRUb1BERiwgZnVsbHNjcmVlbjogdC5leHQuZnVsbHNjcmVlbiwgZ3JvdXBpbmc6IHQuZ3JvdXBCeSwga2V5Ym9hcmRfbmF2aWdhdGlvbjogdC5leHQua2V5Ym9hcmROYXZpZ2F0aW9uLCBtYXJrZXI6IHQuYWRkTWFya2VyLCBtdWx0aXNlbGVjdDogdC5lYWNoU2VsZWN0ZWRUYXNrLCBvdmVybGF5OiB0LmV4dC5vdmVybGF5LCBxdWlja19pbmZvOiB0LnRlbXBsYXRlcy5xdWlja19pbmZvX2NvbnRlbnQsIHRvb2x0aXA6IHQuZXh0LnRvb2x0aXBzLCB1bmRvOiB0LnVuZG8gfTtcbiAgICAgIGZvciAobGV0IHIgaW4gYSkgYVtyXSAmJiAhaVtyXSAmJiBjb25zb2xlLndhcm4oYFlvdSBjb25uZWN0ZWQgdGhlICcke3J9JyBleHRlbnNpb24gdmlhIGFuIG9ic29sZXRlIGZpbGUuIFxuVG8gZml4IGl0LCB5b3UgbmVlZCB0byByZW1vdmUgdGhlIG9ic29sZXRlIGZpbGUgYW5kIGNvbm5lY3QgdGhlIGV4dGVuc2lvbiB2aWEgdGhlIHBsdWdpbnMgbWV0aG9kOiBodHRwczovL2RvY3MuZGh0bWx4LmNvbS9nYW50dC9hcGlfX2dhbnR0X3BsdWdpbnMuaHRtbGApO1xuICAgIH1cbiAgfSk7XG59XG5jb25zdCBYYSA9IGR0LmdhbnR0ID0gZnVuY3Rpb24odCkge1xuICB2YXIgZSA9IHJhKHQpO1xuICByZXR1cm4gZS5lbnYuaXNOb2RlIHx8IChLYShlKSwgZnVuY3Rpb24obikge1xuICAgIG4ubG9hZCA9IGZ1bmN0aW9uKGksIGEsIHIpIHtcbiAgICAgIHRoaXMuX2xvYWRfdXJsID0gaSwgdGhpcy5hc3NlcnQoYXJndW1lbnRzLmxlbmd0aCwgXCJJbnZhbGlkIGxvYWQgYXJndW1lbnRzXCIpO1xuICAgICAgdmFyIHMgPSBcImpzb25cIiwgbyA9IG51bGw7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+PSAzID8gKHMgPSBhLCBvID0gcikgOiB0eXBlb2YgYXJndW1lbnRzWzFdID09IFwic3RyaW5nXCIgPyBzID0gYXJndW1lbnRzWzFdIDogdHlwZW9mIGFyZ3VtZW50c1sxXSA9PSBcImZ1bmN0aW9uXCIgJiYgKG8gPSBhcmd1bWVudHNbMV0pLCB0aGlzLl9sb2FkX3R5cGUgPSBzLCB0aGlzLmNhbGxFdmVudChcIm9uTG9hZFN0YXJ0XCIsIFtpLCBzXSksIHRoaXMuYWpheC5nZXQoaSwgbi5iaW5kKGZ1bmN0aW9uKGwpIHtcbiAgICAgICAgdGhpcy5vbl9sb2FkKGwsIHMpLCB0aGlzLmNhbGxFdmVudChcIm9uTG9hZEVuZFwiLCBbaSwgc10pLCB0eXBlb2YgbyA9PSBcImZ1bmN0aW9uXCIgJiYgby5jYWxsKHRoaXMpO1xuICAgICAgfSwgdGhpcykpO1xuICAgIH07XG4gIH0oZSkpLCBlO1xufShWbik7XG5leHBvcnQge1xuICBYYSBhcyBkZWZhdWx0LFxuICBYYSBhcyBnYW50dFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRodG1seGdhbnR0LmVzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/dhtmlx-gantt/codebase/dhtmlxgantt.es.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/html2canvas/dist/html2canvas.js":
/*!******************************************************!*\
  !*** ./node_modules/html2canvas/dist/html2canvas.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/*!\n * html2canvas 1.4.1 <https://html2canvas.hertzen.com>\n * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>\n * Released under MIT License\n */\n(function (global, factory) {\n     true ? module.exports = factory() :\n    0;\n}(this, (function () { 'use strict';\n\n    /*! *****************************************************************************\r\n    Copyright (c) Microsoft Corporation.\r\n\r\n    Permission to use, copy, modify, and/or distribute this software for any\r\n    purpose with or without fee is hereby granted.\r\n\r\n    THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\n    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\n    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\n    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\n    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\n    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\n    PERFORMANCE OF THIS SOFTWARE.\r\n    ***************************************************************************** */\r\n    /* global Reflect, Promise */\r\n\r\n    var extendStatics = function(d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n\r\n    function __extends(d, b) {\r\n        if (typeof b !== \"function\" && b !== null)\r\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    }\r\n\r\n    var __assign = function() {\r\n        __assign = Object.assign || function __assign(t) {\r\n            for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n                s = arguments[i];\r\n                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n            }\r\n            return t;\r\n        };\r\n        return __assign.apply(this, arguments);\r\n    };\r\n\r\n    function __awaiter(thisArg, _arguments, P, generator) {\r\n        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n        return new (P || (P = Promise))(function (resolve, reject) {\r\n            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n            function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n            step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n        });\r\n    }\r\n\r\n    function __generator(thisArg, body) {\r\n        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n        return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n        function verb(n) { return function (v) { return step([n, v]); }; }\r\n        function step(op) {\r\n            if (f) throw new TypeError(\"Generator is already executing.\");\r\n            while (_) try {\r\n                if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n                if (y = 0, t) op = [op[0] & 2, t.value];\r\n                switch (op[0]) {\r\n                    case 0: case 1: t = op; break;\r\n                    case 4: _.label++; return { value: op[1], done: false };\r\n                    case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                    case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                    default:\r\n                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                        if (t[2]) _.ops.pop();\r\n                        _.trys.pop(); continue;\r\n                }\r\n                op = body.call(thisArg, _);\r\n            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n        }\r\n    }\r\n\r\n    function __spreadArray(to, from, pack) {\r\n        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n            if (ar || !(i in from)) {\r\n                if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n                ar[i] = from[i];\r\n            }\r\n        }\r\n        return to.concat(ar || from);\r\n    }\n\n    var Bounds = /** @class */ (function () {\n        function Bounds(left, top, width, height) {\n            this.left = left;\n            this.top = top;\n            this.width = width;\n            this.height = height;\n        }\n        Bounds.prototype.add = function (x, y, w, h) {\n            return new Bounds(this.left + x, this.top + y, this.width + w, this.height + h);\n        };\n        Bounds.fromClientRect = function (context, clientRect) {\n            return new Bounds(clientRect.left + context.windowBounds.left, clientRect.top + context.windowBounds.top, clientRect.width, clientRect.height);\n        };\n        Bounds.fromDOMRectList = function (context, domRectList) {\n            var domRect = Array.from(domRectList).find(function (rect) { return rect.width !== 0; });\n            return domRect\n                ? new Bounds(domRect.left + context.windowBounds.left, domRect.top + context.windowBounds.top, domRect.width, domRect.height)\n                : Bounds.EMPTY;\n        };\n        Bounds.EMPTY = new Bounds(0, 0, 0, 0);\n        return Bounds;\n    }());\n    var parseBounds = function (context, node) {\n        return Bounds.fromClientRect(context, node.getBoundingClientRect());\n    };\n    var parseDocumentSize = function (document) {\n        var body = document.body;\n        var documentElement = document.documentElement;\n        if (!body || !documentElement) {\n            throw new Error(\"Unable to get document size\");\n        }\n        var width = Math.max(Math.max(body.scrollWidth, documentElement.scrollWidth), Math.max(body.offsetWidth, documentElement.offsetWidth), Math.max(body.clientWidth, documentElement.clientWidth));\n        var height = Math.max(Math.max(body.scrollHeight, documentElement.scrollHeight), Math.max(body.offsetHeight, documentElement.offsetHeight), Math.max(body.clientHeight, documentElement.clientHeight));\n        return new Bounds(0, 0, width, height);\n    };\n\n    /*\n     * css-line-break 2.1.0 <https://github.com/niklasvh/css-line-break#readme>\n     * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>\n     * Released under MIT License\n     */\n    var toCodePoints$1 = function (str) {\n        var codePoints = [];\n        var i = 0;\n        var length = str.length;\n        while (i < length) {\n            var value = str.charCodeAt(i++);\n            if (value >= 0xd800 && value <= 0xdbff && i < length) {\n                var extra = str.charCodeAt(i++);\n                if ((extra & 0xfc00) === 0xdc00) {\n                    codePoints.push(((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000);\n                }\n                else {\n                    codePoints.push(value);\n                    i--;\n                }\n            }\n            else {\n                codePoints.push(value);\n            }\n        }\n        return codePoints;\n    };\n    var fromCodePoint$1 = function () {\n        var codePoints = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            codePoints[_i] = arguments[_i];\n        }\n        if (String.fromCodePoint) {\n            return String.fromCodePoint.apply(String, codePoints);\n        }\n        var length = codePoints.length;\n        if (!length) {\n            return '';\n        }\n        var codeUnits = [];\n        var index = -1;\n        var result = '';\n        while (++index < length) {\n            var codePoint = codePoints[index];\n            if (codePoint <= 0xffff) {\n                codeUnits.push(codePoint);\n            }\n            else {\n                codePoint -= 0x10000;\n                codeUnits.push((codePoint >> 10) + 0xd800, (codePoint % 0x400) + 0xdc00);\n            }\n            if (index + 1 === length || codeUnits.length > 0x4000) {\n                result += String.fromCharCode.apply(String, codeUnits);\n                codeUnits.length = 0;\n            }\n        }\n        return result;\n    };\n    var chars$2 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n    // Use a lookup table to find the index.\n    var lookup$2 = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);\n    for (var i$2 = 0; i$2 < chars$2.length; i$2++) {\n        lookup$2[chars$2.charCodeAt(i$2)] = i$2;\n    }\n\n    /*\n     * utrie 1.0.2 <https://github.com/niklasvh/utrie>\n     * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>\n     * Released under MIT License\n     */\n    var chars$1$1 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n    // Use a lookup table to find the index.\n    var lookup$1$1 = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);\n    for (var i$1$1 = 0; i$1$1 < chars$1$1.length; i$1$1++) {\n        lookup$1$1[chars$1$1.charCodeAt(i$1$1)] = i$1$1;\n    }\n    var decode$1 = function (base64) {\n        var bufferLength = base64.length * 0.75, len = base64.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;\n        if (base64[base64.length - 1] === '=') {\n            bufferLength--;\n            if (base64[base64.length - 2] === '=') {\n                bufferLength--;\n            }\n        }\n        var buffer = typeof ArrayBuffer !== 'undefined' &&\n            typeof Uint8Array !== 'undefined' &&\n            typeof Uint8Array.prototype.slice !== 'undefined'\n            ? new ArrayBuffer(bufferLength)\n            : new Array(bufferLength);\n        var bytes = Array.isArray(buffer) ? buffer : new Uint8Array(buffer);\n        for (i = 0; i < len; i += 4) {\n            encoded1 = lookup$1$1[base64.charCodeAt(i)];\n            encoded2 = lookup$1$1[base64.charCodeAt(i + 1)];\n            encoded3 = lookup$1$1[base64.charCodeAt(i + 2)];\n            encoded4 = lookup$1$1[base64.charCodeAt(i + 3)];\n            bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);\n            bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);\n            bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);\n        }\n        return buffer;\n    };\n    var polyUint16Array$1 = function (buffer) {\n        var length = buffer.length;\n        var bytes = [];\n        for (var i = 0; i < length; i += 2) {\n            bytes.push((buffer[i + 1] << 8) | buffer[i]);\n        }\n        return bytes;\n    };\n    var polyUint32Array$1 = function (buffer) {\n        var length = buffer.length;\n        var bytes = [];\n        for (var i = 0; i < length; i += 4) {\n            bytes.push((buffer[i + 3] << 24) | (buffer[i + 2] << 16) | (buffer[i + 1] << 8) | buffer[i]);\n        }\n        return bytes;\n    };\n\n    /** Shift size for getting the index-2 table offset. */\n    var UTRIE2_SHIFT_2$1 = 5;\n    /** Shift size for getting the index-1 table offset. */\n    var UTRIE2_SHIFT_1$1 = 6 + 5;\n    /**\n     * Shift size for shifting left the index array values.\n     * Increases possible data size with 16-bit index values at the cost\n     * of compactability.\n     * This requires data blocks to be aligned by UTRIE2_DATA_GRANULARITY.\n     */\n    var UTRIE2_INDEX_SHIFT$1 = 2;\n    /**\n     * Difference between the two shift sizes,\n     * for getting an index-1 offset from an index-2 offset. 6=11-5\n     */\n    var UTRIE2_SHIFT_1_2$1 = UTRIE2_SHIFT_1$1 - UTRIE2_SHIFT_2$1;\n    /**\n     * The part of the index-2 table for U+D800..U+DBFF stores values for\n     * lead surrogate code _units_ not code _points_.\n     * Values for lead surrogate code _points_ are indexed with this portion of the table.\n     * Length=32=0x20=0x400>>UTRIE2_SHIFT_2. (There are 1024=0x400 lead surrogates.)\n     */\n    var UTRIE2_LSCP_INDEX_2_OFFSET$1 = 0x10000 >> UTRIE2_SHIFT_2$1;\n    /** Number of entries in a data block. 32=0x20 */\n    var UTRIE2_DATA_BLOCK_LENGTH$1 = 1 << UTRIE2_SHIFT_2$1;\n    /** Mask for getting the lower bits for the in-data-block offset. */\n    var UTRIE2_DATA_MASK$1 = UTRIE2_DATA_BLOCK_LENGTH$1 - 1;\n    var UTRIE2_LSCP_INDEX_2_LENGTH$1 = 0x400 >> UTRIE2_SHIFT_2$1;\n    /** Count the lengths of both BMP pieces. 2080=0x820 */\n    var UTRIE2_INDEX_2_BMP_LENGTH$1 = UTRIE2_LSCP_INDEX_2_OFFSET$1 + UTRIE2_LSCP_INDEX_2_LENGTH$1;\n    /**\n     * The 2-byte UTF-8 version of the index-2 table follows at offset 2080=0x820.\n     * Length 32=0x20 for lead bytes C0..DF, regardless of UTRIE2_SHIFT_2.\n     */\n    var UTRIE2_UTF8_2B_INDEX_2_OFFSET$1 = UTRIE2_INDEX_2_BMP_LENGTH$1;\n    var UTRIE2_UTF8_2B_INDEX_2_LENGTH$1 = 0x800 >> 6; /* U+0800 is the first code point after 2-byte UTF-8 */\n    /**\n     * The index-1 table, only used for supplementary code points, at offset 2112=0x840.\n     * Variable length, for code points up to highStart, where the last single-value range starts.\n     * Maximum length 512=0x200=0x100000>>UTRIE2_SHIFT_1.\n     * (For 0x100000 supplementary code points U+10000..U+10ffff.)\n     *\n     * The part of the index-2 table for supplementary code points starts\n     * after this index-1 table.\n     *\n     * Both the index-1 table and the following part of the index-2 table\n     * are omitted completely if there is only BMP data.\n     */\n    var UTRIE2_INDEX_1_OFFSET$1 = UTRIE2_UTF8_2B_INDEX_2_OFFSET$1 + UTRIE2_UTF8_2B_INDEX_2_LENGTH$1;\n    /**\n     * Number of index-1 entries for the BMP. 32=0x20\n     * This part of the index-1 table is omitted from the serialized form.\n     */\n    var UTRIE2_OMITTED_BMP_INDEX_1_LENGTH$1 = 0x10000 >> UTRIE2_SHIFT_1$1;\n    /** Number of entries in an index-2 block. 64=0x40 */\n    var UTRIE2_INDEX_2_BLOCK_LENGTH$1 = 1 << UTRIE2_SHIFT_1_2$1;\n    /** Mask for getting the lower bits for the in-index-2-block offset. */\n    var UTRIE2_INDEX_2_MASK$1 = UTRIE2_INDEX_2_BLOCK_LENGTH$1 - 1;\n    var slice16$1 = function (view, start, end) {\n        if (view.slice) {\n            return view.slice(start, end);\n        }\n        return new Uint16Array(Array.prototype.slice.call(view, start, end));\n    };\n    var slice32$1 = function (view, start, end) {\n        if (view.slice) {\n            return view.slice(start, end);\n        }\n        return new Uint32Array(Array.prototype.slice.call(view, start, end));\n    };\n    var createTrieFromBase64$1 = function (base64, _byteLength) {\n        var buffer = decode$1(base64);\n        var view32 = Array.isArray(buffer) ? polyUint32Array$1(buffer) : new Uint32Array(buffer);\n        var view16 = Array.isArray(buffer) ? polyUint16Array$1(buffer) : new Uint16Array(buffer);\n        var headerLength = 24;\n        var index = slice16$1(view16, headerLength / 2, view32[4] / 2);\n        var data = view32[5] === 2\n            ? slice16$1(view16, (headerLength + view32[4]) / 2)\n            : slice32$1(view32, Math.ceil((headerLength + view32[4]) / 4));\n        return new Trie$1(view32[0], view32[1], view32[2], view32[3], index, data);\n    };\n    var Trie$1 = /** @class */ (function () {\n        function Trie(initialValue, errorValue, highStart, highValueIndex, index, data) {\n            this.initialValue = initialValue;\n            this.errorValue = errorValue;\n            this.highStart = highStart;\n            this.highValueIndex = highValueIndex;\n            this.index = index;\n            this.data = data;\n        }\n        /**\n         * Get the value for a code point as stored in the Trie.\n         *\n         * @param codePoint the code point\n         * @return the value\n         */\n        Trie.prototype.get = function (codePoint) {\n            var ix;\n            if (codePoint >= 0) {\n                if (codePoint < 0x0d800 || (codePoint > 0x0dbff && codePoint <= 0x0ffff)) {\n                    // Ordinary BMP code point, excluding leading surrogates.\n                    // BMP uses a single level lookup.  BMP index starts at offset 0 in the Trie2 index.\n                    // 16 bit data is stored in the index array itself.\n                    ix = this.index[codePoint >> UTRIE2_SHIFT_2$1];\n                    ix = (ix << UTRIE2_INDEX_SHIFT$1) + (codePoint & UTRIE2_DATA_MASK$1);\n                    return this.data[ix];\n                }\n                if (codePoint <= 0xffff) {\n                    // Lead Surrogate Code Point.  A Separate index section is stored for\n                    // lead surrogate code units and code points.\n                    //   The main index has the code unit data.\n                    //   For this function, we need the code point data.\n                    // Note: this expression could be refactored for slightly improved efficiency, but\n                    //       surrogate code points will be so rare in practice that it's not worth it.\n                    ix = this.index[UTRIE2_LSCP_INDEX_2_OFFSET$1 + ((codePoint - 0xd800) >> UTRIE2_SHIFT_2$1)];\n                    ix = (ix << UTRIE2_INDEX_SHIFT$1) + (codePoint & UTRIE2_DATA_MASK$1);\n                    return this.data[ix];\n                }\n                if (codePoint < this.highStart) {\n                    // Supplemental code point, use two-level lookup.\n                    ix = UTRIE2_INDEX_1_OFFSET$1 - UTRIE2_OMITTED_BMP_INDEX_1_LENGTH$1 + (codePoint >> UTRIE2_SHIFT_1$1);\n                    ix = this.index[ix];\n                    ix += (codePoint >> UTRIE2_SHIFT_2$1) & UTRIE2_INDEX_2_MASK$1;\n                    ix = this.index[ix];\n                    ix = (ix << UTRIE2_INDEX_SHIFT$1) + (codePoint & UTRIE2_DATA_MASK$1);\n                    return this.data[ix];\n                }\n                if (codePoint <= 0x10ffff) {\n                    return this.data[this.highValueIndex];\n                }\n            }\n            // Fall through.  The code point is outside of the legal range of 0..0x10ffff.\n            return this.errorValue;\n        };\n        return Trie;\n    }());\n\n    /*\n     * base64-arraybuffer 1.0.2 <https://github.com/niklasvh/base64-arraybuffer>\n     * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>\n     * Released under MIT License\n     */\n    var chars$3 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n    // Use a lookup table to find the index.\n    var lookup$3 = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);\n    for (var i$3 = 0; i$3 < chars$3.length; i$3++) {\n        lookup$3[chars$3.charCodeAt(i$3)] = i$3;\n    }\n\n    var base64$1 = 'KwAAAAAAAAAACA4AUD0AADAgAAACAAAAAAAIABAAGABAAEgAUABYAGAAaABgAGgAYgBqAF8AZwBgAGgAcQB5AHUAfQCFAI0AlQCdAKIAqgCyALoAYABoAGAAaABgAGgAwgDKAGAAaADGAM4A0wDbAOEA6QDxAPkAAQEJAQ8BFwF1AH0AHAEkASwBNAE6AUIBQQFJAVEBWQFhAWgBcAF4ATAAgAGGAY4BlQGXAZ8BpwGvAbUBvQHFAc0B0wHbAeMB6wHxAfkBAQIJAvEBEQIZAiECKQIxAjgCQAJGAk4CVgJeAmQCbAJ0AnwCgQKJApECmQKgAqgCsAK4ArwCxAIwAMwC0wLbAjAA4wLrAvMC+AIAAwcDDwMwABcDHQMlAy0DNQN1AD0DQQNJA0kDSQNRA1EDVwNZA1kDdQB1AGEDdQBpA20DdQN1AHsDdQCBA4kDkQN1AHUAmQOhA3UAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AKYDrgN1AHUAtgO+A8YDzgPWAxcD3gPjA+sD8wN1AHUA+wMDBAkEdQANBBUEHQQlBCoEFwMyBDgEYABABBcDSARQBFgEYARoBDAAcAQzAXgEgASIBJAEdQCXBHUAnwSnBK4EtgS6BMIEyAR1AHUAdQB1AHUAdQCVANAEYABgAGAAYABgAGAAYABgANgEYADcBOQEYADsBPQE/AQEBQwFFAUcBSQFLAU0BWQEPAVEBUsFUwVbBWAAYgVgAGoFcgV6BYIFigWRBWAAmQWfBaYFYABgAGAAYABgAKoFYACxBbAFuQW6BcEFwQXHBcEFwQXPBdMF2wXjBeoF8gX6BQIGCgYSBhoGIgYqBjIGOgZgAD4GRgZMBmAAUwZaBmAAYABgAGAAYABgAGAAYABgAGAAYABgAGIGYABpBnAGYABgAGAAYABgAGAAYABgAGAAYAB4Bn8GhQZgAGAAYAB1AHcDFQSLBmAAYABgAJMGdQA9A3UAmwajBqsGqwaVALMGuwbDBjAAywbSBtIG1QbSBtIG0gbSBtIG0gbdBuMG6wbzBvsGAwcLBxMHAwcbByMHJwcsBywHMQcsB9IGOAdAB0gHTgfSBkgHVgfSBtIG0gbSBtIG0gbSBtIG0gbSBiwHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAdgAGAALAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAdbB2MHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsB2kH0gZwB64EdQB1AHUAdQB1AHUAdQB1AHUHfQdgAIUHjQd1AHUAlQedB2AAYAClB6sHYACzB7YHvgfGB3UAzgfWBzMB3gfmB1EB7gf1B/0HlQENAQUIDQh1ABUIHQglCBcDLQg1CD0IRQhNCEEDUwh1AHUAdQBbCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIcAh3CHoIMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIgggwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAALAcsBywHLAcsBywHLAcsBywHLAcsB4oILAcsB44I0gaWCJ4Ipgh1AHUAqgiyCHUAdQB1AHUAdQB1AHUAdQB1AHUAtwh8AXUAvwh1AMUIyQjRCNkI4AjoCHUAdQB1AO4I9gj+CAYJDgkTCS0HGwkjCYIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiAAIAAAAFAAYABgAGIAXwBgAHEAdQBFAJUAogCyAKAAYABgAEIA4ABGANMA4QDxAMEBDwE1AFwBLAE6AQEBUQF4QkhCmEKoQrhCgAHIQsAB0MLAAcABwAHAAeDC6ABoAHDCwMMAAcABwAHAAdDDGMMAAcAB6MM4wwjDWMNow3jDaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAEjDqABWw6bDqABpg6gAaABoAHcDvwOPA+gAaABfA/8DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DpcPAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcAB9cPKwkyCToJMAB1AHUAdQBCCUoJTQl1AFUJXAljCWcJawkwADAAMAAwAHMJdQB2CX4JdQCECYoJjgmWCXUAngkwAGAAYABxAHUApgn3A64JtAl1ALkJdQDACTAAMAAwADAAdQB1AHUAdQB1AHUAdQB1AHUAowYNBMUIMAAwADAAMADICcsJ0wnZCRUE4QkwAOkJ8An4CTAAMAB1AAAKvwh1AAgKDwoXCh8KdQAwACcKLgp1ADYKqAmICT4KRgowADAAdQB1AE4KMAB1AFYKdQBeCnUAZQowADAAMAAwADAAMAAwADAAMAAVBHUAbQowADAAdQC5CXUKMAAwAHwBxAijBogEMgF9CoQKiASMCpQKmgqIBKIKqgquCogEDQG2Cr4KxgrLCjAAMADTCtsKCgHjCusK8Qr5CgELMAAwADAAMAB1AIsECQsRC3UANAEZCzAAMAAwADAAMAB1ACELKQswAHUANAExCzkLdQBBC0kLMABRC1kLMAAwADAAMAAwADAAdQBhCzAAMAAwAGAAYABpC3ELdwt/CzAAMACHC4sLkwubC58Lpwt1AK4Ltgt1APsDMAAwADAAMAAwADAAMAAwAL4LwwvLC9IL1wvdCzAAMADlC+kL8Qv5C/8LSQswADAAMAAwADAAMAAwADAAMAAHDDAAMAAwADAAMAAODBYMHgx1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1ACYMMAAwADAAdQB1AHUALgx1AHUAdQB1AHUAdQA2DDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AD4MdQBGDHUAdQB1AHUAdQB1AEkMdQB1AHUAdQB1AFAMMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQBYDHUAdQB1AF8MMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUA+wMVBGcMMAAwAHwBbwx1AHcMfwyHDI8MMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAYABgAJcMMAAwADAAdQB1AJ8MlQClDDAAMACtDCwHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsB7UMLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AA0EMAC9DDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAsBywHLAcsBywHLAcsBywHLQcwAMEMyAwsBywHLAcsBywHLAcsBywHLAcsBywHzAwwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1ANQM2QzhDDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMABgAGAAYABgAGAAYABgAOkMYADxDGAA+AwADQYNYABhCWAAYAAODTAAMAAwADAAFg1gAGAAHg37AzAAMAAwADAAYABgACYNYAAsDTQNPA1gAEMNPg1LDWAAYABgAGAAYABgAGAAYABgAGAAUg1aDYsGVglhDV0NcQBnDW0NdQ15DWAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAlQCBDZUAiA2PDZcNMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAnw2nDTAAMAAwADAAMAAwAHUArw23DTAAMAAwADAAMAAwADAAMAAwADAAMAB1AL8NMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAB1AHUAdQB1AHUAdQDHDTAAYABgAM8NMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAA1w11ANwNMAAwAD0B5A0wADAAMAAwADAAMADsDfQN/A0EDgwOFA4wABsOMAAwADAAMAAwADAAMAAwANIG0gbSBtIG0gbSBtIG0gYjDigOwQUuDsEFMw7SBjoO0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGQg5KDlIOVg7SBtIGXg5lDm0OdQ7SBtIGfQ6EDooOjQ6UDtIGmg6hDtIG0gaoDqwO0ga0DrwO0gZgAGAAYADEDmAAYAAkBtIGzA5gANIOYADaDokO0gbSBt8O5w7SBu8O0gb1DvwO0gZgAGAAxA7SBtIG0gbSBtIGYABgAGAAYAAED2AAsAUMD9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGFA8sBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAccD9IGLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHJA8sBywHLAcsBywHLAccDywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywPLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAc0D9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAccD9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGFA8sBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHPA/SBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gYUD0QPlQCVAJUAMAAwADAAMACVAJUAlQCVAJUAlQCVAEwPMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAA//8EAAQABAAEAAQABAAEAAQABAANAAMAAQABAAIABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQACgATABcAHgAbABoAHgAXABYAEgAeABsAGAAPABgAHABLAEsASwBLAEsASwBLAEsASwBLABgAGAAeAB4AHgATAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQABYAGwASAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAWAA0AEQAeAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAFAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAJABYAGgAbABsAGwAeAB0AHQAeAE8AFwAeAA0AHgAeABoAGwBPAE8ADgBQAB0AHQAdAE8ATwAXAE8ATwBPABYAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAFAAUABQAFAAUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AHgAeAFAATwBAAE8ATwBPAEAATwBQAFAATwBQAB4AHgAeAB4AHgAeAB0AHQAdAB0AHgAdAB4ADgBQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgBQAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAJAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAkACQAJAAkACQAJAAkABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAFAAHgAeAB4AKwArAFAAUABQAFAAGABQACsAKwArACsAHgAeAFAAHgBQAFAAUAArAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAUAAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAYAA0AKwArAB4AHgAbACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQADQAEAB4ABAAEAB4ABAAEABMABAArACsAKwArACsAKwArACsAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAKwArACsAKwBWAFYAVgBWAB4AHgArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AGgAaABoAGAAYAB4AHgAEAAQABAAEAAQABAAEAAQABAAEAAQAEwAEACsAEwATAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABLAEsASwBLAEsASwBLAEsASwBLABoAGQAZAB4AUABQAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQABMAUAAEAAQABAAEAAQABAAEAB4AHgAEAAQABAAEAAQABABQAFAABAAEAB4ABAAEAAQABABQAFAASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUAAeAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAFAABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQAUABQAB4AHgAYABMAUAArACsABAAbABsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAFAABAAEAAQABAAEAFAABAAEAAQAUAAEAAQABAAEAAQAKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAArACsAHgArAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAUAAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAABAAEAA0ADQBLAEsASwBLAEsASwBLAEsASwBLAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUAArACsAKwBQAFAAUABQACsAKwAEAFAABAAEAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABABQACsAKwArACsAKwArACsAKwAEACsAKwArACsAUABQACsAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAFAAUAAaABoAUABQAFAAUABQAEwAHgAbAFAAHgAEACsAKwAEAAQABAArAFAAUABQAFAAUABQACsAKwArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQACsAUABQACsAKwAEACsABAAEAAQABAAEACsAKwArACsABAAEACsAKwAEAAQABAArACsAKwAEACsAKwArACsAKwArACsAUABQAFAAUAArAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLAAQABABQAFAAUAAEAB4AKwArACsAKwArACsAKwArACsAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQACsAKwAEAFAABAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAArACsAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAB4AGwArACsAKwArACsAKwArAFAABAAEAAQABAAEAAQAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABAArACsAKwArACsAKwArAAQABAAEACsAKwArACsAUABQACsAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAB4AUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAAQAUAArAFAAUABQAFAAUABQACsAKwArAFAAUABQACsAUABQAFAAUAArACsAKwBQAFAAKwBQACsAUABQACsAKwArAFAAUAArACsAKwBQAFAAUAArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArAAQABAAEAAQABAArACsAKwAEAAQABAArAAQABAAEAAQAKwArAFAAKwArACsAKwArACsABAArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAHgAeAB4AHgAeAB4AGwAeACsAKwArACsAKwAEAAQABAAEAAQAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAUAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAAEACsAKwArACsAKwArACsABAAEACsAUABQAFAAKwArACsAKwArAFAAUAAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAKwAOAFAAUABQAFAAUABQAFAAHgBQAAQABAAEAA4AUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAKwArAAQAUAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAAEACsAKwArACsAKwArACsABAAEACsAKwArACsAKwArACsAUAArAFAAUAAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwBQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAFAABAAEAAQABAAEAAQABAArAAQABAAEACsABAAEAAQABABQAB4AKwArACsAKwBQAFAAUAAEAFAAUABQAFAAUABQAFAAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAFAAUABQAFAAUABQAFAAUABQABoAUABQAFAAUABQAFAAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQACsAUAArACsAUABQAFAAUABQAFAAUAArACsAKwAEACsAKwArACsABAAEAAQABAAEAAQAKwAEACsABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArAAQABAAeACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAAqAFwAXAAqACoAKgAqACoAKgAqACsAKwArACsAGwBcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAeAEsASwBLAEsASwBLAEsASwBLAEsADQANACsAKwArACsAKwBcAFwAKwBcACsAXABcAFwAXABcACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACsAXAArAFwAXABcAFwAXABcAFwAXABcAFwAKgBcAFwAKgAqACoAKgAqACoAKgAqACoAXAArACsAXABcAFwAXABcACsAXAArACoAKgAqACoAKgAqACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwBcAFwAXABcAFAADgAOAA4ADgAeAA4ADgAJAA4ADgANAAkAEwATABMAEwATAAkAHgATAB4AHgAeAAQABAAeAB4AHgAeAB4AHgBLAEsASwBLAEsASwBLAEsASwBLAFAAUABQAFAAUABQAFAAUABQAFAADQAEAB4ABAAeAAQAFgARABYAEQAEAAQAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQADQAEAAQABAAEAAQADQAEAAQAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArAA0ADQAeAB4AHgAeAB4AHgAEAB4AHgAeAB4AHgAeACsAHgAeAA4ADgANAA4AHgAeAB4AHgAeAAkACQArACsAKwArACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgBcAEsASwBLAEsASwBLAEsASwBLAEsADQANAB4AHgAeAB4AXABcAFwAXABcAFwAKgAqACoAKgBcAFwAXABcACoAKgAqAFwAKgAqACoAXABcACoAKgAqACoAKgAqACoAXABcAFwAKgAqACoAKgBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKgAqAFwAKgBLAEsASwBLAEsASwBLAEsASwBLACoAKgAqACoAKgAqAFAAUABQAFAAUABQACsAUAArACsAKwArACsAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgBQAFAAUABQAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUAArACsAUABQAFAAUABQAFAAUAArAFAAKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAKwBQACsAUABQAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsABAAEAAQAHgANAB4AHgAeAB4AHgAeAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUAArACsADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAANAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAWABEAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAA0ADQANAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAANAA0AKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUAArAAQABAArACsAKwArACsAKwArACsAKwArACsAKwBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqAA0ADQAVAFwADQAeAA0AGwBcACoAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwAeAB4AEwATAA0ADQAOAB4AEwATAB4ABAAEAAQACQArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUAAEAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAHgArACsAKwATABMASwBLAEsASwBLAEsASwBLAEsASwBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAArACsAXABcAFwAXABcACsAKwArACsAKwArACsAKwArACsAKwBcAFwAXABcAFwAXABcAFwAXABcAFwAXAArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAXAArACsAKwAqACoAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAArACsAHgAeAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKwAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKwArAAQASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArACoAKgAqACoAKgAqACoAXAAqACoAKgAqACoAKgArACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABABQAFAAUABQAFAAUABQACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwANAA0AHgANAA0ADQANAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAEAAQAHgAeAB4AHgAeAB4AHgAeAB4AKwArACsABAAEAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwAeAB4AHgAeAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArAA0ADQANAA0ADQBLAEsASwBLAEsASwBLAEsASwBLACsAKwArAFAAUABQAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAA0ADQBQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUAAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArAAQABAAEAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAAQAUABQAFAAUABQAFAABABQAFAABAAEAAQAUAArACsAKwArACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsABAAEAAQABAAEAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAKwBQACsAUAArAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgBQAB4AHgAeAFAAUABQACsAHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQACsAKwAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQACsAHgAeAB4AHgAeAB4AHgAOAB4AKwANAA0ADQANAA0ADQANAAkADQANAA0ACAAEAAsABAAEAA0ACQANAA0ADAAdAB0AHgAXABcAFgAXABcAFwAWABcAHQAdAB4AHgAUABQAFAANAAEAAQAEAAQABAAEAAQACQAaABoAGgAaABoAGgAaABoAHgAXABcAHQAVABUAHgAeAB4AHgAeAB4AGAAWABEAFQAVABUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ADQAeAA0ADQANAA0AHgANAA0ADQAHAB4AHgAeAB4AKwAEAAQABAAEAAQABAAEAAQABAAEAFAAUAArACsATwBQAFAAUABQAFAAHgAeAB4AFgARAE8AUABPAE8ATwBPAFAAUABQAFAAUAAeAB4AHgAWABEAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArABsAGwAbABsAGwAbABsAGgAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGgAbABsAGwAbABoAGwAbABoAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAHgAeAFAAGgAeAB0AHgBQAB4AGgAeAB4AHgAeAB4AHgAeAB4AHgBPAB4AUAAbAB4AHgBQAFAAUABQAFAAHgAeAB4AHQAdAB4AUAAeAFAAHgBQAB4AUABPAFAAUAAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAHgBQAFAAUABQAE8ATwBQAFAAUABQAFAATwBQAFAATwBQAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAFAAUABQAFAATwBPAE8ATwBPAE8ATwBPAE8ATwBQAFAAUABQAFAAUABQAFAAUAAeAB4AUABQAFAAUABPAB4AHgArACsAKwArAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHQAdAB4AHgAeAB0AHQAeAB4AHQAeAB4AHgAdAB4AHQAbABsAHgAdAB4AHgAeAB4AHQAeAB4AHQAdAB0AHQAeAB4AHQAeAB0AHgAdAB0AHQAdAB0AHQAeAB0AHgAeAB4AHgAeAB0AHQAdAB0AHgAeAB4AHgAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHgAeAB0AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHgAeAB0AHQAdAB0AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAeAB4AHgAdAB4AHgAeAB4AHgAeAB4AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABYAEQAWABEAHgAeAB4AHgAeAB4AHQAeAB4AHgAeAB4AHgAeACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAWABEAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAFAAHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAeAB4AHQAdAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHQAdAB4AHgAeAB4AHQAdAB0AHgAeAB0AHgAeAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlAB4AHQAdAB4AHgAdAB4AHgAeAB4AHQAdAB4AHgAeAB4AJQAlAB0AHQAlAB4AJQAlACUAIAAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAeAB4AHgAeAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHgAdAB0AHQAeAB0AJQAdAB0AHgAdAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAdAB0AHQAdACUAHgAlACUAJQAdACUAJQAdAB0AHQAlACUAHQAdACUAHQAdACUAJQAlAB4AHQAeAB4AHgAeAB0AHQAlAB0AHQAdAB0AHQAdACUAJQAlACUAJQAdACUAJQAgACUAHQAdACUAJQAlACUAJQAlACUAJQAeAB4AHgAlACUAIAAgACAAIAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AFwAXABcAFwAXABcAHgATABMAJQAeAB4AHgAWABEAFgARABYAEQAWABEAFgARABYAEQAWABEATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABYAEQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAWABEAFgARABYAEQAWABEAFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFgARABYAEQAWABEAFgARABYAEQAWABEAFgARABYAEQAWABEAFgARABYAEQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAWABEAFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAEAAQABAAeAB4AKwArACsAKwArABMADQANAA0AUAATAA0AUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAUAANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAA0ADQANAA0ADQANAA0ADQAeAA0AFgANAB4AHgAXABcAHgAeABcAFwAWABEAFgARABYAEQAWABEADQANAA0ADQATAFAADQANAB4ADQANAB4AHgAeAB4AHgAMAAwADQANAA0AHgANAA0AFgANAA0ADQANAA0ADQANAA0AHgANAB4ADQANAB4AHgAeACsAKwArACsAKwArACsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwArACsAKwArACsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArAA0AEQARACUAJQBHAFcAVwAWABEAFgARABYAEQAWABEAFgARACUAJQAWABEAFgARABYAEQAWABEAFQAWABEAEQAlAFcAVwBXAFcAVwBXAFcAVwBXAAQABAAEAAQABAAEACUAVwBXAFcAVwA2ACUAJQBXAFcAVwBHAEcAJQAlACUAKwBRAFcAUQBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFEAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBRAFcAUQBXAFEAVwBXAFcAVwBXAFcAUQBXAFcAVwBXAFcAVwBRAFEAKwArAAQABAAVABUARwBHAFcAFQBRAFcAUQBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBRAFcAVwBXAFcAVwBXAFEAUQBXAFcAVwBXABUAUQBHAEcAVwArACsAKwArACsAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwAlACUAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACsAKwArACsAKwArACsAKwArACsAKwArAFEAUQBRAFEAUQBRAFEAUQBRAFEAUQBRAFEAUQBRAFEAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBPAE8ATwBPAE8ATwBPAE8AJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAEcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAADQATAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABLAEsASwBLAEsASwBLAEsASwBLAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAABAAEAAQABAAeAAQABAAEAAQABAAEAAQABAAEAAQAHgBQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUABQAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAeAA0ADQANAA0ADQArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAB4AHgAeAB4AHgAeAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AUABQAFAAUABQAFAAUABQAFAAUABQAAQAUABQAFAABABQAFAAUABQAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAeAB4AHgAeAAQAKwArACsAUABQAFAAUABQAFAAHgAeABoAHgArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAADgAOABMAEwArACsAKwArACsAKwArACsABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwANAA0ASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAFAAUAAeAB4AHgBQAA4AUABQAAQAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAA0ADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArAB4AWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYACsAKwArAAQAHgAeAB4AHgAeAB4ADQANAA0AHgAeAB4AHgArAFAASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArAB4AHgBcAFwAXABcAFwAKgBcAFwAXABcAFwAXABcAFwAXABcAEsASwBLAEsASwBLAEsASwBLAEsAXABcAFwAXABcACsAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArAFAAUABQAAQAUABQAFAAUABQAFAAUABQAAQABAArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAHgANAA0ADQBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAXAAqACoAKgBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAAqAFwAKgAqACoAXABcACoAKgBcAFwAXABcAFwAKgAqAFwAKgBcACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcACoAKgBQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAA0ADQBQAFAAUAAEAAQAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUAArACsAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQADQAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAVABVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBUAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVACsAKwArACsAKwArACsAKwArACsAKwArAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAKwArACsAKwBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAKwArACsAKwAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAKwArACsAKwArAFYABABWAFYAVgBWAFYAVgBWAFYAVgBWAB4AVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgArAFYAVgBWAFYAVgArAFYAKwBWAFYAKwBWAFYAKwBWAFYAVgBWAFYAVgBWAFYAVgBWAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAEQAWAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAaAB4AKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAGAARABEAGAAYABMAEwAWABEAFAArACsAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACUAJQAlACUAJQAWABEAFgARABYAEQAWABEAFgARABYAEQAlACUAFgARACUAJQAlACUAJQAlACUAEQAlABEAKwAVABUAEwATACUAFgARABYAEQAWABEAJQAlACUAJQAlACUAJQAlACsAJQAbABoAJQArACsAKwArAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAcAKwATACUAJQAbABoAJQAlABYAEQAlACUAEQAlABEAJQBXAFcAVwBXAFcAVwBXAFcAVwBXABUAFQAlACUAJQATACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXABYAJQARACUAJQAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAWACUAEQAlABYAEQARABYAEQARABUAVwBRAFEAUQBRAFEAUQBRAFEAUQBRAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAEcARwArACsAVwBXAFcAVwBXAFcAKwArAFcAVwBXAFcAVwBXACsAKwBXAFcAVwBXAFcAVwArACsAVwBXAFcAKwArACsAGgAbACUAJQAlABsAGwArAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwAEAAQABAAQAB0AKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsADQANAA0AKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAAQAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAA0AUABQAFAAUAArACsAKwArAFAAUABQAFAAUABQAFAAUAANAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwAeACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAKwArAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUAArACsAKwBQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwANAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAUABQAFAAUABQAAQABAAEACsABAAEACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAKwBQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEACsAKwArACsABABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAA0ADQANAA0ADQANAA0ADQAeACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAArACsAKwArAFAAUABQAFAAUAANAA0ADQANAA0ADQAUACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsADQANAA0ADQANAA0ADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAAQABAAEAAQAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArAAQABAANACsAKwBQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAB4AHgAeAB4AHgArACsAKwArACsAKwAEAAQABAAEAAQABAAEAA0ADQAeAB4AHgAeAB4AKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwAeACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsASwBLAEsASwBLAEsASwBLAEsASwANAA0ADQANAFAABAAEAFAAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAeAA4AUAArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAADQANAB4ADQAEAAQABAAEAB4ABAAEAEsASwBLAEsASwBLAEsASwBLAEsAUAAOAFAADQANAA0AKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAANAA0AHgANAA0AHgAEACsAUABQAFAAUABQAFAAUAArAFAAKwBQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAA0AKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsABAAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQACsABAAEAFAABAAEAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABAArACsAUAArACsAKwArACsAKwAEACsAKwArACsAKwBQAFAAUABQAFAABAAEACsAKwAEAAQABAAEAAQABAAEACsAKwArAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAAQABABQAFAAUABQAA0ADQANAA0AHgBLAEsASwBLAEsASwBLAEsASwBLAA0ADQArAB4ABABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAFAAUAAeAFAAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAArACsABAAEAAQABAAEAAQABAAEAAQADgANAA0AEwATAB4AHgAeAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAFAAUABQAFAABAAEACsAKwAEAA0ADQAeAFAAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKwArACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBcAFwADQANAA0AKgBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAKwArAFAAKwArAFAAUABQAFAAUABQAFAAUAArAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQAKwAEAAQAKwArAAQABAAEAAQAUAAEAFAABAAEAA0ADQANACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAArACsABAAEAAQABAAEAAQABABQAA4AUAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAFAABAAEAAQABAAOAB4ADQANAA0ADQAOAB4ABAArACsAKwArACsAKwArACsAUAAEAAQABAAEAAQABAAEAAQABAAEAAQAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAA0ADQANAFAADgAOAA4ADQANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEACsABAAEAAQABAAEAAQABAAEAFAADQANAA0ADQANACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwAOABMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAArACsAKwAEACsABAAEACsABAAEAAQABAAEAAQABABQAAQAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAKwBQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQAKwAEAAQAKwAEAAQABAAEAAQAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAaABoAGgAaAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsADQANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAASABIAEgAQwBDAEMAUABQAFAAUABDAFAAUABQAEgAQwBIAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAASABDAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwAJAAkACQAJAAkACQAJABYAEQArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABIAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwANAA0AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEAAQABAANACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAA0ADQANAB4AHgAeAB4AHgAeAFAAUABQAFAADQAeACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAANAA0AHgAeACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwAEAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAARwBHABUARwAJACsAKwArACsAKwArACsAKwArACsAKwAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACsAKwArACsAKwArACsAKwBXAFcAVwBXAFcAVwBXAFcAVwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUQBRAFEAKwArACsAKwArACsAKwArACsAKwArACsAKwBRAFEAUQBRACsAKwArACsAKwArACsAKwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArACsAHgAEAAQADQAEAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArAB4AHgAeAB4AHgAeAB4AKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAAQABAAEAAQABAAeAB4AHgAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAB4AHgAEAAQABAAEAAQABAAEAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQAHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwBQAFAAKwArAFAAKwArAFAAUAArACsAUABQAFAAUAArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAUAArAFAAUABQAFAAUABQAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAHgAeAFAAUABQAFAAUAArAFAAKwArACsAUABQAFAAUABQAFAAUAArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeACsAKwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4ABAAeAB4AHgAeAB4AHgAeAB4AHgAeAAQAHgAeAA0ADQANAA0AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAAQAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArAAQABAAEAAQABAAEAAQAKwAEAAQAKwAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwBQAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArABsAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArAB4AHgAeAB4ABAAEAAQABAAEAAQABABQACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArABYAFgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAGgBQAFAAUAAaAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAKwBQACsAKwBQACsAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwBQACsAUAArACsAKwArACsAKwBQACsAKwArACsAUAArAFAAKwBQACsAUABQAFAAKwBQAFAAKwBQACsAKwBQACsAUAArAFAAKwBQACsAUAArAFAAUAArAFAAKwArAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUAArAFAAUABQAFAAKwBQACsAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAUABQAFAAKwBQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8AJQAlACUAHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB4AHgAeACUAJQAlAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAlACUAJQAlACUAHgAlACUAJQAlACUAIAAgACAAJQAlACAAJQAlACAAIAAgACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACEAIQAhACEAIQAlACUAIAAgACUAJQAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlACUAIAAlACUAJQAlACAAIAAgACUAIAAgACAAJQAlACUAJQAlACUAJQAgACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAlAB4AJQAeACUAJQAlACUAJQAgACUAJQAlACUAHgAlAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAgACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACAAIAAgACUAJQAlACAAIAAgACAAIAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABcAFwAXABUAFQAVAB4AHgAeAB4AJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAgACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAgACUAJQAgACUAJQAlACUAJQAlACUAJQAgACAAIAAgACAAIAAgACAAJQAlACUAJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAgACAAIAAgACAAIAAgACAAIAAgACUAJQAgACAAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAgACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAlACAAIAAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAgACAAIAAlACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwArAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACUAVwBXACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAA==';\n\n    var LETTER_NUMBER_MODIFIER = 50;\n    // Non-tailorable Line Breaking Classes\n    var BK = 1; //  Cause a line break (after)\n    var CR$1 = 2; //  Cause a line break (after), except between CR and LF\n    var LF$1 = 3; //  Cause a line break (after)\n    var CM = 4; //  Prohibit a line break between the character and the preceding character\n    var NL = 5; //  Cause a line break (after)\n    var WJ = 7; //  Prohibit line breaks before and after\n    var ZW = 8; //  Provide a break opportunity\n    var GL = 9; //  Prohibit line breaks before and after\n    var SP = 10; // Enable indirect line breaks\n    var ZWJ$1 = 11; // Prohibit line breaks within joiner sequences\n    // Break Opportunities\n    var B2 = 12; //  Provide a line break opportunity before and after the character\n    var BA = 13; //  Generally provide a line break opportunity after the character\n    var BB = 14; //  Generally provide a line break opportunity before the character\n    var HY = 15; //  Provide a line break opportunity after the character, except in numeric context\n    var CB = 16; //   Provide a line break opportunity contingent on additional information\n    // Characters Prohibiting Certain Breaks\n    var CL = 17; //  Prohibit line breaks before\n    var CP = 18; //  Prohibit line breaks before\n    var EX = 19; //  Prohibit line breaks before\n    var IN = 20; //  Allow only indirect line breaks between pairs\n    var NS = 21; //  Allow only indirect line breaks before\n    var OP = 22; //  Prohibit line breaks after\n    var QU = 23; //  Act like they are both opening and closing\n    // Numeric Context\n    var IS = 24; //  Prevent breaks after any and before numeric\n    var NU = 25; //  Form numeric expressions for line breaking purposes\n    var PO = 26; //  Do not break following a numeric expression\n    var PR = 27; //  Do not break in front of a numeric expression\n    var SY = 28; //  Prevent a break before; and allow a break after\n    // Other Characters\n    var AI = 29; //  Act like AL when the resolvedEAW is N; otherwise; act as ID\n    var AL = 30; //  Are alphabetic characters or symbols that are used with alphabetic characters\n    var CJ = 31; //  Treat as NS or ID for strict or normal breaking.\n    var EB = 32; //  Do not break from following Emoji Modifier\n    var EM = 33; //  Do not break from preceding Emoji Base\n    var H2 = 34; //  Form Korean syllable blocks\n    var H3 = 35; //  Form Korean syllable blocks\n    var HL = 36; //  Do not break around a following hyphen; otherwise act as Alphabetic\n    var ID = 37; //  Break before or after; except in some numeric context\n    var JL = 38; //  Form Korean syllable blocks\n    var JV = 39; //  Form Korean syllable blocks\n    var JT = 40; //  Form Korean syllable blocks\n    var RI$1 = 41; //  Keep pairs together. For pairs; break before and after other classes\n    var SA = 42; //  Provide a line break opportunity contingent on additional, language-specific context analysis\n    var XX = 43; //  Have as yet unknown line breaking behavior or unassigned code positions\n    var ea_OP = [0x2329, 0xff08];\n    var BREAK_MANDATORY = '!';\n    var BREAK_NOT_ALLOWED$1 = '';\n    var BREAK_ALLOWED$1 = '';\n    var UnicodeTrie$1 = createTrieFromBase64$1(base64$1);\n    var ALPHABETICS = [AL, HL];\n    var HARD_LINE_BREAKS = [BK, CR$1, LF$1, NL];\n    var SPACE$1 = [SP, ZW];\n    var PREFIX_POSTFIX = [PR, PO];\n    var LINE_BREAKS = HARD_LINE_BREAKS.concat(SPACE$1);\n    var KOREAN_SYLLABLE_BLOCK = [JL, JV, JT, H2, H3];\n    var HYPHEN = [HY, BA];\n    var codePointsToCharacterClasses = function (codePoints, lineBreak) {\n        if (lineBreak === void 0) { lineBreak = 'strict'; }\n        var types = [];\n        var indices = [];\n        var categories = [];\n        codePoints.forEach(function (codePoint, index) {\n            var classType = UnicodeTrie$1.get(codePoint);\n            if (classType > LETTER_NUMBER_MODIFIER) {\n                categories.push(true);\n                classType -= LETTER_NUMBER_MODIFIER;\n            }\n            else {\n                categories.push(false);\n            }\n            if (['normal', 'auto', 'loose'].indexOf(lineBreak) !== -1) {\n                // U+2010,  U+2013,  U+301C,  U+30A0\n                if ([0x2010, 0x2013, 0x301c, 0x30a0].indexOf(codePoint) !== -1) {\n                    indices.push(index);\n                    return types.push(CB);\n                }\n            }\n            if (classType === CM || classType === ZWJ$1) {\n                // LB10 Treat any remaining combining mark or ZWJ as AL.\n                if (index === 0) {\n                    indices.push(index);\n                    return types.push(AL);\n                }\n                // LB9 Do not break a combining character sequence; treat it as if it has the line breaking class of\n                // the base character in all of the following rules. Treat ZWJ as if it were CM.\n                var prev = types[index - 1];\n                if (LINE_BREAKS.indexOf(prev) === -1) {\n                    indices.push(indices[index - 1]);\n                    return types.push(prev);\n                }\n                indices.push(index);\n                return types.push(AL);\n            }\n            indices.push(index);\n            if (classType === CJ) {\n                return types.push(lineBreak === 'strict' ? NS : ID);\n            }\n            if (classType === SA) {\n                return types.push(AL);\n            }\n            if (classType === AI) {\n                return types.push(AL);\n            }\n            // For supplementary characters, a useful default is to treat characters in the range 10000..1FFFD as AL\n            // and characters in the ranges 20000..2FFFD and 30000..3FFFD as ID, until the implementation can be revised\n            // to take into account the actual line breaking properties for these characters.\n            if (classType === XX) {\n                if ((codePoint >= 0x20000 && codePoint <= 0x2fffd) || (codePoint >= 0x30000 && codePoint <= 0x3fffd)) {\n                    return types.push(ID);\n                }\n                else {\n                    return types.push(AL);\n                }\n            }\n            types.push(classType);\n        });\n        return [indices, types, categories];\n    };\n    var isAdjacentWithSpaceIgnored = function (a, b, currentIndex, classTypes) {\n        var current = classTypes[currentIndex];\n        if (Array.isArray(a) ? a.indexOf(current) !== -1 : a === current) {\n            var i = currentIndex;\n            while (i <= classTypes.length) {\n                i++;\n                var next = classTypes[i];\n                if (next === b) {\n                    return true;\n                }\n                if (next !== SP) {\n                    break;\n                }\n            }\n        }\n        if (current === SP) {\n            var i = currentIndex;\n            while (i > 0) {\n                i--;\n                var prev = classTypes[i];\n                if (Array.isArray(a) ? a.indexOf(prev) !== -1 : a === prev) {\n                    var n = currentIndex;\n                    while (n <= classTypes.length) {\n                        n++;\n                        var next = classTypes[n];\n                        if (next === b) {\n                            return true;\n                        }\n                        if (next !== SP) {\n                            break;\n                        }\n                    }\n                }\n                if (prev !== SP) {\n                    break;\n                }\n            }\n        }\n        return false;\n    };\n    var previousNonSpaceClassType = function (currentIndex, classTypes) {\n        var i = currentIndex;\n        while (i >= 0) {\n            var type = classTypes[i];\n            if (type === SP) {\n                i--;\n            }\n            else {\n                return type;\n            }\n        }\n        return 0;\n    };\n    var _lineBreakAtIndex = function (codePoints, classTypes, indicies, index, forbiddenBreaks) {\n        if (indicies[index] === 0) {\n            return BREAK_NOT_ALLOWED$1;\n        }\n        var currentIndex = index - 1;\n        if (Array.isArray(forbiddenBreaks) && forbiddenBreaks[currentIndex] === true) {\n            return BREAK_NOT_ALLOWED$1;\n        }\n        var beforeIndex = currentIndex - 1;\n        var afterIndex = currentIndex + 1;\n        var current = classTypes[currentIndex];\n        // LB4 Always break after hard line breaks.\n        // LB5 Treat CR followed by LF, as well as CR, LF, and NL as hard line breaks.\n        var before = beforeIndex >= 0 ? classTypes[beforeIndex] : 0;\n        var next = classTypes[afterIndex];\n        if (current === CR$1 && next === LF$1) {\n            return BREAK_NOT_ALLOWED$1;\n        }\n        if (HARD_LINE_BREAKS.indexOf(current) !== -1) {\n            return BREAK_MANDATORY;\n        }\n        // LB6 Do not break before hard line breaks.\n        if (HARD_LINE_BREAKS.indexOf(next) !== -1) {\n            return BREAK_NOT_ALLOWED$1;\n        }\n        // LB7 Do not break before spaces or zero width space.\n        if (SPACE$1.indexOf(next) !== -1) {\n            return BREAK_NOT_ALLOWED$1;\n        }\n        // LB8 Break before any character following a zero-width space, even if one or more spaces intervene.\n        if (previousNonSpaceClassType(currentIndex, classTypes) === ZW) {\n            return BREAK_ALLOWED$1;\n        }\n        // LB8a Do not break after a zero width joiner.\n        if (UnicodeTrie$1.get(codePoints[currentIndex]) === ZWJ$1) {\n            return BREAK_NOT_ALLOWED$1;\n        }\n        // zwj emojis\n        if ((current === EB || current === EM) && UnicodeTrie$1.get(codePoints[afterIndex]) === ZWJ$1) {\n            return BREAK_NOT_ALLOWED$1;\n        }\n        // LB11 Do not break before or after Word joiner and related characters.\n        if (current === WJ || next === WJ) {\n            return BREAK_NOT_ALLOWED$1;\n        }\n        // LB12 Do not break after NBSP and related characters.\n        if (current === GL) {\n            return BREAK_NOT_ALLOWED$1;\n        }\n        // LB12a Do not break before NBSP and related characters, except after spaces and hyphens.\n        if ([SP, BA, HY].indexOf(current) === -1 && next === GL) {\n            return BREAK_NOT_ALLOWED$1;\n        }\n        // LB13 Do not break before ] or ! or ; or /, even after spaces.\n        if ([CL, CP, EX, IS, SY].indexOf(next) !== -1) {\n            return BREAK_NOT_ALLOWED$1;\n        }\n        // LB14 Do not break after [, even after spaces.\n        if (previousNonSpaceClassType(currentIndex, classTypes) === OP) {\n            return BREAK_NOT_ALLOWED$1;\n        }\n        // LB15 Do not break within [, even with intervening spaces.\n        if (isAdjacentWithSpaceIgnored(QU, OP, currentIndex, classTypes)) {\n            return BREAK_NOT_ALLOWED$1;\n        }\n        // LB16 Do not break between closing punctuation and a nonstarter (lb=NS), even with intervening spaces.\n        if (isAdjacentWithSpaceIgnored([CL, CP], NS, currentIndex, classTypes)) {\n            return BREAK_NOT_ALLOWED$1;\n        }\n        // LB17 Do not break within , even with intervening spaces.\n        if (isAdjacentWithSpaceIgnored(B2, B2, currentIndex, classTypes)) {\n            return BREAK_NOT_ALLOWED$1;\n        }\n        // LB18 Break after spaces.\n        if (current === SP) {\n            return BREAK_ALLOWED$1;\n        }\n        // LB19 Do not break before or after quotation marks, such as   .\n        if (current === QU || next === QU) {\n            return BREAK_NOT_ALLOWED$1;\n        }\n        // LB20 Break before and after unresolved CB.\n        if (next === CB || current === CB) {\n            return BREAK_ALLOWED$1;\n        }\n        // LB21 Do not break before hyphen-minus, other hyphens, fixed-width spaces, small kana, and other non-starters, or after acute accents.\n        if ([BA, HY, NS].indexOf(next) !== -1 || current === BB) {\n            return BREAK_NOT_ALLOWED$1;\n        }\n        // LB21a Don't break after Hebrew + Hyphen.\n        if (before === HL && HYPHEN.indexOf(current) !== -1) {\n            return BREAK_NOT_ALLOWED$1;\n        }\n        // LB21b Dont break between Solidus and Hebrew letters.\n        if (current === SY && next === HL) {\n            return BREAK_NOT_ALLOWED$1;\n        }\n        // LB22 Do not break before ellipsis.\n        if (next === IN) {\n            return BREAK_NOT_ALLOWED$1;\n        }\n        // LB23 Do not break between digits and letters.\n        if ((ALPHABETICS.indexOf(next) !== -1 && current === NU) || (ALPHABETICS.indexOf(current) !== -1 && next === NU)) {\n            return BREAK_NOT_ALLOWED$1;\n        }\n        // LB23a Do not break between numeric prefixes and ideographs, or between ideographs and numeric postfixes.\n        if ((current === PR && [ID, EB, EM].indexOf(next) !== -1) ||\n            ([ID, EB, EM].indexOf(current) !== -1 && next === PO)) {\n            return BREAK_NOT_ALLOWED$1;\n        }\n        // LB24 Do not break between numeric prefix/postfix and letters, or between letters and prefix/postfix.\n        if ((ALPHABETICS.indexOf(current) !== -1 && PREFIX_POSTFIX.indexOf(next) !== -1) ||\n            (PREFIX_POSTFIX.indexOf(current) !== -1 && ALPHABETICS.indexOf(next) !== -1)) {\n            return BREAK_NOT_ALLOWED$1;\n        }\n        // LB25 Do not break between the following pairs of classes relevant to numbers:\n        if (\n        // (PR | PO)  ( OP | HY )? NU\n        ([PR, PO].indexOf(current) !== -1 &&\n            (next === NU || ([OP, HY].indexOf(next) !== -1 && classTypes[afterIndex + 1] === NU))) ||\n            // ( OP | HY )  NU\n            ([OP, HY].indexOf(current) !== -1 && next === NU) ||\n            // NU \t(NU | SY | IS)\n            (current === NU && [NU, SY, IS].indexOf(next) !== -1)) {\n            return BREAK_NOT_ALLOWED$1;\n        }\n        // NU (NU | SY | IS)*  (NU | SY | IS | CL | CP)\n        if ([NU, SY, IS, CL, CP].indexOf(next) !== -1) {\n            var prevIndex = currentIndex;\n            while (prevIndex >= 0) {\n                var type = classTypes[prevIndex];\n                if (type === NU) {\n                    return BREAK_NOT_ALLOWED$1;\n                }\n                else if ([SY, IS].indexOf(type) !== -1) {\n                    prevIndex--;\n                }\n                else {\n                    break;\n                }\n            }\n        }\n        // NU (NU | SY | IS)* (CL | CP)?  (PO | PR))\n        if ([PR, PO].indexOf(next) !== -1) {\n            var prevIndex = [CL, CP].indexOf(current) !== -1 ? beforeIndex : currentIndex;\n            while (prevIndex >= 0) {\n                var type = classTypes[prevIndex];\n                if (type === NU) {\n                    return BREAK_NOT_ALLOWED$1;\n                }\n                else if ([SY, IS].indexOf(type) !== -1) {\n                    prevIndex--;\n                }\n                else {\n                    break;\n                }\n            }\n        }\n        // LB26 Do not break a Korean syllable.\n        if ((JL === current && [JL, JV, H2, H3].indexOf(next) !== -1) ||\n            ([JV, H2].indexOf(current) !== -1 && [JV, JT].indexOf(next) !== -1) ||\n            ([JT, H3].indexOf(current) !== -1 && next === JT)) {\n            return BREAK_NOT_ALLOWED$1;\n        }\n        // LB27 Treat a Korean Syllable Block the same as ID.\n        if ((KOREAN_SYLLABLE_BLOCK.indexOf(current) !== -1 && [IN, PO].indexOf(next) !== -1) ||\n            (KOREAN_SYLLABLE_BLOCK.indexOf(next) !== -1 && current === PR)) {\n            return BREAK_NOT_ALLOWED$1;\n        }\n        // LB28 Do not break between alphabetics (at).\n        if (ALPHABETICS.indexOf(current) !== -1 && ALPHABETICS.indexOf(next) !== -1) {\n            return BREAK_NOT_ALLOWED$1;\n        }\n        // LB29 Do not break between numeric punctuation and alphabetics (e.g.).\n        if (current === IS && ALPHABETICS.indexOf(next) !== -1) {\n            return BREAK_NOT_ALLOWED$1;\n        }\n        // LB30 Do not break between letters, numbers, or ordinary symbols and opening or closing parentheses.\n        if ((ALPHABETICS.concat(NU).indexOf(current) !== -1 &&\n            next === OP &&\n            ea_OP.indexOf(codePoints[afterIndex]) === -1) ||\n            (ALPHABETICS.concat(NU).indexOf(next) !== -1 && current === CP)) {\n            return BREAK_NOT_ALLOWED$1;\n        }\n        // LB30a Break between two regional indicator symbols if and only if there are an even number of regional\n        // indicators preceding the position of the break.\n        if (current === RI$1 && next === RI$1) {\n            var i = indicies[currentIndex];\n            var count = 1;\n            while (i > 0) {\n                i--;\n                if (classTypes[i] === RI$1) {\n                    count++;\n                }\n                else {\n                    break;\n                }\n            }\n            if (count % 2 !== 0) {\n                return BREAK_NOT_ALLOWED$1;\n            }\n        }\n        // LB30b Do not break between an emoji base and an emoji modifier.\n        if (current === EB && next === EM) {\n            return BREAK_NOT_ALLOWED$1;\n        }\n        return BREAK_ALLOWED$1;\n    };\n    var cssFormattedClasses = function (codePoints, options) {\n        if (!options) {\n            options = { lineBreak: 'normal', wordBreak: 'normal' };\n        }\n        var _a = codePointsToCharacterClasses(codePoints, options.lineBreak), indicies = _a[0], classTypes = _a[1], isLetterNumber = _a[2];\n        if (options.wordBreak === 'break-all' || options.wordBreak === 'break-word') {\n            classTypes = classTypes.map(function (type) { return ([NU, AL, SA].indexOf(type) !== -1 ? ID : type); });\n        }\n        var forbiddenBreakpoints = options.wordBreak === 'keep-all'\n            ? isLetterNumber.map(function (letterNumber, i) {\n                return letterNumber && codePoints[i] >= 0x4e00 && codePoints[i] <= 0x9fff;\n            })\n            : undefined;\n        return [indicies, classTypes, forbiddenBreakpoints];\n    };\n    var Break = /** @class */ (function () {\n        function Break(codePoints, lineBreak, start, end) {\n            this.codePoints = codePoints;\n            this.required = lineBreak === BREAK_MANDATORY;\n            this.start = start;\n            this.end = end;\n        }\n        Break.prototype.slice = function () {\n            return fromCodePoint$1.apply(void 0, this.codePoints.slice(this.start, this.end));\n        };\n        return Break;\n    }());\n    var LineBreaker = function (str, options) {\n        var codePoints = toCodePoints$1(str);\n        var _a = cssFormattedClasses(codePoints, options), indicies = _a[0], classTypes = _a[1], forbiddenBreakpoints = _a[2];\n        var length = codePoints.length;\n        var lastEnd = 0;\n        var nextIndex = 0;\n        return {\n            next: function () {\n                if (nextIndex >= length) {\n                    return { done: true, value: null };\n                }\n                var lineBreak = BREAK_NOT_ALLOWED$1;\n                while (nextIndex < length &&\n                    (lineBreak = _lineBreakAtIndex(codePoints, classTypes, indicies, ++nextIndex, forbiddenBreakpoints)) ===\n                        BREAK_NOT_ALLOWED$1) { }\n                if (lineBreak !== BREAK_NOT_ALLOWED$1 || nextIndex === length) {\n                    var value = new Break(codePoints, lineBreak, lastEnd, nextIndex);\n                    lastEnd = nextIndex;\n                    return { value: value, done: false };\n                }\n                return { done: true, value: null };\n            },\n        };\n    };\n\n    // https://www.w3.org/TR/css-syntax-3\n    var FLAG_UNRESTRICTED = 1 << 0;\n    var FLAG_ID = 1 << 1;\n    var FLAG_INTEGER = 1 << 2;\n    var FLAG_NUMBER = 1 << 3;\n    var LINE_FEED = 0x000a;\n    var SOLIDUS = 0x002f;\n    var REVERSE_SOLIDUS = 0x005c;\n    var CHARACTER_TABULATION = 0x0009;\n    var SPACE = 0x0020;\n    var QUOTATION_MARK = 0x0022;\n    var EQUALS_SIGN = 0x003d;\n    var NUMBER_SIGN = 0x0023;\n    var DOLLAR_SIGN = 0x0024;\n    var PERCENTAGE_SIGN = 0x0025;\n    var APOSTROPHE = 0x0027;\n    var LEFT_PARENTHESIS = 0x0028;\n    var RIGHT_PARENTHESIS = 0x0029;\n    var LOW_LINE = 0x005f;\n    var HYPHEN_MINUS = 0x002d;\n    var EXCLAMATION_MARK = 0x0021;\n    var LESS_THAN_SIGN = 0x003c;\n    var GREATER_THAN_SIGN = 0x003e;\n    var COMMERCIAL_AT = 0x0040;\n    var LEFT_SQUARE_BRACKET = 0x005b;\n    var RIGHT_SQUARE_BRACKET = 0x005d;\n    var CIRCUMFLEX_ACCENT = 0x003d;\n    var LEFT_CURLY_BRACKET = 0x007b;\n    var QUESTION_MARK = 0x003f;\n    var RIGHT_CURLY_BRACKET = 0x007d;\n    var VERTICAL_LINE = 0x007c;\n    var TILDE = 0x007e;\n    var CONTROL = 0x0080;\n    var REPLACEMENT_CHARACTER = 0xfffd;\n    var ASTERISK = 0x002a;\n    var PLUS_SIGN = 0x002b;\n    var COMMA = 0x002c;\n    var COLON = 0x003a;\n    var SEMICOLON = 0x003b;\n    var FULL_STOP = 0x002e;\n    var NULL = 0x0000;\n    var BACKSPACE = 0x0008;\n    var LINE_TABULATION = 0x000b;\n    var SHIFT_OUT = 0x000e;\n    var INFORMATION_SEPARATOR_ONE = 0x001f;\n    var DELETE = 0x007f;\n    var EOF = -1;\n    var ZERO = 0x0030;\n    var a = 0x0061;\n    var e = 0x0065;\n    var f = 0x0066;\n    var u = 0x0075;\n    var z = 0x007a;\n    var A = 0x0041;\n    var E = 0x0045;\n    var F = 0x0046;\n    var U = 0x0055;\n    var Z = 0x005a;\n    var isDigit = function (codePoint) { return codePoint >= ZERO && codePoint <= 0x0039; };\n    var isSurrogateCodePoint = function (codePoint) { return codePoint >= 0xd800 && codePoint <= 0xdfff; };\n    var isHex = function (codePoint) {\n        return isDigit(codePoint) || (codePoint >= A && codePoint <= F) || (codePoint >= a && codePoint <= f);\n    };\n    var isLowerCaseLetter = function (codePoint) { return codePoint >= a && codePoint <= z; };\n    var isUpperCaseLetter = function (codePoint) { return codePoint >= A && codePoint <= Z; };\n    var isLetter = function (codePoint) { return isLowerCaseLetter(codePoint) || isUpperCaseLetter(codePoint); };\n    var isNonASCIICodePoint = function (codePoint) { return codePoint >= CONTROL; };\n    var isWhiteSpace = function (codePoint) {\n        return codePoint === LINE_FEED || codePoint === CHARACTER_TABULATION || codePoint === SPACE;\n    };\n    var isNameStartCodePoint = function (codePoint) {\n        return isLetter(codePoint) || isNonASCIICodePoint(codePoint) || codePoint === LOW_LINE;\n    };\n    var isNameCodePoint = function (codePoint) {\n        return isNameStartCodePoint(codePoint) || isDigit(codePoint) || codePoint === HYPHEN_MINUS;\n    };\n    var isNonPrintableCodePoint = function (codePoint) {\n        return ((codePoint >= NULL && codePoint <= BACKSPACE) ||\n            codePoint === LINE_TABULATION ||\n            (codePoint >= SHIFT_OUT && codePoint <= INFORMATION_SEPARATOR_ONE) ||\n            codePoint === DELETE);\n    };\n    var isValidEscape = function (c1, c2) {\n        if (c1 !== REVERSE_SOLIDUS) {\n            return false;\n        }\n        return c2 !== LINE_FEED;\n    };\n    var isIdentifierStart = function (c1, c2, c3) {\n        if (c1 === HYPHEN_MINUS) {\n            return isNameStartCodePoint(c2) || isValidEscape(c2, c3);\n        }\n        else if (isNameStartCodePoint(c1)) {\n            return true;\n        }\n        else if (c1 === REVERSE_SOLIDUS && isValidEscape(c1, c2)) {\n            return true;\n        }\n        return false;\n    };\n    var isNumberStart = function (c1, c2, c3) {\n        if (c1 === PLUS_SIGN || c1 === HYPHEN_MINUS) {\n            if (isDigit(c2)) {\n                return true;\n            }\n            return c2 === FULL_STOP && isDigit(c3);\n        }\n        if (c1 === FULL_STOP) {\n            return isDigit(c2);\n        }\n        return isDigit(c1);\n    };\n    var stringToNumber = function (codePoints) {\n        var c = 0;\n        var sign = 1;\n        if (codePoints[c] === PLUS_SIGN || codePoints[c] === HYPHEN_MINUS) {\n            if (codePoints[c] === HYPHEN_MINUS) {\n                sign = -1;\n            }\n            c++;\n        }\n        var integers = [];\n        while (isDigit(codePoints[c])) {\n            integers.push(codePoints[c++]);\n        }\n        var int = integers.length ? parseInt(fromCodePoint$1.apply(void 0, integers), 10) : 0;\n        if (codePoints[c] === FULL_STOP) {\n            c++;\n        }\n        var fraction = [];\n        while (isDigit(codePoints[c])) {\n            fraction.push(codePoints[c++]);\n        }\n        var fracd = fraction.length;\n        var frac = fracd ? parseInt(fromCodePoint$1.apply(void 0, fraction), 10) : 0;\n        if (codePoints[c] === E || codePoints[c] === e) {\n            c++;\n        }\n        var expsign = 1;\n        if (codePoints[c] === PLUS_SIGN || codePoints[c] === HYPHEN_MINUS) {\n            if (codePoints[c] === HYPHEN_MINUS) {\n                expsign = -1;\n            }\n            c++;\n        }\n        var exponent = [];\n        while (isDigit(codePoints[c])) {\n            exponent.push(codePoints[c++]);\n        }\n        var exp = exponent.length ? parseInt(fromCodePoint$1.apply(void 0, exponent), 10) : 0;\n        return sign * (int + frac * Math.pow(10, -fracd)) * Math.pow(10, expsign * exp);\n    };\n    var LEFT_PARENTHESIS_TOKEN = {\n        type: 2 /* LEFT_PARENTHESIS_TOKEN */\n    };\n    var RIGHT_PARENTHESIS_TOKEN = {\n        type: 3 /* RIGHT_PARENTHESIS_TOKEN */\n    };\n    var COMMA_TOKEN = { type: 4 /* COMMA_TOKEN */ };\n    var SUFFIX_MATCH_TOKEN = { type: 13 /* SUFFIX_MATCH_TOKEN */ };\n    var PREFIX_MATCH_TOKEN = { type: 8 /* PREFIX_MATCH_TOKEN */ };\n    var COLUMN_TOKEN = { type: 21 /* COLUMN_TOKEN */ };\n    var DASH_MATCH_TOKEN = { type: 9 /* DASH_MATCH_TOKEN */ };\n    var INCLUDE_MATCH_TOKEN = { type: 10 /* INCLUDE_MATCH_TOKEN */ };\n    var LEFT_CURLY_BRACKET_TOKEN = {\n        type: 11 /* LEFT_CURLY_BRACKET_TOKEN */\n    };\n    var RIGHT_CURLY_BRACKET_TOKEN = {\n        type: 12 /* RIGHT_CURLY_BRACKET_TOKEN */\n    };\n    var SUBSTRING_MATCH_TOKEN = { type: 14 /* SUBSTRING_MATCH_TOKEN */ };\n    var BAD_URL_TOKEN = { type: 23 /* BAD_URL_TOKEN */ };\n    var BAD_STRING_TOKEN = { type: 1 /* BAD_STRING_TOKEN */ };\n    var CDO_TOKEN = { type: 25 /* CDO_TOKEN */ };\n    var CDC_TOKEN = { type: 24 /* CDC_TOKEN */ };\n    var COLON_TOKEN = { type: 26 /* COLON_TOKEN */ };\n    var SEMICOLON_TOKEN = { type: 27 /* SEMICOLON_TOKEN */ };\n    var LEFT_SQUARE_BRACKET_TOKEN = {\n        type: 28 /* LEFT_SQUARE_BRACKET_TOKEN */\n    };\n    var RIGHT_SQUARE_BRACKET_TOKEN = {\n        type: 29 /* RIGHT_SQUARE_BRACKET_TOKEN */\n    };\n    var WHITESPACE_TOKEN = { type: 31 /* WHITESPACE_TOKEN */ };\n    var EOF_TOKEN = { type: 32 /* EOF_TOKEN */ };\n    var Tokenizer = /** @class */ (function () {\n        function Tokenizer() {\n            this._value = [];\n        }\n        Tokenizer.prototype.write = function (chunk) {\n            this._value = this._value.concat(toCodePoints$1(chunk));\n        };\n        Tokenizer.prototype.read = function () {\n            var tokens = [];\n            var token = this.consumeToken();\n            while (token !== EOF_TOKEN) {\n                tokens.push(token);\n                token = this.consumeToken();\n            }\n            return tokens;\n        };\n        Tokenizer.prototype.consumeToken = function () {\n            var codePoint = this.consumeCodePoint();\n            switch (codePoint) {\n                case QUOTATION_MARK:\n                    return this.consumeStringToken(QUOTATION_MARK);\n                case NUMBER_SIGN:\n                    var c1 = this.peekCodePoint(0);\n                    var c2 = this.peekCodePoint(1);\n                    var c3 = this.peekCodePoint(2);\n                    if (isNameCodePoint(c1) || isValidEscape(c2, c3)) {\n                        var flags = isIdentifierStart(c1, c2, c3) ? FLAG_ID : FLAG_UNRESTRICTED;\n                        var value = this.consumeName();\n                        return { type: 5 /* HASH_TOKEN */, value: value, flags: flags };\n                    }\n                    break;\n                case DOLLAR_SIGN:\n                    if (this.peekCodePoint(0) === EQUALS_SIGN) {\n                        this.consumeCodePoint();\n                        return SUFFIX_MATCH_TOKEN;\n                    }\n                    break;\n                case APOSTROPHE:\n                    return this.consumeStringToken(APOSTROPHE);\n                case LEFT_PARENTHESIS:\n                    return LEFT_PARENTHESIS_TOKEN;\n                case RIGHT_PARENTHESIS:\n                    return RIGHT_PARENTHESIS_TOKEN;\n                case ASTERISK:\n                    if (this.peekCodePoint(0) === EQUALS_SIGN) {\n                        this.consumeCodePoint();\n                        return SUBSTRING_MATCH_TOKEN;\n                    }\n                    break;\n                case PLUS_SIGN:\n                    if (isNumberStart(codePoint, this.peekCodePoint(0), this.peekCodePoint(1))) {\n                        this.reconsumeCodePoint(codePoint);\n                        return this.consumeNumericToken();\n                    }\n                    break;\n                case COMMA:\n                    return COMMA_TOKEN;\n                case HYPHEN_MINUS:\n                    var e1 = codePoint;\n                    var e2 = this.peekCodePoint(0);\n                    var e3 = this.peekCodePoint(1);\n                    if (isNumberStart(e1, e2, e3)) {\n                        this.reconsumeCodePoint(codePoint);\n                        return this.consumeNumericToken();\n                    }\n                    if (isIdentifierStart(e1, e2, e3)) {\n                        this.reconsumeCodePoint(codePoint);\n                        return this.consumeIdentLikeToken();\n                    }\n                    if (e2 === HYPHEN_MINUS && e3 === GREATER_THAN_SIGN) {\n                        this.consumeCodePoint();\n                        this.consumeCodePoint();\n                        return CDC_TOKEN;\n                    }\n                    break;\n                case FULL_STOP:\n                    if (isNumberStart(codePoint, this.peekCodePoint(0), this.peekCodePoint(1))) {\n                        this.reconsumeCodePoint(codePoint);\n                        return this.consumeNumericToken();\n                    }\n                    break;\n                case SOLIDUS:\n                    if (this.peekCodePoint(0) === ASTERISK) {\n                        this.consumeCodePoint();\n                        while (true) {\n                            var c = this.consumeCodePoint();\n                            if (c === ASTERISK) {\n                                c = this.consumeCodePoint();\n                                if (c === SOLIDUS) {\n                                    return this.consumeToken();\n                                }\n                            }\n                            if (c === EOF) {\n                                return this.consumeToken();\n                            }\n                        }\n                    }\n                    break;\n                case COLON:\n                    return COLON_TOKEN;\n                case SEMICOLON:\n                    return SEMICOLON_TOKEN;\n                case LESS_THAN_SIGN:\n                    if (this.peekCodePoint(0) === EXCLAMATION_MARK &&\n                        this.peekCodePoint(1) === HYPHEN_MINUS &&\n                        this.peekCodePoint(2) === HYPHEN_MINUS) {\n                        this.consumeCodePoint();\n                        this.consumeCodePoint();\n                        return CDO_TOKEN;\n                    }\n                    break;\n                case COMMERCIAL_AT:\n                    var a1 = this.peekCodePoint(0);\n                    var a2 = this.peekCodePoint(1);\n                    var a3 = this.peekCodePoint(2);\n                    if (isIdentifierStart(a1, a2, a3)) {\n                        var value = this.consumeName();\n                        return { type: 7 /* AT_KEYWORD_TOKEN */, value: value };\n                    }\n                    break;\n                case LEFT_SQUARE_BRACKET:\n                    return LEFT_SQUARE_BRACKET_TOKEN;\n                case REVERSE_SOLIDUS:\n                    if (isValidEscape(codePoint, this.peekCodePoint(0))) {\n                        this.reconsumeCodePoint(codePoint);\n                        return this.consumeIdentLikeToken();\n                    }\n                    break;\n                case RIGHT_SQUARE_BRACKET:\n                    return RIGHT_SQUARE_BRACKET_TOKEN;\n                case CIRCUMFLEX_ACCENT:\n                    if (this.peekCodePoint(0) === EQUALS_SIGN) {\n                        this.consumeCodePoint();\n                        return PREFIX_MATCH_TOKEN;\n                    }\n                    break;\n                case LEFT_CURLY_BRACKET:\n                    return LEFT_CURLY_BRACKET_TOKEN;\n                case RIGHT_CURLY_BRACKET:\n                    return RIGHT_CURLY_BRACKET_TOKEN;\n                case u:\n                case U:\n                    var u1 = this.peekCodePoint(0);\n                    var u2 = this.peekCodePoint(1);\n                    if (u1 === PLUS_SIGN && (isHex(u2) || u2 === QUESTION_MARK)) {\n                        this.consumeCodePoint();\n                        this.consumeUnicodeRangeToken();\n                    }\n                    this.reconsumeCodePoint(codePoint);\n                    return this.consumeIdentLikeToken();\n                case VERTICAL_LINE:\n                    if (this.peekCodePoint(0) === EQUALS_SIGN) {\n                        this.consumeCodePoint();\n                        return DASH_MATCH_TOKEN;\n                    }\n                    if (this.peekCodePoint(0) === VERTICAL_LINE) {\n                        this.consumeCodePoint();\n                        return COLUMN_TOKEN;\n                    }\n                    break;\n                case TILDE:\n                    if (this.peekCodePoint(0) === EQUALS_SIGN) {\n                        this.consumeCodePoint();\n                        return INCLUDE_MATCH_TOKEN;\n                    }\n                    break;\n                case EOF:\n                    return EOF_TOKEN;\n            }\n            if (isWhiteSpace(codePoint)) {\n                this.consumeWhiteSpace();\n                return WHITESPACE_TOKEN;\n            }\n            if (isDigit(codePoint)) {\n                this.reconsumeCodePoint(codePoint);\n                return this.consumeNumericToken();\n            }\n            if (isNameStartCodePoint(codePoint)) {\n                this.reconsumeCodePoint(codePoint);\n                return this.consumeIdentLikeToken();\n            }\n            return { type: 6 /* DELIM_TOKEN */, value: fromCodePoint$1(codePoint) };\n        };\n        Tokenizer.prototype.consumeCodePoint = function () {\n            var value = this._value.shift();\n            return typeof value === 'undefined' ? -1 : value;\n        };\n        Tokenizer.prototype.reconsumeCodePoint = function (codePoint) {\n            this._value.unshift(codePoint);\n        };\n        Tokenizer.prototype.peekCodePoint = function (delta) {\n            if (delta >= this._value.length) {\n                return -1;\n            }\n            return this._value[delta];\n        };\n        Tokenizer.prototype.consumeUnicodeRangeToken = function () {\n            var digits = [];\n            var codePoint = this.consumeCodePoint();\n            while (isHex(codePoint) && digits.length < 6) {\n                digits.push(codePoint);\n                codePoint = this.consumeCodePoint();\n            }\n            var questionMarks = false;\n            while (codePoint === QUESTION_MARK && digits.length < 6) {\n                digits.push(codePoint);\n                codePoint = this.consumeCodePoint();\n                questionMarks = true;\n            }\n            if (questionMarks) {\n                var start_1 = parseInt(fromCodePoint$1.apply(void 0, digits.map(function (digit) { return (digit === QUESTION_MARK ? ZERO : digit); })), 16);\n                var end = parseInt(fromCodePoint$1.apply(void 0, digits.map(function (digit) { return (digit === QUESTION_MARK ? F : digit); })), 16);\n                return { type: 30 /* UNICODE_RANGE_TOKEN */, start: start_1, end: end };\n            }\n            var start = parseInt(fromCodePoint$1.apply(void 0, digits), 16);\n            if (this.peekCodePoint(0) === HYPHEN_MINUS && isHex(this.peekCodePoint(1))) {\n                this.consumeCodePoint();\n                codePoint = this.consumeCodePoint();\n                var endDigits = [];\n                while (isHex(codePoint) && endDigits.length < 6) {\n                    endDigits.push(codePoint);\n                    codePoint = this.consumeCodePoint();\n                }\n                var end = parseInt(fromCodePoint$1.apply(void 0, endDigits), 16);\n                return { type: 30 /* UNICODE_RANGE_TOKEN */, start: start, end: end };\n            }\n            else {\n                return { type: 30 /* UNICODE_RANGE_TOKEN */, start: start, end: start };\n            }\n        };\n        Tokenizer.prototype.consumeIdentLikeToken = function () {\n            var value = this.consumeName();\n            if (value.toLowerCase() === 'url' && this.peekCodePoint(0) === LEFT_PARENTHESIS) {\n                this.consumeCodePoint();\n                return this.consumeUrlToken();\n            }\n            else if (this.peekCodePoint(0) === LEFT_PARENTHESIS) {\n                this.consumeCodePoint();\n                return { type: 19 /* FUNCTION_TOKEN */, value: value };\n            }\n            return { type: 20 /* IDENT_TOKEN */, value: value };\n        };\n        Tokenizer.prototype.consumeUrlToken = function () {\n            var value = [];\n            this.consumeWhiteSpace();\n            if (this.peekCodePoint(0) === EOF) {\n                return { type: 22 /* URL_TOKEN */, value: '' };\n            }\n            var next = this.peekCodePoint(0);\n            if (next === APOSTROPHE || next === QUOTATION_MARK) {\n                var stringToken = this.consumeStringToken(this.consumeCodePoint());\n                if (stringToken.type === 0 /* STRING_TOKEN */) {\n                    this.consumeWhiteSpace();\n                    if (this.peekCodePoint(0) === EOF || this.peekCodePoint(0) === RIGHT_PARENTHESIS) {\n                        this.consumeCodePoint();\n                        return { type: 22 /* URL_TOKEN */, value: stringToken.value };\n                    }\n                }\n                this.consumeBadUrlRemnants();\n                return BAD_URL_TOKEN;\n            }\n            while (true) {\n                var codePoint = this.consumeCodePoint();\n                if (codePoint === EOF || codePoint === RIGHT_PARENTHESIS) {\n                    return { type: 22 /* URL_TOKEN */, value: fromCodePoint$1.apply(void 0, value) };\n                }\n                else if (isWhiteSpace(codePoint)) {\n                    this.consumeWhiteSpace();\n                    if (this.peekCodePoint(0) === EOF || this.peekCodePoint(0) === RIGHT_PARENTHESIS) {\n                        this.consumeCodePoint();\n                        return { type: 22 /* URL_TOKEN */, value: fromCodePoint$1.apply(void 0, value) };\n                    }\n                    this.consumeBadUrlRemnants();\n                    return BAD_URL_TOKEN;\n                }\n                else if (codePoint === QUOTATION_MARK ||\n                    codePoint === APOSTROPHE ||\n                    codePoint === LEFT_PARENTHESIS ||\n                    isNonPrintableCodePoint(codePoint)) {\n                    this.consumeBadUrlRemnants();\n                    return BAD_URL_TOKEN;\n                }\n                else if (codePoint === REVERSE_SOLIDUS) {\n                    if (isValidEscape(codePoint, this.peekCodePoint(0))) {\n                        value.push(this.consumeEscapedCodePoint());\n                    }\n                    else {\n                        this.consumeBadUrlRemnants();\n                        return BAD_URL_TOKEN;\n                    }\n                }\n                else {\n                    value.push(codePoint);\n                }\n            }\n        };\n        Tokenizer.prototype.consumeWhiteSpace = function () {\n            while (isWhiteSpace(this.peekCodePoint(0))) {\n                this.consumeCodePoint();\n            }\n        };\n        Tokenizer.prototype.consumeBadUrlRemnants = function () {\n            while (true) {\n                var codePoint = this.consumeCodePoint();\n                if (codePoint === RIGHT_PARENTHESIS || codePoint === EOF) {\n                    return;\n                }\n                if (isValidEscape(codePoint, this.peekCodePoint(0))) {\n                    this.consumeEscapedCodePoint();\n                }\n            }\n        };\n        Tokenizer.prototype.consumeStringSlice = function (count) {\n            var SLICE_STACK_SIZE = 50000;\n            var value = '';\n            while (count > 0) {\n                var amount = Math.min(SLICE_STACK_SIZE, count);\n                value += fromCodePoint$1.apply(void 0, this._value.splice(0, amount));\n                count -= amount;\n            }\n            this._value.shift();\n            return value;\n        };\n        Tokenizer.prototype.consumeStringToken = function (endingCodePoint) {\n            var value = '';\n            var i = 0;\n            do {\n                var codePoint = this._value[i];\n                if (codePoint === EOF || codePoint === undefined || codePoint === endingCodePoint) {\n                    value += this.consumeStringSlice(i);\n                    return { type: 0 /* STRING_TOKEN */, value: value };\n                }\n                if (codePoint === LINE_FEED) {\n                    this._value.splice(0, i);\n                    return BAD_STRING_TOKEN;\n                }\n                if (codePoint === REVERSE_SOLIDUS) {\n                    var next = this._value[i + 1];\n                    if (next !== EOF && next !== undefined) {\n                        if (next === LINE_FEED) {\n                            value += this.consumeStringSlice(i);\n                            i = -1;\n                            this._value.shift();\n                        }\n                        else if (isValidEscape(codePoint, next)) {\n                            value += this.consumeStringSlice(i);\n                            value += fromCodePoint$1(this.consumeEscapedCodePoint());\n                            i = -1;\n                        }\n                    }\n                }\n                i++;\n            } while (true);\n        };\n        Tokenizer.prototype.consumeNumber = function () {\n            var repr = [];\n            var type = FLAG_INTEGER;\n            var c1 = this.peekCodePoint(0);\n            if (c1 === PLUS_SIGN || c1 === HYPHEN_MINUS) {\n                repr.push(this.consumeCodePoint());\n            }\n            while (isDigit(this.peekCodePoint(0))) {\n                repr.push(this.consumeCodePoint());\n            }\n            c1 = this.peekCodePoint(0);\n            var c2 = this.peekCodePoint(1);\n            if (c1 === FULL_STOP && isDigit(c2)) {\n                repr.push(this.consumeCodePoint(), this.consumeCodePoint());\n                type = FLAG_NUMBER;\n                while (isDigit(this.peekCodePoint(0))) {\n                    repr.push(this.consumeCodePoint());\n                }\n            }\n            c1 = this.peekCodePoint(0);\n            c2 = this.peekCodePoint(1);\n            var c3 = this.peekCodePoint(2);\n            if ((c1 === E || c1 === e) && (((c2 === PLUS_SIGN || c2 === HYPHEN_MINUS) && isDigit(c3)) || isDigit(c2))) {\n                repr.push(this.consumeCodePoint(), this.consumeCodePoint());\n                type = FLAG_NUMBER;\n                while (isDigit(this.peekCodePoint(0))) {\n                    repr.push(this.consumeCodePoint());\n                }\n            }\n            return [stringToNumber(repr), type];\n        };\n        Tokenizer.prototype.consumeNumericToken = function () {\n            var _a = this.consumeNumber(), number = _a[0], flags = _a[1];\n            var c1 = this.peekCodePoint(0);\n            var c2 = this.peekCodePoint(1);\n            var c3 = this.peekCodePoint(2);\n            if (isIdentifierStart(c1, c2, c3)) {\n                var unit = this.consumeName();\n                return { type: 15 /* DIMENSION_TOKEN */, number: number, flags: flags, unit: unit };\n            }\n            if (c1 === PERCENTAGE_SIGN) {\n                this.consumeCodePoint();\n                return { type: 16 /* PERCENTAGE_TOKEN */, number: number, flags: flags };\n            }\n            return { type: 17 /* NUMBER_TOKEN */, number: number, flags: flags };\n        };\n        Tokenizer.prototype.consumeEscapedCodePoint = function () {\n            var codePoint = this.consumeCodePoint();\n            if (isHex(codePoint)) {\n                var hex = fromCodePoint$1(codePoint);\n                while (isHex(this.peekCodePoint(0)) && hex.length < 6) {\n                    hex += fromCodePoint$1(this.consumeCodePoint());\n                }\n                if (isWhiteSpace(this.peekCodePoint(0))) {\n                    this.consumeCodePoint();\n                }\n                var hexCodePoint = parseInt(hex, 16);\n                if (hexCodePoint === 0 || isSurrogateCodePoint(hexCodePoint) || hexCodePoint > 0x10ffff) {\n                    return REPLACEMENT_CHARACTER;\n                }\n                return hexCodePoint;\n            }\n            if (codePoint === EOF) {\n                return REPLACEMENT_CHARACTER;\n            }\n            return codePoint;\n        };\n        Tokenizer.prototype.consumeName = function () {\n            var result = '';\n            while (true) {\n                var codePoint = this.consumeCodePoint();\n                if (isNameCodePoint(codePoint)) {\n                    result += fromCodePoint$1(codePoint);\n                }\n                else if (isValidEscape(codePoint, this.peekCodePoint(0))) {\n                    result += fromCodePoint$1(this.consumeEscapedCodePoint());\n                }\n                else {\n                    this.reconsumeCodePoint(codePoint);\n                    return result;\n                }\n            }\n        };\n        return Tokenizer;\n    }());\n\n    var Parser = /** @class */ (function () {\n        function Parser(tokens) {\n            this._tokens = tokens;\n        }\n        Parser.create = function (value) {\n            var tokenizer = new Tokenizer();\n            tokenizer.write(value);\n            return new Parser(tokenizer.read());\n        };\n        Parser.parseValue = function (value) {\n            return Parser.create(value).parseComponentValue();\n        };\n        Parser.parseValues = function (value) {\n            return Parser.create(value).parseComponentValues();\n        };\n        Parser.prototype.parseComponentValue = function () {\n            var token = this.consumeToken();\n            while (token.type === 31 /* WHITESPACE_TOKEN */) {\n                token = this.consumeToken();\n            }\n            if (token.type === 32 /* EOF_TOKEN */) {\n                throw new SyntaxError(\"Error parsing CSS component value, unexpected EOF\");\n            }\n            this.reconsumeToken(token);\n            var value = this.consumeComponentValue();\n            do {\n                token = this.consumeToken();\n            } while (token.type === 31 /* WHITESPACE_TOKEN */);\n            if (token.type === 32 /* EOF_TOKEN */) {\n                return value;\n            }\n            throw new SyntaxError(\"Error parsing CSS component value, multiple values found when expecting only one\");\n        };\n        Parser.prototype.parseComponentValues = function () {\n            var values = [];\n            while (true) {\n                var value = this.consumeComponentValue();\n                if (value.type === 32 /* EOF_TOKEN */) {\n                    return values;\n                }\n                values.push(value);\n                values.push();\n            }\n        };\n        Parser.prototype.consumeComponentValue = function () {\n            var token = this.consumeToken();\n            switch (token.type) {\n                case 11 /* LEFT_CURLY_BRACKET_TOKEN */:\n                case 28 /* LEFT_SQUARE_BRACKET_TOKEN */:\n                case 2 /* LEFT_PARENTHESIS_TOKEN */:\n                    return this.consumeSimpleBlock(token.type);\n                case 19 /* FUNCTION_TOKEN */:\n                    return this.consumeFunction(token);\n            }\n            return token;\n        };\n        Parser.prototype.consumeSimpleBlock = function (type) {\n            var block = { type: type, values: [] };\n            var token = this.consumeToken();\n            while (true) {\n                if (token.type === 32 /* EOF_TOKEN */ || isEndingTokenFor(token, type)) {\n                    return block;\n                }\n                this.reconsumeToken(token);\n                block.values.push(this.consumeComponentValue());\n                token = this.consumeToken();\n            }\n        };\n        Parser.prototype.consumeFunction = function (functionToken) {\n            var cssFunction = {\n                name: functionToken.value,\n                values: [],\n                type: 18 /* FUNCTION */\n            };\n            while (true) {\n                var token = this.consumeToken();\n                if (token.type === 32 /* EOF_TOKEN */ || token.type === 3 /* RIGHT_PARENTHESIS_TOKEN */) {\n                    return cssFunction;\n                }\n                this.reconsumeToken(token);\n                cssFunction.values.push(this.consumeComponentValue());\n            }\n        };\n        Parser.prototype.consumeToken = function () {\n            var token = this._tokens.shift();\n            return typeof token === 'undefined' ? EOF_TOKEN : token;\n        };\n        Parser.prototype.reconsumeToken = function (token) {\n            this._tokens.unshift(token);\n        };\n        return Parser;\n    }());\n    var isDimensionToken = function (token) { return token.type === 15 /* DIMENSION_TOKEN */; };\n    var isNumberToken = function (token) { return token.type === 17 /* NUMBER_TOKEN */; };\n    var isIdentToken = function (token) { return token.type === 20 /* IDENT_TOKEN */; };\n    var isStringToken = function (token) { return token.type === 0 /* STRING_TOKEN */; };\n    var isIdentWithValue = function (token, value) {\n        return isIdentToken(token) && token.value === value;\n    };\n    var nonWhiteSpace = function (token) { return token.type !== 31 /* WHITESPACE_TOKEN */; };\n    var nonFunctionArgSeparator = function (token) {\n        return token.type !== 31 /* WHITESPACE_TOKEN */ && token.type !== 4 /* COMMA_TOKEN */;\n    };\n    var parseFunctionArgs = function (tokens) {\n        var args = [];\n        var arg = [];\n        tokens.forEach(function (token) {\n            if (token.type === 4 /* COMMA_TOKEN */) {\n                if (arg.length === 0) {\n                    throw new Error(\"Error parsing function args, zero tokens for arg\");\n                }\n                args.push(arg);\n                arg = [];\n                return;\n            }\n            if (token.type !== 31 /* WHITESPACE_TOKEN */) {\n                arg.push(token);\n            }\n        });\n        if (arg.length) {\n            args.push(arg);\n        }\n        return args;\n    };\n    var isEndingTokenFor = function (token, type) {\n        if (type === 11 /* LEFT_CURLY_BRACKET_TOKEN */ && token.type === 12 /* RIGHT_CURLY_BRACKET_TOKEN */) {\n            return true;\n        }\n        if (type === 28 /* LEFT_SQUARE_BRACKET_TOKEN */ && token.type === 29 /* RIGHT_SQUARE_BRACKET_TOKEN */) {\n            return true;\n        }\n        return type === 2 /* LEFT_PARENTHESIS_TOKEN */ && token.type === 3 /* RIGHT_PARENTHESIS_TOKEN */;\n    };\n\n    var isLength = function (token) {\n        return token.type === 17 /* NUMBER_TOKEN */ || token.type === 15 /* DIMENSION_TOKEN */;\n    };\n\n    var isLengthPercentage = function (token) {\n        return token.type === 16 /* PERCENTAGE_TOKEN */ || isLength(token);\n    };\n    var parseLengthPercentageTuple = function (tokens) {\n        return tokens.length > 1 ? [tokens[0], tokens[1]] : [tokens[0]];\n    };\n    var ZERO_LENGTH = {\n        type: 17 /* NUMBER_TOKEN */,\n        number: 0,\n        flags: FLAG_INTEGER\n    };\n    var FIFTY_PERCENT = {\n        type: 16 /* PERCENTAGE_TOKEN */,\n        number: 50,\n        flags: FLAG_INTEGER\n    };\n    var HUNDRED_PERCENT = {\n        type: 16 /* PERCENTAGE_TOKEN */,\n        number: 100,\n        flags: FLAG_INTEGER\n    };\n    var getAbsoluteValueForTuple = function (tuple, width, height) {\n        var x = tuple[0], y = tuple[1];\n        return [getAbsoluteValue(x, width), getAbsoluteValue(typeof y !== 'undefined' ? y : x, height)];\n    };\n    var getAbsoluteValue = function (token, parent) {\n        if (token.type === 16 /* PERCENTAGE_TOKEN */) {\n            return (token.number / 100) * parent;\n        }\n        if (isDimensionToken(token)) {\n            switch (token.unit) {\n                case 'rem':\n                case 'em':\n                    return 16 * token.number; // TODO use correct font-size\n                case 'px':\n                default:\n                    return token.number;\n            }\n        }\n        return token.number;\n    };\n\n    var DEG = 'deg';\n    var GRAD = 'grad';\n    var RAD = 'rad';\n    var TURN = 'turn';\n    var angle = {\n        name: 'angle',\n        parse: function (_context, value) {\n            if (value.type === 15 /* DIMENSION_TOKEN */) {\n                switch (value.unit) {\n                    case DEG:\n                        return (Math.PI * value.number) / 180;\n                    case GRAD:\n                        return (Math.PI / 200) * value.number;\n                    case RAD:\n                        return value.number;\n                    case TURN:\n                        return Math.PI * 2 * value.number;\n                }\n            }\n            throw new Error(\"Unsupported angle type\");\n        }\n    };\n    var isAngle = function (value) {\n        if (value.type === 15 /* DIMENSION_TOKEN */) {\n            if (value.unit === DEG || value.unit === GRAD || value.unit === RAD || value.unit === TURN) {\n                return true;\n            }\n        }\n        return false;\n    };\n    var parseNamedSide = function (tokens) {\n        var sideOrCorner = tokens\n            .filter(isIdentToken)\n            .map(function (ident) { return ident.value; })\n            .join(' ');\n        switch (sideOrCorner) {\n            case 'to bottom right':\n            case 'to right bottom':\n            case 'left top':\n            case 'top left':\n                return [ZERO_LENGTH, ZERO_LENGTH];\n            case 'to top':\n            case 'bottom':\n                return deg(0);\n            case 'to bottom left':\n            case 'to left bottom':\n            case 'right top':\n            case 'top right':\n                return [ZERO_LENGTH, HUNDRED_PERCENT];\n            case 'to right':\n            case 'left':\n                return deg(90);\n            case 'to top left':\n            case 'to left top':\n            case 'right bottom':\n            case 'bottom right':\n                return [HUNDRED_PERCENT, HUNDRED_PERCENT];\n            case 'to bottom':\n            case 'top':\n                return deg(180);\n            case 'to top right':\n            case 'to right top':\n            case 'left bottom':\n            case 'bottom left':\n                return [HUNDRED_PERCENT, ZERO_LENGTH];\n            case 'to left':\n            case 'right':\n                return deg(270);\n        }\n        return 0;\n    };\n    var deg = function (deg) { return (Math.PI * deg) / 180; };\n\n    var color$1 = {\n        name: 'color',\n        parse: function (context, value) {\n            if (value.type === 18 /* FUNCTION */) {\n                var colorFunction = SUPPORTED_COLOR_FUNCTIONS[value.name];\n                if (typeof colorFunction === 'undefined') {\n                    throw new Error(\"Attempting to parse an unsupported color function \\\"\" + value.name + \"\\\"\");\n                }\n                return colorFunction(context, value.values);\n            }\n            if (value.type === 5 /* HASH_TOKEN */) {\n                if (value.value.length === 3) {\n                    var r = value.value.substring(0, 1);\n                    var g = value.value.substring(1, 2);\n                    var b = value.value.substring(2, 3);\n                    return pack(parseInt(r + r, 16), parseInt(g + g, 16), parseInt(b + b, 16), 1);\n                }\n                if (value.value.length === 4) {\n                    var r = value.value.substring(0, 1);\n                    var g = value.value.substring(1, 2);\n                    var b = value.value.substring(2, 3);\n                    var a = value.value.substring(3, 4);\n                    return pack(parseInt(r + r, 16), parseInt(g + g, 16), parseInt(b + b, 16), parseInt(a + a, 16) / 255);\n                }\n                if (value.value.length === 6) {\n                    var r = value.value.substring(0, 2);\n                    var g = value.value.substring(2, 4);\n                    var b = value.value.substring(4, 6);\n                    return pack(parseInt(r, 16), parseInt(g, 16), parseInt(b, 16), 1);\n                }\n                if (value.value.length === 8) {\n                    var r = value.value.substring(0, 2);\n                    var g = value.value.substring(2, 4);\n                    var b = value.value.substring(4, 6);\n                    var a = value.value.substring(6, 8);\n                    return pack(parseInt(r, 16), parseInt(g, 16), parseInt(b, 16), parseInt(a, 16) / 255);\n                }\n            }\n            if (value.type === 20 /* IDENT_TOKEN */) {\n                var namedColor = COLORS[value.value.toUpperCase()];\n                if (typeof namedColor !== 'undefined') {\n                    return namedColor;\n                }\n            }\n            return COLORS.TRANSPARENT;\n        }\n    };\n    var isTransparent = function (color) { return (0xff & color) === 0; };\n    var asString = function (color) {\n        var alpha = 0xff & color;\n        var blue = 0xff & (color >> 8);\n        var green = 0xff & (color >> 16);\n        var red = 0xff & (color >> 24);\n        return alpha < 255 ? \"rgba(\" + red + \",\" + green + \",\" + blue + \",\" + alpha / 255 + \")\" : \"rgb(\" + red + \",\" + green + \",\" + blue + \")\";\n    };\n    var pack = function (r, g, b, a) {\n        return ((r << 24) | (g << 16) | (b << 8) | (Math.round(a * 255) << 0)) >>> 0;\n    };\n    var getTokenColorValue = function (token, i) {\n        if (token.type === 17 /* NUMBER_TOKEN */) {\n            return token.number;\n        }\n        if (token.type === 16 /* PERCENTAGE_TOKEN */) {\n            var max = i === 3 ? 1 : 255;\n            return i === 3 ? (token.number / 100) * max : Math.round((token.number / 100) * max);\n        }\n        return 0;\n    };\n    var rgb = function (_context, args) {\n        var tokens = args.filter(nonFunctionArgSeparator);\n        if (tokens.length === 3) {\n            var _a = tokens.map(getTokenColorValue), r = _a[0], g = _a[1], b = _a[2];\n            return pack(r, g, b, 1);\n        }\n        if (tokens.length === 4) {\n            var _b = tokens.map(getTokenColorValue), r = _b[0], g = _b[1], b = _b[2], a = _b[3];\n            return pack(r, g, b, a);\n        }\n        return 0;\n    };\n    function hue2rgb(t1, t2, hue) {\n        if (hue < 0) {\n            hue += 1;\n        }\n        if (hue >= 1) {\n            hue -= 1;\n        }\n        if (hue < 1 / 6) {\n            return (t2 - t1) * hue * 6 + t1;\n        }\n        else if (hue < 1 / 2) {\n            return t2;\n        }\n        else if (hue < 2 / 3) {\n            return (t2 - t1) * 6 * (2 / 3 - hue) + t1;\n        }\n        else {\n            return t1;\n        }\n    }\n    var hsl = function (context, args) {\n        var tokens = args.filter(nonFunctionArgSeparator);\n        var hue = tokens[0], saturation = tokens[1], lightness = tokens[2], alpha = tokens[3];\n        var h = (hue.type === 17 /* NUMBER_TOKEN */ ? deg(hue.number) : angle.parse(context, hue)) / (Math.PI * 2);\n        var s = isLengthPercentage(saturation) ? saturation.number / 100 : 0;\n        var l = isLengthPercentage(lightness) ? lightness.number / 100 : 0;\n        var a = typeof alpha !== 'undefined' && isLengthPercentage(alpha) ? getAbsoluteValue(alpha, 1) : 1;\n        if (s === 0) {\n            return pack(l * 255, l * 255, l * 255, 1);\n        }\n        var t2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;\n        var t1 = l * 2 - t2;\n        var r = hue2rgb(t1, t2, h + 1 / 3);\n        var g = hue2rgb(t1, t2, h);\n        var b = hue2rgb(t1, t2, h - 1 / 3);\n        return pack(r * 255, g * 255, b * 255, a);\n    };\n    var SUPPORTED_COLOR_FUNCTIONS = {\n        hsl: hsl,\n        hsla: hsl,\n        rgb: rgb,\n        rgba: rgb\n    };\n    var parseColor = function (context, value) {\n        return color$1.parse(context, Parser.create(value).parseComponentValue());\n    };\n    var COLORS = {\n        ALICEBLUE: 0xf0f8ffff,\n        ANTIQUEWHITE: 0xfaebd7ff,\n        AQUA: 0x00ffffff,\n        AQUAMARINE: 0x7fffd4ff,\n        AZURE: 0xf0ffffff,\n        BEIGE: 0xf5f5dcff,\n        BISQUE: 0xffe4c4ff,\n        BLACK: 0x000000ff,\n        BLANCHEDALMOND: 0xffebcdff,\n        BLUE: 0x0000ffff,\n        BLUEVIOLET: 0x8a2be2ff,\n        BROWN: 0xa52a2aff,\n        BURLYWOOD: 0xdeb887ff,\n        CADETBLUE: 0x5f9ea0ff,\n        CHARTREUSE: 0x7fff00ff,\n        CHOCOLATE: 0xd2691eff,\n        CORAL: 0xff7f50ff,\n        CORNFLOWERBLUE: 0x6495edff,\n        CORNSILK: 0xfff8dcff,\n        CRIMSON: 0xdc143cff,\n        CYAN: 0x00ffffff,\n        DARKBLUE: 0x00008bff,\n        DARKCYAN: 0x008b8bff,\n        DARKGOLDENROD: 0xb886bbff,\n        DARKGRAY: 0xa9a9a9ff,\n        DARKGREEN: 0x006400ff,\n        DARKGREY: 0xa9a9a9ff,\n        DARKKHAKI: 0xbdb76bff,\n        DARKMAGENTA: 0x8b008bff,\n        DARKOLIVEGREEN: 0x556b2fff,\n        DARKORANGE: 0xff8c00ff,\n        DARKORCHID: 0x9932ccff,\n        DARKRED: 0x8b0000ff,\n        DARKSALMON: 0xe9967aff,\n        DARKSEAGREEN: 0x8fbc8fff,\n        DARKSLATEBLUE: 0x483d8bff,\n        DARKSLATEGRAY: 0x2f4f4fff,\n        DARKSLATEGREY: 0x2f4f4fff,\n        DARKTURQUOISE: 0x00ced1ff,\n        DARKVIOLET: 0x9400d3ff,\n        DEEPPINK: 0xff1493ff,\n        DEEPSKYBLUE: 0x00bfffff,\n        DIMGRAY: 0x696969ff,\n        DIMGREY: 0x696969ff,\n        DODGERBLUE: 0x1e90ffff,\n        FIREBRICK: 0xb22222ff,\n        FLORALWHITE: 0xfffaf0ff,\n        FORESTGREEN: 0x228b22ff,\n        FUCHSIA: 0xff00ffff,\n        GAINSBORO: 0xdcdcdcff,\n        GHOSTWHITE: 0xf8f8ffff,\n        GOLD: 0xffd700ff,\n        GOLDENROD: 0xdaa520ff,\n        GRAY: 0x808080ff,\n        GREEN: 0x008000ff,\n        GREENYELLOW: 0xadff2fff,\n        GREY: 0x808080ff,\n        HONEYDEW: 0xf0fff0ff,\n        HOTPINK: 0xff69b4ff,\n        INDIANRED: 0xcd5c5cff,\n        INDIGO: 0x4b0082ff,\n        IVORY: 0xfffff0ff,\n        KHAKI: 0xf0e68cff,\n        LAVENDER: 0xe6e6faff,\n        LAVENDERBLUSH: 0xfff0f5ff,\n        LAWNGREEN: 0x7cfc00ff,\n        LEMONCHIFFON: 0xfffacdff,\n        LIGHTBLUE: 0xadd8e6ff,\n        LIGHTCORAL: 0xf08080ff,\n        LIGHTCYAN: 0xe0ffffff,\n        LIGHTGOLDENRODYELLOW: 0xfafad2ff,\n        LIGHTGRAY: 0xd3d3d3ff,\n        LIGHTGREEN: 0x90ee90ff,\n        LIGHTGREY: 0xd3d3d3ff,\n        LIGHTPINK: 0xffb6c1ff,\n        LIGHTSALMON: 0xffa07aff,\n        LIGHTSEAGREEN: 0x20b2aaff,\n        LIGHTSKYBLUE: 0x87cefaff,\n        LIGHTSLATEGRAY: 0x778899ff,\n        LIGHTSLATEGREY: 0x778899ff,\n        LIGHTSTEELBLUE: 0xb0c4deff,\n        LIGHTYELLOW: 0xffffe0ff,\n        LIME: 0x00ff00ff,\n        LIMEGREEN: 0x32cd32ff,\n        LINEN: 0xfaf0e6ff,\n        MAGENTA: 0xff00ffff,\n        MAROON: 0x800000ff,\n        MEDIUMAQUAMARINE: 0x66cdaaff,\n        MEDIUMBLUE: 0x0000cdff,\n        MEDIUMORCHID: 0xba55d3ff,\n        MEDIUMPURPLE: 0x9370dbff,\n        MEDIUMSEAGREEN: 0x3cb371ff,\n        MEDIUMSLATEBLUE: 0x7b68eeff,\n        MEDIUMSPRINGGREEN: 0x00fa9aff,\n        MEDIUMTURQUOISE: 0x48d1ccff,\n        MEDIUMVIOLETRED: 0xc71585ff,\n        MIDNIGHTBLUE: 0x191970ff,\n        MINTCREAM: 0xf5fffaff,\n        MISTYROSE: 0xffe4e1ff,\n        MOCCASIN: 0xffe4b5ff,\n        NAVAJOWHITE: 0xffdeadff,\n        NAVY: 0x000080ff,\n        OLDLACE: 0xfdf5e6ff,\n        OLIVE: 0x808000ff,\n        OLIVEDRAB: 0x6b8e23ff,\n        ORANGE: 0xffa500ff,\n        ORANGERED: 0xff4500ff,\n        ORCHID: 0xda70d6ff,\n        PALEGOLDENROD: 0xeee8aaff,\n        PALEGREEN: 0x98fb98ff,\n        PALETURQUOISE: 0xafeeeeff,\n        PALEVIOLETRED: 0xdb7093ff,\n        PAPAYAWHIP: 0xffefd5ff,\n        PEACHPUFF: 0xffdab9ff,\n        PERU: 0xcd853fff,\n        PINK: 0xffc0cbff,\n        PLUM: 0xdda0ddff,\n        POWDERBLUE: 0xb0e0e6ff,\n        PURPLE: 0x800080ff,\n        REBECCAPURPLE: 0x663399ff,\n        RED: 0xff0000ff,\n        ROSYBROWN: 0xbc8f8fff,\n        ROYALBLUE: 0x4169e1ff,\n        SADDLEBROWN: 0x8b4513ff,\n        SALMON: 0xfa8072ff,\n        SANDYBROWN: 0xf4a460ff,\n        SEAGREEN: 0x2e8b57ff,\n        SEASHELL: 0xfff5eeff,\n        SIENNA: 0xa0522dff,\n        SILVER: 0xc0c0c0ff,\n        SKYBLUE: 0x87ceebff,\n        SLATEBLUE: 0x6a5acdff,\n        SLATEGRAY: 0x708090ff,\n        SLATEGREY: 0x708090ff,\n        SNOW: 0xfffafaff,\n        SPRINGGREEN: 0x00ff7fff,\n        STEELBLUE: 0x4682b4ff,\n        TAN: 0xd2b48cff,\n        TEAL: 0x008080ff,\n        THISTLE: 0xd8bfd8ff,\n        TOMATO: 0xff6347ff,\n        TRANSPARENT: 0x00000000,\n        TURQUOISE: 0x40e0d0ff,\n        VIOLET: 0xee82eeff,\n        WHEAT: 0xf5deb3ff,\n        WHITE: 0xffffffff,\n        WHITESMOKE: 0xf5f5f5ff,\n        YELLOW: 0xffff00ff,\n        YELLOWGREEN: 0x9acd32ff\n    };\n\n    var backgroundClip = {\n        name: 'background-clip',\n        initialValue: 'border-box',\n        prefix: false,\n        type: 1 /* LIST */,\n        parse: function (_context, tokens) {\n            return tokens.map(function (token) {\n                if (isIdentToken(token)) {\n                    switch (token.value) {\n                        case 'padding-box':\n                            return 1 /* PADDING_BOX */;\n                        case 'content-box':\n                            return 2 /* CONTENT_BOX */;\n                    }\n                }\n                return 0 /* BORDER_BOX */;\n            });\n        }\n    };\n\n    var backgroundColor = {\n        name: \"background-color\",\n        initialValue: 'transparent',\n        prefix: false,\n        type: 3 /* TYPE_VALUE */,\n        format: 'color'\n    };\n\n    var parseColorStop = function (context, args) {\n        var color = color$1.parse(context, args[0]);\n        var stop = args[1];\n        return stop && isLengthPercentage(stop) ? { color: color, stop: stop } : { color: color, stop: null };\n    };\n    var processColorStops = function (stops, lineLength) {\n        var first = stops[0];\n        var last = stops[stops.length - 1];\n        if (first.stop === null) {\n            first.stop = ZERO_LENGTH;\n        }\n        if (last.stop === null) {\n            last.stop = HUNDRED_PERCENT;\n        }\n        var processStops = [];\n        var previous = 0;\n        for (var i = 0; i < stops.length; i++) {\n            var stop_1 = stops[i].stop;\n            if (stop_1 !== null) {\n                var absoluteValue = getAbsoluteValue(stop_1, lineLength);\n                if (absoluteValue > previous) {\n                    processStops.push(absoluteValue);\n                }\n                else {\n                    processStops.push(previous);\n                }\n                previous = absoluteValue;\n            }\n            else {\n                processStops.push(null);\n            }\n        }\n        var gapBegin = null;\n        for (var i = 0; i < processStops.length; i++) {\n            var stop_2 = processStops[i];\n            if (stop_2 === null) {\n                if (gapBegin === null) {\n                    gapBegin = i;\n                }\n            }\n            else if (gapBegin !== null) {\n                var gapLength = i - gapBegin;\n                var beforeGap = processStops[gapBegin - 1];\n                var gapValue = (stop_2 - beforeGap) / (gapLength + 1);\n                for (var g = 1; g <= gapLength; g++) {\n                    processStops[gapBegin + g - 1] = gapValue * g;\n                }\n                gapBegin = null;\n            }\n        }\n        return stops.map(function (_a, i) {\n            var color = _a.color;\n            return { color: color, stop: Math.max(Math.min(1, processStops[i] / lineLength), 0) };\n        });\n    };\n    var getAngleFromCorner = function (corner, width, height) {\n        var centerX = width / 2;\n        var centerY = height / 2;\n        var x = getAbsoluteValue(corner[0], width) - centerX;\n        var y = centerY - getAbsoluteValue(corner[1], height);\n        return (Math.atan2(y, x) + Math.PI * 2) % (Math.PI * 2);\n    };\n    var calculateGradientDirection = function (angle, width, height) {\n        var radian = typeof angle === 'number' ? angle : getAngleFromCorner(angle, width, height);\n        var lineLength = Math.abs(width * Math.sin(radian)) + Math.abs(height * Math.cos(radian));\n        var halfWidth = width / 2;\n        var halfHeight = height / 2;\n        var halfLineLength = lineLength / 2;\n        var yDiff = Math.sin(radian - Math.PI / 2) * halfLineLength;\n        var xDiff = Math.cos(radian - Math.PI / 2) * halfLineLength;\n        return [lineLength, halfWidth - xDiff, halfWidth + xDiff, halfHeight - yDiff, halfHeight + yDiff];\n    };\n    var distance = function (a, b) { return Math.sqrt(a * a + b * b); };\n    var findCorner = function (width, height, x, y, closest) {\n        var corners = [\n            [0, 0],\n            [0, height],\n            [width, 0],\n            [width, height]\n        ];\n        return corners.reduce(function (stat, corner) {\n            var cx = corner[0], cy = corner[1];\n            var d = distance(x - cx, y - cy);\n            if (closest ? d < stat.optimumDistance : d > stat.optimumDistance) {\n                return {\n                    optimumCorner: corner,\n                    optimumDistance: d\n                };\n            }\n            return stat;\n        }, {\n            optimumDistance: closest ? Infinity : -Infinity,\n            optimumCorner: null\n        }).optimumCorner;\n    };\n    var calculateRadius = function (gradient, x, y, width, height) {\n        var rx = 0;\n        var ry = 0;\n        switch (gradient.size) {\n            case 0 /* CLOSEST_SIDE */:\n                // The ending shape is sized so that that it exactly meets the side of the gradient box closest to the gradients center.\n                // If the shape is an ellipse, it exactly meets the closest side in each dimension.\n                if (gradient.shape === 0 /* CIRCLE */) {\n                    rx = ry = Math.min(Math.abs(x), Math.abs(x - width), Math.abs(y), Math.abs(y - height));\n                }\n                else if (gradient.shape === 1 /* ELLIPSE */) {\n                    rx = Math.min(Math.abs(x), Math.abs(x - width));\n                    ry = Math.min(Math.abs(y), Math.abs(y - height));\n                }\n                break;\n            case 2 /* CLOSEST_CORNER */:\n                // The ending shape is sized so that that it passes through the corner of the gradient box closest to the gradients center.\n                // If the shape is an ellipse, the ending shape is given the same aspect-ratio it would have if closest-side were specified.\n                if (gradient.shape === 0 /* CIRCLE */) {\n                    rx = ry = Math.min(distance(x, y), distance(x, y - height), distance(x - width, y), distance(x - width, y - height));\n                }\n                else if (gradient.shape === 1 /* ELLIPSE */) {\n                    // Compute the ratio ry/rx (which is to be the same as for \"closest-side\")\n                    var c = Math.min(Math.abs(y), Math.abs(y - height)) / Math.min(Math.abs(x), Math.abs(x - width));\n                    var _a = findCorner(width, height, x, y, true), cx = _a[0], cy = _a[1];\n                    rx = distance(cx - x, (cy - y) / c);\n                    ry = c * rx;\n                }\n                break;\n            case 1 /* FARTHEST_SIDE */:\n                // Same as closest-side, except the ending shape is sized based on the farthest side(s)\n                if (gradient.shape === 0 /* CIRCLE */) {\n                    rx = ry = Math.max(Math.abs(x), Math.abs(x - width), Math.abs(y), Math.abs(y - height));\n                }\n                else if (gradient.shape === 1 /* ELLIPSE */) {\n                    rx = Math.max(Math.abs(x), Math.abs(x - width));\n                    ry = Math.max(Math.abs(y), Math.abs(y - height));\n                }\n                break;\n            case 3 /* FARTHEST_CORNER */:\n                // Same as closest-corner, except the ending shape is sized based on the farthest corner.\n                // If the shape is an ellipse, the ending shape is given the same aspect ratio it would have if farthest-side were specified.\n                if (gradient.shape === 0 /* CIRCLE */) {\n                    rx = ry = Math.max(distance(x, y), distance(x, y - height), distance(x - width, y), distance(x - width, y - height));\n                }\n                else if (gradient.shape === 1 /* ELLIPSE */) {\n                    // Compute the ratio ry/rx (which is to be the same as for \"farthest-side\")\n                    var c = Math.max(Math.abs(y), Math.abs(y - height)) / Math.max(Math.abs(x), Math.abs(x - width));\n                    var _b = findCorner(width, height, x, y, false), cx = _b[0], cy = _b[1];\n                    rx = distance(cx - x, (cy - y) / c);\n                    ry = c * rx;\n                }\n                break;\n        }\n        if (Array.isArray(gradient.size)) {\n            rx = getAbsoluteValue(gradient.size[0], width);\n            ry = gradient.size.length === 2 ? getAbsoluteValue(gradient.size[1], height) : rx;\n        }\n        return [rx, ry];\n    };\n\n    var linearGradient = function (context, tokens) {\n        var angle$1 = deg(180);\n        var stops = [];\n        parseFunctionArgs(tokens).forEach(function (arg, i) {\n            if (i === 0) {\n                var firstToken = arg[0];\n                if (firstToken.type === 20 /* IDENT_TOKEN */ && firstToken.value === 'to') {\n                    angle$1 = parseNamedSide(arg);\n                    return;\n                }\n                else if (isAngle(firstToken)) {\n                    angle$1 = angle.parse(context, firstToken);\n                    return;\n                }\n            }\n            var colorStop = parseColorStop(context, arg);\n            stops.push(colorStop);\n        });\n        return { angle: angle$1, stops: stops, type: 1 /* LINEAR_GRADIENT */ };\n    };\n\n    var prefixLinearGradient = function (context, tokens) {\n        var angle$1 = deg(180);\n        var stops = [];\n        parseFunctionArgs(tokens).forEach(function (arg, i) {\n            if (i === 0) {\n                var firstToken = arg[0];\n                if (firstToken.type === 20 /* IDENT_TOKEN */ &&\n                    ['top', 'left', 'right', 'bottom'].indexOf(firstToken.value) !== -1) {\n                    angle$1 = parseNamedSide(arg);\n                    return;\n                }\n                else if (isAngle(firstToken)) {\n                    angle$1 = (angle.parse(context, firstToken) + deg(270)) % deg(360);\n                    return;\n                }\n            }\n            var colorStop = parseColorStop(context, arg);\n            stops.push(colorStop);\n        });\n        return {\n            angle: angle$1,\n            stops: stops,\n            type: 1 /* LINEAR_GRADIENT */\n        };\n    };\n\n    var webkitGradient = function (context, tokens) {\n        var angle = deg(180);\n        var stops = [];\n        var type = 1 /* LINEAR_GRADIENT */;\n        var shape = 0 /* CIRCLE */;\n        var size = 3 /* FARTHEST_CORNER */;\n        var position = [];\n        parseFunctionArgs(tokens).forEach(function (arg, i) {\n            var firstToken = arg[0];\n            if (i === 0) {\n                if (isIdentToken(firstToken) && firstToken.value === 'linear') {\n                    type = 1 /* LINEAR_GRADIENT */;\n                    return;\n                }\n                else if (isIdentToken(firstToken) && firstToken.value === 'radial') {\n                    type = 2 /* RADIAL_GRADIENT */;\n                    return;\n                }\n            }\n            if (firstToken.type === 18 /* FUNCTION */) {\n                if (firstToken.name === 'from') {\n                    var color = color$1.parse(context, firstToken.values[0]);\n                    stops.push({ stop: ZERO_LENGTH, color: color });\n                }\n                else if (firstToken.name === 'to') {\n                    var color = color$1.parse(context, firstToken.values[0]);\n                    stops.push({ stop: HUNDRED_PERCENT, color: color });\n                }\n                else if (firstToken.name === 'color-stop') {\n                    var values = firstToken.values.filter(nonFunctionArgSeparator);\n                    if (values.length === 2) {\n                        var color = color$1.parse(context, values[1]);\n                        var stop_1 = values[0];\n                        if (isNumberToken(stop_1)) {\n                            stops.push({\n                                stop: { type: 16 /* PERCENTAGE_TOKEN */, number: stop_1.number * 100, flags: stop_1.flags },\n                                color: color\n                            });\n                        }\n                    }\n                }\n            }\n        });\n        return type === 1 /* LINEAR_GRADIENT */\n            ? {\n                angle: (angle + deg(180)) % deg(360),\n                stops: stops,\n                type: type\n            }\n            : { size: size, shape: shape, stops: stops, position: position, type: type };\n    };\n\n    var CLOSEST_SIDE = 'closest-side';\n    var FARTHEST_SIDE = 'farthest-side';\n    var CLOSEST_CORNER = 'closest-corner';\n    var FARTHEST_CORNER = 'farthest-corner';\n    var CIRCLE = 'circle';\n    var ELLIPSE = 'ellipse';\n    var COVER = 'cover';\n    var CONTAIN = 'contain';\n    var radialGradient = function (context, tokens) {\n        var shape = 0 /* CIRCLE */;\n        var size = 3 /* FARTHEST_CORNER */;\n        var stops = [];\n        var position = [];\n        parseFunctionArgs(tokens).forEach(function (arg, i) {\n            var isColorStop = true;\n            if (i === 0) {\n                var isAtPosition_1 = false;\n                isColorStop = arg.reduce(function (acc, token) {\n                    if (isAtPosition_1) {\n                        if (isIdentToken(token)) {\n                            switch (token.value) {\n                                case 'center':\n                                    position.push(FIFTY_PERCENT);\n                                    return acc;\n                                case 'top':\n                                case 'left':\n                                    position.push(ZERO_LENGTH);\n                                    return acc;\n                                case 'right':\n                                case 'bottom':\n                                    position.push(HUNDRED_PERCENT);\n                                    return acc;\n                            }\n                        }\n                        else if (isLengthPercentage(token) || isLength(token)) {\n                            position.push(token);\n                        }\n                    }\n                    else if (isIdentToken(token)) {\n                        switch (token.value) {\n                            case CIRCLE:\n                                shape = 0 /* CIRCLE */;\n                                return false;\n                            case ELLIPSE:\n                                shape = 1 /* ELLIPSE */;\n                                return false;\n                            case 'at':\n                                isAtPosition_1 = true;\n                                return false;\n                            case CLOSEST_SIDE:\n                                size = 0 /* CLOSEST_SIDE */;\n                                return false;\n                            case COVER:\n                            case FARTHEST_SIDE:\n                                size = 1 /* FARTHEST_SIDE */;\n                                return false;\n                            case CONTAIN:\n                            case CLOSEST_CORNER:\n                                size = 2 /* CLOSEST_CORNER */;\n                                return false;\n                            case FARTHEST_CORNER:\n                                size = 3 /* FARTHEST_CORNER */;\n                                return false;\n                        }\n                    }\n                    else if (isLength(token) || isLengthPercentage(token)) {\n                        if (!Array.isArray(size)) {\n                            size = [];\n                        }\n                        size.push(token);\n                        return false;\n                    }\n                    return acc;\n                }, isColorStop);\n            }\n            if (isColorStop) {\n                var colorStop = parseColorStop(context, arg);\n                stops.push(colorStop);\n            }\n        });\n        return { size: size, shape: shape, stops: stops, position: position, type: 2 /* RADIAL_GRADIENT */ };\n    };\n\n    var prefixRadialGradient = function (context, tokens) {\n        var shape = 0 /* CIRCLE */;\n        var size = 3 /* FARTHEST_CORNER */;\n        var stops = [];\n        var position = [];\n        parseFunctionArgs(tokens).forEach(function (arg, i) {\n            var isColorStop = true;\n            if (i === 0) {\n                isColorStop = arg.reduce(function (acc, token) {\n                    if (isIdentToken(token)) {\n                        switch (token.value) {\n                            case 'center':\n                                position.push(FIFTY_PERCENT);\n                                return false;\n                            case 'top':\n                            case 'left':\n                                position.push(ZERO_LENGTH);\n                                return false;\n                            case 'right':\n                            case 'bottom':\n                                position.push(HUNDRED_PERCENT);\n                                return false;\n                        }\n                    }\n                    else if (isLengthPercentage(token) || isLength(token)) {\n                        position.push(token);\n                        return false;\n                    }\n                    return acc;\n                }, isColorStop);\n            }\n            else if (i === 1) {\n                isColorStop = arg.reduce(function (acc, token) {\n                    if (isIdentToken(token)) {\n                        switch (token.value) {\n                            case CIRCLE:\n                                shape = 0 /* CIRCLE */;\n                                return false;\n                            case ELLIPSE:\n                                shape = 1 /* ELLIPSE */;\n                                return false;\n                            case CONTAIN:\n                            case CLOSEST_SIDE:\n                                size = 0 /* CLOSEST_SIDE */;\n                                return false;\n                            case FARTHEST_SIDE:\n                                size = 1 /* FARTHEST_SIDE */;\n                                return false;\n                            case CLOSEST_CORNER:\n                                size = 2 /* CLOSEST_CORNER */;\n                                return false;\n                            case COVER:\n                            case FARTHEST_CORNER:\n                                size = 3 /* FARTHEST_CORNER */;\n                                return false;\n                        }\n                    }\n                    else if (isLength(token) || isLengthPercentage(token)) {\n                        if (!Array.isArray(size)) {\n                            size = [];\n                        }\n                        size.push(token);\n                        return false;\n                    }\n                    return acc;\n                }, isColorStop);\n            }\n            if (isColorStop) {\n                var colorStop = parseColorStop(context, arg);\n                stops.push(colorStop);\n            }\n        });\n        return { size: size, shape: shape, stops: stops, position: position, type: 2 /* RADIAL_GRADIENT */ };\n    };\n\n    var isLinearGradient = function (background) {\n        return background.type === 1 /* LINEAR_GRADIENT */;\n    };\n    var isRadialGradient = function (background) {\n        return background.type === 2 /* RADIAL_GRADIENT */;\n    };\n    var image = {\n        name: 'image',\n        parse: function (context, value) {\n            if (value.type === 22 /* URL_TOKEN */) {\n                var image_1 = { url: value.value, type: 0 /* URL */ };\n                context.cache.addImage(value.value);\n                return image_1;\n            }\n            if (value.type === 18 /* FUNCTION */) {\n                var imageFunction = SUPPORTED_IMAGE_FUNCTIONS[value.name];\n                if (typeof imageFunction === 'undefined') {\n                    throw new Error(\"Attempting to parse an unsupported image function \\\"\" + value.name + \"\\\"\");\n                }\n                return imageFunction(context, value.values);\n            }\n            throw new Error(\"Unsupported image type \" + value.type);\n        }\n    };\n    function isSupportedImage(value) {\n        return (!(value.type === 20 /* IDENT_TOKEN */ && value.value === 'none') &&\n            (value.type !== 18 /* FUNCTION */ || !!SUPPORTED_IMAGE_FUNCTIONS[value.name]));\n    }\n    var SUPPORTED_IMAGE_FUNCTIONS = {\n        'linear-gradient': linearGradient,\n        '-moz-linear-gradient': prefixLinearGradient,\n        '-ms-linear-gradient': prefixLinearGradient,\n        '-o-linear-gradient': prefixLinearGradient,\n        '-webkit-linear-gradient': prefixLinearGradient,\n        'radial-gradient': radialGradient,\n        '-moz-radial-gradient': prefixRadialGradient,\n        '-ms-radial-gradient': prefixRadialGradient,\n        '-o-radial-gradient': prefixRadialGradient,\n        '-webkit-radial-gradient': prefixRadialGradient,\n        '-webkit-gradient': webkitGradient\n    };\n\n    var backgroundImage = {\n        name: 'background-image',\n        initialValue: 'none',\n        type: 1 /* LIST */,\n        prefix: false,\n        parse: function (context, tokens) {\n            if (tokens.length === 0) {\n                return [];\n            }\n            var first = tokens[0];\n            if (first.type === 20 /* IDENT_TOKEN */ && first.value === 'none') {\n                return [];\n            }\n            return tokens\n                .filter(function (value) { return nonFunctionArgSeparator(value) && isSupportedImage(value); })\n                .map(function (value) { return image.parse(context, value); });\n        }\n    };\n\n    var backgroundOrigin = {\n        name: 'background-origin',\n        initialValue: 'border-box',\n        prefix: false,\n        type: 1 /* LIST */,\n        parse: function (_context, tokens) {\n            return tokens.map(function (token) {\n                if (isIdentToken(token)) {\n                    switch (token.value) {\n                        case 'padding-box':\n                            return 1 /* PADDING_BOX */;\n                        case 'content-box':\n                            return 2 /* CONTENT_BOX */;\n                    }\n                }\n                return 0 /* BORDER_BOX */;\n            });\n        }\n    };\n\n    var backgroundPosition = {\n        name: 'background-position',\n        initialValue: '0% 0%',\n        type: 1 /* LIST */,\n        prefix: false,\n        parse: function (_context, tokens) {\n            return parseFunctionArgs(tokens)\n                .map(function (values) { return values.filter(isLengthPercentage); })\n                .map(parseLengthPercentageTuple);\n        }\n    };\n\n    var backgroundRepeat = {\n        name: 'background-repeat',\n        initialValue: 'repeat',\n        prefix: false,\n        type: 1 /* LIST */,\n        parse: function (_context, tokens) {\n            return parseFunctionArgs(tokens)\n                .map(function (values) {\n                return values\n                    .filter(isIdentToken)\n                    .map(function (token) { return token.value; })\n                    .join(' ');\n            })\n                .map(parseBackgroundRepeat);\n        }\n    };\n    var parseBackgroundRepeat = function (value) {\n        switch (value) {\n            case 'no-repeat':\n                return 1 /* NO_REPEAT */;\n            case 'repeat-x':\n            case 'repeat no-repeat':\n                return 2 /* REPEAT_X */;\n            case 'repeat-y':\n            case 'no-repeat repeat':\n                return 3 /* REPEAT_Y */;\n            case 'repeat':\n            default:\n                return 0 /* REPEAT */;\n        }\n    };\n\n    var BACKGROUND_SIZE;\n    (function (BACKGROUND_SIZE) {\n        BACKGROUND_SIZE[\"AUTO\"] = \"auto\";\n        BACKGROUND_SIZE[\"CONTAIN\"] = \"contain\";\n        BACKGROUND_SIZE[\"COVER\"] = \"cover\";\n    })(BACKGROUND_SIZE || (BACKGROUND_SIZE = {}));\n    var backgroundSize = {\n        name: 'background-size',\n        initialValue: '0',\n        prefix: false,\n        type: 1 /* LIST */,\n        parse: function (_context, tokens) {\n            return parseFunctionArgs(tokens).map(function (values) { return values.filter(isBackgroundSizeInfoToken); });\n        }\n    };\n    var isBackgroundSizeInfoToken = function (value) {\n        return isIdentToken(value) || isLengthPercentage(value);\n    };\n\n    var borderColorForSide = function (side) { return ({\n        name: \"border-\" + side + \"-color\",\n        initialValue: 'transparent',\n        prefix: false,\n        type: 3 /* TYPE_VALUE */,\n        format: 'color'\n    }); };\n    var borderTopColor = borderColorForSide('top');\n    var borderRightColor = borderColorForSide('right');\n    var borderBottomColor = borderColorForSide('bottom');\n    var borderLeftColor = borderColorForSide('left');\n\n    var borderRadiusForSide = function (side) { return ({\n        name: \"border-radius-\" + side,\n        initialValue: '0 0',\n        prefix: false,\n        type: 1 /* LIST */,\n        parse: function (_context, tokens) {\n            return parseLengthPercentageTuple(tokens.filter(isLengthPercentage));\n        }\n    }); };\n    var borderTopLeftRadius = borderRadiusForSide('top-left');\n    var borderTopRightRadius = borderRadiusForSide('top-right');\n    var borderBottomRightRadius = borderRadiusForSide('bottom-right');\n    var borderBottomLeftRadius = borderRadiusForSide('bottom-left');\n\n    var borderStyleForSide = function (side) { return ({\n        name: \"border-\" + side + \"-style\",\n        initialValue: 'solid',\n        prefix: false,\n        type: 2 /* IDENT_VALUE */,\n        parse: function (_context, style) {\n            switch (style) {\n                case 'none':\n                    return 0 /* NONE */;\n                case 'dashed':\n                    return 2 /* DASHED */;\n                case 'dotted':\n                    return 3 /* DOTTED */;\n                case 'double':\n                    return 4 /* DOUBLE */;\n            }\n            return 1 /* SOLID */;\n        }\n    }); };\n    var borderTopStyle = borderStyleForSide('top');\n    var borderRightStyle = borderStyleForSide('right');\n    var borderBottomStyle = borderStyleForSide('bottom');\n    var borderLeftStyle = borderStyleForSide('left');\n\n    var borderWidthForSide = function (side) { return ({\n        name: \"border-\" + side + \"-width\",\n        initialValue: '0',\n        type: 0 /* VALUE */,\n        prefix: false,\n        parse: function (_context, token) {\n            if (isDimensionToken(token)) {\n                return token.number;\n            }\n            return 0;\n        }\n    }); };\n    var borderTopWidth = borderWidthForSide('top');\n    var borderRightWidth = borderWidthForSide('right');\n    var borderBottomWidth = borderWidthForSide('bottom');\n    var borderLeftWidth = borderWidthForSide('left');\n\n    var color = {\n        name: \"color\",\n        initialValue: 'transparent',\n        prefix: false,\n        type: 3 /* TYPE_VALUE */,\n        format: 'color'\n    };\n\n    var direction = {\n        name: 'direction',\n        initialValue: 'ltr',\n        prefix: false,\n        type: 2 /* IDENT_VALUE */,\n        parse: function (_context, direction) {\n            switch (direction) {\n                case 'rtl':\n                    return 1 /* RTL */;\n                case 'ltr':\n                default:\n                    return 0 /* LTR */;\n            }\n        }\n    };\n\n    var display = {\n        name: 'display',\n        initialValue: 'inline-block',\n        prefix: false,\n        type: 1 /* LIST */,\n        parse: function (_context, tokens) {\n            return tokens.filter(isIdentToken).reduce(function (bit, token) {\n                return bit | parseDisplayValue(token.value);\n            }, 0 /* NONE */);\n        }\n    };\n    var parseDisplayValue = function (display) {\n        switch (display) {\n            case 'block':\n            case '-webkit-box':\n                return 2 /* BLOCK */;\n            case 'inline':\n                return 4 /* INLINE */;\n            case 'run-in':\n                return 8 /* RUN_IN */;\n            case 'flow':\n                return 16 /* FLOW */;\n            case 'flow-root':\n                return 32 /* FLOW_ROOT */;\n            case 'table':\n                return 64 /* TABLE */;\n            case 'flex':\n            case '-webkit-flex':\n                return 128 /* FLEX */;\n            case 'grid':\n            case '-ms-grid':\n                return 256 /* GRID */;\n            case 'ruby':\n                return 512 /* RUBY */;\n            case 'subgrid':\n                return 1024 /* SUBGRID */;\n            case 'list-item':\n                return 2048 /* LIST_ITEM */;\n            case 'table-row-group':\n                return 4096 /* TABLE_ROW_GROUP */;\n            case 'table-header-group':\n                return 8192 /* TABLE_HEADER_GROUP */;\n            case 'table-footer-group':\n                return 16384 /* TABLE_FOOTER_GROUP */;\n            case 'table-row':\n                return 32768 /* TABLE_ROW */;\n            case 'table-cell':\n                return 65536 /* TABLE_CELL */;\n            case 'table-column-group':\n                return 131072 /* TABLE_COLUMN_GROUP */;\n            case 'table-column':\n                return 262144 /* TABLE_COLUMN */;\n            case 'table-caption':\n                return 524288 /* TABLE_CAPTION */;\n            case 'ruby-base':\n                return 1048576 /* RUBY_BASE */;\n            case 'ruby-text':\n                return 2097152 /* RUBY_TEXT */;\n            case 'ruby-base-container':\n                return 4194304 /* RUBY_BASE_CONTAINER */;\n            case 'ruby-text-container':\n                return 8388608 /* RUBY_TEXT_CONTAINER */;\n            case 'contents':\n                return 16777216 /* CONTENTS */;\n            case 'inline-block':\n                return 33554432 /* INLINE_BLOCK */;\n            case 'inline-list-item':\n                return 67108864 /* INLINE_LIST_ITEM */;\n            case 'inline-table':\n                return 134217728 /* INLINE_TABLE */;\n            case 'inline-flex':\n                return 268435456 /* INLINE_FLEX */;\n            case 'inline-grid':\n                return 536870912 /* INLINE_GRID */;\n        }\n        return 0 /* NONE */;\n    };\n\n    var float = {\n        name: 'float',\n        initialValue: 'none',\n        prefix: false,\n        type: 2 /* IDENT_VALUE */,\n        parse: function (_context, float) {\n            switch (float) {\n                case 'left':\n                    return 1 /* LEFT */;\n                case 'right':\n                    return 2 /* RIGHT */;\n                case 'inline-start':\n                    return 3 /* INLINE_START */;\n                case 'inline-end':\n                    return 4 /* INLINE_END */;\n            }\n            return 0 /* NONE */;\n        }\n    };\n\n    var letterSpacing = {\n        name: 'letter-spacing',\n        initialValue: '0',\n        prefix: false,\n        type: 0 /* VALUE */,\n        parse: function (_context, token) {\n            if (token.type === 20 /* IDENT_TOKEN */ && token.value === 'normal') {\n                return 0;\n            }\n            if (token.type === 17 /* NUMBER_TOKEN */) {\n                return token.number;\n            }\n            if (token.type === 15 /* DIMENSION_TOKEN */) {\n                return token.number;\n            }\n            return 0;\n        }\n    };\n\n    var LINE_BREAK;\n    (function (LINE_BREAK) {\n        LINE_BREAK[\"NORMAL\"] = \"normal\";\n        LINE_BREAK[\"STRICT\"] = \"strict\";\n    })(LINE_BREAK || (LINE_BREAK = {}));\n    var lineBreak = {\n        name: 'line-break',\n        initialValue: 'normal',\n        prefix: false,\n        type: 2 /* IDENT_VALUE */,\n        parse: function (_context, lineBreak) {\n            switch (lineBreak) {\n                case 'strict':\n                    return LINE_BREAK.STRICT;\n                case 'normal':\n                default:\n                    return LINE_BREAK.NORMAL;\n            }\n        }\n    };\n\n    var lineHeight = {\n        name: 'line-height',\n        initialValue: 'normal',\n        prefix: false,\n        type: 4 /* TOKEN_VALUE */\n    };\n    var computeLineHeight = function (token, fontSize) {\n        if (isIdentToken(token) && token.value === 'normal') {\n            return 1.2 * fontSize;\n        }\n        else if (token.type === 17 /* NUMBER_TOKEN */) {\n            return fontSize * token.number;\n        }\n        else if (isLengthPercentage(token)) {\n            return getAbsoluteValue(token, fontSize);\n        }\n        return fontSize;\n    };\n\n    var listStyleImage = {\n        name: 'list-style-image',\n        initialValue: 'none',\n        type: 0 /* VALUE */,\n        prefix: false,\n        parse: function (context, token) {\n            if (token.type === 20 /* IDENT_TOKEN */ && token.value === 'none') {\n                return null;\n            }\n            return image.parse(context, token);\n        }\n    };\n\n    var listStylePosition = {\n        name: 'list-style-position',\n        initialValue: 'outside',\n        prefix: false,\n        type: 2 /* IDENT_VALUE */,\n        parse: function (_context, position) {\n            switch (position) {\n                case 'inside':\n                    return 0 /* INSIDE */;\n                case 'outside':\n                default:\n                    return 1 /* OUTSIDE */;\n            }\n        }\n    };\n\n    var listStyleType = {\n        name: 'list-style-type',\n        initialValue: 'none',\n        prefix: false,\n        type: 2 /* IDENT_VALUE */,\n        parse: function (_context, type) {\n            switch (type) {\n                case 'disc':\n                    return 0 /* DISC */;\n                case 'circle':\n                    return 1 /* CIRCLE */;\n                case 'square':\n                    return 2 /* SQUARE */;\n                case 'decimal':\n                    return 3 /* DECIMAL */;\n                case 'cjk-decimal':\n                    return 4 /* CJK_DECIMAL */;\n                case 'decimal-leading-zero':\n                    return 5 /* DECIMAL_LEADING_ZERO */;\n                case 'lower-roman':\n                    return 6 /* LOWER_ROMAN */;\n                case 'upper-roman':\n                    return 7 /* UPPER_ROMAN */;\n                case 'lower-greek':\n                    return 8 /* LOWER_GREEK */;\n                case 'lower-alpha':\n                    return 9 /* LOWER_ALPHA */;\n                case 'upper-alpha':\n                    return 10 /* UPPER_ALPHA */;\n                case 'arabic-indic':\n                    return 11 /* ARABIC_INDIC */;\n                case 'armenian':\n                    return 12 /* ARMENIAN */;\n                case 'bengali':\n                    return 13 /* BENGALI */;\n                case 'cambodian':\n                    return 14 /* CAMBODIAN */;\n                case 'cjk-earthly-branch':\n                    return 15 /* CJK_EARTHLY_BRANCH */;\n                case 'cjk-heavenly-stem':\n                    return 16 /* CJK_HEAVENLY_STEM */;\n                case 'cjk-ideographic':\n                    return 17 /* CJK_IDEOGRAPHIC */;\n                case 'devanagari':\n                    return 18 /* DEVANAGARI */;\n                case 'ethiopic-numeric':\n                    return 19 /* ETHIOPIC_NUMERIC */;\n                case 'georgian':\n                    return 20 /* GEORGIAN */;\n                case 'gujarati':\n                    return 21 /* GUJARATI */;\n                case 'gurmukhi':\n                    return 22 /* GURMUKHI */;\n                case 'hebrew':\n                    return 22 /* HEBREW */;\n                case 'hiragana':\n                    return 23 /* HIRAGANA */;\n                case 'hiragana-iroha':\n                    return 24 /* HIRAGANA_IROHA */;\n                case 'japanese-formal':\n                    return 25 /* JAPANESE_FORMAL */;\n                case 'japanese-informal':\n                    return 26 /* JAPANESE_INFORMAL */;\n                case 'kannada':\n                    return 27 /* KANNADA */;\n                case 'katakana':\n                    return 28 /* KATAKANA */;\n                case 'katakana-iroha':\n                    return 29 /* KATAKANA_IROHA */;\n                case 'khmer':\n                    return 30 /* KHMER */;\n                case 'korean-hangul-formal':\n                    return 31 /* KOREAN_HANGUL_FORMAL */;\n                case 'korean-hanja-formal':\n                    return 32 /* KOREAN_HANJA_FORMAL */;\n                case 'korean-hanja-informal':\n                    return 33 /* KOREAN_HANJA_INFORMAL */;\n                case 'lao':\n                    return 34 /* LAO */;\n                case 'lower-armenian':\n                    return 35 /* LOWER_ARMENIAN */;\n                case 'malayalam':\n                    return 36 /* MALAYALAM */;\n                case 'mongolian':\n                    return 37 /* MONGOLIAN */;\n                case 'myanmar':\n                    return 38 /* MYANMAR */;\n                case 'oriya':\n                    return 39 /* ORIYA */;\n                case 'persian':\n                    return 40 /* PERSIAN */;\n                case 'simp-chinese-formal':\n                    return 41 /* SIMP_CHINESE_FORMAL */;\n                case 'simp-chinese-informal':\n                    return 42 /* SIMP_CHINESE_INFORMAL */;\n                case 'tamil':\n                    return 43 /* TAMIL */;\n                case 'telugu':\n                    return 44 /* TELUGU */;\n                case 'thai':\n                    return 45 /* THAI */;\n                case 'tibetan':\n                    return 46 /* TIBETAN */;\n                case 'trad-chinese-formal':\n                    return 47 /* TRAD_CHINESE_FORMAL */;\n                case 'trad-chinese-informal':\n                    return 48 /* TRAD_CHINESE_INFORMAL */;\n                case 'upper-armenian':\n                    return 49 /* UPPER_ARMENIAN */;\n                case 'disclosure-open':\n                    return 50 /* DISCLOSURE_OPEN */;\n                case 'disclosure-closed':\n                    return 51 /* DISCLOSURE_CLOSED */;\n                case 'none':\n                default:\n                    return -1 /* NONE */;\n            }\n        }\n    };\n\n    var marginForSide = function (side) { return ({\n        name: \"margin-\" + side,\n        initialValue: '0',\n        prefix: false,\n        type: 4 /* TOKEN_VALUE */\n    }); };\n    var marginTop = marginForSide('top');\n    var marginRight = marginForSide('right');\n    var marginBottom = marginForSide('bottom');\n    var marginLeft = marginForSide('left');\n\n    var overflow = {\n        name: 'overflow',\n        initialValue: 'visible',\n        prefix: false,\n        type: 1 /* LIST */,\n        parse: function (_context, tokens) {\n            return tokens.filter(isIdentToken).map(function (overflow) {\n                switch (overflow.value) {\n                    case 'hidden':\n                        return 1 /* HIDDEN */;\n                    case 'scroll':\n                        return 2 /* SCROLL */;\n                    case 'clip':\n                        return 3 /* CLIP */;\n                    case 'auto':\n                        return 4 /* AUTO */;\n                    case 'visible':\n                    default:\n                        return 0 /* VISIBLE */;\n                }\n            });\n        }\n    };\n\n    var overflowWrap = {\n        name: 'overflow-wrap',\n        initialValue: 'normal',\n        prefix: false,\n        type: 2 /* IDENT_VALUE */,\n        parse: function (_context, overflow) {\n            switch (overflow) {\n                case 'break-word':\n                    return \"break-word\" /* BREAK_WORD */;\n                case 'normal':\n                default:\n                    return \"normal\" /* NORMAL */;\n            }\n        }\n    };\n\n    var paddingForSide = function (side) { return ({\n        name: \"padding-\" + side,\n        initialValue: '0',\n        prefix: false,\n        type: 3 /* TYPE_VALUE */,\n        format: 'length-percentage'\n    }); };\n    var paddingTop = paddingForSide('top');\n    var paddingRight = paddingForSide('right');\n    var paddingBottom = paddingForSide('bottom');\n    var paddingLeft = paddingForSide('left');\n\n    var textAlign = {\n        name: 'text-align',\n        initialValue: 'left',\n        prefix: false,\n        type: 2 /* IDENT_VALUE */,\n        parse: function (_context, textAlign) {\n            switch (textAlign) {\n                case 'right':\n                    return 2 /* RIGHT */;\n                case 'center':\n                case 'justify':\n                    return 1 /* CENTER */;\n                case 'left':\n                default:\n                    return 0 /* LEFT */;\n            }\n        }\n    };\n\n    var position = {\n        name: 'position',\n        initialValue: 'static',\n        prefix: false,\n        type: 2 /* IDENT_VALUE */,\n        parse: function (_context, position) {\n            switch (position) {\n                case 'relative':\n                    return 1 /* RELATIVE */;\n                case 'absolute':\n                    return 2 /* ABSOLUTE */;\n                case 'fixed':\n                    return 3 /* FIXED */;\n                case 'sticky':\n                    return 4 /* STICKY */;\n            }\n            return 0 /* STATIC */;\n        }\n    };\n\n    var textShadow = {\n        name: 'text-shadow',\n        initialValue: 'none',\n        type: 1 /* LIST */,\n        prefix: false,\n        parse: function (context, tokens) {\n            if (tokens.length === 1 && isIdentWithValue(tokens[0], 'none')) {\n                return [];\n            }\n            return parseFunctionArgs(tokens).map(function (values) {\n                var shadow = {\n                    color: COLORS.TRANSPARENT,\n                    offsetX: ZERO_LENGTH,\n                    offsetY: ZERO_LENGTH,\n                    blur: ZERO_LENGTH\n                };\n                var c = 0;\n                for (var i = 0; i < values.length; i++) {\n                    var token = values[i];\n                    if (isLength(token)) {\n                        if (c === 0) {\n                            shadow.offsetX = token;\n                        }\n                        else if (c === 1) {\n                            shadow.offsetY = token;\n                        }\n                        else {\n                            shadow.blur = token;\n                        }\n                        c++;\n                    }\n                    else {\n                        shadow.color = color$1.parse(context, token);\n                    }\n                }\n                return shadow;\n            });\n        }\n    };\n\n    var textTransform = {\n        name: 'text-transform',\n        initialValue: 'none',\n        prefix: false,\n        type: 2 /* IDENT_VALUE */,\n        parse: function (_context, textTransform) {\n            switch (textTransform) {\n                case 'uppercase':\n                    return 2 /* UPPERCASE */;\n                case 'lowercase':\n                    return 1 /* LOWERCASE */;\n                case 'capitalize':\n                    return 3 /* CAPITALIZE */;\n            }\n            return 0 /* NONE */;\n        }\n    };\n\n    var transform$1 = {\n        name: 'transform',\n        initialValue: 'none',\n        prefix: true,\n        type: 0 /* VALUE */,\n        parse: function (_context, token) {\n            if (token.type === 20 /* IDENT_TOKEN */ && token.value === 'none') {\n                return null;\n            }\n            if (token.type === 18 /* FUNCTION */) {\n                var transformFunction = SUPPORTED_TRANSFORM_FUNCTIONS[token.name];\n                if (typeof transformFunction === 'undefined') {\n                    throw new Error(\"Attempting to parse an unsupported transform function \\\"\" + token.name + \"\\\"\");\n                }\n                return transformFunction(token.values);\n            }\n            return null;\n        }\n    };\n    var matrix = function (args) {\n        var values = args.filter(function (arg) { return arg.type === 17 /* NUMBER_TOKEN */; }).map(function (arg) { return arg.number; });\n        return values.length === 6 ? values : null;\n    };\n    // doesn't support 3D transforms at the moment\n    var matrix3d = function (args) {\n        var values = args.filter(function (arg) { return arg.type === 17 /* NUMBER_TOKEN */; }).map(function (arg) { return arg.number; });\n        var a1 = values[0], b1 = values[1]; values[2]; values[3]; var a2 = values[4], b2 = values[5]; values[6]; values[7]; values[8]; values[9]; values[10]; values[11]; var a4 = values[12], b4 = values[13]; values[14]; values[15];\n        return values.length === 16 ? [a1, b1, a2, b2, a4, b4] : null;\n    };\n    var SUPPORTED_TRANSFORM_FUNCTIONS = {\n        matrix: matrix,\n        matrix3d: matrix3d\n    };\n\n    var DEFAULT_VALUE = {\n        type: 16 /* PERCENTAGE_TOKEN */,\n        number: 50,\n        flags: FLAG_INTEGER\n    };\n    var DEFAULT = [DEFAULT_VALUE, DEFAULT_VALUE];\n    var transformOrigin = {\n        name: 'transform-origin',\n        initialValue: '50% 50%',\n        prefix: true,\n        type: 1 /* LIST */,\n        parse: function (_context, tokens) {\n            var origins = tokens.filter(isLengthPercentage);\n            if (origins.length !== 2) {\n                return DEFAULT;\n            }\n            return [origins[0], origins[1]];\n        }\n    };\n\n    var visibility = {\n        name: 'visible',\n        initialValue: 'none',\n        prefix: false,\n        type: 2 /* IDENT_VALUE */,\n        parse: function (_context, visibility) {\n            switch (visibility) {\n                case 'hidden':\n                    return 1 /* HIDDEN */;\n                case 'collapse':\n                    return 2 /* COLLAPSE */;\n                case 'visible':\n                default:\n                    return 0 /* VISIBLE */;\n            }\n        }\n    };\n\n    var WORD_BREAK;\n    (function (WORD_BREAK) {\n        WORD_BREAK[\"NORMAL\"] = \"normal\";\n        WORD_BREAK[\"BREAK_ALL\"] = \"break-all\";\n        WORD_BREAK[\"KEEP_ALL\"] = \"keep-all\";\n    })(WORD_BREAK || (WORD_BREAK = {}));\n    var wordBreak = {\n        name: 'word-break',\n        initialValue: 'normal',\n        prefix: false,\n        type: 2 /* IDENT_VALUE */,\n        parse: function (_context, wordBreak) {\n            switch (wordBreak) {\n                case 'break-all':\n                    return WORD_BREAK.BREAK_ALL;\n                case 'keep-all':\n                    return WORD_BREAK.KEEP_ALL;\n                case 'normal':\n                default:\n                    return WORD_BREAK.NORMAL;\n            }\n        }\n    };\n\n    var zIndex = {\n        name: 'z-index',\n        initialValue: 'auto',\n        prefix: false,\n        type: 0 /* VALUE */,\n        parse: function (_context, token) {\n            if (token.type === 20 /* IDENT_TOKEN */) {\n                return { auto: true, order: 0 };\n            }\n            if (isNumberToken(token)) {\n                return { auto: false, order: token.number };\n            }\n            throw new Error(\"Invalid z-index number parsed\");\n        }\n    };\n\n    var time = {\n        name: 'time',\n        parse: function (_context, value) {\n            if (value.type === 15 /* DIMENSION_TOKEN */) {\n                switch (value.unit.toLowerCase()) {\n                    case 's':\n                        return 1000 * value.number;\n                    case 'ms':\n                        return value.number;\n                }\n            }\n            throw new Error(\"Unsupported time type\");\n        }\n    };\n\n    var opacity = {\n        name: 'opacity',\n        initialValue: '1',\n        type: 0 /* VALUE */,\n        prefix: false,\n        parse: function (_context, token) {\n            if (isNumberToken(token)) {\n                return token.number;\n            }\n            return 1;\n        }\n    };\n\n    var textDecorationColor = {\n        name: \"text-decoration-color\",\n        initialValue: 'transparent',\n        prefix: false,\n        type: 3 /* TYPE_VALUE */,\n        format: 'color'\n    };\n\n    var textDecorationLine = {\n        name: 'text-decoration-line',\n        initialValue: 'none',\n        prefix: false,\n        type: 1 /* LIST */,\n        parse: function (_context, tokens) {\n            return tokens\n                .filter(isIdentToken)\n                .map(function (token) {\n                switch (token.value) {\n                    case 'underline':\n                        return 1 /* UNDERLINE */;\n                    case 'overline':\n                        return 2 /* OVERLINE */;\n                    case 'line-through':\n                        return 3 /* LINE_THROUGH */;\n                    case 'none':\n                        return 4 /* BLINK */;\n                }\n                return 0 /* NONE */;\n            })\n                .filter(function (line) { return line !== 0 /* NONE */; });\n        }\n    };\n\n    var fontFamily = {\n        name: \"font-family\",\n        initialValue: '',\n        prefix: false,\n        type: 1 /* LIST */,\n        parse: function (_context, tokens) {\n            var accumulator = [];\n            var results = [];\n            tokens.forEach(function (token) {\n                switch (token.type) {\n                    case 20 /* IDENT_TOKEN */:\n                    case 0 /* STRING_TOKEN */:\n                        accumulator.push(token.value);\n                        break;\n                    case 17 /* NUMBER_TOKEN */:\n                        accumulator.push(token.number.toString());\n                        break;\n                    case 4 /* COMMA_TOKEN */:\n                        results.push(accumulator.join(' '));\n                        accumulator.length = 0;\n                        break;\n                }\n            });\n            if (accumulator.length) {\n                results.push(accumulator.join(' '));\n            }\n            return results.map(function (result) { return (result.indexOf(' ') === -1 ? result : \"'\" + result + \"'\"); });\n        }\n    };\n\n    var fontSize = {\n        name: \"font-size\",\n        initialValue: '0',\n        prefix: false,\n        type: 3 /* TYPE_VALUE */,\n        format: 'length'\n    };\n\n    var fontWeight = {\n        name: 'font-weight',\n        initialValue: 'normal',\n        type: 0 /* VALUE */,\n        prefix: false,\n        parse: function (_context, token) {\n            if (isNumberToken(token)) {\n                return token.number;\n            }\n            if (isIdentToken(token)) {\n                switch (token.value) {\n                    case 'bold':\n                        return 700;\n                    case 'normal':\n                    default:\n                        return 400;\n                }\n            }\n            return 400;\n        }\n    };\n\n    var fontVariant = {\n        name: 'font-variant',\n        initialValue: 'none',\n        type: 1 /* LIST */,\n        prefix: false,\n        parse: function (_context, tokens) {\n            return tokens.filter(isIdentToken).map(function (token) { return token.value; });\n        }\n    };\n\n    var fontStyle = {\n        name: 'font-style',\n        initialValue: 'normal',\n        prefix: false,\n        type: 2 /* IDENT_VALUE */,\n        parse: function (_context, overflow) {\n            switch (overflow) {\n                case 'oblique':\n                    return \"oblique\" /* OBLIQUE */;\n                case 'italic':\n                    return \"italic\" /* ITALIC */;\n                case 'normal':\n                default:\n                    return \"normal\" /* NORMAL */;\n            }\n        }\n    };\n\n    var contains = function (bit, value) { return (bit & value) !== 0; };\n\n    var content = {\n        name: 'content',\n        initialValue: 'none',\n        type: 1 /* LIST */,\n        prefix: false,\n        parse: function (_context, tokens) {\n            if (tokens.length === 0) {\n                return [];\n            }\n            var first = tokens[0];\n            if (first.type === 20 /* IDENT_TOKEN */ && first.value === 'none') {\n                return [];\n            }\n            return tokens;\n        }\n    };\n\n    var counterIncrement = {\n        name: 'counter-increment',\n        initialValue: 'none',\n        prefix: true,\n        type: 1 /* LIST */,\n        parse: function (_context, tokens) {\n            if (tokens.length === 0) {\n                return null;\n            }\n            var first = tokens[0];\n            if (first.type === 20 /* IDENT_TOKEN */ && first.value === 'none') {\n                return null;\n            }\n            var increments = [];\n            var filtered = tokens.filter(nonWhiteSpace);\n            for (var i = 0; i < filtered.length; i++) {\n                var counter = filtered[i];\n                var next = filtered[i + 1];\n                if (counter.type === 20 /* IDENT_TOKEN */) {\n                    var increment = next && isNumberToken(next) ? next.number : 1;\n                    increments.push({ counter: counter.value, increment: increment });\n                }\n            }\n            return increments;\n        }\n    };\n\n    var counterReset = {\n        name: 'counter-reset',\n        initialValue: 'none',\n        prefix: true,\n        type: 1 /* LIST */,\n        parse: function (_context, tokens) {\n            if (tokens.length === 0) {\n                return [];\n            }\n            var resets = [];\n            var filtered = tokens.filter(nonWhiteSpace);\n            for (var i = 0; i < filtered.length; i++) {\n                var counter = filtered[i];\n                var next = filtered[i + 1];\n                if (isIdentToken(counter) && counter.value !== 'none') {\n                    var reset = next && isNumberToken(next) ? next.number : 0;\n                    resets.push({ counter: counter.value, reset: reset });\n                }\n            }\n            return resets;\n        }\n    };\n\n    var duration = {\n        name: 'duration',\n        initialValue: '0s',\n        prefix: false,\n        type: 1 /* LIST */,\n        parse: function (context, tokens) {\n            return tokens.filter(isDimensionToken).map(function (token) { return time.parse(context, token); });\n        }\n    };\n\n    var quotes = {\n        name: 'quotes',\n        initialValue: 'none',\n        prefix: true,\n        type: 1 /* LIST */,\n        parse: function (_context, tokens) {\n            if (tokens.length === 0) {\n                return null;\n            }\n            var first = tokens[0];\n            if (first.type === 20 /* IDENT_TOKEN */ && first.value === 'none') {\n                return null;\n            }\n            var quotes = [];\n            var filtered = tokens.filter(isStringToken);\n            if (filtered.length % 2 !== 0) {\n                return null;\n            }\n            for (var i = 0; i < filtered.length; i += 2) {\n                var open_1 = filtered[i].value;\n                var close_1 = filtered[i + 1].value;\n                quotes.push({ open: open_1, close: close_1 });\n            }\n            return quotes;\n        }\n    };\n    var getQuote = function (quotes, depth, open) {\n        if (!quotes) {\n            return '';\n        }\n        var quote = quotes[Math.min(depth, quotes.length - 1)];\n        if (!quote) {\n            return '';\n        }\n        return open ? quote.open : quote.close;\n    };\n\n    var boxShadow = {\n        name: 'box-shadow',\n        initialValue: 'none',\n        type: 1 /* LIST */,\n        prefix: false,\n        parse: function (context, tokens) {\n            if (tokens.length === 1 && isIdentWithValue(tokens[0], 'none')) {\n                return [];\n            }\n            return parseFunctionArgs(tokens).map(function (values) {\n                var shadow = {\n                    color: 0x000000ff,\n                    offsetX: ZERO_LENGTH,\n                    offsetY: ZERO_LENGTH,\n                    blur: ZERO_LENGTH,\n                    spread: ZERO_LENGTH,\n                    inset: false\n                };\n                var c = 0;\n                for (var i = 0; i < values.length; i++) {\n                    var token = values[i];\n                    if (isIdentWithValue(token, 'inset')) {\n                        shadow.inset = true;\n                    }\n                    else if (isLength(token)) {\n                        if (c === 0) {\n                            shadow.offsetX = token;\n                        }\n                        else if (c === 1) {\n                            shadow.offsetY = token;\n                        }\n                        else if (c === 2) {\n                            shadow.blur = token;\n                        }\n                        else {\n                            shadow.spread = token;\n                        }\n                        c++;\n                    }\n                    else {\n                        shadow.color = color$1.parse(context, token);\n                    }\n                }\n                return shadow;\n            });\n        }\n    };\n\n    var paintOrder = {\n        name: 'paint-order',\n        initialValue: 'normal',\n        prefix: false,\n        type: 1 /* LIST */,\n        parse: function (_context, tokens) {\n            var DEFAULT_VALUE = [0 /* FILL */, 1 /* STROKE */, 2 /* MARKERS */];\n            var layers = [];\n            tokens.filter(isIdentToken).forEach(function (token) {\n                switch (token.value) {\n                    case 'stroke':\n                        layers.push(1 /* STROKE */);\n                        break;\n                    case 'fill':\n                        layers.push(0 /* FILL */);\n                        break;\n                    case 'markers':\n                        layers.push(2 /* MARKERS */);\n                        break;\n                }\n            });\n            DEFAULT_VALUE.forEach(function (value) {\n                if (layers.indexOf(value) === -1) {\n                    layers.push(value);\n                }\n            });\n            return layers;\n        }\n    };\n\n    var webkitTextStrokeColor = {\n        name: \"-webkit-text-stroke-color\",\n        initialValue: 'currentcolor',\n        prefix: false,\n        type: 3 /* TYPE_VALUE */,\n        format: 'color'\n    };\n\n    var webkitTextStrokeWidth = {\n        name: \"-webkit-text-stroke-width\",\n        initialValue: '0',\n        type: 0 /* VALUE */,\n        prefix: false,\n        parse: function (_context, token) {\n            if (isDimensionToken(token)) {\n                return token.number;\n            }\n            return 0;\n        }\n    };\n\n    var CSSParsedDeclaration = /** @class */ (function () {\n        function CSSParsedDeclaration(context, declaration) {\n            var _a, _b;\n            this.animationDuration = parse(context, duration, declaration.animationDuration);\n            this.backgroundClip = parse(context, backgroundClip, declaration.backgroundClip);\n            this.backgroundColor = parse(context, backgroundColor, declaration.backgroundColor);\n            this.backgroundImage = parse(context, backgroundImage, declaration.backgroundImage);\n            this.backgroundOrigin = parse(context, backgroundOrigin, declaration.backgroundOrigin);\n            this.backgroundPosition = parse(context, backgroundPosition, declaration.backgroundPosition);\n            this.backgroundRepeat = parse(context, backgroundRepeat, declaration.backgroundRepeat);\n            this.backgroundSize = parse(context, backgroundSize, declaration.backgroundSize);\n            this.borderTopColor = parse(context, borderTopColor, declaration.borderTopColor);\n            this.borderRightColor = parse(context, borderRightColor, declaration.borderRightColor);\n            this.borderBottomColor = parse(context, borderBottomColor, declaration.borderBottomColor);\n            this.borderLeftColor = parse(context, borderLeftColor, declaration.borderLeftColor);\n            this.borderTopLeftRadius = parse(context, borderTopLeftRadius, declaration.borderTopLeftRadius);\n            this.borderTopRightRadius = parse(context, borderTopRightRadius, declaration.borderTopRightRadius);\n            this.borderBottomRightRadius = parse(context, borderBottomRightRadius, declaration.borderBottomRightRadius);\n            this.borderBottomLeftRadius = parse(context, borderBottomLeftRadius, declaration.borderBottomLeftRadius);\n            this.borderTopStyle = parse(context, borderTopStyle, declaration.borderTopStyle);\n            this.borderRightStyle = parse(context, borderRightStyle, declaration.borderRightStyle);\n            this.borderBottomStyle = parse(context, borderBottomStyle, declaration.borderBottomStyle);\n            this.borderLeftStyle = parse(context, borderLeftStyle, declaration.borderLeftStyle);\n            this.borderTopWidth = parse(context, borderTopWidth, declaration.borderTopWidth);\n            this.borderRightWidth = parse(context, borderRightWidth, declaration.borderRightWidth);\n            this.borderBottomWidth = parse(context, borderBottomWidth, declaration.borderBottomWidth);\n            this.borderLeftWidth = parse(context, borderLeftWidth, declaration.borderLeftWidth);\n            this.boxShadow = parse(context, boxShadow, declaration.boxShadow);\n            this.color = parse(context, color, declaration.color);\n            this.direction = parse(context, direction, declaration.direction);\n            this.display = parse(context, display, declaration.display);\n            this.float = parse(context, float, declaration.cssFloat);\n            this.fontFamily = parse(context, fontFamily, declaration.fontFamily);\n            this.fontSize = parse(context, fontSize, declaration.fontSize);\n            this.fontStyle = parse(context, fontStyle, declaration.fontStyle);\n            this.fontVariant = parse(context, fontVariant, declaration.fontVariant);\n            this.fontWeight = parse(context, fontWeight, declaration.fontWeight);\n            this.letterSpacing = parse(context, letterSpacing, declaration.letterSpacing);\n            this.lineBreak = parse(context, lineBreak, declaration.lineBreak);\n            this.lineHeight = parse(context, lineHeight, declaration.lineHeight);\n            this.listStyleImage = parse(context, listStyleImage, declaration.listStyleImage);\n            this.listStylePosition = parse(context, listStylePosition, declaration.listStylePosition);\n            this.listStyleType = parse(context, listStyleType, declaration.listStyleType);\n            this.marginTop = parse(context, marginTop, declaration.marginTop);\n            this.marginRight = parse(context, marginRight, declaration.marginRight);\n            this.marginBottom = parse(context, marginBottom, declaration.marginBottom);\n            this.marginLeft = parse(context, marginLeft, declaration.marginLeft);\n            this.opacity = parse(context, opacity, declaration.opacity);\n            var overflowTuple = parse(context, overflow, declaration.overflow);\n            this.overflowX = overflowTuple[0];\n            this.overflowY = overflowTuple[overflowTuple.length > 1 ? 1 : 0];\n            this.overflowWrap = parse(context, overflowWrap, declaration.overflowWrap);\n            this.paddingTop = parse(context, paddingTop, declaration.paddingTop);\n            this.paddingRight = parse(context, paddingRight, declaration.paddingRight);\n            this.paddingBottom = parse(context, paddingBottom, declaration.paddingBottom);\n            this.paddingLeft = parse(context, paddingLeft, declaration.paddingLeft);\n            this.paintOrder = parse(context, paintOrder, declaration.paintOrder);\n            this.position = parse(context, position, declaration.position);\n            this.textAlign = parse(context, textAlign, declaration.textAlign);\n            this.textDecorationColor = parse(context, textDecorationColor, (_a = declaration.textDecorationColor) !== null && _a !== void 0 ? _a : declaration.color);\n            this.textDecorationLine = parse(context, textDecorationLine, (_b = declaration.textDecorationLine) !== null && _b !== void 0 ? _b : declaration.textDecoration);\n            this.textShadow = parse(context, textShadow, declaration.textShadow);\n            this.textTransform = parse(context, textTransform, declaration.textTransform);\n            this.transform = parse(context, transform$1, declaration.transform);\n            this.transformOrigin = parse(context, transformOrigin, declaration.transformOrigin);\n            this.visibility = parse(context, visibility, declaration.visibility);\n            this.webkitTextStrokeColor = parse(context, webkitTextStrokeColor, declaration.webkitTextStrokeColor);\n            this.webkitTextStrokeWidth = parse(context, webkitTextStrokeWidth, declaration.webkitTextStrokeWidth);\n            this.wordBreak = parse(context, wordBreak, declaration.wordBreak);\n            this.zIndex = parse(context, zIndex, declaration.zIndex);\n        }\n        CSSParsedDeclaration.prototype.isVisible = function () {\n            return this.display > 0 && this.opacity > 0 && this.visibility === 0 /* VISIBLE */;\n        };\n        CSSParsedDeclaration.prototype.isTransparent = function () {\n            return isTransparent(this.backgroundColor);\n        };\n        CSSParsedDeclaration.prototype.isTransformed = function () {\n            return this.transform !== null;\n        };\n        CSSParsedDeclaration.prototype.isPositioned = function () {\n            return this.position !== 0 /* STATIC */;\n        };\n        CSSParsedDeclaration.prototype.isPositionedWithZIndex = function () {\n            return this.isPositioned() && !this.zIndex.auto;\n        };\n        CSSParsedDeclaration.prototype.isFloating = function () {\n            return this.float !== 0 /* NONE */;\n        };\n        CSSParsedDeclaration.prototype.isInlineLevel = function () {\n            return (contains(this.display, 4 /* INLINE */) ||\n                contains(this.display, 33554432 /* INLINE_BLOCK */) ||\n                contains(this.display, 268435456 /* INLINE_FLEX */) ||\n                contains(this.display, 536870912 /* INLINE_GRID */) ||\n                contains(this.display, 67108864 /* INLINE_LIST_ITEM */) ||\n                contains(this.display, 134217728 /* INLINE_TABLE */));\n        };\n        return CSSParsedDeclaration;\n    }());\n    var CSSParsedPseudoDeclaration = /** @class */ (function () {\n        function CSSParsedPseudoDeclaration(context, declaration) {\n            this.content = parse(context, content, declaration.content);\n            this.quotes = parse(context, quotes, declaration.quotes);\n        }\n        return CSSParsedPseudoDeclaration;\n    }());\n    var CSSParsedCounterDeclaration = /** @class */ (function () {\n        function CSSParsedCounterDeclaration(context, declaration) {\n            this.counterIncrement = parse(context, counterIncrement, declaration.counterIncrement);\n            this.counterReset = parse(context, counterReset, declaration.counterReset);\n        }\n        return CSSParsedCounterDeclaration;\n    }());\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    var parse = function (context, descriptor, style) {\n        var tokenizer = new Tokenizer();\n        var value = style !== null && typeof style !== 'undefined' ? style.toString() : descriptor.initialValue;\n        tokenizer.write(value);\n        var parser = new Parser(tokenizer.read());\n        switch (descriptor.type) {\n            case 2 /* IDENT_VALUE */:\n                var token = parser.parseComponentValue();\n                return descriptor.parse(context, isIdentToken(token) ? token.value : descriptor.initialValue);\n            case 0 /* VALUE */:\n                return descriptor.parse(context, parser.parseComponentValue());\n            case 1 /* LIST */:\n                return descriptor.parse(context, parser.parseComponentValues());\n            case 4 /* TOKEN_VALUE */:\n                return parser.parseComponentValue();\n            case 3 /* TYPE_VALUE */:\n                switch (descriptor.format) {\n                    case 'angle':\n                        return angle.parse(context, parser.parseComponentValue());\n                    case 'color':\n                        return color$1.parse(context, parser.parseComponentValue());\n                    case 'image':\n                        return image.parse(context, parser.parseComponentValue());\n                    case 'length':\n                        var length_1 = parser.parseComponentValue();\n                        return isLength(length_1) ? length_1 : ZERO_LENGTH;\n                    case 'length-percentage':\n                        var value_1 = parser.parseComponentValue();\n                        return isLengthPercentage(value_1) ? value_1 : ZERO_LENGTH;\n                    case 'time':\n                        return time.parse(context, parser.parseComponentValue());\n                }\n                break;\n        }\n    };\n\n    var elementDebuggerAttribute = 'data-html2canvas-debug';\n    var getElementDebugType = function (element) {\n        var attribute = element.getAttribute(elementDebuggerAttribute);\n        switch (attribute) {\n            case 'all':\n                return 1 /* ALL */;\n            case 'clone':\n                return 2 /* CLONE */;\n            case 'parse':\n                return 3 /* PARSE */;\n            case 'render':\n                return 4 /* RENDER */;\n            default:\n                return 0 /* NONE */;\n        }\n    };\n    var isDebugging = function (element, type) {\n        var elementType = getElementDebugType(element);\n        return elementType === 1 /* ALL */ || type === elementType;\n    };\n\n    var ElementContainer = /** @class */ (function () {\n        function ElementContainer(context, element) {\n            this.context = context;\n            this.textNodes = [];\n            this.elements = [];\n            this.flags = 0;\n            if (isDebugging(element, 3 /* PARSE */)) {\n                debugger;\n            }\n            this.styles = new CSSParsedDeclaration(context, window.getComputedStyle(element, null));\n            if (isHTMLElementNode(element)) {\n                if (this.styles.animationDuration.some(function (duration) { return duration > 0; })) {\n                    element.style.animationDuration = '0s';\n                }\n                if (this.styles.transform !== null) {\n                    // getBoundingClientRect takes transforms into account\n                    element.style.transform = 'none';\n                }\n            }\n            this.bounds = parseBounds(this.context, element);\n            if (isDebugging(element, 4 /* RENDER */)) {\n                this.flags |= 16 /* DEBUG_RENDER */;\n            }\n        }\n        return ElementContainer;\n    }());\n\n    /*\n     * text-segmentation 1.0.3 <https://github.com/niklasvh/text-segmentation>\n     * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>\n     * Released under MIT License\n     */\n    var base64 = 'AAAAAAAAAAAAEA4AGBkAAFAaAAACAAAAAAAIABAAGAAwADgACAAQAAgAEAAIABAACAAQAAgAEAAIABAACAAQAAgAEAAIABAAQABIAEQATAAIABAACAAQAAgAEAAIABAAVABcAAgAEAAIABAACAAQAGAAaABwAHgAgACIAI4AlgAIABAAmwCjAKgAsAC2AL4AvQDFAMoA0gBPAVYBWgEIAAgACACMANoAYgFkAWwBdAF8AX0BhQGNAZUBlgGeAaMBlQGWAasBswF8AbsBwwF0AcsBYwHTAQgA2wG/AOMBdAF8AekB8QF0AfkB+wHiAHQBfAEIAAMC5gQIAAsCEgIIAAgAFgIeAggAIgIpAggAMQI5AkACygEIAAgASAJQAlgCYAIIAAgACAAKBQoFCgUTBRMFGQUrBSsFCAAIAAgACAAIAAgACAAIAAgACABdAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABoAmgCrwGvAQgAbgJ2AggAHgEIAAgACADnAXsCCAAIAAgAgwIIAAgACAAIAAgACACKAggAkQKZAggAPADJAAgAoQKkAqwCsgK6AsICCADJAggA0AIIAAgACAAIANYC3gIIAAgACAAIAAgACABAAOYCCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAkASoB+QIEAAgACAA8AEMCCABCBQgACABJBVAFCAAIAAgACAAIAAgACAAIAAgACABTBVoFCAAIAFoFCABfBWUFCAAIAAgACAAIAAgAbQUIAAgACAAIAAgACABzBXsFfQWFBYoFigWKBZEFigWKBYoFmAWfBaYFrgWxBbkFCAAIAAgACAAIAAgACAAIAAgACAAIAMEFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAMgFCADQBQgACAAIAAgACAAIAAgACAAIAAgACAAIAO4CCAAIAAgAiQAIAAgACABAAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAD0AggACAD8AggACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIANYFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAMDvwAIAAgAJAIIAAgACAAIAAgACAAIAAgACwMTAwgACAB9BOsEGwMjAwgAKwMyAwsFYgE3A/MEPwMIAEUDTQNRAwgAWQOsAGEDCAAIAAgACAAIAAgACABpAzQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFIQUoBSwFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABtAwgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABMAEwACAAIAAgACAAIABgACAAIAAgACAC/AAgACAAyAQgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACACAAIAAwAAgACAAIAAgACAAIAAgACAAIAAAARABIAAgACAAIABQASAAIAAgAIABwAEAAjgCIABsAqAC2AL0AigDQAtwC+IJIQqVAZUBWQqVAZUBlQGVAZUBlQGrC5UBlQGVAZUBlQGVAZUBlQGVAXsKlQGVAbAK6wsrDGUMpQzlDJUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAfAKAAuZA64AtwCJALoC6ADwAAgAuACgA/oEpgO6AqsD+AAIAAgAswMIAAgACAAIAIkAuwP5AfsBwwPLAwgACAAIAAgACADRA9kDCAAIAOED6QMIAAgACAAIAAgACADuA/YDCAAIAP4DyQAIAAgABgQIAAgAXQAOBAgACAAIAAgACAAIABMECAAIAAgACAAIAAgACAD8AAQBCAAIAAgAGgQiBCoECAExBAgAEAEIAAgACAAIAAgACAAIAAgACAAIAAgACAA4BAgACABABEYECAAIAAgATAQYAQgAVAQIAAgACAAIAAgACAAIAAgACAAIAFoECAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAOQEIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAB+BAcACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAEABhgSMBAgACAAIAAgAlAQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAwAEAAQABAADAAMAAwADAAQABAAEAAQABAAEAAQABHATAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAdQMIAAgACAAIAAgACAAIAMkACAAIAAgAfQMIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACACFA4kDCAAIAAgACAAIAOcBCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAIcDCAAIAAgACAAIAAgACAAIAAgACAAIAJEDCAAIAAgACADFAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABgBAgAZgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAbAQCBXIECAAIAHkECAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABAAJwEQACjBKoEsgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAC6BMIECAAIAAgACAAIAAgACABmBAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAxwQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAGYECAAIAAgAzgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAigWKBYoFigWKBYoFigWKBd0FXwUIAOIF6gXxBYoF3gT5BQAGCAaKBYoFigWKBYoFigWKBYoFigWKBYoFigXWBIoFigWKBYoFigWKBYoFigWKBYsFEAaKBYoFigWKBYoFigWKBRQGCACKBYoFigWKBQgACAAIANEECAAIABgGigUgBggAJgYIAC4GMwaKBYoF0wQ3Bj4GigWKBYoFigWKBYoFigWKBYoFigWKBYoFigUIAAgACAAIAAgACAAIAAgAigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWLBf///////wQABAAEAAQABAAEAAQABAAEAAQAAwAEAAQAAgAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAQADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAUAAAAFAAUAAAAFAAUAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUAAQAAAAUABQAFAAUABQAFAAAAAAAFAAUAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAFAAUAAQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUABQAFAAAABwAHAAcAAAAHAAcABwAFAAEAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAcABwAFAAUAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAAAAQABAAAAAAAAAAAAAAAFAAUABQAFAAAABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABwAHAAcAAAAHAAcAAAAAAAUABQAHAAUAAQAHAAEABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABwABAAUABQAFAAUAAAAAAAAAAAAAAAEAAQABAAEAAQABAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABQANAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEAAQABAAEAAQABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAABQAHAAUABQAFAAAAAAAAAAcABQAFAAUABQAFAAQABAAEAAQABAAEAAQABAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUAAAAFAAUABQAFAAUAAAAFAAUABQAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAAAAAAAAAAAAUABQAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAUAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABwAHAAcABwAFAAcABwAAAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAUABwAHAAUABQAFAAUAAAAAAAcABwAAAAAABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAABQAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAABwAHAAcABQAFAAAAAAAAAAAABQAFAAAAAAAFAAUABQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAFAAUABQAFAAUAAAAFAAUABwAAAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAFAAUABwAFAAUABQAFAAAAAAAHAAcAAAAAAAcABwAFAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABwAAAAAAAAAHAAcABwAAAAcABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAABQAHAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAcABwAAAAUABQAFAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABQAHAAcABQAHAAcAAAAFAAcABwAAAAcABwAFAAUAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAFAAcABwAFAAUABQAAAAUAAAAHAAcABwAHAAcABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAHAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAABwAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAUAAAAFAAAAAAAAAAAABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUABQAFAAUAAAAFAAUAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABwAFAAUABQAFAAUABQAAAAUABQAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABQAFAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABQAFAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAHAAUABQAFAAUABQAFAAUABwAHAAcABwAHAAcABwAHAAUABwAHAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABwAHAAcABwAFAAUABwAHAAcAAAAAAAAAAAAHAAcABQAHAAcABwAHAAcABwAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAHAAUABQAFAAUABQAFAAUAAAAFAAAABQAAAAAABQAFAAUABQAFAAUABQAFAAcABwAHAAcABwAHAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAUABQAFAAUABQAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABwAFAAcABwAHAAcABwAFAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAUABQAFAAUABwAHAAUABQAHAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABQAFAAcABwAHAAUABwAFAAUABQAHAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAUABQAFAAUABQAFAAUABQAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAcABQAFAAUABQAFAAUABQAAAAAAAAAAAAUAAAAAAAAAAAAAAAAABQAAAAAABwAFAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUAAAAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAABQAAAAAAAAAFAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAUABQAHAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAHAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABwAFAAUABQAFAAcABwAFAAUABwAHAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAcABwAFAAUABwAHAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAFAAUABQAAAAAABQAFAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAFAAcABwAAAAAAAAAAAAAABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAFAAcABwAFAAcABwAAAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAFAAUABQAAAAUABQAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABwAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABQAFAAUABQAFAAUABQAFAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAHAAcABQAHAAUABQAAAAAAAAAAAAAAAAAFAAAABwAHAAcABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAcABwAAAAAABwAHAAAAAAAHAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABwAHAAUABQAFAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABQAFAAUABQAFAAUABwAFAAcABwAFAAcABQAFAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABQAFAAUABQAAAAAABwAHAAcABwAFAAUABwAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAHAAUABQAFAAUABQAFAAUABQAHAAcABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAFAAcABwAFAAUABQAFAAUABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAcABwAFAAUABQAFAAcABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABQAHAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAAAAAAFAAUABwAHAAcABwAFAAAAAAAAAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABwAHAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAHAAUABQAFAAUABQAFAAUABwAFAAUABwAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAAAAAAAABQAAAAUABQAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAHAAcAAAAFAAUAAAAHAAcABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAAAAAAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAUABQAFAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAABQAFAAUABQAFAAUABQAAAAUABQAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAFAAUABQAFAAUADgAOAA4ADgAOAA4ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAAAAAAAAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAMAAwADAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAAAAAAAAAAAAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAAAAAAAAAAAAsADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwACwAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAADgAOAA4AAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAAAA4ADgAOAA4ADgAOAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAA4AAAAOAAAAAAAAAAAAAAAAAA4AAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAADgAAAAAAAAAAAA4AAAAOAAAAAAAAAAAADgAOAA4AAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAAAAA4ADgAOAA4ADgAOAA4ADgAOAAAADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4AAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAOAA4ADgAOAA4ADgAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAAAAAAA=';\n\n    /*\n     * utrie 1.0.2 <https://github.com/niklasvh/utrie>\n     * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>\n     * Released under MIT License\n     */\n    var chars$1 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n    // Use a lookup table to find the index.\n    var lookup$1 = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);\n    for (var i$1 = 0; i$1 < chars$1.length; i$1++) {\n        lookup$1[chars$1.charCodeAt(i$1)] = i$1;\n    }\n    var decode = function (base64) {\n        var bufferLength = base64.length * 0.75, len = base64.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;\n        if (base64[base64.length - 1] === '=') {\n            bufferLength--;\n            if (base64[base64.length - 2] === '=') {\n                bufferLength--;\n            }\n        }\n        var buffer = typeof ArrayBuffer !== 'undefined' &&\n            typeof Uint8Array !== 'undefined' &&\n            typeof Uint8Array.prototype.slice !== 'undefined'\n            ? new ArrayBuffer(bufferLength)\n            : new Array(bufferLength);\n        var bytes = Array.isArray(buffer) ? buffer : new Uint8Array(buffer);\n        for (i = 0; i < len; i += 4) {\n            encoded1 = lookup$1[base64.charCodeAt(i)];\n            encoded2 = lookup$1[base64.charCodeAt(i + 1)];\n            encoded3 = lookup$1[base64.charCodeAt(i + 2)];\n            encoded4 = lookup$1[base64.charCodeAt(i + 3)];\n            bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);\n            bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);\n            bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);\n        }\n        return buffer;\n    };\n    var polyUint16Array = function (buffer) {\n        var length = buffer.length;\n        var bytes = [];\n        for (var i = 0; i < length; i += 2) {\n            bytes.push((buffer[i + 1] << 8) | buffer[i]);\n        }\n        return bytes;\n    };\n    var polyUint32Array = function (buffer) {\n        var length = buffer.length;\n        var bytes = [];\n        for (var i = 0; i < length; i += 4) {\n            bytes.push((buffer[i + 3] << 24) | (buffer[i + 2] << 16) | (buffer[i + 1] << 8) | buffer[i]);\n        }\n        return bytes;\n    };\n\n    /** Shift size for getting the index-2 table offset. */\n    var UTRIE2_SHIFT_2 = 5;\n    /** Shift size for getting the index-1 table offset. */\n    var UTRIE2_SHIFT_1 = 6 + 5;\n    /**\n     * Shift size for shifting left the index array values.\n     * Increases possible data size with 16-bit index values at the cost\n     * of compactability.\n     * This requires data blocks to be aligned by UTRIE2_DATA_GRANULARITY.\n     */\n    var UTRIE2_INDEX_SHIFT = 2;\n    /**\n     * Difference between the two shift sizes,\n     * for getting an index-1 offset from an index-2 offset. 6=11-5\n     */\n    var UTRIE2_SHIFT_1_2 = UTRIE2_SHIFT_1 - UTRIE2_SHIFT_2;\n    /**\n     * The part of the index-2 table for U+D800..U+DBFF stores values for\n     * lead surrogate code _units_ not code _points_.\n     * Values for lead surrogate code _points_ are indexed with this portion of the table.\n     * Length=32=0x20=0x400>>UTRIE2_SHIFT_2. (There are 1024=0x400 lead surrogates.)\n     */\n    var UTRIE2_LSCP_INDEX_2_OFFSET = 0x10000 >> UTRIE2_SHIFT_2;\n    /** Number of entries in a data block. 32=0x20 */\n    var UTRIE2_DATA_BLOCK_LENGTH = 1 << UTRIE2_SHIFT_2;\n    /** Mask for getting the lower bits for the in-data-block offset. */\n    var UTRIE2_DATA_MASK = UTRIE2_DATA_BLOCK_LENGTH - 1;\n    var UTRIE2_LSCP_INDEX_2_LENGTH = 0x400 >> UTRIE2_SHIFT_2;\n    /** Count the lengths of both BMP pieces. 2080=0x820 */\n    var UTRIE2_INDEX_2_BMP_LENGTH = UTRIE2_LSCP_INDEX_2_OFFSET + UTRIE2_LSCP_INDEX_2_LENGTH;\n    /**\n     * The 2-byte UTF-8 version of the index-2 table follows at offset 2080=0x820.\n     * Length 32=0x20 for lead bytes C0..DF, regardless of UTRIE2_SHIFT_2.\n     */\n    var UTRIE2_UTF8_2B_INDEX_2_OFFSET = UTRIE2_INDEX_2_BMP_LENGTH;\n    var UTRIE2_UTF8_2B_INDEX_2_LENGTH = 0x800 >> 6; /* U+0800 is the first code point after 2-byte UTF-8 */\n    /**\n     * The index-1 table, only used for supplementary code points, at offset 2112=0x840.\n     * Variable length, for code points up to highStart, where the last single-value range starts.\n     * Maximum length 512=0x200=0x100000>>UTRIE2_SHIFT_1.\n     * (For 0x100000 supplementary code points U+10000..U+10ffff.)\n     *\n     * The part of the index-2 table for supplementary code points starts\n     * after this index-1 table.\n     *\n     * Both the index-1 table and the following part of the index-2 table\n     * are omitted completely if there is only BMP data.\n     */\n    var UTRIE2_INDEX_1_OFFSET = UTRIE2_UTF8_2B_INDEX_2_OFFSET + UTRIE2_UTF8_2B_INDEX_2_LENGTH;\n    /**\n     * Number of index-1 entries for the BMP. 32=0x20\n     * This part of the index-1 table is omitted from the serialized form.\n     */\n    var UTRIE2_OMITTED_BMP_INDEX_1_LENGTH = 0x10000 >> UTRIE2_SHIFT_1;\n    /** Number of entries in an index-2 block. 64=0x40 */\n    var UTRIE2_INDEX_2_BLOCK_LENGTH = 1 << UTRIE2_SHIFT_1_2;\n    /** Mask for getting the lower bits for the in-index-2-block offset. */\n    var UTRIE2_INDEX_2_MASK = UTRIE2_INDEX_2_BLOCK_LENGTH - 1;\n    var slice16 = function (view, start, end) {\n        if (view.slice) {\n            return view.slice(start, end);\n        }\n        return new Uint16Array(Array.prototype.slice.call(view, start, end));\n    };\n    var slice32 = function (view, start, end) {\n        if (view.slice) {\n            return view.slice(start, end);\n        }\n        return new Uint32Array(Array.prototype.slice.call(view, start, end));\n    };\n    var createTrieFromBase64 = function (base64, _byteLength) {\n        var buffer = decode(base64);\n        var view32 = Array.isArray(buffer) ? polyUint32Array(buffer) : new Uint32Array(buffer);\n        var view16 = Array.isArray(buffer) ? polyUint16Array(buffer) : new Uint16Array(buffer);\n        var headerLength = 24;\n        var index = slice16(view16, headerLength / 2, view32[4] / 2);\n        var data = view32[5] === 2\n            ? slice16(view16, (headerLength + view32[4]) / 2)\n            : slice32(view32, Math.ceil((headerLength + view32[4]) / 4));\n        return new Trie(view32[0], view32[1], view32[2], view32[3], index, data);\n    };\n    var Trie = /** @class */ (function () {\n        function Trie(initialValue, errorValue, highStart, highValueIndex, index, data) {\n            this.initialValue = initialValue;\n            this.errorValue = errorValue;\n            this.highStart = highStart;\n            this.highValueIndex = highValueIndex;\n            this.index = index;\n            this.data = data;\n        }\n        /**\n         * Get the value for a code point as stored in the Trie.\n         *\n         * @param codePoint the code point\n         * @return the value\n         */\n        Trie.prototype.get = function (codePoint) {\n            var ix;\n            if (codePoint >= 0) {\n                if (codePoint < 0x0d800 || (codePoint > 0x0dbff && codePoint <= 0x0ffff)) {\n                    // Ordinary BMP code point, excluding leading surrogates.\n                    // BMP uses a single level lookup.  BMP index starts at offset 0 in the Trie2 index.\n                    // 16 bit data is stored in the index array itself.\n                    ix = this.index[codePoint >> UTRIE2_SHIFT_2];\n                    ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);\n                    return this.data[ix];\n                }\n                if (codePoint <= 0xffff) {\n                    // Lead Surrogate Code Point.  A Separate index section is stored for\n                    // lead surrogate code units and code points.\n                    //   The main index has the code unit data.\n                    //   For this function, we need the code point data.\n                    // Note: this expression could be refactored for slightly improved efficiency, but\n                    //       surrogate code points will be so rare in practice that it's not worth it.\n                    ix = this.index[UTRIE2_LSCP_INDEX_2_OFFSET + ((codePoint - 0xd800) >> UTRIE2_SHIFT_2)];\n                    ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);\n                    return this.data[ix];\n                }\n                if (codePoint < this.highStart) {\n                    // Supplemental code point, use two-level lookup.\n                    ix = UTRIE2_INDEX_1_OFFSET - UTRIE2_OMITTED_BMP_INDEX_1_LENGTH + (codePoint >> UTRIE2_SHIFT_1);\n                    ix = this.index[ix];\n                    ix += (codePoint >> UTRIE2_SHIFT_2) & UTRIE2_INDEX_2_MASK;\n                    ix = this.index[ix];\n                    ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);\n                    return this.data[ix];\n                }\n                if (codePoint <= 0x10ffff) {\n                    return this.data[this.highValueIndex];\n                }\n            }\n            // Fall through.  The code point is outside of the legal range of 0..0x10ffff.\n            return this.errorValue;\n        };\n        return Trie;\n    }());\n\n    /*\n     * base64-arraybuffer 1.0.2 <https://github.com/niklasvh/base64-arraybuffer>\n     * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>\n     * Released under MIT License\n     */\n    var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n    // Use a lookup table to find the index.\n    var lookup = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);\n    for (var i = 0; i < chars.length; i++) {\n        lookup[chars.charCodeAt(i)] = i;\n    }\n\n    var Prepend = 1;\n    var CR = 2;\n    var LF = 3;\n    var Control = 4;\n    var Extend = 5;\n    var SpacingMark = 7;\n    var L = 8;\n    var V = 9;\n    var T = 10;\n    var LV = 11;\n    var LVT = 12;\n    var ZWJ = 13;\n    var Extended_Pictographic = 14;\n    var RI = 15;\n    var toCodePoints = function (str) {\n        var codePoints = [];\n        var i = 0;\n        var length = str.length;\n        while (i < length) {\n            var value = str.charCodeAt(i++);\n            if (value >= 0xd800 && value <= 0xdbff && i < length) {\n                var extra = str.charCodeAt(i++);\n                if ((extra & 0xfc00) === 0xdc00) {\n                    codePoints.push(((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000);\n                }\n                else {\n                    codePoints.push(value);\n                    i--;\n                }\n            }\n            else {\n                codePoints.push(value);\n            }\n        }\n        return codePoints;\n    };\n    var fromCodePoint = function () {\n        var codePoints = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            codePoints[_i] = arguments[_i];\n        }\n        if (String.fromCodePoint) {\n            return String.fromCodePoint.apply(String, codePoints);\n        }\n        var length = codePoints.length;\n        if (!length) {\n            return '';\n        }\n        var codeUnits = [];\n        var index = -1;\n        var result = '';\n        while (++index < length) {\n            var codePoint = codePoints[index];\n            if (codePoint <= 0xffff) {\n                codeUnits.push(codePoint);\n            }\n            else {\n                codePoint -= 0x10000;\n                codeUnits.push((codePoint >> 10) + 0xd800, (codePoint % 0x400) + 0xdc00);\n            }\n            if (index + 1 === length || codeUnits.length > 0x4000) {\n                result += String.fromCharCode.apply(String, codeUnits);\n                codeUnits.length = 0;\n            }\n        }\n        return result;\n    };\n    var UnicodeTrie = createTrieFromBase64(base64);\n    var BREAK_NOT_ALLOWED = '';\n    var BREAK_ALLOWED = '';\n    var codePointToClass = function (codePoint) { return UnicodeTrie.get(codePoint); };\n    var _graphemeBreakAtIndex = function (_codePoints, classTypes, index) {\n        var prevIndex = index - 2;\n        var prev = classTypes[prevIndex];\n        var current = classTypes[index - 1];\n        var next = classTypes[index];\n        // GB3 Do not break between a CR and LF\n        if (current === CR && next === LF) {\n            return BREAK_NOT_ALLOWED;\n        }\n        // GB4 Otherwise, break before and after controls.\n        if (current === CR || current === LF || current === Control) {\n            return BREAK_ALLOWED;\n        }\n        // GB5\n        if (next === CR || next === LF || next === Control) {\n            return BREAK_ALLOWED;\n        }\n        // Do not break Hangul syllable sequences.\n        // GB6\n        if (current === L && [L, V, LV, LVT].indexOf(next) !== -1) {\n            return BREAK_NOT_ALLOWED;\n        }\n        // GB7\n        if ((current === LV || current === V) && (next === V || next === T)) {\n            return BREAK_NOT_ALLOWED;\n        }\n        // GB8\n        if ((current === LVT || current === T) && next === T) {\n            return BREAK_NOT_ALLOWED;\n        }\n        // GB9 Do not break before extending characters or ZWJ.\n        if (next === ZWJ || next === Extend) {\n            return BREAK_NOT_ALLOWED;\n        }\n        // Do not break before SpacingMarks, or after Prepend characters.\n        // GB9a\n        if (next === SpacingMark) {\n            return BREAK_NOT_ALLOWED;\n        }\n        // GB9a\n        if (current === Prepend) {\n            return BREAK_NOT_ALLOWED;\n        }\n        // GB11 Do not break within emoji modifier sequences or emoji zwj sequences.\n        if (current === ZWJ && next === Extended_Pictographic) {\n            while (prev === Extend) {\n                prev = classTypes[--prevIndex];\n            }\n            if (prev === Extended_Pictographic) {\n                return BREAK_NOT_ALLOWED;\n            }\n        }\n        // GB12 Do not break within emoji flag sequences.\n        // That is, do not break between regional indicator (RI) symbols\n        // if there is an odd number of RI characters before the break point.\n        if (current === RI && next === RI) {\n            var countRI = 0;\n            while (prev === RI) {\n                countRI++;\n                prev = classTypes[--prevIndex];\n            }\n            if (countRI % 2 === 0) {\n                return BREAK_NOT_ALLOWED;\n            }\n        }\n        return BREAK_ALLOWED;\n    };\n    var GraphemeBreaker = function (str) {\n        var codePoints = toCodePoints(str);\n        var length = codePoints.length;\n        var index = 0;\n        var lastEnd = 0;\n        var classTypes = codePoints.map(codePointToClass);\n        return {\n            next: function () {\n                if (index >= length) {\n                    return { done: true, value: null };\n                }\n                var graphemeBreak = BREAK_NOT_ALLOWED;\n                while (index < length &&\n                    (graphemeBreak = _graphemeBreakAtIndex(codePoints, classTypes, ++index)) === BREAK_NOT_ALLOWED) { }\n                if (graphemeBreak !== BREAK_NOT_ALLOWED || index === length) {\n                    var value = fromCodePoint.apply(null, codePoints.slice(lastEnd, index));\n                    lastEnd = index;\n                    return { value: value, done: false };\n                }\n                return { done: true, value: null };\n            },\n        };\n    };\n    var splitGraphemes = function (str) {\n        var breaker = GraphemeBreaker(str);\n        var graphemes = [];\n        var bk;\n        while (!(bk = breaker.next()).done) {\n            if (bk.value) {\n                graphemes.push(bk.value.slice());\n            }\n        }\n        return graphemes;\n    };\n\n    var testRangeBounds = function (document) {\n        var TEST_HEIGHT = 123;\n        if (document.createRange) {\n            var range = document.createRange();\n            if (range.getBoundingClientRect) {\n                var testElement = document.createElement('boundtest');\n                testElement.style.height = TEST_HEIGHT + \"px\";\n                testElement.style.display = 'block';\n                document.body.appendChild(testElement);\n                range.selectNode(testElement);\n                var rangeBounds = range.getBoundingClientRect();\n                var rangeHeight = Math.round(rangeBounds.height);\n                document.body.removeChild(testElement);\n                if (rangeHeight === TEST_HEIGHT) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    };\n    var testIOSLineBreak = function (document) {\n        var testElement = document.createElement('boundtest');\n        testElement.style.width = '50px';\n        testElement.style.display = 'block';\n        testElement.style.fontSize = '12px';\n        testElement.style.letterSpacing = '0px';\n        testElement.style.wordSpacing = '0px';\n        document.body.appendChild(testElement);\n        var range = document.createRange();\n        testElement.innerHTML = typeof ''.repeat === 'function' ? '&#128104;'.repeat(10) : '';\n        var node = testElement.firstChild;\n        var textList = toCodePoints$1(node.data).map(function (i) { return fromCodePoint$1(i); });\n        var offset = 0;\n        var prev = {};\n        // ios 13 does not handle range getBoundingClientRect line changes correctly #2177\n        var supports = textList.every(function (text, i) {\n            range.setStart(node, offset);\n            range.setEnd(node, offset + text.length);\n            var rect = range.getBoundingClientRect();\n            offset += text.length;\n            var boundAhead = rect.x > prev.x || rect.y > prev.y;\n            prev = rect;\n            if (i === 0) {\n                return true;\n            }\n            return boundAhead;\n        });\n        document.body.removeChild(testElement);\n        return supports;\n    };\n    var testCORS = function () { return typeof new Image().crossOrigin !== 'undefined'; };\n    var testResponseType = function () { return typeof new XMLHttpRequest().responseType === 'string'; };\n    var testSVG = function (document) {\n        var img = new Image();\n        var canvas = document.createElement('canvas');\n        var ctx = canvas.getContext('2d');\n        if (!ctx) {\n            return false;\n        }\n        img.src = \"data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg'></svg>\";\n        try {\n            ctx.drawImage(img, 0, 0);\n            canvas.toDataURL();\n        }\n        catch (e) {\n            return false;\n        }\n        return true;\n    };\n    var isGreenPixel = function (data) {\n        return data[0] === 0 && data[1] === 255 && data[2] === 0 && data[3] === 255;\n    };\n    var testForeignObject = function (document) {\n        var canvas = document.createElement('canvas');\n        var size = 100;\n        canvas.width = size;\n        canvas.height = size;\n        var ctx = canvas.getContext('2d');\n        if (!ctx) {\n            return Promise.reject(false);\n        }\n        ctx.fillStyle = 'rgb(0, 255, 0)';\n        ctx.fillRect(0, 0, size, size);\n        var img = new Image();\n        var greenImageSrc = canvas.toDataURL();\n        img.src = greenImageSrc;\n        var svg = createForeignObjectSVG(size, size, 0, 0, img);\n        ctx.fillStyle = 'red';\n        ctx.fillRect(0, 0, size, size);\n        return loadSerializedSVG$1(svg)\n            .then(function (img) {\n            ctx.drawImage(img, 0, 0);\n            var data = ctx.getImageData(0, 0, size, size).data;\n            ctx.fillStyle = 'red';\n            ctx.fillRect(0, 0, size, size);\n            var node = document.createElement('div');\n            node.style.backgroundImage = \"url(\" + greenImageSrc + \")\";\n            node.style.height = size + \"px\";\n            // Firefox 55 does not render inline <img /> tags\n            return isGreenPixel(data)\n                ? loadSerializedSVG$1(createForeignObjectSVG(size, size, 0, 0, node))\n                : Promise.reject(false);\n        })\n            .then(function (img) {\n            ctx.drawImage(img, 0, 0);\n            // Edge does not render background-images\n            return isGreenPixel(ctx.getImageData(0, 0, size, size).data);\n        })\n            .catch(function () { return false; });\n    };\n    var createForeignObjectSVG = function (width, height, x, y, node) {\n        var xmlns = 'http://www.w3.org/2000/svg';\n        var svg = document.createElementNS(xmlns, 'svg');\n        var foreignObject = document.createElementNS(xmlns, 'foreignObject');\n        svg.setAttributeNS(null, 'width', width.toString());\n        svg.setAttributeNS(null, 'height', height.toString());\n        foreignObject.setAttributeNS(null, 'width', '100%');\n        foreignObject.setAttributeNS(null, 'height', '100%');\n        foreignObject.setAttributeNS(null, 'x', x.toString());\n        foreignObject.setAttributeNS(null, 'y', y.toString());\n        foreignObject.setAttributeNS(null, 'externalResourcesRequired', 'true');\n        svg.appendChild(foreignObject);\n        foreignObject.appendChild(node);\n        return svg;\n    };\n    var loadSerializedSVG$1 = function (svg) {\n        return new Promise(function (resolve, reject) {\n            var img = new Image();\n            img.onload = function () { return resolve(img); };\n            img.onerror = reject;\n            img.src = \"data:image/svg+xml;charset=utf-8,\" + encodeURIComponent(new XMLSerializer().serializeToString(svg));\n        });\n    };\n    var FEATURES = {\n        get SUPPORT_RANGE_BOUNDS() {\n            var value = testRangeBounds(document);\n            Object.defineProperty(FEATURES, 'SUPPORT_RANGE_BOUNDS', { value: value });\n            return value;\n        },\n        get SUPPORT_WORD_BREAKING() {\n            var value = FEATURES.SUPPORT_RANGE_BOUNDS && testIOSLineBreak(document);\n            Object.defineProperty(FEATURES, 'SUPPORT_WORD_BREAKING', { value: value });\n            return value;\n        },\n        get SUPPORT_SVG_DRAWING() {\n            var value = testSVG(document);\n            Object.defineProperty(FEATURES, 'SUPPORT_SVG_DRAWING', { value: value });\n            return value;\n        },\n        get SUPPORT_FOREIGNOBJECT_DRAWING() {\n            var value = typeof Array.from === 'function' && typeof window.fetch === 'function'\n                ? testForeignObject(document)\n                : Promise.resolve(false);\n            Object.defineProperty(FEATURES, 'SUPPORT_FOREIGNOBJECT_DRAWING', { value: value });\n            return value;\n        },\n        get SUPPORT_CORS_IMAGES() {\n            var value = testCORS();\n            Object.defineProperty(FEATURES, 'SUPPORT_CORS_IMAGES', { value: value });\n            return value;\n        },\n        get SUPPORT_RESPONSE_TYPE() {\n            var value = testResponseType();\n            Object.defineProperty(FEATURES, 'SUPPORT_RESPONSE_TYPE', { value: value });\n            return value;\n        },\n        get SUPPORT_CORS_XHR() {\n            var value = 'withCredentials' in new XMLHttpRequest();\n            Object.defineProperty(FEATURES, 'SUPPORT_CORS_XHR', { value: value });\n            return value;\n        },\n        get SUPPORT_NATIVE_TEXT_SEGMENTATION() {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            var value = !!(typeof Intl !== 'undefined' && Intl.Segmenter);\n            Object.defineProperty(FEATURES, 'SUPPORT_NATIVE_TEXT_SEGMENTATION', { value: value });\n            return value;\n        }\n    };\n\n    var TextBounds = /** @class */ (function () {\n        function TextBounds(text, bounds) {\n            this.text = text;\n            this.bounds = bounds;\n        }\n        return TextBounds;\n    }());\n    var parseTextBounds = function (context, value, styles, node) {\n        var textList = breakText(value, styles);\n        var textBounds = [];\n        var offset = 0;\n        textList.forEach(function (text) {\n            if (styles.textDecorationLine.length || text.trim().length > 0) {\n                if (FEATURES.SUPPORT_RANGE_BOUNDS) {\n                    var clientRects = createRange(node, offset, text.length).getClientRects();\n                    if (clientRects.length > 1) {\n                        var subSegments = segmentGraphemes(text);\n                        var subOffset_1 = 0;\n                        subSegments.forEach(function (subSegment) {\n                            textBounds.push(new TextBounds(subSegment, Bounds.fromDOMRectList(context, createRange(node, subOffset_1 + offset, subSegment.length).getClientRects())));\n                            subOffset_1 += subSegment.length;\n                        });\n                    }\n                    else {\n                        textBounds.push(new TextBounds(text, Bounds.fromDOMRectList(context, clientRects)));\n                    }\n                }\n                else {\n                    var replacementNode = node.splitText(text.length);\n                    textBounds.push(new TextBounds(text, getWrapperBounds(context, node)));\n                    node = replacementNode;\n                }\n            }\n            else if (!FEATURES.SUPPORT_RANGE_BOUNDS) {\n                node = node.splitText(text.length);\n            }\n            offset += text.length;\n        });\n        return textBounds;\n    };\n    var getWrapperBounds = function (context, node) {\n        var ownerDocument = node.ownerDocument;\n        if (ownerDocument) {\n            var wrapper = ownerDocument.createElement('html2canvaswrapper');\n            wrapper.appendChild(node.cloneNode(true));\n            var parentNode = node.parentNode;\n            if (parentNode) {\n                parentNode.replaceChild(wrapper, node);\n                var bounds = parseBounds(context, wrapper);\n                if (wrapper.firstChild) {\n                    parentNode.replaceChild(wrapper.firstChild, wrapper);\n                }\n                return bounds;\n            }\n        }\n        return Bounds.EMPTY;\n    };\n    var createRange = function (node, offset, length) {\n        var ownerDocument = node.ownerDocument;\n        if (!ownerDocument) {\n            throw new Error('Node has no owner document');\n        }\n        var range = ownerDocument.createRange();\n        range.setStart(node, offset);\n        range.setEnd(node, offset + length);\n        return range;\n    };\n    var segmentGraphemes = function (value) {\n        if (FEATURES.SUPPORT_NATIVE_TEXT_SEGMENTATION) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            var segmenter = new Intl.Segmenter(void 0, { granularity: 'grapheme' });\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            return Array.from(segmenter.segment(value)).map(function (segment) { return segment.segment; });\n        }\n        return splitGraphemes(value);\n    };\n    var segmentWords = function (value, styles) {\n        if (FEATURES.SUPPORT_NATIVE_TEXT_SEGMENTATION) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            var segmenter = new Intl.Segmenter(void 0, {\n                granularity: 'word'\n            });\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            return Array.from(segmenter.segment(value)).map(function (segment) { return segment.segment; });\n        }\n        return breakWords(value, styles);\n    };\n    var breakText = function (value, styles) {\n        return styles.letterSpacing !== 0 ? segmentGraphemes(value) : segmentWords(value, styles);\n    };\n    // https://drafts.csswg.org/css-text/#word-separator\n    var wordSeparators = [0x0020, 0x00a0, 0x1361, 0x10100, 0x10101, 0x1039, 0x1091];\n    var breakWords = function (str, styles) {\n        var breaker = LineBreaker(str, {\n            lineBreak: styles.lineBreak,\n            wordBreak: styles.overflowWrap === \"break-word\" /* BREAK_WORD */ ? 'break-word' : styles.wordBreak\n        });\n        var words = [];\n        var bk;\n        var _loop_1 = function () {\n            if (bk.value) {\n                var value = bk.value.slice();\n                var codePoints = toCodePoints$1(value);\n                var word_1 = '';\n                codePoints.forEach(function (codePoint) {\n                    if (wordSeparators.indexOf(codePoint) === -1) {\n                        word_1 += fromCodePoint$1(codePoint);\n                    }\n                    else {\n                        if (word_1.length) {\n                            words.push(word_1);\n                        }\n                        words.push(fromCodePoint$1(codePoint));\n                        word_1 = '';\n                    }\n                });\n                if (word_1.length) {\n                    words.push(word_1);\n                }\n            }\n        };\n        while (!(bk = breaker.next()).done) {\n            _loop_1();\n        }\n        return words;\n    };\n\n    var TextContainer = /** @class */ (function () {\n        function TextContainer(context, node, styles) {\n            this.text = transform(node.data, styles.textTransform);\n            this.textBounds = parseTextBounds(context, this.text, styles, node);\n        }\n        return TextContainer;\n    }());\n    var transform = function (text, transform) {\n        switch (transform) {\n            case 1 /* LOWERCASE */:\n                return text.toLowerCase();\n            case 3 /* CAPITALIZE */:\n                return text.replace(CAPITALIZE, capitalize);\n            case 2 /* UPPERCASE */:\n                return text.toUpperCase();\n            default:\n                return text;\n        }\n    };\n    var CAPITALIZE = /(^|\\s|:|-|\\(|\\))([a-z])/g;\n    var capitalize = function (m, p1, p2) {\n        if (m.length > 0) {\n            return p1 + p2.toUpperCase();\n        }\n        return m;\n    };\n\n    var ImageElementContainer = /** @class */ (function (_super) {\n        __extends(ImageElementContainer, _super);\n        function ImageElementContainer(context, img) {\n            var _this = _super.call(this, context, img) || this;\n            _this.src = img.currentSrc || img.src;\n            _this.intrinsicWidth = img.naturalWidth;\n            _this.intrinsicHeight = img.naturalHeight;\n            _this.context.cache.addImage(_this.src);\n            return _this;\n        }\n        return ImageElementContainer;\n    }(ElementContainer));\n\n    var CanvasElementContainer = /** @class */ (function (_super) {\n        __extends(CanvasElementContainer, _super);\n        function CanvasElementContainer(context, canvas) {\n            var _this = _super.call(this, context, canvas) || this;\n            _this.canvas = canvas;\n            _this.intrinsicWidth = canvas.width;\n            _this.intrinsicHeight = canvas.height;\n            return _this;\n        }\n        return CanvasElementContainer;\n    }(ElementContainer));\n\n    var SVGElementContainer = /** @class */ (function (_super) {\n        __extends(SVGElementContainer, _super);\n        function SVGElementContainer(context, img) {\n            var _this = _super.call(this, context, img) || this;\n            var s = new XMLSerializer();\n            var bounds = parseBounds(context, img);\n            img.setAttribute('width', bounds.width + \"px\");\n            img.setAttribute('height', bounds.height + \"px\");\n            _this.svg = \"data:image/svg+xml,\" + encodeURIComponent(s.serializeToString(img));\n            _this.intrinsicWidth = img.width.baseVal.value;\n            _this.intrinsicHeight = img.height.baseVal.value;\n            _this.context.cache.addImage(_this.svg);\n            return _this;\n        }\n        return SVGElementContainer;\n    }(ElementContainer));\n\n    var LIElementContainer = /** @class */ (function (_super) {\n        __extends(LIElementContainer, _super);\n        function LIElementContainer(context, element) {\n            var _this = _super.call(this, context, element) || this;\n            _this.value = element.value;\n            return _this;\n        }\n        return LIElementContainer;\n    }(ElementContainer));\n\n    var OLElementContainer = /** @class */ (function (_super) {\n        __extends(OLElementContainer, _super);\n        function OLElementContainer(context, element) {\n            var _this = _super.call(this, context, element) || this;\n            _this.start = element.start;\n            _this.reversed = typeof element.reversed === 'boolean' && element.reversed === true;\n            return _this;\n        }\n        return OLElementContainer;\n    }(ElementContainer));\n\n    var CHECKBOX_BORDER_RADIUS = [\n        {\n            type: 15 /* DIMENSION_TOKEN */,\n            flags: 0,\n            unit: 'px',\n            number: 3\n        }\n    ];\n    var RADIO_BORDER_RADIUS = [\n        {\n            type: 16 /* PERCENTAGE_TOKEN */,\n            flags: 0,\n            number: 50\n        }\n    ];\n    var reformatInputBounds = function (bounds) {\n        if (bounds.width > bounds.height) {\n            return new Bounds(bounds.left + (bounds.width - bounds.height) / 2, bounds.top, bounds.height, bounds.height);\n        }\n        else if (bounds.width < bounds.height) {\n            return new Bounds(bounds.left, bounds.top + (bounds.height - bounds.width) / 2, bounds.width, bounds.width);\n        }\n        return bounds;\n    };\n    var getInputValue = function (node) {\n        var value = node.type === PASSWORD ? new Array(node.value.length + 1).join('\\u2022') : node.value;\n        return value.length === 0 ? node.placeholder || '' : value;\n    };\n    var CHECKBOX = 'checkbox';\n    var RADIO = 'radio';\n    var PASSWORD = 'password';\n    var INPUT_COLOR = 0x2a2a2aff;\n    var InputElementContainer = /** @class */ (function (_super) {\n        __extends(InputElementContainer, _super);\n        function InputElementContainer(context, input) {\n            var _this = _super.call(this, context, input) || this;\n            _this.type = input.type.toLowerCase();\n            _this.checked = input.checked;\n            _this.value = getInputValue(input);\n            if (_this.type === CHECKBOX || _this.type === RADIO) {\n                _this.styles.backgroundColor = 0xdededeff;\n                _this.styles.borderTopColor =\n                    _this.styles.borderRightColor =\n                        _this.styles.borderBottomColor =\n                            _this.styles.borderLeftColor =\n                                0xa5a5a5ff;\n                _this.styles.borderTopWidth =\n                    _this.styles.borderRightWidth =\n                        _this.styles.borderBottomWidth =\n                            _this.styles.borderLeftWidth =\n                                1;\n                _this.styles.borderTopStyle =\n                    _this.styles.borderRightStyle =\n                        _this.styles.borderBottomStyle =\n                            _this.styles.borderLeftStyle =\n                                1 /* SOLID */;\n                _this.styles.backgroundClip = [0 /* BORDER_BOX */];\n                _this.styles.backgroundOrigin = [0 /* BORDER_BOX */];\n                _this.bounds = reformatInputBounds(_this.bounds);\n            }\n            switch (_this.type) {\n                case CHECKBOX:\n                    _this.styles.borderTopRightRadius =\n                        _this.styles.borderTopLeftRadius =\n                            _this.styles.borderBottomRightRadius =\n                                _this.styles.borderBottomLeftRadius =\n                                    CHECKBOX_BORDER_RADIUS;\n                    break;\n                case RADIO:\n                    _this.styles.borderTopRightRadius =\n                        _this.styles.borderTopLeftRadius =\n                            _this.styles.borderBottomRightRadius =\n                                _this.styles.borderBottomLeftRadius =\n                                    RADIO_BORDER_RADIUS;\n                    break;\n            }\n            return _this;\n        }\n        return InputElementContainer;\n    }(ElementContainer));\n\n    var SelectElementContainer = /** @class */ (function (_super) {\n        __extends(SelectElementContainer, _super);\n        function SelectElementContainer(context, element) {\n            var _this = _super.call(this, context, element) || this;\n            var option = element.options[element.selectedIndex || 0];\n            _this.value = option ? option.text || '' : '';\n            return _this;\n        }\n        return SelectElementContainer;\n    }(ElementContainer));\n\n    var TextareaElementContainer = /** @class */ (function (_super) {\n        __extends(TextareaElementContainer, _super);\n        function TextareaElementContainer(context, element) {\n            var _this = _super.call(this, context, element) || this;\n            _this.value = element.value;\n            return _this;\n        }\n        return TextareaElementContainer;\n    }(ElementContainer));\n\n    var IFrameElementContainer = /** @class */ (function (_super) {\n        __extends(IFrameElementContainer, _super);\n        function IFrameElementContainer(context, iframe) {\n            var _this = _super.call(this, context, iframe) || this;\n            _this.src = iframe.src;\n            _this.width = parseInt(iframe.width, 10) || 0;\n            _this.height = parseInt(iframe.height, 10) || 0;\n            _this.backgroundColor = _this.styles.backgroundColor;\n            try {\n                if (iframe.contentWindow &&\n                    iframe.contentWindow.document &&\n                    iframe.contentWindow.document.documentElement) {\n                    _this.tree = parseTree(context, iframe.contentWindow.document.documentElement);\n                    // http://www.w3.org/TR/css3-background/#special-backgrounds\n                    var documentBackgroundColor = iframe.contentWindow.document.documentElement\n                        ? parseColor(context, getComputedStyle(iframe.contentWindow.document.documentElement).backgroundColor)\n                        : COLORS.TRANSPARENT;\n                    var bodyBackgroundColor = iframe.contentWindow.document.body\n                        ? parseColor(context, getComputedStyle(iframe.contentWindow.document.body).backgroundColor)\n                        : COLORS.TRANSPARENT;\n                    _this.backgroundColor = isTransparent(documentBackgroundColor)\n                        ? isTransparent(bodyBackgroundColor)\n                            ? _this.styles.backgroundColor\n                            : bodyBackgroundColor\n                        : documentBackgroundColor;\n                }\n            }\n            catch (e) { }\n            return _this;\n        }\n        return IFrameElementContainer;\n    }(ElementContainer));\n\n    var LIST_OWNERS = ['OL', 'UL', 'MENU'];\n    var parseNodeTree = function (context, node, parent, root) {\n        for (var childNode = node.firstChild, nextNode = void 0; childNode; childNode = nextNode) {\n            nextNode = childNode.nextSibling;\n            if (isTextNode(childNode) && childNode.data.trim().length > 0) {\n                parent.textNodes.push(new TextContainer(context, childNode, parent.styles));\n            }\n            else if (isElementNode(childNode)) {\n                if (isSlotElement(childNode) && childNode.assignedNodes) {\n                    childNode.assignedNodes().forEach(function (childNode) { return parseNodeTree(context, childNode, parent, root); });\n                }\n                else {\n                    var container = createContainer(context, childNode);\n                    if (container.styles.isVisible()) {\n                        if (createsRealStackingContext(childNode, container, root)) {\n                            container.flags |= 4 /* CREATES_REAL_STACKING_CONTEXT */;\n                        }\n                        else if (createsStackingContext(container.styles)) {\n                            container.flags |= 2 /* CREATES_STACKING_CONTEXT */;\n                        }\n                        if (LIST_OWNERS.indexOf(childNode.tagName) !== -1) {\n                            container.flags |= 8 /* IS_LIST_OWNER */;\n                        }\n                        parent.elements.push(container);\n                        childNode.slot;\n                        if (childNode.shadowRoot) {\n                            parseNodeTree(context, childNode.shadowRoot, container, root);\n                        }\n                        else if (!isTextareaElement(childNode) &&\n                            !isSVGElement(childNode) &&\n                            !isSelectElement(childNode)) {\n                            parseNodeTree(context, childNode, container, root);\n                        }\n                    }\n                }\n            }\n        }\n    };\n    var createContainer = function (context, element) {\n        if (isImageElement(element)) {\n            return new ImageElementContainer(context, element);\n        }\n        if (isCanvasElement(element)) {\n            return new CanvasElementContainer(context, element);\n        }\n        if (isSVGElement(element)) {\n            return new SVGElementContainer(context, element);\n        }\n        if (isLIElement(element)) {\n            return new LIElementContainer(context, element);\n        }\n        if (isOLElement(element)) {\n            return new OLElementContainer(context, element);\n        }\n        if (isInputElement(element)) {\n            return new InputElementContainer(context, element);\n        }\n        if (isSelectElement(element)) {\n            return new SelectElementContainer(context, element);\n        }\n        if (isTextareaElement(element)) {\n            return new TextareaElementContainer(context, element);\n        }\n        if (isIFrameElement(element)) {\n            return new IFrameElementContainer(context, element);\n        }\n        return new ElementContainer(context, element);\n    };\n    var parseTree = function (context, element) {\n        var container = createContainer(context, element);\n        container.flags |= 4 /* CREATES_REAL_STACKING_CONTEXT */;\n        parseNodeTree(context, element, container, container);\n        return container;\n    };\n    var createsRealStackingContext = function (node, container, root) {\n        return (container.styles.isPositionedWithZIndex() ||\n            container.styles.opacity < 1 ||\n            container.styles.isTransformed() ||\n            (isBodyElement(node) && root.styles.isTransparent()));\n    };\n    var createsStackingContext = function (styles) { return styles.isPositioned() || styles.isFloating(); };\n    var isTextNode = function (node) { return node.nodeType === Node.TEXT_NODE; };\n    var isElementNode = function (node) { return node.nodeType === Node.ELEMENT_NODE; };\n    var isHTMLElementNode = function (node) {\n        return isElementNode(node) && typeof node.style !== 'undefined' && !isSVGElementNode(node);\n    };\n    var isSVGElementNode = function (element) {\n        return typeof element.className === 'object';\n    };\n    var isLIElement = function (node) { return node.tagName === 'LI'; };\n    var isOLElement = function (node) { return node.tagName === 'OL'; };\n    var isInputElement = function (node) { return node.tagName === 'INPUT'; };\n    var isHTMLElement = function (node) { return node.tagName === 'HTML'; };\n    var isSVGElement = function (node) { return node.tagName === 'svg'; };\n    var isBodyElement = function (node) { return node.tagName === 'BODY'; };\n    var isCanvasElement = function (node) { return node.tagName === 'CANVAS'; };\n    var isVideoElement = function (node) { return node.tagName === 'VIDEO'; };\n    var isImageElement = function (node) { return node.tagName === 'IMG'; };\n    var isIFrameElement = function (node) { return node.tagName === 'IFRAME'; };\n    var isStyleElement = function (node) { return node.tagName === 'STYLE'; };\n    var isScriptElement = function (node) { return node.tagName === 'SCRIPT'; };\n    var isTextareaElement = function (node) { return node.tagName === 'TEXTAREA'; };\n    var isSelectElement = function (node) { return node.tagName === 'SELECT'; };\n    var isSlotElement = function (node) { return node.tagName === 'SLOT'; };\n    // https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name\n    var isCustomElement = function (node) { return node.tagName.indexOf('-') > 0; };\n\n    var CounterState = /** @class */ (function () {\n        function CounterState() {\n            this.counters = {};\n        }\n        CounterState.prototype.getCounterValue = function (name) {\n            var counter = this.counters[name];\n            if (counter && counter.length) {\n                return counter[counter.length - 1];\n            }\n            return 1;\n        };\n        CounterState.prototype.getCounterValues = function (name) {\n            var counter = this.counters[name];\n            return counter ? counter : [];\n        };\n        CounterState.prototype.pop = function (counters) {\n            var _this = this;\n            counters.forEach(function (counter) { return _this.counters[counter].pop(); });\n        };\n        CounterState.prototype.parse = function (style) {\n            var _this = this;\n            var counterIncrement = style.counterIncrement;\n            var counterReset = style.counterReset;\n            var canReset = true;\n            if (counterIncrement !== null) {\n                counterIncrement.forEach(function (entry) {\n                    var counter = _this.counters[entry.counter];\n                    if (counter && entry.increment !== 0) {\n                        canReset = false;\n                        if (!counter.length) {\n                            counter.push(1);\n                        }\n                        counter[Math.max(0, counter.length - 1)] += entry.increment;\n                    }\n                });\n            }\n            var counterNames = [];\n            if (canReset) {\n                counterReset.forEach(function (entry) {\n                    var counter = _this.counters[entry.counter];\n                    counterNames.push(entry.counter);\n                    if (!counter) {\n                        counter = _this.counters[entry.counter] = [];\n                    }\n                    counter.push(entry.reset);\n                });\n            }\n            return counterNames;\n        };\n        return CounterState;\n    }());\n    var ROMAN_UPPER = {\n        integers: [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1],\n        values: ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I']\n    };\n    var ARMENIAN = {\n        integers: [\n            9000, 8000, 7000, 6000, 5000, 4000, 3000, 2000, 1000, 900, 800, 700, 600, 500, 400, 300, 200, 100, 90, 80, 70,\n            60, 50, 40, 30, 20, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1\n        ],\n        values: [\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            ''\n        ]\n    };\n    var HEBREW = {\n        integers: [\n            10000, 9000, 8000, 7000, 6000, 5000, 4000, 3000, 2000, 1000, 400, 300, 200, 100, 90, 80, 70, 60, 50, 40, 30, 20,\n            19, 18, 17, 16, 15, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1\n        ],\n        values: [\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            ''\n        ]\n    };\n    var GEORGIAN = {\n        integers: [\n            10000, 9000, 8000, 7000, 6000, 5000, 4000, 3000, 2000, 1000, 900, 800, 700, 600, 500, 400, 300, 200, 100, 90,\n            80, 70, 60, 50, 40, 30, 20, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1\n        ],\n        values: [\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            ''\n        ]\n    };\n    var createAdditiveCounter = function (value, min, max, symbols, fallback, suffix) {\n        if (value < min || value > max) {\n            return createCounterText(value, fallback, suffix.length > 0);\n        }\n        return (symbols.integers.reduce(function (string, integer, index) {\n            while (value >= integer) {\n                value -= integer;\n                string += symbols.values[index];\n            }\n            return string;\n        }, '') + suffix);\n    };\n    var createCounterStyleWithSymbolResolver = function (value, codePointRangeLength, isNumeric, resolver) {\n        var string = '';\n        do {\n            if (!isNumeric) {\n                value--;\n            }\n            string = resolver(value) + string;\n            value /= codePointRangeLength;\n        } while (value * codePointRangeLength >= codePointRangeLength);\n        return string;\n    };\n    var createCounterStyleFromRange = function (value, codePointRangeStart, codePointRangeEnd, isNumeric, suffix) {\n        var codePointRangeLength = codePointRangeEnd - codePointRangeStart + 1;\n        return ((value < 0 ? '-' : '') +\n            (createCounterStyleWithSymbolResolver(Math.abs(value), codePointRangeLength, isNumeric, function (codePoint) {\n                return fromCodePoint$1(Math.floor(codePoint % codePointRangeLength) + codePointRangeStart);\n            }) +\n                suffix));\n    };\n    var createCounterStyleFromSymbols = function (value, symbols, suffix) {\n        if (suffix === void 0) { suffix = '. '; }\n        var codePointRangeLength = symbols.length;\n        return (createCounterStyleWithSymbolResolver(Math.abs(value), codePointRangeLength, false, function (codePoint) { return symbols[Math.floor(codePoint % codePointRangeLength)]; }) + suffix);\n    };\n    var CJK_ZEROS = 1 << 0;\n    var CJK_TEN_COEFFICIENTS = 1 << 1;\n    var CJK_TEN_HIGH_COEFFICIENTS = 1 << 2;\n    var CJK_HUNDRED_COEFFICIENTS = 1 << 3;\n    var createCJKCounter = function (value, numbers, multipliers, negativeSign, suffix, flags) {\n        if (value < -9999 || value > 9999) {\n            return createCounterText(value, 4 /* CJK_DECIMAL */, suffix.length > 0);\n        }\n        var tmp = Math.abs(value);\n        var string = suffix;\n        if (tmp === 0) {\n            return numbers[0] + string;\n        }\n        for (var digit = 0; tmp > 0 && digit <= 4; digit++) {\n            var coefficient = tmp % 10;\n            if (coefficient === 0 && contains(flags, CJK_ZEROS) && string !== '') {\n                string = numbers[coefficient] + string;\n            }\n            else if (coefficient > 1 ||\n                (coefficient === 1 && digit === 0) ||\n                (coefficient === 1 && digit === 1 && contains(flags, CJK_TEN_COEFFICIENTS)) ||\n                (coefficient === 1 && digit === 1 && contains(flags, CJK_TEN_HIGH_COEFFICIENTS) && value > 100) ||\n                (coefficient === 1 && digit > 1 && contains(flags, CJK_HUNDRED_COEFFICIENTS))) {\n                string = numbers[coefficient] + (digit > 0 ? multipliers[digit - 1] : '') + string;\n            }\n            else if (coefficient === 1 && digit > 0) {\n                string = multipliers[digit - 1] + string;\n            }\n            tmp = Math.floor(tmp / 10);\n        }\n        return (value < 0 ? negativeSign : '') + string;\n    };\n    var CHINESE_INFORMAL_MULTIPLIERS = '';\n    var CHINESE_FORMAL_MULTIPLIERS = '';\n    var JAPANESE_NEGATIVE = '';\n    var KOREAN_NEGATIVE = '';\n    var createCounterText = function (value, type, appendSuffix) {\n        var defaultSuffix = appendSuffix ? '. ' : '';\n        var cjkSuffix = appendSuffix ? '' : '';\n        var koreanSuffix = appendSuffix ? ', ' : '';\n        var spaceSuffix = appendSuffix ? ' ' : '';\n        switch (type) {\n            case 0 /* DISC */:\n                return '' + spaceSuffix;\n            case 1 /* CIRCLE */:\n                return '' + spaceSuffix;\n            case 2 /* SQUARE */:\n                return '' + spaceSuffix;\n            case 5 /* DECIMAL_LEADING_ZERO */:\n                var string = createCounterStyleFromRange(value, 48, 57, true, defaultSuffix);\n                return string.length < 4 ? \"0\" + string : string;\n            case 4 /* CJK_DECIMAL */:\n                return createCounterStyleFromSymbols(value, '', cjkSuffix);\n            case 6 /* LOWER_ROMAN */:\n                return createAdditiveCounter(value, 1, 3999, ROMAN_UPPER, 3 /* DECIMAL */, defaultSuffix).toLowerCase();\n            case 7 /* UPPER_ROMAN */:\n                return createAdditiveCounter(value, 1, 3999, ROMAN_UPPER, 3 /* DECIMAL */, defaultSuffix);\n            case 8 /* LOWER_GREEK */:\n                return createCounterStyleFromRange(value, 945, 969, false, defaultSuffix);\n            case 9 /* LOWER_ALPHA */:\n                return createCounterStyleFromRange(value, 97, 122, false, defaultSuffix);\n            case 10 /* UPPER_ALPHA */:\n                return createCounterStyleFromRange(value, 65, 90, false, defaultSuffix);\n            case 11 /* ARABIC_INDIC */:\n                return createCounterStyleFromRange(value, 1632, 1641, true, defaultSuffix);\n            case 12 /* ARMENIAN */:\n            case 49 /* UPPER_ARMENIAN */:\n                return createAdditiveCounter(value, 1, 9999, ARMENIAN, 3 /* DECIMAL */, defaultSuffix);\n            case 35 /* LOWER_ARMENIAN */:\n                return createAdditiveCounter(value, 1, 9999, ARMENIAN, 3 /* DECIMAL */, defaultSuffix).toLowerCase();\n            case 13 /* BENGALI */:\n                return createCounterStyleFromRange(value, 2534, 2543, true, defaultSuffix);\n            case 14 /* CAMBODIAN */:\n            case 30 /* KHMER */:\n                return createCounterStyleFromRange(value, 6112, 6121, true, defaultSuffix);\n            case 15 /* CJK_EARTHLY_BRANCH */:\n                return createCounterStyleFromSymbols(value, '', cjkSuffix);\n            case 16 /* CJK_HEAVENLY_STEM */:\n                return createCounterStyleFromSymbols(value, '', cjkSuffix);\n            case 17 /* CJK_IDEOGRAPHIC */:\n            case 48 /* TRAD_CHINESE_INFORMAL */:\n                return createCJKCounter(value, '', CHINESE_INFORMAL_MULTIPLIERS, '', cjkSuffix, CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);\n            case 47 /* TRAD_CHINESE_FORMAL */:\n                return createCJKCounter(value, '', CHINESE_FORMAL_MULTIPLIERS, '', cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);\n            case 42 /* SIMP_CHINESE_INFORMAL */:\n                return createCJKCounter(value, '', CHINESE_INFORMAL_MULTIPLIERS, '', cjkSuffix, CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);\n            case 41 /* SIMP_CHINESE_FORMAL */:\n                return createCJKCounter(value, '', CHINESE_FORMAL_MULTIPLIERS, '', cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);\n            case 26 /* JAPANESE_INFORMAL */:\n                return createCJKCounter(value, '', '', JAPANESE_NEGATIVE, cjkSuffix, 0);\n            case 25 /* JAPANESE_FORMAL */:\n                return createCJKCounter(value, '', '', JAPANESE_NEGATIVE, cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);\n            case 31 /* KOREAN_HANGUL_FORMAL */:\n                return createCJKCounter(value, '', '', KOREAN_NEGATIVE, koreanSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);\n            case 33 /* KOREAN_HANJA_INFORMAL */:\n                return createCJKCounter(value, '', '', KOREAN_NEGATIVE, koreanSuffix, 0);\n            case 32 /* KOREAN_HANJA_FORMAL */:\n                return createCJKCounter(value, '', '', KOREAN_NEGATIVE, koreanSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);\n            case 18 /* DEVANAGARI */:\n                return createCounterStyleFromRange(value, 0x966, 0x96f, true, defaultSuffix);\n            case 20 /* GEORGIAN */:\n                return createAdditiveCounter(value, 1, 19999, GEORGIAN, 3 /* DECIMAL */, defaultSuffix);\n            case 21 /* GUJARATI */:\n                return createCounterStyleFromRange(value, 0xae6, 0xaef, true, defaultSuffix);\n            case 22 /* GURMUKHI */:\n                return createCounterStyleFromRange(value, 0xa66, 0xa6f, true, defaultSuffix);\n            case 22 /* HEBREW */:\n                return createAdditiveCounter(value, 1, 10999, HEBREW, 3 /* DECIMAL */, defaultSuffix);\n            case 23 /* HIRAGANA */:\n                return createCounterStyleFromSymbols(value, '');\n            case 24 /* HIRAGANA_IROHA */:\n                return createCounterStyleFromSymbols(value, '');\n            case 27 /* KANNADA */:\n                return createCounterStyleFromRange(value, 0xce6, 0xcef, true, defaultSuffix);\n            case 28 /* KATAKANA */:\n                return createCounterStyleFromSymbols(value, '', cjkSuffix);\n            case 29 /* KATAKANA_IROHA */:\n                return createCounterStyleFromSymbols(value, '', cjkSuffix);\n            case 34 /* LAO */:\n                return createCounterStyleFromRange(value, 0xed0, 0xed9, true, defaultSuffix);\n            case 37 /* MONGOLIAN */:\n                return createCounterStyleFromRange(value, 0x1810, 0x1819, true, defaultSuffix);\n            case 38 /* MYANMAR */:\n                return createCounterStyleFromRange(value, 0x1040, 0x1049, true, defaultSuffix);\n            case 39 /* ORIYA */:\n                return createCounterStyleFromRange(value, 0xb66, 0xb6f, true, defaultSuffix);\n            case 40 /* PERSIAN */:\n                return createCounterStyleFromRange(value, 0x6f0, 0x6f9, true, defaultSuffix);\n            case 43 /* TAMIL */:\n                return createCounterStyleFromRange(value, 0xbe6, 0xbef, true, defaultSuffix);\n            case 44 /* TELUGU */:\n                return createCounterStyleFromRange(value, 0xc66, 0xc6f, true, defaultSuffix);\n            case 45 /* THAI */:\n                return createCounterStyleFromRange(value, 0xe50, 0xe59, true, defaultSuffix);\n            case 46 /* TIBETAN */:\n                return createCounterStyleFromRange(value, 0xf20, 0xf29, true, defaultSuffix);\n            case 3 /* DECIMAL */:\n            default:\n                return createCounterStyleFromRange(value, 48, 57, true, defaultSuffix);\n        }\n    };\n\n    var IGNORE_ATTRIBUTE = 'data-html2canvas-ignore';\n    var DocumentCloner = /** @class */ (function () {\n        function DocumentCloner(context, element, options) {\n            this.context = context;\n            this.options = options;\n            this.scrolledElements = [];\n            this.referenceElement = element;\n            this.counters = new CounterState();\n            this.quoteDepth = 0;\n            if (!element.ownerDocument) {\n                throw new Error('Cloned element does not have an owner document');\n            }\n            this.documentElement = this.cloneNode(element.ownerDocument.documentElement, false);\n        }\n        DocumentCloner.prototype.toIFrame = function (ownerDocument, windowSize) {\n            var _this = this;\n            var iframe = createIFrameContainer(ownerDocument, windowSize);\n            if (!iframe.contentWindow) {\n                return Promise.reject(\"Unable to find iframe window\");\n            }\n            var scrollX = ownerDocument.defaultView.pageXOffset;\n            var scrollY = ownerDocument.defaultView.pageYOffset;\n            var cloneWindow = iframe.contentWindow;\n            var documentClone = cloneWindow.document;\n            /* Chrome doesn't detect relative background-images assigned in inline <style> sheets when fetched through getComputedStyle\n             if window url is about:blank, we can assign the url to current by writing onto the document\n             */\n            var iframeLoad = iframeLoader(iframe).then(function () { return __awaiter(_this, void 0, void 0, function () {\n                var onclone, referenceElement;\n                return __generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0:\n                            this.scrolledElements.forEach(restoreNodeScroll);\n                            if (cloneWindow) {\n                                cloneWindow.scrollTo(windowSize.left, windowSize.top);\n                                if (/(iPad|iPhone|iPod)/g.test(navigator.userAgent) &&\n                                    (cloneWindow.scrollY !== windowSize.top || cloneWindow.scrollX !== windowSize.left)) {\n                                    this.context.logger.warn('Unable to restore scroll position for cloned document');\n                                    this.context.windowBounds = this.context.windowBounds.add(cloneWindow.scrollX - windowSize.left, cloneWindow.scrollY - windowSize.top, 0, 0);\n                                }\n                            }\n                            onclone = this.options.onclone;\n                            referenceElement = this.clonedReferenceElement;\n                            if (typeof referenceElement === 'undefined') {\n                                return [2 /*return*/, Promise.reject(\"Error finding the \" + this.referenceElement.nodeName + \" in the cloned document\")];\n                            }\n                            if (!(documentClone.fonts && documentClone.fonts.ready)) return [3 /*break*/, 2];\n                            return [4 /*yield*/, documentClone.fonts.ready];\n                        case 1:\n                            _a.sent();\n                            _a.label = 2;\n                        case 2:\n                            if (!/(AppleWebKit)/g.test(navigator.userAgent)) return [3 /*break*/, 4];\n                            return [4 /*yield*/, imagesReady(documentClone)];\n                        case 3:\n                            _a.sent();\n                            _a.label = 4;\n                        case 4:\n                            if (typeof onclone === 'function') {\n                                return [2 /*return*/, Promise.resolve()\n                                        .then(function () { return onclone(documentClone, referenceElement); })\n                                        .then(function () { return iframe; })];\n                            }\n                            return [2 /*return*/, iframe];\n                    }\n                });\n            }); });\n            documentClone.open();\n            documentClone.write(serializeDoctype(document.doctype) + \"<html></html>\");\n            // Chrome scrolls the parent document for some reason after the write to the cloned window???\n            restoreOwnerScroll(this.referenceElement.ownerDocument, scrollX, scrollY);\n            documentClone.replaceChild(documentClone.adoptNode(this.documentElement), documentClone.documentElement);\n            documentClone.close();\n            return iframeLoad;\n        };\n        DocumentCloner.prototype.createElementClone = function (node) {\n            if (isDebugging(node, 2 /* CLONE */)) {\n                debugger;\n            }\n            if (isCanvasElement(node)) {\n                return this.createCanvasClone(node);\n            }\n            if (isVideoElement(node)) {\n                return this.createVideoClone(node);\n            }\n            if (isStyleElement(node)) {\n                return this.createStyleClone(node);\n            }\n            var clone = node.cloneNode(false);\n            if (isImageElement(clone)) {\n                if (isImageElement(node) && node.currentSrc && node.currentSrc !== node.src) {\n                    clone.src = node.currentSrc;\n                    clone.srcset = '';\n                }\n                if (clone.loading === 'lazy') {\n                    clone.loading = 'eager';\n                }\n            }\n            if (isCustomElement(clone)) {\n                return this.createCustomElementClone(clone);\n            }\n            return clone;\n        };\n        DocumentCloner.prototype.createCustomElementClone = function (node) {\n            var clone = document.createElement('html2canvascustomelement');\n            copyCSSStyles(node.style, clone);\n            return clone;\n        };\n        DocumentCloner.prototype.createStyleClone = function (node) {\n            try {\n                var sheet = node.sheet;\n                if (sheet && sheet.cssRules) {\n                    var css = [].slice.call(sheet.cssRules, 0).reduce(function (css, rule) {\n                        if (rule && typeof rule.cssText === 'string') {\n                            return css + rule.cssText;\n                        }\n                        return css;\n                    }, '');\n                    var style = node.cloneNode(false);\n                    style.textContent = css;\n                    return style;\n                }\n            }\n            catch (e) {\n                // accessing node.sheet.cssRules throws a DOMException\n                this.context.logger.error('Unable to access cssRules property', e);\n                if (e.name !== 'SecurityError') {\n                    throw e;\n                }\n            }\n            return node.cloneNode(false);\n        };\n        DocumentCloner.prototype.createCanvasClone = function (canvas) {\n            var _a;\n            if (this.options.inlineImages && canvas.ownerDocument) {\n                var img = canvas.ownerDocument.createElement('img');\n                try {\n                    img.src = canvas.toDataURL();\n                    return img;\n                }\n                catch (e) {\n                    this.context.logger.info(\"Unable to inline canvas contents, canvas is tainted\", canvas);\n                }\n            }\n            var clonedCanvas = canvas.cloneNode(false);\n            try {\n                clonedCanvas.width = canvas.width;\n                clonedCanvas.height = canvas.height;\n                var ctx = canvas.getContext('2d');\n                var clonedCtx = clonedCanvas.getContext('2d');\n                if (clonedCtx) {\n                    if (!this.options.allowTaint && ctx) {\n                        clonedCtx.putImageData(ctx.getImageData(0, 0, canvas.width, canvas.height), 0, 0);\n                    }\n                    else {\n                        var gl = (_a = canvas.getContext('webgl2')) !== null && _a !== void 0 ? _a : canvas.getContext('webgl');\n                        if (gl) {\n                            var attribs = gl.getContextAttributes();\n                            if ((attribs === null || attribs === void 0 ? void 0 : attribs.preserveDrawingBuffer) === false) {\n                                this.context.logger.warn('Unable to clone WebGL context as it has preserveDrawingBuffer=false', canvas);\n                            }\n                        }\n                        clonedCtx.drawImage(canvas, 0, 0);\n                    }\n                }\n                return clonedCanvas;\n            }\n            catch (e) {\n                this.context.logger.info(\"Unable to clone canvas as it is tainted\", canvas);\n            }\n            return clonedCanvas;\n        };\n        DocumentCloner.prototype.createVideoClone = function (video) {\n            var canvas = video.ownerDocument.createElement('canvas');\n            canvas.width = video.offsetWidth;\n            canvas.height = video.offsetHeight;\n            var ctx = canvas.getContext('2d');\n            try {\n                if (ctx) {\n                    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);\n                    if (!this.options.allowTaint) {\n                        ctx.getImageData(0, 0, canvas.width, canvas.height);\n                    }\n                }\n                return canvas;\n            }\n            catch (e) {\n                this.context.logger.info(\"Unable to clone video as it is tainted\", video);\n            }\n            var blankCanvas = video.ownerDocument.createElement('canvas');\n            blankCanvas.width = video.offsetWidth;\n            blankCanvas.height = video.offsetHeight;\n            return blankCanvas;\n        };\n        DocumentCloner.prototype.appendChildNode = function (clone, child, copyStyles) {\n            if (!isElementNode(child) ||\n                (!isScriptElement(child) &&\n                    !child.hasAttribute(IGNORE_ATTRIBUTE) &&\n                    (typeof this.options.ignoreElements !== 'function' || !this.options.ignoreElements(child)))) {\n                if (!this.options.copyStyles || !isElementNode(child) || !isStyleElement(child)) {\n                    clone.appendChild(this.cloneNode(child, copyStyles));\n                }\n            }\n        };\n        DocumentCloner.prototype.cloneChildNodes = function (node, clone, copyStyles) {\n            var _this = this;\n            for (var child = node.shadowRoot ? node.shadowRoot.firstChild : node.firstChild; child; child = child.nextSibling) {\n                if (isElementNode(child) && isSlotElement(child) && typeof child.assignedNodes === 'function') {\n                    var assignedNodes = child.assignedNodes();\n                    if (assignedNodes.length) {\n                        assignedNodes.forEach(function (assignedNode) { return _this.appendChildNode(clone, assignedNode, copyStyles); });\n                    }\n                }\n                else {\n                    this.appendChildNode(clone, child, copyStyles);\n                }\n            }\n        };\n        DocumentCloner.prototype.cloneNode = function (node, copyStyles) {\n            if (isTextNode(node)) {\n                return document.createTextNode(node.data);\n            }\n            if (!node.ownerDocument) {\n                return node.cloneNode(false);\n            }\n            var window = node.ownerDocument.defaultView;\n            if (window && isElementNode(node) && (isHTMLElementNode(node) || isSVGElementNode(node))) {\n                var clone = this.createElementClone(node);\n                clone.style.transitionProperty = 'none';\n                var style = window.getComputedStyle(node);\n                var styleBefore = window.getComputedStyle(node, ':before');\n                var styleAfter = window.getComputedStyle(node, ':after');\n                if (this.referenceElement === node && isHTMLElementNode(clone)) {\n                    this.clonedReferenceElement = clone;\n                }\n                if (isBodyElement(clone)) {\n                    createPseudoHideStyles(clone);\n                }\n                var counters = this.counters.parse(new CSSParsedCounterDeclaration(this.context, style));\n                var before = this.resolvePseudoContent(node, clone, styleBefore, PseudoElementType.BEFORE);\n                if (isCustomElement(node)) {\n                    copyStyles = true;\n                }\n                if (!isVideoElement(node)) {\n                    this.cloneChildNodes(node, clone, copyStyles);\n                }\n                if (before) {\n                    clone.insertBefore(before, clone.firstChild);\n                }\n                var after = this.resolvePseudoContent(node, clone, styleAfter, PseudoElementType.AFTER);\n                if (after) {\n                    clone.appendChild(after);\n                }\n                this.counters.pop(counters);\n                if ((style && (this.options.copyStyles || isSVGElementNode(node)) && !isIFrameElement(node)) ||\n                    copyStyles) {\n                    copyCSSStyles(style, clone);\n                }\n                if (node.scrollTop !== 0 || node.scrollLeft !== 0) {\n                    this.scrolledElements.push([clone, node.scrollLeft, node.scrollTop]);\n                }\n                if ((isTextareaElement(node) || isSelectElement(node)) &&\n                    (isTextareaElement(clone) || isSelectElement(clone))) {\n                    clone.value = node.value;\n                }\n                return clone;\n            }\n            return node.cloneNode(false);\n        };\n        DocumentCloner.prototype.resolvePseudoContent = function (node, clone, style, pseudoElt) {\n            var _this = this;\n            if (!style) {\n                return;\n            }\n            var value = style.content;\n            var document = clone.ownerDocument;\n            if (!document || !value || value === 'none' || value === '-moz-alt-content' || style.display === 'none') {\n                return;\n            }\n            this.counters.parse(new CSSParsedCounterDeclaration(this.context, style));\n            var declaration = new CSSParsedPseudoDeclaration(this.context, style);\n            var anonymousReplacedElement = document.createElement('html2canvaspseudoelement');\n            copyCSSStyles(style, anonymousReplacedElement);\n            declaration.content.forEach(function (token) {\n                if (token.type === 0 /* STRING_TOKEN */) {\n                    anonymousReplacedElement.appendChild(document.createTextNode(token.value));\n                }\n                else if (token.type === 22 /* URL_TOKEN */) {\n                    var img = document.createElement('img');\n                    img.src = token.value;\n                    img.style.opacity = '1';\n                    anonymousReplacedElement.appendChild(img);\n                }\n                else if (token.type === 18 /* FUNCTION */) {\n                    if (token.name === 'attr') {\n                        var attr = token.values.filter(isIdentToken);\n                        if (attr.length) {\n                            anonymousReplacedElement.appendChild(document.createTextNode(node.getAttribute(attr[0].value) || ''));\n                        }\n                    }\n                    else if (token.name === 'counter') {\n                        var _a = token.values.filter(nonFunctionArgSeparator), counter = _a[0], counterStyle = _a[1];\n                        if (counter && isIdentToken(counter)) {\n                            var counterState = _this.counters.getCounterValue(counter.value);\n                            var counterType = counterStyle && isIdentToken(counterStyle)\n                                ? listStyleType.parse(_this.context, counterStyle.value)\n                                : 3 /* DECIMAL */;\n                            anonymousReplacedElement.appendChild(document.createTextNode(createCounterText(counterState, counterType, false)));\n                        }\n                    }\n                    else if (token.name === 'counters') {\n                        var _b = token.values.filter(nonFunctionArgSeparator), counter = _b[0], delim = _b[1], counterStyle = _b[2];\n                        if (counter && isIdentToken(counter)) {\n                            var counterStates = _this.counters.getCounterValues(counter.value);\n                            var counterType_1 = counterStyle && isIdentToken(counterStyle)\n                                ? listStyleType.parse(_this.context, counterStyle.value)\n                                : 3 /* DECIMAL */;\n                            var separator = delim && delim.type === 0 /* STRING_TOKEN */ ? delim.value : '';\n                            var text = counterStates\n                                .map(function (value) { return createCounterText(value, counterType_1, false); })\n                                .join(separator);\n                            anonymousReplacedElement.appendChild(document.createTextNode(text));\n                        }\n                    }\n                    else ;\n                }\n                else if (token.type === 20 /* IDENT_TOKEN */) {\n                    switch (token.value) {\n                        case 'open-quote':\n                            anonymousReplacedElement.appendChild(document.createTextNode(getQuote(declaration.quotes, _this.quoteDepth++, true)));\n                            break;\n                        case 'close-quote':\n                            anonymousReplacedElement.appendChild(document.createTextNode(getQuote(declaration.quotes, --_this.quoteDepth, false)));\n                            break;\n                        default:\n                            // safari doesn't parse string tokens correctly because of lack of quotes\n                            anonymousReplacedElement.appendChild(document.createTextNode(token.value));\n                    }\n                }\n            });\n            anonymousReplacedElement.className = PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + \" \" + PSEUDO_HIDE_ELEMENT_CLASS_AFTER;\n            var newClassName = pseudoElt === PseudoElementType.BEFORE\n                ? \" \" + PSEUDO_HIDE_ELEMENT_CLASS_BEFORE\n                : \" \" + PSEUDO_HIDE_ELEMENT_CLASS_AFTER;\n            if (isSVGElementNode(clone)) {\n                clone.className.baseValue += newClassName;\n            }\n            else {\n                clone.className += newClassName;\n            }\n            return anonymousReplacedElement;\n        };\n        DocumentCloner.destroy = function (container) {\n            if (container.parentNode) {\n                container.parentNode.removeChild(container);\n                return true;\n            }\n            return false;\n        };\n        return DocumentCloner;\n    }());\n    var PseudoElementType;\n    (function (PseudoElementType) {\n        PseudoElementType[PseudoElementType[\"BEFORE\"] = 0] = \"BEFORE\";\n        PseudoElementType[PseudoElementType[\"AFTER\"] = 1] = \"AFTER\";\n    })(PseudoElementType || (PseudoElementType = {}));\n    var createIFrameContainer = function (ownerDocument, bounds) {\n        var cloneIframeContainer = ownerDocument.createElement('iframe');\n        cloneIframeContainer.className = 'html2canvas-container';\n        cloneIframeContainer.style.visibility = 'hidden';\n        cloneIframeContainer.style.position = 'fixed';\n        cloneIframeContainer.style.left = '-10000px';\n        cloneIframeContainer.style.top = '0px';\n        cloneIframeContainer.style.border = '0';\n        cloneIframeContainer.width = bounds.width.toString();\n        cloneIframeContainer.height = bounds.height.toString();\n        cloneIframeContainer.scrolling = 'no'; // ios won't scroll without it\n        cloneIframeContainer.setAttribute(IGNORE_ATTRIBUTE, 'true');\n        ownerDocument.body.appendChild(cloneIframeContainer);\n        return cloneIframeContainer;\n    };\n    var imageReady = function (img) {\n        return new Promise(function (resolve) {\n            if (img.complete) {\n                resolve();\n                return;\n            }\n            if (!img.src) {\n                resolve();\n                return;\n            }\n            img.onload = resolve;\n            img.onerror = resolve;\n        });\n    };\n    var imagesReady = function (document) {\n        return Promise.all([].slice.call(document.images, 0).map(imageReady));\n    };\n    var iframeLoader = function (iframe) {\n        return new Promise(function (resolve, reject) {\n            var cloneWindow = iframe.contentWindow;\n            if (!cloneWindow) {\n                return reject(\"No window assigned for iframe\");\n            }\n            var documentClone = cloneWindow.document;\n            cloneWindow.onload = iframe.onload = function () {\n                cloneWindow.onload = iframe.onload = null;\n                var interval = setInterval(function () {\n                    if (documentClone.body.childNodes.length > 0 && documentClone.readyState === 'complete') {\n                        clearInterval(interval);\n                        resolve(iframe);\n                    }\n                }, 50);\n            };\n        });\n    };\n    var ignoredStyleProperties = [\n        'all',\n        'd',\n        'content' // Safari shows pseudoelements if content is set\n    ];\n    var copyCSSStyles = function (style, target) {\n        // Edge does not provide value for cssText\n        for (var i = style.length - 1; i >= 0; i--) {\n            var property = style.item(i);\n            if (ignoredStyleProperties.indexOf(property) === -1) {\n                target.style.setProperty(property, style.getPropertyValue(property));\n            }\n        }\n        return target;\n    };\n    var serializeDoctype = function (doctype) {\n        var str = '';\n        if (doctype) {\n            str += '<!DOCTYPE ';\n            if (doctype.name) {\n                str += doctype.name;\n            }\n            if (doctype.internalSubset) {\n                str += doctype.internalSubset;\n            }\n            if (doctype.publicId) {\n                str += \"\\\"\" + doctype.publicId + \"\\\"\";\n            }\n            if (doctype.systemId) {\n                str += \"\\\"\" + doctype.systemId + \"\\\"\";\n            }\n            str += '>';\n        }\n        return str;\n    };\n    var restoreOwnerScroll = function (ownerDocument, x, y) {\n        if (ownerDocument &&\n            ownerDocument.defaultView &&\n            (x !== ownerDocument.defaultView.pageXOffset || y !== ownerDocument.defaultView.pageYOffset)) {\n            ownerDocument.defaultView.scrollTo(x, y);\n        }\n    };\n    var restoreNodeScroll = function (_a) {\n        var element = _a[0], x = _a[1], y = _a[2];\n        element.scrollLeft = x;\n        element.scrollTop = y;\n    };\n    var PSEUDO_BEFORE = ':before';\n    var PSEUDO_AFTER = ':after';\n    var PSEUDO_HIDE_ELEMENT_CLASS_BEFORE = '___html2canvas___pseudoelement_before';\n    var PSEUDO_HIDE_ELEMENT_CLASS_AFTER = '___html2canvas___pseudoelement_after';\n    var PSEUDO_HIDE_ELEMENT_STYLE = \"{\\n    content: \\\"\\\" !important;\\n    display: none !important;\\n}\";\n    var createPseudoHideStyles = function (body) {\n        createStyles(body, \".\" + PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + PSEUDO_BEFORE + PSEUDO_HIDE_ELEMENT_STYLE + \"\\n         .\" + PSEUDO_HIDE_ELEMENT_CLASS_AFTER + PSEUDO_AFTER + PSEUDO_HIDE_ELEMENT_STYLE);\n    };\n    var createStyles = function (body, styles) {\n        var document = body.ownerDocument;\n        if (document) {\n            var style = document.createElement('style');\n            style.textContent = styles;\n            body.appendChild(style);\n        }\n    };\n\n    var CacheStorage = /** @class */ (function () {\n        function CacheStorage() {\n        }\n        CacheStorage.getOrigin = function (url) {\n            var link = CacheStorage._link;\n            if (!link) {\n                return 'about:blank';\n            }\n            link.href = url;\n            link.href = link.href; // IE9, LOL! - http://jsfiddle.net/niklasvh/2e48b/\n            return link.protocol + link.hostname + link.port;\n        };\n        CacheStorage.isSameOrigin = function (src) {\n            return CacheStorage.getOrigin(src) === CacheStorage._origin;\n        };\n        CacheStorage.setContext = function (window) {\n            CacheStorage._link = window.document.createElement('a');\n            CacheStorage._origin = CacheStorage.getOrigin(window.location.href);\n        };\n        CacheStorage._origin = 'about:blank';\n        return CacheStorage;\n    }());\n    var Cache = /** @class */ (function () {\n        function Cache(context, _options) {\n            this.context = context;\n            this._options = _options;\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            this._cache = {};\n        }\n        Cache.prototype.addImage = function (src) {\n            var result = Promise.resolve();\n            if (this.has(src)) {\n                return result;\n            }\n            if (isBlobImage(src) || isRenderable(src)) {\n                (this._cache[src] = this.loadImage(src)).catch(function () {\n                    // prevent unhandled rejection\n                });\n                return result;\n            }\n            return result;\n        };\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Cache.prototype.match = function (src) {\n            return this._cache[src];\n        };\n        Cache.prototype.loadImage = function (key) {\n            return __awaiter(this, void 0, void 0, function () {\n                var isSameOrigin, useCORS, useProxy, src;\n                var _this = this;\n                return __generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0:\n                            isSameOrigin = CacheStorage.isSameOrigin(key);\n                            useCORS = !isInlineImage(key) && this._options.useCORS === true && FEATURES.SUPPORT_CORS_IMAGES && !isSameOrigin;\n                            useProxy = !isInlineImage(key) &&\n                                !isSameOrigin &&\n                                !isBlobImage(key) &&\n                                typeof this._options.proxy === 'string' &&\n                                FEATURES.SUPPORT_CORS_XHR &&\n                                !useCORS;\n                            if (!isSameOrigin &&\n                                this._options.allowTaint === false &&\n                                !isInlineImage(key) &&\n                                !isBlobImage(key) &&\n                                !useProxy &&\n                                !useCORS) {\n                                return [2 /*return*/];\n                            }\n                            src = key;\n                            if (!useProxy) return [3 /*break*/, 2];\n                            return [4 /*yield*/, this.proxy(src)];\n                        case 1:\n                            src = _a.sent();\n                            _a.label = 2;\n                        case 2:\n                            this.context.logger.debug(\"Added image \" + key.substring(0, 256));\n                            return [4 /*yield*/, new Promise(function (resolve, reject) {\n                                    var img = new Image();\n                                    img.onload = function () { return resolve(img); };\n                                    img.onerror = reject;\n                                    //ios safari 10.3 taints canvas with data urls unless crossOrigin is set to anonymous\n                                    if (isInlineBase64Image(src) || useCORS) {\n                                        img.crossOrigin = 'anonymous';\n                                    }\n                                    img.src = src;\n                                    if (img.complete === true) {\n                                        // Inline XML images may fail to parse, throwing an Error later on\n                                        setTimeout(function () { return resolve(img); }, 500);\n                                    }\n                                    if (_this._options.imageTimeout > 0) {\n                                        setTimeout(function () { return reject(\"Timed out (\" + _this._options.imageTimeout + \"ms) loading image\"); }, _this._options.imageTimeout);\n                                    }\n                                })];\n                        case 3: return [2 /*return*/, _a.sent()];\n                    }\n                });\n            });\n        };\n        Cache.prototype.has = function (key) {\n            return typeof this._cache[key] !== 'undefined';\n        };\n        Cache.prototype.keys = function () {\n            return Promise.resolve(Object.keys(this._cache));\n        };\n        Cache.prototype.proxy = function (src) {\n            var _this = this;\n            var proxy = this._options.proxy;\n            if (!proxy) {\n                throw new Error('No proxy defined');\n            }\n            var key = src.substring(0, 256);\n            return new Promise(function (resolve, reject) {\n                var responseType = FEATURES.SUPPORT_RESPONSE_TYPE ? 'blob' : 'text';\n                var xhr = new XMLHttpRequest();\n                xhr.onload = function () {\n                    if (xhr.status === 200) {\n                        if (responseType === 'text') {\n                            resolve(xhr.response);\n                        }\n                        else {\n                            var reader_1 = new FileReader();\n                            reader_1.addEventListener('load', function () { return resolve(reader_1.result); }, false);\n                            reader_1.addEventListener('error', function (e) { return reject(e); }, false);\n                            reader_1.readAsDataURL(xhr.response);\n                        }\n                    }\n                    else {\n                        reject(\"Failed to proxy resource \" + key + \" with status code \" + xhr.status);\n                    }\n                };\n                xhr.onerror = reject;\n                var queryString = proxy.indexOf('?') > -1 ? '&' : '?';\n                xhr.open('GET', \"\" + proxy + queryString + \"url=\" + encodeURIComponent(src) + \"&responseType=\" + responseType);\n                if (responseType !== 'text' && xhr instanceof XMLHttpRequest) {\n                    xhr.responseType = responseType;\n                }\n                if (_this._options.imageTimeout) {\n                    var timeout_1 = _this._options.imageTimeout;\n                    xhr.timeout = timeout_1;\n                    xhr.ontimeout = function () { return reject(\"Timed out (\" + timeout_1 + \"ms) proxying \" + key); };\n                }\n                xhr.send();\n            });\n        };\n        return Cache;\n    }());\n    var INLINE_SVG = /^data:image\\/svg\\+xml/i;\n    var INLINE_BASE64 = /^data:image\\/.*;base64,/i;\n    var INLINE_IMG = /^data:image\\/.*/i;\n    var isRenderable = function (src) { return FEATURES.SUPPORT_SVG_DRAWING || !isSVG(src); };\n    var isInlineImage = function (src) { return INLINE_IMG.test(src); };\n    var isInlineBase64Image = function (src) { return INLINE_BASE64.test(src); };\n    var isBlobImage = function (src) { return src.substr(0, 4) === 'blob'; };\n    var isSVG = function (src) { return src.substr(-3).toLowerCase() === 'svg' || INLINE_SVG.test(src); };\n\n    var Vector = /** @class */ (function () {\n        function Vector(x, y) {\n            this.type = 0 /* VECTOR */;\n            this.x = x;\n            this.y = y;\n        }\n        Vector.prototype.add = function (deltaX, deltaY) {\n            return new Vector(this.x + deltaX, this.y + deltaY);\n        };\n        return Vector;\n    }());\n\n    var lerp = function (a, b, t) {\n        return new Vector(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t);\n    };\n    var BezierCurve = /** @class */ (function () {\n        function BezierCurve(start, startControl, endControl, end) {\n            this.type = 1 /* BEZIER_CURVE */;\n            this.start = start;\n            this.startControl = startControl;\n            this.endControl = endControl;\n            this.end = end;\n        }\n        BezierCurve.prototype.subdivide = function (t, firstHalf) {\n            var ab = lerp(this.start, this.startControl, t);\n            var bc = lerp(this.startControl, this.endControl, t);\n            var cd = lerp(this.endControl, this.end, t);\n            var abbc = lerp(ab, bc, t);\n            var bccd = lerp(bc, cd, t);\n            var dest = lerp(abbc, bccd, t);\n            return firstHalf ? new BezierCurve(this.start, ab, abbc, dest) : new BezierCurve(dest, bccd, cd, this.end);\n        };\n        BezierCurve.prototype.add = function (deltaX, deltaY) {\n            return new BezierCurve(this.start.add(deltaX, deltaY), this.startControl.add(deltaX, deltaY), this.endControl.add(deltaX, deltaY), this.end.add(deltaX, deltaY));\n        };\n        BezierCurve.prototype.reverse = function () {\n            return new BezierCurve(this.end, this.endControl, this.startControl, this.start);\n        };\n        return BezierCurve;\n    }());\n    var isBezierCurve = function (path) { return path.type === 1 /* BEZIER_CURVE */; };\n\n    var BoundCurves = /** @class */ (function () {\n        function BoundCurves(element) {\n            var styles = element.styles;\n            var bounds = element.bounds;\n            var _a = getAbsoluteValueForTuple(styles.borderTopLeftRadius, bounds.width, bounds.height), tlh = _a[0], tlv = _a[1];\n            var _b = getAbsoluteValueForTuple(styles.borderTopRightRadius, bounds.width, bounds.height), trh = _b[0], trv = _b[1];\n            var _c = getAbsoluteValueForTuple(styles.borderBottomRightRadius, bounds.width, bounds.height), brh = _c[0], brv = _c[1];\n            var _d = getAbsoluteValueForTuple(styles.borderBottomLeftRadius, bounds.width, bounds.height), blh = _d[0], blv = _d[1];\n            var factors = [];\n            factors.push((tlh + trh) / bounds.width);\n            factors.push((blh + brh) / bounds.width);\n            factors.push((tlv + blv) / bounds.height);\n            factors.push((trv + brv) / bounds.height);\n            var maxFactor = Math.max.apply(Math, factors);\n            if (maxFactor > 1) {\n                tlh /= maxFactor;\n                tlv /= maxFactor;\n                trh /= maxFactor;\n                trv /= maxFactor;\n                brh /= maxFactor;\n                brv /= maxFactor;\n                blh /= maxFactor;\n                blv /= maxFactor;\n            }\n            var topWidth = bounds.width - trh;\n            var rightHeight = bounds.height - brv;\n            var bottomWidth = bounds.width - brh;\n            var leftHeight = bounds.height - blv;\n            var borderTopWidth = styles.borderTopWidth;\n            var borderRightWidth = styles.borderRightWidth;\n            var borderBottomWidth = styles.borderBottomWidth;\n            var borderLeftWidth = styles.borderLeftWidth;\n            var paddingTop = getAbsoluteValue(styles.paddingTop, element.bounds.width);\n            var paddingRight = getAbsoluteValue(styles.paddingRight, element.bounds.width);\n            var paddingBottom = getAbsoluteValue(styles.paddingBottom, element.bounds.width);\n            var paddingLeft = getAbsoluteValue(styles.paddingLeft, element.bounds.width);\n            this.topLeftBorderDoubleOuterBox =\n                tlh > 0 || tlv > 0\n                    ? getCurvePoints(bounds.left + borderLeftWidth / 3, bounds.top + borderTopWidth / 3, tlh - borderLeftWidth / 3, tlv - borderTopWidth / 3, CORNER.TOP_LEFT)\n                    : new Vector(bounds.left + borderLeftWidth / 3, bounds.top + borderTopWidth / 3);\n            this.topRightBorderDoubleOuterBox =\n                tlh > 0 || tlv > 0\n                    ? getCurvePoints(bounds.left + topWidth, bounds.top + borderTopWidth / 3, trh - borderRightWidth / 3, trv - borderTopWidth / 3, CORNER.TOP_RIGHT)\n                    : new Vector(bounds.left + bounds.width - borderRightWidth / 3, bounds.top + borderTopWidth / 3);\n            this.bottomRightBorderDoubleOuterBox =\n                brh > 0 || brv > 0\n                    ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh - borderRightWidth / 3, brv - borderBottomWidth / 3, CORNER.BOTTOM_RIGHT)\n                    : new Vector(bounds.left + bounds.width - borderRightWidth / 3, bounds.top + bounds.height - borderBottomWidth / 3);\n            this.bottomLeftBorderDoubleOuterBox =\n                blh > 0 || blv > 0\n                    ? getCurvePoints(bounds.left + borderLeftWidth / 3, bounds.top + leftHeight, blh - borderLeftWidth / 3, blv - borderBottomWidth / 3, CORNER.BOTTOM_LEFT)\n                    : new Vector(bounds.left + borderLeftWidth / 3, bounds.top + bounds.height - borderBottomWidth / 3);\n            this.topLeftBorderDoubleInnerBox =\n                tlh > 0 || tlv > 0\n                    ? getCurvePoints(bounds.left + (borderLeftWidth * 2) / 3, bounds.top + (borderTopWidth * 2) / 3, tlh - (borderLeftWidth * 2) / 3, tlv - (borderTopWidth * 2) / 3, CORNER.TOP_LEFT)\n                    : new Vector(bounds.left + (borderLeftWidth * 2) / 3, bounds.top + (borderTopWidth * 2) / 3);\n            this.topRightBorderDoubleInnerBox =\n                tlh > 0 || tlv > 0\n                    ? getCurvePoints(bounds.left + topWidth, bounds.top + (borderTopWidth * 2) / 3, trh - (borderRightWidth * 2) / 3, trv - (borderTopWidth * 2) / 3, CORNER.TOP_RIGHT)\n                    : new Vector(bounds.left + bounds.width - (borderRightWidth * 2) / 3, bounds.top + (borderTopWidth * 2) / 3);\n            this.bottomRightBorderDoubleInnerBox =\n                brh > 0 || brv > 0\n                    ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh - (borderRightWidth * 2) / 3, brv - (borderBottomWidth * 2) / 3, CORNER.BOTTOM_RIGHT)\n                    : new Vector(bounds.left + bounds.width - (borderRightWidth * 2) / 3, bounds.top + bounds.height - (borderBottomWidth * 2) / 3);\n            this.bottomLeftBorderDoubleInnerBox =\n                blh > 0 || blv > 0\n                    ? getCurvePoints(bounds.left + (borderLeftWidth * 2) / 3, bounds.top + leftHeight, blh - (borderLeftWidth * 2) / 3, blv - (borderBottomWidth * 2) / 3, CORNER.BOTTOM_LEFT)\n                    : new Vector(bounds.left + (borderLeftWidth * 2) / 3, bounds.top + bounds.height - (borderBottomWidth * 2) / 3);\n            this.topLeftBorderStroke =\n                tlh > 0 || tlv > 0\n                    ? getCurvePoints(bounds.left + borderLeftWidth / 2, bounds.top + borderTopWidth / 2, tlh - borderLeftWidth / 2, tlv - borderTopWidth / 2, CORNER.TOP_LEFT)\n                    : new Vector(bounds.left + borderLeftWidth / 2, bounds.top + borderTopWidth / 2);\n            this.topRightBorderStroke =\n                tlh > 0 || tlv > 0\n                    ? getCurvePoints(bounds.left + topWidth, bounds.top + borderTopWidth / 2, trh - borderRightWidth / 2, trv - borderTopWidth / 2, CORNER.TOP_RIGHT)\n                    : new Vector(bounds.left + bounds.width - borderRightWidth / 2, bounds.top + borderTopWidth / 2);\n            this.bottomRightBorderStroke =\n                brh > 0 || brv > 0\n                    ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh - borderRightWidth / 2, brv - borderBottomWidth / 2, CORNER.BOTTOM_RIGHT)\n                    : new Vector(bounds.left + bounds.width - borderRightWidth / 2, bounds.top + bounds.height - borderBottomWidth / 2);\n            this.bottomLeftBorderStroke =\n                blh > 0 || blv > 0\n                    ? getCurvePoints(bounds.left + borderLeftWidth / 2, bounds.top + leftHeight, blh - borderLeftWidth / 2, blv - borderBottomWidth / 2, CORNER.BOTTOM_LEFT)\n                    : new Vector(bounds.left + borderLeftWidth / 2, bounds.top + bounds.height - borderBottomWidth / 2);\n            this.topLeftBorderBox =\n                tlh > 0 || tlv > 0\n                    ? getCurvePoints(bounds.left, bounds.top, tlh, tlv, CORNER.TOP_LEFT)\n                    : new Vector(bounds.left, bounds.top);\n            this.topRightBorderBox =\n                trh > 0 || trv > 0\n                    ? getCurvePoints(bounds.left + topWidth, bounds.top, trh, trv, CORNER.TOP_RIGHT)\n                    : new Vector(bounds.left + bounds.width, bounds.top);\n            this.bottomRightBorderBox =\n                brh > 0 || brv > 0\n                    ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh, brv, CORNER.BOTTOM_RIGHT)\n                    : new Vector(bounds.left + bounds.width, bounds.top + bounds.height);\n            this.bottomLeftBorderBox =\n                blh > 0 || blv > 0\n                    ? getCurvePoints(bounds.left, bounds.top + leftHeight, blh, blv, CORNER.BOTTOM_LEFT)\n                    : new Vector(bounds.left, bounds.top + bounds.height);\n            this.topLeftPaddingBox =\n                tlh > 0 || tlv > 0\n                    ? getCurvePoints(bounds.left + borderLeftWidth, bounds.top + borderTopWidth, Math.max(0, tlh - borderLeftWidth), Math.max(0, tlv - borderTopWidth), CORNER.TOP_LEFT)\n                    : new Vector(bounds.left + borderLeftWidth, bounds.top + borderTopWidth);\n            this.topRightPaddingBox =\n                trh > 0 || trv > 0\n                    ? getCurvePoints(bounds.left + Math.min(topWidth, bounds.width - borderRightWidth), bounds.top + borderTopWidth, topWidth > bounds.width + borderRightWidth ? 0 : Math.max(0, trh - borderRightWidth), Math.max(0, trv - borderTopWidth), CORNER.TOP_RIGHT)\n                    : new Vector(bounds.left + bounds.width - borderRightWidth, bounds.top + borderTopWidth);\n            this.bottomRightPaddingBox =\n                brh > 0 || brv > 0\n                    ? getCurvePoints(bounds.left + Math.min(bottomWidth, bounds.width - borderLeftWidth), bounds.top + Math.min(rightHeight, bounds.height - borderBottomWidth), Math.max(0, brh - borderRightWidth), Math.max(0, brv - borderBottomWidth), CORNER.BOTTOM_RIGHT)\n                    : new Vector(bounds.left + bounds.width - borderRightWidth, bounds.top + bounds.height - borderBottomWidth);\n            this.bottomLeftPaddingBox =\n                blh > 0 || blv > 0\n                    ? getCurvePoints(bounds.left + borderLeftWidth, bounds.top + Math.min(leftHeight, bounds.height - borderBottomWidth), Math.max(0, blh - borderLeftWidth), Math.max(0, blv - borderBottomWidth), CORNER.BOTTOM_LEFT)\n                    : new Vector(bounds.left + borderLeftWidth, bounds.top + bounds.height - borderBottomWidth);\n            this.topLeftContentBox =\n                tlh > 0 || tlv > 0\n                    ? getCurvePoints(bounds.left + borderLeftWidth + paddingLeft, bounds.top + borderTopWidth + paddingTop, Math.max(0, tlh - (borderLeftWidth + paddingLeft)), Math.max(0, tlv - (borderTopWidth + paddingTop)), CORNER.TOP_LEFT)\n                    : new Vector(bounds.left + borderLeftWidth + paddingLeft, bounds.top + borderTopWidth + paddingTop);\n            this.topRightContentBox =\n                trh > 0 || trv > 0\n                    ? getCurvePoints(bounds.left + Math.min(topWidth, bounds.width + borderLeftWidth + paddingLeft), bounds.top + borderTopWidth + paddingTop, topWidth > bounds.width + borderLeftWidth + paddingLeft ? 0 : trh - borderLeftWidth + paddingLeft, trv - (borderTopWidth + paddingTop), CORNER.TOP_RIGHT)\n                    : new Vector(bounds.left + bounds.width - (borderRightWidth + paddingRight), bounds.top + borderTopWidth + paddingTop);\n            this.bottomRightContentBox =\n                brh > 0 || brv > 0\n                    ? getCurvePoints(bounds.left + Math.min(bottomWidth, bounds.width - (borderLeftWidth + paddingLeft)), bounds.top + Math.min(rightHeight, bounds.height + borderTopWidth + paddingTop), Math.max(0, brh - (borderRightWidth + paddingRight)), brv - (borderBottomWidth + paddingBottom), CORNER.BOTTOM_RIGHT)\n                    : new Vector(bounds.left + bounds.width - (borderRightWidth + paddingRight), bounds.top + bounds.height - (borderBottomWidth + paddingBottom));\n            this.bottomLeftContentBox =\n                blh > 0 || blv > 0\n                    ? getCurvePoints(bounds.left + borderLeftWidth + paddingLeft, bounds.top + leftHeight, Math.max(0, blh - (borderLeftWidth + paddingLeft)), blv - (borderBottomWidth + paddingBottom), CORNER.BOTTOM_LEFT)\n                    : new Vector(bounds.left + borderLeftWidth + paddingLeft, bounds.top + bounds.height - (borderBottomWidth + paddingBottom));\n        }\n        return BoundCurves;\n    }());\n    var CORNER;\n    (function (CORNER) {\n        CORNER[CORNER[\"TOP_LEFT\"] = 0] = \"TOP_LEFT\";\n        CORNER[CORNER[\"TOP_RIGHT\"] = 1] = \"TOP_RIGHT\";\n        CORNER[CORNER[\"BOTTOM_RIGHT\"] = 2] = \"BOTTOM_RIGHT\";\n        CORNER[CORNER[\"BOTTOM_LEFT\"] = 3] = \"BOTTOM_LEFT\";\n    })(CORNER || (CORNER = {}));\n    var getCurvePoints = function (x, y, r1, r2, position) {\n        var kappa = 4 * ((Math.sqrt(2) - 1) / 3);\n        var ox = r1 * kappa; // control point offset horizontal\n        var oy = r2 * kappa; // control point offset vertical\n        var xm = x + r1; // x-middle\n        var ym = y + r2; // y-middle\n        switch (position) {\n            case CORNER.TOP_LEFT:\n                return new BezierCurve(new Vector(x, ym), new Vector(x, ym - oy), new Vector(xm - ox, y), new Vector(xm, y));\n            case CORNER.TOP_RIGHT:\n                return new BezierCurve(new Vector(x, y), new Vector(x + ox, y), new Vector(xm, ym - oy), new Vector(xm, ym));\n            case CORNER.BOTTOM_RIGHT:\n                return new BezierCurve(new Vector(xm, y), new Vector(xm, y + oy), new Vector(x + ox, ym), new Vector(x, ym));\n            case CORNER.BOTTOM_LEFT:\n            default:\n                return new BezierCurve(new Vector(xm, ym), new Vector(xm - ox, ym), new Vector(x, y + oy), new Vector(x, y));\n        }\n    };\n    var calculateBorderBoxPath = function (curves) {\n        return [curves.topLeftBorderBox, curves.topRightBorderBox, curves.bottomRightBorderBox, curves.bottomLeftBorderBox];\n    };\n    var calculateContentBoxPath = function (curves) {\n        return [\n            curves.topLeftContentBox,\n            curves.topRightContentBox,\n            curves.bottomRightContentBox,\n            curves.bottomLeftContentBox\n        ];\n    };\n    var calculatePaddingBoxPath = function (curves) {\n        return [\n            curves.topLeftPaddingBox,\n            curves.topRightPaddingBox,\n            curves.bottomRightPaddingBox,\n            curves.bottomLeftPaddingBox\n        ];\n    };\n\n    var TransformEffect = /** @class */ (function () {\n        function TransformEffect(offsetX, offsetY, matrix) {\n            this.offsetX = offsetX;\n            this.offsetY = offsetY;\n            this.matrix = matrix;\n            this.type = 0 /* TRANSFORM */;\n            this.target = 2 /* BACKGROUND_BORDERS */ | 4 /* CONTENT */;\n        }\n        return TransformEffect;\n    }());\n    var ClipEffect = /** @class */ (function () {\n        function ClipEffect(path, target) {\n            this.path = path;\n            this.target = target;\n            this.type = 1 /* CLIP */;\n        }\n        return ClipEffect;\n    }());\n    var OpacityEffect = /** @class */ (function () {\n        function OpacityEffect(opacity) {\n            this.opacity = opacity;\n            this.type = 2 /* OPACITY */;\n            this.target = 2 /* BACKGROUND_BORDERS */ | 4 /* CONTENT */;\n        }\n        return OpacityEffect;\n    }());\n    var isTransformEffect = function (effect) {\n        return effect.type === 0 /* TRANSFORM */;\n    };\n    var isClipEffect = function (effect) { return effect.type === 1 /* CLIP */; };\n    var isOpacityEffect = function (effect) { return effect.type === 2 /* OPACITY */; };\n\n    var equalPath = function (a, b) {\n        if (a.length === b.length) {\n            return a.some(function (v, i) { return v === b[i]; });\n        }\n        return false;\n    };\n    var transformPath = function (path, deltaX, deltaY, deltaW, deltaH) {\n        return path.map(function (point, index) {\n            switch (index) {\n                case 0:\n                    return point.add(deltaX, deltaY);\n                case 1:\n                    return point.add(deltaX + deltaW, deltaY);\n                case 2:\n                    return point.add(deltaX + deltaW, deltaY + deltaH);\n                case 3:\n                    return point.add(deltaX, deltaY + deltaH);\n            }\n            return point;\n        });\n    };\n\n    var StackingContext = /** @class */ (function () {\n        function StackingContext(container) {\n            this.element = container;\n            this.inlineLevel = [];\n            this.nonInlineLevel = [];\n            this.negativeZIndex = [];\n            this.zeroOrAutoZIndexOrTransformedOrOpacity = [];\n            this.positiveZIndex = [];\n            this.nonPositionedFloats = [];\n            this.nonPositionedInlineLevel = [];\n        }\n        return StackingContext;\n    }());\n    var ElementPaint = /** @class */ (function () {\n        function ElementPaint(container, parent) {\n            this.container = container;\n            this.parent = parent;\n            this.effects = [];\n            this.curves = new BoundCurves(this.container);\n            if (this.container.styles.opacity < 1) {\n                this.effects.push(new OpacityEffect(this.container.styles.opacity));\n            }\n            if (this.container.styles.transform !== null) {\n                var offsetX = this.container.bounds.left + this.container.styles.transformOrigin[0].number;\n                var offsetY = this.container.bounds.top + this.container.styles.transformOrigin[1].number;\n                var matrix = this.container.styles.transform;\n                this.effects.push(new TransformEffect(offsetX, offsetY, matrix));\n            }\n            if (this.container.styles.overflowX !== 0 /* VISIBLE */) {\n                var borderBox = calculateBorderBoxPath(this.curves);\n                var paddingBox = calculatePaddingBoxPath(this.curves);\n                if (equalPath(borderBox, paddingBox)) {\n                    this.effects.push(new ClipEffect(borderBox, 2 /* BACKGROUND_BORDERS */ | 4 /* CONTENT */));\n                }\n                else {\n                    this.effects.push(new ClipEffect(borderBox, 2 /* BACKGROUND_BORDERS */));\n                    this.effects.push(new ClipEffect(paddingBox, 4 /* CONTENT */));\n                }\n            }\n        }\n        ElementPaint.prototype.getEffects = function (target) {\n            var inFlow = [2 /* ABSOLUTE */, 3 /* FIXED */].indexOf(this.container.styles.position) === -1;\n            var parent = this.parent;\n            var effects = this.effects.slice(0);\n            while (parent) {\n                var croplessEffects = parent.effects.filter(function (effect) { return !isClipEffect(effect); });\n                if (inFlow || parent.container.styles.position !== 0 /* STATIC */ || !parent.parent) {\n                    effects.unshift.apply(effects, croplessEffects);\n                    inFlow = [2 /* ABSOLUTE */, 3 /* FIXED */].indexOf(parent.container.styles.position) === -1;\n                    if (parent.container.styles.overflowX !== 0 /* VISIBLE */) {\n                        var borderBox = calculateBorderBoxPath(parent.curves);\n                        var paddingBox = calculatePaddingBoxPath(parent.curves);\n                        if (!equalPath(borderBox, paddingBox)) {\n                            effects.unshift(new ClipEffect(paddingBox, 2 /* BACKGROUND_BORDERS */ | 4 /* CONTENT */));\n                        }\n                    }\n                }\n                else {\n                    effects.unshift.apply(effects, croplessEffects);\n                }\n                parent = parent.parent;\n            }\n            return effects.filter(function (effect) { return contains(effect.target, target); });\n        };\n        return ElementPaint;\n    }());\n    var parseStackTree = function (parent, stackingContext, realStackingContext, listItems) {\n        parent.container.elements.forEach(function (child) {\n            var treatAsRealStackingContext = contains(child.flags, 4 /* CREATES_REAL_STACKING_CONTEXT */);\n            var createsStackingContext = contains(child.flags, 2 /* CREATES_STACKING_CONTEXT */);\n            var paintContainer = new ElementPaint(child, parent);\n            if (contains(child.styles.display, 2048 /* LIST_ITEM */)) {\n                listItems.push(paintContainer);\n            }\n            var listOwnerItems = contains(child.flags, 8 /* IS_LIST_OWNER */) ? [] : listItems;\n            if (treatAsRealStackingContext || createsStackingContext) {\n                var parentStack = treatAsRealStackingContext || child.styles.isPositioned() ? realStackingContext : stackingContext;\n                var stack = new StackingContext(paintContainer);\n                if (child.styles.isPositioned() || child.styles.opacity < 1 || child.styles.isTransformed()) {\n                    var order_1 = child.styles.zIndex.order;\n                    if (order_1 < 0) {\n                        var index_1 = 0;\n                        parentStack.negativeZIndex.some(function (current, i) {\n                            if (order_1 > current.element.container.styles.zIndex.order) {\n                                index_1 = i;\n                                return false;\n                            }\n                            else if (index_1 > 0) {\n                                return true;\n                            }\n                            return false;\n                        });\n                        parentStack.negativeZIndex.splice(index_1, 0, stack);\n                    }\n                    else if (order_1 > 0) {\n                        var index_2 = 0;\n                        parentStack.positiveZIndex.some(function (current, i) {\n                            if (order_1 >= current.element.container.styles.zIndex.order) {\n                                index_2 = i + 1;\n                                return false;\n                            }\n                            else if (index_2 > 0) {\n                                return true;\n                            }\n                            return false;\n                        });\n                        parentStack.positiveZIndex.splice(index_2, 0, stack);\n                    }\n                    else {\n                        parentStack.zeroOrAutoZIndexOrTransformedOrOpacity.push(stack);\n                    }\n                }\n                else {\n                    if (child.styles.isFloating()) {\n                        parentStack.nonPositionedFloats.push(stack);\n                    }\n                    else {\n                        parentStack.nonPositionedInlineLevel.push(stack);\n                    }\n                }\n                parseStackTree(paintContainer, stack, treatAsRealStackingContext ? stack : realStackingContext, listOwnerItems);\n            }\n            else {\n                if (child.styles.isInlineLevel()) {\n                    stackingContext.inlineLevel.push(paintContainer);\n                }\n                else {\n                    stackingContext.nonInlineLevel.push(paintContainer);\n                }\n                parseStackTree(paintContainer, stackingContext, realStackingContext, listOwnerItems);\n            }\n            if (contains(child.flags, 8 /* IS_LIST_OWNER */)) {\n                processListItems(child, listOwnerItems);\n            }\n        });\n    };\n    var processListItems = function (owner, elements) {\n        var numbering = owner instanceof OLElementContainer ? owner.start : 1;\n        var reversed = owner instanceof OLElementContainer ? owner.reversed : false;\n        for (var i = 0; i < elements.length; i++) {\n            var item = elements[i];\n            if (item.container instanceof LIElementContainer &&\n                typeof item.container.value === 'number' &&\n                item.container.value !== 0) {\n                numbering = item.container.value;\n            }\n            item.listValue = createCounterText(numbering, item.container.styles.listStyleType, true);\n            numbering += reversed ? -1 : 1;\n        }\n    };\n    var parseStackingContexts = function (container) {\n        var paintContainer = new ElementPaint(container, null);\n        var root = new StackingContext(paintContainer);\n        var listItems = [];\n        parseStackTree(paintContainer, root, root, listItems);\n        processListItems(paintContainer.container, listItems);\n        return root;\n    };\n\n    var parsePathForBorder = function (curves, borderSide) {\n        switch (borderSide) {\n            case 0:\n                return createPathFromCurves(curves.topLeftBorderBox, curves.topLeftPaddingBox, curves.topRightBorderBox, curves.topRightPaddingBox);\n            case 1:\n                return createPathFromCurves(curves.topRightBorderBox, curves.topRightPaddingBox, curves.bottomRightBorderBox, curves.bottomRightPaddingBox);\n            case 2:\n                return createPathFromCurves(curves.bottomRightBorderBox, curves.bottomRightPaddingBox, curves.bottomLeftBorderBox, curves.bottomLeftPaddingBox);\n            case 3:\n            default:\n                return createPathFromCurves(curves.bottomLeftBorderBox, curves.bottomLeftPaddingBox, curves.topLeftBorderBox, curves.topLeftPaddingBox);\n        }\n    };\n    var parsePathForBorderDoubleOuter = function (curves, borderSide) {\n        switch (borderSide) {\n            case 0:\n                return createPathFromCurves(curves.topLeftBorderBox, curves.topLeftBorderDoubleOuterBox, curves.topRightBorderBox, curves.topRightBorderDoubleOuterBox);\n            case 1:\n                return createPathFromCurves(curves.topRightBorderBox, curves.topRightBorderDoubleOuterBox, curves.bottomRightBorderBox, curves.bottomRightBorderDoubleOuterBox);\n            case 2:\n                return createPathFromCurves(curves.bottomRightBorderBox, curves.bottomRightBorderDoubleOuterBox, curves.bottomLeftBorderBox, curves.bottomLeftBorderDoubleOuterBox);\n            case 3:\n            default:\n                return createPathFromCurves(curves.bottomLeftBorderBox, curves.bottomLeftBorderDoubleOuterBox, curves.topLeftBorderBox, curves.topLeftBorderDoubleOuterBox);\n        }\n    };\n    var parsePathForBorderDoubleInner = function (curves, borderSide) {\n        switch (borderSide) {\n            case 0:\n                return createPathFromCurves(curves.topLeftBorderDoubleInnerBox, curves.topLeftPaddingBox, curves.topRightBorderDoubleInnerBox, curves.topRightPaddingBox);\n            case 1:\n                return createPathFromCurves(curves.topRightBorderDoubleInnerBox, curves.topRightPaddingBox, curves.bottomRightBorderDoubleInnerBox, curves.bottomRightPaddingBox);\n            case 2:\n                return createPathFromCurves(curves.bottomRightBorderDoubleInnerBox, curves.bottomRightPaddingBox, curves.bottomLeftBorderDoubleInnerBox, curves.bottomLeftPaddingBox);\n            case 3:\n            default:\n                return createPathFromCurves(curves.bottomLeftBorderDoubleInnerBox, curves.bottomLeftPaddingBox, curves.topLeftBorderDoubleInnerBox, curves.topLeftPaddingBox);\n        }\n    };\n    var parsePathForBorderStroke = function (curves, borderSide) {\n        switch (borderSide) {\n            case 0:\n                return createStrokePathFromCurves(curves.topLeftBorderStroke, curves.topRightBorderStroke);\n            case 1:\n                return createStrokePathFromCurves(curves.topRightBorderStroke, curves.bottomRightBorderStroke);\n            case 2:\n                return createStrokePathFromCurves(curves.bottomRightBorderStroke, curves.bottomLeftBorderStroke);\n            case 3:\n            default:\n                return createStrokePathFromCurves(curves.bottomLeftBorderStroke, curves.topLeftBorderStroke);\n        }\n    };\n    var createStrokePathFromCurves = function (outer1, outer2) {\n        var path = [];\n        if (isBezierCurve(outer1)) {\n            path.push(outer1.subdivide(0.5, false));\n        }\n        else {\n            path.push(outer1);\n        }\n        if (isBezierCurve(outer2)) {\n            path.push(outer2.subdivide(0.5, true));\n        }\n        else {\n            path.push(outer2);\n        }\n        return path;\n    };\n    var createPathFromCurves = function (outer1, inner1, outer2, inner2) {\n        var path = [];\n        if (isBezierCurve(outer1)) {\n            path.push(outer1.subdivide(0.5, false));\n        }\n        else {\n            path.push(outer1);\n        }\n        if (isBezierCurve(outer2)) {\n            path.push(outer2.subdivide(0.5, true));\n        }\n        else {\n            path.push(outer2);\n        }\n        if (isBezierCurve(inner2)) {\n            path.push(inner2.subdivide(0.5, true).reverse());\n        }\n        else {\n            path.push(inner2);\n        }\n        if (isBezierCurve(inner1)) {\n            path.push(inner1.subdivide(0.5, false).reverse());\n        }\n        else {\n            path.push(inner1);\n        }\n        return path;\n    };\n\n    var paddingBox = function (element) {\n        var bounds = element.bounds;\n        var styles = element.styles;\n        return bounds.add(styles.borderLeftWidth, styles.borderTopWidth, -(styles.borderRightWidth + styles.borderLeftWidth), -(styles.borderTopWidth + styles.borderBottomWidth));\n    };\n    var contentBox = function (element) {\n        var styles = element.styles;\n        var bounds = element.bounds;\n        var paddingLeft = getAbsoluteValue(styles.paddingLeft, bounds.width);\n        var paddingRight = getAbsoluteValue(styles.paddingRight, bounds.width);\n        var paddingTop = getAbsoluteValue(styles.paddingTop, bounds.width);\n        var paddingBottom = getAbsoluteValue(styles.paddingBottom, bounds.width);\n        return bounds.add(paddingLeft + styles.borderLeftWidth, paddingTop + styles.borderTopWidth, -(styles.borderRightWidth + styles.borderLeftWidth + paddingLeft + paddingRight), -(styles.borderTopWidth + styles.borderBottomWidth + paddingTop + paddingBottom));\n    };\n\n    var calculateBackgroundPositioningArea = function (backgroundOrigin, element) {\n        if (backgroundOrigin === 0 /* BORDER_BOX */) {\n            return element.bounds;\n        }\n        if (backgroundOrigin === 2 /* CONTENT_BOX */) {\n            return contentBox(element);\n        }\n        return paddingBox(element);\n    };\n    var calculateBackgroundPaintingArea = function (backgroundClip, element) {\n        if (backgroundClip === 0 /* BORDER_BOX */) {\n            return element.bounds;\n        }\n        if (backgroundClip === 2 /* CONTENT_BOX */) {\n            return contentBox(element);\n        }\n        return paddingBox(element);\n    };\n    var calculateBackgroundRendering = function (container, index, intrinsicSize) {\n        var backgroundPositioningArea = calculateBackgroundPositioningArea(getBackgroundValueForIndex(container.styles.backgroundOrigin, index), container);\n        var backgroundPaintingArea = calculateBackgroundPaintingArea(getBackgroundValueForIndex(container.styles.backgroundClip, index), container);\n        var backgroundImageSize = calculateBackgroundSize(getBackgroundValueForIndex(container.styles.backgroundSize, index), intrinsicSize, backgroundPositioningArea);\n        var sizeWidth = backgroundImageSize[0], sizeHeight = backgroundImageSize[1];\n        var position = getAbsoluteValueForTuple(getBackgroundValueForIndex(container.styles.backgroundPosition, index), backgroundPositioningArea.width - sizeWidth, backgroundPositioningArea.height - sizeHeight);\n        var path = calculateBackgroundRepeatPath(getBackgroundValueForIndex(container.styles.backgroundRepeat, index), position, backgroundImageSize, backgroundPositioningArea, backgroundPaintingArea);\n        var offsetX = Math.round(backgroundPositioningArea.left + position[0]);\n        var offsetY = Math.round(backgroundPositioningArea.top + position[1]);\n        return [path, offsetX, offsetY, sizeWidth, sizeHeight];\n    };\n    var isAuto = function (token) { return isIdentToken(token) && token.value === BACKGROUND_SIZE.AUTO; };\n    var hasIntrinsicValue = function (value) { return typeof value === 'number'; };\n    var calculateBackgroundSize = function (size, _a, bounds) {\n        var intrinsicWidth = _a[0], intrinsicHeight = _a[1], intrinsicProportion = _a[2];\n        var first = size[0], second = size[1];\n        if (!first) {\n            return [0, 0];\n        }\n        if (isLengthPercentage(first) && second && isLengthPercentage(second)) {\n            return [getAbsoluteValue(first, bounds.width), getAbsoluteValue(second, bounds.height)];\n        }\n        var hasIntrinsicProportion = hasIntrinsicValue(intrinsicProportion);\n        if (isIdentToken(first) && (first.value === BACKGROUND_SIZE.CONTAIN || first.value === BACKGROUND_SIZE.COVER)) {\n            if (hasIntrinsicValue(intrinsicProportion)) {\n                var targetRatio = bounds.width / bounds.height;\n                return targetRatio < intrinsicProportion !== (first.value === BACKGROUND_SIZE.COVER)\n                    ? [bounds.width, bounds.width / intrinsicProportion]\n                    : [bounds.height * intrinsicProportion, bounds.height];\n            }\n            return [bounds.width, bounds.height];\n        }\n        var hasIntrinsicWidth = hasIntrinsicValue(intrinsicWidth);\n        var hasIntrinsicHeight = hasIntrinsicValue(intrinsicHeight);\n        var hasIntrinsicDimensions = hasIntrinsicWidth || hasIntrinsicHeight;\n        // If the background-size is auto or auto auto:\n        if (isAuto(first) && (!second || isAuto(second))) {\n            // If the image has both horizontal and vertical intrinsic dimensions, it's rendered at that size.\n            if (hasIntrinsicWidth && hasIntrinsicHeight) {\n                return [intrinsicWidth, intrinsicHeight];\n            }\n            // If the image has no intrinsic dimensions and has no intrinsic proportions,\n            // it's rendered at the size of the background positioning area.\n            if (!hasIntrinsicProportion && !hasIntrinsicDimensions) {\n                return [bounds.width, bounds.height];\n            }\n            // TODO If the image has no intrinsic dimensions but has intrinsic proportions, it's rendered as if contain had been specified instead.\n            // If the image has only one intrinsic dimension and has intrinsic proportions, it's rendered at the size corresponding to that one dimension.\n            // The other dimension is computed using the specified dimension and the intrinsic proportions.\n            if (hasIntrinsicDimensions && hasIntrinsicProportion) {\n                var width_1 = hasIntrinsicWidth\n                    ? intrinsicWidth\n                    : intrinsicHeight * intrinsicProportion;\n                var height_1 = hasIntrinsicHeight\n                    ? intrinsicHeight\n                    : intrinsicWidth / intrinsicProportion;\n                return [width_1, height_1];\n            }\n            // If the image has only one intrinsic dimension but has no intrinsic proportions,\n            // it's rendered using the specified dimension and the other dimension of the background positioning area.\n            var width_2 = hasIntrinsicWidth ? intrinsicWidth : bounds.width;\n            var height_2 = hasIntrinsicHeight ? intrinsicHeight : bounds.height;\n            return [width_2, height_2];\n        }\n        // If the image has intrinsic proportions, it's stretched to the specified dimension.\n        // The unspecified dimension is computed using the specified dimension and the intrinsic proportions.\n        if (hasIntrinsicProportion) {\n            var width_3 = 0;\n            var height_3 = 0;\n            if (isLengthPercentage(first)) {\n                width_3 = getAbsoluteValue(first, bounds.width);\n            }\n            else if (isLengthPercentage(second)) {\n                height_3 = getAbsoluteValue(second, bounds.height);\n            }\n            if (isAuto(first)) {\n                width_3 = height_3 * intrinsicProportion;\n            }\n            else if (!second || isAuto(second)) {\n                height_3 = width_3 / intrinsicProportion;\n            }\n            return [width_3, height_3];\n        }\n        // If the image has no intrinsic proportions, it's stretched to the specified dimension.\n        // The unspecified dimension is computed using the image's corresponding intrinsic dimension,\n        // if there is one. If there is no such intrinsic dimension,\n        // it becomes the corresponding dimension of the background positioning area.\n        var width = null;\n        var height = null;\n        if (isLengthPercentage(first)) {\n            width = getAbsoluteValue(first, bounds.width);\n        }\n        else if (second && isLengthPercentage(second)) {\n            height = getAbsoluteValue(second, bounds.height);\n        }\n        if (width !== null && (!second || isAuto(second))) {\n            height =\n                hasIntrinsicWidth && hasIntrinsicHeight\n                    ? (width / intrinsicWidth) * intrinsicHeight\n                    : bounds.height;\n        }\n        if (height !== null && isAuto(first)) {\n            width =\n                hasIntrinsicWidth && hasIntrinsicHeight\n                    ? (height / intrinsicHeight) * intrinsicWidth\n                    : bounds.width;\n        }\n        if (width !== null && height !== null) {\n            return [width, height];\n        }\n        throw new Error(\"Unable to calculate background-size for element\");\n    };\n    var getBackgroundValueForIndex = function (values, index) {\n        var value = values[index];\n        if (typeof value === 'undefined') {\n            return values[0];\n        }\n        return value;\n    };\n    var calculateBackgroundRepeatPath = function (repeat, _a, _b, backgroundPositioningArea, backgroundPaintingArea) {\n        var x = _a[0], y = _a[1];\n        var width = _b[0], height = _b[1];\n        switch (repeat) {\n            case 2 /* REPEAT_X */:\n                return [\n                    new Vector(Math.round(backgroundPositioningArea.left), Math.round(backgroundPositioningArea.top + y)),\n                    new Vector(Math.round(backgroundPositioningArea.left + backgroundPositioningArea.width), Math.round(backgroundPositioningArea.top + y)),\n                    new Vector(Math.round(backgroundPositioningArea.left + backgroundPositioningArea.width), Math.round(height + backgroundPositioningArea.top + y)),\n                    new Vector(Math.round(backgroundPositioningArea.left), Math.round(height + backgroundPositioningArea.top + y))\n                ];\n            case 3 /* REPEAT_Y */:\n                return [\n                    new Vector(Math.round(backgroundPositioningArea.left + x), Math.round(backgroundPositioningArea.top)),\n                    new Vector(Math.round(backgroundPositioningArea.left + x + width), Math.round(backgroundPositioningArea.top)),\n                    new Vector(Math.round(backgroundPositioningArea.left + x + width), Math.round(backgroundPositioningArea.height + backgroundPositioningArea.top)),\n                    new Vector(Math.round(backgroundPositioningArea.left + x), Math.round(backgroundPositioningArea.height + backgroundPositioningArea.top))\n                ];\n            case 1 /* NO_REPEAT */:\n                return [\n                    new Vector(Math.round(backgroundPositioningArea.left + x), Math.round(backgroundPositioningArea.top + y)),\n                    new Vector(Math.round(backgroundPositioningArea.left + x + width), Math.round(backgroundPositioningArea.top + y)),\n                    new Vector(Math.round(backgroundPositioningArea.left + x + width), Math.round(backgroundPositioningArea.top + y + height)),\n                    new Vector(Math.round(backgroundPositioningArea.left + x), Math.round(backgroundPositioningArea.top + y + height))\n                ];\n            default:\n                return [\n                    new Vector(Math.round(backgroundPaintingArea.left), Math.round(backgroundPaintingArea.top)),\n                    new Vector(Math.round(backgroundPaintingArea.left + backgroundPaintingArea.width), Math.round(backgroundPaintingArea.top)),\n                    new Vector(Math.round(backgroundPaintingArea.left + backgroundPaintingArea.width), Math.round(backgroundPaintingArea.height + backgroundPaintingArea.top)),\n                    new Vector(Math.round(backgroundPaintingArea.left), Math.round(backgroundPaintingArea.height + backgroundPaintingArea.top))\n                ];\n        }\n    };\n\n    var SMALL_IMAGE = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';\n\n    var SAMPLE_TEXT = 'Hidden Text';\n    var FontMetrics = /** @class */ (function () {\n        function FontMetrics(document) {\n            this._data = {};\n            this._document = document;\n        }\n        FontMetrics.prototype.parseMetrics = function (fontFamily, fontSize) {\n            var container = this._document.createElement('div');\n            var img = this._document.createElement('img');\n            var span = this._document.createElement('span');\n            var body = this._document.body;\n            container.style.visibility = 'hidden';\n            container.style.fontFamily = fontFamily;\n            container.style.fontSize = fontSize;\n            container.style.margin = '0';\n            container.style.padding = '0';\n            container.style.whiteSpace = 'nowrap';\n            body.appendChild(container);\n            img.src = SMALL_IMAGE;\n            img.width = 1;\n            img.height = 1;\n            img.style.margin = '0';\n            img.style.padding = '0';\n            img.style.verticalAlign = 'baseline';\n            span.style.fontFamily = fontFamily;\n            span.style.fontSize = fontSize;\n            span.style.margin = '0';\n            span.style.padding = '0';\n            span.appendChild(this._document.createTextNode(SAMPLE_TEXT));\n            container.appendChild(span);\n            container.appendChild(img);\n            var baseline = img.offsetTop - span.offsetTop + 2;\n            container.removeChild(span);\n            container.appendChild(this._document.createTextNode(SAMPLE_TEXT));\n            container.style.lineHeight = 'normal';\n            img.style.verticalAlign = 'super';\n            var middle = img.offsetTop - container.offsetTop + 2;\n            body.removeChild(container);\n            return { baseline: baseline, middle: middle };\n        };\n        FontMetrics.prototype.getMetrics = function (fontFamily, fontSize) {\n            var key = fontFamily + \" \" + fontSize;\n            if (typeof this._data[key] === 'undefined') {\n                this._data[key] = this.parseMetrics(fontFamily, fontSize);\n            }\n            return this._data[key];\n        };\n        return FontMetrics;\n    }());\n\n    var Renderer = /** @class */ (function () {\n        function Renderer(context, options) {\n            this.context = context;\n            this.options = options;\n        }\n        return Renderer;\n    }());\n\n    var MASK_OFFSET = 10000;\n    var CanvasRenderer = /** @class */ (function (_super) {\n        __extends(CanvasRenderer, _super);\n        function CanvasRenderer(context, options) {\n            var _this = _super.call(this, context, options) || this;\n            _this._activeEffects = [];\n            _this.canvas = options.canvas ? options.canvas : document.createElement('canvas');\n            _this.ctx = _this.canvas.getContext('2d');\n            if (!options.canvas) {\n                _this.canvas.width = Math.floor(options.width * options.scale);\n                _this.canvas.height = Math.floor(options.height * options.scale);\n                _this.canvas.style.width = options.width + \"px\";\n                _this.canvas.style.height = options.height + \"px\";\n            }\n            _this.fontMetrics = new FontMetrics(document);\n            _this.ctx.scale(_this.options.scale, _this.options.scale);\n            _this.ctx.translate(-options.x, -options.y);\n            _this.ctx.textBaseline = 'bottom';\n            _this._activeEffects = [];\n            _this.context.logger.debug(\"Canvas renderer initialized (\" + options.width + \"x\" + options.height + \") with scale \" + options.scale);\n            return _this;\n        }\n        CanvasRenderer.prototype.applyEffects = function (effects) {\n            var _this = this;\n            while (this._activeEffects.length) {\n                this.popEffect();\n            }\n            effects.forEach(function (effect) { return _this.applyEffect(effect); });\n        };\n        CanvasRenderer.prototype.applyEffect = function (effect) {\n            this.ctx.save();\n            if (isOpacityEffect(effect)) {\n                this.ctx.globalAlpha = effect.opacity;\n            }\n            if (isTransformEffect(effect)) {\n                this.ctx.translate(effect.offsetX, effect.offsetY);\n                this.ctx.transform(effect.matrix[0], effect.matrix[1], effect.matrix[2], effect.matrix[3], effect.matrix[4], effect.matrix[5]);\n                this.ctx.translate(-effect.offsetX, -effect.offsetY);\n            }\n            if (isClipEffect(effect)) {\n                this.path(effect.path);\n                this.ctx.clip();\n            }\n            this._activeEffects.push(effect);\n        };\n        CanvasRenderer.prototype.popEffect = function () {\n            this._activeEffects.pop();\n            this.ctx.restore();\n        };\n        CanvasRenderer.prototype.renderStack = function (stack) {\n            return __awaiter(this, void 0, void 0, function () {\n                var styles;\n                return __generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0:\n                            styles = stack.element.container.styles;\n                            if (!styles.isVisible()) return [3 /*break*/, 2];\n                            return [4 /*yield*/, this.renderStackContent(stack)];\n                        case 1:\n                            _a.sent();\n                            _a.label = 2;\n                        case 2: return [2 /*return*/];\n                    }\n                });\n            });\n        };\n        CanvasRenderer.prototype.renderNode = function (paint) {\n            return __awaiter(this, void 0, void 0, function () {\n                return __generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0:\n                            if (contains(paint.container.flags, 16 /* DEBUG_RENDER */)) {\n                                debugger;\n                            }\n                            if (!paint.container.styles.isVisible()) return [3 /*break*/, 3];\n                            return [4 /*yield*/, this.renderNodeBackgroundAndBorders(paint)];\n                        case 1:\n                            _a.sent();\n                            return [4 /*yield*/, this.renderNodeContent(paint)];\n                        case 2:\n                            _a.sent();\n                            _a.label = 3;\n                        case 3: return [2 /*return*/];\n                    }\n                });\n            });\n        };\n        CanvasRenderer.prototype.renderTextWithLetterSpacing = function (text, letterSpacing, baseline) {\n            var _this = this;\n            if (letterSpacing === 0) {\n                this.ctx.fillText(text.text, text.bounds.left, text.bounds.top + baseline);\n            }\n            else {\n                var letters = segmentGraphemes(text.text);\n                letters.reduce(function (left, letter) {\n                    _this.ctx.fillText(letter, left, text.bounds.top + baseline);\n                    return left + _this.ctx.measureText(letter).width;\n                }, text.bounds.left);\n            }\n        };\n        CanvasRenderer.prototype.createFontStyle = function (styles) {\n            var fontVariant = styles.fontVariant\n                .filter(function (variant) { return variant === 'normal' || variant === 'small-caps'; })\n                .join('');\n            var fontFamily = fixIOSSystemFonts(styles.fontFamily).join(', ');\n            var fontSize = isDimensionToken(styles.fontSize)\n                ? \"\" + styles.fontSize.number + styles.fontSize.unit\n                : styles.fontSize.number + \"px\";\n            return [\n                [styles.fontStyle, fontVariant, styles.fontWeight, fontSize, fontFamily].join(' '),\n                fontFamily,\n                fontSize\n            ];\n        };\n        CanvasRenderer.prototype.renderTextNode = function (text, styles) {\n            return __awaiter(this, void 0, void 0, function () {\n                var _a, font, fontFamily, fontSize, _b, baseline, middle, paintOrder;\n                var _this = this;\n                return __generator(this, function (_c) {\n                    _a = this.createFontStyle(styles), font = _a[0], fontFamily = _a[1], fontSize = _a[2];\n                    this.ctx.font = font;\n                    this.ctx.direction = styles.direction === 1 /* RTL */ ? 'rtl' : 'ltr';\n                    this.ctx.textAlign = 'left';\n                    this.ctx.textBaseline = 'alphabetic';\n                    _b = this.fontMetrics.getMetrics(fontFamily, fontSize), baseline = _b.baseline, middle = _b.middle;\n                    paintOrder = styles.paintOrder;\n                    text.textBounds.forEach(function (text) {\n                        paintOrder.forEach(function (paintOrderLayer) {\n                            switch (paintOrderLayer) {\n                                case 0 /* FILL */:\n                                    _this.ctx.fillStyle = asString(styles.color);\n                                    _this.renderTextWithLetterSpacing(text, styles.letterSpacing, baseline);\n                                    var textShadows = styles.textShadow;\n                                    if (textShadows.length && text.text.trim().length) {\n                                        textShadows\n                                            .slice(0)\n                                            .reverse()\n                                            .forEach(function (textShadow) {\n                                            _this.ctx.shadowColor = asString(textShadow.color);\n                                            _this.ctx.shadowOffsetX = textShadow.offsetX.number * _this.options.scale;\n                                            _this.ctx.shadowOffsetY = textShadow.offsetY.number * _this.options.scale;\n                                            _this.ctx.shadowBlur = textShadow.blur.number;\n                                            _this.renderTextWithLetterSpacing(text, styles.letterSpacing, baseline);\n                                        });\n                                        _this.ctx.shadowColor = '';\n                                        _this.ctx.shadowOffsetX = 0;\n                                        _this.ctx.shadowOffsetY = 0;\n                                        _this.ctx.shadowBlur = 0;\n                                    }\n                                    if (styles.textDecorationLine.length) {\n                                        _this.ctx.fillStyle = asString(styles.textDecorationColor || styles.color);\n                                        styles.textDecorationLine.forEach(function (textDecorationLine) {\n                                            switch (textDecorationLine) {\n                                                case 1 /* UNDERLINE */:\n                                                    // Draws a line at the baseline of the font\n                                                    // TODO As some browsers display the line as more than 1px if the font-size is big,\n                                                    // need to take that into account both in position and size\n                                                    _this.ctx.fillRect(text.bounds.left, Math.round(text.bounds.top + baseline), text.bounds.width, 1);\n                                                    break;\n                                                case 2 /* OVERLINE */:\n                                                    _this.ctx.fillRect(text.bounds.left, Math.round(text.bounds.top), text.bounds.width, 1);\n                                                    break;\n                                                case 3 /* LINE_THROUGH */:\n                                                    // TODO try and find exact position for line-through\n                                                    _this.ctx.fillRect(text.bounds.left, Math.ceil(text.bounds.top + middle), text.bounds.width, 1);\n                                                    break;\n                                            }\n                                        });\n                                    }\n                                    break;\n                                case 1 /* STROKE */:\n                                    if (styles.webkitTextStrokeWidth && text.text.trim().length) {\n                                        _this.ctx.strokeStyle = asString(styles.webkitTextStrokeColor);\n                                        _this.ctx.lineWidth = styles.webkitTextStrokeWidth;\n                                        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                                        _this.ctx.lineJoin = !!window.chrome ? 'miter' : 'round';\n                                        _this.ctx.strokeText(text.text, text.bounds.left, text.bounds.top + baseline);\n                                    }\n                                    _this.ctx.strokeStyle = '';\n                                    _this.ctx.lineWidth = 0;\n                                    _this.ctx.lineJoin = 'miter';\n                                    break;\n                            }\n                        });\n                    });\n                    return [2 /*return*/];\n                });\n            });\n        };\n        CanvasRenderer.prototype.renderReplacedElement = function (container, curves, image) {\n            if (image && container.intrinsicWidth > 0 && container.intrinsicHeight > 0) {\n                var box = contentBox(container);\n                var path = calculatePaddingBoxPath(curves);\n                this.path(path);\n                this.ctx.save();\n                this.ctx.clip();\n                this.ctx.drawImage(image, 0, 0, container.intrinsicWidth, container.intrinsicHeight, box.left, box.top, box.width, box.height);\n                this.ctx.restore();\n            }\n        };\n        CanvasRenderer.prototype.renderNodeContent = function (paint) {\n            return __awaiter(this, void 0, void 0, function () {\n                var container, curves, styles, _i, _a, child, image, image, iframeRenderer, canvas, size, _b, fontFamily, fontSize, baseline, bounds, x, textBounds, img, image, url, fontFamily, bounds;\n                return __generator(this, function (_c) {\n                    switch (_c.label) {\n                        case 0:\n                            this.applyEffects(paint.getEffects(4 /* CONTENT */));\n                            container = paint.container;\n                            curves = paint.curves;\n                            styles = container.styles;\n                            _i = 0, _a = container.textNodes;\n                            _c.label = 1;\n                        case 1:\n                            if (!(_i < _a.length)) return [3 /*break*/, 4];\n                            child = _a[_i];\n                            return [4 /*yield*/, this.renderTextNode(child, styles)];\n                        case 2:\n                            _c.sent();\n                            _c.label = 3;\n                        case 3:\n                            _i++;\n                            return [3 /*break*/, 1];\n                        case 4:\n                            if (!(container instanceof ImageElementContainer)) return [3 /*break*/, 8];\n                            _c.label = 5;\n                        case 5:\n                            _c.trys.push([5, 7, , 8]);\n                            return [4 /*yield*/, this.context.cache.match(container.src)];\n                        case 6:\n                            image = _c.sent();\n                            this.renderReplacedElement(container, curves, image);\n                            return [3 /*break*/, 8];\n                        case 7:\n                            _c.sent();\n                            this.context.logger.error(\"Error loading image \" + container.src);\n                            return [3 /*break*/, 8];\n                        case 8:\n                            if (container instanceof CanvasElementContainer) {\n                                this.renderReplacedElement(container, curves, container.canvas);\n                            }\n                            if (!(container instanceof SVGElementContainer)) return [3 /*break*/, 12];\n                            _c.label = 9;\n                        case 9:\n                            _c.trys.push([9, 11, , 12]);\n                            return [4 /*yield*/, this.context.cache.match(container.svg)];\n                        case 10:\n                            image = _c.sent();\n                            this.renderReplacedElement(container, curves, image);\n                            return [3 /*break*/, 12];\n                        case 11:\n                            _c.sent();\n                            this.context.logger.error(\"Error loading svg \" + container.svg.substring(0, 255));\n                            return [3 /*break*/, 12];\n                        case 12:\n                            if (!(container instanceof IFrameElementContainer && container.tree)) return [3 /*break*/, 14];\n                            iframeRenderer = new CanvasRenderer(this.context, {\n                                scale: this.options.scale,\n                                backgroundColor: container.backgroundColor,\n                                x: 0,\n                                y: 0,\n                                width: container.width,\n                                height: container.height\n                            });\n                            return [4 /*yield*/, iframeRenderer.render(container.tree)];\n                        case 13:\n                            canvas = _c.sent();\n                            if (container.width && container.height) {\n                                this.ctx.drawImage(canvas, 0, 0, container.width, container.height, container.bounds.left, container.bounds.top, container.bounds.width, container.bounds.height);\n                            }\n                            _c.label = 14;\n                        case 14:\n                            if (container instanceof InputElementContainer) {\n                                size = Math.min(container.bounds.width, container.bounds.height);\n                                if (container.type === CHECKBOX) {\n                                    if (container.checked) {\n                                        this.ctx.save();\n                                        this.path([\n                                            new Vector(container.bounds.left + size * 0.39363, container.bounds.top + size * 0.79),\n                                            new Vector(container.bounds.left + size * 0.16, container.bounds.top + size * 0.5549),\n                                            new Vector(container.bounds.left + size * 0.27347, container.bounds.top + size * 0.44071),\n                                            new Vector(container.bounds.left + size * 0.39694, container.bounds.top + size * 0.5649),\n                                            new Vector(container.bounds.left + size * 0.72983, container.bounds.top + size * 0.23),\n                                            new Vector(container.bounds.left + size * 0.84, container.bounds.top + size * 0.34085),\n                                            new Vector(container.bounds.left + size * 0.39363, container.bounds.top + size * 0.79)\n                                        ]);\n                                        this.ctx.fillStyle = asString(INPUT_COLOR);\n                                        this.ctx.fill();\n                                        this.ctx.restore();\n                                    }\n                                }\n                                else if (container.type === RADIO) {\n                                    if (container.checked) {\n                                        this.ctx.save();\n                                        this.ctx.beginPath();\n                                        this.ctx.arc(container.bounds.left + size / 2, container.bounds.top + size / 2, size / 4, 0, Math.PI * 2, true);\n                                        this.ctx.fillStyle = asString(INPUT_COLOR);\n                                        this.ctx.fill();\n                                        this.ctx.restore();\n                                    }\n                                }\n                            }\n                            if (isTextInputElement(container) && container.value.length) {\n                                _b = this.createFontStyle(styles), fontFamily = _b[0], fontSize = _b[1];\n                                baseline = this.fontMetrics.getMetrics(fontFamily, fontSize).baseline;\n                                this.ctx.font = fontFamily;\n                                this.ctx.fillStyle = asString(styles.color);\n                                this.ctx.textBaseline = 'alphabetic';\n                                this.ctx.textAlign = canvasTextAlign(container.styles.textAlign);\n                                bounds = contentBox(container);\n                                x = 0;\n                                switch (container.styles.textAlign) {\n                                    case 1 /* CENTER */:\n                                        x += bounds.width / 2;\n                                        break;\n                                    case 2 /* RIGHT */:\n                                        x += bounds.width;\n                                        break;\n                                }\n                                textBounds = bounds.add(x, 0, 0, -bounds.height / 2 + 1);\n                                this.ctx.save();\n                                this.path([\n                                    new Vector(bounds.left, bounds.top),\n                                    new Vector(bounds.left + bounds.width, bounds.top),\n                                    new Vector(bounds.left + bounds.width, bounds.top + bounds.height),\n                                    new Vector(bounds.left, bounds.top + bounds.height)\n                                ]);\n                                this.ctx.clip();\n                                this.renderTextWithLetterSpacing(new TextBounds(container.value, textBounds), styles.letterSpacing, baseline);\n                                this.ctx.restore();\n                                this.ctx.textBaseline = 'alphabetic';\n                                this.ctx.textAlign = 'left';\n                            }\n                            if (!contains(container.styles.display, 2048 /* LIST_ITEM */)) return [3 /*break*/, 20];\n                            if (!(container.styles.listStyleImage !== null)) return [3 /*break*/, 19];\n                            img = container.styles.listStyleImage;\n                            if (!(img.type === 0 /* URL */)) return [3 /*break*/, 18];\n                            image = void 0;\n                            url = img.url;\n                            _c.label = 15;\n                        case 15:\n                            _c.trys.push([15, 17, , 18]);\n                            return [4 /*yield*/, this.context.cache.match(url)];\n                        case 16:\n                            image = _c.sent();\n                            this.ctx.drawImage(image, container.bounds.left - (image.width + 10), container.bounds.top);\n                            return [3 /*break*/, 18];\n                        case 17:\n                            _c.sent();\n                            this.context.logger.error(\"Error loading list-style-image \" + url);\n                            return [3 /*break*/, 18];\n                        case 18: return [3 /*break*/, 20];\n                        case 19:\n                            if (paint.listValue && container.styles.listStyleType !== -1 /* NONE */) {\n                                fontFamily = this.createFontStyle(styles)[0];\n                                this.ctx.font = fontFamily;\n                                this.ctx.fillStyle = asString(styles.color);\n                                this.ctx.textBaseline = 'middle';\n                                this.ctx.textAlign = 'right';\n                                bounds = new Bounds(container.bounds.left, container.bounds.top + getAbsoluteValue(container.styles.paddingTop, container.bounds.width), container.bounds.width, computeLineHeight(styles.lineHeight, styles.fontSize.number) / 2 + 1);\n                                this.renderTextWithLetterSpacing(new TextBounds(paint.listValue, bounds), styles.letterSpacing, computeLineHeight(styles.lineHeight, styles.fontSize.number) / 2 + 2);\n                                this.ctx.textBaseline = 'bottom';\n                                this.ctx.textAlign = 'left';\n                            }\n                            _c.label = 20;\n                        case 20: return [2 /*return*/];\n                    }\n                });\n            });\n        };\n        CanvasRenderer.prototype.renderStackContent = function (stack) {\n            return __awaiter(this, void 0, void 0, function () {\n                var _i, _a, child, _b, _c, child, _d, _e, child, _f, _g, child, _h, _j, child, _k, _l, child, _m, _o, child;\n                return __generator(this, function (_p) {\n                    switch (_p.label) {\n                        case 0:\n                            if (contains(stack.element.container.flags, 16 /* DEBUG_RENDER */)) {\n                                debugger;\n                            }\n                            // https://www.w3.org/TR/css-position-3/#painting-order\n                            // 1. the background and borders of the element forming the stacking context.\n                            return [4 /*yield*/, this.renderNodeBackgroundAndBorders(stack.element)];\n                        case 1:\n                            // https://www.w3.org/TR/css-position-3/#painting-order\n                            // 1. the background and borders of the element forming the stacking context.\n                            _p.sent();\n                            _i = 0, _a = stack.negativeZIndex;\n                            _p.label = 2;\n                        case 2:\n                            if (!(_i < _a.length)) return [3 /*break*/, 5];\n                            child = _a[_i];\n                            return [4 /*yield*/, this.renderStack(child)];\n                        case 3:\n                            _p.sent();\n                            _p.label = 4;\n                        case 4:\n                            _i++;\n                            return [3 /*break*/, 2];\n                        case 5: \n                        // 3. For all its in-flow, non-positioned, block-level descendants in tree order:\n                        return [4 /*yield*/, this.renderNodeContent(stack.element)];\n                        case 6:\n                            // 3. For all its in-flow, non-positioned, block-level descendants in tree order:\n                            _p.sent();\n                            _b = 0, _c = stack.nonInlineLevel;\n                            _p.label = 7;\n                        case 7:\n                            if (!(_b < _c.length)) return [3 /*break*/, 10];\n                            child = _c[_b];\n                            return [4 /*yield*/, this.renderNode(child)];\n                        case 8:\n                            _p.sent();\n                            _p.label = 9;\n                        case 9:\n                            _b++;\n                            return [3 /*break*/, 7];\n                        case 10:\n                            _d = 0, _e = stack.nonPositionedFloats;\n                            _p.label = 11;\n                        case 11:\n                            if (!(_d < _e.length)) return [3 /*break*/, 14];\n                            child = _e[_d];\n                            return [4 /*yield*/, this.renderStack(child)];\n                        case 12:\n                            _p.sent();\n                            _p.label = 13;\n                        case 13:\n                            _d++;\n                            return [3 /*break*/, 11];\n                        case 14:\n                            _f = 0, _g = stack.nonPositionedInlineLevel;\n                            _p.label = 15;\n                        case 15:\n                            if (!(_f < _g.length)) return [3 /*break*/, 18];\n                            child = _g[_f];\n                            return [4 /*yield*/, this.renderStack(child)];\n                        case 16:\n                            _p.sent();\n                            _p.label = 17;\n                        case 17:\n                            _f++;\n                            return [3 /*break*/, 15];\n                        case 18:\n                            _h = 0, _j = stack.inlineLevel;\n                            _p.label = 19;\n                        case 19:\n                            if (!(_h < _j.length)) return [3 /*break*/, 22];\n                            child = _j[_h];\n                            return [4 /*yield*/, this.renderNode(child)];\n                        case 20:\n                            _p.sent();\n                            _p.label = 21;\n                        case 21:\n                            _h++;\n                            return [3 /*break*/, 19];\n                        case 22:\n                            _k = 0, _l = stack.zeroOrAutoZIndexOrTransformedOrOpacity;\n                            _p.label = 23;\n                        case 23:\n                            if (!(_k < _l.length)) return [3 /*break*/, 26];\n                            child = _l[_k];\n                            return [4 /*yield*/, this.renderStack(child)];\n                        case 24:\n                            _p.sent();\n                            _p.label = 25;\n                        case 25:\n                            _k++;\n                            return [3 /*break*/, 23];\n                        case 26:\n                            _m = 0, _o = stack.positiveZIndex;\n                            _p.label = 27;\n                        case 27:\n                            if (!(_m < _o.length)) return [3 /*break*/, 30];\n                            child = _o[_m];\n                            return [4 /*yield*/, this.renderStack(child)];\n                        case 28:\n                            _p.sent();\n                            _p.label = 29;\n                        case 29:\n                            _m++;\n                            return [3 /*break*/, 27];\n                        case 30: return [2 /*return*/];\n                    }\n                });\n            });\n        };\n        CanvasRenderer.prototype.mask = function (paths) {\n            this.ctx.beginPath();\n            this.ctx.moveTo(0, 0);\n            this.ctx.lineTo(this.canvas.width, 0);\n            this.ctx.lineTo(this.canvas.width, this.canvas.height);\n            this.ctx.lineTo(0, this.canvas.height);\n            this.ctx.lineTo(0, 0);\n            this.formatPath(paths.slice(0).reverse());\n            this.ctx.closePath();\n        };\n        CanvasRenderer.prototype.path = function (paths) {\n            this.ctx.beginPath();\n            this.formatPath(paths);\n            this.ctx.closePath();\n        };\n        CanvasRenderer.prototype.formatPath = function (paths) {\n            var _this = this;\n            paths.forEach(function (point, index) {\n                var start = isBezierCurve(point) ? point.start : point;\n                if (index === 0) {\n                    _this.ctx.moveTo(start.x, start.y);\n                }\n                else {\n                    _this.ctx.lineTo(start.x, start.y);\n                }\n                if (isBezierCurve(point)) {\n                    _this.ctx.bezierCurveTo(point.startControl.x, point.startControl.y, point.endControl.x, point.endControl.y, point.end.x, point.end.y);\n                }\n            });\n        };\n        CanvasRenderer.prototype.renderRepeat = function (path, pattern, offsetX, offsetY) {\n            this.path(path);\n            this.ctx.fillStyle = pattern;\n            this.ctx.translate(offsetX, offsetY);\n            this.ctx.fill();\n            this.ctx.translate(-offsetX, -offsetY);\n        };\n        CanvasRenderer.prototype.resizeImage = function (image, width, height) {\n            var _a;\n            if (image.width === width && image.height === height) {\n                return image;\n            }\n            var ownerDocument = (_a = this.canvas.ownerDocument) !== null && _a !== void 0 ? _a : document;\n            var canvas = ownerDocument.createElement('canvas');\n            canvas.width = Math.max(1, width);\n            canvas.height = Math.max(1, height);\n            var ctx = canvas.getContext('2d');\n            ctx.drawImage(image, 0, 0, image.width, image.height, 0, 0, width, height);\n            return canvas;\n        };\n        CanvasRenderer.prototype.renderBackgroundImage = function (container) {\n            return __awaiter(this, void 0, void 0, function () {\n                var index, _loop_1, this_1, _i, _a, backgroundImage;\n                return __generator(this, function (_b) {\n                    switch (_b.label) {\n                        case 0:\n                            index = container.styles.backgroundImage.length - 1;\n                            _loop_1 = function (backgroundImage) {\n                                var image, url, _c, path, x, y, width, height, pattern, _d, path, x, y, width, height, _e, lineLength, x0, x1, y0, y1, canvas, ctx, gradient_1, pattern, _f, path, left, top_1, width, height, position, x, y, _g, rx, ry, radialGradient_1, midX, midY, f, invF;\n                                return __generator(this, function (_h) {\n                                    switch (_h.label) {\n                                        case 0:\n                                            if (!(backgroundImage.type === 0 /* URL */)) return [3 /*break*/, 5];\n                                            image = void 0;\n                                            url = backgroundImage.url;\n                                            _h.label = 1;\n                                        case 1:\n                                            _h.trys.push([1, 3, , 4]);\n                                            return [4 /*yield*/, this_1.context.cache.match(url)];\n                                        case 2:\n                                            image = _h.sent();\n                                            return [3 /*break*/, 4];\n                                        case 3:\n                                            _h.sent();\n                                            this_1.context.logger.error(\"Error loading background-image \" + url);\n                                            return [3 /*break*/, 4];\n                                        case 4:\n                                            if (image) {\n                                                _c = calculateBackgroundRendering(container, index, [\n                                                    image.width,\n                                                    image.height,\n                                                    image.width / image.height\n                                                ]), path = _c[0], x = _c[1], y = _c[2], width = _c[3], height = _c[4];\n                                                pattern = this_1.ctx.createPattern(this_1.resizeImage(image, width, height), 'repeat');\n                                                this_1.renderRepeat(path, pattern, x, y);\n                                            }\n                                            return [3 /*break*/, 6];\n                                        case 5:\n                                            if (isLinearGradient(backgroundImage)) {\n                                                _d = calculateBackgroundRendering(container, index, [null, null, null]), path = _d[0], x = _d[1], y = _d[2], width = _d[3], height = _d[4];\n                                                _e = calculateGradientDirection(backgroundImage.angle, width, height), lineLength = _e[0], x0 = _e[1], x1 = _e[2], y0 = _e[3], y1 = _e[4];\n                                                canvas = document.createElement('canvas');\n                                                canvas.width = width;\n                                                canvas.height = height;\n                                                ctx = canvas.getContext('2d');\n                                                gradient_1 = ctx.createLinearGradient(x0, y0, x1, y1);\n                                                processColorStops(backgroundImage.stops, lineLength).forEach(function (colorStop) {\n                                                    return gradient_1.addColorStop(colorStop.stop, asString(colorStop.color));\n                                                });\n                                                ctx.fillStyle = gradient_1;\n                                                ctx.fillRect(0, 0, width, height);\n                                                if (width > 0 && height > 0) {\n                                                    pattern = this_1.ctx.createPattern(canvas, 'repeat');\n                                                    this_1.renderRepeat(path, pattern, x, y);\n                                                }\n                                            }\n                                            else if (isRadialGradient(backgroundImage)) {\n                                                _f = calculateBackgroundRendering(container, index, [\n                                                    null,\n                                                    null,\n                                                    null\n                                                ]), path = _f[0], left = _f[1], top_1 = _f[2], width = _f[3], height = _f[4];\n                                                position = backgroundImage.position.length === 0 ? [FIFTY_PERCENT] : backgroundImage.position;\n                                                x = getAbsoluteValue(position[0], width);\n                                                y = getAbsoluteValue(position[position.length - 1], height);\n                                                _g = calculateRadius(backgroundImage, x, y, width, height), rx = _g[0], ry = _g[1];\n                                                if (rx > 0 && ry > 0) {\n                                                    radialGradient_1 = this_1.ctx.createRadialGradient(left + x, top_1 + y, 0, left + x, top_1 + y, rx);\n                                                    processColorStops(backgroundImage.stops, rx * 2).forEach(function (colorStop) {\n                                                        return radialGradient_1.addColorStop(colorStop.stop, asString(colorStop.color));\n                                                    });\n                                                    this_1.path(path);\n                                                    this_1.ctx.fillStyle = radialGradient_1;\n                                                    if (rx !== ry) {\n                                                        midX = container.bounds.left + 0.5 * container.bounds.width;\n                                                        midY = container.bounds.top + 0.5 * container.bounds.height;\n                                                        f = ry / rx;\n                                                        invF = 1 / f;\n                                                        this_1.ctx.save();\n                                                        this_1.ctx.translate(midX, midY);\n                                                        this_1.ctx.transform(1, 0, 0, f, 0, 0);\n                                                        this_1.ctx.translate(-midX, -midY);\n                                                        this_1.ctx.fillRect(left, invF * (top_1 - midY) + midY, width, height * invF);\n                                                        this_1.ctx.restore();\n                                                    }\n                                                    else {\n                                                        this_1.ctx.fill();\n                                                    }\n                                                }\n                                            }\n                                            _h.label = 6;\n                                        case 6:\n                                            index--;\n                                            return [2 /*return*/];\n                                    }\n                                });\n                            };\n                            this_1 = this;\n                            _i = 0, _a = container.styles.backgroundImage.slice(0).reverse();\n                            _b.label = 1;\n                        case 1:\n                            if (!(_i < _a.length)) return [3 /*break*/, 4];\n                            backgroundImage = _a[_i];\n                            return [5 /*yield**/, _loop_1(backgroundImage)];\n                        case 2:\n                            _b.sent();\n                            _b.label = 3;\n                        case 3:\n                            _i++;\n                            return [3 /*break*/, 1];\n                        case 4: return [2 /*return*/];\n                    }\n                });\n            });\n        };\n        CanvasRenderer.prototype.renderSolidBorder = function (color, side, curvePoints) {\n            return __awaiter(this, void 0, void 0, function () {\n                return __generator(this, function (_a) {\n                    this.path(parsePathForBorder(curvePoints, side));\n                    this.ctx.fillStyle = asString(color);\n                    this.ctx.fill();\n                    return [2 /*return*/];\n                });\n            });\n        };\n        CanvasRenderer.prototype.renderDoubleBorder = function (color, width, side, curvePoints) {\n            return __awaiter(this, void 0, void 0, function () {\n                var outerPaths, innerPaths;\n                return __generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0:\n                            if (!(width < 3)) return [3 /*break*/, 2];\n                            return [4 /*yield*/, this.renderSolidBorder(color, side, curvePoints)];\n                        case 1:\n                            _a.sent();\n                            return [2 /*return*/];\n                        case 2:\n                            outerPaths = parsePathForBorderDoubleOuter(curvePoints, side);\n                            this.path(outerPaths);\n                            this.ctx.fillStyle = asString(color);\n                            this.ctx.fill();\n                            innerPaths = parsePathForBorderDoubleInner(curvePoints, side);\n                            this.path(innerPaths);\n                            this.ctx.fill();\n                            return [2 /*return*/];\n                    }\n                });\n            });\n        };\n        CanvasRenderer.prototype.renderNodeBackgroundAndBorders = function (paint) {\n            return __awaiter(this, void 0, void 0, function () {\n                var styles, hasBackground, borders, backgroundPaintingArea, side, _i, borders_1, border;\n                var _this = this;\n                return __generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0:\n                            this.applyEffects(paint.getEffects(2 /* BACKGROUND_BORDERS */));\n                            styles = paint.container.styles;\n                            hasBackground = !isTransparent(styles.backgroundColor) || styles.backgroundImage.length;\n                            borders = [\n                                { style: styles.borderTopStyle, color: styles.borderTopColor, width: styles.borderTopWidth },\n                                { style: styles.borderRightStyle, color: styles.borderRightColor, width: styles.borderRightWidth },\n                                { style: styles.borderBottomStyle, color: styles.borderBottomColor, width: styles.borderBottomWidth },\n                                { style: styles.borderLeftStyle, color: styles.borderLeftColor, width: styles.borderLeftWidth }\n                            ];\n                            backgroundPaintingArea = calculateBackgroundCurvedPaintingArea(getBackgroundValueForIndex(styles.backgroundClip, 0), paint.curves);\n                            if (!(hasBackground || styles.boxShadow.length)) return [3 /*break*/, 2];\n                            this.ctx.save();\n                            this.path(backgroundPaintingArea);\n                            this.ctx.clip();\n                            if (!isTransparent(styles.backgroundColor)) {\n                                this.ctx.fillStyle = asString(styles.backgroundColor);\n                                this.ctx.fill();\n                            }\n                            return [4 /*yield*/, this.renderBackgroundImage(paint.container)];\n                        case 1:\n                            _a.sent();\n                            this.ctx.restore();\n                            styles.boxShadow\n                                .slice(0)\n                                .reverse()\n                                .forEach(function (shadow) {\n                                _this.ctx.save();\n                                var borderBoxArea = calculateBorderBoxPath(paint.curves);\n                                var maskOffset = shadow.inset ? 0 : MASK_OFFSET;\n                                var shadowPaintingArea = transformPath(borderBoxArea, -maskOffset + (shadow.inset ? 1 : -1) * shadow.spread.number, (shadow.inset ? 1 : -1) * shadow.spread.number, shadow.spread.number * (shadow.inset ? -2 : 2), shadow.spread.number * (shadow.inset ? -2 : 2));\n                                if (shadow.inset) {\n                                    _this.path(borderBoxArea);\n                                    _this.ctx.clip();\n                                    _this.mask(shadowPaintingArea);\n                                }\n                                else {\n                                    _this.mask(borderBoxArea);\n                                    _this.ctx.clip();\n                                    _this.path(shadowPaintingArea);\n                                }\n                                _this.ctx.shadowOffsetX = shadow.offsetX.number + maskOffset;\n                                _this.ctx.shadowOffsetY = shadow.offsetY.number;\n                                _this.ctx.shadowColor = asString(shadow.color);\n                                _this.ctx.shadowBlur = shadow.blur.number;\n                                _this.ctx.fillStyle = shadow.inset ? asString(shadow.color) : 'rgba(0,0,0,1)';\n                                _this.ctx.fill();\n                                _this.ctx.restore();\n                            });\n                            _a.label = 2;\n                        case 2:\n                            side = 0;\n                            _i = 0, borders_1 = borders;\n                            _a.label = 3;\n                        case 3:\n                            if (!(_i < borders_1.length)) return [3 /*break*/, 13];\n                            border = borders_1[_i];\n                            if (!(border.style !== 0 /* NONE */ && !isTransparent(border.color) && border.width > 0)) return [3 /*break*/, 11];\n                            if (!(border.style === 2 /* DASHED */)) return [3 /*break*/, 5];\n                            return [4 /*yield*/, this.renderDashedDottedBorder(border.color, border.width, side, paint.curves, 2 /* DASHED */)];\n                        case 4:\n                            _a.sent();\n                            return [3 /*break*/, 11];\n                        case 5:\n                            if (!(border.style === 3 /* DOTTED */)) return [3 /*break*/, 7];\n                            return [4 /*yield*/, this.renderDashedDottedBorder(border.color, border.width, side, paint.curves, 3 /* DOTTED */)];\n                        case 6:\n                            _a.sent();\n                            return [3 /*break*/, 11];\n                        case 7:\n                            if (!(border.style === 4 /* DOUBLE */)) return [3 /*break*/, 9];\n                            return [4 /*yield*/, this.renderDoubleBorder(border.color, border.width, side, paint.curves)];\n                        case 8:\n                            _a.sent();\n                            return [3 /*break*/, 11];\n                        case 9: return [4 /*yield*/, this.renderSolidBorder(border.color, side, paint.curves)];\n                        case 10:\n                            _a.sent();\n                            _a.label = 11;\n                        case 11:\n                            side++;\n                            _a.label = 12;\n                        case 12:\n                            _i++;\n                            return [3 /*break*/, 3];\n                        case 13: return [2 /*return*/];\n                    }\n                });\n            });\n        };\n        CanvasRenderer.prototype.renderDashedDottedBorder = function (color, width, side, curvePoints, style) {\n            return __awaiter(this, void 0, void 0, function () {\n                var strokePaths, boxPaths, startX, startY, endX, endY, length, dashLength, spaceLength, useLineDash, multiplier, numberOfDashes, minSpace, maxSpace, path1, path2, path1, path2;\n                return __generator(this, function (_a) {\n                    this.ctx.save();\n                    strokePaths = parsePathForBorderStroke(curvePoints, side);\n                    boxPaths = parsePathForBorder(curvePoints, side);\n                    if (style === 2 /* DASHED */) {\n                        this.path(boxPaths);\n                        this.ctx.clip();\n                    }\n                    if (isBezierCurve(boxPaths[0])) {\n                        startX = boxPaths[0].start.x;\n                        startY = boxPaths[0].start.y;\n                    }\n                    else {\n                        startX = boxPaths[0].x;\n                        startY = boxPaths[0].y;\n                    }\n                    if (isBezierCurve(boxPaths[1])) {\n                        endX = boxPaths[1].end.x;\n                        endY = boxPaths[1].end.y;\n                    }\n                    else {\n                        endX = boxPaths[1].x;\n                        endY = boxPaths[1].y;\n                    }\n                    if (side === 0 || side === 2) {\n                        length = Math.abs(startX - endX);\n                    }\n                    else {\n                        length = Math.abs(startY - endY);\n                    }\n                    this.ctx.beginPath();\n                    if (style === 3 /* DOTTED */) {\n                        this.formatPath(strokePaths);\n                    }\n                    else {\n                        this.formatPath(boxPaths.slice(0, 2));\n                    }\n                    dashLength = width < 3 ? width * 3 : width * 2;\n                    spaceLength = width < 3 ? width * 2 : width;\n                    if (style === 3 /* DOTTED */) {\n                        dashLength = width;\n                        spaceLength = width;\n                    }\n                    useLineDash = true;\n                    if (length <= dashLength * 2) {\n                        useLineDash = false;\n                    }\n                    else if (length <= dashLength * 2 + spaceLength) {\n                        multiplier = length / (2 * dashLength + spaceLength);\n                        dashLength *= multiplier;\n                        spaceLength *= multiplier;\n                    }\n                    else {\n                        numberOfDashes = Math.floor((length + spaceLength) / (dashLength + spaceLength));\n                        minSpace = (length - numberOfDashes * dashLength) / (numberOfDashes - 1);\n                        maxSpace = (length - (numberOfDashes + 1) * dashLength) / numberOfDashes;\n                        spaceLength =\n                            maxSpace <= 0 || Math.abs(spaceLength - minSpace) < Math.abs(spaceLength - maxSpace)\n                                ? minSpace\n                                : maxSpace;\n                    }\n                    if (useLineDash) {\n                        if (style === 3 /* DOTTED */) {\n                            this.ctx.setLineDash([0, dashLength + spaceLength]);\n                        }\n                        else {\n                            this.ctx.setLineDash([dashLength, spaceLength]);\n                        }\n                    }\n                    if (style === 3 /* DOTTED */) {\n                        this.ctx.lineCap = 'round';\n                        this.ctx.lineWidth = width;\n                    }\n                    else {\n                        this.ctx.lineWidth = width * 2 + 1.1;\n                    }\n                    this.ctx.strokeStyle = asString(color);\n                    this.ctx.stroke();\n                    this.ctx.setLineDash([]);\n                    // dashed round edge gap\n                    if (style === 2 /* DASHED */) {\n                        if (isBezierCurve(boxPaths[0])) {\n                            path1 = boxPaths[3];\n                            path2 = boxPaths[0];\n                            this.ctx.beginPath();\n                            this.formatPath([new Vector(path1.end.x, path1.end.y), new Vector(path2.start.x, path2.start.y)]);\n                            this.ctx.stroke();\n                        }\n                        if (isBezierCurve(boxPaths[1])) {\n                            path1 = boxPaths[1];\n                            path2 = boxPaths[2];\n                            this.ctx.beginPath();\n                            this.formatPath([new Vector(path1.end.x, path1.end.y), new Vector(path2.start.x, path2.start.y)]);\n                            this.ctx.stroke();\n                        }\n                    }\n                    this.ctx.restore();\n                    return [2 /*return*/];\n                });\n            });\n        };\n        CanvasRenderer.prototype.render = function (element) {\n            return __awaiter(this, void 0, void 0, function () {\n                var stack;\n                return __generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0:\n                            if (this.options.backgroundColor) {\n                                this.ctx.fillStyle = asString(this.options.backgroundColor);\n                                this.ctx.fillRect(this.options.x, this.options.y, this.options.width, this.options.height);\n                            }\n                            stack = parseStackingContexts(element);\n                            return [4 /*yield*/, this.renderStack(stack)];\n                        case 1:\n                            _a.sent();\n                            this.applyEffects([]);\n                            return [2 /*return*/, this.canvas];\n                    }\n                });\n            });\n        };\n        return CanvasRenderer;\n    }(Renderer));\n    var isTextInputElement = function (container) {\n        if (container instanceof TextareaElementContainer) {\n            return true;\n        }\n        else if (container instanceof SelectElementContainer) {\n            return true;\n        }\n        else if (container instanceof InputElementContainer && container.type !== RADIO && container.type !== CHECKBOX) {\n            return true;\n        }\n        return false;\n    };\n    var calculateBackgroundCurvedPaintingArea = function (clip, curves) {\n        switch (clip) {\n            case 0 /* BORDER_BOX */:\n                return calculateBorderBoxPath(curves);\n            case 2 /* CONTENT_BOX */:\n                return calculateContentBoxPath(curves);\n            case 1 /* PADDING_BOX */:\n            default:\n                return calculatePaddingBoxPath(curves);\n        }\n    };\n    var canvasTextAlign = function (textAlign) {\n        switch (textAlign) {\n            case 1 /* CENTER */:\n                return 'center';\n            case 2 /* RIGHT */:\n                return 'right';\n            case 0 /* LEFT */:\n            default:\n                return 'left';\n        }\n    };\n    // see https://github.com/niklasvh/html2canvas/pull/2645\n    var iOSBrokenFonts = ['-apple-system', 'system-ui'];\n    var fixIOSSystemFonts = function (fontFamilies) {\n        return /iPhone OS 15_(0|1)/.test(window.navigator.userAgent)\n            ? fontFamilies.filter(function (fontFamily) { return iOSBrokenFonts.indexOf(fontFamily) === -1; })\n            : fontFamilies;\n    };\n\n    var ForeignObjectRenderer = /** @class */ (function (_super) {\n        __extends(ForeignObjectRenderer, _super);\n        function ForeignObjectRenderer(context, options) {\n            var _this = _super.call(this, context, options) || this;\n            _this.canvas = options.canvas ? options.canvas : document.createElement('canvas');\n            _this.ctx = _this.canvas.getContext('2d');\n            _this.options = options;\n            _this.canvas.width = Math.floor(options.width * options.scale);\n            _this.canvas.height = Math.floor(options.height * options.scale);\n            _this.canvas.style.width = options.width + \"px\";\n            _this.canvas.style.height = options.height + \"px\";\n            _this.ctx.scale(_this.options.scale, _this.options.scale);\n            _this.ctx.translate(-options.x, -options.y);\n            _this.context.logger.debug(\"EXPERIMENTAL ForeignObject renderer initialized (\" + options.width + \"x\" + options.height + \" at \" + options.x + \",\" + options.y + \") with scale \" + options.scale);\n            return _this;\n        }\n        ForeignObjectRenderer.prototype.render = function (element) {\n            return __awaiter(this, void 0, void 0, function () {\n                var svg, img;\n                return __generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0:\n                            svg = createForeignObjectSVG(this.options.width * this.options.scale, this.options.height * this.options.scale, this.options.scale, this.options.scale, element);\n                            return [4 /*yield*/, loadSerializedSVG(svg)];\n                        case 1:\n                            img = _a.sent();\n                            if (this.options.backgroundColor) {\n                                this.ctx.fillStyle = asString(this.options.backgroundColor);\n                                this.ctx.fillRect(0, 0, this.options.width * this.options.scale, this.options.height * this.options.scale);\n                            }\n                            this.ctx.drawImage(img, -this.options.x * this.options.scale, -this.options.y * this.options.scale);\n                            return [2 /*return*/, this.canvas];\n                    }\n                });\n            });\n        };\n        return ForeignObjectRenderer;\n    }(Renderer));\n    var loadSerializedSVG = function (svg) {\n        return new Promise(function (resolve, reject) {\n            var img = new Image();\n            img.onload = function () {\n                resolve(img);\n            };\n            img.onerror = reject;\n            img.src = \"data:image/svg+xml;charset=utf-8,\" + encodeURIComponent(new XMLSerializer().serializeToString(svg));\n        });\n    };\n\n    var Logger = /** @class */ (function () {\n        function Logger(_a) {\n            var id = _a.id, enabled = _a.enabled;\n            this.id = id;\n            this.enabled = enabled;\n            this.start = Date.now();\n        }\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Logger.prototype.debug = function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            if (this.enabled) {\n                // eslint-disable-next-line no-console\n                if (typeof window !== 'undefined' && window.console && typeof console.debug === 'function') {\n                    // eslint-disable-next-line no-console\n                    console.debug.apply(console, __spreadArray([this.id, this.getTime() + \"ms\"], args));\n                }\n                else {\n                    this.info.apply(this, args);\n                }\n            }\n        };\n        Logger.prototype.getTime = function () {\n            return Date.now() - this.start;\n        };\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Logger.prototype.info = function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            if (this.enabled) {\n                // eslint-disable-next-line no-console\n                if (typeof window !== 'undefined' && window.console && typeof console.info === 'function') {\n                    // eslint-disable-next-line no-console\n                    console.info.apply(console, __spreadArray([this.id, this.getTime() + \"ms\"], args));\n                }\n            }\n        };\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Logger.prototype.warn = function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            if (this.enabled) {\n                // eslint-disable-next-line no-console\n                if (typeof window !== 'undefined' && window.console && typeof console.warn === 'function') {\n                    // eslint-disable-next-line no-console\n                    console.warn.apply(console, __spreadArray([this.id, this.getTime() + \"ms\"], args));\n                }\n                else {\n                    this.info.apply(this, args);\n                }\n            }\n        };\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Logger.prototype.error = function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            if (this.enabled) {\n                // eslint-disable-next-line no-console\n                if (typeof window !== 'undefined' && window.console && typeof console.error === 'function') {\n                    // eslint-disable-next-line no-console\n                    console.error.apply(console, __spreadArray([this.id, this.getTime() + \"ms\"], args));\n                }\n                else {\n                    this.info.apply(this, args);\n                }\n            }\n        };\n        Logger.instances = {};\n        return Logger;\n    }());\n\n    var Context = /** @class */ (function () {\n        function Context(options, windowBounds) {\n            var _a;\n            this.windowBounds = windowBounds;\n            this.instanceName = \"#\" + Context.instanceCount++;\n            this.logger = new Logger({ id: this.instanceName, enabled: options.logging });\n            this.cache = (_a = options.cache) !== null && _a !== void 0 ? _a : new Cache(this, options);\n        }\n        Context.instanceCount = 1;\n        return Context;\n    }());\n\n    var html2canvas = function (element, options) {\n        if (options === void 0) { options = {}; }\n        return renderElement(element, options);\n    };\n    if (typeof window !== 'undefined') {\n        CacheStorage.setContext(window);\n    }\n    var renderElement = function (element, opts) { return __awaiter(void 0, void 0, void 0, function () {\n        var ownerDocument, defaultView, resourceOptions, contextOptions, windowOptions, windowBounds, context, foreignObjectRendering, cloneOptions, documentCloner, clonedElement, container, _a, width, height, left, top, backgroundColor, renderOptions, canvas, renderer, root, renderer;\n        var _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;\n        return __generator(this, function (_u) {\n            switch (_u.label) {\n                case 0:\n                    if (!element || typeof element !== 'object') {\n                        return [2 /*return*/, Promise.reject('Invalid element provided as first argument')];\n                    }\n                    ownerDocument = element.ownerDocument;\n                    if (!ownerDocument) {\n                        throw new Error(\"Element is not attached to a Document\");\n                    }\n                    defaultView = ownerDocument.defaultView;\n                    if (!defaultView) {\n                        throw new Error(\"Document is not attached to a Window\");\n                    }\n                    resourceOptions = {\n                        allowTaint: (_b = opts.allowTaint) !== null && _b !== void 0 ? _b : false,\n                        imageTimeout: (_c = opts.imageTimeout) !== null && _c !== void 0 ? _c : 15000,\n                        proxy: opts.proxy,\n                        useCORS: (_d = opts.useCORS) !== null && _d !== void 0 ? _d : false\n                    };\n                    contextOptions = __assign({ logging: (_e = opts.logging) !== null && _e !== void 0 ? _e : true, cache: opts.cache }, resourceOptions);\n                    windowOptions = {\n                        windowWidth: (_f = opts.windowWidth) !== null && _f !== void 0 ? _f : defaultView.innerWidth,\n                        windowHeight: (_g = opts.windowHeight) !== null && _g !== void 0 ? _g : defaultView.innerHeight,\n                        scrollX: (_h = opts.scrollX) !== null && _h !== void 0 ? _h : defaultView.pageXOffset,\n                        scrollY: (_j = opts.scrollY) !== null && _j !== void 0 ? _j : defaultView.pageYOffset\n                    };\n                    windowBounds = new Bounds(windowOptions.scrollX, windowOptions.scrollY, windowOptions.windowWidth, windowOptions.windowHeight);\n                    context = new Context(contextOptions, windowBounds);\n                    foreignObjectRendering = (_k = opts.foreignObjectRendering) !== null && _k !== void 0 ? _k : false;\n                    cloneOptions = {\n                        allowTaint: (_l = opts.allowTaint) !== null && _l !== void 0 ? _l : false,\n                        onclone: opts.onclone,\n                        ignoreElements: opts.ignoreElements,\n                        inlineImages: foreignObjectRendering,\n                        copyStyles: foreignObjectRendering\n                    };\n                    context.logger.debug(\"Starting document clone with size \" + windowBounds.width + \"x\" + windowBounds.height + \" scrolled to \" + -windowBounds.left + \",\" + -windowBounds.top);\n                    documentCloner = new DocumentCloner(context, element, cloneOptions);\n                    clonedElement = documentCloner.clonedReferenceElement;\n                    if (!clonedElement) {\n                        return [2 /*return*/, Promise.reject(\"Unable to find element in cloned iframe\")];\n                    }\n                    return [4 /*yield*/, documentCloner.toIFrame(ownerDocument, windowBounds)];\n                case 1:\n                    container = _u.sent();\n                    _a = isBodyElement(clonedElement) || isHTMLElement(clonedElement)\n                        ? parseDocumentSize(clonedElement.ownerDocument)\n                        : parseBounds(context, clonedElement), width = _a.width, height = _a.height, left = _a.left, top = _a.top;\n                    backgroundColor = parseBackgroundColor(context, clonedElement, opts.backgroundColor);\n                    renderOptions = {\n                        canvas: opts.canvas,\n                        backgroundColor: backgroundColor,\n                        scale: (_o = (_m = opts.scale) !== null && _m !== void 0 ? _m : defaultView.devicePixelRatio) !== null && _o !== void 0 ? _o : 1,\n                        x: ((_p = opts.x) !== null && _p !== void 0 ? _p : 0) + left,\n                        y: ((_q = opts.y) !== null && _q !== void 0 ? _q : 0) + top,\n                        width: (_r = opts.width) !== null && _r !== void 0 ? _r : Math.ceil(width),\n                        height: (_s = opts.height) !== null && _s !== void 0 ? _s : Math.ceil(height)\n                    };\n                    if (!foreignObjectRendering) return [3 /*break*/, 3];\n                    context.logger.debug(\"Document cloned, using foreign object rendering\");\n                    renderer = new ForeignObjectRenderer(context, renderOptions);\n                    return [4 /*yield*/, renderer.render(clonedElement)];\n                case 2:\n                    canvas = _u.sent();\n                    return [3 /*break*/, 5];\n                case 3:\n                    context.logger.debug(\"Document cloned, element located at \" + left + \",\" + top + \" with size \" + width + \"x\" + height + \" using computed rendering\");\n                    context.logger.debug(\"Starting DOM parsing\");\n                    root = parseTree(context, clonedElement);\n                    if (backgroundColor === root.styles.backgroundColor) {\n                        root.styles.backgroundColor = COLORS.TRANSPARENT;\n                    }\n                    context.logger.debug(\"Starting renderer for element at \" + renderOptions.x + \",\" + renderOptions.y + \" with size \" + renderOptions.width + \"x\" + renderOptions.height);\n                    renderer = new CanvasRenderer(context, renderOptions);\n                    return [4 /*yield*/, renderer.render(root)];\n                case 4:\n                    canvas = _u.sent();\n                    _u.label = 5;\n                case 5:\n                    if ((_t = opts.removeContainer) !== null && _t !== void 0 ? _t : true) {\n                        if (!DocumentCloner.destroy(container)) {\n                            context.logger.error(\"Cannot detach cloned iframe as it is not in the DOM anymore\");\n                        }\n                    }\n                    context.logger.debug(\"Finished rendering\");\n                    return [2 /*return*/, canvas];\n            }\n        });\n    }); };\n    var parseBackgroundColor = function (context, element, backgroundColorOverride) {\n        var ownerDocument = element.ownerDocument;\n        // http://www.w3.org/TR/css3-background/#special-backgrounds\n        var documentBackgroundColor = ownerDocument.documentElement\n            ? parseColor(context, getComputedStyle(ownerDocument.documentElement).backgroundColor)\n            : COLORS.TRANSPARENT;\n        var bodyBackgroundColor = ownerDocument.body\n            ? parseColor(context, getComputedStyle(ownerDocument.body).backgroundColor)\n            : COLORS.TRANSPARENT;\n        var defaultBackgroundColor = typeof backgroundColorOverride === 'string'\n            ? parseColor(context, backgroundColorOverride)\n            : backgroundColorOverride === null\n                ? COLORS.TRANSPARENT\n                : 0xffffffff;\n        return element === ownerDocument.documentElement\n            ? isTransparent(documentBackgroundColor)\n                ? isTransparent(bodyBackgroundColor)\n                    ? defaultBackgroundColor\n                    : bodyBackgroundColor\n                : documentBackgroundColor\n            : defaultBackgroundColor;\n    };\n\n    return html2canvas;\n\n})));\n//# sourceMappingURL=html2canvas.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9odG1sMmNhbnZhcy9kaXN0L2h0bWwyY2FudmFzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksS0FBNEQ7QUFDaEUsSUFBSSxDQUMwRztBQUM5RyxDQUFDLHNCQUFzQjs7QUFFdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUN2Riw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxPQUFPO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQywrREFBK0QsaUJBQWlCO0FBQ2hIO0FBQ0Esd0NBQXdDLE1BQU0sK0JBQStCLFlBQVk7QUFDekYsdUNBQXVDLE1BQU0sbUNBQW1DLFlBQVk7QUFDNUYsb0NBQW9DO0FBQ3BDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw2QkFBNkIsMEJBQTBCLGNBQWMscUJBQXFCO0FBQzVHLHFCQUFxQixvREFBb0QscUVBQXFFLGNBQWM7QUFDNUosMkJBQTJCLHNCQUFzQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUMsdUNBQXVDLFNBQVM7QUFDaEQsdUNBQXVDLFdBQVcsVUFBVTtBQUM1RCw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLGtIQUFrSCxPQUFPO0FBQ3pILHFGQUFxRixpQkFBaUI7QUFDdEcsNkRBQTZELGdCQUFnQixRQUFRO0FBQ3JGLG1EQUFtRCxnQkFBZ0IsZ0JBQWdCO0FBQ25GO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQSxjQUFjLFlBQVksYUFBYSxTQUFTLFVBQVU7QUFDMUQsd0NBQXdDLFNBQVM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUYsT0FBTztBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLDBCQUEwQjtBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix1QkFBdUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0JBQXNCO0FBQzVDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwwQkFBMEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0JBQXNCO0FBQzVDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixrQkFBa0I7QUFDbEIsa0JBQWtCO0FBQ2xCLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCLG9CQUFvQjtBQUNwQjtBQUNBLGlCQUFpQjtBQUNqQixpQkFBaUI7QUFDakIsaUJBQWlCO0FBQ2pCLGlCQUFpQjtBQUNqQixpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUI7QUFDakIsaUJBQWlCO0FBQ2pCLGlCQUFpQjtBQUNqQixpQkFBaUI7QUFDakIsaUJBQWlCO0FBQ2pCLGlCQUFpQjtBQUNqQixpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUI7QUFDakIsaUJBQWlCO0FBQ2pCLGlCQUFpQjtBQUNqQixpQkFBaUI7QUFDakIsaUJBQWlCLDRCQUE0QjtBQUM3QztBQUNBLGlCQUFpQiwyQ0FBMkMsV0FBVztBQUN2RSxpQkFBaUI7QUFDakIsaUJBQWlCO0FBQ2pCLGlCQUFpQjtBQUNqQixpQkFBaUI7QUFDakIsaUJBQWlCO0FBQ2pCLGlCQUFpQjtBQUNqQixpQkFBaUIsNENBQTRDO0FBQzdELGlCQUFpQiwyQkFBMkI7QUFDNUMsaUJBQWlCO0FBQ2pCLGlCQUFpQjtBQUNqQixpQkFBaUI7QUFDakIsbUJBQW1CLG9DQUFvQztBQUN2RCxpQkFBaUI7QUFDakIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsMERBQTBELHlEQUF5RDtBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EseUJBQXlCO0FBQ3pCLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQsbURBQW1EO0FBQ25ELDBDQUEwQztBQUMxQyxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsK0JBQStCO0FBQy9CLCtCQUErQjtBQUMvQix5QkFBeUI7QUFDekIsNkJBQTZCO0FBQzdCLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEMsMEJBQTBCO0FBQzFCLDZCQUE2QjtBQUM3QixzQkFBc0I7QUFDdEIsc0JBQXNCO0FBQ3RCLHdCQUF3QjtBQUN4Qiw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtR0FBbUcsa0RBQWtEO0FBQ3JKLCtGQUErRiwrQ0FBK0M7QUFDOUkseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsOENBQThDO0FBQzlDLDJDQUEyQztBQUMzQywwQ0FBMEM7QUFDMUMsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxxQkFBcUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsMkJBQTJCLElBQUk7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssZ0NBQWdDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsc0JBQXNCO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzQkFBc0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix1QkFBdUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSx5QkFBeUI7QUFDekIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEU7QUFDNUU7QUFDQSxvRUFBb0UsNEJBQTRCO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0EsMENBQTBDO0FBQzFDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSxjQUFjO0FBQ3BGO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSx1RUFBdUUsY0FBYztBQUNyRjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EscUVBQXFFLGNBQWM7QUFDbkY7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0UsY0FBYztBQUM3RjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EscUVBQXFFLGNBQWM7QUFDbkY7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHVFQUF1RSxjQUFjO0FBQ3JGO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxrRUFBa0UsY0FBYztBQUNoRjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxrRkFBa0YsY0FBYztBQUNoRztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQseUJBQXlCO0FBQ2xGO0FBQ0EsaUZBQWlGLHlCQUF5QjtBQUMxRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsaUZBQWlGLHlCQUF5QjtBQUMxRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsaUVBQWlFLFdBQVc7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLHlEQUF5RDtBQUN0STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRCx1Q0FBdUM7QUFDdkMsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4Qyx3Q0FBd0M7QUFDeEMsMkNBQTJDO0FBQzNDLDBDQUEwQztBQUMxQyx5Q0FBeUM7QUFDekMsMENBQTBDO0FBQzFDLDRDQUE0QztBQUM1QywyQ0FBMkM7QUFDM0MsMkNBQTJDO0FBQzNDLDRDQUE0QztBQUM1QywyQ0FBMkM7QUFDM0MsNENBQTRDO0FBQzVDLDhDQUE4QztBQUM5Qyw0Q0FBNEM7QUFDNUMsMENBQTBDO0FBQzFDO0FBQ0EsNENBQTRDOztBQUU1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELHVDQUF1QztBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0EsMEhBQTBILCtEQUErRDtBQUN6TDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHVCQUF1QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUU7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxrREFBa0Q7QUFDOUcsNERBQTRELGdCQUFnQjtBQUM1RTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYSxJQUFJO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RkFBNkYsT0FBTztBQUNwRztBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsZ0VBQWdFO0FBQ3hJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCx3REFBd0Q7QUFDaEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxh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TDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsMENBQTBDOztBQUUxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssd0JBQXdCO0FBQzdCO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCLHlCQUF5QjtBQUN6Qix5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQyw4Q0FBOEM7O0FBRTlDO0FBQ0E7QUFDQSw0Q0FBNEMsb0JBQW9CO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGLCtCQUErQjtBQUMvRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCx5Q0FBeUM7QUFDL0Y7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxQkFBcUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEMsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDOztBQUV0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsbUNBQW1DO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLDBEQUEwRDtBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckI7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQywwRkFBMEY7QUFDNUgsa0NBQWtDLGdHQUFnRztBQUNsSSxrQ0FBa0MsbUdBQW1HO0FBQ3JJLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxtREFBbUQ7QUFDN0c7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUMsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHVCQUF1QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qix1QkFBdUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsdUJBQXVCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHVCQUF1QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsaURBQWlEO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELHVGQUF1RjtBQUN2STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQztBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9odG1sMmNhbnZhcy9kaXN0L2h0bWwyY2FudmFzLmpzPzFkYTEiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBodG1sMmNhbnZhcyAxLjQuMSA8aHR0cHM6Ly9odG1sMmNhbnZhcy5oZXJ0emVuLmNvbT5cbiAqIENvcHlyaWdodCAoYykgMjAyMiBOaWtsYXMgdm9uIEhlcnR6ZW4gPGh0dHBzOi8vaGVydHplbi5jb20+XG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgTGljZW5zZVxuICovXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuICAgIChnbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogZ2xvYmFsIHx8IHNlbGYsIGdsb2JhbC5odG1sMmNhbnZhcyA9IGZhY3RvcnkoKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuICAgIC8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4gICAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG4gICAgUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbiAgICBwdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG4gICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG4gICAgUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbiAgICBBTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbiAgICBJTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuICAgIExPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbiAgICBPVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcbiAgICBQRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4gICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuICAgIC8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXHJcblxyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbihkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gX19nZW5lcmF0b3IodGhpc0FyZywgYm9keSkge1xyXG4gICAgICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XHJcbiAgICAgICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XHJcbiAgICAgICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XHJcbiAgICAgICAgICAgIHdoaWxlIChfKSB0cnkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xyXG4gICAgICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cclxuICAgICAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIF9fc3ByZWFkQXJyYXkodG8sIGZyb20sIHBhY2spIHtcclxuICAgICAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xyXG4gICAgICAgICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgZnJvbSk7XHJcbiAgICB9XG5cbiAgICB2YXIgQm91bmRzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBCb3VuZHMobGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xuICAgICAgICAgICAgdGhpcy50b3AgPSB0b3A7XG4gICAgICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBCb3VuZHMucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICh4LCB5LCB3LCBoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJvdW5kcyh0aGlzLmxlZnQgKyB4LCB0aGlzLnRvcCArIHksIHRoaXMud2lkdGggKyB3LCB0aGlzLmhlaWdodCArIGgpO1xuICAgICAgICB9O1xuICAgICAgICBCb3VuZHMuZnJvbUNsaWVudFJlY3QgPSBmdW5jdGlvbiAoY29udGV4dCwgY2xpZW50UmVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCb3VuZHMoY2xpZW50UmVjdC5sZWZ0ICsgY29udGV4dC53aW5kb3dCb3VuZHMubGVmdCwgY2xpZW50UmVjdC50b3AgKyBjb250ZXh0LndpbmRvd0JvdW5kcy50b3AsIGNsaWVudFJlY3Qud2lkdGgsIGNsaWVudFJlY3QuaGVpZ2h0KTtcbiAgICAgICAgfTtcbiAgICAgICAgQm91bmRzLmZyb21ET01SZWN0TGlzdCA9IGZ1bmN0aW9uIChjb250ZXh0LCBkb21SZWN0TGlzdCkge1xuICAgICAgICAgICAgdmFyIGRvbVJlY3QgPSBBcnJheS5mcm9tKGRvbVJlY3RMaXN0KS5maW5kKGZ1bmN0aW9uIChyZWN0KSB7IHJldHVybiByZWN0LndpZHRoICE9PSAwOyB9KTtcbiAgICAgICAgICAgIHJldHVybiBkb21SZWN0XG4gICAgICAgICAgICAgICAgPyBuZXcgQm91bmRzKGRvbVJlY3QubGVmdCArIGNvbnRleHQud2luZG93Qm91bmRzLmxlZnQsIGRvbVJlY3QudG9wICsgY29udGV4dC53aW5kb3dCb3VuZHMudG9wLCBkb21SZWN0LndpZHRoLCBkb21SZWN0LmhlaWdodClcbiAgICAgICAgICAgICAgICA6IEJvdW5kcy5FTVBUWTtcbiAgICAgICAgfTtcbiAgICAgICAgQm91bmRzLkVNUFRZID0gbmV3IEJvdW5kcygwLCAwLCAwLCAwKTtcbiAgICAgICAgcmV0dXJuIEJvdW5kcztcbiAgICB9KCkpO1xuICAgIHZhciBwYXJzZUJvdW5kcyA9IGZ1bmN0aW9uIChjb250ZXh0LCBub2RlKSB7XG4gICAgICAgIHJldHVybiBCb3VuZHMuZnJvbUNsaWVudFJlY3QoY29udGV4dCwgbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSk7XG4gICAgfTtcbiAgICB2YXIgcGFyc2VEb2N1bWVudFNpemUgPSBmdW5jdGlvbiAoZG9jdW1lbnQpIHtcbiAgICAgICAgdmFyIGJvZHkgPSBkb2N1bWVudC5ib2R5O1xuICAgICAgICB2YXIgZG9jdW1lbnRFbGVtZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICBpZiAoIWJvZHkgfHwgIWRvY3VtZW50RWxlbWVudCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGdldCBkb2N1bWVudCBzaXplXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB3aWR0aCA9IE1hdGgubWF4KE1hdGgubWF4KGJvZHkuc2Nyb2xsV2lkdGgsIGRvY3VtZW50RWxlbWVudC5zY3JvbGxXaWR0aCksIE1hdGgubWF4KGJvZHkub2Zmc2V0V2lkdGgsIGRvY3VtZW50RWxlbWVudC5vZmZzZXRXaWR0aCksIE1hdGgubWF4KGJvZHkuY2xpZW50V2lkdGgsIGRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCkpO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gTWF0aC5tYXgoTWF0aC5tYXgoYm9keS5zY3JvbGxIZWlnaHQsIGRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHQpLCBNYXRoLm1heChib2R5Lm9mZnNldEhlaWdodCwgZG9jdW1lbnRFbGVtZW50Lm9mZnNldEhlaWdodCksIE1hdGgubWF4KGJvZHkuY2xpZW50SGVpZ2h0LCBkb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0KSk7XG4gICAgICAgIHJldHVybiBuZXcgQm91bmRzKDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgIH07XG5cbiAgICAvKlxuICAgICAqIGNzcy1saW5lLWJyZWFrIDIuMS4wIDxodHRwczovL2dpdGh1Yi5jb20vbmlrbGFzdmgvY3NzLWxpbmUtYnJlYWsjcmVhZG1lPlxuICAgICAqIENvcHlyaWdodCAoYykgMjAyMiBOaWtsYXMgdm9uIEhlcnR6ZW4gPGh0dHBzOi8vaGVydHplbi5jb20+XG4gICAgICogUmVsZWFzZWQgdW5kZXIgTUlUIExpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgdG9Db2RlUG9pbnRzJDEgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIHZhciBjb2RlUG9pbnRzID0gW107XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHN0ci5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBzdHIuY2hhckNvZGVBdChpKyspO1xuICAgICAgICAgICAgaWYgKHZhbHVlID49IDB4ZDgwMCAmJiB2YWx1ZSA8PSAweGRiZmYgJiYgaSA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBleHRyYSA9IHN0ci5jaGFyQ29kZUF0KGkrKyk7XG4gICAgICAgICAgICAgICAgaWYgKChleHRyYSAmIDB4ZmMwMCkgPT09IDB4ZGMwMCkge1xuICAgICAgICAgICAgICAgICAgICBjb2RlUG9pbnRzLnB1c2goKCh2YWx1ZSAmIDB4M2ZmKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNmZikgKyAweDEwMDAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGVQb2ludHMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb2RlUG9pbnRzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2RlUG9pbnRzO1xuICAgIH07XG4gICAgdmFyIGZyb21Db2RlUG9pbnQkMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvZGVQb2ludHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGNvZGVQb2ludHNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoU3RyaW5nLmZyb21Db2RlUG9pbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNvZGVQb2ludC5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsZW5ndGggPSBjb2RlUG9pbnRzLmxlbmd0aDtcbiAgICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29kZVVuaXRzID0gW107XG4gICAgICAgIHZhciBpbmRleCA9IC0xO1xuICAgICAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgY29kZVBvaW50ID0gY29kZVBvaW50c1tpbmRleF07XG4gICAgICAgICAgICBpZiAoY29kZVBvaW50IDw9IDB4ZmZmZikge1xuICAgICAgICAgICAgICAgIGNvZGVVbml0cy5wdXNoKGNvZGVQb2ludCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMDtcbiAgICAgICAgICAgICAgICBjb2RlVW5pdHMucHVzaCgoY29kZVBvaW50ID4+IDEwKSArIDB4ZDgwMCwgKGNvZGVQb2ludCAlIDB4NDAwKSArIDB4ZGMwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW5kZXggKyAxID09PSBsZW5ndGggfHwgY29kZVVuaXRzLmxlbmd0aCA+IDB4NDAwMCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVVuaXRzKTtcbiAgICAgICAgICAgICAgICBjb2RlVW5pdHMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgdmFyIGNoYXJzJDIgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyc7XG4gICAgLy8gVXNlIGEgbG9va3VwIHRhYmxlIHRvIGZpbmQgdGhlIGluZGV4LlxuICAgIHZhciBsb29rdXAkMiA9IHR5cGVvZiBVaW50OEFycmF5ID09PSAndW5kZWZpbmVkJyA/IFtdIDogbmV3IFVpbnQ4QXJyYXkoMjU2KTtcbiAgICBmb3IgKHZhciBpJDIgPSAwOyBpJDIgPCBjaGFycyQyLmxlbmd0aDsgaSQyKyspIHtcbiAgICAgICAgbG9va3VwJDJbY2hhcnMkMi5jaGFyQ29kZUF0KGkkMildID0gaSQyO1xuICAgIH1cblxuICAgIC8qXG4gICAgICogdXRyaWUgMS4wLjIgPGh0dHBzOi8vZ2l0aHViLmNvbS9uaWtsYXN2aC91dHJpZT5cbiAgICAgKiBDb3B5cmlnaHQgKGMpIDIwMjIgTmlrbGFzIHZvbiBIZXJ0emVuIDxodHRwczovL2hlcnR6ZW4uY29tPlxuICAgICAqIFJlbGVhc2VkIHVuZGVyIE1JVCBMaWNlbnNlXG4gICAgICovXG4gICAgdmFyIGNoYXJzJDEkMSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJztcbiAgICAvLyBVc2UgYSBsb29rdXAgdGFibGUgdG8gZmluZCB0aGUgaW5kZXguXG4gICAgdmFyIGxvb2t1cCQxJDEgPSB0eXBlb2YgVWludDhBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyBbXSA6IG5ldyBVaW50OEFycmF5KDI1Nik7XG4gICAgZm9yICh2YXIgaSQxJDEgPSAwOyBpJDEkMSA8IGNoYXJzJDEkMS5sZW5ndGg7IGkkMSQxKyspIHtcbiAgICAgICAgbG9va3VwJDEkMVtjaGFycyQxJDEuY2hhckNvZGVBdChpJDEkMSldID0gaSQxJDE7XG4gICAgfVxuICAgIHZhciBkZWNvZGUkMSA9IGZ1bmN0aW9uIChiYXNlNjQpIHtcbiAgICAgICAgdmFyIGJ1ZmZlckxlbmd0aCA9IGJhc2U2NC5sZW5ndGggKiAwLjc1LCBsZW4gPSBiYXNlNjQubGVuZ3RoLCBpLCBwID0gMCwgZW5jb2RlZDEsIGVuY29kZWQyLCBlbmNvZGVkMywgZW5jb2RlZDQ7XG4gICAgICAgIGlmIChiYXNlNjRbYmFzZTY0Lmxlbmd0aCAtIDFdID09PSAnPScpIHtcbiAgICAgICAgICAgIGJ1ZmZlckxlbmd0aC0tO1xuICAgICAgICAgICAgaWYgKGJhc2U2NFtiYXNlNjQubGVuZ3RoIC0gMl0gPT09ICc9Jykge1xuICAgICAgICAgICAgICAgIGJ1ZmZlckxlbmd0aC0tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBidWZmZXIgPSB0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5zbGljZSAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgID8gbmV3IEFycmF5QnVmZmVyKGJ1ZmZlckxlbmd0aClcbiAgICAgICAgICAgIDogbmV3IEFycmF5KGJ1ZmZlckxlbmd0aCk7XG4gICAgICAgIHZhciBieXRlcyA9IEFycmF5LmlzQXJyYXkoYnVmZmVyKSA/IGJ1ZmZlciA6IG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgICAgICAgICAgZW5jb2RlZDEgPSBsb29rdXAkMSQxW2Jhc2U2NC5jaGFyQ29kZUF0KGkpXTtcbiAgICAgICAgICAgIGVuY29kZWQyID0gbG9va3VwJDEkMVtiYXNlNjQuY2hhckNvZGVBdChpICsgMSldO1xuICAgICAgICAgICAgZW5jb2RlZDMgPSBsb29rdXAkMSQxW2Jhc2U2NC5jaGFyQ29kZUF0KGkgKyAyKV07XG4gICAgICAgICAgICBlbmNvZGVkNCA9IGxvb2t1cCQxJDFbYmFzZTY0LmNoYXJDb2RlQXQoaSArIDMpXTtcbiAgICAgICAgICAgIGJ5dGVzW3ArK10gPSAoZW5jb2RlZDEgPDwgMikgfCAoZW5jb2RlZDIgPj4gNCk7XG4gICAgICAgICAgICBieXRlc1twKytdID0gKChlbmNvZGVkMiAmIDE1KSA8PCA0KSB8IChlbmNvZGVkMyA+PiAyKTtcbiAgICAgICAgICAgIGJ5dGVzW3ArK10gPSAoKGVuY29kZWQzICYgMykgPDwgNikgfCAoZW5jb2RlZDQgJiA2Myk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICB9O1xuICAgIHZhciBwb2x5VWludDE2QXJyYXkkMSA9IGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGJ1ZmZlci5sZW5ndGg7XG4gICAgICAgIHZhciBieXRlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICBieXRlcy5wdXNoKChidWZmZXJbaSArIDFdIDw8IDgpIHwgYnVmZmVyW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnl0ZXM7XG4gICAgfTtcbiAgICB2YXIgcG9seVVpbnQzMkFycmF5JDEgPSBmdW5jdGlvbiAoYnVmZmVyKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBidWZmZXIubGVuZ3RoO1xuICAgICAgICB2YXIgYnl0ZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gNCkge1xuICAgICAgICAgICAgYnl0ZXMucHVzaCgoYnVmZmVyW2kgKyAzXSA8PCAyNCkgfCAoYnVmZmVyW2kgKyAyXSA8PCAxNikgfCAoYnVmZmVyW2kgKyAxXSA8PCA4KSB8IGJ1ZmZlcltpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIH07XG5cbiAgICAvKiogU2hpZnQgc2l6ZSBmb3IgZ2V0dGluZyB0aGUgaW5kZXgtMiB0YWJsZSBvZmZzZXQuICovXG4gICAgdmFyIFVUUklFMl9TSElGVF8yJDEgPSA1O1xuICAgIC8qKiBTaGlmdCBzaXplIGZvciBnZXR0aW5nIHRoZSBpbmRleC0xIHRhYmxlIG9mZnNldC4gKi9cbiAgICB2YXIgVVRSSUUyX1NISUZUXzEkMSA9IDYgKyA1O1xuICAgIC8qKlxuICAgICAqIFNoaWZ0IHNpemUgZm9yIHNoaWZ0aW5nIGxlZnQgdGhlIGluZGV4IGFycmF5IHZhbHVlcy5cbiAgICAgKiBJbmNyZWFzZXMgcG9zc2libGUgZGF0YSBzaXplIHdpdGggMTYtYml0IGluZGV4IHZhbHVlcyBhdCB0aGUgY29zdFxuICAgICAqIG9mIGNvbXBhY3RhYmlsaXR5LlxuICAgICAqIFRoaXMgcmVxdWlyZXMgZGF0YSBibG9ja3MgdG8gYmUgYWxpZ25lZCBieSBVVFJJRTJfREFUQV9HUkFOVUxBUklUWS5cbiAgICAgKi9cbiAgICB2YXIgVVRSSUUyX0lOREVYX1NISUZUJDEgPSAyO1xuICAgIC8qKlxuICAgICAqIERpZmZlcmVuY2UgYmV0d2VlbiB0aGUgdHdvIHNoaWZ0IHNpemVzLFxuICAgICAqIGZvciBnZXR0aW5nIGFuIGluZGV4LTEgb2Zmc2V0IGZyb20gYW4gaW5kZXgtMiBvZmZzZXQuIDY9MTEtNVxuICAgICAqL1xuICAgIHZhciBVVFJJRTJfU0hJRlRfMV8yJDEgPSBVVFJJRTJfU0hJRlRfMSQxIC0gVVRSSUUyX1NISUZUXzIkMTtcbiAgICAvKipcbiAgICAgKiBUaGUgcGFydCBvZiB0aGUgaW5kZXgtMiB0YWJsZSBmb3IgVStEODAwLi5VK0RCRkYgc3RvcmVzIHZhbHVlcyBmb3JcbiAgICAgKiBsZWFkIHN1cnJvZ2F0ZSBjb2RlIF91bml0c18gbm90IGNvZGUgX3BvaW50c18uXG4gICAgICogVmFsdWVzIGZvciBsZWFkIHN1cnJvZ2F0ZSBjb2RlIF9wb2ludHNfIGFyZSBpbmRleGVkIHdpdGggdGhpcyBwb3J0aW9uIG9mIHRoZSB0YWJsZS5cbiAgICAgKiBMZW5ndGg9MzI9MHgyMD0weDQwMD4+VVRSSUUyX1NISUZUXzIuIChUaGVyZSBhcmUgMTAyND0weDQwMCBsZWFkIHN1cnJvZ2F0ZXMuKVxuICAgICAqL1xuICAgIHZhciBVVFJJRTJfTFNDUF9JTkRFWF8yX09GRlNFVCQxID0gMHgxMDAwMCA+PiBVVFJJRTJfU0hJRlRfMiQxO1xuICAgIC8qKiBOdW1iZXIgb2YgZW50cmllcyBpbiBhIGRhdGEgYmxvY2suIDMyPTB4MjAgKi9cbiAgICB2YXIgVVRSSUUyX0RBVEFfQkxPQ0tfTEVOR1RIJDEgPSAxIDw8IFVUUklFMl9TSElGVF8yJDE7XG4gICAgLyoqIE1hc2sgZm9yIGdldHRpbmcgdGhlIGxvd2VyIGJpdHMgZm9yIHRoZSBpbi1kYXRhLWJsb2NrIG9mZnNldC4gKi9cbiAgICB2YXIgVVRSSUUyX0RBVEFfTUFTSyQxID0gVVRSSUUyX0RBVEFfQkxPQ0tfTEVOR1RIJDEgLSAxO1xuICAgIHZhciBVVFJJRTJfTFNDUF9JTkRFWF8yX0xFTkdUSCQxID0gMHg0MDAgPj4gVVRSSUUyX1NISUZUXzIkMTtcbiAgICAvKiogQ291bnQgdGhlIGxlbmd0aHMgb2YgYm90aCBCTVAgcGllY2VzLiAyMDgwPTB4ODIwICovXG4gICAgdmFyIFVUUklFMl9JTkRFWF8yX0JNUF9MRU5HVEgkMSA9IFVUUklFMl9MU0NQX0lOREVYXzJfT0ZGU0VUJDEgKyBVVFJJRTJfTFNDUF9JTkRFWF8yX0xFTkdUSCQxO1xuICAgIC8qKlxuICAgICAqIFRoZSAyLWJ5dGUgVVRGLTggdmVyc2lvbiBvZiB0aGUgaW5kZXgtMiB0YWJsZSBmb2xsb3dzIGF0IG9mZnNldCAyMDgwPTB4ODIwLlxuICAgICAqIExlbmd0aCAzMj0weDIwIGZvciBsZWFkIGJ5dGVzIEMwLi5ERiwgcmVnYXJkbGVzcyBvZiBVVFJJRTJfU0hJRlRfMi5cbiAgICAgKi9cbiAgICB2YXIgVVRSSUUyX1VURjhfMkJfSU5ERVhfMl9PRkZTRVQkMSA9IFVUUklFMl9JTkRFWF8yX0JNUF9MRU5HVEgkMTtcbiAgICB2YXIgVVRSSUUyX1VURjhfMkJfSU5ERVhfMl9MRU5HVEgkMSA9IDB4ODAwID4+IDY7IC8qIFUrMDgwMCBpcyB0aGUgZmlyc3QgY29kZSBwb2ludCBhZnRlciAyLWJ5dGUgVVRGLTggKi9cbiAgICAvKipcbiAgICAgKiBUaGUgaW5kZXgtMSB0YWJsZSwgb25seSB1c2VkIGZvciBzdXBwbGVtZW50YXJ5IGNvZGUgcG9pbnRzLCBhdCBvZmZzZXQgMjExMj0weDg0MC5cbiAgICAgKiBWYXJpYWJsZSBsZW5ndGgsIGZvciBjb2RlIHBvaW50cyB1cCB0byBoaWdoU3RhcnQsIHdoZXJlIHRoZSBsYXN0IHNpbmdsZS12YWx1ZSByYW5nZSBzdGFydHMuXG4gICAgICogTWF4aW11bSBsZW5ndGggNTEyPTB4MjAwPTB4MTAwMDAwPj5VVFJJRTJfU0hJRlRfMS5cbiAgICAgKiAoRm9yIDB4MTAwMDAwIHN1cHBsZW1lbnRhcnkgY29kZSBwb2ludHMgVSsxMDAwMC4uVSsxMGZmZmYuKVxuICAgICAqXG4gICAgICogVGhlIHBhcnQgb2YgdGhlIGluZGV4LTIgdGFibGUgZm9yIHN1cHBsZW1lbnRhcnkgY29kZSBwb2ludHMgc3RhcnRzXG4gICAgICogYWZ0ZXIgdGhpcyBpbmRleC0xIHRhYmxlLlxuICAgICAqXG4gICAgICogQm90aCB0aGUgaW5kZXgtMSB0YWJsZSBhbmQgdGhlIGZvbGxvd2luZyBwYXJ0IG9mIHRoZSBpbmRleC0yIHRhYmxlXG4gICAgICogYXJlIG9taXR0ZWQgY29tcGxldGVseSBpZiB0aGVyZSBpcyBvbmx5IEJNUCBkYXRhLlxuICAgICAqL1xuICAgIHZhciBVVFJJRTJfSU5ERVhfMV9PRkZTRVQkMSA9IFVUUklFMl9VVEY4XzJCX0lOREVYXzJfT0ZGU0VUJDEgKyBVVFJJRTJfVVRGOF8yQl9JTkRFWF8yX0xFTkdUSCQxO1xuICAgIC8qKlxuICAgICAqIE51bWJlciBvZiBpbmRleC0xIGVudHJpZXMgZm9yIHRoZSBCTVAuIDMyPTB4MjBcbiAgICAgKiBUaGlzIHBhcnQgb2YgdGhlIGluZGV4LTEgdGFibGUgaXMgb21pdHRlZCBmcm9tIHRoZSBzZXJpYWxpemVkIGZvcm0uXG4gICAgICovXG4gICAgdmFyIFVUUklFMl9PTUlUVEVEX0JNUF9JTkRFWF8xX0xFTkdUSCQxID0gMHgxMDAwMCA+PiBVVFJJRTJfU0hJRlRfMSQxO1xuICAgIC8qKiBOdW1iZXIgb2YgZW50cmllcyBpbiBhbiBpbmRleC0yIGJsb2NrLiA2ND0weDQwICovXG4gICAgdmFyIFVUUklFMl9JTkRFWF8yX0JMT0NLX0xFTkdUSCQxID0gMSA8PCBVVFJJRTJfU0hJRlRfMV8yJDE7XG4gICAgLyoqIE1hc2sgZm9yIGdldHRpbmcgdGhlIGxvd2VyIGJpdHMgZm9yIHRoZSBpbi1pbmRleC0yLWJsb2NrIG9mZnNldC4gKi9cbiAgICB2YXIgVVRSSUUyX0lOREVYXzJfTUFTSyQxID0gVVRSSUUyX0lOREVYXzJfQkxPQ0tfTEVOR1RIJDEgLSAxO1xuICAgIHZhciBzbGljZTE2JDEgPSBmdW5jdGlvbiAodmlldywgc3RhcnQsIGVuZCkge1xuICAgICAgICBpZiAodmlldy5zbGljZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZpZXcuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBVaW50MTZBcnJheShBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh2aWV3LCBzdGFydCwgZW5kKSk7XG4gICAgfTtcbiAgICB2YXIgc2xpY2UzMiQxID0gZnVuY3Rpb24gKHZpZXcsIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgaWYgKHZpZXcuc2xpY2UpIHtcbiAgICAgICAgICAgIHJldHVybiB2aWV3LnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVWludDMyQXJyYXkoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodmlldywgc3RhcnQsIGVuZCkpO1xuICAgIH07XG4gICAgdmFyIGNyZWF0ZVRyaWVGcm9tQmFzZTY0JDEgPSBmdW5jdGlvbiAoYmFzZTY0LCBfYnl0ZUxlbmd0aCkge1xuICAgICAgICB2YXIgYnVmZmVyID0gZGVjb2RlJDEoYmFzZTY0KTtcbiAgICAgICAgdmFyIHZpZXczMiA9IEFycmF5LmlzQXJyYXkoYnVmZmVyKSA/IHBvbHlVaW50MzJBcnJheSQxKGJ1ZmZlcikgOiBuZXcgVWludDMyQXJyYXkoYnVmZmVyKTtcbiAgICAgICAgdmFyIHZpZXcxNiA9IEFycmF5LmlzQXJyYXkoYnVmZmVyKSA/IHBvbHlVaW50MTZBcnJheSQxKGJ1ZmZlcikgOiBuZXcgVWludDE2QXJyYXkoYnVmZmVyKTtcbiAgICAgICAgdmFyIGhlYWRlckxlbmd0aCA9IDI0O1xuICAgICAgICB2YXIgaW5kZXggPSBzbGljZTE2JDEodmlldzE2LCBoZWFkZXJMZW5ndGggLyAyLCB2aWV3MzJbNF0gLyAyKTtcbiAgICAgICAgdmFyIGRhdGEgPSB2aWV3MzJbNV0gPT09IDJcbiAgICAgICAgICAgID8gc2xpY2UxNiQxKHZpZXcxNiwgKGhlYWRlckxlbmd0aCArIHZpZXczMls0XSkgLyAyKVxuICAgICAgICAgICAgOiBzbGljZTMyJDEodmlldzMyLCBNYXRoLmNlaWwoKGhlYWRlckxlbmd0aCArIHZpZXczMls0XSkgLyA0KSk7XG4gICAgICAgIHJldHVybiBuZXcgVHJpZSQxKHZpZXczMlswXSwgdmlldzMyWzFdLCB2aWV3MzJbMl0sIHZpZXczMlszXSwgaW5kZXgsIGRhdGEpO1xuICAgIH07XG4gICAgdmFyIFRyaWUkMSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gVHJpZShpbml0aWFsVmFsdWUsIGVycm9yVmFsdWUsIGhpZ2hTdGFydCwgaGlnaFZhbHVlSW5kZXgsIGluZGV4LCBkYXRhKSB7XG4gICAgICAgICAgICB0aGlzLmluaXRpYWxWYWx1ZSA9IGluaXRpYWxWYWx1ZTtcbiAgICAgICAgICAgIHRoaXMuZXJyb3JWYWx1ZSA9IGVycm9yVmFsdWU7XG4gICAgICAgICAgICB0aGlzLmhpZ2hTdGFydCA9IGhpZ2hTdGFydDtcbiAgICAgICAgICAgIHRoaXMuaGlnaFZhbHVlSW5kZXggPSBoaWdoVmFsdWVJbmRleDtcbiAgICAgICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgdmFsdWUgZm9yIGEgY29kZSBwb2ludCBhcyBzdG9yZWQgaW4gdGhlIFRyaWUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBjb2RlUG9pbnQgdGhlIGNvZGUgcG9pbnRcbiAgICAgICAgICogQHJldHVybiB0aGUgdmFsdWVcbiAgICAgICAgICovXG4gICAgICAgIFRyaWUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChjb2RlUG9pbnQpIHtcbiAgICAgICAgICAgIHZhciBpeDtcbiAgICAgICAgICAgIGlmIChjb2RlUG9pbnQgPj0gMCkge1xuICAgICAgICAgICAgICAgIGlmIChjb2RlUG9pbnQgPCAweDBkODAwIHx8IChjb2RlUG9pbnQgPiAweDBkYmZmICYmIGNvZGVQb2ludCA8PSAweDBmZmZmKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBPcmRpbmFyeSBCTVAgY29kZSBwb2ludCwgZXhjbHVkaW5nIGxlYWRpbmcgc3Vycm9nYXRlcy5cbiAgICAgICAgICAgICAgICAgICAgLy8gQk1QIHVzZXMgYSBzaW5nbGUgbGV2ZWwgbG9va3VwLiAgQk1QIGluZGV4IHN0YXJ0cyBhdCBvZmZzZXQgMCBpbiB0aGUgVHJpZTIgaW5kZXguXG4gICAgICAgICAgICAgICAgICAgIC8vIDE2IGJpdCBkYXRhIGlzIHN0b3JlZCBpbiB0aGUgaW5kZXggYXJyYXkgaXRzZWxmLlxuICAgICAgICAgICAgICAgICAgICBpeCA9IHRoaXMuaW5kZXhbY29kZVBvaW50ID4+IFVUUklFMl9TSElGVF8yJDFdO1xuICAgICAgICAgICAgICAgICAgICBpeCA9IChpeCA8PCBVVFJJRTJfSU5ERVhfU0hJRlQkMSkgKyAoY29kZVBvaW50ICYgVVRSSUUyX0RBVEFfTUFTSyQxKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVtpeF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjb2RlUG9pbnQgPD0gMHhmZmZmKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIExlYWQgU3Vycm9nYXRlIENvZGUgUG9pbnQuICBBIFNlcGFyYXRlIGluZGV4IHNlY3Rpb24gaXMgc3RvcmVkIGZvclxuICAgICAgICAgICAgICAgICAgICAvLyBsZWFkIHN1cnJvZ2F0ZSBjb2RlIHVuaXRzIGFuZCBjb2RlIHBvaW50cy5cbiAgICAgICAgICAgICAgICAgICAgLy8gICBUaGUgbWFpbiBpbmRleCBoYXMgdGhlIGNvZGUgdW5pdCBkYXRhLlxuICAgICAgICAgICAgICAgICAgICAvLyAgIEZvciB0aGlzIGZ1bmN0aW9uLCB3ZSBuZWVkIHRoZSBjb2RlIHBvaW50IGRhdGEuXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdGU6IHRoaXMgZXhwcmVzc2lvbiBjb3VsZCBiZSByZWZhY3RvcmVkIGZvciBzbGlnaHRseSBpbXByb3ZlZCBlZmZpY2llbmN5LCBidXRcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgc3Vycm9nYXRlIGNvZGUgcG9pbnRzIHdpbGwgYmUgc28gcmFyZSBpbiBwcmFjdGljZSB0aGF0IGl0J3Mgbm90IHdvcnRoIGl0LlxuICAgICAgICAgICAgICAgICAgICBpeCA9IHRoaXMuaW5kZXhbVVRSSUUyX0xTQ1BfSU5ERVhfMl9PRkZTRVQkMSArICgoY29kZVBvaW50IC0gMHhkODAwKSA+PiBVVFJJRTJfU0hJRlRfMiQxKV07XG4gICAgICAgICAgICAgICAgICAgIGl4ID0gKGl4IDw8IFVUUklFMl9JTkRFWF9TSElGVCQxKSArIChjb2RlUG9pbnQgJiBVVFJJRTJfREFUQV9NQVNLJDEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhW2l4XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNvZGVQb2ludCA8IHRoaXMuaGlnaFN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFN1cHBsZW1lbnRhbCBjb2RlIHBvaW50LCB1c2UgdHdvLWxldmVsIGxvb2t1cC5cbiAgICAgICAgICAgICAgICAgICAgaXggPSBVVFJJRTJfSU5ERVhfMV9PRkZTRVQkMSAtIFVUUklFMl9PTUlUVEVEX0JNUF9JTkRFWF8xX0xFTkdUSCQxICsgKGNvZGVQb2ludCA+PiBVVFJJRTJfU0hJRlRfMSQxKTtcbiAgICAgICAgICAgICAgICAgICAgaXggPSB0aGlzLmluZGV4W2l4XTtcbiAgICAgICAgICAgICAgICAgICAgaXggKz0gKGNvZGVQb2ludCA+PiBVVFJJRTJfU0hJRlRfMiQxKSAmIFVUUklFMl9JTkRFWF8yX01BU0skMTtcbiAgICAgICAgICAgICAgICAgICAgaXggPSB0aGlzLmluZGV4W2l4XTtcbiAgICAgICAgICAgICAgICAgICAgaXggPSAoaXggPDwgVVRSSUUyX0lOREVYX1NISUZUJDEpICsgKGNvZGVQb2ludCAmIFVUUklFMl9EQVRBX01BU0skMSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFbaXhdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY29kZVBvaW50IDw9IDB4MTBmZmZmKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFbdGhpcy5oaWdoVmFsdWVJbmRleF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRmFsbCB0aHJvdWdoLiAgVGhlIGNvZGUgcG9pbnQgaXMgb3V0c2lkZSBvZiB0aGUgbGVnYWwgcmFuZ2Ugb2YgMC4uMHgxMGZmZmYuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lcnJvclZhbHVlO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gVHJpZTtcbiAgICB9KCkpO1xuXG4gICAgLypcbiAgICAgKiBiYXNlNjQtYXJyYXlidWZmZXIgMS4wLjIgPGh0dHBzOi8vZ2l0aHViLmNvbS9uaWtsYXN2aC9iYXNlNjQtYXJyYXlidWZmZXI+XG4gICAgICogQ29weXJpZ2h0IChjKSAyMDIyIE5pa2xhcyB2b24gSGVydHplbiA8aHR0cHM6Ly9oZXJ0emVuLmNvbT5cbiAgICAgKiBSZWxlYXNlZCB1bmRlciBNSVQgTGljZW5zZVxuICAgICAqL1xuICAgIHZhciBjaGFycyQzID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nO1xuICAgIC8vIFVzZSBhIGxvb2t1cCB0YWJsZSB0byBmaW5kIHRoZSBpbmRleC5cbiAgICB2YXIgbG9va3VwJDMgPSB0eXBlb2YgVWludDhBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyBbXSA6IG5ldyBVaW50OEFycmF5KDI1Nik7XG4gICAgZm9yICh2YXIgaSQzID0gMDsgaSQzIDwgY2hhcnMkMy5sZW5ndGg7IGkkMysrKSB7XG4gICAgICAgIGxvb2t1cCQzW2NoYXJzJDMuY2hhckNvZGVBdChpJDMpXSA9IGkkMztcbiAgICB9XG5cbiAgICB2YXIgYmFzZTY0JDEgPSAnS3dBQUFBQUFBQUFBQ0E0QVVEMEFBREFnQUFBQ0FBQUFBQUFJQUJBQUdBQkFBRWdBVUFCWUFHQUFhQUJnQUdnQVlnQnFBRjhBWndCZ0FHZ0FjUUI1QUhVQWZRQ0ZBSTBBbFFDZEFLSUFxZ0N5QUxvQVlBQm9BR0FBYUFCZ0FHZ0F3Z0RLQUdBQWFBREdBTTRBMHdEYkFPRUE2UUR4QVBrQUFRRUpBUThCRndGMUFIMEFIQUVrQVN3Qk5BRTZBVUlCUVFGSkFWRUJXUUZoQVdnQmNBRjRBVEFBZ0FHR0FZNEJsUUdYQVo4QnB3R3ZBYlVCdlFIRkFjMEIwd0hiQWVNQjZ3SHhBZmtCQVFJSkF2RUJFUUlaQWlFQ0tRSXhBamdDUUFKR0FrNENWZ0plQW1RQ2JBSjBBbndDZ1FLSkFwRUNtUUtnQXFnQ3NBSzRBcndDeEFJd0FNd0Mwd0xiQWpBQTR3THJBdk1DK0FJQUF3Y0REd013QUJjREhRTWxBeTBETlFOMUFEMERRUU5KQTBrRFNRTlJBMUVEVndOWkExa0RkUUIxQUdFRGRRQnBBMjBEZFFOMUFIc0RkUUNCQTRrRGtRTjFBSFVBbVFPaEEzVUFkUUIxQUhVQWRRQjFBSFVBZFFCMUFIVUFkUUIxQUhVQWRRQjFBSFVBZFFCMUFLWURyZ04xQUhVQXRnTytBOFlEemdQV0F4Y0QzZ1BqQStzRDh3TjFBSFVBK3dNREJBa0VkUUFOQkJVRUhRUWxCQ29FRndNeUJEZ0VZQUJBQkJjRFNBUlFCRmdFWUFSb0JEQUFjQVF6QVhnRWdBU0lCSkFFZFFDWEJIVUFud1NuQks0RXRnUzZCTUlFeUFSMUFIVUFkUUIxQUhVQWRRQ1ZBTkFFWUFCZ0FHQUFZQUJnQUdBQVlBQmdBTmdFWUFEY0JPUUVZQURzQlBRRS9BUUVCUXdGRkFVY0JTUUZMQVUwQldRRVBBVkVCVXNGVXdWYkJXQUFZZ1ZnQUdvRmNnVjZCWUlGaWdXUkJXQUFtUVdmQmFZRllBQmdBR0FBWUFCZ0FLb0ZZQUN4QmJBRnVRVzZCY0VGd1FYSEJjRUZ3UVhQQmRNRjJ3WGpCZW9GOGdYNkJRSUdDZ1lTQmhvR0lnWXFCaklHT2daZ0FENEdSZ1pNQm1BQVV3WmFCbUFBWUFCZ0FHQUFZQUJnQUdBQVlBQmdBR0FBWUFCZ0FHSUdZQUJwQm5BR1lBQmdBR0FBWUFCZ0FHQUFZQUJnQUdBQVlBQjRCbjhHaFFaZ0FHQUFZQUIxQUhjREZRU0xCbUFBWUFCZ0FKTUdkUUE5QTNVQW13YWpCcXNHcXdhVkFMTUd1d2JEQmpBQXl3YlNCdElHMVFiU0J0SUcwZ2JTQnRJRzBnYmRCdU1HNndiekJ2c0dBd2NMQnhNSEF3Y2JCeU1ISndjc0J5d0hNUWNzQjlJR09BZEFCMGdIVGdmU0JrZ0hWZ2ZTQnRJRzBnYlNCdElHMGdiU0J0SUcwZ2JTQml3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWRnQUdBQUxBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWRiQjJNSExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQjJrSDBnWndCNjRFZFFCMUFIVUFkUUIxQUhVQWRRQjFBSFVIZlFkZ0FJVUhqUWQxQUhVQWxRZWRCMkFBWUFDbEI2c0hZQUN6QjdZSHZnZkdCM1VBemdmV0J6TUIzZ2ZtQjFFQjdnZjFCLzBIbFFFTkFRVUlEUWgxQUJVSUhRZ2xDQmNETFFnMUNEMElSUWhOQ0VFRFV3aDFBSFVBZFFCYkNHTUlaQWhsQ0dZSVp3aG9DR2tJWXdoa0NHVUlaZ2huQ0dnSWFRaGpDR1FJWlFobUNHY0lhQWhwQ0dNSVpBaGxDR1lJWndob0NHa0lZd2hrQ0dVSVpnaG5DR2dJYVFoakNHUUlaUWhtQ0djSWFBaHBDR01JWkFobENHWUlad2hvQ0drSVl3aGtDR1VJWmdobkNHZ0lhUWhqQ0dRSVpRaG1DR2NJYUFocENHTUlaQWhsQ0dZSVp3aG9DR2tJWXdoa0NHVUlaZ2huQ0dnSWFRaGpDR1FJWlFobUNHY0lhQWhwQ0dNSVpBaGxDR1lJWndob0NHa0lZd2hrQ0dVSVpnaG5DR2dJYVFoakNHUUlaUWhtQ0djSWFBaHBDR01JWkFobENHWUlad2hvQ0drSVl3aGtDR1VJWmdobkNHZ0lhUWhqQ0dRSVpRaG1DR2NJYUFocENHTUlaQWhsQ0dZSVp3aG9DR2tJWXdoa0NHVUlaZ2huQ0dnSWFRaGpDR1FJWlFobUNHY0lhQWhwQ0dNSVpBaGxDR1lJWndob0NHa0lZd2hrQ0dVSVpnaG5DR2dJYVFoakNHUUlaUWhtQ0djSWFBaHBDR01JWkFobENHWUlad2hvQ0drSVl3aGtDR1VJWmdobkNHZ0lhUWhqQ0dRSVpRaG1DR2NJYUFocENHTUlaQWhsQ0dZSVp3aG9DR2tJWXdoa0NHVUlaZ2huQ0dnSWFRaGpDR1FJWlFobUNHY0lhQWhwQ0dNSVpBaGxDR1lJWndob0NHa0lZd2hrQ0dVSVpnaG5DR2dJYVFoakNHUUlaUWhtQ0djSWFBaHBDR01JWkFobENHWUlad2hvQ0drSVl3aGtDR1VJWmdobkNHZ0lhUWhqQ0dRSVpRaG1DR2NJYUFocENHTUlaQWhsQ0dZSVp3aG9DR2tJWXdoa0NHVUlaZ2huQ0dnSWFRaGpDR1FJWlFobUNHY0lhQWhwQ0dNSVpBaGxDR1lJWndob0NHa0lZd2hrQ0dVSVpnaG5DR2dJYVFoakNHUUlaUWhtQ0djSWFBaHBDR01JWkFobENHWUlad2hvQ0drSVl3aGtDR1VJWmdobkNHZ0lhUWhqQ0dRSVpRaG1DR2NJYUFocENHTUlaQWhsQ0dZSVp3aG9DR2tJWXdoa0NHVUlaZ2huQ0dnSWFRaGpDR1FJWlFobUNHY0lhQWhwQ0dNSVpBaGxDR1lJWndob0NHa0lZd2hrQ0dVSVpnaG5DR2dJY0FoM0NIb0lNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBSUlJZ2dpQ0NJSUlnZ2lDQ0lJSWdnaUNDSUlJZ2dpQ0NJSUlnZ2lDQ0lJSWdnaUNDSUlJZ2dpQ0NJSUlnZ2lDQ0lJSWdnaUNDSUlJZ2dpQ0NJSUlnZ2d3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQUxBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCNG9JTEFjc0I0NEkwZ2FXQ0o0SXBnaDFBSFVBcWdpeUNIVUFkUUIxQUhVQWRRQjFBSFVBZFFCMUFIVUF0d2g4QVhVQXZ3aDFBTVVJeVFqUkNOa0k0QWpvQ0hVQWRRQjFBTzRJOWdqK0NBWUpEZ2tUQ1MwSEd3a2pDWUlJZ2dpQ0NJSUlnZ2lDQ0lJSWdnaUNDSUlJZ2dpQ0NJSUlnZ2lDQ0lJSWdnaUNDSUlJZ2dpQ0NJSUlnZ2lDQ0lJSWdnaUNDSUlJZ2dpQ0NJSUlnZ2lBQUlBQUFBRkFBWUFCZ0FHSUFYd0JnQUhFQWRRQkZBSlVBb2dDeUFLQUFZQUJnQUVJQTRBQkdBTk1BNFFEeEFNRUJEd0UxQUZ3QkxBRTZBUUVCVVFGNFFraENtRUtvUXJoQ2dBSElRc0FCME1MQUFjQUJ3QUhBQWVEQzZBQm9BSERDd01NQUFjQUJ3QUhBQWREREdNTUFBY0FCNk1NNHd3akRXTU5vdzNqRGFBQm9BR2dBYUFCb0FHZ0FhQUJvQUdnQWFBQm9BR2dBYUFCb0FHZ0FhQUJvQUdnQWFBQm9BRWpEcUFCV3c2YkRxQUJwZzZnQWFBQm9BSGNEdndPUEErZ0FhQUJmQS84RHZ3Ty9BNzhEdndPL0E3OER2d08vQTc4RHZ3Ty9BNzhEdndPL0E3OER2d08vQTc4RHZ3Ty9BNzhEdndPL0E3OER2d08vQTc4RHBjUEFBY0FCd0FIQUFjQUJ3QUhBQWNBQndBSEFBY0FCd0FIQUFjQUJ3QUhBQWNBQndBSEFBY0FCd0FIQUFjQUJ3QUhBQWNBQndBSEFBY0FCd0FIQUFjQUJ3QUhBQWNBQndBSEFBY0FCd0FIQUFjQUJ3QUhBQWNBQndBSEFBY0FCd0FIQUFjQUJ3QUhBQWNBQndBSEFBY0FCd0FIQUFjQUJ3QUhBQWNBQndBSEFBY0FCd0FIQUFjQUJ3QUhBQWNBQndBSEFBY0FCd0FIQUFjQUJ3QUhBQWNBQndBSEFBY0FCd0FIQUFjQUJ3QUhBQWNBQndBSEFBY0FCd0FIQUFjQUJ3QUhBQWNBQndBSEFBY0FCd0FIQUFjQUJ3QUhBQWNBQndBSEFBY0FCd0FIQUFjQUJ3QUhBQWNBQndBSEFBY0FCd0FIQUFjQUJ3QUhBQWNBQndBSEFBY0FCd0FIQUFjQUJ3QUhBQWNBQndBSEFBY0FCd0FIQUFjQUJ3QUhBQWNBQndBSEFBY0FCd0FIQUFjQUJ3QUhBQWNBQndBSEFBY0FCd0FIQUFjQUJ3QUhBQWNBQndBSEFBY0FCd0FIQUFjQUJ3QUhBQWNBQndBSEFBY0FCd0FIQUFjQUJ3QUhBQWNBQndBSEFBY0FCd0FIQUFjQUJ3QUhBQWNBQndBSEFBY0FCd0FIQUFjQUJ3QUhBQWNBQndBSEFBY0FCd0FIQUFjQUJ3QUhBQWNBQndBSEFBY0FCd0FIQUFjQUJ3QUhBQWNBQndBSEFBY0FCd0FIQUFjQUJ3QUhBQWNBQndBSEFBY0FCd0FIQUFjQUJ3QUhBQWNBQndBSEFBY0FCd0FIQUFjQUJ3QUhBQWNBQndBSEFBY0FCd0FIQUFjQUJ3QUhBQWNBQndBSEFBY0FCd0FIQUFjQUJ3QUhBQWNBQndBSEFBY0FCd0FIQUFjQUJ3QUhBQWNBQndBSEFBY0FCd0FIQUFjQUJ3QUhBQWNBQndBSEFBY0FCd0FIQUFjQUJ3QUhBQWNBQndBSEFBY0FCd0FIQUFjQUJ3QUhBQWNBQndBSEFBY0FCd0FIQUFjQUJ3QUhBQWNBQndBSEFBY0FCd0FIQUFjQUJ3QUhBQWNBQndBSEFBY0FCd0FIQUFjQUI5Y1BLd2t5Q1RvSk1BQjFBSFVBZFFCQ0NVb0pUUWwxQUZVSlhBbGpDV2NKYXdrd0FEQUFNQUF3QUhNSmRRQjJDWDRKZFFDRUNZb0pqZ21XQ1hVQW5na3dBR0FBWUFCeEFIVUFwZ24zQTY0SnRBbDFBTGtKZFFEQUNUQUFNQUF3QURBQWRRQjFBSFVBZFFCMUFIVUFkUUIxQUhVQW93WU5CTVVJTUFBd0FEQUFNQURJQ2NzSjB3blpDUlVFNFFrd0FPa0o4QW40Q1RBQU1BQjFBQUFLdndoMUFBZ0tEd29YQ2g4S2RRQXdBQ2NLTGdwMUFEWUtxQW1JQ1Q0S1Jnb3dBREFBZFFCMUFFNEtNQUIxQUZZS2RRQmVDblVBWlFvd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBVkJIVUFiUW93QURBQWRRQzVDWFVLTUFBd0FId0J4QWlqQm9nRU1nRjlDb1FLaUFTTUNwUUttZ3FJQktJS3FncXVDb2dFRFFHMkNyNEt4Z3JMQ2pBQU1BRFRDdHNLQ2dIakN1c0s4UXI1Q2dFTE1BQXdBREFBTUFCMUFJc0VDUXNSQzNVQU5BRVpDekFBTUFBd0FEQUFNQUIxQUNFTEtRc3dBSFVBTkFFeEN6a0xkUUJCQzBrTE1BQlJDMWtMTUFBd0FEQUFNQUF3QURBQWRRQmhDekFBTUFBd0FHQUFZQUJwQzNFTGR3dC9DekFBTUFDSEM0c0xrd3ViQzU4THB3dDFBSzRMdGd0MUFQc0RNQUF3QURBQU1BQXdBREFBTUFBd0FMNEx3d3ZMQzlJTDF3dmRDekFBTUFEbEMra0w4UXY1Qy84TFNRc3dBREFBTUFBd0FEQUFNQUF3QURBQU1BQUhEREFBTUFBd0FEQUFNQUFPREJZTUhneDFBSFVBZFFCMUFIVUFkUUIxQUhVQWRRQjFBSFVBZFFCMUFIVUFkUUIxQUhVQWRRQjFBSFVBZFFCMUFIVUFkUUIxQUhVQWRRQjFBQ1lNTUFBd0FEQUFkUUIxQUhVQUxneDFBSFVBZFFCMUFIVUFkUUEyRERBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBSFVBZFFCMUFIVUFkUUIxQUhVQWRRQjFBSFVBZFFCMUFIVUFkUUIxQUhVQWRRQjFBRDRNZFFCR0RIVUFkUUIxQUhVQWRRQjFBRWtNZFFCMUFIVUFkUUIxQUZBTU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FIVUFkUUIxQUhVQWRRQjFBSFVBZFFCMUFIVUFkUUIxQUhVQWRRQllESFVBZFFCMUFGOE1NQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQjFBSFVBZFFCMUFIVUFkUUIxQUhVQWRRQjFBSFVBZFFCMUFIVUFkUUIxQUhVQSt3TVZCR2NNTUFBd0FId0Jid3gxQUhjTWZ3eUhESThNTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFZQUJnQUpjTU1BQXdBREFBZFFCMUFKOE1sUUNsRERBQU1BQ3REQ3dITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCN1VNTEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SGRRQjFBSFVBZFFCMUFIVUFkUUIxQUhVQWRRQjFBSFVBZFFCMUFBMEVNQUM5RERBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBc0J5d0hMQWNzQnl3SExBY3NCeXdITFFjd0FNRU15QXdzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SHpBd3dBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FIVUFkUUIxQU5RTTJRemhEREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQmdBR0FBWUFCZ0FHQUFZQUJnQU9rTVlBRHhER0FBK0F3QURRWU5ZQUJoQ1dBQVlBQU9EVEFBTUFBd0FEQUFGZzFnQUdBQUhnMzdBekFBTUFBd0FEQUFZQUJnQUNZTllBQXNEVFFOUEExZ0FFTU5QZzFMRFdBQVlBQmdBR0FBWUFCZ0FHQUFZQUJnQUdBQVVnMWFEWXNHVmdsaERWME5jUUJuRFcwTmRRMTVEV0FBWUFCZ0FHQUFZQUJnQUdBQVlBQmdBR0FBWUFCZ0FHQUFZQUJnQUdBQWxRQ0JEWlVBaUEyUERaY05NQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBbncybkRUQUFNQUF3QURBQU1BQXdBSFVBcncyM0RUQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUIxQUw4Tk1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFCMUFIVUFkUUIxQUhVQWRRREhEVEFBWUFCZ0FNOE5NQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBMXcxMUFOd05NQUF3QUQwQjVBMHdBREFBTUFBd0FEQUFNQURzRGZRTi9BMEVEZ3dPRkE0d0FCc09NQUF3QURBQU1BQXdBREFBTUFBd0FOSUcwZ2JTQnRJRzBnYlNCdElHMGdZakRpZ093UVV1RHNFRk13N1NCam9PMGdiU0J0SUcwZ2JTQnRJRzBnYlNCdElHMGdiU0J0SUdRZzVLRGxJT1ZnN1NCdElHWGc1bERtME9kUTdTQnRJR2ZRNkVEb29PalE2VUR0SUdtZzZoRHRJRzBnYW9EcXdPMGdhMERyd08wZ1pnQUdBQVlBREVEbUFBWUFBa0J0SUd6QTVnQU5JT1lBRGFEb2tPMGdiU0J0OE81dzdTQnU4TzBnYjFEdndPMGdaZ0FHQUF4QTdTQnRJRzBnYlNCdElHWUFCZ0FHQUFZQUFFRDJBQXNBVU1EOUlHMGdiU0J0SUcwZ2JTQnRJRzBnYlNCdElHMGdiU0J0SUcwZ2JTQnRJRzBnYlNCdElHMGdiU0J0SUcwZ2JTQnRJRzBnYlNCdElHMGdiU0J0SUdGQThzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNjRDlJR0xBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdISkE4c0J5d0hMQWNzQnl3SExBY2NEeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdQTEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWMwRDlJRzBnYlNCdElHMGdiU0J0SUcwZ2JTQnRJRzBnYlNCdElHMGdiU0J0SUcwZ2JTQnRJRzBnYlNCdElHMGdiU0J0SUcwZ2JTQnRJRzBnYlNCdElHMGdiU0J0SUcwZ2JTQnRJRzBnYlNCdElHMGdiU0J0SUcwZ2JTQnRJRzBnYlNCdElHMGdiU0J0SUcwZ2JTQnRJRzBnYlNCdElHMGdiU0J0SUcwZ2JTQnRJR0xBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNjRDlJRzBnYlNCdElHMGdiU0J0SUcwZ2JTQnRJRzBnYlNCdElHMGdiU0J0SUcwZ2JTQnRJRzBnYlNCdElHMGdiU0J0SUcwZ2JTQnRJRzBnYlNCdElHMGdiU0J0SUcwZ2JTQnRJRzBnYlNCdElHMGdiU0J0SUcwZ2JTQnRJR0ZBOHNCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SFBBL1NCdElHMGdiU0J0SUcwZ2JTQnRJRzBnYlNCdElHMGdiU0J0SUcwZ2JTQnRJRzBnYlNCdElHMGdiU0J0SUcwZ2JTQnRJRzBnYlNCdElHMGdiU0J0SUcwZ2JTQnRJRzBnYlNCdElHMGdiU0J0SUcwZ2JTQnRJRzBnYlNCdElHMGdiU0J0SUcwZ2JTQnRJRzBnYlNCdElHMGdiU0J0SUcwZ2JTQnRJRzBnWVVEMFFQbFFDVkFKVUFNQUF3QURBQU1BQ1ZBSlVBbFFDVkFKVUFsUUNWQUV3UE1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBLy84RUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBTkFBTUFBUUFCQUFJQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUNnQVRBQmNBSGdBYkFCb0FIZ0FYQUJZQUVnQWVBQnNBR0FBUEFCZ0FIQUJMQUVzQVN3QkxBRXNBU3dCTEFFc0FTd0JMQUJnQUdBQWVBQjRBSGdBVEFCNEFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFCWUFHd0FTQUI0QUhnQWVBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQVdBQTBBRVFBZUFBUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUFRQUJBQUVBQVFBQkFBRkFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBSkFCWUFHZ0FiQUJzQUd3QWVBQjBBSFFBZUFFOEFGd0FlQUEwQUhnQWVBQm9BR3dCUEFFOEFEZ0JRQUIwQUhRQWRBRThBVHdBWEFFOEFUd0JQQUJZQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFCMEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWRBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFGQUFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUFlQUI0QUhnQWVBRkFBVHdCQUFFOEFUd0JQQUVBQVR3QlFBRkFBVHdCUUFCNEFIZ0FlQUI0QUhnQWVBQjBBSFFBZEFCMEFIZ0FkQUI0QURnQlFBRkFBVUFCUUFGQUFIZ0FlQUI0QUhnQWVBQjRBSGdCUUFCNEFVQUFlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUpBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBa0FDUUFKQUFrQUNRQUpBQWtBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFlQUI0QUhnQWVBRkFBSGdBZUFCNEFLd0FyQUZBQVVBQlFBRkFBR0FCUUFDc0FLd0FyQUNzQUhnQWVBRkFBSGdCUUFGQUFVQUFyQUZBQUt3QWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBS3dBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUJBQUVBQVFBQkFBRUFBUUFCQUFlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FyQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUFyQUNzQVVBQWVBQjRBSGdBZUFCNEFIZ0JRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFBWUFBMEFLd0FyQUI0QUhnQWJBQ3NBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBRFFBRUFCNEFCQUFFQUI0QUJBQUVBQk1BQkFBckFDc0FLd0FyQUNzQUt3QXJBQ3NBVmdCV0FGWUFWZ0JXQUZZQVZnQldBRllBVmdCV0FGWUFWZ0JXQUZZQVZnQldBRllBVmdCV0FGWUFWZ0JXQUZZQVZnQldBRllBS3dBckFDc0FLd0JXQUZZQVZnQldBQjRBSGdBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFHZ0FhQUJvQUdBQVlBQjRBSGdBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFFd0FFQUNzQUV3QVRBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFCTEFFc0FTd0JMQUVzQVN3QkxBRXNBU3dCTEFCb0FHUUFaQUI0QVVBQlFBQVFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUJNQVVBQUVBQVFBQkFBRUFBUUFCQUFFQUI0QUhnQUVBQVFBQkFBRUFBUUFCQUJRQUZBQUJBQUVBQjRBQkFBRUFBUUFCQUJRQUZBQVN3QkxBRXNBU3dCTEFFc0FTd0JMQUVzQVN3QlFBRkFBVUFBZUFCNEFVQUFlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBS3dBZUFGQUFCQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQ3NBS3dCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFGQUFLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBRXNBU3dCTEFFc0FTd0JMQUVzQVN3QkxBRXNBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQVVBQlFBQjRBSGdBWUFCTUFVQUFyQUNzQUJBQWJBQnNBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUFFQUFRQUJBQUVBRkFBQkFBRUFBUUFCQUFFQUZBQUJBQUVBQVFBVUFBRUFBUUFCQUFFQUFRQUt3QXJBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUNzQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUFFQUFRQUJBQXJBQ3NBSGdBckFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUFyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFBckFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFCNEFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBQVFBQkFBRUFGQUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFVQUFFQUFRQUJBQUVBQVFBQkFBRUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFCQUFFQUEwQURRQkxBRXNBU3dCTEFFc0FTd0JMQUVzQVN3QkxBQjRBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQUVBQVFBQkFBckFGQUFVQUJRQUZBQVVBQlFBRkFBVUFBckFDc0FVQUJRQUNzQUt3QlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFLd0JRQUZBQVVBQlFBRkFBVUFCUUFDc0FVQUFyQUNzQUt3QlFBRkFBVUFCUUFDc0FLd0FFQUZBQUJBQUVBQVFBQkFBRUFBUUFCQUFyQUNzQUJBQUVBQ3NBS3dBRUFBUUFCQUJRQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FFQUNzQUt3QXJBQ3NBVUFCUUFDc0FVQUJRQUZBQUJBQUVBQ3NBS3dCTEFFc0FTd0JMQUVzQVN3QkxBRXNBU3dCTEFGQUFVQUFhQUJvQVVBQlFBRkFBVUFCUUFFd0FIZ0FiQUZBQUhnQUVBQ3NBS3dBRUFBUUFCQUFyQUZBQVVBQlFBRkFBVUFCUUFDc0FLd0FyQUNzQVVBQlFBQ3NBS3dCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQUt3QlFBRkFBVUFCUUFGQUFVQUJRQUNzQVVBQlFBQ3NBVUFCUUFDc0FVQUJRQUNzQUt3QUVBQ3NBQkFBRUFBUUFCQUFFQUNzQUt3QXJBQ3NBQkFBRUFDc0FLd0FFQUFRQUJBQXJBQ3NBS3dBRUFDc0FLd0FyQUNzQUt3QXJBQ3NBVUFCUUFGQUFVQUFyQUZBQUt3QXJBQ3NBS3dBckFDc0FLd0JMQUVzQVN3QkxBRXNBU3dCTEFFc0FTd0JMQUFRQUJBQlFBRkFBVUFBRUFCNEFLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FFQUFRQUJBQXJBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBQ3NBVUFCUUFGQUFLd0JRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBS3dCUUFGQUFVQUJRQUZBQVVBQlFBQ3NBVUFCUUFDc0FVQUJRQUZBQVVBQlFBQ3NBS3dBRUFGQUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFDc0FCQUFFQUFRQUt3QUVBQVFBQkFBckFDc0FVQUFyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dCUUFGQUFCQUFFQUNzQUt3QkxBRXNBU3dCTEFFc0FTd0JMQUVzQVN3QkxBQjRBR3dBckFDc0FLd0FyQUNzQUt3QXJBRkFBQkFBRUFBUUFCQUFFQUFRQUt3QUVBQVFBQkFBckFGQUFVQUJRQUZBQVVBQlFBRkFBVUFBckFDc0FVQUJRQUNzQUt3QlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFBUUFCQUFFQUFRQUJBQXJBQ3NBQkFBRUFDc0FLd0FFQUFRQUJBQXJBQ3NBS3dBckFDc0FLd0FyQUFRQUJBQUVBQ3NBS3dBckFDc0FVQUJRQUNzQVVBQlFBRkFBQkFBRUFDc0FLd0JMQUVzQVN3QkxBRXNBU3dCTEFFc0FTd0JMQUI0QVVBQlFBRkFBVUFCUUFGQUFVQUFyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUFRQVVBQXJBRkFBVUFCUUFGQUFVQUJRQUNzQUt3QXJBRkFBVUFCUUFDc0FVQUJRQUZBQVVBQXJBQ3NBS3dCUUFGQUFLd0JRQUNzQVVBQlFBQ3NBS3dBckFGQUFVQUFyQUNzQUt3QlFBRkFBVUFBckFDc0FLd0JRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQXJBQ3NBS3dBckFBUUFCQUFFQUFRQUJBQXJBQ3NBS3dBRUFBUUFCQUFyQUFRQUJBQUVBQVFBS3dBckFGQUFLd0FyQUNzQUt3QXJBQ3NBQkFBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFFc0FTd0JMQUVzQVN3QkxBRXNBU3dCTEFFc0FVQUJRQUZBQUhnQWVBQjRBSGdBZUFCNEFHd0FlQUNzQUt3QXJBQ3NBS3dBRUFBUUFCQUFFQUFRQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUNzQVVBQlFBRkFBS3dCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQXJBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQUt3QXJBQ3NBVUFBRUFBUUFCQUFFQUFRQUJBQUVBQ3NBQkFBRUFBUUFLd0FFQUFRQUJBQUVBQ3NBS3dBckFDc0FLd0FyQUNzQUJBQUVBQ3NBVUFCUUFGQUFLd0FyQUNzQUt3QXJBRkFBVUFBRUFBUUFLd0FyQUVzQVN3QkxBRXNBU3dCTEFFc0FTd0JMQUVzQUt3QXJBQ3NBS3dBckFDc0FLd0FPQUZBQVVBQlFBRkFBVUFCUUFGQUFIZ0JRQUFRQUJBQUVBQTRBVUFCUUFGQUFVQUJRQUZBQVVBQlFBQ3NBVUFCUUFGQUFLd0JRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFBckFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFLd0JRQUZBQVVBQlFBRkFBS3dBckFBUUFVQUFFQUFRQUJBQUVBQVFBQkFBRUFDc0FCQUFFQUFRQUt3QUVBQVFBQkFBRUFDc0FLd0FyQUNzQUt3QXJBQ3NBQkFBRUFDc0FLd0FyQUNzQUt3QXJBQ3NBVUFBckFGQUFVQUFFQUFRQUt3QXJBRXNBU3dCTEFFc0FTd0JMQUVzQVN3QkxBRXNBS3dCUUFGQUFLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QUVBQVFBQkFBRUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFDc0FVQUJRQUZBQUt3QlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBQkFBRUFGQUFCQUFFQUFRQUJBQUVBQVFBQkFBckFBUUFCQUFFQUNzQUJBQUVBQVFBQkFCUUFCNEFLd0FyQUNzQUt3QlFBRkFBVUFBRUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFCQUFFQUNzQUt3QkxBRXNBU3dCTEFFc0FTd0JMQUVzQVN3QkxBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBQm9BVUFCUUFGQUFVQUJRQUZBQUt3QUVBQVFBQkFBckFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFDc0FLd0FyQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQXJBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBQ3NBVUFBckFDc0FVQUJRQUZBQVVBQlFBRkFBVUFBckFDc0FLd0FFQUNzQUt3QXJBQ3NBQkFBRUFBUUFCQUFFQUFRQUt3QUVBQ3NBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQ3NBS3dBckFDc0FLd0FyQUVzQVN3QkxBRXNBU3dCTEFFc0FTd0JMQUVzQUt3QXJBQVFBQkFBZUFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUZ3QVhBQmNBRndBWEFCY0FGd0FYQUJjQUZ3QVhBQmNBRndBWEFCY0FGd0FYQUJjQUZ3QVhBQmNBRndBWEFCY0FGd0FYQUJjQUZ3QVhBQmNBRndBWEFBcUFGd0FYQUFxQUNvQUtnQXFBQ29BS2dBcUFDc0FLd0FyQUNzQUd3QmNBRndBWEFCY0FGd0FYQUJjQUNvQUtnQXFBQ29BS2dBcUFDb0FLZ0FlQUVzQVN3QkxBRXNBU3dCTEFFc0FTd0JMQUVzQURRQU5BQ3NBS3dBckFDc0FLd0JjQUZ3QUt3QmNBQ3NBWEFCY0FGd0FYQUJjQUNzQVhBQmNBRndBWEFCY0FGd0FYQUJjQUZ3QVhBQmNBRndBWEFCY0FGd0FYQUJjQUZ3QVhBQmNBQ3NBWEFBckFGd0FYQUJjQUZ3QVhBQmNBRndBWEFCY0FGd0FLZ0JjQUZ3QUtnQXFBQ29BS2dBcUFDb0FLZ0FxQUNvQVhBQXJBQ3NBWEFCY0FGd0FYQUJjQUNzQVhBQXJBQ29BS2dBcUFDb0FLZ0FxQUNzQUt3QkxBRXNBU3dCTEFFc0FTd0JMQUVzQVN3QkxBQ3NBS3dCY0FGd0FYQUJjQUZBQURnQU9BQTRBRGdBZUFBNEFEZ0FKQUE0QURnQU5BQWtBRXdBVEFCTUFFd0FUQUFrQUhnQVRBQjRBSGdBZUFBUUFCQUFlQUI0QUhnQWVBQjRBSGdCTEFFc0FTd0JMQUVzQVN3QkxBRXNBU3dCTEFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFEUUFFQUI0QUJBQWVBQVFBRmdBUkFCWUFFUUFFQUFRQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUNzQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFLd0FyQUNzQUt3QUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFEUUFFQUFRQUJBQUVBQVFBRFFBRUFBUUFVQUJRQUZBQVVBQlFBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBckFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQXJBQTBBRFFBZUFCNEFIZ0FlQUI0QUhnQUVBQjRBSGdBZUFCNEFIZ0FlQUNzQUhnQWVBQTRBRGdBTkFBNEFIZ0FlQUI0QUhnQWVBQWtBQ1FBckFDc0FLd0FyQUNzQVhBQmNBRndBWEFCY0FGd0FYQUJjQUZ3QVhBQmNBRndBWEFCY0FGd0FYQUJjQUZ3QVhBQmNBRndBWEFCY0FGd0FYQUJjQUZ3QVhBQmNBRndBWEFCY0FGd0FYQUJjQUNvQUtnQXFBQ29BS2dBcUFDb0FLZ0FxQUNvQUtnQXFBQ29BS2dBcUFDb0FLZ0FxQUNvQUtnQmNBRXNBU3dCTEFFc0FTd0JMQUVzQVN3QkxBRXNBRFFBTkFCNEFIZ0FlQUI0QVhBQmNBRndBWEFCY0FGd0FLZ0FxQUNvQUtnQmNBRndBWEFCY0FDb0FLZ0FxQUZ3QUtnQXFBQ29BWEFCY0FDb0FLZ0FxQUNvQUtnQXFBQ29BWEFCY0FGd0FLZ0FxQUNvQUtnQmNBRndBWEFCY0FGd0FYQUJjQUZ3QVhBQmNBRndBWEFCY0FDb0FLZ0FxQUNvQUtnQXFBQ29BS2dBcUFDb0FLZ0FxQUZ3QUtnQkxBRXNBU3dCTEFFc0FTd0JMQUVzQVN3QkxBQ29BS2dBcUFDb0FLZ0FxQUZBQVVBQlFBRkFBVUFCUUFDc0FVQUFyQUNzQUt3QXJBQ3NBVUFBckFDc0FVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFIZ0JRQUZBQVVBQlFBRmdBV0FCWUFGZ0FXQUJZQUZnQVdBQllBRmdBV0FCWUFGZ0FXQUJZQUZnQVdBQllBRmdBV0FCWUFGZ0FXQUJZQUZnQVdBQllBRmdBV0FCWUFGZ0FXQUJaQUZrQVdRQlpBRmtBV1FCWkFGa0FXUUJaQUZrQVdRQlpBRmtBV1FCWkFGa0FXUUJaQUZrQVdRQlpBRmtBV1FCWkFGa0FXUUJaQUZrQVdRQlpBRmtBV2dCYUFGb0FXZ0JhQUZvQVdnQmFBRm9BV2dCYUFGb0FXZ0JhQUZvQVdnQmFBRm9BV2dCYUFGb0FXZ0JhQUZvQVdnQmFBRm9BV2dCYUFGb0FXZ0JhQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUNzQVVBQlFBRkFBVUFBckFDc0FVQUJRQUZBQVVBQlFBRkFBVUFBckFGQUFLd0JRQUZBQVVBQlFBQ3NBS3dCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFBckFGQUFVQUJRQUZBQUt3QXJBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQXJBRkFBVUFCUUFGQUFLd0FyQUZBQVVBQlFBRkFBVUFCUUFGQUFLd0JRQUNzQVVBQlFBRkFBVUFBckFDc0FVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBS3dCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBS3dCUUFGQUFVQUJRQUNzQUt3QlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQXJBQ3NBQkFBRUFBUUFIZ0FOQUI0QUhnQWVBQjRBSGdBZUFCNEFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUNzQUt3QXJBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQXJBQ3NBS3dBckFDc0FLd0JRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBQ3NBS3dCUUFGQUFVQUJRQUZBQVVBQXJBQ3NBRFFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQUhnQWVBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQU5BRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQVdBQkVBS3dBckFDc0FVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUEwQURRQU5BRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFBckFDc0FLd0FyQUNzQUt3QXJBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFLd0JRQUZBQVVBQlFBQVFBQkFBRUFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0JRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUFFQUFRQUJBQU5BQTBBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBQkFBRUFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBS3dCUUFGQUFVQUFyQUFRQUJBQXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dCY0FGd0FYQUJjQUZ3QVhBQmNBRndBWEFCY0FGd0FYQUJjQUZ3QVhBQmNBRndBWEFCY0FGd0FLZ0FxQUNvQUtnQXFBQ29BS2dBcUFDb0FLZ0FxQUNvQUtnQXFBQ29BS2dBcUFDb0FLZ0FxQUEwQURRQVZBRndBRFFBZUFBMEFHd0JjQUNvQUt3QXJBRXNBU3dCTEFFc0FTd0JMQUVzQVN3QkxBRXNBS3dBckFDc0FLd0FyQUNzQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQXJBQ3NBS3dBckFDc0FLd0FlQUI0QUV3QVRBQTBBRFFBT0FCNEFFd0FUQUI0QUJBQUVBQVFBQ1FBckFFc0FTd0JMQUVzQVN3QkxBRXNBU3dCTEFFc0FLd0FyQUNzQUt3QXJBQ3NBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQXJBQ3NBS3dBckFDc0FLd0FyQUZBQVVBQlFBRkFBVUFBRUFBUUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFBUUFVQUFyQUNzQUt3QXJBQ3NBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUFyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBS3dBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFyQUNzQUt3QXJBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFDc0FLd0FyQUNzQUhnQXJBQ3NBS3dBVEFCTUFTd0JMQUVzQVN3QkxBRXNBU3dCTEFFc0FTd0JjQUZ3QVhBQmNBRndBWEFCY0FGd0FYQUJjQUZ3QVhBQmNBRndBWEFCY0FGd0FYQUFyQUNzQVhBQmNBRndBWEFCY0FDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0JjQUZ3QVhBQmNBRndBWEFCY0FGd0FYQUJjQUZ3QVhBQXJBQ3NBS3dBckFGd0FYQUJjQUZ3QVhBQmNBRndBWEFCY0FGd0FYQUJjQUZ3QVhBQmNBRndBWEFCY0FDc0FLd0FyQUNzQUt3QXJBRXNBU3dCTEFFc0FTd0JMQUVzQVN3QkxBRXNBWEFBckFDc0FLd0FxQUNvQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFBUUFCQUFFQUFRQUJBQXJBQ3NBSGdBZUFGd0FYQUJjQUZ3QVhBQmNBRndBWEFCY0FGd0FYQUJjQUZ3QVhBQmNBRndBWEFCY0FGd0FYQUJjQUNvQUtnQXFBQ29BS2dBcUFDb0FLZ0FxQUNvQUt3QXFBQ29BS2dBcUFDb0FLZ0FxQUNvQUtnQXFBQ29BS2dBcUFDb0FLZ0FxQUNvQUtnQXFBQ29BS2dBcUFDb0FLZ0FxQUNvQUtnQXFBQ29BS3dBckFBUUFTd0JMQUVzQVN3QkxBRXNBU3dCTEFFc0FTd0FyQUNzQUt3QXJBQ3NBS3dCTEFFc0FTd0JMQUVzQVN3QkxBRXNBU3dCTEFDc0FLd0FyQUNzQUt3QXJBQ29BS2dBcUFDb0FLZ0FxQUNvQVhBQXFBQ29BS2dBcUFDb0FLZ0FyQUNzQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBQkFBRUFBUUFCQUFFQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUFRQUJBQUVBQVFBQkFCUUFGQUFVQUJRQUZBQVVBQlFBQ3NBS3dBckFDc0FTd0JMQUVzQVN3QkxBRXNBU3dCTEFFc0FTd0FOQUEwQUhnQU5BQTBBRFFBTkFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFLd0FyQUNzQUJBQUVBQVFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQlFBRkFBU3dCTEFFc0FTd0JMQUVzQVN3QkxBRXNBU3dCUUFGQUFVQUJRQUZBQVVBQlFBRkFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FlQUI0QUhnQWVBRkFBVUFCUUFGQUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUNzQUt3QXJBQTBBRFFBTkFBMEFEUUJMQUVzQVN3QkxBRXNBU3dCTEFFc0FTd0JMQUNzQUt3QXJBRkFBVUFCUUFFc0FTd0JMQUVzQVN3QkxBRXNBU3dCTEFFc0FVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBQTBBRFFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFBckFDc0FLd0FyQUNzQUt3QXJBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBQ3NBS3dCUUFGQUFVQUFlQUI0QUhnQWVBQjRBSGdBZUFCNEFLd0FyQUNzQUt3QXJBQ3NBS3dBckFBUUFCQUFFQUI0QUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFCUUFGQUFVQUJRQUFRQVVBQlFBRkFBVUFCUUFGQUFCQUJRQUZBQUJBQUVBQVFBVUFBckFDc0FLd0FyQUNzQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUNzQUJBQUVBQVFBQkFBRUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUt3QXJBRkFBVUFCUUFGQUFVQUJRQUNzQUt3QlFBRkFBVUFCUUFGQUFVQUJRQUZBQUt3QlFBQ3NBVUFBckFGQUFLd0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQ3NBS3dBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FyQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0JRQUI0QUhnQWVBRkFBVUFCUUFDc0FIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0JRQUZBQVVBQlFBQ3NBS3dBZUFCNEFIZ0FlQUI0QUhnQXJBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBS3dBckFGQUFVQUJRQUNzQUhnQWVBQjRBSGdBZUFCNEFIZ0FPQUI0QUt3QU5BQTBBRFFBTkFBMEFEUUFOQUFrQURRQU5BQTBBQ0FBRUFBc0FCQUFFQUEwQUNRQU5BQTBBREFBZEFCMEFIZ0FYQUJjQUZnQVhBQmNBRndBV0FCY0FIUUFkQUI0QUhnQVVBQlFBRkFBTkFBRUFBUUFFQUFRQUJBQUVBQVFBQ1FBYUFCb0FHZ0FhQUJvQUdnQWFBQm9BSGdBWEFCY0FIUUFWQUJVQUhnQWVBQjRBSGdBZUFCNEFHQUFXQUJFQUZRQVZBQlVBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFEUUFlQUEwQURRQU5BQTBBSGdBTkFBMEFEUUFIQUI0QUhnQWVBQjRBS3dBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFGQUFVQUFyQUNzQVR3QlFBRkFBVUFCUUFGQUFIZ0FlQUI0QUZnQVJBRThBVUFCUEFFOEFUd0JQQUZBQVVBQlFBRkFBVUFBZUFCNEFIZ0FXQUJFQUt3QlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFDc0FLd0FyQUJzQUd3QWJBQnNBR3dBYkFCc0FHZ0FiQUJzQUd3QWJBQnNBR3dBYkFCc0FHd0FiQUJzQUd3QWJBQnNBR2dBYkFCc0FHd0FiQUJvQUd3QWJBQm9BR3dBYkFCc0FHd0FiQUJzQUd3QWJBQnNBR3dBYkFCc0FHd0FiQUJzQUd3QWJBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUhnQWVBRkFBR2dBZUFCMEFIZ0JRQUI0QUdnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQlBBQjRBVUFBYkFCNEFIZ0JRQUZBQVVBQlFBRkFBSGdBZUFCNEFIUUFkQUI0QVVBQWVBRkFBSGdCUUFCNEFVQUJQQUZBQVVBQWVBQjRBSGdBZUFCNEFIZ0FlQUZBQVVBQlFBRkFBVUFBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBRkFBSGdCUUFGQUFVQUJRQUU4QVR3QlFBRkFBVUFCUUFGQUFUd0JRQUZBQVR3QlFBRThBVHdCUEFFOEFUd0JQQUU4QVR3QlBBRThBVHdCUEFGQUFVQUJRQUZBQVR3QlBBRThBVHdCUEFFOEFUd0JQQUU4QVR3QlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQWVBQjRBVUFCUUFGQUFVQUJQQUI0QUhnQXJBQ3NBS3dBckFCMEFIUUFkQUIwQUhRQWRBQjBBSFFBZEFCMEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUIwQUhnQWRBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZEFCNEFIUUFkQUI0QUhnQWVBQjBBSFFBZUFCNEFIUUFlQUI0QUhnQWRBQjRBSFFBYkFCc0FIZ0FkQUI0QUhnQWVBQjRBSFFBZUFCNEFIUUFkQUIwQUhRQWVBQjRBSFFBZUFCMEFIZ0FkQUIwQUhRQWRBQjBBSFFBZUFCMEFIZ0FlQUI0QUhnQWVBQjBBSFFBZEFCMEFIZ0FlQUI0QUhnQWRBQjBBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZEFCNEFIZ0FlQUIwQUhnQWVBQjRBSGdBZUFCMEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWRBQjBBSGdBZUFCMEFIUUFkQUIwQUhnQWVBQjBBSFFBZUFCNEFIUUFkQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUIwQUhRQWVBQjRBSFFBZEFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhRQWVBQjRBSGdBZEFCNEFIZ0FlQUI0QUhnQWVBQjRBSFFBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjBBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUZBQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUJZQUVRQVdBQkVBSGdBZUFCNEFIZ0FlQUI0QUhRQWVBQjRBSGdBZUFCNEFIZ0FlQUNVQUpRQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQVdBQkVBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFKUUFsQUNVQUpRQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFFOEFUd0JQQUU4QVR3QlBBRThBVHdCUEFFOEFUd0JQQUU4QVR3QlBBRThBVHdCUEFFOEFUd0JQQUU4QVR3QlBBRThBVHdCUEFFOEFUd0JQQUU4QVR3QWRBQjBBSFFBZEFCMEFIUUFkQUIwQUhRQWRBQjBBSFFBZEFCMEFIUUFkQUIwQUhRQWRBQjBBSFFBZEFCMEFIUUFkQUIwQUhRQWRBQjBBSFFBZEFCMEFIUUFkQUU4QVR3QlBBRThBVHdCUEFFOEFUd0JQQUU4QVR3QlBBRThBVHdCUEFFOEFUd0JQQUU4QVR3QlBBRkFBSFFBZEFCMEFIUUFkQUIwQUhRQWRBQjBBSFFBZEFCMEFIZ0FlQUI0QUhnQWRBQjBBSFFBZEFCMEFIUUFkQUIwQUhRQWRBQjBBSFFBZEFCMEFIUUFkQUIwQUhRQWRBQjBBSFFBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIUUFkQUIwQUhRQWRBQjBBSFFBZEFCMEFIUUFkQUIwQUhRQWRBQjBBSFFBZUFCNEFIUUFkQUIwQUhRQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjBBSFFBZUFCMEFIUUFkQUIwQUhRQWRBQjBBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjBBSFFBZUFCNEFIUUFkQUI0QUhnQWVBQjRBSFFBZEFCNEFIZ0FlQUI0QUhRQWRBQjBBSGdBZUFCMEFIZ0FlQUIwQUhRQWRBQjBBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWRBQjBBSFFBZEFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCMEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBbEFDVUFKUUFsQUI0QUhRQWRBQjRBSGdBZEFCNEFIZ0FlQUI0QUhRQWRBQjRBSGdBZUFCNEFKUUFsQUIwQUhRQWxBQjRBSlFBbEFDVUFJQUFsQUNVQUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FsQUNVQUpRQWVBQjRBSGdBZUFCMEFIZ0FkQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWRBQjBBSGdBZEFCMEFIUUFlQUIwQUpRQWRBQjBBSGdBZEFCMEFIZ0FkQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFDVUFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhRQWRBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFkQUIwQUhRQWRBQ1VBSGdBbEFDVUFKUUFkQUNVQUpRQWRBQjBBSFFBbEFDVUFIUUFkQUNVQUhRQWRBQ1VBSlFBbEFCNEFIUUFlQUI0QUhnQWVBQjBBSFFBbEFCMEFIUUFkQUIwQUhRQWRBQ1VBSlFBbEFDVUFKUUFkQUNVQUpRQWdBQ1VBSFFBZEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBZUFCNEFIZ0FsQUNVQUlBQWdBQ0FBSUFBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjBBSGdBZUFCNEFGd0FYQUJjQUZ3QVhBQmNBSGdBVEFCTUFKUUFlQUI0QUhnQVdBQkVBRmdBUkFCWUFFUUFXQUJFQUZnQVJBQllBRVFBV0FCRUFUd0JQQUU4QVR3QlBBRThBVHdCUEFFOEFUd0JQQUU4QVR3QlBBRThBVHdCUEFFOEFUd0JQQUU4QVR3QWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCWUFFUUFlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FXQUJFQUZnQVJBQllBRVFBV0FCRUFGZ0FSQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUZnQVJBQllBRVFBV0FCRUFGZ0FSQUJZQUVRQVdBQkVBRmdBUkFCWUFFUUFXQUJFQUZnQVJBQllBRVFBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBV0FCRUFGZ0FSQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUZnQVJBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FkQUIwQUhRQWRBQjBBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FyQUNzQUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFLd0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QVVBQlFBRkFBVUFBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQUVBQVFBQkFBZUFCNEFLd0FyQUNzQUt3QXJBQk1BRFFBTkFBMEFVQUFUQUEwQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUNzQUt3QXJBQ3NBS3dBckFDc0FVQUFOQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBRUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QlFBRkFBVUFCUUFGQUFVQUJRQUNzQVVBQlFBRkFBVUFCUUFGQUFVQUFyQUZBQVVBQlFBRkFBVUFCUUFGQUFLd0JRQUZBQVVBQlFBRkFBVUFCUUFDc0FGd0FYQUJjQUZ3QVhBQmNBRndBWEFCY0FGd0FYQUJjQUZ3QVhBQTBBRFFBTkFBMEFEUUFOQUEwQURRQWVBQTBBRmdBTkFCNEFIZ0FYQUJjQUhnQWVBQmNBRndBV0FCRUFGZ0FSQUJZQUVRQVdBQkVBRFFBTkFBMEFEUUFUQUZBQURRQU5BQjRBRFFBTkFCNEFIZ0FlQUI0QUhnQU1BQXdBRFFBTkFBMEFIZ0FOQUEwQUZnQU5BQTBBRFFBTkFBMEFEUUFOQUEwQUhnQU5BQjRBRFFBTkFCNEFIZ0FlQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ3NBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FsQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQXJBQ3NBS3dBckFBMEFFUUFSQUNVQUpRQkhBRmNBVndBV0FCRUFGZ0FSQUJZQUVRQVdBQkVBRmdBUkFDVUFKUUFXQUJFQUZnQVJBQllBRVFBV0FCRUFGUUFXQUJFQUVRQWxBRmNBVndCWEFGY0FWd0JYQUZjQVZ3QlhBQVFBQkFBRUFBUUFCQUFFQUNVQVZ3QlhBRmNBVndBMkFDVUFKUUJYQUZjQVZ3QkhBRWNBSlFBbEFDVUFLd0JSQUZjQVVRQlhBRkVBVndCUkFGY0FVUUJYQUZjQVZ3QlhBRmNBVndCWEFGY0FWd0JYQUZjQVZ3QlhBRmNBVndCWEFGY0FWd0JYQUZjQVZ3QlhBRmNBVndCWEFGRUFWd0JYQUZjQVZ3QlhBRmNBVndCWEFGY0FWd0JYQUZjQVZ3QlhBRmNBVndCWEFGY0FWd0JYQUZjQVZ3QlhBRmNBVndCWEFGY0FWd0JYQUZjQVZ3QlJBRmNBVVFCWEFGRUFWd0JYQUZjQVZ3QlhBRmNBVVFCWEFGY0FWd0JYQUZjQVZ3QlJBRkVBS3dBckFBUUFCQUFWQUJVQVJ3QkhBRmNBRlFCUkFGY0FVUUJYQUZFQVZ3QlJBRmNBVVFCWEFGY0FWd0JYQUZjQVZ3QlhBRmNBVndCWEFGY0FWd0JYQUZjQVZ3QlhBRmNBVndCWEFGY0FWd0JYQUZjQVZ3QlhBRkVBVndCUkFGY0FVUUJYQUZjQVZ3QlhBRmNBVndCUkFGY0FWd0JYQUZjQVZ3QlhBRkVBVVFCWEFGY0FWd0JYQUJVQVVRQkhBRWNBVndBckFDc0FLd0FyQUNzQVZ3QlhBRmNBVndCWEFGY0FWd0JYQUZjQVZ3QlhBRmNBVndCWEFGY0FWd0JYQUZjQVZ3QlhBRmNBVndCWEFGY0FWd0JYQUZjQUt3QlhBRmNBVndCWEFGY0FWd0JYQUZjQVZ3QlhBRmNBVndCWEFGY0FWd0JYQUZjQVZ3QlhBRmNBVndCWEFGY0FWd0JYQUZjQVZ3QlhBRmNBVndCWEFGY0FWd0JYQUZjQVZ3QlhBRmNBS3dBbEFDVUFWd0JYQUZjQVZ3QWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFGRUFVUUJSQUZFQVVRQlJBRkVBVVFCUkFGRUFVUUJSQUZFQVVRQlJBRkVBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFyQUZjQVZ3QlhBRmNBVndCWEFGY0FWd0JYQUZjQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFCUEFFOEFUd0JQQUU4QVR3QlBBRThBSlFCWEFGY0FWd0JYQUZjQVZ3QlhBRmNBVndCWEFGY0FWd0JYQUZjQVZ3QWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQVZ3QlhBRmNBVndCWEFGY0FWd0JYQUZjQVZ3QlhBRmNBVndCWEFGY0FWd0JYQUZjQVZ3QlhBRmNBVndCWEFGY0FWd0JYQUZjQVZ3QlhBRmNBVndCWEFDVUFKUUFsQUZjQVZ3QlhBRmNBVndCWEFGY0FWd0JYQUZjQVZ3QlhBRmNBVndCWEFGY0FWd0JYQUZjQVZ3QlhBRWNBVndCWEFGY0FWd0JYQUZjQVZ3QlhBRmNBVndCWEFGY0FWd0JYQUZjQUt3QXJBQ3NBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBRFFBVEFBMEFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCTEFFc0FTd0JMQUVzQVN3QkxBRXNBU3dCTEFGQUFVQUFyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFGQUFCQUFFQUFRQUJBQWVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBSGdCUUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFVQUJRQUFRQUJBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUFRQUJBQWVBQTBBRFFBTkFBMEFEUUFyQUNzQUt3QXJBQ3NBS3dBckFDc0FIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QVVBQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0JRQUI0QUhnQWVBQjRBSGdBZUFGQUFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBckFDc0FIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QWVBQjRBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFBUUFVQUJRQUZBQUJBQlFBRkFBVUFCUUFBUUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBQVFBQkFBRUFBUUFCQUFlQUI0QUhnQWVBQVFBS3dBckFDc0FVQUJRQUZBQVVBQlFBRkFBSGdBZUFCb0FIZ0FyQUNzQUt3QXJBQ3NBS3dCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFEZ0FPQUJNQUV3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUJBQUVBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFBUUFCQUFFQUFRQUJBQUVBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QU5BQTBBU3dCTEFFc0FTd0JMQUVzQVN3QkxBRXNBU3dBckFDc0FLd0FyQUNzQUt3QUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQlFBRkFBVUFCUUFGQUFVQUFlQUI0QUhnQlFBQTRBVUFCUUFBUUFVQUJRQUZBQVVBQlFBRkFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQTBBRFFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQjRBV0FCWUFGZ0FXQUJZQUZnQVdBQllBRmdBV0FCWUFGZ0FXQUJZQUZnQVdBQllBRmdBV0FCWUFGZ0FXQUJZQUZnQVdBQllBRmdBV0FCWUFDc0FLd0FyQUFRQUhnQWVBQjRBSGdBZUFCNEFEUUFOQUEwQUhnQWVBQjRBSGdBckFGQUFTd0JMQUVzQVN3QkxBRXNBU3dCTEFFc0FTd0FyQUNzQUt3QXJBQjRBSGdCY0FGd0FYQUJjQUZ3QUtnQmNBRndBWEFCY0FGd0FYQUJjQUZ3QVhBQmNBRXNBU3dCTEFFc0FTd0JMQUVzQVN3QkxBRXNBWEFCY0FGd0FYQUJjQUNzQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFGQUFVQUJRQUFRQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUFRQUJBQXJBQ3NBU3dCTEFFc0FTd0JMQUVzQVN3QkxBRXNBU3dBckFDc0FIZ0FOQUEwQURRQmNBRndBWEFCY0FGd0FYQUJjQUZ3QVhBQmNBRndBWEFCY0FGd0FYQUJjQUZ3QVhBQmNBRndBWEFCY0FGd0FLZ0FxQUNvQVhBQXFBQ29BS2dCY0FGd0FYQUJjQUZ3QVhBQmNBRndBWEFCY0FGd0FYQUJjQUZ3QVhBQmNBRndBWEFBcUFGd0FLZ0FxQUNvQVhBQmNBQ29BS2dCY0FGd0FYQUJjQUZ3QUtnQXFBRndBS2dCY0FDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBRndBWEFCY0FDb0FLZ0JRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQUJBQUVBQVFBQkFBRUFBMEFEUUJRQUZBQVVBQUVBQVFBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dCUUFGQUFVQUJRQUZBQVVBQXJBQ3NBVUFCUUFGQUFVQUJRQUZBQUt3QXJBRkFBVUFCUUFGQUFVQUJRQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUZBQVVBQlFBRkFBVUFCUUFGQUFLd0JRQUZBQVVBQlFBRkFBVUFCUUFDc0FVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFIZ0FlQUNzQUt3QXJBQ3NBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBRFFBRUFBUUFLd0FyQUVzQVN3QkxBRXNBU3dCTEFFc0FTd0JMQUVzQUt3QXJBQ3NBS3dBckFDc0FWQUJWQUZVQVZRQlZBRlVBVlFCVkFGVUFWUUJWQUZVQVZRQlZBRlVBVlFCVkFGVUFWUUJWQUZVQVZRQlZBRlVBVlFCVkFGVUFWUUJVQUZVQVZRQlZBRlVBVlFCVkFGVUFWUUJWQUZVQVZRQlZBRlVBVlFCVkFGVUFWUUJWQUZVQVZRQlZBRlVBVlFCVkFGVUFWUUJWQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBRmtBV1FCWkFGa0FXUUJaQUZrQVdRQlpBRmtBV1FCWkFGa0FXUUJaQUZrQVdRQlpBRmtBS3dBckFDc0FLd0JhQUZvQVdnQmFBRm9BV2dCYUFGb0FXZ0JhQUZvQVdnQmFBRm9BV2dCYUFGb0FXZ0JhQUZvQVdnQmFBRm9BV2dCYUFGb0FXZ0JhQUZvQUt3QXJBQ3NBS3dBR0FBWUFCZ0FHQUFZQUJnQUdBQVlBQmdBR0FBWUFCZ0FHQUFZQUJnQUdBQVlBQmdBR0FBWUFCZ0FHQUFZQUJnQUdBQVlBQmdBR0FBWUFCZ0FHQUFZQVZ3QlhBRmNBVndCWEFGY0FWd0JYQUZjQVZ3QlhBRmNBVndCWEFDVUFKUUJYQUZjQVZ3QlhBRmNBVndCWEFGY0FWd0JYQUZjQVZ3QlhBRmNBVndCWEFGY0FWd0JYQUZjQVZ3QlhBRmNBVndCWEFGY0FKUUFsQUNVQUpRQWxBQ1VBVUFCUUFGQUFVQUJRQUZBQVVBQXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dCUUFGQUFVQUJRQUZBQUt3QXJBQ3NBS3dBckFGWUFCQUJXQUZZQVZnQldBRllBVmdCV0FGWUFWZ0JXQUI0QVZnQldBRllBVmdCV0FGWUFWZ0JXQUZZQVZnQldBRllBVmdBckFGWUFWZ0JXQUZZQVZnQXJBRllBS3dCV0FGWUFLd0JXQUZZQUt3QldBRllBVmdCV0FGWUFWZ0JXQUZZQVZnQldBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBRVFBV0FGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBS3dBckFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0JRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQWFBQjRBS3dBckFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBR0FBUkFCRUFHQUFZQUJNQUV3QVdBQkVBRkFBckFDc0FLd0FyQUNzQUt3QUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUNVQUpRQWxBQ1VBSlFBV0FCRUFGZ0FSQUJZQUVRQVdBQkVBRmdBUkFCWUFFUUFsQUNVQUZnQVJBQ1VBSlFBbEFDVUFKUUFsQUNVQUVRQWxBQkVBS3dBVkFCVUFFd0FUQUNVQUZnQVJBQllBRVFBV0FCRUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDc0FKUUFiQUJvQUpRQXJBQ3NBS3dBckFGQUFVQUJRQUZBQVVBQXJBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFLd0FyQUFjQUt3QVRBQ1VBSlFBYkFCb0FKUUFsQUJZQUVRQWxBQ1VBRVFBbEFCRUFKUUJYQUZjQVZ3QlhBRmNBVndCWEFGY0FWd0JYQUJVQUZRQWxBQ1VBSlFBVEFDVUFWd0JYQUZjQVZ3QlhBRmNBVndCWEFGY0FWd0JYQUZjQVZ3QlhBRmNBVndCWEFGY0FWd0JYQUZjQVZ3QlhBRmNBVndCWEFCWUFKUUFSQUNVQUpRQWxBRmNBVndCWEFGY0FWd0JYQUZjQVZ3QlhBRmNBVndCWEFGY0FWd0JYQUZjQVZ3QlhBRmNBVndCWEFGY0FWd0JYQUZjQVZ3QVdBQ1VBRVFBbEFCWUFFUUFSQUJZQUVRQVJBQlVBVndCUkFGRUFVUUJSQUZFQVVRQlJBRkVBVVFCUkFGY0FWd0JYQUZjQVZ3QlhBRmNBVndCWEFGY0FWd0JYQUZjQVZ3QlhBRmNBVndCWEFGY0FWd0JYQUZjQVZ3QlhBRmNBVndCWEFGY0FWd0JYQUZjQVZ3QlhBRWNBUndBckFDc0FWd0JYQUZjQVZ3QlhBRmNBS3dBckFGY0FWd0JYQUZjQVZ3QlhBQ3NBS3dCWEFGY0FWd0JYQUZjQVZ3QXJBQ3NBVndCWEFGY0FLd0FyQUNzQUdnQWJBQ1VBSlFBbEFCc0FHd0FyQUI0QUhnQWVBQjRBSGdBZUFCNEFLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FFQUFRQUJBQVFBQjBBS3dBckFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUNzQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFBckFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFLd0JRQUZBQUt3QlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUFyQUNzQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFDc0FLd0JRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUFyQUNzQUt3QXJBQ3NBRFFBTkFBMEFLd0FyQUNzQUt3QlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUNzQUt3QXJBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdCUUFGQUFIZ0FlQUI0QUt3QWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQVFBS3dBckFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUFyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBRUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQUt3QXJBQ3NBS3dBckFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQUJBQUVBQVFBQkFBRUFDc0FLd0FyQUNzQUt3QlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFBckFBMEFVQUJRQUZBQVVBQXJBQ3NBS3dBckFGQUFVQUJRQUZBQVVBQlFBRkFBVUFBTkFGQUFVQUJRQUZBQVVBQXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFDc0FLd0JRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQUt3QXJBQ3NBS3dCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBZUFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBVUFCUUFGQUFVQUJRQUZBQUt3QXJBRkFBS3dCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQXJBRkFBVUFBckFDc0FLd0JRQUNzQUt3QlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFLd0FOQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFBZUFCNEFVQUJRQUZBQVVBQlFBRkFBVUFBckFDc0FLd0FyQUNzQUt3QXJBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQXJBRkFBVUFBckFDc0FLd0FyQUNzQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBQ3NBS3dBckFBMEFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFDc0FLd0FyQUNzQUt3QWVBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUNzQUt3QXJBQ3NBVUFCUUFGQUFVQUJRQUFRQUJBQUVBQ3NBQkFBRUFDc0FLd0FyQUNzQUt3QUVBQVFBQkFBRUFGQUFVQUJRQUZBQUt3QlFBRkFBVUFBckFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBS3dBckFBUUFCQUFFQUNzQUt3QXJBQ3NBQkFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFBckFDc0FLd0FyQUNzQUt3QXJBQTBBRFFBTkFBMEFEUUFOQUEwQURRQWVBQ3NBS3dBckFDc0FLd0FyQUNzQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFBZUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFBZUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBQVFBQkFBckFDc0FLd0FyQUZBQVVBQlFBRkFBVUFBTkFBMEFEUUFOQUEwQURRQVVBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFLd0FyQUNzQURRQU5BQTBBRFFBTkFBMEFEUUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUFyQUNzQUt3QXJBQ3NBS3dBckFCNEFIZ0FlQUI0QUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBVUFCUUFGQUFVQUJRQUZBQVVBQXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQXJBQ3NBS3dBckFDc0FLd0FyQUZBQVVBQlFBRkFBVUFCUUFBUUFCQUFFQUFRQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUVzQVN3QkxBRXNBU3dCTEFFc0FTd0JMQUVzQUt3QXJBQ3NBS3dBckFDc0FVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUFyQUFRQUJBQU5BQ3NBS3dCUUFGQUFLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBRkFBVUFCUUFGQUFVQUJRQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQlFBRkFBVUFCUUFCNEFIZ0FlQUI0QUhnQXJBQ3NBS3dBckFDc0FLd0FFQUFRQUJBQUVBQVFBQkFBRUFBMEFEUUFlQUI0QUhnQWVBQjRBS3dBckFDc0FLd0JRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFFc0FTd0JMQUVzQVN3QkxBRXNBU3dCTEFFc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBQkFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBZUFCNEFIZ0FOQUEwQURRQU5BQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBZUFDc0FLd0JRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFLd0FyQUNzQUt3QXJBQ3NBS3dCTEFFc0FTd0JMQUVzQVN3QkxBRXNBU3dCTEFDc0FLd0FyQUNzQUt3QXJBRkFBVUFCUUFGQUFVQUJRQUZBQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFDc0FTd0JMQUVzQVN3QkxBRXNBU3dCTEFFc0FTd0FOQUEwQURRQU5BRkFBQkFBRUFGQUFLd0FyQUNzQUt3QXJBQ3NBS3dBckFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFCQUFlQUE0QVVBQXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QUVBRkFBVUFCUUFGQUFEUUFOQUI0QURRQUVBQVFBQkFBRUFCNEFCQUFFQUVzQVN3QkxBRXNBU3dCTEFFc0FTd0JMQUVzQVVBQU9BRkFBRFFBTkFBMEFLd0JRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBQ3NBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQU5BQTBBSGdBTkFBMEFIZ0FFQUNzQVVBQlFBRkFBVUFCUUFGQUFVQUFyQUZBQUt3QlFBRkFBVUFCUUFDc0FVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBS3dCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFBMEFLd0FyQUNzQUt3QXJBQ3NBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBS3dBckFDc0FLd0FyQUVzQVN3QkxBRXNBU3dCTEFFc0FTd0JMQUVzQUt3QXJBQ3NBS3dBckFDc0FCQUFFQUFRQUJBQXJBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQXJBQ3NBVUFCUUFDc0FLd0JRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBS3dCUUFGQUFVQUJRQUZBQVVBQlFBQ3NBVUFCUUFDc0FVQUJRQUZBQVVBQlFBQ3NBQkFBRUFGQUFCQUFFQUFRQUJBQUVBQVFBQkFBckFDc0FCQUFFQUNzQUt3QUVBQVFBQkFBckFDc0FVQUFyQUNzQUt3QXJBQ3NBS3dBRUFDc0FLd0FyQUNzQUt3QlFBRkFBVUFCUUFGQUFCQUFFQUNzQUt3QUVBQVFBQkFBRUFBUUFCQUFFQUNzQUt3QXJBQVFBQkFBRUFBUUFCQUFyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUJBQUVBQVFBQkFBRUFBUUFCQUJRQUZBQVVBQlFBQTBBRFFBTkFBMEFIZ0JMQUVzQVN3QkxBRXNBU3dCTEFFc0FTd0JMQUEwQURRQXJBQjRBQkFCUUFGQUFVQUFyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QUVBQVFBQkFBRUFGQUFVQUFlQUZBQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUVzQVN3QkxBRXNBU3dCTEFFc0FTd0JMQUVzQUt3QXJBQ3NBS3dBckFDc0FVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBQkFBRUFBUUFCQUFFQUFRQUJBQXJBQ3NBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBRGdBTkFBMEFFd0FUQUI0QUhnQWVBQTBBRFFBTkFBMEFEUUFOQUEwQURRQU5BQTBBRFFBTkFBMEFEUUFOQUZBQVVBQlFBRkFBQkFBRUFDc0FLd0FFQUEwQURRQWVBRkFBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFFc0FTd0JMQUVzQVN3QkxBRXNBU3dCTEFFc0FLd0FyQUNzQUt3QXJBQ3NBRGdBT0FBNEFEZ0FPQUE0QURnQU9BQTRBRGdBT0FBNEFEZ0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFGQUFLd0FyQUNzQUt3QXJBQ3NBS3dCTEFFc0FTd0JMQUVzQVN3QkxBRXNBU3dCTEFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQVhBQmNBRndBWEFCY0FGd0FYQUJjQUZ3QVhBQmNBRndBWEFCY0FGd0FYQUJjQUZ3QVhBQmNBRndBWEFCY0FGd0FYQUJjQUZ3QUt3QXJBQ29BS2dBcUFDb0FLZ0FxQUNvQUtnQXFBQ29BS2dBcUFDb0FLZ0FxQUNzQUt3QXJBQ3NBU3dCTEFFc0FTd0JMQUVzQVN3QkxBRXNBU3dCY0FGd0FEUUFOQUEwQUtnQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQWVBQ3NBS3dBckFDc0FTd0JMQUVzQVN3QkxBRXNBU3dCTEFFc0FTd0JRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUFyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QlFBRkFBVUFCUUFGQUFVQUJRQUZBQUt3QXJBRkFBS3dBckFGQUFVQUJRQUZBQVVBQlFBRkFBVUFBckFGQUFVQUFyQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFCQUFFQUFRQUJBQUVBQVFBS3dBRUFBUUFLd0FyQUFRQUJBQUVBQVFBVUFBRUFGQUFCQUFFQUEwQURRQU5BQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBRXNBU3dCTEFFc0FTd0JMQUVzQVN3QkxBRXNBS3dBckFDc0FLd0FyQUNzQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUNzQUt3QlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFCQUFFQUFRQUJBQUVBQVFBQkFBckFDc0FCQUFFQUFRQUJBQUVBQVFBQkFCUUFBNEFVQUFFQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUZBQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUFFQUFRQUJBQUVBQVFBQkFBRUFGQUFCQUFFQUFRQUJBQU9BQjRBRFFBTkFBMEFEUUFPQUI0QUJBQXJBQ3NBS3dBckFDc0FLd0FyQUNzQVVBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQTBBRFFBTkFGQUFEZ0FPQUE0QURRQU5BQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFBckFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQ3NBQkFBRUFBUUFCQUFFQUFRQUJBQUVBRkFBRFFBTkFBMEFEUUFOQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQVN3QkxBRXNBU3dCTEFFc0FTd0JMQUVzQVN3QlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUFyQUNzQUt3QU9BQk1BVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBS3dBckFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQXJBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0JRQUZBQVVBQlFBRkFBVUFCUUFDc0FVQUJRQUNzQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFBRUFBUUFCQUFFQUFRQUJBQXJBQ3NBS3dBRUFDc0FCQUFFQUNzQUJBQUVBQVFBQkFBRUFBUUFCQUJRQUFRQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUVzQVN3QkxBRXNBU3dCTEFFc0FTd0JMQUVzQUt3QXJBQ3NBS3dBckFDc0FVQUJRQUZBQVVBQlFBRkFBS3dCUUFGQUFLd0JRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFBRUFBUUFCQUFFQUFRQUt3QUVBQVFBS3dBRUFBUUFCQUFFQUFRQVVBQXJBQ3NBS3dBckFDc0FLd0FyQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQUJBQUVBQVFBQkFBZUFCNEFLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0JRQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FhQUJvQUdnQWFBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFBMEFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFDc0FLd0FyQUNzQUt3QXJBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUNzQURRQU5BQTBBRFFBTkFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0JRQUZBQVVBQlFBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVNBQklBRWdBUXdCREFFTUFVQUJRQUZBQVVBQkRBRkFBVUFCUUFFZ0FRd0JJQUVNQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVNBQkRBRU1BVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQUt3QUpBQWtBQ1FBSkFBa0FDUUFKQUJZQUVRQXJBQ3NBS3dBckFDc0FLd0FyQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCSUFFTUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUFyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFFc0FTd0JMQUVzQVN3QkxBRXNBU3dCTEFFc0FLd0FyQUNzQUt3QU5BQTBBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFLd0FyQUFRQUJBQUVBQVFBQkFBTkFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFBRUFBUUFCQUFFQUFRQUJBQUVBQTBBRFFBTkFCNEFIZ0FlQUI0QUhnQWVBRkFBVUFCUUFGQUFEUUFlQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQVN3QkxBRXNBU3dCTEFFc0FTd0JMQUVzQVN3QXJBRkFBVUFCUUFGQUFVQUJRQUZBQUt3QlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFBckFDc0FLd0FyQUNzQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFBTkFBMEFIZ0FlQUNzQUt3QXJBQ3NBS3dCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFLd0FyQUNzQUt3QUVBRkFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUt3QXJBQ3NBS3dBckFDc0FLd0FFQUFRQUJBQUVBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFSd0JIQUJVQVJ3QUpBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBRUFBUUFLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBRmNBVndCWEFGY0FWd0JYQUZjQVZ3QlhBRmNBVndCWEFGY0FWd0JYQUZjQVZ3QlhBRmNBVndCWEFGY0FWd0JYQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0JYQUZjQVZ3QlhBRmNBVndCWEFGY0FWd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBVVFCUkFGRUFLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QlJBRkVBVVFCUkFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dCWEFGY0FWd0JYQUZjQVZ3QlhBRmNBVndCWEFGY0FWd0JYQUZjQVZ3QlhBRmNBVndCWEFGY0FWd0JYQUZjQVZ3QlhBRmNBVndCWEFDc0FLd0FyQUNzQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBQ3NBS3dBckFDc0FLd0JRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBQ3NBS3dBckFDc0FLd0FyQUNzQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQXJBQ3NBSGdBRUFBUUFEUUFFQUFRQUJBQUVBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUI0QUhnQWVBQjRBSGdBZUFCNEFLd0FyQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFBUUFCQUFFQUFRQUJBQWVBQjRBSGdBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUI0QUhnQUVBQVFBQkFBRUFBUUFCQUFFQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBQkFBRUFBUUFCQUFlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUJBQUVBQVFBSGdBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FyQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBS3dCUUFGQUFLd0FyQUZBQUt3QXJBRkFBVUFBckFDc0FVQUJRQUZBQVVBQXJBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFDc0FVQUFyQUZBQVVBQlFBRkFBVUFCUUFGQUFLd0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUt3QlFBRkFBVUFCUUFDc0FLd0JRQUZBQVVBQlFBRkFBVUFCUUFGQUFLd0JRQUZBQVVBQlFBRkFBVUFCUUFDc0FIZ0FlQUZBQVVBQlFBRkFBVUFBckFGQUFLd0FyQUNzQVVBQlFBRkFBVUFCUUFGQUFVQUFyQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFLd0FyQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFIZ0JRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUNzQUt3QkxBRXNBU3dCTEFFc0FTd0JMQUVzQVN3QkxBRXNBU3dCTEFFc0FTd0JMQUVzQVN3QkxBRXNBU3dCTEFFc0FTd0JMQUVzQVN3QkxBRXNBU3dCTEFFc0FTd0JMQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBZUFCNEFIZ0FlQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBQkFBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFBUUFIZ0FlQUEwQURRQU5BQTBBSGdBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QUVBQVFBQkFBRUFBUUFLd0FFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQVFBQkFBRUFBUUFCQUFFQUFRQUt3QUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUt3QXJBQVFBQkFBRUFBUUFCQUFFQUFRQUt3QUVBQVFBS3dBRUFBUUFCQUFFQUFRQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUFyQUNzQUt3QUVBQVFBQkFBRUFBUUFCQUFFQUZBQVVBQlFBRkFBVUFCUUFGQUFLd0FyQUVzQVN3QkxBRXNBU3dCTEFFc0FTd0JMQUVzQUt3QXJBQ3NBS3dCUUFCNEFLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUFFQUFRQUJBQUVBRXNBU3dCTEFFc0FTd0JMQUVzQVN3QkxBRXNBS3dBckFDc0FLd0FyQUJzQVVBQlFBRkFBVUFCUUFDc0FLd0JRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUFFQUFRQUJBQUVBQVFBQkFBRUFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFCNEFIZ0FlQUI0QUJBQUVBQVFBQkFBRUFBUUFCQUJRQUNzQUt3QXJBQ3NBU3dCTEFFc0FTd0JMQUVzQVN3QkxBRXNBU3dBckFDc0FLd0FyQUJZQUZnQXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFHZ0JRQUZBQVVBQWFBRkFBVUFCUUFGQUFLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFBZUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBQ3NBS3dCUUFGQUFVQUJRQUNzQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQUt3QlFBRkFBS3dCUUFDc0FLd0JRQUNzQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQXJBRkFBVUFCUUFGQUFLd0JRQUNzQVVBQXJBQ3NBS3dBckFDc0FLd0JRQUNzQUt3QXJBQ3NBVUFBckFGQUFLd0JRQUNzQVVBQlFBRkFBS3dCUUFGQUFLd0JRQUNzQUt3QlFBQ3NBVUFBckFGQUFLd0JRQUNzQVVBQXJBRkFBVUFBckFGQUFLd0FyQUZBQVVBQlFBRkFBS3dCUUFGQUFVQUJRQUZBQVVBQlFBQ3NBVUFCUUFGQUFVQUFyQUZBQVVBQlFBRkFBS3dCUUFDc0FVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUFyQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUFyQUNzQUt3QXJBQ3NBVUFCUUFGQUFLd0JRQUZBQVVBQlFBRkFBS3dCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QWVBQjRBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUU4QVR3QlBBRThBVHdCUEFFOEFUd0JQQUU4QVR3QlBBRThBSlFBbEFDVUFIUUFkQUIwQUhRQWRBQjBBSFFBZEFCMEFIUUFkQUIwQUhRQWRBQjBBSFFBZEFCMEFIZ0FlQUIwQUhRQWRBQjBBSFFBZEFCMEFIUUFkQUIwQUhRQWRBQjBBSFFBZEFCMEFIUUFkQUI0QUhnQWVBQ1VBSlFBbEFCMEFIUUFkQUIwQUhRQWRBQjBBSFFBZEFCMEFIUUFkQUIwQUhRQWRBQjBBSFFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFwQUNrQUtRQXBBQ2tBS1FBcEFDa0FLUUFwQUNrQUtRQXBBQ2tBS1FBcEFDa0FLUUFwQUNrQUtRQXBBQ2tBS1FBcEFDa0FKUUFsQUNVQUpRQWxBQ0FBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFlQUI0QUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFCNEFIZ0FsQUNVQUpRQWxBQ1VBSGdBbEFDVUFKUUFsQUNVQUlBQWdBQ0FBSlFBbEFDQUFKUUFsQUNBQUlBQWdBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDRUFJUUFoQUNFQUlRQWxBQ1VBSUFBZ0FDVUFKUUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUpRQWxBQ1VBSUFBbEFDVUFKUUFsQUNBQUlBQWdBQ1VBSUFBZ0FDQUFKUUFsQUNVQUpRQWxBQ1VBSlFBZ0FDVUFJQUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSGdBbEFCNEFKUUFlQUNVQUpRQWxBQ1VBSlFBZ0FDVUFKUUFsQUNVQUhnQWxBQjRBSGdBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUI0QUhnQWVBQjRBSGdBZUFCNEFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FsQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ0FBSUFBbEFDVUFKUUFsQUNBQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNBQUpRQWxBQ1VBSlFBZ0FDQUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWVBQjRBSGdBZUFCNEFIZ0FsQUNVQUpRQWxBQ1VBSlFBbEFDQUFJQUFnQUNVQUpRQWxBQ0FBSUFBZ0FDQUFJQUFlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQmNBRndBWEFCVUFGUUFWQUI0QUhnQWVBQjRBSlFBbEFDVUFJQUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDQUFJQUFnQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNBQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ0FBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSlFBbEFDVUFKUUFlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFDVUFKUUFsQUNVQUpRQWxBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FnQUNVQUpRQWdBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUpRQWxBQ1VBSlFBbEFDVUFJQUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNVQUpRQWdBQ0FBSUFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWdBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDQUFJQUFsQUNBQUlBQWxBQ0FBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFnQUNBQUlBQWxBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFKUUFsQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUt3QWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBRXNBU3dCTEFFc0FTd0JMQUVzQVN3QkxBRXNBS3dBckFDc0FLd0FyQUNzQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBS3dBckFGY0FWd0JYQUZjQVZ3QlhBRmNBVndCWEFGY0FWd0JYQUZjQVZ3QlhBRmNBVndCWEFGY0FWd0JYQUZjQVZ3QlhBRmNBVndCWEFGY0FWd0JYQUNVQUpRQlhBRmNBVndCWEFGY0FWd0JYQUZjQVZ3QlhBRmNBVndCWEFGY0FWd0JYQUZjQVZ3QlhBRmNBVndBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFWd0JYQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFCWEFGY0FWd0JYQUZjQVZ3QlhBRmNBVndCWEFGY0FWd0JYQUZjQVZ3QlhBRmNBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUJYQUZjQVZ3QlhBRmNBVndCWEFGY0FWd0JYQUZjQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBS3dBRUFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUE9PSc7XG5cbiAgICB2YXIgTEVUVEVSX05VTUJFUl9NT0RJRklFUiA9IDUwO1xuICAgIC8vIE5vbi10YWlsb3JhYmxlIExpbmUgQnJlYWtpbmcgQ2xhc3Nlc1xuICAgIHZhciBCSyA9IDE7IC8vICBDYXVzZSBhIGxpbmUgYnJlYWsgKGFmdGVyKVxuICAgIHZhciBDUiQxID0gMjsgLy8gIENhdXNlIGEgbGluZSBicmVhayAoYWZ0ZXIpLCBleGNlcHQgYmV0d2VlbiBDUiBhbmQgTEZcbiAgICB2YXIgTEYkMSA9IDM7IC8vICBDYXVzZSBhIGxpbmUgYnJlYWsgKGFmdGVyKVxuICAgIHZhciBDTSA9IDQ7IC8vICBQcm9oaWJpdCBhIGxpbmUgYnJlYWsgYmV0d2VlbiB0aGUgY2hhcmFjdGVyIGFuZCB0aGUgcHJlY2VkaW5nIGNoYXJhY3RlclxuICAgIHZhciBOTCA9IDU7IC8vICBDYXVzZSBhIGxpbmUgYnJlYWsgKGFmdGVyKVxuICAgIHZhciBXSiA9IDc7IC8vICBQcm9oaWJpdCBsaW5lIGJyZWFrcyBiZWZvcmUgYW5kIGFmdGVyXG4gICAgdmFyIFpXID0gODsgLy8gIFByb3ZpZGUgYSBicmVhayBvcHBvcnR1bml0eVxuICAgIHZhciBHTCA9IDk7IC8vICBQcm9oaWJpdCBsaW5lIGJyZWFrcyBiZWZvcmUgYW5kIGFmdGVyXG4gICAgdmFyIFNQID0gMTA7IC8vIEVuYWJsZSBpbmRpcmVjdCBsaW5lIGJyZWFrc1xuICAgIHZhciBaV0okMSA9IDExOyAvLyBQcm9oaWJpdCBsaW5lIGJyZWFrcyB3aXRoaW4gam9pbmVyIHNlcXVlbmNlc1xuICAgIC8vIEJyZWFrIE9wcG9ydHVuaXRpZXNcbiAgICB2YXIgQjIgPSAxMjsgLy8gIFByb3ZpZGUgYSBsaW5lIGJyZWFrIG9wcG9ydHVuaXR5IGJlZm9yZSBhbmQgYWZ0ZXIgdGhlIGNoYXJhY3RlclxuICAgIHZhciBCQSA9IDEzOyAvLyAgR2VuZXJhbGx5IHByb3ZpZGUgYSBsaW5lIGJyZWFrIG9wcG9ydHVuaXR5IGFmdGVyIHRoZSBjaGFyYWN0ZXJcbiAgICB2YXIgQkIgPSAxNDsgLy8gIEdlbmVyYWxseSBwcm92aWRlIGEgbGluZSBicmVhayBvcHBvcnR1bml0eSBiZWZvcmUgdGhlIGNoYXJhY3RlclxuICAgIHZhciBIWSA9IDE1OyAvLyAgUHJvdmlkZSBhIGxpbmUgYnJlYWsgb3Bwb3J0dW5pdHkgYWZ0ZXIgdGhlIGNoYXJhY3RlciwgZXhjZXB0IGluIG51bWVyaWMgY29udGV4dFxuICAgIHZhciBDQiA9IDE2OyAvLyAgIFByb3ZpZGUgYSBsaW5lIGJyZWFrIG9wcG9ydHVuaXR5IGNvbnRpbmdlbnQgb24gYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuICAgIC8vIENoYXJhY3RlcnMgUHJvaGliaXRpbmcgQ2VydGFpbiBCcmVha3NcbiAgICB2YXIgQ0wgPSAxNzsgLy8gIFByb2hpYml0IGxpbmUgYnJlYWtzIGJlZm9yZVxuICAgIHZhciBDUCA9IDE4OyAvLyAgUHJvaGliaXQgbGluZSBicmVha3MgYmVmb3JlXG4gICAgdmFyIEVYID0gMTk7IC8vICBQcm9oaWJpdCBsaW5lIGJyZWFrcyBiZWZvcmVcbiAgICB2YXIgSU4gPSAyMDsgLy8gIEFsbG93IG9ubHkgaW5kaXJlY3QgbGluZSBicmVha3MgYmV0d2VlbiBwYWlyc1xuICAgIHZhciBOUyA9IDIxOyAvLyAgQWxsb3cgb25seSBpbmRpcmVjdCBsaW5lIGJyZWFrcyBiZWZvcmVcbiAgICB2YXIgT1AgPSAyMjsgLy8gIFByb2hpYml0IGxpbmUgYnJlYWtzIGFmdGVyXG4gICAgdmFyIFFVID0gMjM7IC8vICBBY3QgbGlrZSB0aGV5IGFyZSBib3RoIG9wZW5pbmcgYW5kIGNsb3NpbmdcbiAgICAvLyBOdW1lcmljIENvbnRleHRcbiAgICB2YXIgSVMgPSAyNDsgLy8gIFByZXZlbnQgYnJlYWtzIGFmdGVyIGFueSBhbmQgYmVmb3JlIG51bWVyaWNcbiAgICB2YXIgTlUgPSAyNTsgLy8gIEZvcm0gbnVtZXJpYyBleHByZXNzaW9ucyBmb3IgbGluZSBicmVha2luZyBwdXJwb3Nlc1xuICAgIHZhciBQTyA9IDI2OyAvLyAgRG8gbm90IGJyZWFrIGZvbGxvd2luZyBhIG51bWVyaWMgZXhwcmVzc2lvblxuICAgIHZhciBQUiA9IDI3OyAvLyAgRG8gbm90IGJyZWFrIGluIGZyb250IG9mIGEgbnVtZXJpYyBleHByZXNzaW9uXG4gICAgdmFyIFNZID0gMjg7IC8vICBQcmV2ZW50IGEgYnJlYWsgYmVmb3JlOyBhbmQgYWxsb3cgYSBicmVhayBhZnRlclxuICAgIC8vIE90aGVyIENoYXJhY3RlcnNcbiAgICB2YXIgQUkgPSAyOTsgLy8gIEFjdCBsaWtlIEFMIHdoZW4gdGhlIHJlc29sdmVkRUFXIGlzIE47IG90aGVyd2lzZTsgYWN0IGFzIElEXG4gICAgdmFyIEFMID0gMzA7IC8vICBBcmUgYWxwaGFiZXRpYyBjaGFyYWN0ZXJzIG9yIHN5bWJvbHMgdGhhdCBhcmUgdXNlZCB3aXRoIGFscGhhYmV0aWMgY2hhcmFjdGVyc1xuICAgIHZhciBDSiA9IDMxOyAvLyAgVHJlYXQgYXMgTlMgb3IgSUQgZm9yIHN0cmljdCBvciBub3JtYWwgYnJlYWtpbmcuXG4gICAgdmFyIEVCID0gMzI7IC8vICBEbyBub3QgYnJlYWsgZnJvbSBmb2xsb3dpbmcgRW1vamkgTW9kaWZpZXJcbiAgICB2YXIgRU0gPSAzMzsgLy8gIERvIG5vdCBicmVhayBmcm9tIHByZWNlZGluZyBFbW9qaSBCYXNlXG4gICAgdmFyIEgyID0gMzQ7IC8vICBGb3JtIEtvcmVhbiBzeWxsYWJsZSBibG9ja3NcbiAgICB2YXIgSDMgPSAzNTsgLy8gIEZvcm0gS29yZWFuIHN5bGxhYmxlIGJsb2Nrc1xuICAgIHZhciBITCA9IDM2OyAvLyAgRG8gbm90IGJyZWFrIGFyb3VuZCBhIGZvbGxvd2luZyBoeXBoZW47IG90aGVyd2lzZSBhY3QgYXMgQWxwaGFiZXRpY1xuICAgIHZhciBJRCA9IDM3OyAvLyAgQnJlYWsgYmVmb3JlIG9yIGFmdGVyOyBleGNlcHQgaW4gc29tZSBudW1lcmljIGNvbnRleHRcbiAgICB2YXIgSkwgPSAzODsgLy8gIEZvcm0gS29yZWFuIHN5bGxhYmxlIGJsb2Nrc1xuICAgIHZhciBKViA9IDM5OyAvLyAgRm9ybSBLb3JlYW4gc3lsbGFibGUgYmxvY2tzXG4gICAgdmFyIEpUID0gNDA7IC8vICBGb3JtIEtvcmVhbiBzeWxsYWJsZSBibG9ja3NcbiAgICB2YXIgUkkkMSA9IDQxOyAvLyAgS2VlcCBwYWlycyB0b2dldGhlci4gRm9yIHBhaXJzOyBicmVhayBiZWZvcmUgYW5kIGFmdGVyIG90aGVyIGNsYXNzZXNcbiAgICB2YXIgU0EgPSA0MjsgLy8gIFByb3ZpZGUgYSBsaW5lIGJyZWFrIG9wcG9ydHVuaXR5IGNvbnRpbmdlbnQgb24gYWRkaXRpb25hbCwgbGFuZ3VhZ2Utc3BlY2lmaWMgY29udGV4dCBhbmFseXNpc1xuICAgIHZhciBYWCA9IDQzOyAvLyAgSGF2ZSBhcyB5ZXQgdW5rbm93biBsaW5lIGJyZWFraW5nIGJlaGF2aW9yIG9yIHVuYXNzaWduZWQgY29kZSBwb3NpdGlvbnNcbiAgICB2YXIgZWFfT1AgPSBbMHgyMzI5LCAweGZmMDhdO1xuICAgIHZhciBCUkVBS19NQU5EQVRPUlkgPSAnISc7XG4gICAgdmFyIEJSRUFLX05PVF9BTExPV0VEJDEgPSAnw5cnO1xuICAgIHZhciBCUkVBS19BTExPV0VEJDEgPSAnw7cnO1xuICAgIHZhciBVbmljb2RlVHJpZSQxID0gY3JlYXRlVHJpZUZyb21CYXNlNjQkMShiYXNlNjQkMSk7XG4gICAgdmFyIEFMUEhBQkVUSUNTID0gW0FMLCBITF07XG4gICAgdmFyIEhBUkRfTElORV9CUkVBS1MgPSBbQkssIENSJDEsIExGJDEsIE5MXTtcbiAgICB2YXIgU1BBQ0UkMSA9IFtTUCwgWlddO1xuICAgIHZhciBQUkVGSVhfUE9TVEZJWCA9IFtQUiwgUE9dO1xuICAgIHZhciBMSU5FX0JSRUFLUyA9IEhBUkRfTElORV9CUkVBS1MuY29uY2F0KFNQQUNFJDEpO1xuICAgIHZhciBLT1JFQU5fU1lMTEFCTEVfQkxPQ0sgPSBbSkwsIEpWLCBKVCwgSDIsIEgzXTtcbiAgICB2YXIgSFlQSEVOID0gW0hZLCBCQV07XG4gICAgdmFyIGNvZGVQb2ludHNUb0NoYXJhY3RlckNsYXNzZXMgPSBmdW5jdGlvbiAoY29kZVBvaW50cywgbGluZUJyZWFrKSB7XG4gICAgICAgIGlmIChsaW5lQnJlYWsgPT09IHZvaWQgMCkgeyBsaW5lQnJlYWsgPSAnc3RyaWN0JzsgfVxuICAgICAgICB2YXIgdHlwZXMgPSBbXTtcbiAgICAgICAgdmFyIGluZGljZXMgPSBbXTtcbiAgICAgICAgdmFyIGNhdGVnb3JpZXMgPSBbXTtcbiAgICAgICAgY29kZVBvaW50cy5mb3JFYWNoKGZ1bmN0aW9uIChjb2RlUG9pbnQsIGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgY2xhc3NUeXBlID0gVW5pY29kZVRyaWUkMS5nZXQoY29kZVBvaW50KTtcbiAgICAgICAgICAgIGlmIChjbGFzc1R5cGUgPiBMRVRURVJfTlVNQkVSX01PRElGSUVSKSB7XG4gICAgICAgICAgICAgICAgY2F0ZWdvcmllcy5wdXNoKHRydWUpO1xuICAgICAgICAgICAgICAgIGNsYXNzVHlwZSAtPSBMRVRURVJfTlVNQkVSX01PRElGSUVSO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2F0ZWdvcmllcy5wdXNoKGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChbJ25vcm1hbCcsICdhdXRvJywgJ2xvb3NlJ10uaW5kZXhPZihsaW5lQnJlYWspICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIC8vIFUrMjAxMCwg4oCTIFUrMjAxMywg44CcIFUrMzAxQywg44KgIFUrMzBBMFxuICAgICAgICAgICAgICAgIGlmIChbMHgyMDEwLCAweDIwMTMsIDB4MzAxYywgMHgzMGEwXS5pbmRleE9mKGNvZGVQb2ludCkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGljZXMucHVzaChpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0eXBlcy5wdXNoKENCKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2xhc3NUeXBlID09PSBDTSB8fCBjbGFzc1R5cGUgPT09IFpXSiQxKSB7XG4gICAgICAgICAgICAgICAgLy8gTEIxMCBUcmVhdCBhbnkgcmVtYWluaW5nIGNvbWJpbmluZyBtYXJrIG9yIFpXSiBhcyBBTC5cbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kaWNlcy5wdXNoKGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVzLnB1c2goQUwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBMQjkgRG8gbm90IGJyZWFrIGEgY29tYmluaW5nIGNoYXJhY3RlciBzZXF1ZW5jZTsgdHJlYXQgaXQgYXMgaWYgaXQgaGFzIHRoZSBsaW5lIGJyZWFraW5nIGNsYXNzIG9mXG4gICAgICAgICAgICAgICAgLy8gdGhlIGJhc2UgY2hhcmFjdGVyIGluIGFsbCBvZiB0aGUgZm9sbG93aW5nIHJ1bGVzLiBUcmVhdCBaV0ogYXMgaWYgaXQgd2VyZSBDTS5cbiAgICAgICAgICAgICAgICB2YXIgcHJldiA9IHR5cGVzW2luZGV4IC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKExJTkVfQlJFQUtTLmluZGV4T2YocHJldikgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGljZXMucHVzaChpbmRpY2VzW2luZGV4IC0gMV0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHlwZXMucHVzaChwcmV2KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5kaWNlcy5wdXNoKGluZGV4KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZXMucHVzaChBTCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbmRpY2VzLnB1c2goaW5kZXgpO1xuICAgICAgICAgICAgaWYgKGNsYXNzVHlwZSA9PT0gQ0opIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZXMucHVzaChsaW5lQnJlYWsgPT09ICdzdHJpY3QnID8gTlMgOiBJRCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2xhc3NUeXBlID09PSBTQSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlcy5wdXNoKEFMKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjbGFzc1R5cGUgPT09IEFJKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVzLnB1c2goQUwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRm9yIHN1cHBsZW1lbnRhcnkgY2hhcmFjdGVycywgYSB1c2VmdWwgZGVmYXVsdCBpcyB0byB0cmVhdCBjaGFyYWN0ZXJzIGluIHRoZSByYW5nZSAxMDAwMC4uMUZGRkQgYXMgQUxcbiAgICAgICAgICAgIC8vIGFuZCBjaGFyYWN0ZXJzIGluIHRoZSByYW5nZXMgMjAwMDAuLjJGRkZEIGFuZCAzMDAwMC4uM0ZGRkQgYXMgSUQsIHVudGlsIHRoZSBpbXBsZW1lbnRhdGlvbiBjYW4gYmUgcmV2aXNlZFxuICAgICAgICAgICAgLy8gdG8gdGFrZSBpbnRvIGFjY291bnQgdGhlIGFjdHVhbCBsaW5lIGJyZWFraW5nIHByb3BlcnRpZXMgZm9yIHRoZXNlIGNoYXJhY3RlcnMuXG4gICAgICAgICAgICBpZiAoY2xhc3NUeXBlID09PSBYWCkge1xuICAgICAgICAgICAgICAgIGlmICgoY29kZVBvaW50ID49IDB4MjAwMDAgJiYgY29kZVBvaW50IDw9IDB4MmZmZmQpIHx8IChjb2RlUG9pbnQgPj0gMHgzMDAwMCAmJiBjb2RlUG9pbnQgPD0gMHgzZmZmZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVzLnB1c2goSUQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVzLnB1c2goQUwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHR5cGVzLnB1c2goY2xhc3NUeXBlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBbaW5kaWNlcywgdHlwZXMsIGNhdGVnb3JpZXNdO1xuICAgIH07XG4gICAgdmFyIGlzQWRqYWNlbnRXaXRoU3BhY2VJZ25vcmVkID0gZnVuY3Rpb24gKGEsIGIsIGN1cnJlbnRJbmRleCwgY2xhc3NUeXBlcykge1xuICAgICAgICB2YXIgY3VycmVudCA9IGNsYXNzVHlwZXNbY3VycmVudEluZGV4XTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYSkgPyBhLmluZGV4T2YoY3VycmVudCkgIT09IC0xIDogYSA9PT0gY3VycmVudCkge1xuICAgICAgICAgICAgdmFyIGkgPSBjdXJyZW50SW5kZXg7XG4gICAgICAgICAgICB3aGlsZSAoaSA8PSBjbGFzc1R5cGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICB2YXIgbmV4dCA9IGNsYXNzVHlwZXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKG5leHQgPT09IGIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChuZXh0ICE9PSBTUCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnQgPT09IFNQKSB7XG4gICAgICAgICAgICB2YXIgaSA9IGN1cnJlbnRJbmRleDtcbiAgICAgICAgICAgIHdoaWxlIChpID4gMCkge1xuICAgICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgICAgICB2YXIgcHJldiA9IGNsYXNzVHlwZXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYSkgPyBhLmluZGV4T2YocHJldikgIT09IC0xIDogYSA9PT0gcHJldikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IGN1cnJlbnRJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKG4gPD0gY2xhc3NUeXBlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG4rKztcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXh0ID0gY2xhc3NUeXBlc1tuXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0ID09PSBiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCAhPT0gU1ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocHJldiAhPT0gU1ApIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIHZhciBwcmV2aW91c05vblNwYWNlQ2xhc3NUeXBlID0gZnVuY3Rpb24gKGN1cnJlbnRJbmRleCwgY2xhc3NUeXBlcykge1xuICAgICAgICB2YXIgaSA9IGN1cnJlbnRJbmRleDtcbiAgICAgICAgd2hpbGUgKGkgPj0gMCkge1xuICAgICAgICAgICAgdmFyIHR5cGUgPSBjbGFzc1R5cGVzW2ldO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09IFNQKSB7XG4gICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfTtcbiAgICB2YXIgX2xpbmVCcmVha0F0SW5kZXggPSBmdW5jdGlvbiAoY29kZVBvaW50cywgY2xhc3NUeXBlcywgaW5kaWNpZXMsIGluZGV4LCBmb3JiaWRkZW5CcmVha3MpIHtcbiAgICAgICAgaWYgKGluZGljaWVzW2luZGV4XSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIEJSRUFLX05PVF9BTExPV0VEJDE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGN1cnJlbnRJbmRleCA9IGluZGV4IC0gMTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZm9yYmlkZGVuQnJlYWtzKSAmJiBmb3JiaWRkZW5CcmVha3NbY3VycmVudEluZGV4XSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIEJSRUFLX05PVF9BTExPV0VEJDE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJlZm9yZUluZGV4ID0gY3VycmVudEluZGV4IC0gMTtcbiAgICAgICAgdmFyIGFmdGVySW5kZXggPSBjdXJyZW50SW5kZXggKyAxO1xuICAgICAgICB2YXIgY3VycmVudCA9IGNsYXNzVHlwZXNbY3VycmVudEluZGV4XTtcbiAgICAgICAgLy8gTEI0IEFsd2F5cyBicmVhayBhZnRlciBoYXJkIGxpbmUgYnJlYWtzLlxuICAgICAgICAvLyBMQjUgVHJlYXQgQ1IgZm9sbG93ZWQgYnkgTEYsIGFzIHdlbGwgYXMgQ1IsIExGLCBhbmQgTkwgYXMgaGFyZCBsaW5lIGJyZWFrcy5cbiAgICAgICAgdmFyIGJlZm9yZSA9IGJlZm9yZUluZGV4ID49IDAgPyBjbGFzc1R5cGVzW2JlZm9yZUluZGV4XSA6IDA7XG4gICAgICAgIHZhciBuZXh0ID0gY2xhc3NUeXBlc1thZnRlckluZGV4XTtcbiAgICAgICAgaWYgKGN1cnJlbnQgPT09IENSJDEgJiYgbmV4dCA9PT0gTEYkMSkge1xuICAgICAgICAgICAgcmV0dXJuIEJSRUFLX05PVF9BTExPV0VEJDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEhBUkRfTElORV9CUkVBS1MuaW5kZXhPZihjdXJyZW50KSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBCUkVBS19NQU5EQVRPUlk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTEI2IERvIG5vdCBicmVhayBiZWZvcmUgaGFyZCBsaW5lIGJyZWFrcy5cbiAgICAgICAgaWYgKEhBUkRfTElORV9CUkVBS1MuaW5kZXhPZihuZXh0KSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBCUkVBS19OT1RfQUxMT1dFRCQxO1xuICAgICAgICB9XG4gICAgICAgIC8vIExCNyBEbyBub3QgYnJlYWsgYmVmb3JlIHNwYWNlcyBvciB6ZXJvIHdpZHRoIHNwYWNlLlxuICAgICAgICBpZiAoU1BBQ0UkMS5pbmRleE9mKG5leHQpICE9PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIEJSRUFLX05PVF9BTExPV0VEJDE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTEI4IEJyZWFrIGJlZm9yZSBhbnkgY2hhcmFjdGVyIGZvbGxvd2luZyBhIHplcm8td2lkdGggc3BhY2UsIGV2ZW4gaWYgb25lIG9yIG1vcmUgc3BhY2VzIGludGVydmVuZS5cbiAgICAgICAgaWYgKHByZXZpb3VzTm9uU3BhY2VDbGFzc1R5cGUoY3VycmVudEluZGV4LCBjbGFzc1R5cGVzKSA9PT0gWlcpIHtcbiAgICAgICAgICAgIHJldHVybiBCUkVBS19BTExPV0VEJDE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTEI4YSBEbyBub3QgYnJlYWsgYWZ0ZXIgYSB6ZXJvIHdpZHRoIGpvaW5lci5cbiAgICAgICAgaWYgKFVuaWNvZGVUcmllJDEuZ2V0KGNvZGVQb2ludHNbY3VycmVudEluZGV4XSkgPT09IFpXSiQxKSB7XG4gICAgICAgICAgICByZXR1cm4gQlJFQUtfTk9UX0FMTE9XRUQkMTtcbiAgICAgICAgfVxuICAgICAgICAvLyB6d2ogZW1vamlzXG4gICAgICAgIGlmICgoY3VycmVudCA9PT0gRUIgfHwgY3VycmVudCA9PT0gRU0pICYmIFVuaWNvZGVUcmllJDEuZ2V0KGNvZGVQb2ludHNbYWZ0ZXJJbmRleF0pID09PSBaV0okMSkge1xuICAgICAgICAgICAgcmV0dXJuIEJSRUFLX05PVF9BTExPV0VEJDE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTEIxMSBEbyBub3QgYnJlYWsgYmVmb3JlIG9yIGFmdGVyIFdvcmQgam9pbmVyIGFuZCByZWxhdGVkIGNoYXJhY3RlcnMuXG4gICAgICAgIGlmIChjdXJyZW50ID09PSBXSiB8fCBuZXh0ID09PSBXSikge1xuICAgICAgICAgICAgcmV0dXJuIEJSRUFLX05PVF9BTExPV0VEJDE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTEIxMiBEbyBub3QgYnJlYWsgYWZ0ZXIgTkJTUCBhbmQgcmVsYXRlZCBjaGFyYWN0ZXJzLlxuICAgICAgICBpZiAoY3VycmVudCA9PT0gR0wpIHtcbiAgICAgICAgICAgIHJldHVybiBCUkVBS19OT1RfQUxMT1dFRCQxO1xuICAgICAgICB9XG4gICAgICAgIC8vIExCMTJhIERvIG5vdCBicmVhayBiZWZvcmUgTkJTUCBhbmQgcmVsYXRlZCBjaGFyYWN0ZXJzLCBleGNlcHQgYWZ0ZXIgc3BhY2VzIGFuZCBoeXBoZW5zLlxuICAgICAgICBpZiAoW1NQLCBCQSwgSFldLmluZGV4T2YoY3VycmVudCkgPT09IC0xICYmIG5leHQgPT09IEdMKSB7XG4gICAgICAgICAgICByZXR1cm4gQlJFQUtfTk9UX0FMTE9XRUQkMTtcbiAgICAgICAgfVxuICAgICAgICAvLyBMQjEzIERvIG5vdCBicmVhayBiZWZvcmUg4oCYXeKAmSBvciDigJgh4oCZIG9yIOKAmDvigJkgb3Ig4oCYL+KAmSwgZXZlbiBhZnRlciBzcGFjZXMuXG4gICAgICAgIGlmIChbQ0wsIENQLCBFWCwgSVMsIFNZXS5pbmRleE9mKG5leHQpICE9PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIEJSRUFLX05PVF9BTExPV0VEJDE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTEIxNCBEbyBub3QgYnJlYWsgYWZ0ZXIg4oCYW+KAmSwgZXZlbiBhZnRlciBzcGFjZXMuXG4gICAgICAgIGlmIChwcmV2aW91c05vblNwYWNlQ2xhc3NUeXBlKGN1cnJlbnRJbmRleCwgY2xhc3NUeXBlcykgPT09IE9QKSB7XG4gICAgICAgICAgICByZXR1cm4gQlJFQUtfTk9UX0FMTE9XRUQkMTtcbiAgICAgICAgfVxuICAgICAgICAvLyBMQjE1IERvIG5vdCBicmVhayB3aXRoaW4g4oCY4oCdW+KAmSwgZXZlbiB3aXRoIGludGVydmVuaW5nIHNwYWNlcy5cbiAgICAgICAgaWYgKGlzQWRqYWNlbnRXaXRoU3BhY2VJZ25vcmVkKFFVLCBPUCwgY3VycmVudEluZGV4LCBjbGFzc1R5cGVzKSkge1xuICAgICAgICAgICAgcmV0dXJuIEJSRUFLX05PVF9BTExPV0VEJDE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTEIxNiBEbyBub3QgYnJlYWsgYmV0d2VlbiBjbG9zaW5nIHB1bmN0dWF0aW9uIGFuZCBhIG5vbnN0YXJ0ZXIgKGxiPU5TKSwgZXZlbiB3aXRoIGludGVydmVuaW5nIHNwYWNlcy5cbiAgICAgICAgaWYgKGlzQWRqYWNlbnRXaXRoU3BhY2VJZ25vcmVkKFtDTCwgQ1BdLCBOUywgY3VycmVudEluZGV4LCBjbGFzc1R5cGVzKSkge1xuICAgICAgICAgICAgcmV0dXJuIEJSRUFLX05PVF9BTExPV0VEJDE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTEIxNyBEbyBub3QgYnJlYWsgd2l0aGluIOKAmOKAlOKAlOKAmSwgZXZlbiB3aXRoIGludGVydmVuaW5nIHNwYWNlcy5cbiAgICAgICAgaWYgKGlzQWRqYWNlbnRXaXRoU3BhY2VJZ25vcmVkKEIyLCBCMiwgY3VycmVudEluZGV4LCBjbGFzc1R5cGVzKSkge1xuICAgICAgICAgICAgcmV0dXJuIEJSRUFLX05PVF9BTExPV0VEJDE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTEIxOCBCcmVhayBhZnRlciBzcGFjZXMuXG4gICAgICAgIGlmIChjdXJyZW50ID09PSBTUCkge1xuICAgICAgICAgICAgcmV0dXJuIEJSRUFLX0FMTE9XRUQkMTtcbiAgICAgICAgfVxuICAgICAgICAvLyBMQjE5IERvIG5vdCBicmVhayBiZWZvcmUgb3IgYWZ0ZXIgcXVvdGF0aW9uIG1hcmtzLCBzdWNoIGFzIOKAmCDigJ0g4oCZLlxuICAgICAgICBpZiAoY3VycmVudCA9PT0gUVUgfHwgbmV4dCA9PT0gUVUpIHtcbiAgICAgICAgICAgIHJldHVybiBCUkVBS19OT1RfQUxMT1dFRCQxO1xuICAgICAgICB9XG4gICAgICAgIC8vIExCMjAgQnJlYWsgYmVmb3JlIGFuZCBhZnRlciB1bnJlc29sdmVkIENCLlxuICAgICAgICBpZiAobmV4dCA9PT0gQ0IgfHwgY3VycmVudCA9PT0gQ0IpIHtcbiAgICAgICAgICAgIHJldHVybiBCUkVBS19BTExPV0VEJDE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTEIyMSBEbyBub3QgYnJlYWsgYmVmb3JlIGh5cGhlbi1taW51cywgb3RoZXIgaHlwaGVucywgZml4ZWQtd2lkdGggc3BhY2VzLCBzbWFsbCBrYW5hLCBhbmQgb3RoZXIgbm9uLXN0YXJ0ZXJzLCBvciBhZnRlciBhY3V0ZSBhY2NlbnRzLlxuICAgICAgICBpZiAoW0JBLCBIWSwgTlNdLmluZGV4T2YobmV4dCkgIT09IC0xIHx8IGN1cnJlbnQgPT09IEJCKSB7XG4gICAgICAgICAgICByZXR1cm4gQlJFQUtfTk9UX0FMTE9XRUQkMTtcbiAgICAgICAgfVxuICAgICAgICAvLyBMQjIxYSBEb24ndCBicmVhayBhZnRlciBIZWJyZXcgKyBIeXBoZW4uXG4gICAgICAgIGlmIChiZWZvcmUgPT09IEhMICYmIEhZUEhFTi5pbmRleE9mKGN1cnJlbnQpICE9PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIEJSRUFLX05PVF9BTExPV0VEJDE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTEIyMWIgRG9u4oCZdCBicmVhayBiZXR3ZWVuIFNvbGlkdXMgYW5kIEhlYnJldyBsZXR0ZXJzLlxuICAgICAgICBpZiAoY3VycmVudCA9PT0gU1kgJiYgbmV4dCA9PT0gSEwpIHtcbiAgICAgICAgICAgIHJldHVybiBCUkVBS19OT1RfQUxMT1dFRCQxO1xuICAgICAgICB9XG4gICAgICAgIC8vIExCMjIgRG8gbm90IGJyZWFrIGJlZm9yZSBlbGxpcHNpcy5cbiAgICAgICAgaWYgKG5leHQgPT09IElOKSB7XG4gICAgICAgICAgICByZXR1cm4gQlJFQUtfTk9UX0FMTE9XRUQkMTtcbiAgICAgICAgfVxuICAgICAgICAvLyBMQjIzIERvIG5vdCBicmVhayBiZXR3ZWVuIGRpZ2l0cyBhbmQgbGV0dGVycy5cbiAgICAgICAgaWYgKChBTFBIQUJFVElDUy5pbmRleE9mKG5leHQpICE9PSAtMSAmJiBjdXJyZW50ID09PSBOVSkgfHwgKEFMUEhBQkVUSUNTLmluZGV4T2YoY3VycmVudCkgIT09IC0xICYmIG5leHQgPT09IE5VKSkge1xuICAgICAgICAgICAgcmV0dXJuIEJSRUFLX05PVF9BTExPV0VEJDE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTEIyM2EgRG8gbm90IGJyZWFrIGJldHdlZW4gbnVtZXJpYyBwcmVmaXhlcyBhbmQgaWRlb2dyYXBocywgb3IgYmV0d2VlbiBpZGVvZ3JhcGhzIGFuZCBudW1lcmljIHBvc3RmaXhlcy5cbiAgICAgICAgaWYgKChjdXJyZW50ID09PSBQUiAmJiBbSUQsIEVCLCBFTV0uaW5kZXhPZihuZXh0KSAhPT0gLTEpIHx8XG4gICAgICAgICAgICAoW0lELCBFQiwgRU1dLmluZGV4T2YoY3VycmVudCkgIT09IC0xICYmIG5leHQgPT09IFBPKSkge1xuICAgICAgICAgICAgcmV0dXJuIEJSRUFLX05PVF9BTExPV0VEJDE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTEIyNCBEbyBub3QgYnJlYWsgYmV0d2VlbiBudW1lcmljIHByZWZpeC9wb3N0Zml4IGFuZCBsZXR0ZXJzLCBvciBiZXR3ZWVuIGxldHRlcnMgYW5kIHByZWZpeC9wb3N0Zml4LlxuICAgICAgICBpZiAoKEFMUEhBQkVUSUNTLmluZGV4T2YoY3VycmVudCkgIT09IC0xICYmIFBSRUZJWF9QT1NURklYLmluZGV4T2YobmV4dCkgIT09IC0xKSB8fFxuICAgICAgICAgICAgKFBSRUZJWF9QT1NURklYLmluZGV4T2YoY3VycmVudCkgIT09IC0xICYmIEFMUEhBQkVUSUNTLmluZGV4T2YobmV4dCkgIT09IC0xKSkge1xuICAgICAgICAgICAgcmV0dXJuIEJSRUFLX05PVF9BTExPV0VEJDE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTEIyNSBEbyBub3QgYnJlYWsgYmV0d2VlbiB0aGUgZm9sbG93aW5nIHBhaXJzIG9mIGNsYXNzZXMgcmVsZXZhbnQgdG8gbnVtYmVyczpcbiAgICAgICAgaWYgKFxuICAgICAgICAvLyAoUFIgfCBQTykgw5cgKCBPUCB8IEhZICk/IE5VXG4gICAgICAgIChbUFIsIFBPXS5pbmRleE9mKGN1cnJlbnQpICE9PSAtMSAmJlxuICAgICAgICAgICAgKG5leHQgPT09IE5VIHx8IChbT1AsIEhZXS5pbmRleE9mKG5leHQpICE9PSAtMSAmJiBjbGFzc1R5cGVzW2FmdGVySW5kZXggKyAxXSA9PT0gTlUpKSkgfHxcbiAgICAgICAgICAgIC8vICggT1AgfCBIWSApIMOXIE5VXG4gICAgICAgICAgICAoW09QLCBIWV0uaW5kZXhPZihjdXJyZW50KSAhPT0gLTEgJiYgbmV4dCA9PT0gTlUpIHx8XG4gICAgICAgICAgICAvLyBOVSDDl1x0KE5VIHwgU1kgfCBJUylcbiAgICAgICAgICAgIChjdXJyZW50ID09PSBOVSAmJiBbTlUsIFNZLCBJU10uaW5kZXhPZihuZXh0KSAhPT0gLTEpKSB7XG4gICAgICAgICAgICByZXR1cm4gQlJFQUtfTk9UX0FMTE9XRUQkMTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOVSAoTlUgfCBTWSB8IElTKSogw5cgKE5VIHwgU1kgfCBJUyB8IENMIHwgQ1ApXG4gICAgICAgIGlmIChbTlUsIFNZLCBJUywgQ0wsIENQXS5pbmRleE9mKG5leHQpICE9PSAtMSkge1xuICAgICAgICAgICAgdmFyIHByZXZJbmRleCA9IGN1cnJlbnRJbmRleDtcbiAgICAgICAgICAgIHdoaWxlIChwcmV2SW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgIHZhciB0eXBlID0gY2xhc3NUeXBlc1twcmV2SW5kZXhdO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBOVSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQlJFQUtfTk9UX0FMTE9XRUQkMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoW1NZLCBJU10uaW5kZXhPZih0eXBlKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldkluZGV4LS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gTlUgKE5VIHwgU1kgfCBJUykqIChDTCB8IENQKT8gw5cgKFBPIHwgUFIpKVxuICAgICAgICBpZiAoW1BSLCBQT10uaW5kZXhPZihuZXh0KSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHZhciBwcmV2SW5kZXggPSBbQ0wsIENQXS5pbmRleE9mKGN1cnJlbnQpICE9PSAtMSA/IGJlZm9yZUluZGV4IDogY3VycmVudEluZGV4O1xuICAgICAgICAgICAgd2hpbGUgKHByZXZJbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBjbGFzc1R5cGVzW3ByZXZJbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IE5VKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBCUkVBS19OT1RfQUxMT1dFRCQxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChbU1ksIElTXS5pbmRleE9mKHR5cGUpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBwcmV2SW5kZXgtLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBMQjI2IERvIG5vdCBicmVhayBhIEtvcmVhbiBzeWxsYWJsZS5cbiAgICAgICAgaWYgKChKTCA9PT0gY3VycmVudCAmJiBbSkwsIEpWLCBIMiwgSDNdLmluZGV4T2YobmV4dCkgIT09IC0xKSB8fFxuICAgICAgICAgICAgKFtKViwgSDJdLmluZGV4T2YoY3VycmVudCkgIT09IC0xICYmIFtKViwgSlRdLmluZGV4T2YobmV4dCkgIT09IC0xKSB8fFxuICAgICAgICAgICAgKFtKVCwgSDNdLmluZGV4T2YoY3VycmVudCkgIT09IC0xICYmIG5leHQgPT09IEpUKSkge1xuICAgICAgICAgICAgcmV0dXJuIEJSRUFLX05PVF9BTExPV0VEJDE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTEIyNyBUcmVhdCBhIEtvcmVhbiBTeWxsYWJsZSBCbG9jayB0aGUgc2FtZSBhcyBJRC5cbiAgICAgICAgaWYgKChLT1JFQU5fU1lMTEFCTEVfQkxPQ0suaW5kZXhPZihjdXJyZW50KSAhPT0gLTEgJiYgW0lOLCBQT10uaW5kZXhPZihuZXh0KSAhPT0gLTEpIHx8XG4gICAgICAgICAgICAoS09SRUFOX1NZTExBQkxFX0JMT0NLLmluZGV4T2YobmV4dCkgIT09IC0xICYmIGN1cnJlbnQgPT09IFBSKSkge1xuICAgICAgICAgICAgcmV0dXJuIEJSRUFLX05PVF9BTExPV0VEJDE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTEIyOCBEbyBub3QgYnJlYWsgYmV0d2VlbiBhbHBoYWJldGljcyAo4oCcYXTigJ0pLlxuICAgICAgICBpZiAoQUxQSEFCRVRJQ1MuaW5kZXhPZihjdXJyZW50KSAhPT0gLTEgJiYgQUxQSEFCRVRJQ1MuaW5kZXhPZihuZXh0KSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBCUkVBS19OT1RfQUxMT1dFRCQxO1xuICAgICAgICB9XG4gICAgICAgIC8vIExCMjkgRG8gbm90IGJyZWFrIGJldHdlZW4gbnVtZXJpYyBwdW5jdHVhdGlvbiBhbmQgYWxwaGFiZXRpY3MgKOKAnGUuZy7igJ0pLlxuICAgICAgICBpZiAoY3VycmVudCA9PT0gSVMgJiYgQUxQSEFCRVRJQ1MuaW5kZXhPZihuZXh0KSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBCUkVBS19OT1RfQUxMT1dFRCQxO1xuICAgICAgICB9XG4gICAgICAgIC8vIExCMzAgRG8gbm90IGJyZWFrIGJldHdlZW4gbGV0dGVycywgbnVtYmVycywgb3Igb3JkaW5hcnkgc3ltYm9scyBhbmQgb3BlbmluZyBvciBjbG9zaW5nIHBhcmVudGhlc2VzLlxuICAgICAgICBpZiAoKEFMUEhBQkVUSUNTLmNvbmNhdChOVSkuaW5kZXhPZihjdXJyZW50KSAhPT0gLTEgJiZcbiAgICAgICAgICAgIG5leHQgPT09IE9QICYmXG4gICAgICAgICAgICBlYV9PUC5pbmRleE9mKGNvZGVQb2ludHNbYWZ0ZXJJbmRleF0pID09PSAtMSkgfHxcbiAgICAgICAgICAgIChBTFBIQUJFVElDUy5jb25jYXQoTlUpLmluZGV4T2YobmV4dCkgIT09IC0xICYmIGN1cnJlbnQgPT09IENQKSkge1xuICAgICAgICAgICAgcmV0dXJuIEJSRUFLX05PVF9BTExPV0VEJDE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTEIzMGEgQnJlYWsgYmV0d2VlbiB0d28gcmVnaW9uYWwgaW5kaWNhdG9yIHN5bWJvbHMgaWYgYW5kIG9ubHkgaWYgdGhlcmUgYXJlIGFuIGV2ZW4gbnVtYmVyIG9mIHJlZ2lvbmFsXG4gICAgICAgIC8vIGluZGljYXRvcnMgcHJlY2VkaW5nIHRoZSBwb3NpdGlvbiBvZiB0aGUgYnJlYWsuXG4gICAgICAgIGlmIChjdXJyZW50ID09PSBSSSQxICYmIG5leHQgPT09IFJJJDEpIHtcbiAgICAgICAgICAgIHZhciBpID0gaW5kaWNpZXNbY3VycmVudEluZGV4XTtcbiAgICAgICAgICAgIHZhciBjb3VudCA9IDE7XG4gICAgICAgICAgICB3aGlsZSAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICBpLS07XG4gICAgICAgICAgICAgICAgaWYgKGNsYXNzVHlwZXNbaV0gPT09IFJJJDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb3VudCAlIDIgIT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQlJFQUtfTk9UX0FMTE9XRUQkMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBMQjMwYiBEbyBub3QgYnJlYWsgYmV0d2VlbiBhbiBlbW9qaSBiYXNlIGFuZCBhbiBlbW9qaSBtb2RpZmllci5cbiAgICAgICAgaWYgKGN1cnJlbnQgPT09IEVCICYmIG5leHQgPT09IEVNKSB7XG4gICAgICAgICAgICByZXR1cm4gQlJFQUtfTk9UX0FMTE9XRUQkMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQlJFQUtfQUxMT1dFRCQxO1xuICAgIH07XG4gICAgdmFyIGNzc0Zvcm1hdHRlZENsYXNzZXMgPSBmdW5jdGlvbiAoY29kZVBvaW50cywgb3B0aW9ucykge1xuICAgICAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7IGxpbmVCcmVhazogJ25vcm1hbCcsIHdvcmRCcmVhazogJ25vcm1hbCcgfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX2EgPSBjb2RlUG9pbnRzVG9DaGFyYWN0ZXJDbGFzc2VzKGNvZGVQb2ludHMsIG9wdGlvbnMubGluZUJyZWFrKSwgaW5kaWNpZXMgPSBfYVswXSwgY2xhc3NUeXBlcyA9IF9hWzFdLCBpc0xldHRlck51bWJlciA9IF9hWzJdO1xuICAgICAgICBpZiAob3B0aW9ucy53b3JkQnJlYWsgPT09ICdicmVhay1hbGwnIHx8IG9wdGlvbnMud29yZEJyZWFrID09PSAnYnJlYWstd29yZCcpIHtcbiAgICAgICAgICAgIGNsYXNzVHlwZXMgPSBjbGFzc1R5cGVzLm1hcChmdW5jdGlvbiAodHlwZSkgeyByZXR1cm4gKFtOVSwgQUwsIFNBXS5pbmRleE9mKHR5cGUpICE9PSAtMSA/IElEIDogdHlwZSk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmb3JiaWRkZW5CcmVha3BvaW50cyA9IG9wdGlvbnMud29yZEJyZWFrID09PSAna2VlcC1hbGwnXG4gICAgICAgICAgICA/IGlzTGV0dGVyTnVtYmVyLm1hcChmdW5jdGlvbiAobGV0dGVyTnVtYmVyLCBpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxldHRlck51bWJlciAmJiBjb2RlUG9pbnRzW2ldID49IDB4NGUwMCAmJiBjb2RlUG9pbnRzW2ldIDw9IDB4OWZmZjtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIFtpbmRpY2llcywgY2xhc3NUeXBlcywgZm9yYmlkZGVuQnJlYWtwb2ludHNdO1xuICAgIH07XG4gICAgdmFyIEJyZWFrID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBCcmVhayhjb2RlUG9pbnRzLCBsaW5lQnJlYWssIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgICAgIHRoaXMuY29kZVBvaW50cyA9IGNvZGVQb2ludHM7XG4gICAgICAgICAgICB0aGlzLnJlcXVpcmVkID0gbGluZUJyZWFrID09PSBCUkVBS19NQU5EQVRPUlk7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgICB0aGlzLmVuZCA9IGVuZDtcbiAgICAgICAgfVxuICAgICAgICBCcmVhay5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZnJvbUNvZGVQb2ludCQxLmFwcGx5KHZvaWQgMCwgdGhpcy5jb2RlUG9pbnRzLnNsaWNlKHRoaXMuc3RhcnQsIHRoaXMuZW5kKSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBCcmVhaztcbiAgICB9KCkpO1xuICAgIHZhciBMaW5lQnJlYWtlciA9IGZ1bmN0aW9uIChzdHIsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGNvZGVQb2ludHMgPSB0b0NvZGVQb2ludHMkMShzdHIpO1xuICAgICAgICB2YXIgX2EgPSBjc3NGb3JtYXR0ZWRDbGFzc2VzKGNvZGVQb2ludHMsIG9wdGlvbnMpLCBpbmRpY2llcyA9IF9hWzBdLCBjbGFzc1R5cGVzID0gX2FbMV0sIGZvcmJpZGRlbkJyZWFrcG9pbnRzID0gX2FbMl07XG4gICAgICAgIHZhciBsZW5ndGggPSBjb2RlUG9pbnRzLmxlbmd0aDtcbiAgICAgICAgdmFyIGxhc3RFbmQgPSAwO1xuICAgICAgICB2YXIgbmV4dEluZGV4ID0gMDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAobmV4dEluZGV4ID49IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlLCB2YWx1ZTogbnVsbCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgbGluZUJyZWFrID0gQlJFQUtfTk9UX0FMTE9XRUQkMTtcbiAgICAgICAgICAgICAgICB3aGlsZSAobmV4dEluZGV4IDwgbGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgICAgIChsaW5lQnJlYWsgPSBfbGluZUJyZWFrQXRJbmRleChjb2RlUG9pbnRzLCBjbGFzc1R5cGVzLCBpbmRpY2llcywgKytuZXh0SW5kZXgsIGZvcmJpZGRlbkJyZWFrcG9pbnRzKSkgPT09XG4gICAgICAgICAgICAgICAgICAgICAgICBCUkVBS19OT1RfQUxMT1dFRCQxKSB7IH1cbiAgICAgICAgICAgICAgICBpZiAobGluZUJyZWFrICE9PSBCUkVBS19OT1RfQUxMT1dFRCQxIHx8IG5leHRJbmRleCA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IG5ldyBCcmVhayhjb2RlUG9pbnRzLCBsaW5lQnJlYWssIGxhc3RFbmQsIG5leHRJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RFbmQgPSBuZXh0SW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB2YWx1ZSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZG9uZTogdHJ1ZSwgdmFsdWU6IG51bGwgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9jc3Mtc3ludGF4LTNcbiAgICB2YXIgRkxBR19VTlJFU1RSSUNURUQgPSAxIDw8IDA7XG4gICAgdmFyIEZMQUdfSUQgPSAxIDw8IDE7XG4gICAgdmFyIEZMQUdfSU5URUdFUiA9IDEgPDwgMjtcbiAgICB2YXIgRkxBR19OVU1CRVIgPSAxIDw8IDM7XG4gICAgdmFyIExJTkVfRkVFRCA9IDB4MDAwYTtcbiAgICB2YXIgU09MSURVUyA9IDB4MDAyZjtcbiAgICB2YXIgUkVWRVJTRV9TT0xJRFVTID0gMHgwMDVjO1xuICAgIHZhciBDSEFSQUNURVJfVEFCVUxBVElPTiA9IDB4MDAwOTtcbiAgICB2YXIgU1BBQ0UgPSAweDAwMjA7XG4gICAgdmFyIFFVT1RBVElPTl9NQVJLID0gMHgwMDIyO1xuICAgIHZhciBFUVVBTFNfU0lHTiA9IDB4MDAzZDtcbiAgICB2YXIgTlVNQkVSX1NJR04gPSAweDAwMjM7XG4gICAgdmFyIERPTExBUl9TSUdOID0gMHgwMDI0O1xuICAgIHZhciBQRVJDRU5UQUdFX1NJR04gPSAweDAwMjU7XG4gICAgdmFyIEFQT1NUUk9QSEUgPSAweDAwMjc7XG4gICAgdmFyIExFRlRfUEFSRU5USEVTSVMgPSAweDAwMjg7XG4gICAgdmFyIFJJR0hUX1BBUkVOVEhFU0lTID0gMHgwMDI5O1xuICAgIHZhciBMT1dfTElORSA9IDB4MDA1ZjtcbiAgICB2YXIgSFlQSEVOX01JTlVTID0gMHgwMDJkO1xuICAgIHZhciBFWENMQU1BVElPTl9NQVJLID0gMHgwMDIxO1xuICAgIHZhciBMRVNTX1RIQU5fU0lHTiA9IDB4MDAzYztcbiAgICB2YXIgR1JFQVRFUl9USEFOX1NJR04gPSAweDAwM2U7XG4gICAgdmFyIENPTU1FUkNJQUxfQVQgPSAweDAwNDA7XG4gICAgdmFyIExFRlRfU1FVQVJFX0JSQUNLRVQgPSAweDAwNWI7XG4gICAgdmFyIFJJR0hUX1NRVUFSRV9CUkFDS0VUID0gMHgwMDVkO1xuICAgIHZhciBDSVJDVU1GTEVYX0FDQ0VOVCA9IDB4MDAzZDtcbiAgICB2YXIgTEVGVF9DVVJMWV9CUkFDS0VUID0gMHgwMDdiO1xuICAgIHZhciBRVUVTVElPTl9NQVJLID0gMHgwMDNmO1xuICAgIHZhciBSSUdIVF9DVVJMWV9CUkFDS0VUID0gMHgwMDdkO1xuICAgIHZhciBWRVJUSUNBTF9MSU5FID0gMHgwMDdjO1xuICAgIHZhciBUSUxERSA9IDB4MDA3ZTtcbiAgICB2YXIgQ09OVFJPTCA9IDB4MDA4MDtcbiAgICB2YXIgUkVQTEFDRU1FTlRfQ0hBUkFDVEVSID0gMHhmZmZkO1xuICAgIHZhciBBU1RFUklTSyA9IDB4MDAyYTtcbiAgICB2YXIgUExVU19TSUdOID0gMHgwMDJiO1xuICAgIHZhciBDT01NQSA9IDB4MDAyYztcbiAgICB2YXIgQ09MT04gPSAweDAwM2E7XG4gICAgdmFyIFNFTUlDT0xPTiA9IDB4MDAzYjtcbiAgICB2YXIgRlVMTF9TVE9QID0gMHgwMDJlO1xuICAgIHZhciBOVUxMID0gMHgwMDAwO1xuICAgIHZhciBCQUNLU1BBQ0UgPSAweDAwMDg7XG4gICAgdmFyIExJTkVfVEFCVUxBVElPTiA9IDB4MDAwYjtcbiAgICB2YXIgU0hJRlRfT1VUID0gMHgwMDBlO1xuICAgIHZhciBJTkZPUk1BVElPTl9TRVBBUkFUT1JfT05FID0gMHgwMDFmO1xuICAgIHZhciBERUxFVEUgPSAweDAwN2Y7XG4gICAgdmFyIEVPRiA9IC0xO1xuICAgIHZhciBaRVJPID0gMHgwMDMwO1xuICAgIHZhciBhID0gMHgwMDYxO1xuICAgIHZhciBlID0gMHgwMDY1O1xuICAgIHZhciBmID0gMHgwMDY2O1xuICAgIHZhciB1ID0gMHgwMDc1O1xuICAgIHZhciB6ID0gMHgwMDdhO1xuICAgIHZhciBBID0gMHgwMDQxO1xuICAgIHZhciBFID0gMHgwMDQ1O1xuICAgIHZhciBGID0gMHgwMDQ2O1xuICAgIHZhciBVID0gMHgwMDU1O1xuICAgIHZhciBaID0gMHgwMDVhO1xuICAgIHZhciBpc0RpZ2l0ID0gZnVuY3Rpb24gKGNvZGVQb2ludCkgeyByZXR1cm4gY29kZVBvaW50ID49IFpFUk8gJiYgY29kZVBvaW50IDw9IDB4MDAzOTsgfTtcbiAgICB2YXIgaXNTdXJyb2dhdGVDb2RlUG9pbnQgPSBmdW5jdGlvbiAoY29kZVBvaW50KSB7IHJldHVybiBjb2RlUG9pbnQgPj0gMHhkODAwICYmIGNvZGVQb2ludCA8PSAweGRmZmY7IH07XG4gICAgdmFyIGlzSGV4ID0gZnVuY3Rpb24gKGNvZGVQb2ludCkge1xuICAgICAgICByZXR1cm4gaXNEaWdpdChjb2RlUG9pbnQpIHx8IChjb2RlUG9pbnQgPj0gQSAmJiBjb2RlUG9pbnQgPD0gRikgfHwgKGNvZGVQb2ludCA+PSBhICYmIGNvZGVQb2ludCA8PSBmKTtcbiAgICB9O1xuICAgIHZhciBpc0xvd2VyQ2FzZUxldHRlciA9IGZ1bmN0aW9uIChjb2RlUG9pbnQpIHsgcmV0dXJuIGNvZGVQb2ludCA+PSBhICYmIGNvZGVQb2ludCA8PSB6OyB9O1xuICAgIHZhciBpc1VwcGVyQ2FzZUxldHRlciA9IGZ1bmN0aW9uIChjb2RlUG9pbnQpIHsgcmV0dXJuIGNvZGVQb2ludCA+PSBBICYmIGNvZGVQb2ludCA8PSBaOyB9O1xuICAgIHZhciBpc0xldHRlciA9IGZ1bmN0aW9uIChjb2RlUG9pbnQpIHsgcmV0dXJuIGlzTG93ZXJDYXNlTGV0dGVyKGNvZGVQb2ludCkgfHwgaXNVcHBlckNhc2VMZXR0ZXIoY29kZVBvaW50KTsgfTtcbiAgICB2YXIgaXNOb25BU0NJSUNvZGVQb2ludCA9IGZ1bmN0aW9uIChjb2RlUG9pbnQpIHsgcmV0dXJuIGNvZGVQb2ludCA+PSBDT05UUk9MOyB9O1xuICAgIHZhciBpc1doaXRlU3BhY2UgPSBmdW5jdGlvbiAoY29kZVBvaW50KSB7XG4gICAgICAgIHJldHVybiBjb2RlUG9pbnQgPT09IExJTkVfRkVFRCB8fCBjb2RlUG9pbnQgPT09IENIQVJBQ1RFUl9UQUJVTEFUSU9OIHx8IGNvZGVQb2ludCA9PT0gU1BBQ0U7XG4gICAgfTtcbiAgICB2YXIgaXNOYW1lU3RhcnRDb2RlUG9pbnQgPSBmdW5jdGlvbiAoY29kZVBvaW50KSB7XG4gICAgICAgIHJldHVybiBpc0xldHRlcihjb2RlUG9pbnQpIHx8IGlzTm9uQVNDSUlDb2RlUG9pbnQoY29kZVBvaW50KSB8fCBjb2RlUG9pbnQgPT09IExPV19MSU5FO1xuICAgIH07XG4gICAgdmFyIGlzTmFtZUNvZGVQb2ludCA9IGZ1bmN0aW9uIChjb2RlUG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIGlzTmFtZVN0YXJ0Q29kZVBvaW50KGNvZGVQb2ludCkgfHwgaXNEaWdpdChjb2RlUG9pbnQpIHx8IGNvZGVQb2ludCA9PT0gSFlQSEVOX01JTlVTO1xuICAgIH07XG4gICAgdmFyIGlzTm9uUHJpbnRhYmxlQ29kZVBvaW50ID0gZnVuY3Rpb24gKGNvZGVQb2ludCkge1xuICAgICAgICByZXR1cm4gKChjb2RlUG9pbnQgPj0gTlVMTCAmJiBjb2RlUG9pbnQgPD0gQkFDS1NQQUNFKSB8fFxuICAgICAgICAgICAgY29kZVBvaW50ID09PSBMSU5FX1RBQlVMQVRJT04gfHxcbiAgICAgICAgICAgIChjb2RlUG9pbnQgPj0gU0hJRlRfT1VUICYmIGNvZGVQb2ludCA8PSBJTkZPUk1BVElPTl9TRVBBUkFUT1JfT05FKSB8fFxuICAgICAgICAgICAgY29kZVBvaW50ID09PSBERUxFVEUpO1xuICAgIH07XG4gICAgdmFyIGlzVmFsaWRFc2NhcGUgPSBmdW5jdGlvbiAoYzEsIGMyKSB7XG4gICAgICAgIGlmIChjMSAhPT0gUkVWRVJTRV9TT0xJRFVTKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGMyICE9PSBMSU5FX0ZFRUQ7XG4gICAgfTtcbiAgICB2YXIgaXNJZGVudGlmaWVyU3RhcnQgPSBmdW5jdGlvbiAoYzEsIGMyLCBjMykge1xuICAgICAgICBpZiAoYzEgPT09IEhZUEhFTl9NSU5VUykge1xuICAgICAgICAgICAgcmV0dXJuIGlzTmFtZVN0YXJ0Q29kZVBvaW50KGMyKSB8fCBpc1ZhbGlkRXNjYXBlKGMyLCBjMyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNOYW1lU3RhcnRDb2RlUG9pbnQoYzEpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjMSA9PT0gUkVWRVJTRV9TT0xJRFVTICYmIGlzVmFsaWRFc2NhcGUoYzEsIGMyKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgdmFyIGlzTnVtYmVyU3RhcnQgPSBmdW5jdGlvbiAoYzEsIGMyLCBjMykge1xuICAgICAgICBpZiAoYzEgPT09IFBMVVNfU0lHTiB8fCBjMSA9PT0gSFlQSEVOX01JTlVTKSB7XG4gICAgICAgICAgICBpZiAoaXNEaWdpdChjMikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjMiA9PT0gRlVMTF9TVE9QICYmIGlzRGlnaXQoYzMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjMSA9PT0gRlVMTF9TVE9QKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNEaWdpdChjMik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzRGlnaXQoYzEpO1xuICAgIH07XG4gICAgdmFyIHN0cmluZ1RvTnVtYmVyID0gZnVuY3Rpb24gKGNvZGVQb2ludHMpIHtcbiAgICAgICAgdmFyIGMgPSAwO1xuICAgICAgICB2YXIgc2lnbiA9IDE7XG4gICAgICAgIGlmIChjb2RlUG9pbnRzW2NdID09PSBQTFVTX1NJR04gfHwgY29kZVBvaW50c1tjXSA9PT0gSFlQSEVOX01JTlVTKSB7XG4gICAgICAgICAgICBpZiAoY29kZVBvaW50c1tjXSA9PT0gSFlQSEVOX01JTlVTKSB7XG4gICAgICAgICAgICAgICAgc2lnbiA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYysrO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbnRlZ2VycyA9IFtdO1xuICAgICAgICB3aGlsZSAoaXNEaWdpdChjb2RlUG9pbnRzW2NdKSkge1xuICAgICAgICAgICAgaW50ZWdlcnMucHVzaChjb2RlUG9pbnRzW2MrK10pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbnQgPSBpbnRlZ2Vycy5sZW5ndGggPyBwYXJzZUludChmcm9tQ29kZVBvaW50JDEuYXBwbHkodm9pZCAwLCBpbnRlZ2VycyksIDEwKSA6IDA7XG4gICAgICAgIGlmIChjb2RlUG9pbnRzW2NdID09PSBGVUxMX1NUT1ApIHtcbiAgICAgICAgICAgIGMrKztcbiAgICAgICAgfVxuICAgICAgICB2YXIgZnJhY3Rpb24gPSBbXTtcbiAgICAgICAgd2hpbGUgKGlzRGlnaXQoY29kZVBvaW50c1tjXSkpIHtcbiAgICAgICAgICAgIGZyYWN0aW9uLnB1c2goY29kZVBvaW50c1tjKytdKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZnJhY2QgPSBmcmFjdGlvbi5sZW5ndGg7XG4gICAgICAgIHZhciBmcmFjID0gZnJhY2QgPyBwYXJzZUludChmcm9tQ29kZVBvaW50JDEuYXBwbHkodm9pZCAwLCBmcmFjdGlvbiksIDEwKSA6IDA7XG4gICAgICAgIGlmIChjb2RlUG9pbnRzW2NdID09PSBFIHx8IGNvZGVQb2ludHNbY10gPT09IGUpIHtcbiAgICAgICAgICAgIGMrKztcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXhwc2lnbiA9IDE7XG4gICAgICAgIGlmIChjb2RlUG9pbnRzW2NdID09PSBQTFVTX1NJR04gfHwgY29kZVBvaW50c1tjXSA9PT0gSFlQSEVOX01JTlVTKSB7XG4gICAgICAgICAgICBpZiAoY29kZVBvaW50c1tjXSA9PT0gSFlQSEVOX01JTlVTKSB7XG4gICAgICAgICAgICAgICAgZXhwc2lnbiA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYysrO1xuICAgICAgICB9XG4gICAgICAgIHZhciBleHBvbmVudCA9IFtdO1xuICAgICAgICB3aGlsZSAoaXNEaWdpdChjb2RlUG9pbnRzW2NdKSkge1xuICAgICAgICAgICAgZXhwb25lbnQucHVzaChjb2RlUG9pbnRzW2MrK10pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBleHAgPSBleHBvbmVudC5sZW5ndGggPyBwYXJzZUludChmcm9tQ29kZVBvaW50JDEuYXBwbHkodm9pZCAwLCBleHBvbmVudCksIDEwKSA6IDA7XG4gICAgICAgIHJldHVybiBzaWduICogKGludCArIGZyYWMgKiBNYXRoLnBvdygxMCwgLWZyYWNkKSkgKiBNYXRoLnBvdygxMCwgZXhwc2lnbiAqIGV4cCk7XG4gICAgfTtcbiAgICB2YXIgTEVGVF9QQVJFTlRIRVNJU19UT0tFTiA9IHtcbiAgICAgICAgdHlwZTogMiAvKiBMRUZUX1BBUkVOVEhFU0lTX1RPS0VOICovXG4gICAgfTtcbiAgICB2YXIgUklHSFRfUEFSRU5USEVTSVNfVE9LRU4gPSB7XG4gICAgICAgIHR5cGU6IDMgLyogUklHSFRfUEFSRU5USEVTSVNfVE9LRU4gKi9cbiAgICB9O1xuICAgIHZhciBDT01NQV9UT0tFTiA9IHsgdHlwZTogNCAvKiBDT01NQV9UT0tFTiAqLyB9O1xuICAgIHZhciBTVUZGSVhfTUFUQ0hfVE9LRU4gPSB7IHR5cGU6IDEzIC8qIFNVRkZJWF9NQVRDSF9UT0tFTiAqLyB9O1xuICAgIHZhciBQUkVGSVhfTUFUQ0hfVE9LRU4gPSB7IHR5cGU6IDggLyogUFJFRklYX01BVENIX1RPS0VOICovIH07XG4gICAgdmFyIENPTFVNTl9UT0tFTiA9IHsgdHlwZTogMjEgLyogQ09MVU1OX1RPS0VOICovIH07XG4gICAgdmFyIERBU0hfTUFUQ0hfVE9LRU4gPSB7IHR5cGU6IDkgLyogREFTSF9NQVRDSF9UT0tFTiAqLyB9O1xuICAgIHZhciBJTkNMVURFX01BVENIX1RPS0VOID0geyB0eXBlOiAxMCAvKiBJTkNMVURFX01BVENIX1RPS0VOICovIH07XG4gICAgdmFyIExFRlRfQ1VSTFlfQlJBQ0tFVF9UT0tFTiA9IHtcbiAgICAgICAgdHlwZTogMTEgLyogTEVGVF9DVVJMWV9CUkFDS0VUX1RPS0VOICovXG4gICAgfTtcbiAgICB2YXIgUklHSFRfQ1VSTFlfQlJBQ0tFVF9UT0tFTiA9IHtcbiAgICAgICAgdHlwZTogMTIgLyogUklHSFRfQ1VSTFlfQlJBQ0tFVF9UT0tFTiAqL1xuICAgIH07XG4gICAgdmFyIFNVQlNUUklOR19NQVRDSF9UT0tFTiA9IHsgdHlwZTogMTQgLyogU1VCU1RSSU5HX01BVENIX1RPS0VOICovIH07XG4gICAgdmFyIEJBRF9VUkxfVE9LRU4gPSB7IHR5cGU6IDIzIC8qIEJBRF9VUkxfVE9LRU4gKi8gfTtcbiAgICB2YXIgQkFEX1NUUklOR19UT0tFTiA9IHsgdHlwZTogMSAvKiBCQURfU1RSSU5HX1RPS0VOICovIH07XG4gICAgdmFyIENET19UT0tFTiA9IHsgdHlwZTogMjUgLyogQ0RPX1RPS0VOICovIH07XG4gICAgdmFyIENEQ19UT0tFTiA9IHsgdHlwZTogMjQgLyogQ0RDX1RPS0VOICovIH07XG4gICAgdmFyIENPTE9OX1RPS0VOID0geyB0eXBlOiAyNiAvKiBDT0xPTl9UT0tFTiAqLyB9O1xuICAgIHZhciBTRU1JQ09MT05fVE9LRU4gPSB7IHR5cGU6IDI3IC8qIFNFTUlDT0xPTl9UT0tFTiAqLyB9O1xuICAgIHZhciBMRUZUX1NRVUFSRV9CUkFDS0VUX1RPS0VOID0ge1xuICAgICAgICB0eXBlOiAyOCAvKiBMRUZUX1NRVUFSRV9CUkFDS0VUX1RPS0VOICovXG4gICAgfTtcbiAgICB2YXIgUklHSFRfU1FVQVJFX0JSQUNLRVRfVE9LRU4gPSB7XG4gICAgICAgIHR5cGU6IDI5IC8qIFJJR0hUX1NRVUFSRV9CUkFDS0VUX1RPS0VOICovXG4gICAgfTtcbiAgICB2YXIgV0hJVEVTUEFDRV9UT0tFTiA9IHsgdHlwZTogMzEgLyogV0hJVEVTUEFDRV9UT0tFTiAqLyB9O1xuICAgIHZhciBFT0ZfVE9LRU4gPSB7IHR5cGU6IDMyIC8qIEVPRl9UT0tFTiAqLyB9O1xuICAgIHZhciBUb2tlbml6ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFRva2VuaXplcigpIHtcbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gW107XG4gICAgICAgIH1cbiAgICAgICAgVG9rZW5pemVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSB0aGlzLl92YWx1ZS5jb25jYXQodG9Db2RlUG9pbnRzJDEoY2h1bmspKTtcbiAgICAgICAgfTtcbiAgICAgICAgVG9rZW5pemVyLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHRva2VucyA9IFtdO1xuICAgICAgICAgICAgdmFyIHRva2VuID0gdGhpcy5jb25zdW1lVG9rZW4oKTtcbiAgICAgICAgICAgIHdoaWxlICh0b2tlbiAhPT0gRU9GX1RPS0VOKSB7XG4gICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy5jb25zdW1lVG9rZW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgICAgIH07XG4gICAgICAgIFRva2VuaXplci5wcm90b3R5cGUuY29uc3VtZVRva2VuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGNvZGVQb2ludCA9IHRoaXMuY29uc3VtZUNvZGVQb2ludCgpO1xuICAgICAgICAgICAgc3dpdGNoIChjb2RlUG9pbnQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFFVT1RBVElPTl9NQVJLOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdW1lU3RyaW5nVG9rZW4oUVVPVEFUSU9OX01BUkspO1xuICAgICAgICAgICAgICAgIGNhc2UgTlVNQkVSX1NJR046XG4gICAgICAgICAgICAgICAgICAgIHZhciBjMSA9IHRoaXMucGVla0NvZGVQb2ludCgwKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGMyID0gdGhpcy5wZWVrQ29kZVBvaW50KDEpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYzMgPSB0aGlzLnBlZWtDb2RlUG9pbnQoMik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc05hbWVDb2RlUG9pbnQoYzEpIHx8IGlzVmFsaWRFc2NhcGUoYzIsIGMzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZsYWdzID0gaXNJZGVudGlmaWVyU3RhcnQoYzEsIGMyLCBjMykgPyBGTEFHX0lEIDogRkxBR19VTlJFU1RSSUNURUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmNvbnN1bWVOYW1lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB0eXBlOiA1IC8qIEhBU0hfVE9LRU4gKi8sIHZhbHVlOiB2YWx1ZSwgZmxhZ3M6IGZsYWdzIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBET0xMQVJfU0lHTjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucGVla0NvZGVQb2ludCgwKSA9PT0gRVFVQUxTX1NJR04pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29uc3VtZUNvZGVQb2ludCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFNVRkZJWF9NQVRDSF9UT0tFTjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEFQT1NUUk9QSEU6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN1bWVTdHJpbmdUb2tlbihBUE9TVFJPUEhFKTtcbiAgICAgICAgICAgICAgICBjYXNlIExFRlRfUEFSRU5USEVTSVM6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBMRUZUX1BBUkVOVEhFU0lTX1RPS0VOO1xuICAgICAgICAgICAgICAgIGNhc2UgUklHSFRfUEFSRU5USEVTSVM6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBSSUdIVF9QQVJFTlRIRVNJU19UT0tFTjtcbiAgICAgICAgICAgICAgICBjYXNlIEFTVEVSSVNLOlxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wZWVrQ29kZVBvaW50KDApID09PSBFUVVBTFNfU0lHTikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25zdW1lQ29kZVBvaW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gU1VCU1RSSU5HX01BVENIX1RPS0VOO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgUExVU19TSUdOOlxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOdW1iZXJTdGFydChjb2RlUG9pbnQsIHRoaXMucGVla0NvZGVQb2ludCgwKSwgdGhpcy5wZWVrQ29kZVBvaW50KDEpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWNvbnN1bWVDb2RlUG9pbnQoY29kZVBvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN1bWVOdW1lcmljVG9rZW4oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIENPTU1BOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQ09NTUFfVE9LRU47XG4gICAgICAgICAgICAgICAgY2FzZSBIWVBIRU5fTUlOVVM6XG4gICAgICAgICAgICAgICAgICAgIHZhciBlMSA9IGNvZGVQb2ludDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGUyID0gdGhpcy5wZWVrQ29kZVBvaW50KDApO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZTMgPSB0aGlzLnBlZWtDb2RlUG9pbnQoMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc051bWJlclN0YXJ0KGUxLCBlMiwgZTMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlY29uc3VtZUNvZGVQb2ludChjb2RlUG9pbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3VtZU51bWVyaWNUb2tlbigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0lkZW50aWZpZXJTdGFydChlMSwgZTIsIGUzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWNvbnN1bWVDb2RlUG9pbnQoY29kZVBvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN1bWVJZGVudExpa2VUb2tlbigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChlMiA9PT0gSFlQSEVOX01JTlVTICYmIGUzID09PSBHUkVBVEVSX1RIQU5fU0lHTikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25zdW1lQ29kZVBvaW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnN1bWVDb2RlUG9pbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBDRENfVE9LRU47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBGVUxMX1NUT1A6XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc051bWJlclN0YXJ0KGNvZGVQb2ludCwgdGhpcy5wZWVrQ29kZVBvaW50KDApLCB0aGlzLnBlZWtDb2RlUG9pbnQoMSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlY29uc3VtZUNvZGVQb2ludChjb2RlUG9pbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3VtZU51bWVyaWNUb2tlbigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgU09MSURVUzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucGVla0NvZGVQb2ludCgwKSA9PT0gQVNURVJJU0spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29uc3VtZUNvZGVQb2ludCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IHRoaXMuY29uc3VtZUNvZGVQb2ludCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjID09PSBBU1RFUklTSykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjID0gdGhpcy5jb25zdW1lQ29kZVBvaW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjID09PSBTT0xJRFVTKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdW1lVG9rZW4oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYyA9PT0gRU9GKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN1bWVUb2tlbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIENPTE9OOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQ09MT05fVE9LRU47XG4gICAgICAgICAgICAgICAgY2FzZSBTRU1JQ09MT046XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTRU1JQ09MT05fVE9LRU47XG4gICAgICAgICAgICAgICAgY2FzZSBMRVNTX1RIQU5fU0lHTjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucGVla0NvZGVQb2ludCgwKSA9PT0gRVhDTEFNQVRJT05fTUFSSyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wZWVrQ29kZVBvaW50KDEpID09PSBIWVBIRU5fTUlOVVMgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGVla0NvZGVQb2ludCgyKSA9PT0gSFlQSEVOX01JTlVTKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnN1bWVDb2RlUG9pbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29uc3VtZUNvZGVQb2ludCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIENET19UT0tFTjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIENPTU1FUkNJQUxfQVQ6XG4gICAgICAgICAgICAgICAgICAgIHZhciBhMSA9IHRoaXMucGVla0NvZGVQb2ludCgwKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGEyID0gdGhpcy5wZWVrQ29kZVBvaW50KDEpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYTMgPSB0aGlzLnBlZWtDb2RlUG9pbnQoMik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0lkZW50aWZpZXJTdGFydChhMSwgYTIsIGEzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5jb25zdW1lTmFtZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogNyAvKiBBVF9LRVlXT1JEX1RPS0VOICovLCB2YWx1ZTogdmFsdWUgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIExFRlRfU1FVQVJFX0JSQUNLRVQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBMRUZUX1NRVUFSRV9CUkFDS0VUX1RPS0VOO1xuICAgICAgICAgICAgICAgIGNhc2UgUkVWRVJTRV9TT0xJRFVTOlxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNWYWxpZEVzY2FwZShjb2RlUG9pbnQsIHRoaXMucGVla0NvZGVQb2ludCgwKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVjb25zdW1lQ29kZVBvaW50KGNvZGVQb2ludCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdW1lSWRlbnRMaWtlVG9rZW4oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFJJR0hUX1NRVUFSRV9CUkFDS0VUOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUklHSFRfU1FVQVJFX0JSQUNLRVRfVE9LRU47XG4gICAgICAgICAgICAgICAgY2FzZSBDSVJDVU1GTEVYX0FDQ0VOVDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucGVla0NvZGVQb2ludCgwKSA9PT0gRVFVQUxTX1NJR04pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29uc3VtZUNvZGVQb2ludCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBSRUZJWF9NQVRDSF9UT0tFTjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIExFRlRfQ1VSTFlfQlJBQ0tFVDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIExFRlRfQ1VSTFlfQlJBQ0tFVF9UT0tFTjtcbiAgICAgICAgICAgICAgICBjYXNlIFJJR0hUX0NVUkxZX0JSQUNLRVQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBSSUdIVF9DVVJMWV9CUkFDS0VUX1RPS0VOO1xuICAgICAgICAgICAgICAgIGNhc2UgdTpcbiAgICAgICAgICAgICAgICBjYXNlIFU6XG4gICAgICAgICAgICAgICAgICAgIHZhciB1MSA9IHRoaXMucGVla0NvZGVQb2ludCgwKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHUyID0gdGhpcy5wZWVrQ29kZVBvaW50KDEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodTEgPT09IFBMVVNfU0lHTiAmJiAoaXNIZXgodTIpIHx8IHUyID09PSBRVUVTVElPTl9NQVJLKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25zdW1lQ29kZVBvaW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnN1bWVVbmljb2RlUmFuZ2VUb2tlbigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVjb25zdW1lQ29kZVBvaW50KGNvZGVQb2ludCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN1bWVJZGVudExpa2VUb2tlbigpO1xuICAgICAgICAgICAgICAgIGNhc2UgVkVSVElDQUxfTElORTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucGVla0NvZGVQb2ludCgwKSA9PT0gRVFVQUxTX1NJR04pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29uc3VtZUNvZGVQb2ludCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIERBU0hfTUFUQ0hfVE9LRU47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucGVla0NvZGVQb2ludCgwKSA9PT0gVkVSVElDQUxfTElORSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25zdW1lQ29kZVBvaW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gQ09MVU1OX1RPS0VOO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgVElMREU6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnBlZWtDb2RlUG9pbnQoMCkgPT09IEVRVUFMU19TSUdOKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnN1bWVDb2RlUG9pbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBJTkNMVURFX01BVENIX1RPS0VOO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgRU9GOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRU9GX1RPS0VOO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzV2hpdGVTcGFjZShjb2RlUG9pbnQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25zdW1lV2hpdGVTcGFjZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBXSElURVNQQUNFX1RPS0VOO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzRGlnaXQoY29kZVBvaW50KSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVjb25zdW1lQ29kZVBvaW50KGNvZGVQb2ludCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3VtZU51bWVyaWNUb2tlbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzTmFtZVN0YXJ0Q29kZVBvaW50KGNvZGVQb2ludCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlY29uc3VtZUNvZGVQb2ludChjb2RlUG9pbnQpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN1bWVJZGVudExpa2VUb2tlbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogNiAvKiBERUxJTV9UT0tFTiAqLywgdmFsdWU6IGZyb21Db2RlUG9pbnQkMShjb2RlUG9pbnQpIH07XG4gICAgICAgIH07XG4gICAgICAgIFRva2VuaXplci5wcm90b3R5cGUuY29uc3VtZUNvZGVQb2ludCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX3ZhbHVlLnNoaWZ0KCk7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyA/IC0xIDogdmFsdWU7XG4gICAgICAgIH07XG4gICAgICAgIFRva2VuaXplci5wcm90b3R5cGUucmVjb25zdW1lQ29kZVBvaW50ID0gZnVuY3Rpb24gKGNvZGVQb2ludCkge1xuICAgICAgICAgICAgdGhpcy5fdmFsdWUudW5zaGlmdChjb2RlUG9pbnQpO1xuICAgICAgICB9O1xuICAgICAgICBUb2tlbml6ZXIucHJvdG90eXBlLnBlZWtDb2RlUG9pbnQgPSBmdW5jdGlvbiAoZGVsdGEpIHtcbiAgICAgICAgICAgIGlmIChkZWx0YSA+PSB0aGlzLl92YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWVbZGVsdGFdO1xuICAgICAgICB9O1xuICAgICAgICBUb2tlbml6ZXIucHJvdG90eXBlLmNvbnN1bWVVbmljb2RlUmFuZ2VUb2tlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBkaWdpdHMgPSBbXTtcbiAgICAgICAgICAgIHZhciBjb2RlUG9pbnQgPSB0aGlzLmNvbnN1bWVDb2RlUG9pbnQoKTtcbiAgICAgICAgICAgIHdoaWxlIChpc0hleChjb2RlUG9pbnQpICYmIGRpZ2l0cy5sZW5ndGggPCA2KSB7XG4gICAgICAgICAgICAgICAgZGlnaXRzLnB1c2goY29kZVBvaW50KTtcbiAgICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0aGlzLmNvbnN1bWVDb2RlUG9pbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBxdWVzdGlvbk1hcmtzID0gZmFsc2U7XG4gICAgICAgICAgICB3aGlsZSAoY29kZVBvaW50ID09PSBRVUVTVElPTl9NQVJLICYmIGRpZ2l0cy5sZW5ndGggPCA2KSB7XG4gICAgICAgICAgICAgICAgZGlnaXRzLnB1c2goY29kZVBvaW50KTtcbiAgICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0aGlzLmNvbnN1bWVDb2RlUG9pbnQoKTtcbiAgICAgICAgICAgICAgICBxdWVzdGlvbk1hcmtzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChxdWVzdGlvbk1hcmtzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0XzEgPSBwYXJzZUludChmcm9tQ29kZVBvaW50JDEuYXBwbHkodm9pZCAwLCBkaWdpdHMubWFwKGZ1bmN0aW9uIChkaWdpdCkgeyByZXR1cm4gKGRpZ2l0ID09PSBRVUVTVElPTl9NQVJLID8gWkVSTyA6IGRpZ2l0KTsgfSkpLCAxNik7XG4gICAgICAgICAgICAgICAgdmFyIGVuZCA9IHBhcnNlSW50KGZyb21Db2RlUG9pbnQkMS5hcHBseSh2b2lkIDAsIGRpZ2l0cy5tYXAoZnVuY3Rpb24gKGRpZ2l0KSB7IHJldHVybiAoZGlnaXQgPT09IFFVRVNUSU9OX01BUksgPyBGIDogZGlnaXQpOyB9KSksIDE2KTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB0eXBlOiAzMCAvKiBVTklDT0RFX1JBTkdFX1RPS0VOICovLCBzdGFydDogc3RhcnRfMSwgZW5kOiBlbmQgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzdGFydCA9IHBhcnNlSW50KGZyb21Db2RlUG9pbnQkMS5hcHBseSh2b2lkIDAsIGRpZ2l0cyksIDE2KTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBlZWtDb2RlUG9pbnQoMCkgPT09IEhZUEhFTl9NSU5VUyAmJiBpc0hleCh0aGlzLnBlZWtDb2RlUG9pbnQoMSkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25zdW1lQ29kZVBvaW50KCk7XG4gICAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGhpcy5jb25zdW1lQ29kZVBvaW50KCk7XG4gICAgICAgICAgICAgICAgdmFyIGVuZERpZ2l0cyA9IFtdO1xuICAgICAgICAgICAgICAgIHdoaWxlIChpc0hleChjb2RlUG9pbnQpICYmIGVuZERpZ2l0cy5sZW5ndGggPCA2KSB7XG4gICAgICAgICAgICAgICAgICAgIGVuZERpZ2l0cy5wdXNoKGNvZGVQb2ludCk7XG4gICAgICAgICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRoaXMuY29uc3VtZUNvZGVQb2ludCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgZW5kID0gcGFyc2VJbnQoZnJvbUNvZGVQb2ludCQxLmFwcGx5KHZvaWQgMCwgZW5kRGlnaXRzKSwgMTYpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IDMwIC8qIFVOSUNPREVfUkFOR0VfVE9LRU4gKi8sIHN0YXJ0OiBzdGFydCwgZW5kOiBlbmQgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IDMwIC8qIFVOSUNPREVfUkFOR0VfVE9LRU4gKi8sIHN0YXJ0OiBzdGFydCwgZW5kOiBzdGFydCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBUb2tlbml6ZXIucHJvdG90eXBlLmNvbnN1bWVJZGVudExpa2VUb2tlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuY29uc3VtZU5hbWUoKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZS50b0xvd2VyQ2FzZSgpID09PSAndXJsJyAmJiB0aGlzLnBlZWtDb2RlUG9pbnQoMCkgPT09IExFRlRfUEFSRU5USEVTSVMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnN1bWVDb2RlUG9pbnQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdW1lVXJsVG9rZW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMucGVla0NvZGVQb2ludCgwKSA9PT0gTEVGVF9QQVJFTlRIRVNJUykge1xuICAgICAgICAgICAgICAgIHRoaXMuY29uc3VtZUNvZGVQb2ludCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IDE5IC8qIEZVTkNUSU9OX1RPS0VOICovLCB2YWx1ZTogdmFsdWUgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IDIwIC8qIElERU5UX1RPS0VOICovLCB2YWx1ZTogdmFsdWUgfTtcbiAgICAgICAgfTtcbiAgICAgICAgVG9rZW5pemVyLnByb3RvdHlwZS5jb25zdW1lVXJsVG9rZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuY29uc3VtZVdoaXRlU3BhY2UoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBlZWtDb2RlUG9pbnQoMCkgPT09IEVPRikge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IDIyIC8qIFVSTF9UT0tFTiAqLywgdmFsdWU6ICcnIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbmV4dCA9IHRoaXMucGVla0NvZGVQb2ludCgwKTtcbiAgICAgICAgICAgIGlmIChuZXh0ID09PSBBUE9TVFJPUEhFIHx8IG5leHQgPT09IFFVT1RBVElPTl9NQVJLKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0cmluZ1Rva2VuID0gdGhpcy5jb25zdW1lU3RyaW5nVG9rZW4odGhpcy5jb25zdW1lQ29kZVBvaW50KCkpO1xuICAgICAgICAgICAgICAgIGlmIChzdHJpbmdUb2tlbi50eXBlID09PSAwIC8qIFNUUklOR19UT0tFTiAqLykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnN1bWVXaGl0ZVNwYWNlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnBlZWtDb2RlUG9pbnQoMCkgPT09IEVPRiB8fCB0aGlzLnBlZWtDb2RlUG9pbnQoMCkgPT09IFJJR0hUX1BBUkVOVEhFU0lTKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnN1bWVDb2RlUG9pbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IDIyIC8qIFVSTF9UT0tFTiAqLywgdmFsdWU6IHN0cmluZ1Rva2VuLnZhbHVlIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5jb25zdW1lQmFkVXJsUmVtbmFudHMoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gQkFEX1VSTF9UT0tFTjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvZGVQb2ludCA9IHRoaXMuY29uc3VtZUNvZGVQb2ludCgpO1xuICAgICAgICAgICAgICAgIGlmIChjb2RlUG9pbnQgPT09IEVPRiB8fCBjb2RlUG9pbnQgPT09IFJJR0hUX1BBUkVOVEhFU0lTKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IDIyIC8qIFVSTF9UT0tFTiAqLywgdmFsdWU6IGZyb21Db2RlUG9pbnQkMS5hcHBseSh2b2lkIDAsIHZhbHVlKSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc1doaXRlU3BhY2UoY29kZVBvaW50KSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnN1bWVXaGl0ZVNwYWNlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnBlZWtDb2RlUG9pbnQoMCkgPT09IEVPRiB8fCB0aGlzLnBlZWtDb2RlUG9pbnQoMCkgPT09IFJJR0hUX1BBUkVOVEhFU0lTKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnN1bWVDb2RlUG9pbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IDIyIC8qIFVSTF9UT0tFTiAqLywgdmFsdWU6IGZyb21Db2RlUG9pbnQkMS5hcHBseSh2b2lkIDAsIHZhbHVlKSB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29uc3VtZUJhZFVybFJlbW5hbnRzKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBCQURfVVJMX1RPS0VOO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjb2RlUG9pbnQgPT09IFFVT1RBVElPTl9NQVJLIHx8XG4gICAgICAgICAgICAgICAgICAgIGNvZGVQb2ludCA9PT0gQVBPU1RST1BIRSB8fFxuICAgICAgICAgICAgICAgICAgICBjb2RlUG9pbnQgPT09IExFRlRfUEFSRU5USEVTSVMgfHxcbiAgICAgICAgICAgICAgICAgICAgaXNOb25QcmludGFibGVDb2RlUG9pbnQoY29kZVBvaW50KSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnN1bWVCYWRVcmxSZW1uYW50cygpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQkFEX1VSTF9UT0tFTjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY29kZVBvaW50ID09PSBSRVZFUlNFX1NPTElEVVMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzVmFsaWRFc2NhcGUoY29kZVBvaW50LCB0aGlzLnBlZWtDb2RlUG9pbnQoMCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5wdXNoKHRoaXMuY29uc3VtZUVzY2FwZWRDb2RlUG9pbnQoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnN1bWVCYWRVcmxSZW1uYW50cygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJBRF9VUkxfVE9LRU47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLnB1c2goY29kZVBvaW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFRva2VuaXplci5wcm90b3R5cGUuY29uc3VtZVdoaXRlU3BhY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB3aGlsZSAoaXNXaGl0ZVNwYWNlKHRoaXMucGVla0NvZGVQb2ludCgwKSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnN1bWVDb2RlUG9pbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgVG9rZW5pemVyLnByb3RvdHlwZS5jb25zdW1lQmFkVXJsUmVtbmFudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgIHZhciBjb2RlUG9pbnQgPSB0aGlzLmNvbnN1bWVDb2RlUG9pbnQoKTtcbiAgICAgICAgICAgICAgICBpZiAoY29kZVBvaW50ID09PSBSSUdIVF9QQVJFTlRIRVNJUyB8fCBjb2RlUG9pbnQgPT09IEVPRikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc1ZhbGlkRXNjYXBlKGNvZGVQb2ludCwgdGhpcy5wZWVrQ29kZVBvaW50KDApKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnN1bWVFc2NhcGVkQ29kZVBvaW50KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBUb2tlbml6ZXIucHJvdG90eXBlLmNvbnN1bWVTdHJpbmdTbGljZSA9IGZ1bmN0aW9uIChjb3VudCkge1xuICAgICAgICAgICAgdmFyIFNMSUNFX1NUQUNLX1NJWkUgPSA1MDAwMDtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9ICcnO1xuICAgICAgICAgICAgd2hpbGUgKGNvdW50ID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciBhbW91bnQgPSBNYXRoLm1pbihTTElDRV9TVEFDS19TSVpFLCBjb3VudCk7XG4gICAgICAgICAgICAgICAgdmFsdWUgKz0gZnJvbUNvZGVQb2ludCQxLmFwcGx5KHZvaWQgMCwgdGhpcy5fdmFsdWUuc3BsaWNlKDAsIGFtb3VudCkpO1xuICAgICAgICAgICAgICAgIGNvdW50IC09IGFtb3VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlLnNoaWZ0KCk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH07XG4gICAgICAgIFRva2VuaXplci5wcm90b3R5cGUuY29uc3VtZVN0cmluZ1Rva2VuID0gZnVuY3Rpb24gKGVuZGluZ0NvZGVQb2ludCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gJyc7XG4gICAgICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgdmFyIGNvZGVQb2ludCA9IHRoaXMuX3ZhbHVlW2ldO1xuICAgICAgICAgICAgICAgIGlmIChjb2RlUG9pbnQgPT09IEVPRiB8fCBjb2RlUG9pbnQgPT09IHVuZGVmaW5lZCB8fCBjb2RlUG9pbnQgPT09IGVuZGluZ0NvZGVQb2ludCkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSB0aGlzLmNvbnN1bWVTdHJpbmdTbGljZShpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogMCAvKiBTVFJJTkdfVE9LRU4gKi8sIHZhbHVlOiB2YWx1ZSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY29kZVBvaW50ID09PSBMSU5FX0ZFRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmFsdWUuc3BsaWNlKDAsIGkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQkFEX1NUUklOR19UT0tFTjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNvZGVQb2ludCA9PT0gUkVWRVJTRV9TT0xJRFVTKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0ID0gdGhpcy5fdmFsdWVbaSArIDFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCAhPT0gRU9GICYmIG5leHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQgPT09IExJTkVfRkVFRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IHRoaXMuY29uc3VtZVN0cmluZ1NsaWNlKGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNWYWxpZEVzY2FwZShjb2RlUG9pbnQsIG5leHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gdGhpcy5jb25zdW1lU3RyaW5nU2xpY2UoaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gZnJvbUNvZGVQb2ludCQxKHRoaXMuY29uc3VtZUVzY2FwZWRDb2RlUG9pbnQoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSA9IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH0gd2hpbGUgKHRydWUpO1xuICAgICAgICB9O1xuICAgICAgICBUb2tlbml6ZXIucHJvdG90eXBlLmNvbnN1bWVOdW1iZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVwciA9IFtdO1xuICAgICAgICAgICAgdmFyIHR5cGUgPSBGTEFHX0lOVEVHRVI7XG4gICAgICAgICAgICB2YXIgYzEgPSB0aGlzLnBlZWtDb2RlUG9pbnQoMCk7XG4gICAgICAgICAgICBpZiAoYzEgPT09IFBMVVNfU0lHTiB8fCBjMSA9PT0gSFlQSEVOX01JTlVTKSB7XG4gICAgICAgICAgICAgICAgcmVwci5wdXNoKHRoaXMuY29uc3VtZUNvZGVQb2ludCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChpc0RpZ2l0KHRoaXMucGVla0NvZGVQb2ludCgwKSkpIHtcbiAgICAgICAgICAgICAgICByZXByLnB1c2godGhpcy5jb25zdW1lQ29kZVBvaW50KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYzEgPSB0aGlzLnBlZWtDb2RlUG9pbnQoMCk7XG4gICAgICAgICAgICB2YXIgYzIgPSB0aGlzLnBlZWtDb2RlUG9pbnQoMSk7XG4gICAgICAgICAgICBpZiAoYzEgPT09IEZVTExfU1RPUCAmJiBpc0RpZ2l0KGMyKSkge1xuICAgICAgICAgICAgICAgIHJlcHIucHVzaCh0aGlzLmNvbnN1bWVDb2RlUG9pbnQoKSwgdGhpcy5jb25zdW1lQ29kZVBvaW50KCkpO1xuICAgICAgICAgICAgICAgIHR5cGUgPSBGTEFHX05VTUJFUjtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaXNEaWdpdCh0aGlzLnBlZWtDb2RlUG9pbnQoMCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcHIucHVzaCh0aGlzLmNvbnN1bWVDb2RlUG9pbnQoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYzEgPSB0aGlzLnBlZWtDb2RlUG9pbnQoMCk7XG4gICAgICAgICAgICBjMiA9IHRoaXMucGVla0NvZGVQb2ludCgxKTtcbiAgICAgICAgICAgIHZhciBjMyA9IHRoaXMucGVla0NvZGVQb2ludCgyKTtcbiAgICAgICAgICAgIGlmICgoYzEgPT09IEUgfHwgYzEgPT09IGUpICYmICgoKGMyID09PSBQTFVTX1NJR04gfHwgYzIgPT09IEhZUEhFTl9NSU5VUykgJiYgaXNEaWdpdChjMykpIHx8IGlzRGlnaXQoYzIpKSkge1xuICAgICAgICAgICAgICAgIHJlcHIucHVzaCh0aGlzLmNvbnN1bWVDb2RlUG9pbnQoKSwgdGhpcy5jb25zdW1lQ29kZVBvaW50KCkpO1xuICAgICAgICAgICAgICAgIHR5cGUgPSBGTEFHX05VTUJFUjtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaXNEaWdpdCh0aGlzLnBlZWtDb2RlUG9pbnQoMCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcHIucHVzaCh0aGlzLmNvbnN1bWVDb2RlUG9pbnQoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtzdHJpbmdUb051bWJlcihyZXByKSwgdHlwZV07XG4gICAgICAgIH07XG4gICAgICAgIFRva2VuaXplci5wcm90b3R5cGUuY29uc3VtZU51bWVyaWNUb2tlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IHRoaXMuY29uc3VtZU51bWJlcigpLCBudW1iZXIgPSBfYVswXSwgZmxhZ3MgPSBfYVsxXTtcbiAgICAgICAgICAgIHZhciBjMSA9IHRoaXMucGVla0NvZGVQb2ludCgwKTtcbiAgICAgICAgICAgIHZhciBjMiA9IHRoaXMucGVla0NvZGVQb2ludCgxKTtcbiAgICAgICAgICAgIHZhciBjMyA9IHRoaXMucGVla0NvZGVQb2ludCgyKTtcbiAgICAgICAgICAgIGlmIChpc0lkZW50aWZpZXJTdGFydChjMSwgYzIsIGMzKSkge1xuICAgICAgICAgICAgICAgIHZhciB1bml0ID0gdGhpcy5jb25zdW1lTmFtZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IDE1IC8qIERJTUVOU0lPTl9UT0tFTiAqLywgbnVtYmVyOiBudW1iZXIsIGZsYWdzOiBmbGFncywgdW5pdDogdW5pdCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGMxID09PSBQRVJDRU5UQUdFX1NJR04pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnN1bWVDb2RlUG9pbnQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB0eXBlOiAxNiAvKiBQRVJDRU5UQUdFX1RPS0VOICovLCBudW1iZXI6IG51bWJlciwgZmxhZ3M6IGZsYWdzIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyB0eXBlOiAxNyAvKiBOVU1CRVJfVE9LRU4gKi8sIG51bWJlcjogbnVtYmVyLCBmbGFnczogZmxhZ3MgfTtcbiAgICAgICAgfTtcbiAgICAgICAgVG9rZW5pemVyLnByb3RvdHlwZS5jb25zdW1lRXNjYXBlZENvZGVQb2ludCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjb2RlUG9pbnQgPSB0aGlzLmNvbnN1bWVDb2RlUG9pbnQoKTtcbiAgICAgICAgICAgIGlmIChpc0hleChjb2RlUG9pbnQpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGhleCA9IGZyb21Db2RlUG9pbnQkMShjb2RlUG9pbnQpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChpc0hleCh0aGlzLnBlZWtDb2RlUG9pbnQoMCkpICYmIGhleC5sZW5ndGggPCA2KSB7XG4gICAgICAgICAgICAgICAgICAgIGhleCArPSBmcm9tQ29kZVBvaW50JDEodGhpcy5jb25zdW1lQ29kZVBvaW50KCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNXaGl0ZVNwYWNlKHRoaXMucGVla0NvZGVQb2ludCgwKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25zdW1lQ29kZVBvaW50KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBoZXhDb2RlUG9pbnQgPSBwYXJzZUludChoZXgsIDE2KTtcbiAgICAgICAgICAgICAgICBpZiAoaGV4Q29kZVBvaW50ID09PSAwIHx8IGlzU3Vycm9nYXRlQ29kZVBvaW50KGhleENvZGVQb2ludCkgfHwgaGV4Q29kZVBvaW50ID4gMHgxMGZmZmYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJFUExBQ0VNRU5UX0NIQVJBQ1RFUjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhleENvZGVQb2ludDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb2RlUG9pbnQgPT09IEVPRikge1xuICAgICAgICAgICAgICAgIHJldHVybiBSRVBMQUNFTUVOVF9DSEFSQUNURVI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29kZVBvaW50O1xuICAgICAgICB9O1xuICAgICAgICBUb2tlbml6ZXIucHJvdG90eXBlLmNvbnN1bWVOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29kZVBvaW50ID0gdGhpcy5jb25zdW1lQ29kZVBvaW50KCk7XG4gICAgICAgICAgICAgICAgaWYgKGlzTmFtZUNvZGVQb2ludChjb2RlUG9pbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBmcm9tQ29kZVBvaW50JDEoY29kZVBvaW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNWYWxpZEVzY2FwZShjb2RlUG9pbnQsIHRoaXMucGVla0NvZGVQb2ludCgwKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IGZyb21Db2RlUG9pbnQkMSh0aGlzLmNvbnN1bWVFc2NhcGVkQ29kZVBvaW50KCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWNvbnN1bWVDb2RlUG9pbnQoY29kZVBvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBUb2tlbml6ZXI7XG4gICAgfSgpKTtcblxuICAgIHZhciBQYXJzZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFBhcnNlcih0b2tlbnMpIHtcbiAgICAgICAgICAgIHRoaXMuX3Rva2VucyA9IHRva2VucztcbiAgICAgICAgfVxuICAgICAgICBQYXJzZXIuY3JlYXRlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgdG9rZW5pemVyID0gbmV3IFRva2VuaXplcigpO1xuICAgICAgICAgICAgdG9rZW5pemVyLndyaXRlKHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUGFyc2VyKHRva2VuaXplci5yZWFkKCkpO1xuICAgICAgICB9O1xuICAgICAgICBQYXJzZXIucGFyc2VWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIFBhcnNlci5jcmVhdGUodmFsdWUpLnBhcnNlQ29tcG9uZW50VmFsdWUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgUGFyc2VyLnBhcnNlVmFsdWVzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gUGFyc2VyLmNyZWF0ZSh2YWx1ZSkucGFyc2VDb21wb25lbnRWYWx1ZXMoKTtcbiAgICAgICAgfTtcbiAgICAgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUNvbXBvbmVudFZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHRva2VuID0gdGhpcy5jb25zdW1lVG9rZW4oKTtcbiAgICAgICAgICAgIHdoaWxlICh0b2tlbi50eXBlID09PSAzMSAvKiBXSElURVNQQUNFX1RPS0VOICovKSB7XG4gICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLmNvbnN1bWVUb2tlbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IDMyIC8qIEVPRl9UT0tFTiAqLykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIkVycm9yIHBhcnNpbmcgQ1NTIGNvbXBvbmVudCB2YWx1ZSwgdW5leHBlY3RlZCBFT0ZcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlY29uc3VtZVRva2VuKHRva2VuKTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuY29uc3VtZUNvbXBvbmVudFZhbHVlKCk7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLmNvbnN1bWVUb2tlbigpO1xuICAgICAgICAgICAgfSB3aGlsZSAodG9rZW4udHlwZSA9PT0gMzEgLyogV0hJVEVTUEFDRV9UT0tFTiAqLyk7XG4gICAgICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gMzIgLyogRU9GX1RPS0VOICovKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiRXJyb3IgcGFyc2luZyBDU1MgY29tcG9uZW50IHZhbHVlLCBtdWx0aXBsZSB2YWx1ZXMgZm91bmQgd2hlbiBleHBlY3Rpbmcgb25seSBvbmVcIik7XG4gICAgICAgIH07XG4gICAgICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VDb21wb25lbnRWYWx1ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWVzID0gW107XG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuY29uc3VtZUNvbXBvbmVudFZhbHVlKCk7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLnR5cGUgPT09IDMyIC8qIEVPRl9UT0tFTiAqLykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgdmFsdWVzLnB1c2goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgUGFyc2VyLnByb3RvdHlwZS5jb25zdW1lQ29tcG9uZW50VmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLmNvbnN1bWVUb2tlbigpO1xuICAgICAgICAgICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxMSAvKiBMRUZUX0NVUkxZX0JSQUNLRVRfVE9LRU4gKi86XG4gICAgICAgICAgICAgICAgY2FzZSAyOCAvKiBMRUZUX1NRVUFSRV9CUkFDS0VUX1RPS0VOICovOlxuICAgICAgICAgICAgICAgIGNhc2UgMiAvKiBMRUZUX1BBUkVOVEhFU0lTX1RPS0VOICovOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdW1lU2ltcGxlQmxvY2sodG9rZW4udHlwZSk7XG4gICAgICAgICAgICAgICAgY2FzZSAxOSAvKiBGVU5DVElPTl9UT0tFTiAqLzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3VtZUZ1bmN0aW9uKHRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgfTtcbiAgICAgICAgUGFyc2VyLnByb3RvdHlwZS5jb25zdW1lU2ltcGxlQmxvY2sgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgICAgdmFyIGJsb2NrID0geyB0eXBlOiB0eXBlLCB2YWx1ZXM6IFtdIH07XG4gICAgICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLmNvbnN1bWVUb2tlbigpO1xuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gMzIgLyogRU9GX1RPS0VOICovIHx8IGlzRW5kaW5nVG9rZW5Gb3IodG9rZW4sIHR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBibG9jaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5yZWNvbnN1bWVUb2tlbih0b2tlbik7XG4gICAgICAgICAgICAgICAgYmxvY2sudmFsdWVzLnB1c2godGhpcy5jb25zdW1lQ29tcG9uZW50VmFsdWUoKSk7XG4gICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLmNvbnN1bWVUb2tlbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBQYXJzZXIucHJvdG90eXBlLmNvbnN1bWVGdW5jdGlvbiA9IGZ1bmN0aW9uIChmdW5jdGlvblRva2VuKSB7XG4gICAgICAgICAgICB2YXIgY3NzRnVuY3Rpb24gPSB7XG4gICAgICAgICAgICAgICAgbmFtZTogZnVuY3Rpb25Ub2tlbi52YWx1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZXM6IFtdLFxuICAgICAgICAgICAgICAgIHR5cGU6IDE4IC8qIEZVTkNUSU9OICovXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLmNvbnN1bWVUb2tlbigpO1xuICAgICAgICAgICAgICAgIGlmICh0b2tlbi50eXBlID09PSAzMiAvKiBFT0ZfVE9LRU4gKi8gfHwgdG9rZW4udHlwZSA9PT0gMyAvKiBSSUdIVF9QQVJFTlRIRVNJU19UT0tFTiAqLykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3NzRnVuY3Rpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucmVjb25zdW1lVG9rZW4odG9rZW4pO1xuICAgICAgICAgICAgICAgIGNzc0Z1bmN0aW9uLnZhbHVlcy5wdXNoKHRoaXMuY29uc3VtZUNvbXBvbmVudFZhbHVlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBQYXJzZXIucHJvdG90eXBlLmNvbnN1bWVUb2tlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0b2tlbiA9IHRoaXMuX3Rva2Vucy5zaGlmdCgpO1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB0b2tlbiA9PT0gJ3VuZGVmaW5lZCcgPyBFT0ZfVE9LRU4gOiB0b2tlbjtcbiAgICAgICAgfTtcbiAgICAgICAgUGFyc2VyLnByb3RvdHlwZS5yZWNvbnN1bWVUb2tlbiA9IGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICAgICAgdGhpcy5fdG9rZW5zLnVuc2hpZnQodG9rZW4pO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gUGFyc2VyO1xuICAgIH0oKSk7XG4gICAgdmFyIGlzRGltZW5zaW9uVG9rZW4gPSBmdW5jdGlvbiAodG9rZW4pIHsgcmV0dXJuIHRva2VuLnR5cGUgPT09IDE1IC8qIERJTUVOU0lPTl9UT0tFTiAqLzsgfTtcbiAgICB2YXIgaXNOdW1iZXJUb2tlbiA9IGZ1bmN0aW9uICh0b2tlbikgeyByZXR1cm4gdG9rZW4udHlwZSA9PT0gMTcgLyogTlVNQkVSX1RPS0VOICovOyB9O1xuICAgIHZhciBpc0lkZW50VG9rZW4gPSBmdW5jdGlvbiAodG9rZW4pIHsgcmV0dXJuIHRva2VuLnR5cGUgPT09IDIwIC8qIElERU5UX1RPS0VOICovOyB9O1xuICAgIHZhciBpc1N0cmluZ1Rva2VuID0gZnVuY3Rpb24gKHRva2VuKSB7IHJldHVybiB0b2tlbi50eXBlID09PSAwIC8qIFNUUklOR19UT0tFTiAqLzsgfTtcbiAgICB2YXIgaXNJZGVudFdpdGhWYWx1ZSA9IGZ1bmN0aW9uICh0b2tlbiwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGlzSWRlbnRUb2tlbih0b2tlbikgJiYgdG9rZW4udmFsdWUgPT09IHZhbHVlO1xuICAgIH07XG4gICAgdmFyIG5vbldoaXRlU3BhY2UgPSBmdW5jdGlvbiAodG9rZW4pIHsgcmV0dXJuIHRva2VuLnR5cGUgIT09IDMxIC8qIFdISVRFU1BBQ0VfVE9LRU4gKi87IH07XG4gICAgdmFyIG5vbkZ1bmN0aW9uQXJnU2VwYXJhdG9yID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgIHJldHVybiB0b2tlbi50eXBlICE9PSAzMSAvKiBXSElURVNQQUNFX1RPS0VOICovICYmIHRva2VuLnR5cGUgIT09IDQgLyogQ09NTUFfVE9LRU4gKi87XG4gICAgfTtcbiAgICB2YXIgcGFyc2VGdW5jdGlvbkFyZ3MgPSBmdW5jdGlvbiAodG9rZW5zKSB7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIHZhciBhcmcgPSBbXTtcbiAgICAgICAgdG9rZW5zLmZvckVhY2goZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gNCAvKiBDT01NQV9UT0tFTiAqLykge1xuICAgICAgICAgICAgICAgIGlmIChhcmcubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVycm9yIHBhcnNpbmcgZnVuY3Rpb24gYXJncywgemVybyB0b2tlbnMgZm9yIGFyZ1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXJncy5wdXNoKGFyZyk7XG4gICAgICAgICAgICAgICAgYXJnID0gW107XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRva2VuLnR5cGUgIT09IDMxIC8qIFdISVRFU1BBQ0VfVE9LRU4gKi8pIHtcbiAgICAgICAgICAgICAgICBhcmcucHVzaCh0b2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoYXJnLmxlbmd0aCkge1xuICAgICAgICAgICAgYXJncy5wdXNoKGFyZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFyZ3M7XG4gICAgfTtcbiAgICB2YXIgaXNFbmRpbmdUb2tlbkZvciA9IGZ1bmN0aW9uICh0b2tlbiwgdHlwZSkge1xuICAgICAgICBpZiAodHlwZSA9PT0gMTEgLyogTEVGVF9DVVJMWV9CUkFDS0VUX1RPS0VOICovICYmIHRva2VuLnR5cGUgPT09IDEyIC8qIFJJR0hUX0NVUkxZX0JSQUNLRVRfVE9LRU4gKi8pIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAyOCAvKiBMRUZUX1NRVUFSRV9CUkFDS0VUX1RPS0VOICovICYmIHRva2VuLnR5cGUgPT09IDI5IC8qIFJJR0hUX1NRVUFSRV9CUkFDS0VUX1RPS0VOICovKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHlwZSA9PT0gMiAvKiBMRUZUX1BBUkVOVEhFU0lTX1RPS0VOICovICYmIHRva2VuLnR5cGUgPT09IDMgLyogUklHSFRfUEFSRU5USEVTSVNfVE9LRU4gKi87XG4gICAgfTtcblxuICAgIHZhciBpc0xlbmd0aCA9IGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICByZXR1cm4gdG9rZW4udHlwZSA9PT0gMTcgLyogTlVNQkVSX1RPS0VOICovIHx8IHRva2VuLnR5cGUgPT09IDE1IC8qIERJTUVOU0lPTl9UT0tFTiAqLztcbiAgICB9O1xuXG4gICAgdmFyIGlzTGVuZ3RoUGVyY2VudGFnZSA9IGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICByZXR1cm4gdG9rZW4udHlwZSA9PT0gMTYgLyogUEVSQ0VOVEFHRV9UT0tFTiAqLyB8fCBpc0xlbmd0aCh0b2tlbik7XG4gICAgfTtcbiAgICB2YXIgcGFyc2VMZW5ndGhQZXJjZW50YWdlVHVwbGUgPSBmdW5jdGlvbiAodG9rZW5zKSB7XG4gICAgICAgIHJldHVybiB0b2tlbnMubGVuZ3RoID4gMSA/IFt0b2tlbnNbMF0sIHRva2Vuc1sxXV0gOiBbdG9rZW5zWzBdXTtcbiAgICB9O1xuICAgIHZhciBaRVJPX0xFTkdUSCA9IHtcbiAgICAgICAgdHlwZTogMTcgLyogTlVNQkVSX1RPS0VOICovLFxuICAgICAgICBudW1iZXI6IDAsXG4gICAgICAgIGZsYWdzOiBGTEFHX0lOVEVHRVJcbiAgICB9O1xuICAgIHZhciBGSUZUWV9QRVJDRU5UID0ge1xuICAgICAgICB0eXBlOiAxNiAvKiBQRVJDRU5UQUdFX1RPS0VOICovLFxuICAgICAgICBudW1iZXI6IDUwLFxuICAgICAgICBmbGFnczogRkxBR19JTlRFR0VSXG4gICAgfTtcbiAgICB2YXIgSFVORFJFRF9QRVJDRU5UID0ge1xuICAgICAgICB0eXBlOiAxNiAvKiBQRVJDRU5UQUdFX1RPS0VOICovLFxuICAgICAgICBudW1iZXI6IDEwMCxcbiAgICAgICAgZmxhZ3M6IEZMQUdfSU5URUdFUlxuICAgIH07XG4gICAgdmFyIGdldEFic29sdXRlVmFsdWVGb3JUdXBsZSA9IGZ1bmN0aW9uICh0dXBsZSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICB2YXIgeCA9IHR1cGxlWzBdLCB5ID0gdHVwbGVbMV07XG4gICAgICAgIHJldHVybiBbZ2V0QWJzb2x1dGVWYWx1ZSh4LCB3aWR0aCksIGdldEFic29sdXRlVmFsdWUodHlwZW9mIHkgIT09ICd1bmRlZmluZWQnID8geSA6IHgsIGhlaWdodCldO1xuICAgIH07XG4gICAgdmFyIGdldEFic29sdXRlVmFsdWUgPSBmdW5jdGlvbiAodG9rZW4sIHBhcmVudCkge1xuICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gMTYgLyogUEVSQ0VOVEFHRV9UT0tFTiAqLykge1xuICAgICAgICAgICAgcmV0dXJuICh0b2tlbi5udW1iZXIgLyAxMDApICogcGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0RpbWVuc2lvblRva2VuKHRva2VuKSkge1xuICAgICAgICAgICAgc3dpdGNoICh0b2tlbi51bml0KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAncmVtJzpcbiAgICAgICAgICAgICAgICBjYXNlICdlbSc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxNiAqIHRva2VuLm51bWJlcjsgLy8gVE9ETyB1c2UgY29ycmVjdCBmb250LXNpemVcbiAgICAgICAgICAgICAgICBjYXNlICdweCc6XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuLm51bWJlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9rZW4ubnVtYmVyO1xuICAgIH07XG5cbiAgICB2YXIgREVHID0gJ2RlZyc7XG4gICAgdmFyIEdSQUQgPSAnZ3JhZCc7XG4gICAgdmFyIFJBRCA9ICdyYWQnO1xuICAgIHZhciBUVVJOID0gJ3R1cm4nO1xuICAgIHZhciBhbmdsZSA9IHtcbiAgICAgICAgbmFtZTogJ2FuZ2xlJyxcbiAgICAgICAgcGFyc2U6IGZ1bmN0aW9uIChfY29udGV4dCwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZS50eXBlID09PSAxNSAvKiBESU1FTlNJT05fVE9LRU4gKi8pIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHZhbHVlLnVuaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBERUc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKE1hdGguUEkgKiB2YWx1ZS5udW1iZXIpIC8gMTgwO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIEdSQUQ6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKE1hdGguUEkgLyAyMDApICogdmFsdWUubnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFJBRDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5udW1iZXI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgVFVSTjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLlBJICogMiAqIHZhbHVlLm51bWJlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBhbmdsZSB0eXBlXCIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgaXNBbmdsZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUudHlwZSA9PT0gMTUgLyogRElNRU5TSU9OX1RPS0VOICovKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUudW5pdCA9PT0gREVHIHx8IHZhbHVlLnVuaXQgPT09IEdSQUQgfHwgdmFsdWUudW5pdCA9PT0gUkFEIHx8IHZhbHVlLnVuaXQgPT09IFRVUk4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICB2YXIgcGFyc2VOYW1lZFNpZGUgPSBmdW5jdGlvbiAodG9rZW5zKSB7XG4gICAgICAgIHZhciBzaWRlT3JDb3JuZXIgPSB0b2tlbnNcbiAgICAgICAgICAgIC5maWx0ZXIoaXNJZGVudFRva2VuKVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoaWRlbnQpIHsgcmV0dXJuIGlkZW50LnZhbHVlOyB9KVxuICAgICAgICAgICAgLmpvaW4oJyAnKTtcbiAgICAgICAgc3dpdGNoIChzaWRlT3JDb3JuZXIpIHtcbiAgICAgICAgICAgIGNhc2UgJ3RvIGJvdHRvbSByaWdodCc6XG4gICAgICAgICAgICBjYXNlICd0byByaWdodCBib3R0b20nOlxuICAgICAgICAgICAgY2FzZSAnbGVmdCB0b3AnOlxuICAgICAgICAgICAgY2FzZSAndG9wIGxlZnQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBbWkVST19MRU5HVEgsIFpFUk9fTEVOR1RIXTtcbiAgICAgICAgICAgIGNhc2UgJ3RvIHRvcCc6XG4gICAgICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgICAgICAgIHJldHVybiBkZWcoMCk7XG4gICAgICAgICAgICBjYXNlICd0byBib3R0b20gbGVmdCc6XG4gICAgICAgICAgICBjYXNlICd0byBsZWZ0IGJvdHRvbSc6XG4gICAgICAgICAgICBjYXNlICdyaWdodCB0b3AnOlxuICAgICAgICAgICAgY2FzZSAndG9wIHJpZ2h0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gW1pFUk9fTEVOR1RILCBIVU5EUkVEX1BFUkNFTlRdO1xuICAgICAgICAgICAgY2FzZSAndG8gcmlnaHQnOlxuICAgICAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZyg5MCk7XG4gICAgICAgICAgICBjYXNlICd0byB0b3AgbGVmdCc6XG4gICAgICAgICAgICBjYXNlICd0byBsZWZ0IHRvcCc6XG4gICAgICAgICAgICBjYXNlICdyaWdodCBib3R0b20nOlxuICAgICAgICAgICAgY2FzZSAnYm90dG9tIHJpZ2h0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gW0hVTkRSRURfUEVSQ0VOVCwgSFVORFJFRF9QRVJDRU5UXTtcbiAgICAgICAgICAgIGNhc2UgJ3RvIGJvdHRvbSc6XG4gICAgICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgICAgICAgIHJldHVybiBkZWcoMTgwKTtcbiAgICAgICAgICAgIGNhc2UgJ3RvIHRvcCByaWdodCc6XG4gICAgICAgICAgICBjYXNlICd0byByaWdodCB0b3AnOlxuICAgICAgICAgICAgY2FzZSAnbGVmdCBib3R0b20nOlxuICAgICAgICAgICAgY2FzZSAnYm90dG9tIGxlZnQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBbSFVORFJFRF9QRVJDRU5ULCBaRVJPX0xFTkdUSF07XG4gICAgICAgICAgICBjYXNlICd0byBsZWZ0JzpcbiAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVnKDI3MCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfTtcbiAgICB2YXIgZGVnID0gZnVuY3Rpb24gKGRlZykgeyByZXR1cm4gKE1hdGguUEkgKiBkZWcpIC8gMTgwOyB9O1xuXG4gICAgdmFyIGNvbG9yJDEgPSB7XG4gICAgICAgIG5hbWU6ICdjb2xvcicsXG4gICAgICAgIHBhcnNlOiBmdW5jdGlvbiAoY29udGV4dCwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZS50eXBlID09PSAxOCAvKiBGVU5DVElPTiAqLykge1xuICAgICAgICAgICAgICAgIHZhciBjb2xvckZ1bmN0aW9uID0gU1VQUE9SVEVEX0NPTE9SX0ZVTkNUSU9OU1t2YWx1ZS5uYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbG9yRnVuY3Rpb24gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkF0dGVtcHRpbmcgdG8gcGFyc2UgYW4gdW5zdXBwb3J0ZWQgY29sb3IgZnVuY3Rpb24gXFxcIlwiICsgdmFsdWUubmFtZSArIFwiXFxcIlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbG9yRnVuY3Rpb24oY29udGV4dCwgdmFsdWUudmFsdWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZS50eXBlID09PSA1IC8qIEhBU0hfVE9LRU4gKi8pIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUudmFsdWUubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByID0gdmFsdWUudmFsdWUuc3Vic3RyaW5nKDAsIDEpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZyA9IHZhbHVlLnZhbHVlLnN1YnN0cmluZygxLCAyKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGIgPSB2YWx1ZS52YWx1ZS5zdWJzdHJpbmcoMiwgMyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYWNrKHBhcnNlSW50KHIgKyByLCAxNiksIHBhcnNlSW50KGcgKyBnLCAxNiksIHBhcnNlSW50KGIgKyBiLCAxNiksIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUudmFsdWUubGVuZ3RoID09PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByID0gdmFsdWUudmFsdWUuc3Vic3RyaW5nKDAsIDEpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZyA9IHZhbHVlLnZhbHVlLnN1YnN0cmluZygxLCAyKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGIgPSB2YWx1ZS52YWx1ZS5zdWJzdHJpbmcoMiwgMyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhID0gdmFsdWUudmFsdWUuc3Vic3RyaW5nKDMsIDQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFjayhwYXJzZUludChyICsgciwgMTYpLCBwYXJzZUludChnICsgZywgMTYpLCBwYXJzZUludChiICsgYiwgMTYpLCBwYXJzZUludChhICsgYSwgMTYpIC8gMjU1KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLnZhbHVlLmxlbmd0aCA9PT0gNikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgciA9IHZhbHVlLnZhbHVlLnN1YnN0cmluZygwLCAyKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGcgPSB2YWx1ZS52YWx1ZS5zdWJzdHJpbmcoMiwgNCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiID0gdmFsdWUudmFsdWUuc3Vic3RyaW5nKDQsIDYpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFjayhwYXJzZUludChyLCAxNiksIHBhcnNlSW50KGcsIDE2KSwgcGFyc2VJbnQoYiwgMTYpLCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLnZhbHVlLmxlbmd0aCA9PT0gOCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgciA9IHZhbHVlLnZhbHVlLnN1YnN0cmluZygwLCAyKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGcgPSB2YWx1ZS52YWx1ZS5zdWJzdHJpbmcoMiwgNCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiID0gdmFsdWUudmFsdWUuc3Vic3RyaW5nKDQsIDYpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IHZhbHVlLnZhbHVlLnN1YnN0cmluZyg2LCA4KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhY2socGFyc2VJbnQociwgMTYpLCBwYXJzZUludChnLCAxNiksIHBhcnNlSW50KGIsIDE2KSwgcGFyc2VJbnQoYSwgMTYpIC8gMjU1KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUudHlwZSA9PT0gMjAgLyogSURFTlRfVE9LRU4gKi8pIHtcbiAgICAgICAgICAgICAgICB2YXIgbmFtZWRDb2xvciA9IENPTE9SU1t2YWx1ZS52YWx1ZS50b1VwcGVyQ2FzZSgpXTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG5hbWVkQ29sb3IgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuYW1lZENvbG9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBDT0xPUlMuVFJBTlNQQVJFTlQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBpc1RyYW5zcGFyZW50ID0gZnVuY3Rpb24gKGNvbG9yKSB7IHJldHVybiAoMHhmZiAmIGNvbG9yKSA9PT0gMDsgfTtcbiAgICB2YXIgYXNTdHJpbmcgPSBmdW5jdGlvbiAoY29sb3IpIHtcbiAgICAgICAgdmFyIGFscGhhID0gMHhmZiAmIGNvbG9yO1xuICAgICAgICB2YXIgYmx1ZSA9IDB4ZmYgJiAoY29sb3IgPj4gOCk7XG4gICAgICAgIHZhciBncmVlbiA9IDB4ZmYgJiAoY29sb3IgPj4gMTYpO1xuICAgICAgICB2YXIgcmVkID0gMHhmZiAmIChjb2xvciA+PiAyNCk7XG4gICAgICAgIHJldHVybiBhbHBoYSA8IDI1NSA/IFwicmdiYShcIiArIHJlZCArIFwiLFwiICsgZ3JlZW4gKyBcIixcIiArIGJsdWUgKyBcIixcIiArIGFscGhhIC8gMjU1ICsgXCIpXCIgOiBcInJnYihcIiArIHJlZCArIFwiLFwiICsgZ3JlZW4gKyBcIixcIiArIGJsdWUgKyBcIilcIjtcbiAgICB9O1xuICAgIHZhciBwYWNrID0gZnVuY3Rpb24gKHIsIGcsIGIsIGEpIHtcbiAgICAgICAgcmV0dXJuICgociA8PCAyNCkgfCAoZyA8PCAxNikgfCAoYiA8PCA4KSB8IChNYXRoLnJvdW5kKGEgKiAyNTUpIDw8IDApKSA+Pj4gMDtcbiAgICB9O1xuICAgIHZhciBnZXRUb2tlbkNvbG9yVmFsdWUgPSBmdW5jdGlvbiAodG9rZW4sIGkpIHtcbiAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IDE3IC8qIE5VTUJFUl9UT0tFTiAqLykge1xuICAgICAgICAgICAgcmV0dXJuIHRva2VuLm51bWJlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gMTYgLyogUEVSQ0VOVEFHRV9UT0tFTiAqLykge1xuICAgICAgICAgICAgdmFyIG1heCA9IGkgPT09IDMgPyAxIDogMjU1O1xuICAgICAgICAgICAgcmV0dXJuIGkgPT09IDMgPyAodG9rZW4ubnVtYmVyIC8gMTAwKSAqIG1heCA6IE1hdGgucm91bmQoKHRva2VuLm51bWJlciAvIDEwMCkgKiBtYXgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH07XG4gICAgdmFyIHJnYiA9IGZ1bmN0aW9uIChfY29udGV4dCwgYXJncykge1xuICAgICAgICB2YXIgdG9rZW5zID0gYXJncy5maWx0ZXIobm9uRnVuY3Rpb25BcmdTZXBhcmF0b3IpO1xuICAgICAgICBpZiAodG9rZW5zLmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgdmFyIF9hID0gdG9rZW5zLm1hcChnZXRUb2tlbkNvbG9yVmFsdWUpLCByID0gX2FbMF0sIGcgPSBfYVsxXSwgYiA9IF9hWzJdO1xuICAgICAgICAgICAgcmV0dXJuIHBhY2sociwgZywgYiwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRva2Vucy5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgICAgIHZhciBfYiA9IHRva2Vucy5tYXAoZ2V0VG9rZW5Db2xvclZhbHVlKSwgciA9IF9iWzBdLCBnID0gX2JbMV0sIGIgPSBfYlsyXSwgYSA9IF9iWzNdO1xuICAgICAgICAgICAgcmV0dXJuIHBhY2sociwgZywgYiwgYSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBodWUycmdiKHQxLCB0MiwgaHVlKSB7XG4gICAgICAgIGlmIChodWUgPCAwKSB7XG4gICAgICAgICAgICBodWUgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaHVlID49IDEpIHtcbiAgICAgICAgICAgIGh1ZSAtPSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChodWUgPCAxIC8gNikge1xuICAgICAgICAgICAgcmV0dXJuICh0MiAtIHQxKSAqIGh1ZSAqIDYgKyB0MTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChodWUgPCAxIC8gMikge1xuICAgICAgICAgICAgcmV0dXJuIHQyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGh1ZSA8IDIgLyAzKSB7XG4gICAgICAgICAgICByZXR1cm4gKHQyIC0gdDEpICogNiAqICgyIC8gMyAtIGh1ZSkgKyB0MTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0MTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgaHNsID0gZnVuY3Rpb24gKGNvbnRleHQsIGFyZ3MpIHtcbiAgICAgICAgdmFyIHRva2VucyA9IGFyZ3MuZmlsdGVyKG5vbkZ1bmN0aW9uQXJnU2VwYXJhdG9yKTtcbiAgICAgICAgdmFyIGh1ZSA9IHRva2Vuc1swXSwgc2F0dXJhdGlvbiA9IHRva2Vuc1sxXSwgbGlnaHRuZXNzID0gdG9rZW5zWzJdLCBhbHBoYSA9IHRva2Vuc1szXTtcbiAgICAgICAgdmFyIGggPSAoaHVlLnR5cGUgPT09IDE3IC8qIE5VTUJFUl9UT0tFTiAqLyA/IGRlZyhodWUubnVtYmVyKSA6IGFuZ2xlLnBhcnNlKGNvbnRleHQsIGh1ZSkpIC8gKE1hdGguUEkgKiAyKTtcbiAgICAgICAgdmFyIHMgPSBpc0xlbmd0aFBlcmNlbnRhZ2Uoc2F0dXJhdGlvbikgPyBzYXR1cmF0aW9uLm51bWJlciAvIDEwMCA6IDA7XG4gICAgICAgIHZhciBsID0gaXNMZW5ndGhQZXJjZW50YWdlKGxpZ2h0bmVzcykgPyBsaWdodG5lc3MubnVtYmVyIC8gMTAwIDogMDtcbiAgICAgICAgdmFyIGEgPSB0eXBlb2YgYWxwaGEgIT09ICd1bmRlZmluZWQnICYmIGlzTGVuZ3RoUGVyY2VudGFnZShhbHBoYSkgPyBnZXRBYnNvbHV0ZVZhbHVlKGFscGhhLCAxKSA6IDE7XG4gICAgICAgIGlmIChzID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFjayhsICogMjU1LCBsICogMjU1LCBsICogMjU1LCAxKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdDIgPSBsIDw9IDAuNSA/IGwgKiAocyArIDEpIDogbCArIHMgLSBsICogcztcbiAgICAgICAgdmFyIHQxID0gbCAqIDIgLSB0MjtcbiAgICAgICAgdmFyIHIgPSBodWUycmdiKHQxLCB0MiwgaCArIDEgLyAzKTtcbiAgICAgICAgdmFyIGcgPSBodWUycmdiKHQxLCB0MiwgaCk7XG4gICAgICAgIHZhciBiID0gaHVlMnJnYih0MSwgdDIsIGggLSAxIC8gMyk7XG4gICAgICAgIHJldHVybiBwYWNrKHIgKiAyNTUsIGcgKiAyNTUsIGIgKiAyNTUsIGEpO1xuICAgIH07XG4gICAgdmFyIFNVUFBPUlRFRF9DT0xPUl9GVU5DVElPTlMgPSB7XG4gICAgICAgIGhzbDogaHNsLFxuICAgICAgICBoc2xhOiBoc2wsXG4gICAgICAgIHJnYjogcmdiLFxuICAgICAgICByZ2JhOiByZ2JcbiAgICB9O1xuICAgIHZhciBwYXJzZUNvbG9yID0gZnVuY3Rpb24gKGNvbnRleHQsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBjb2xvciQxLnBhcnNlKGNvbnRleHQsIFBhcnNlci5jcmVhdGUodmFsdWUpLnBhcnNlQ29tcG9uZW50VmFsdWUoKSk7XG4gICAgfTtcbiAgICB2YXIgQ09MT1JTID0ge1xuICAgICAgICBBTElDRUJMVUU6IDB4ZjBmOGZmZmYsXG4gICAgICAgIEFOVElRVUVXSElURTogMHhmYWViZDdmZixcbiAgICAgICAgQVFVQTogMHgwMGZmZmZmZixcbiAgICAgICAgQVFVQU1BUklORTogMHg3ZmZmZDRmZixcbiAgICAgICAgQVpVUkU6IDB4ZjBmZmZmZmYsXG4gICAgICAgIEJFSUdFOiAweGY1ZjVkY2ZmLFxuICAgICAgICBCSVNRVUU6IDB4ZmZlNGM0ZmYsXG4gICAgICAgIEJMQUNLOiAweDAwMDAwMGZmLFxuICAgICAgICBCTEFOQ0hFREFMTU9ORDogMHhmZmViY2RmZixcbiAgICAgICAgQkxVRTogMHgwMDAwZmZmZixcbiAgICAgICAgQkxVRVZJT0xFVDogMHg4YTJiZTJmZixcbiAgICAgICAgQlJPV046IDB4YTUyYTJhZmYsXG4gICAgICAgIEJVUkxZV09PRDogMHhkZWI4ODdmZixcbiAgICAgICAgQ0FERVRCTFVFOiAweDVmOWVhMGZmLFxuICAgICAgICBDSEFSVFJFVVNFOiAweDdmZmYwMGZmLFxuICAgICAgICBDSE9DT0xBVEU6IDB4ZDI2OTFlZmYsXG4gICAgICAgIENPUkFMOiAweGZmN2Y1MGZmLFxuICAgICAgICBDT1JORkxPV0VSQkxVRTogMHg2NDk1ZWRmZixcbiAgICAgICAgQ09STlNJTEs6IDB4ZmZmOGRjZmYsXG4gICAgICAgIENSSU1TT046IDB4ZGMxNDNjZmYsXG4gICAgICAgIENZQU46IDB4MDBmZmZmZmYsXG4gICAgICAgIERBUktCTFVFOiAweDAwMDA4YmZmLFxuICAgICAgICBEQVJLQ1lBTjogMHgwMDhiOGJmZixcbiAgICAgICAgREFSS0dPTERFTlJPRDogMHhiODg2YmJmZixcbiAgICAgICAgREFSS0dSQVk6IDB4YTlhOWE5ZmYsXG4gICAgICAgIERBUktHUkVFTjogMHgwMDY0MDBmZixcbiAgICAgICAgREFSS0dSRVk6IDB4YTlhOWE5ZmYsXG4gICAgICAgIERBUktLSEFLSTogMHhiZGI3NmJmZixcbiAgICAgICAgREFSS01BR0VOVEE6IDB4OGIwMDhiZmYsXG4gICAgICAgIERBUktPTElWRUdSRUVOOiAweDU1NmIyZmZmLFxuICAgICAgICBEQVJLT1JBTkdFOiAweGZmOGMwMGZmLFxuICAgICAgICBEQVJLT1JDSElEOiAweDk5MzJjY2ZmLFxuICAgICAgICBEQVJLUkVEOiAweDhiMDAwMGZmLFxuICAgICAgICBEQVJLU0FMTU9OOiAweGU5OTY3YWZmLFxuICAgICAgICBEQVJLU0VBR1JFRU46IDB4OGZiYzhmZmYsXG4gICAgICAgIERBUktTTEFURUJMVUU6IDB4NDgzZDhiZmYsXG4gICAgICAgIERBUktTTEFURUdSQVk6IDB4MmY0ZjRmZmYsXG4gICAgICAgIERBUktTTEFURUdSRVk6IDB4MmY0ZjRmZmYsXG4gICAgICAgIERBUktUVVJRVU9JU0U6IDB4MDBjZWQxZmYsXG4gICAgICAgIERBUktWSU9MRVQ6IDB4OTQwMGQzZmYsXG4gICAgICAgIERFRVBQSU5LOiAweGZmMTQ5M2ZmLFxuICAgICAgICBERUVQU0tZQkxVRTogMHgwMGJmZmZmZixcbiAgICAgICAgRElNR1JBWTogMHg2OTY5NjlmZixcbiAgICAgICAgRElNR1JFWTogMHg2OTY5NjlmZixcbiAgICAgICAgRE9ER0VSQkxVRTogMHgxZTkwZmZmZixcbiAgICAgICAgRklSRUJSSUNLOiAweGIyMjIyMmZmLFxuICAgICAgICBGTE9SQUxXSElURTogMHhmZmZhZjBmZixcbiAgICAgICAgRk9SRVNUR1JFRU46IDB4MjI4YjIyZmYsXG4gICAgICAgIEZVQ0hTSUE6IDB4ZmYwMGZmZmYsXG4gICAgICAgIEdBSU5TQk9STzogMHhkY2RjZGNmZixcbiAgICAgICAgR0hPU1RXSElURTogMHhmOGY4ZmZmZixcbiAgICAgICAgR09MRDogMHhmZmQ3MDBmZixcbiAgICAgICAgR09MREVOUk9EOiAweGRhYTUyMGZmLFxuICAgICAgICBHUkFZOiAweDgwODA4MGZmLFxuICAgICAgICBHUkVFTjogMHgwMDgwMDBmZixcbiAgICAgICAgR1JFRU5ZRUxMT1c6IDB4YWRmZjJmZmYsXG4gICAgICAgIEdSRVk6IDB4ODA4MDgwZmYsXG4gICAgICAgIEhPTkVZREVXOiAweGYwZmZmMGZmLFxuICAgICAgICBIT1RQSU5LOiAweGZmNjliNGZmLFxuICAgICAgICBJTkRJQU5SRUQ6IDB4Y2Q1YzVjZmYsXG4gICAgICAgIElORElHTzogMHg0YjAwODJmZixcbiAgICAgICAgSVZPUlk6IDB4ZmZmZmYwZmYsXG4gICAgICAgIEtIQUtJOiAweGYwZTY4Y2ZmLFxuICAgICAgICBMQVZFTkRFUjogMHhlNmU2ZmFmZixcbiAgICAgICAgTEFWRU5ERVJCTFVTSDogMHhmZmYwZjVmZixcbiAgICAgICAgTEFXTkdSRUVOOiAweDdjZmMwMGZmLFxuICAgICAgICBMRU1PTkNISUZGT046IDB4ZmZmYWNkZmYsXG4gICAgICAgIExJR0hUQkxVRTogMHhhZGQ4ZTZmZixcbiAgICAgICAgTElHSFRDT1JBTDogMHhmMDgwODBmZixcbiAgICAgICAgTElHSFRDWUFOOiAweGUwZmZmZmZmLFxuICAgICAgICBMSUdIVEdPTERFTlJPRFlFTExPVzogMHhmYWZhZDJmZixcbiAgICAgICAgTElHSFRHUkFZOiAweGQzZDNkM2ZmLFxuICAgICAgICBMSUdIVEdSRUVOOiAweDkwZWU5MGZmLFxuICAgICAgICBMSUdIVEdSRVk6IDB4ZDNkM2QzZmYsXG4gICAgICAgIExJR0hUUElOSzogMHhmZmI2YzFmZixcbiAgICAgICAgTElHSFRTQUxNT046IDB4ZmZhMDdhZmYsXG4gICAgICAgIExJR0hUU0VBR1JFRU46IDB4MjBiMmFhZmYsXG4gICAgICAgIExJR0hUU0tZQkxVRTogMHg4N2NlZmFmZixcbiAgICAgICAgTElHSFRTTEFURUdSQVk6IDB4Nzc4ODk5ZmYsXG4gICAgICAgIExJR0hUU0xBVEVHUkVZOiAweDc3ODg5OWZmLFxuICAgICAgICBMSUdIVFNURUVMQkxVRTogMHhiMGM0ZGVmZixcbiAgICAgICAgTElHSFRZRUxMT1c6IDB4ZmZmZmUwZmYsXG4gICAgICAgIExJTUU6IDB4MDBmZjAwZmYsXG4gICAgICAgIExJTUVHUkVFTjogMHgzMmNkMzJmZixcbiAgICAgICAgTElORU46IDB4ZmFmMGU2ZmYsXG4gICAgICAgIE1BR0VOVEE6IDB4ZmYwMGZmZmYsXG4gICAgICAgIE1BUk9PTjogMHg4MDAwMDBmZixcbiAgICAgICAgTUVESVVNQVFVQU1BUklORTogMHg2NmNkYWFmZixcbiAgICAgICAgTUVESVVNQkxVRTogMHgwMDAwY2RmZixcbiAgICAgICAgTUVESVVNT1JDSElEOiAweGJhNTVkM2ZmLFxuICAgICAgICBNRURJVU1QVVJQTEU6IDB4OTM3MGRiZmYsXG4gICAgICAgIE1FRElVTVNFQUdSRUVOOiAweDNjYjM3MWZmLFxuICAgICAgICBNRURJVU1TTEFURUJMVUU6IDB4N2I2OGVlZmYsXG4gICAgICAgIE1FRElVTVNQUklOR0dSRUVOOiAweDAwZmE5YWZmLFxuICAgICAgICBNRURJVU1UVVJRVU9JU0U6IDB4NDhkMWNjZmYsXG4gICAgICAgIE1FRElVTVZJT0xFVFJFRDogMHhjNzE1ODVmZixcbiAgICAgICAgTUlETklHSFRCTFVFOiAweDE5MTk3MGZmLFxuICAgICAgICBNSU5UQ1JFQU06IDB4ZjVmZmZhZmYsXG4gICAgICAgIE1JU1RZUk9TRTogMHhmZmU0ZTFmZixcbiAgICAgICAgTU9DQ0FTSU46IDB4ZmZlNGI1ZmYsXG4gICAgICAgIE5BVkFKT1dISVRFOiAweGZmZGVhZGZmLFxuICAgICAgICBOQVZZOiAweDAwMDA4MGZmLFxuICAgICAgICBPTERMQUNFOiAweGZkZjVlNmZmLFxuICAgICAgICBPTElWRTogMHg4MDgwMDBmZixcbiAgICAgICAgT0xJVkVEUkFCOiAweDZiOGUyM2ZmLFxuICAgICAgICBPUkFOR0U6IDB4ZmZhNTAwZmYsXG4gICAgICAgIE9SQU5HRVJFRDogMHhmZjQ1MDBmZixcbiAgICAgICAgT1JDSElEOiAweGRhNzBkNmZmLFxuICAgICAgICBQQUxFR09MREVOUk9EOiAweGVlZThhYWZmLFxuICAgICAgICBQQUxFR1JFRU46IDB4OThmYjk4ZmYsXG4gICAgICAgIFBBTEVUVVJRVU9JU0U6IDB4YWZlZWVlZmYsXG4gICAgICAgIFBBTEVWSU9MRVRSRUQ6IDB4ZGI3MDkzZmYsXG4gICAgICAgIFBBUEFZQVdISVA6IDB4ZmZlZmQ1ZmYsXG4gICAgICAgIFBFQUNIUFVGRjogMHhmZmRhYjlmZixcbiAgICAgICAgUEVSVTogMHhjZDg1M2ZmZixcbiAgICAgICAgUElOSzogMHhmZmMwY2JmZixcbiAgICAgICAgUExVTTogMHhkZGEwZGRmZixcbiAgICAgICAgUE9XREVSQkxVRTogMHhiMGUwZTZmZixcbiAgICAgICAgUFVSUExFOiAweDgwMDA4MGZmLFxuICAgICAgICBSRUJFQ0NBUFVSUExFOiAweDY2MzM5OWZmLFxuICAgICAgICBSRUQ6IDB4ZmYwMDAwZmYsXG4gICAgICAgIFJPU1lCUk9XTjogMHhiYzhmOGZmZixcbiAgICAgICAgUk9ZQUxCTFVFOiAweDQxNjllMWZmLFxuICAgICAgICBTQURETEVCUk9XTjogMHg4YjQ1MTNmZixcbiAgICAgICAgU0FMTU9OOiAweGZhODA3MmZmLFxuICAgICAgICBTQU5EWUJST1dOOiAweGY0YTQ2MGZmLFxuICAgICAgICBTRUFHUkVFTjogMHgyZThiNTdmZixcbiAgICAgICAgU0VBU0hFTEw6IDB4ZmZmNWVlZmYsXG4gICAgICAgIFNJRU5OQTogMHhhMDUyMmRmZixcbiAgICAgICAgU0lMVkVSOiAweGMwYzBjMGZmLFxuICAgICAgICBTS1lCTFVFOiAweDg3Y2VlYmZmLFxuICAgICAgICBTTEFURUJMVUU6IDB4NmE1YWNkZmYsXG4gICAgICAgIFNMQVRFR1JBWTogMHg3MDgwOTBmZixcbiAgICAgICAgU0xBVEVHUkVZOiAweDcwODA5MGZmLFxuICAgICAgICBTTk9XOiAweGZmZmFmYWZmLFxuICAgICAgICBTUFJJTkdHUkVFTjogMHgwMGZmN2ZmZixcbiAgICAgICAgU1RFRUxCTFVFOiAweDQ2ODJiNGZmLFxuICAgICAgICBUQU46IDB4ZDJiNDhjZmYsXG4gICAgICAgIFRFQUw6IDB4MDA4MDgwZmYsXG4gICAgICAgIFRISVNUTEU6IDB4ZDhiZmQ4ZmYsXG4gICAgICAgIFRPTUFUTzogMHhmZjYzNDdmZixcbiAgICAgICAgVFJBTlNQQVJFTlQ6IDB4MDAwMDAwMDAsXG4gICAgICAgIFRVUlFVT0lTRTogMHg0MGUwZDBmZixcbiAgICAgICAgVklPTEVUOiAweGVlODJlZWZmLFxuICAgICAgICBXSEVBVDogMHhmNWRlYjNmZixcbiAgICAgICAgV0hJVEU6IDB4ZmZmZmZmZmYsXG4gICAgICAgIFdISVRFU01PS0U6IDB4ZjVmNWY1ZmYsXG4gICAgICAgIFlFTExPVzogMHhmZmZmMDBmZixcbiAgICAgICAgWUVMTE9XR1JFRU46IDB4OWFjZDMyZmZcbiAgICB9O1xuXG4gICAgdmFyIGJhY2tncm91bmRDbGlwID0ge1xuICAgICAgICBuYW1lOiAnYmFja2dyb3VuZC1jbGlwJyxcbiAgICAgICAgaW5pdGlhbFZhbHVlOiAnYm9yZGVyLWJveCcsXG4gICAgICAgIHByZWZpeDogZmFsc2UsXG4gICAgICAgIHR5cGU6IDEgLyogTElTVCAqLyxcbiAgICAgICAgcGFyc2U6IGZ1bmN0aW9uIChfY29udGV4dCwgdG9rZW5zKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW5zLm1hcChmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNJZGVudFRva2VuKHRva2VuKSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHRva2VuLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdwYWRkaW5nLWJveCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDEgLyogUEFERElOR19CT1ggKi87XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdjb250ZW50LWJveCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDIgLyogQ09OVEVOVF9CT1ggKi87XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIDAgLyogQk9SREVSX0JPWCAqLztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBiYWNrZ3JvdW5kQ29sb3IgPSB7XG4gICAgICAgIG5hbWU6IFwiYmFja2dyb3VuZC1jb2xvclwiLFxuICAgICAgICBpbml0aWFsVmFsdWU6ICd0cmFuc3BhcmVudCcsXG4gICAgICAgIHByZWZpeDogZmFsc2UsXG4gICAgICAgIHR5cGU6IDMgLyogVFlQRV9WQUxVRSAqLyxcbiAgICAgICAgZm9ybWF0OiAnY29sb3InXG4gICAgfTtcblxuICAgIHZhciBwYXJzZUNvbG9yU3RvcCA9IGZ1bmN0aW9uIChjb250ZXh0LCBhcmdzKSB7XG4gICAgICAgIHZhciBjb2xvciA9IGNvbG9yJDEucGFyc2UoY29udGV4dCwgYXJnc1swXSk7XG4gICAgICAgIHZhciBzdG9wID0gYXJnc1sxXTtcbiAgICAgICAgcmV0dXJuIHN0b3AgJiYgaXNMZW5ndGhQZXJjZW50YWdlKHN0b3ApID8geyBjb2xvcjogY29sb3IsIHN0b3A6IHN0b3AgfSA6IHsgY29sb3I6IGNvbG9yLCBzdG9wOiBudWxsIH07XG4gICAgfTtcbiAgICB2YXIgcHJvY2Vzc0NvbG9yU3RvcHMgPSBmdW5jdGlvbiAoc3RvcHMsIGxpbmVMZW5ndGgpIHtcbiAgICAgICAgdmFyIGZpcnN0ID0gc3RvcHNbMF07XG4gICAgICAgIHZhciBsYXN0ID0gc3RvcHNbc3RvcHMubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChmaXJzdC5zdG9wID09PSBudWxsKSB7XG4gICAgICAgICAgICBmaXJzdC5zdG9wID0gWkVST19MRU5HVEg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3Quc3RvcCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgbGFzdC5zdG9wID0gSFVORFJFRF9QRVJDRU5UO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcm9jZXNzU3RvcHMgPSBbXTtcbiAgICAgICAgdmFyIHByZXZpb3VzID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdG9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHN0b3BfMSA9IHN0b3BzW2ldLnN0b3A7XG4gICAgICAgICAgICBpZiAoc3RvcF8xICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFic29sdXRlVmFsdWUgPSBnZXRBYnNvbHV0ZVZhbHVlKHN0b3BfMSwgbGluZUxlbmd0aCk7XG4gICAgICAgICAgICAgICAgaWYgKGFic29sdXRlVmFsdWUgPiBwcmV2aW91cykge1xuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzU3RvcHMucHVzaChhYnNvbHV0ZVZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3NTdG9wcy5wdXNoKHByZXZpb3VzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJldmlvdXMgPSBhYnNvbHV0ZVZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJvY2Vzc1N0b3BzLnB1c2gobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGdhcEJlZ2luID0gbnVsbDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9jZXNzU3RvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzdG9wXzIgPSBwcm9jZXNzU3RvcHNbaV07XG4gICAgICAgICAgICBpZiAoc3RvcF8yID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGdhcEJlZ2luID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGdhcEJlZ2luID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChnYXBCZWdpbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciBnYXBMZW5ndGggPSBpIC0gZ2FwQmVnaW47XG4gICAgICAgICAgICAgICAgdmFyIGJlZm9yZUdhcCA9IHByb2Nlc3NTdG9wc1tnYXBCZWdpbiAtIDFdO1xuICAgICAgICAgICAgICAgIHZhciBnYXBWYWx1ZSA9IChzdG9wXzIgLSBiZWZvcmVHYXApIC8gKGdhcExlbmd0aCArIDEpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGcgPSAxOyBnIDw9IGdhcExlbmd0aDsgZysrKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3NTdG9wc1tnYXBCZWdpbiArIGcgLSAxXSA9IGdhcFZhbHVlICogZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZ2FwQmVnaW4gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdG9wcy5tYXAoZnVuY3Rpb24gKF9hLCBpKSB7XG4gICAgICAgICAgICB2YXIgY29sb3IgPSBfYS5jb2xvcjtcbiAgICAgICAgICAgIHJldHVybiB7IGNvbG9yOiBjb2xvciwgc3RvcDogTWF0aC5tYXgoTWF0aC5taW4oMSwgcHJvY2Vzc1N0b3BzW2ldIC8gbGluZUxlbmd0aCksIDApIH07XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgdmFyIGdldEFuZ2xlRnJvbUNvcm5lciA9IGZ1bmN0aW9uIChjb3JuZXIsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgdmFyIGNlbnRlclggPSB3aWR0aCAvIDI7XG4gICAgICAgIHZhciBjZW50ZXJZID0gaGVpZ2h0IC8gMjtcbiAgICAgICAgdmFyIHggPSBnZXRBYnNvbHV0ZVZhbHVlKGNvcm5lclswXSwgd2lkdGgpIC0gY2VudGVyWDtcbiAgICAgICAgdmFyIHkgPSBjZW50ZXJZIC0gZ2V0QWJzb2x1dGVWYWx1ZShjb3JuZXJbMV0sIGhlaWdodCk7XG4gICAgICAgIHJldHVybiAoTWF0aC5hdGFuMih5LCB4KSArIE1hdGguUEkgKiAyKSAlIChNYXRoLlBJICogMik7XG4gICAgfTtcbiAgICB2YXIgY2FsY3VsYXRlR3JhZGllbnREaXJlY3Rpb24gPSBmdW5jdGlvbiAoYW5nbGUsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgdmFyIHJhZGlhbiA9IHR5cGVvZiBhbmdsZSA9PT0gJ251bWJlcicgPyBhbmdsZSA6IGdldEFuZ2xlRnJvbUNvcm5lcihhbmdsZSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHZhciBsaW5lTGVuZ3RoID0gTWF0aC5hYnMod2lkdGggKiBNYXRoLnNpbihyYWRpYW4pKSArIE1hdGguYWJzKGhlaWdodCAqIE1hdGguY29zKHJhZGlhbikpO1xuICAgICAgICB2YXIgaGFsZldpZHRoID0gd2lkdGggLyAyO1xuICAgICAgICB2YXIgaGFsZkhlaWdodCA9IGhlaWdodCAvIDI7XG4gICAgICAgIHZhciBoYWxmTGluZUxlbmd0aCA9IGxpbmVMZW5ndGggLyAyO1xuICAgICAgICB2YXIgeURpZmYgPSBNYXRoLnNpbihyYWRpYW4gLSBNYXRoLlBJIC8gMikgKiBoYWxmTGluZUxlbmd0aDtcbiAgICAgICAgdmFyIHhEaWZmID0gTWF0aC5jb3MocmFkaWFuIC0gTWF0aC5QSSAvIDIpICogaGFsZkxpbmVMZW5ndGg7XG4gICAgICAgIHJldHVybiBbbGluZUxlbmd0aCwgaGFsZldpZHRoIC0geERpZmYsIGhhbGZXaWR0aCArIHhEaWZmLCBoYWxmSGVpZ2h0IC0geURpZmYsIGhhbGZIZWlnaHQgKyB5RGlmZl07XG4gICAgfTtcbiAgICB2YXIgZGlzdGFuY2UgPSBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gTWF0aC5zcXJ0KGEgKiBhICsgYiAqIGIpOyB9O1xuICAgIHZhciBmaW5kQ29ybmVyID0gZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQsIHgsIHksIGNsb3Nlc3QpIHtcbiAgICAgICAgdmFyIGNvcm5lcnMgPSBbXG4gICAgICAgICAgICBbMCwgMF0sXG4gICAgICAgICAgICBbMCwgaGVpZ2h0XSxcbiAgICAgICAgICAgIFt3aWR0aCwgMF0sXG4gICAgICAgICAgICBbd2lkdGgsIGhlaWdodF1cbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIGNvcm5lcnMucmVkdWNlKGZ1bmN0aW9uIChzdGF0LCBjb3JuZXIpIHtcbiAgICAgICAgICAgIHZhciBjeCA9IGNvcm5lclswXSwgY3kgPSBjb3JuZXJbMV07XG4gICAgICAgICAgICB2YXIgZCA9IGRpc3RhbmNlKHggLSBjeCwgeSAtIGN5KTtcbiAgICAgICAgICAgIGlmIChjbG9zZXN0ID8gZCA8IHN0YXQub3B0aW11bURpc3RhbmNlIDogZCA+IHN0YXQub3B0aW11bURpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW11bUNvcm5lcjogY29ybmVyLFxuICAgICAgICAgICAgICAgICAgICBvcHRpbXVtRGlzdGFuY2U6IGRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0YXQ7XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG9wdGltdW1EaXN0YW5jZTogY2xvc2VzdCA/IEluZmluaXR5IDogLUluZmluaXR5LFxuICAgICAgICAgICAgb3B0aW11bUNvcm5lcjogbnVsbFxuICAgICAgICB9KS5vcHRpbXVtQ29ybmVyO1xuICAgIH07XG4gICAgdmFyIGNhbGN1bGF0ZVJhZGl1cyA9IGZ1bmN0aW9uIChncmFkaWVudCwgeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICB2YXIgcnggPSAwO1xuICAgICAgICB2YXIgcnkgPSAwO1xuICAgICAgICBzd2l0Y2ggKGdyYWRpZW50LnNpemUpIHtcbiAgICAgICAgICAgIGNhc2UgMCAvKiBDTE9TRVNUX1NJREUgKi86XG4gICAgICAgICAgICAgICAgLy8gVGhlIGVuZGluZyBzaGFwZSBpcyBzaXplZCBzbyB0aGF0IHRoYXQgaXQgZXhhY3RseSBtZWV0cyB0aGUgc2lkZSBvZiB0aGUgZ3JhZGllbnQgYm94IGNsb3Nlc3QgdG8gdGhlIGdyYWRpZW504oCZcyBjZW50ZXIuXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHNoYXBlIGlzIGFuIGVsbGlwc2UsIGl0IGV4YWN0bHkgbWVldHMgdGhlIGNsb3Nlc3Qgc2lkZSBpbiBlYWNoIGRpbWVuc2lvbi5cbiAgICAgICAgICAgICAgICBpZiAoZ3JhZGllbnQuc2hhcGUgPT09IDAgLyogQ0lSQ0xFICovKSB7XG4gICAgICAgICAgICAgICAgICAgIHJ4ID0gcnkgPSBNYXRoLm1pbihNYXRoLmFicyh4KSwgTWF0aC5hYnMoeCAtIHdpZHRoKSwgTWF0aC5hYnMoeSksIE1hdGguYWJzKHkgLSBoZWlnaHQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZ3JhZGllbnQuc2hhcGUgPT09IDEgLyogRUxMSVBTRSAqLykge1xuICAgICAgICAgICAgICAgICAgICByeCA9IE1hdGgubWluKE1hdGguYWJzKHgpLCBNYXRoLmFicyh4IC0gd2lkdGgpKTtcbiAgICAgICAgICAgICAgICAgICAgcnkgPSBNYXRoLm1pbihNYXRoLmFicyh5KSwgTWF0aC5hYnMoeSAtIGhlaWdodCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMiAvKiBDTE9TRVNUX0NPUk5FUiAqLzpcbiAgICAgICAgICAgICAgICAvLyBUaGUgZW5kaW5nIHNoYXBlIGlzIHNpemVkIHNvIHRoYXQgdGhhdCBpdCBwYXNzZXMgdGhyb3VnaCB0aGUgY29ybmVyIG9mIHRoZSBncmFkaWVudCBib3ggY2xvc2VzdCB0byB0aGUgZ3JhZGllbnTigJlzIGNlbnRlci5cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgc2hhcGUgaXMgYW4gZWxsaXBzZSwgdGhlIGVuZGluZyBzaGFwZSBpcyBnaXZlbiB0aGUgc2FtZSBhc3BlY3QtcmF0aW8gaXQgd291bGQgaGF2ZSBpZiBjbG9zZXN0LXNpZGUgd2VyZSBzcGVjaWZpZWQuXG4gICAgICAgICAgICAgICAgaWYgKGdyYWRpZW50LnNoYXBlID09PSAwIC8qIENJUkNMRSAqLykge1xuICAgICAgICAgICAgICAgICAgICByeCA9IHJ5ID0gTWF0aC5taW4oZGlzdGFuY2UoeCwgeSksIGRpc3RhbmNlKHgsIHkgLSBoZWlnaHQpLCBkaXN0YW5jZSh4IC0gd2lkdGgsIHkpLCBkaXN0YW5jZSh4IC0gd2lkdGgsIHkgLSBoZWlnaHQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZ3JhZGllbnQuc2hhcGUgPT09IDEgLyogRUxMSVBTRSAqLykge1xuICAgICAgICAgICAgICAgICAgICAvLyBDb21wdXRlIHRoZSByYXRpbyByeS9yeCAod2hpY2ggaXMgdG8gYmUgdGhlIHNhbWUgYXMgZm9yIFwiY2xvc2VzdC1zaWRlXCIpXG4gICAgICAgICAgICAgICAgICAgIHZhciBjID0gTWF0aC5taW4oTWF0aC5hYnMoeSksIE1hdGguYWJzKHkgLSBoZWlnaHQpKSAvIE1hdGgubWluKE1hdGguYWJzKHgpLCBNYXRoLmFicyh4IC0gd2lkdGgpKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hID0gZmluZENvcm5lcih3aWR0aCwgaGVpZ2h0LCB4LCB5LCB0cnVlKSwgY3ggPSBfYVswXSwgY3kgPSBfYVsxXTtcbiAgICAgICAgICAgICAgICAgICAgcnggPSBkaXN0YW5jZShjeCAtIHgsIChjeSAtIHkpIC8gYyk7XG4gICAgICAgICAgICAgICAgICAgIHJ5ID0gYyAqIHJ4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMSAvKiBGQVJUSEVTVF9TSURFICovOlxuICAgICAgICAgICAgICAgIC8vIFNhbWUgYXMgY2xvc2VzdC1zaWRlLCBleGNlcHQgdGhlIGVuZGluZyBzaGFwZSBpcyBzaXplZCBiYXNlZCBvbiB0aGUgZmFydGhlc3Qgc2lkZShzKVxuICAgICAgICAgICAgICAgIGlmIChncmFkaWVudC5zaGFwZSA9PT0gMCAvKiBDSVJDTEUgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgcnggPSByeSA9IE1hdGgubWF4KE1hdGguYWJzKHgpLCBNYXRoLmFicyh4IC0gd2lkdGgpLCBNYXRoLmFicyh5KSwgTWF0aC5hYnMoeSAtIGhlaWdodCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChncmFkaWVudC5zaGFwZSA9PT0gMSAvKiBFTExJUFNFICovKSB7XG4gICAgICAgICAgICAgICAgICAgIHJ4ID0gTWF0aC5tYXgoTWF0aC5hYnMoeCksIE1hdGguYWJzKHggLSB3aWR0aCkpO1xuICAgICAgICAgICAgICAgICAgICByeSA9IE1hdGgubWF4KE1hdGguYWJzKHkpLCBNYXRoLmFicyh5IC0gaGVpZ2h0KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzIC8qIEZBUlRIRVNUX0NPUk5FUiAqLzpcbiAgICAgICAgICAgICAgICAvLyBTYW1lIGFzIGNsb3Nlc3QtY29ybmVyLCBleGNlcHQgdGhlIGVuZGluZyBzaGFwZSBpcyBzaXplZCBiYXNlZCBvbiB0aGUgZmFydGhlc3QgY29ybmVyLlxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBzaGFwZSBpcyBhbiBlbGxpcHNlLCB0aGUgZW5kaW5nIHNoYXBlIGlzIGdpdmVuIHRoZSBzYW1lIGFzcGVjdCByYXRpbyBpdCB3b3VsZCBoYXZlIGlmIGZhcnRoZXN0LXNpZGUgd2VyZSBzcGVjaWZpZWQuXG4gICAgICAgICAgICAgICAgaWYgKGdyYWRpZW50LnNoYXBlID09PSAwIC8qIENJUkNMRSAqLykge1xuICAgICAgICAgICAgICAgICAgICByeCA9IHJ5ID0gTWF0aC5tYXgoZGlzdGFuY2UoeCwgeSksIGRpc3RhbmNlKHgsIHkgLSBoZWlnaHQpLCBkaXN0YW5jZSh4IC0gd2lkdGgsIHkpLCBkaXN0YW5jZSh4IC0gd2lkdGgsIHkgLSBoZWlnaHQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZ3JhZGllbnQuc2hhcGUgPT09IDEgLyogRUxMSVBTRSAqLykge1xuICAgICAgICAgICAgICAgICAgICAvLyBDb21wdXRlIHRoZSByYXRpbyByeS9yeCAod2hpY2ggaXMgdG8gYmUgdGhlIHNhbWUgYXMgZm9yIFwiZmFydGhlc3Qtc2lkZVwiKVxuICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IE1hdGgubWF4KE1hdGguYWJzKHkpLCBNYXRoLmFicyh5IC0gaGVpZ2h0KSkgLyBNYXRoLm1heChNYXRoLmFicyh4KSwgTWF0aC5hYnMoeCAtIHdpZHRoKSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYiA9IGZpbmRDb3JuZXIod2lkdGgsIGhlaWdodCwgeCwgeSwgZmFsc2UpLCBjeCA9IF9iWzBdLCBjeSA9IF9iWzFdO1xuICAgICAgICAgICAgICAgICAgICByeCA9IGRpc3RhbmNlKGN4IC0geCwgKGN5IC0geSkgLyBjKTtcbiAgICAgICAgICAgICAgICAgICAgcnkgPSBjICogcng7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGdyYWRpZW50LnNpemUpKSB7XG4gICAgICAgICAgICByeCA9IGdldEFic29sdXRlVmFsdWUoZ3JhZGllbnQuc2l6ZVswXSwgd2lkdGgpO1xuICAgICAgICAgICAgcnkgPSBncmFkaWVudC5zaXplLmxlbmd0aCA9PT0gMiA/IGdldEFic29sdXRlVmFsdWUoZ3JhZGllbnQuc2l6ZVsxXSwgaGVpZ2h0KSA6IHJ4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbcngsIHJ5XTtcbiAgICB9O1xuXG4gICAgdmFyIGxpbmVhckdyYWRpZW50ID0gZnVuY3Rpb24gKGNvbnRleHQsIHRva2Vucykge1xuICAgICAgICB2YXIgYW5nbGUkMSA9IGRlZygxODApO1xuICAgICAgICB2YXIgc3RvcHMgPSBbXTtcbiAgICAgICAgcGFyc2VGdW5jdGlvbkFyZ3ModG9rZW5zKS5mb3JFYWNoKGZ1bmN0aW9uIChhcmcsIGkpIHtcbiAgICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpcnN0VG9rZW4gPSBhcmdbMF07XG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0VG9rZW4udHlwZSA9PT0gMjAgLyogSURFTlRfVE9LRU4gKi8gJiYgZmlyc3RUb2tlbi52YWx1ZSA9PT0gJ3RvJykge1xuICAgICAgICAgICAgICAgICAgICBhbmdsZSQxID0gcGFyc2VOYW1lZFNpZGUoYXJnKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0FuZ2xlKGZpcnN0VG9rZW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIGFuZ2xlJDEgPSBhbmdsZS5wYXJzZShjb250ZXh0LCBmaXJzdFRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjb2xvclN0b3AgPSBwYXJzZUNvbG9yU3RvcChjb250ZXh0LCBhcmcpO1xuICAgICAgICAgICAgc3RvcHMucHVzaChjb2xvclN0b3ApO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHsgYW5nbGU6IGFuZ2xlJDEsIHN0b3BzOiBzdG9wcywgdHlwZTogMSAvKiBMSU5FQVJfR1JBRElFTlQgKi8gfTtcbiAgICB9O1xuXG4gICAgdmFyIHByZWZpeExpbmVhckdyYWRpZW50ID0gZnVuY3Rpb24gKGNvbnRleHQsIHRva2Vucykge1xuICAgICAgICB2YXIgYW5nbGUkMSA9IGRlZygxODApO1xuICAgICAgICB2YXIgc3RvcHMgPSBbXTtcbiAgICAgICAgcGFyc2VGdW5jdGlvbkFyZ3ModG9rZW5zKS5mb3JFYWNoKGZ1bmN0aW9uIChhcmcsIGkpIHtcbiAgICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpcnN0VG9rZW4gPSBhcmdbMF07XG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0VG9rZW4udHlwZSA9PT0gMjAgLyogSURFTlRfVE9LRU4gKi8gJiZcbiAgICAgICAgICAgICAgICAgICAgWyd0b3AnLCAnbGVmdCcsICdyaWdodCcsICdib3R0b20nXS5pbmRleE9mKGZpcnN0VG9rZW4udmFsdWUpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBhbmdsZSQxID0gcGFyc2VOYW1lZFNpZGUoYXJnKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0FuZ2xlKGZpcnN0VG9rZW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIGFuZ2xlJDEgPSAoYW5nbGUucGFyc2UoY29udGV4dCwgZmlyc3RUb2tlbikgKyBkZWcoMjcwKSkgJSBkZWcoMzYwKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjb2xvclN0b3AgPSBwYXJzZUNvbG9yU3RvcChjb250ZXh0LCBhcmcpO1xuICAgICAgICAgICAgc3RvcHMucHVzaChjb2xvclN0b3ApO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFuZ2xlOiBhbmdsZSQxLFxuICAgICAgICAgICAgc3RvcHM6IHN0b3BzLFxuICAgICAgICAgICAgdHlwZTogMSAvKiBMSU5FQVJfR1JBRElFTlQgKi9cbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIHdlYmtpdEdyYWRpZW50ID0gZnVuY3Rpb24gKGNvbnRleHQsIHRva2Vucykge1xuICAgICAgICB2YXIgYW5nbGUgPSBkZWcoMTgwKTtcbiAgICAgICAgdmFyIHN0b3BzID0gW107XG4gICAgICAgIHZhciB0eXBlID0gMSAvKiBMSU5FQVJfR1JBRElFTlQgKi87XG4gICAgICAgIHZhciBzaGFwZSA9IDAgLyogQ0lSQ0xFICovO1xuICAgICAgICB2YXIgc2l6ZSA9IDMgLyogRkFSVEhFU1RfQ09STkVSICovO1xuICAgICAgICB2YXIgcG9zaXRpb24gPSBbXTtcbiAgICAgICAgcGFyc2VGdW5jdGlvbkFyZ3ModG9rZW5zKS5mb3JFYWNoKGZ1bmN0aW9uIChhcmcsIGkpIHtcbiAgICAgICAgICAgIHZhciBmaXJzdFRva2VuID0gYXJnWzBdO1xuICAgICAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNJZGVudFRva2VuKGZpcnN0VG9rZW4pICYmIGZpcnN0VG9rZW4udmFsdWUgPT09ICdsaW5lYXInKSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPSAxIC8qIExJTkVBUl9HUkFESUVOVCAqLztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0lkZW50VG9rZW4oZmlyc3RUb2tlbikgJiYgZmlyc3RUb2tlbi52YWx1ZSA9PT0gJ3JhZGlhbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9IDIgLyogUkFESUFMX0dSQURJRU5UICovO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpcnN0VG9rZW4udHlwZSA9PT0gMTggLyogRlVOQ1RJT04gKi8pIHtcbiAgICAgICAgICAgICAgICBpZiAoZmlyc3RUb2tlbi5uYW1lID09PSAnZnJvbScpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbG9yID0gY29sb3IkMS5wYXJzZShjb250ZXh0LCBmaXJzdFRva2VuLnZhbHVlc1swXSk7XG4gICAgICAgICAgICAgICAgICAgIHN0b3BzLnB1c2goeyBzdG9wOiBaRVJPX0xFTkdUSCwgY29sb3I6IGNvbG9yIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmaXJzdFRva2VuLm5hbWUgPT09ICd0bycpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbG9yID0gY29sb3IkMS5wYXJzZShjb250ZXh0LCBmaXJzdFRva2VuLnZhbHVlc1swXSk7XG4gICAgICAgICAgICAgICAgICAgIHN0b3BzLnB1c2goeyBzdG9wOiBIVU5EUkVEX1BFUkNFTlQsIGNvbG9yOiBjb2xvciB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZmlyc3RUb2tlbi5uYW1lID09PSAnY29sb3Itc3RvcCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlcyA9IGZpcnN0VG9rZW4udmFsdWVzLmZpbHRlcihub25GdW5jdGlvbkFyZ1NlcGFyYXRvcik7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZXMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29sb3IgPSBjb2xvciQxLnBhcnNlKGNvbnRleHQsIHZhbHVlc1sxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RvcF8xID0gdmFsdWVzWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzTnVtYmVyVG9rZW4oc3RvcF8xKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3BzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9wOiB7IHR5cGU6IDE2IC8qIFBFUkNFTlRBR0VfVE9LRU4gKi8sIG51bWJlcjogc3RvcF8xLm51bWJlciAqIDEwMCwgZmxhZ3M6IHN0b3BfMS5mbGFncyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogY29sb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0eXBlID09PSAxIC8qIExJTkVBUl9HUkFESUVOVCAqL1xuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgYW5nbGU6IChhbmdsZSArIGRlZygxODApKSAlIGRlZygzNjApLFxuICAgICAgICAgICAgICAgIHN0b3BzOiBzdG9wcyxcbiAgICAgICAgICAgICAgICB0eXBlOiB0eXBlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA6IHsgc2l6ZTogc2l6ZSwgc2hhcGU6IHNoYXBlLCBzdG9wczogc3RvcHMsIHBvc2l0aW9uOiBwb3NpdGlvbiwgdHlwZTogdHlwZSB9O1xuICAgIH07XG5cbiAgICB2YXIgQ0xPU0VTVF9TSURFID0gJ2Nsb3Nlc3Qtc2lkZSc7XG4gICAgdmFyIEZBUlRIRVNUX1NJREUgPSAnZmFydGhlc3Qtc2lkZSc7XG4gICAgdmFyIENMT1NFU1RfQ09STkVSID0gJ2Nsb3Nlc3QtY29ybmVyJztcbiAgICB2YXIgRkFSVEhFU1RfQ09STkVSID0gJ2ZhcnRoZXN0LWNvcm5lcic7XG4gICAgdmFyIENJUkNMRSA9ICdjaXJjbGUnO1xuICAgIHZhciBFTExJUFNFID0gJ2VsbGlwc2UnO1xuICAgIHZhciBDT1ZFUiA9ICdjb3Zlcic7XG4gICAgdmFyIENPTlRBSU4gPSAnY29udGFpbic7XG4gICAgdmFyIHJhZGlhbEdyYWRpZW50ID0gZnVuY3Rpb24gKGNvbnRleHQsIHRva2Vucykge1xuICAgICAgICB2YXIgc2hhcGUgPSAwIC8qIENJUkNMRSAqLztcbiAgICAgICAgdmFyIHNpemUgPSAzIC8qIEZBUlRIRVNUX0NPUk5FUiAqLztcbiAgICAgICAgdmFyIHN0b3BzID0gW107XG4gICAgICAgIHZhciBwb3NpdGlvbiA9IFtdO1xuICAgICAgICBwYXJzZUZ1bmN0aW9uQXJncyh0b2tlbnMpLmZvckVhY2goZnVuY3Rpb24gKGFyZywgaSkge1xuICAgICAgICAgICAgdmFyIGlzQ29sb3JTdG9wID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlzQXRQb3NpdGlvbl8xID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaXNDb2xvclN0b3AgPSBhcmcucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHRva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0F0UG9zaXRpb25fMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzSWRlbnRUb2tlbih0b2tlbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHRva2VuLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbi5wdXNoKEZJRlRZX1BFUkNFTlQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbi5wdXNoKFpFUk9fTEVOR1RIKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uLnB1c2goSFVORFJFRF9QRVJDRU5UKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNMZW5ndGhQZXJjZW50YWdlKHRva2VuKSB8fCBpc0xlbmd0aCh0b2tlbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbi5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0lkZW50VG9rZW4odG9rZW4pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHRva2VuLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBDSVJDTEU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYXBlID0gMCAvKiBDSVJDTEUgKi87XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEVMTElQU0U6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYXBlID0gMSAvKiBFTExJUFNFICovO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnYXQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0F0UG9zaXRpb25fMSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIENMT1NFU1RfU0lERTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZSA9IDAgLyogQ0xPU0VTVF9TSURFICovO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBDT1ZFUjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEZBUlRIRVNUX1NJREU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpemUgPSAxIC8qIEZBUlRIRVNUX1NJREUgKi87XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIENPTlRBSU46XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBDTE9TRVNUX0NPUk5FUjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZSA9IDIgLyogQ0xPU0VTVF9DT1JORVIgKi87XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEZBUlRIRVNUX0NPUk5FUjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZSA9IDMgLyogRkFSVEhFU1RfQ09STkVSICovO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNMZW5ndGgodG9rZW4pIHx8IGlzTGVuZ3RoUGVyY2VudGFnZSh0b2tlbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShzaXplKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpemUgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHNpemUucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICAgICAgICB9LCBpc0NvbG9yU3RvcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNDb2xvclN0b3ApIHtcbiAgICAgICAgICAgICAgICB2YXIgY29sb3JTdG9wID0gcGFyc2VDb2xvclN0b3AoY29udGV4dCwgYXJnKTtcbiAgICAgICAgICAgICAgICBzdG9wcy5wdXNoKGNvbG9yU3RvcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4geyBzaXplOiBzaXplLCBzaGFwZTogc2hhcGUsIHN0b3BzOiBzdG9wcywgcG9zaXRpb246IHBvc2l0aW9uLCB0eXBlOiAyIC8qIFJBRElBTF9HUkFESUVOVCAqLyB9O1xuICAgIH07XG5cbiAgICB2YXIgcHJlZml4UmFkaWFsR3JhZGllbnQgPSBmdW5jdGlvbiAoY29udGV4dCwgdG9rZW5zKSB7XG4gICAgICAgIHZhciBzaGFwZSA9IDAgLyogQ0lSQ0xFICovO1xuICAgICAgICB2YXIgc2l6ZSA9IDMgLyogRkFSVEhFU1RfQ09STkVSICovO1xuICAgICAgICB2YXIgc3RvcHMgPSBbXTtcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gW107XG4gICAgICAgIHBhcnNlRnVuY3Rpb25BcmdzKHRva2VucykuZm9yRWFjaChmdW5jdGlvbiAoYXJnLCBpKSB7XG4gICAgICAgICAgICB2YXIgaXNDb2xvclN0b3AgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBpc0NvbG9yU3RvcCA9IGFyZy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgdG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzSWRlbnRUb2tlbih0b2tlbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodG9rZW4udmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbi5wdXNoKEZJRlRZX1BFUkNFTlQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24ucHVzaChaRVJPX0xFTkdUSCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24ucHVzaChIVU5EUkVEX1BFUkNFTlQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNMZW5ndGhQZXJjZW50YWdlKHRva2VuKSB8fCBpc0xlbmd0aCh0b2tlbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICAgICAgfSwgaXNDb2xvclN0b3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGlzQ29sb3JTdG9wID0gYXJnLnJlZHVjZShmdW5jdGlvbiAoYWNjLCB0b2tlbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNJZGVudFRva2VuKHRva2VuKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0b2tlbi52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQ0lSQ0xFOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFwZSA9IDAgLyogQ0lSQ0xFICovO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBFTExJUFNFOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFwZSA9IDEgLyogRUxMSVBTRSAqLztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQ09OVEFJTjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIENMT1NFU1RfU0lERTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZSA9IDAgLyogQ0xPU0VTVF9TSURFICovO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBGQVJUSEVTVF9TSURFOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaXplID0gMSAvKiBGQVJUSEVTVF9TSURFICovO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBDTE9TRVNUX0NPUk5FUjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZSA9IDIgLyogQ0xPU0VTVF9DT1JORVIgKi87XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIENPVkVSOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRkFSVEhFU1RfQ09STkVSOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaXplID0gMyAvKiBGQVJUSEVTVF9DT1JORVIgKi87XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0xlbmd0aCh0b2tlbikgfHwgaXNMZW5ndGhQZXJjZW50YWdlKHRva2VuKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHNpemUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZS5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgICAgIH0sIGlzQ29sb3JTdG9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0NvbG9yU3RvcCkge1xuICAgICAgICAgICAgICAgIHZhciBjb2xvclN0b3AgPSBwYXJzZUNvbG9yU3RvcChjb250ZXh0LCBhcmcpO1xuICAgICAgICAgICAgICAgIHN0b3BzLnB1c2goY29sb3JTdG9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7IHNpemU6IHNpemUsIHNoYXBlOiBzaGFwZSwgc3RvcHM6IHN0b3BzLCBwb3NpdGlvbjogcG9zaXRpb24sIHR5cGU6IDIgLyogUkFESUFMX0dSQURJRU5UICovIH07XG4gICAgfTtcblxuICAgIHZhciBpc0xpbmVhckdyYWRpZW50ID0gZnVuY3Rpb24gKGJhY2tncm91bmQpIHtcbiAgICAgICAgcmV0dXJuIGJhY2tncm91bmQudHlwZSA9PT0gMSAvKiBMSU5FQVJfR1JBRElFTlQgKi87XG4gICAgfTtcbiAgICB2YXIgaXNSYWRpYWxHcmFkaWVudCA9IGZ1bmN0aW9uIChiYWNrZ3JvdW5kKSB7XG4gICAgICAgIHJldHVybiBiYWNrZ3JvdW5kLnR5cGUgPT09IDIgLyogUkFESUFMX0dSQURJRU5UICovO1xuICAgIH07XG4gICAgdmFyIGltYWdlID0ge1xuICAgICAgICBuYW1lOiAnaW1hZ2UnLFxuICAgICAgICBwYXJzZTogZnVuY3Rpb24gKGNvbnRleHQsIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUudHlwZSA9PT0gMjIgLyogVVJMX1RPS0VOICovKSB7XG4gICAgICAgICAgICAgICAgdmFyIGltYWdlXzEgPSB7IHVybDogdmFsdWUudmFsdWUsIHR5cGU6IDAgLyogVVJMICovIH07XG4gICAgICAgICAgICAgICAgY29udGV4dC5jYWNoZS5hZGRJbWFnZSh2YWx1ZS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGltYWdlXzE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUudHlwZSA9PT0gMTggLyogRlVOQ1RJT04gKi8pIHtcbiAgICAgICAgICAgICAgICB2YXIgaW1hZ2VGdW5jdGlvbiA9IFNVUFBPUlRFRF9JTUFHRV9GVU5DVElPTlNbdmFsdWUubmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpbWFnZUZ1bmN0aW9uID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBdHRlbXB0aW5nIHRvIHBhcnNlIGFuIHVuc3VwcG9ydGVkIGltYWdlIGZ1bmN0aW9uIFxcXCJcIiArIHZhbHVlLm5hbWUgKyBcIlxcXCJcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBpbWFnZUZ1bmN0aW9uKGNvbnRleHQsIHZhbHVlLnZhbHVlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBpbWFnZSB0eXBlIFwiICsgdmFsdWUudHlwZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIGlzU3VwcG9ydGVkSW1hZ2UodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICghKHZhbHVlLnR5cGUgPT09IDIwIC8qIElERU5UX1RPS0VOICovICYmIHZhbHVlLnZhbHVlID09PSAnbm9uZScpICYmXG4gICAgICAgICAgICAodmFsdWUudHlwZSAhPT0gMTggLyogRlVOQ1RJT04gKi8gfHwgISFTVVBQT1JURURfSU1BR0VfRlVOQ1RJT05TW3ZhbHVlLm5hbWVdKSk7XG4gICAgfVxuICAgIHZhciBTVVBQT1JURURfSU1BR0VfRlVOQ1RJT05TID0ge1xuICAgICAgICAnbGluZWFyLWdyYWRpZW50JzogbGluZWFyR3JhZGllbnQsXG4gICAgICAgICctbW96LWxpbmVhci1ncmFkaWVudCc6IHByZWZpeExpbmVhckdyYWRpZW50LFxuICAgICAgICAnLW1zLWxpbmVhci1ncmFkaWVudCc6IHByZWZpeExpbmVhckdyYWRpZW50LFxuICAgICAgICAnLW8tbGluZWFyLWdyYWRpZW50JzogcHJlZml4TGluZWFyR3JhZGllbnQsXG4gICAgICAgICctd2Via2l0LWxpbmVhci1ncmFkaWVudCc6IHByZWZpeExpbmVhckdyYWRpZW50LFxuICAgICAgICAncmFkaWFsLWdyYWRpZW50JzogcmFkaWFsR3JhZGllbnQsXG4gICAgICAgICctbW96LXJhZGlhbC1ncmFkaWVudCc6IHByZWZpeFJhZGlhbEdyYWRpZW50LFxuICAgICAgICAnLW1zLXJhZGlhbC1ncmFkaWVudCc6IHByZWZpeFJhZGlhbEdyYWRpZW50LFxuICAgICAgICAnLW8tcmFkaWFsLWdyYWRpZW50JzogcHJlZml4UmFkaWFsR3JhZGllbnQsXG4gICAgICAgICctd2Via2l0LXJhZGlhbC1ncmFkaWVudCc6IHByZWZpeFJhZGlhbEdyYWRpZW50LFxuICAgICAgICAnLXdlYmtpdC1ncmFkaWVudCc6IHdlYmtpdEdyYWRpZW50XG4gICAgfTtcblxuICAgIHZhciBiYWNrZ3JvdW5kSW1hZ2UgPSB7XG4gICAgICAgIG5hbWU6ICdiYWNrZ3JvdW5kLWltYWdlJyxcbiAgICAgICAgaW5pdGlhbFZhbHVlOiAnbm9uZScsXG4gICAgICAgIHR5cGU6IDEgLyogTElTVCAqLyxcbiAgICAgICAgcHJlZml4OiBmYWxzZSxcbiAgICAgICAgcGFyc2U6IGZ1bmN0aW9uIChjb250ZXh0LCB0b2tlbnMpIHtcbiAgICAgICAgICAgIGlmICh0b2tlbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGZpcnN0ID0gdG9rZW5zWzBdO1xuICAgICAgICAgICAgaWYgKGZpcnN0LnR5cGUgPT09IDIwIC8qIElERU5UX1RPS0VOICovICYmIGZpcnN0LnZhbHVlID09PSAnbm9uZScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdG9rZW5zXG4gICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIG5vbkZ1bmN0aW9uQXJnU2VwYXJhdG9yKHZhbHVlKSAmJiBpc1N1cHBvcnRlZEltYWdlKHZhbHVlKTsgfSlcbiAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gaW1hZ2UucGFyc2UoY29udGV4dCwgdmFsdWUpOyB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgYmFja2dyb3VuZE9yaWdpbiA9IHtcbiAgICAgICAgbmFtZTogJ2JhY2tncm91bmQtb3JpZ2luJyxcbiAgICAgICAgaW5pdGlhbFZhbHVlOiAnYm9yZGVyLWJveCcsXG4gICAgICAgIHByZWZpeDogZmFsc2UsXG4gICAgICAgIHR5cGU6IDEgLyogTElTVCAqLyxcbiAgICAgICAgcGFyc2U6IGZ1bmN0aW9uIChfY29udGV4dCwgdG9rZW5zKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW5zLm1hcChmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNJZGVudFRva2VuKHRva2VuKSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHRva2VuLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdwYWRkaW5nLWJveCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDEgLyogUEFERElOR19CT1ggKi87XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdjb250ZW50LWJveCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDIgLyogQ09OVEVOVF9CT1ggKi87XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIDAgLyogQk9SREVSX0JPWCAqLztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBiYWNrZ3JvdW5kUG9zaXRpb24gPSB7XG4gICAgICAgIG5hbWU6ICdiYWNrZ3JvdW5kLXBvc2l0aW9uJyxcbiAgICAgICAgaW5pdGlhbFZhbHVlOiAnMCUgMCUnLFxuICAgICAgICB0eXBlOiAxIC8qIExJU1QgKi8sXG4gICAgICAgIHByZWZpeDogZmFsc2UsXG4gICAgICAgIHBhcnNlOiBmdW5jdGlvbiAoX2NvbnRleHQsIHRva2Vucykge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlRnVuY3Rpb25BcmdzKHRva2VucylcbiAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uICh2YWx1ZXMpIHsgcmV0dXJuIHZhbHVlcy5maWx0ZXIoaXNMZW5ndGhQZXJjZW50YWdlKTsgfSlcbiAgICAgICAgICAgICAgICAubWFwKHBhcnNlTGVuZ3RoUGVyY2VudGFnZVR1cGxlKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgYmFja2dyb3VuZFJlcGVhdCA9IHtcbiAgICAgICAgbmFtZTogJ2JhY2tncm91bmQtcmVwZWF0JyxcbiAgICAgICAgaW5pdGlhbFZhbHVlOiAncmVwZWF0JyxcbiAgICAgICAgcHJlZml4OiBmYWxzZSxcbiAgICAgICAgdHlwZTogMSAvKiBMSVNUICovLFxuICAgICAgICBwYXJzZTogZnVuY3Rpb24gKF9jb250ZXh0LCB0b2tlbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUZ1bmN0aW9uQXJncyh0b2tlbnMpXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAodmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGlzSWRlbnRUb2tlbilcbiAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAodG9rZW4pIHsgcmV0dXJuIHRva2VuLnZhbHVlOyB9KVxuICAgICAgICAgICAgICAgICAgICAuam9pbignICcpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAubWFwKHBhcnNlQmFja2dyb3VuZFJlcGVhdCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBwYXJzZUJhY2tncm91bmRSZXBlYXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgICAgICAgY2FzZSAnbm8tcmVwZWF0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gMSAvKiBOT19SRVBFQVQgKi87XG4gICAgICAgICAgICBjYXNlICdyZXBlYXQteCc6XG4gICAgICAgICAgICBjYXNlICdyZXBlYXQgbm8tcmVwZWF0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gMiAvKiBSRVBFQVRfWCAqLztcbiAgICAgICAgICAgIGNhc2UgJ3JlcGVhdC15JzpcbiAgICAgICAgICAgIGNhc2UgJ25vLXJlcGVhdCByZXBlYXQnOlxuICAgICAgICAgICAgICAgIHJldHVybiAzIC8qIFJFUEVBVF9ZICovO1xuICAgICAgICAgICAgY2FzZSAncmVwZWF0JzpcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDAgLyogUkVQRUFUICovO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBCQUNLR1JPVU5EX1NJWkU7XG4gICAgKGZ1bmN0aW9uIChCQUNLR1JPVU5EX1NJWkUpIHtcbiAgICAgICAgQkFDS0dST1VORF9TSVpFW1wiQVVUT1wiXSA9IFwiYXV0b1wiO1xuICAgICAgICBCQUNLR1JPVU5EX1NJWkVbXCJDT05UQUlOXCJdID0gXCJjb250YWluXCI7XG4gICAgICAgIEJBQ0tHUk9VTkRfU0laRVtcIkNPVkVSXCJdID0gXCJjb3ZlclwiO1xuICAgIH0pKEJBQ0tHUk9VTkRfU0laRSB8fCAoQkFDS0dST1VORF9TSVpFID0ge30pKTtcbiAgICB2YXIgYmFja2dyb3VuZFNpemUgPSB7XG4gICAgICAgIG5hbWU6ICdiYWNrZ3JvdW5kLXNpemUnLFxuICAgICAgICBpbml0aWFsVmFsdWU6ICcwJyxcbiAgICAgICAgcHJlZml4OiBmYWxzZSxcbiAgICAgICAgdHlwZTogMSAvKiBMSVNUICovLFxuICAgICAgICBwYXJzZTogZnVuY3Rpb24gKF9jb250ZXh0LCB0b2tlbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUZ1bmN0aW9uQXJncyh0b2tlbnMpLm1hcChmdW5jdGlvbiAodmFsdWVzKSB7IHJldHVybiB2YWx1ZXMuZmlsdGVyKGlzQmFja2dyb3VuZFNpemVJbmZvVG9rZW4pOyB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIGlzQmFja2dyb3VuZFNpemVJbmZvVG9rZW4gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGlzSWRlbnRUb2tlbih2YWx1ZSkgfHwgaXNMZW5ndGhQZXJjZW50YWdlKHZhbHVlKTtcbiAgICB9O1xuXG4gICAgdmFyIGJvcmRlckNvbG9yRm9yU2lkZSA9IGZ1bmN0aW9uIChzaWRlKSB7IHJldHVybiAoe1xuICAgICAgICBuYW1lOiBcImJvcmRlci1cIiArIHNpZGUgKyBcIi1jb2xvclwiLFxuICAgICAgICBpbml0aWFsVmFsdWU6ICd0cmFuc3BhcmVudCcsXG4gICAgICAgIHByZWZpeDogZmFsc2UsXG4gICAgICAgIHR5cGU6IDMgLyogVFlQRV9WQUxVRSAqLyxcbiAgICAgICAgZm9ybWF0OiAnY29sb3InXG4gICAgfSk7IH07XG4gICAgdmFyIGJvcmRlclRvcENvbG9yID0gYm9yZGVyQ29sb3JGb3JTaWRlKCd0b3AnKTtcbiAgICB2YXIgYm9yZGVyUmlnaHRDb2xvciA9IGJvcmRlckNvbG9yRm9yU2lkZSgncmlnaHQnKTtcbiAgICB2YXIgYm9yZGVyQm90dG9tQ29sb3IgPSBib3JkZXJDb2xvckZvclNpZGUoJ2JvdHRvbScpO1xuICAgIHZhciBib3JkZXJMZWZ0Q29sb3IgPSBib3JkZXJDb2xvckZvclNpZGUoJ2xlZnQnKTtcblxuICAgIHZhciBib3JkZXJSYWRpdXNGb3JTaWRlID0gZnVuY3Rpb24gKHNpZGUpIHsgcmV0dXJuICh7XG4gICAgICAgIG5hbWU6IFwiYm9yZGVyLXJhZGl1cy1cIiArIHNpZGUsXG4gICAgICAgIGluaXRpYWxWYWx1ZTogJzAgMCcsXG4gICAgICAgIHByZWZpeDogZmFsc2UsXG4gICAgICAgIHR5cGU6IDEgLyogTElTVCAqLyxcbiAgICAgICAgcGFyc2U6IGZ1bmN0aW9uIChfY29udGV4dCwgdG9rZW5zKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VMZW5ndGhQZXJjZW50YWdlVHVwbGUodG9rZW5zLmZpbHRlcihpc0xlbmd0aFBlcmNlbnRhZ2UpKTtcbiAgICAgICAgfVxuICAgIH0pOyB9O1xuICAgIHZhciBib3JkZXJUb3BMZWZ0UmFkaXVzID0gYm9yZGVyUmFkaXVzRm9yU2lkZSgndG9wLWxlZnQnKTtcbiAgICB2YXIgYm9yZGVyVG9wUmlnaHRSYWRpdXMgPSBib3JkZXJSYWRpdXNGb3JTaWRlKCd0b3AtcmlnaHQnKTtcbiAgICB2YXIgYm9yZGVyQm90dG9tUmlnaHRSYWRpdXMgPSBib3JkZXJSYWRpdXNGb3JTaWRlKCdib3R0b20tcmlnaHQnKTtcbiAgICB2YXIgYm9yZGVyQm90dG9tTGVmdFJhZGl1cyA9IGJvcmRlclJhZGl1c0ZvclNpZGUoJ2JvdHRvbS1sZWZ0Jyk7XG5cbiAgICB2YXIgYm9yZGVyU3R5bGVGb3JTaWRlID0gZnVuY3Rpb24gKHNpZGUpIHsgcmV0dXJuICh7XG4gICAgICAgIG5hbWU6IFwiYm9yZGVyLVwiICsgc2lkZSArIFwiLXN0eWxlXCIsXG4gICAgICAgIGluaXRpYWxWYWx1ZTogJ3NvbGlkJyxcbiAgICAgICAgcHJlZml4OiBmYWxzZSxcbiAgICAgICAgdHlwZTogMiAvKiBJREVOVF9WQUxVRSAqLyxcbiAgICAgICAgcGFyc2U6IGZ1bmN0aW9uIChfY29udGV4dCwgc3R5bGUpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoc3R5bGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdub25lJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDAgLyogTk9ORSAqLztcbiAgICAgICAgICAgICAgICBjYXNlICdkYXNoZWQnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMiAvKiBEQVNIRUQgKi87XG4gICAgICAgICAgICAgICAgY2FzZSAnZG90dGVkJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDMgLyogRE9UVEVEICovO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2RvdWJsZSc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiA0IC8qIERPVUJMRSAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAxIC8qIFNPTElEICovO1xuICAgICAgICB9XG4gICAgfSk7IH07XG4gICAgdmFyIGJvcmRlclRvcFN0eWxlID0gYm9yZGVyU3R5bGVGb3JTaWRlKCd0b3AnKTtcbiAgICB2YXIgYm9yZGVyUmlnaHRTdHlsZSA9IGJvcmRlclN0eWxlRm9yU2lkZSgncmlnaHQnKTtcbiAgICB2YXIgYm9yZGVyQm90dG9tU3R5bGUgPSBib3JkZXJTdHlsZUZvclNpZGUoJ2JvdHRvbScpO1xuICAgIHZhciBib3JkZXJMZWZ0U3R5bGUgPSBib3JkZXJTdHlsZUZvclNpZGUoJ2xlZnQnKTtcblxuICAgIHZhciBib3JkZXJXaWR0aEZvclNpZGUgPSBmdW5jdGlvbiAoc2lkZSkgeyByZXR1cm4gKHtcbiAgICAgICAgbmFtZTogXCJib3JkZXItXCIgKyBzaWRlICsgXCItd2lkdGhcIixcbiAgICAgICAgaW5pdGlhbFZhbHVlOiAnMCcsXG4gICAgICAgIHR5cGU6IDAgLyogVkFMVUUgKi8sXG4gICAgICAgIHByZWZpeDogZmFsc2UsXG4gICAgICAgIHBhcnNlOiBmdW5jdGlvbiAoX2NvbnRleHQsIHRva2VuKSB7XG4gICAgICAgICAgICBpZiAoaXNEaW1lbnNpb25Ub2tlbih0b2tlbikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW4ubnVtYmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICB9KTsgfTtcbiAgICB2YXIgYm9yZGVyVG9wV2lkdGggPSBib3JkZXJXaWR0aEZvclNpZGUoJ3RvcCcpO1xuICAgIHZhciBib3JkZXJSaWdodFdpZHRoID0gYm9yZGVyV2lkdGhGb3JTaWRlKCdyaWdodCcpO1xuICAgIHZhciBib3JkZXJCb3R0b21XaWR0aCA9IGJvcmRlcldpZHRoRm9yU2lkZSgnYm90dG9tJyk7XG4gICAgdmFyIGJvcmRlckxlZnRXaWR0aCA9IGJvcmRlcldpZHRoRm9yU2lkZSgnbGVmdCcpO1xuXG4gICAgdmFyIGNvbG9yID0ge1xuICAgICAgICBuYW1lOiBcImNvbG9yXCIsXG4gICAgICAgIGluaXRpYWxWYWx1ZTogJ3RyYW5zcGFyZW50JyxcbiAgICAgICAgcHJlZml4OiBmYWxzZSxcbiAgICAgICAgdHlwZTogMyAvKiBUWVBFX1ZBTFVFICovLFxuICAgICAgICBmb3JtYXQ6ICdjb2xvcidcbiAgICB9O1xuXG4gICAgdmFyIGRpcmVjdGlvbiA9IHtcbiAgICAgICAgbmFtZTogJ2RpcmVjdGlvbicsXG4gICAgICAgIGluaXRpYWxWYWx1ZTogJ2x0cicsXG4gICAgICAgIHByZWZpeDogZmFsc2UsXG4gICAgICAgIHR5cGU6IDIgLyogSURFTlRfVkFMVUUgKi8sXG4gICAgICAgIHBhcnNlOiBmdW5jdGlvbiAoX2NvbnRleHQsIGRpcmVjdGlvbikge1xuICAgICAgICAgICAgc3dpdGNoIChkaXJlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBjYXNlICdydGwnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMSAvKiBSVEwgKi87XG4gICAgICAgICAgICAgICAgY2FzZSAnbHRyJzpcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMCAvKiBMVFIgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGRpc3BsYXkgPSB7XG4gICAgICAgIG5hbWU6ICdkaXNwbGF5JyxcbiAgICAgICAgaW5pdGlhbFZhbHVlOiAnaW5saW5lLWJsb2NrJyxcbiAgICAgICAgcHJlZml4OiBmYWxzZSxcbiAgICAgICAgdHlwZTogMSAvKiBMSVNUICovLFxuICAgICAgICBwYXJzZTogZnVuY3Rpb24gKF9jb250ZXh0LCB0b2tlbnMpIHtcbiAgICAgICAgICAgIHJldHVybiB0b2tlbnMuZmlsdGVyKGlzSWRlbnRUb2tlbikucmVkdWNlKGZ1bmN0aW9uIChiaXQsIHRva2VuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJpdCB8IHBhcnNlRGlzcGxheVZhbHVlKHRva2VuLnZhbHVlKTtcbiAgICAgICAgICAgIH0sIDAgLyogTk9ORSAqLyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBwYXJzZURpc3BsYXlWYWx1ZSA9IGZ1bmN0aW9uIChkaXNwbGF5KSB7XG4gICAgICAgIHN3aXRjaCAoZGlzcGxheSkge1xuICAgICAgICAgICAgY2FzZSAnYmxvY2snOlxuICAgICAgICAgICAgY2FzZSAnLXdlYmtpdC1ib3gnOlxuICAgICAgICAgICAgICAgIHJldHVybiAyIC8qIEJMT0NLICovO1xuICAgICAgICAgICAgY2FzZSAnaW5saW5lJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gNCAvKiBJTkxJTkUgKi87XG4gICAgICAgICAgICBjYXNlICdydW4taW4nOlxuICAgICAgICAgICAgICAgIHJldHVybiA4IC8qIFJVTl9JTiAqLztcbiAgICAgICAgICAgIGNhc2UgJ2Zsb3cnOlxuICAgICAgICAgICAgICAgIHJldHVybiAxNiAvKiBGTE9XICovO1xuICAgICAgICAgICAgY2FzZSAnZmxvdy1yb290JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gMzIgLyogRkxPV19ST09UICovO1xuICAgICAgICAgICAgY2FzZSAndGFibGUnOlxuICAgICAgICAgICAgICAgIHJldHVybiA2NCAvKiBUQUJMRSAqLztcbiAgICAgICAgICAgIGNhc2UgJ2ZsZXgnOlxuICAgICAgICAgICAgY2FzZSAnLXdlYmtpdC1mbGV4JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gMTI4IC8qIEZMRVggKi87XG4gICAgICAgICAgICBjYXNlICdncmlkJzpcbiAgICAgICAgICAgIGNhc2UgJy1tcy1ncmlkJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gMjU2IC8qIEdSSUQgKi87XG4gICAgICAgICAgICBjYXNlICdydWJ5JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gNTEyIC8qIFJVQlkgKi87XG4gICAgICAgICAgICBjYXNlICdzdWJncmlkJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gMTAyNCAvKiBTVUJHUklEICovO1xuICAgICAgICAgICAgY2FzZSAnbGlzdC1pdGVtJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gMjA0OCAvKiBMSVNUX0lURU0gKi87XG4gICAgICAgICAgICBjYXNlICd0YWJsZS1yb3ctZ3JvdXAnOlxuICAgICAgICAgICAgICAgIHJldHVybiA0MDk2IC8qIFRBQkxFX1JPV19HUk9VUCAqLztcbiAgICAgICAgICAgIGNhc2UgJ3RhYmxlLWhlYWRlci1ncm91cCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDgxOTIgLyogVEFCTEVfSEVBREVSX0dST1VQICovO1xuICAgICAgICAgICAgY2FzZSAndGFibGUtZm9vdGVyLWdyb3VwJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gMTYzODQgLyogVEFCTEVfRk9PVEVSX0dST1VQICovO1xuICAgICAgICAgICAgY2FzZSAndGFibGUtcm93JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gMzI3NjggLyogVEFCTEVfUk9XICovO1xuICAgICAgICAgICAgY2FzZSAndGFibGUtY2VsbCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDY1NTM2IC8qIFRBQkxFX0NFTEwgKi87XG4gICAgICAgICAgICBjYXNlICd0YWJsZS1jb2x1bW4tZ3JvdXAnOlxuICAgICAgICAgICAgICAgIHJldHVybiAxMzEwNzIgLyogVEFCTEVfQ09MVU1OX0dST1VQICovO1xuICAgICAgICAgICAgY2FzZSAndGFibGUtY29sdW1uJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gMjYyMTQ0IC8qIFRBQkxFX0NPTFVNTiAqLztcbiAgICAgICAgICAgIGNhc2UgJ3RhYmxlLWNhcHRpb24nOlxuICAgICAgICAgICAgICAgIHJldHVybiA1MjQyODggLyogVEFCTEVfQ0FQVElPTiAqLztcbiAgICAgICAgICAgIGNhc2UgJ3J1YnktYmFzZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDEwNDg1NzYgLyogUlVCWV9CQVNFICovO1xuICAgICAgICAgICAgY2FzZSAncnVieS10ZXh0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gMjA5NzE1MiAvKiBSVUJZX1RFWFQgKi87XG4gICAgICAgICAgICBjYXNlICdydWJ5LWJhc2UtY29udGFpbmVyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gNDE5NDMwNCAvKiBSVUJZX0JBU0VfQ09OVEFJTkVSICovO1xuICAgICAgICAgICAgY2FzZSAncnVieS10ZXh0LWNvbnRhaW5lcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDgzODg2MDggLyogUlVCWV9URVhUX0NPTlRBSU5FUiAqLztcbiAgICAgICAgICAgIGNhc2UgJ2NvbnRlbnRzJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gMTY3NzcyMTYgLyogQ09OVEVOVFMgKi87XG4gICAgICAgICAgICBjYXNlICdpbmxpbmUtYmxvY2snOlxuICAgICAgICAgICAgICAgIHJldHVybiAzMzU1NDQzMiAvKiBJTkxJTkVfQkxPQ0sgKi87XG4gICAgICAgICAgICBjYXNlICdpbmxpbmUtbGlzdC1pdGVtJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gNjcxMDg4NjQgLyogSU5MSU5FX0xJU1RfSVRFTSAqLztcbiAgICAgICAgICAgIGNhc2UgJ2lubGluZS10YWJsZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDEzNDIxNzcyOCAvKiBJTkxJTkVfVEFCTEUgKi87XG4gICAgICAgICAgICBjYXNlICdpbmxpbmUtZmxleCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDI2ODQzNTQ1NiAvKiBJTkxJTkVfRkxFWCAqLztcbiAgICAgICAgICAgIGNhc2UgJ2lubGluZS1ncmlkJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gNTM2ODcwOTEyIC8qIElOTElORV9HUklEICovO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwIC8qIE5PTkUgKi87XG4gICAgfTtcblxuICAgIHZhciBmbG9hdCA9IHtcbiAgICAgICAgbmFtZTogJ2Zsb2F0JyxcbiAgICAgICAgaW5pdGlhbFZhbHVlOiAnbm9uZScsXG4gICAgICAgIHByZWZpeDogZmFsc2UsXG4gICAgICAgIHR5cGU6IDIgLyogSURFTlRfVkFMVUUgKi8sXG4gICAgICAgIHBhcnNlOiBmdW5jdGlvbiAoX2NvbnRleHQsIGZsb2F0KSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGZsb2F0KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxIC8qIExFRlQgKi87XG4gICAgICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMiAvKiBSSUdIVCAqLztcbiAgICAgICAgICAgICAgICBjYXNlICdpbmxpbmUtc3RhcnQnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMyAvKiBJTkxJTkVfU1RBUlQgKi87XG4gICAgICAgICAgICAgICAgY2FzZSAnaW5saW5lLWVuZCc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiA0IC8qIElOTElORV9FTkQgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gMCAvKiBOT05FICovO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBsZXR0ZXJTcGFjaW5nID0ge1xuICAgICAgICBuYW1lOiAnbGV0dGVyLXNwYWNpbmcnLFxuICAgICAgICBpbml0aWFsVmFsdWU6ICcwJyxcbiAgICAgICAgcHJlZml4OiBmYWxzZSxcbiAgICAgICAgdHlwZTogMCAvKiBWQUxVRSAqLyxcbiAgICAgICAgcGFyc2U6IGZ1bmN0aW9uIChfY29udGV4dCwgdG9rZW4pIHtcbiAgICAgICAgICAgIGlmICh0b2tlbi50eXBlID09PSAyMCAvKiBJREVOVF9UT0tFTiAqLyAmJiB0b2tlbi52YWx1ZSA9PT0gJ25vcm1hbCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b2tlbi50eXBlID09PSAxNyAvKiBOVU1CRVJfVE9LRU4gKi8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW4ubnVtYmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IDE1IC8qIERJTUVOU0lPTl9UT0tFTiAqLykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbi5udW1iZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgTElORV9CUkVBSztcbiAgICAoZnVuY3Rpb24gKExJTkVfQlJFQUspIHtcbiAgICAgICAgTElORV9CUkVBS1tcIk5PUk1BTFwiXSA9IFwibm9ybWFsXCI7XG4gICAgICAgIExJTkVfQlJFQUtbXCJTVFJJQ1RcIl0gPSBcInN0cmljdFwiO1xuICAgIH0pKExJTkVfQlJFQUsgfHwgKExJTkVfQlJFQUsgPSB7fSkpO1xuICAgIHZhciBsaW5lQnJlYWsgPSB7XG4gICAgICAgIG5hbWU6ICdsaW5lLWJyZWFrJyxcbiAgICAgICAgaW5pdGlhbFZhbHVlOiAnbm9ybWFsJyxcbiAgICAgICAgcHJlZml4OiBmYWxzZSxcbiAgICAgICAgdHlwZTogMiAvKiBJREVOVF9WQUxVRSAqLyxcbiAgICAgICAgcGFyc2U6IGZ1bmN0aW9uIChfY29udGV4dCwgbGluZUJyZWFrKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGxpbmVCcmVhaykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmljdCc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBMSU5FX0JSRUFLLlNUUklDVDtcbiAgICAgICAgICAgICAgICBjYXNlICdub3JtYWwnOlxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBMSU5FX0JSRUFLLk5PUk1BTDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgbGluZUhlaWdodCA9IHtcbiAgICAgICAgbmFtZTogJ2xpbmUtaGVpZ2h0JyxcbiAgICAgICAgaW5pdGlhbFZhbHVlOiAnbm9ybWFsJyxcbiAgICAgICAgcHJlZml4OiBmYWxzZSxcbiAgICAgICAgdHlwZTogNCAvKiBUT0tFTl9WQUxVRSAqL1xuICAgIH07XG4gICAgdmFyIGNvbXB1dGVMaW5lSGVpZ2h0ID0gZnVuY3Rpb24gKHRva2VuLCBmb250U2l6ZSkge1xuICAgICAgICBpZiAoaXNJZGVudFRva2VuKHRva2VuKSAmJiB0b2tlbi52YWx1ZSA9PT0gJ25vcm1hbCcpIHtcbiAgICAgICAgICAgIHJldHVybiAxLjIgKiBmb250U2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0b2tlbi50eXBlID09PSAxNyAvKiBOVU1CRVJfVE9LRU4gKi8pIHtcbiAgICAgICAgICAgIHJldHVybiBmb250U2l6ZSAqIHRva2VuLm51bWJlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0xlbmd0aFBlcmNlbnRhZ2UodG9rZW4pKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0QWJzb2x1dGVWYWx1ZSh0b2tlbiwgZm9udFNpemUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb250U2l6ZTtcbiAgICB9O1xuXG4gICAgdmFyIGxpc3RTdHlsZUltYWdlID0ge1xuICAgICAgICBuYW1lOiAnbGlzdC1zdHlsZS1pbWFnZScsXG4gICAgICAgIGluaXRpYWxWYWx1ZTogJ25vbmUnLFxuICAgICAgICB0eXBlOiAwIC8qIFZBTFVFICovLFxuICAgICAgICBwcmVmaXg6IGZhbHNlLFxuICAgICAgICBwYXJzZTogZnVuY3Rpb24gKGNvbnRleHQsIHRva2VuKSB7XG4gICAgICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gMjAgLyogSURFTlRfVE9LRU4gKi8gJiYgdG9rZW4udmFsdWUgPT09ICdub25lJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGltYWdlLnBhcnNlKGNvbnRleHQsIHRva2VuKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgbGlzdFN0eWxlUG9zaXRpb24gPSB7XG4gICAgICAgIG5hbWU6ICdsaXN0LXN0eWxlLXBvc2l0aW9uJyxcbiAgICAgICAgaW5pdGlhbFZhbHVlOiAnb3V0c2lkZScsXG4gICAgICAgIHByZWZpeDogZmFsc2UsXG4gICAgICAgIHR5cGU6IDIgLyogSURFTlRfVkFMVUUgKi8sXG4gICAgICAgIHBhcnNlOiBmdW5jdGlvbiAoX2NvbnRleHQsIHBvc2l0aW9uKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnaW5zaWRlJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDAgLyogSU5TSURFICovO1xuICAgICAgICAgICAgICAgIGNhc2UgJ291dHNpZGUnOlxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxIC8qIE9VVFNJREUgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGxpc3RTdHlsZVR5cGUgPSB7XG4gICAgICAgIG5hbWU6ICdsaXN0LXN0eWxlLXR5cGUnLFxuICAgICAgICBpbml0aWFsVmFsdWU6ICdub25lJyxcbiAgICAgICAgcHJlZml4OiBmYWxzZSxcbiAgICAgICAgdHlwZTogMiAvKiBJREVOVF9WQUxVRSAqLyxcbiAgICAgICAgcGFyc2U6IGZ1bmN0aW9uIChfY29udGV4dCwgdHlwZSkge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnZGlzYyc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwIC8qIERJU0MgKi87XG4gICAgICAgICAgICAgICAgY2FzZSAnY2lyY2xlJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDEgLyogQ0lSQ0xFICovO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3NxdWFyZSc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAyIC8qIFNRVUFSRSAqLztcbiAgICAgICAgICAgICAgICBjYXNlICdkZWNpbWFsJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDMgLyogREVDSU1BTCAqLztcbiAgICAgICAgICAgICAgICBjYXNlICdjamstZGVjaW1hbCc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiA0IC8qIENKS19ERUNJTUFMICovO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2RlY2ltYWwtbGVhZGluZy16ZXJvJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDUgLyogREVDSU1BTF9MRUFESU5HX1pFUk8gKi87XG4gICAgICAgICAgICAgICAgY2FzZSAnbG93ZXItcm9tYW4nOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gNiAvKiBMT1dFUl9ST01BTiAqLztcbiAgICAgICAgICAgICAgICBjYXNlICd1cHBlci1yb21hbic6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiA3IC8qIFVQUEVSX1JPTUFOICovO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2xvd2VyLWdyZWVrJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDggLyogTE9XRVJfR1JFRUsgKi87XG4gICAgICAgICAgICAgICAgY2FzZSAnbG93ZXItYWxwaGEnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gOSAvKiBMT1dFUl9BTFBIQSAqLztcbiAgICAgICAgICAgICAgICBjYXNlICd1cHBlci1hbHBoYSc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxMCAvKiBVUFBFUl9BTFBIQSAqLztcbiAgICAgICAgICAgICAgICBjYXNlICdhcmFiaWMtaW5kaWMnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTEgLyogQVJBQklDX0lORElDICovO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2FybWVuaWFuJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDEyIC8qIEFSTUVOSUFOICovO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2JlbmdhbGknOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTMgLyogQkVOR0FMSSAqLztcbiAgICAgICAgICAgICAgICBjYXNlICdjYW1ib2RpYW4nOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTQgLyogQ0FNQk9ESUFOICovO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2Nqay1lYXJ0aGx5LWJyYW5jaCc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxNSAvKiBDSktfRUFSVEhMWV9CUkFOQ0ggKi87XG4gICAgICAgICAgICAgICAgY2FzZSAnY2prLWhlYXZlbmx5LXN0ZW0nOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTYgLyogQ0pLX0hFQVZFTkxZX1NURU0gKi87XG4gICAgICAgICAgICAgICAgY2FzZSAnY2prLWlkZW9ncmFwaGljJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE3IC8qIENKS19JREVPR1JBUEhJQyAqLztcbiAgICAgICAgICAgICAgICBjYXNlICdkZXZhbmFnYXJpJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE4IC8qIERFVkFOQUdBUkkgKi87XG4gICAgICAgICAgICAgICAgY2FzZSAnZXRoaW9waWMtbnVtZXJpYyc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxOSAvKiBFVEhJT1BJQ19OVU1FUklDICovO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2dlb3JnaWFuJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDIwIC8qIEdFT1JHSUFOICovO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2d1amFyYXRpJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDIxIC8qIEdVSkFSQVRJICovO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2d1cm11a2hpJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDIyIC8qIEdVUk1VS0hJICovO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2hlYnJldyc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAyMiAvKiBIRUJSRVcgKi87XG4gICAgICAgICAgICAgICAgY2FzZSAnaGlyYWdhbmEnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMjMgLyogSElSQUdBTkEgKi87XG4gICAgICAgICAgICAgICAgY2FzZSAnaGlyYWdhbmEtaXJvaGEnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMjQgLyogSElSQUdBTkFfSVJPSEEgKi87XG4gICAgICAgICAgICAgICAgY2FzZSAnamFwYW5lc2UtZm9ybWFsJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDI1IC8qIEpBUEFORVNFX0ZPUk1BTCAqLztcbiAgICAgICAgICAgICAgICBjYXNlICdqYXBhbmVzZS1pbmZvcm1hbCc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAyNiAvKiBKQVBBTkVTRV9JTkZPUk1BTCAqLztcbiAgICAgICAgICAgICAgICBjYXNlICdrYW5uYWRhJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDI3IC8qIEtBTk5BREEgKi87XG4gICAgICAgICAgICAgICAgY2FzZSAna2F0YWthbmEnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMjggLyogS0FUQUtBTkEgKi87XG4gICAgICAgICAgICAgICAgY2FzZSAna2F0YWthbmEtaXJvaGEnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMjkgLyogS0FUQUtBTkFfSVJPSEEgKi87XG4gICAgICAgICAgICAgICAgY2FzZSAna2htZXInOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMzAgLyogS0hNRVIgKi87XG4gICAgICAgICAgICAgICAgY2FzZSAna29yZWFuLWhhbmd1bC1mb3JtYWwnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMzEgLyogS09SRUFOX0hBTkdVTF9GT1JNQUwgKi87XG4gICAgICAgICAgICAgICAgY2FzZSAna29yZWFuLWhhbmphLWZvcm1hbCc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAzMiAvKiBLT1JFQU5fSEFOSkFfRk9STUFMICovO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2tvcmVhbi1oYW5qYS1pbmZvcm1hbCc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAzMyAvKiBLT1JFQU5fSEFOSkFfSU5GT1JNQUwgKi87XG4gICAgICAgICAgICAgICAgY2FzZSAnbGFvJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDM0IC8qIExBTyAqLztcbiAgICAgICAgICAgICAgICBjYXNlICdsb3dlci1hcm1lbmlhbic6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAzNSAvKiBMT1dFUl9BUk1FTklBTiAqLztcbiAgICAgICAgICAgICAgICBjYXNlICdtYWxheWFsYW0nOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMzYgLyogTUFMQVlBTEFNICovO1xuICAgICAgICAgICAgICAgIGNhc2UgJ21vbmdvbGlhbic6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAzNyAvKiBNT05HT0xJQU4gKi87XG4gICAgICAgICAgICAgICAgY2FzZSAnbXlhbm1hcic6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAzOCAvKiBNWUFOTUFSICovO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29yaXlhJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDM5IC8qIE9SSVlBICovO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3BlcnNpYW4nOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gNDAgLyogUEVSU0lBTiAqLztcbiAgICAgICAgICAgICAgICBjYXNlICdzaW1wLWNoaW5lc2UtZm9ybWFsJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDQxIC8qIFNJTVBfQ0hJTkVTRV9GT1JNQUwgKi87XG4gICAgICAgICAgICAgICAgY2FzZSAnc2ltcC1jaGluZXNlLWluZm9ybWFsJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDQyIC8qIFNJTVBfQ0hJTkVTRV9JTkZPUk1BTCAqLztcbiAgICAgICAgICAgICAgICBjYXNlICd0YW1pbCc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiA0MyAvKiBUQU1JTCAqLztcbiAgICAgICAgICAgICAgICBjYXNlICd0ZWx1Z3UnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gNDQgLyogVEVMVUdVICovO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3RoYWknOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gNDUgLyogVEhBSSAqLztcbiAgICAgICAgICAgICAgICBjYXNlICd0aWJldGFuJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDQ2IC8qIFRJQkVUQU4gKi87XG4gICAgICAgICAgICAgICAgY2FzZSAndHJhZC1jaGluZXNlLWZvcm1hbCc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiA0NyAvKiBUUkFEX0NISU5FU0VfRk9STUFMICovO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3RyYWQtY2hpbmVzZS1pbmZvcm1hbCc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiA0OCAvKiBUUkFEX0NISU5FU0VfSU5GT1JNQUwgKi87XG4gICAgICAgICAgICAgICAgY2FzZSAndXBwZXItYXJtZW5pYW4nOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gNDkgLyogVVBQRVJfQVJNRU5JQU4gKi87XG4gICAgICAgICAgICAgICAgY2FzZSAnZGlzY2xvc3VyZS1vcGVuJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDUwIC8qIERJU0NMT1NVUkVfT1BFTiAqLztcbiAgICAgICAgICAgICAgICBjYXNlICdkaXNjbG9zdXJlLWNsb3NlZCc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiA1MSAvKiBESVNDTE9TVVJFX0NMT1NFRCAqLztcbiAgICAgICAgICAgICAgICBjYXNlICdub25lJzpcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTEgLyogTk9ORSAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgbWFyZ2luRm9yU2lkZSA9IGZ1bmN0aW9uIChzaWRlKSB7IHJldHVybiAoe1xuICAgICAgICBuYW1lOiBcIm1hcmdpbi1cIiArIHNpZGUsXG4gICAgICAgIGluaXRpYWxWYWx1ZTogJzAnLFxuICAgICAgICBwcmVmaXg6IGZhbHNlLFxuICAgICAgICB0eXBlOiA0IC8qIFRPS0VOX1ZBTFVFICovXG4gICAgfSk7IH07XG4gICAgdmFyIG1hcmdpblRvcCA9IG1hcmdpbkZvclNpZGUoJ3RvcCcpO1xuICAgIHZhciBtYXJnaW5SaWdodCA9IG1hcmdpbkZvclNpZGUoJ3JpZ2h0Jyk7XG4gICAgdmFyIG1hcmdpbkJvdHRvbSA9IG1hcmdpbkZvclNpZGUoJ2JvdHRvbScpO1xuICAgIHZhciBtYXJnaW5MZWZ0ID0gbWFyZ2luRm9yU2lkZSgnbGVmdCcpO1xuXG4gICAgdmFyIG92ZXJmbG93ID0ge1xuICAgICAgICBuYW1lOiAnb3ZlcmZsb3cnLFxuICAgICAgICBpbml0aWFsVmFsdWU6ICd2aXNpYmxlJyxcbiAgICAgICAgcHJlZml4OiBmYWxzZSxcbiAgICAgICAgdHlwZTogMSAvKiBMSVNUICovLFxuICAgICAgICBwYXJzZTogZnVuY3Rpb24gKF9jb250ZXh0LCB0b2tlbnMpIHtcbiAgICAgICAgICAgIHJldHVybiB0b2tlbnMuZmlsdGVyKGlzSWRlbnRUb2tlbikubWFwKGZ1bmN0aW9uIChvdmVyZmxvdykge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAob3ZlcmZsb3cudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnaGlkZGVuJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAxIC8qIEhJRERFTiAqLztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc2Nyb2xsJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAyIC8qIFNDUk9MTCAqLztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnY2xpcCc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMyAvKiBDTElQICovO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdhdXRvJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA0IC8qIEFVVE8gKi87XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3Zpc2libGUnOlxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDAgLyogVklTSUJMRSAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgb3ZlcmZsb3dXcmFwID0ge1xuICAgICAgICBuYW1lOiAnb3ZlcmZsb3ctd3JhcCcsXG4gICAgICAgIGluaXRpYWxWYWx1ZTogJ25vcm1hbCcsXG4gICAgICAgIHByZWZpeDogZmFsc2UsXG4gICAgICAgIHR5cGU6IDIgLyogSURFTlRfVkFMVUUgKi8sXG4gICAgICAgIHBhcnNlOiBmdW5jdGlvbiAoX2NvbnRleHQsIG92ZXJmbG93KSB7XG4gICAgICAgICAgICBzd2l0Y2ggKG92ZXJmbG93KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnYnJlYWstd29yZCc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImJyZWFrLXdvcmRcIiAvKiBCUkVBS19XT1JEICovO1xuICAgICAgICAgICAgICAgIGNhc2UgJ25vcm1hbCc6XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwibm9ybWFsXCIgLyogTk9STUFMICovO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBwYWRkaW5nRm9yU2lkZSA9IGZ1bmN0aW9uIChzaWRlKSB7IHJldHVybiAoe1xuICAgICAgICBuYW1lOiBcInBhZGRpbmctXCIgKyBzaWRlLFxuICAgICAgICBpbml0aWFsVmFsdWU6ICcwJyxcbiAgICAgICAgcHJlZml4OiBmYWxzZSxcbiAgICAgICAgdHlwZTogMyAvKiBUWVBFX1ZBTFVFICovLFxuICAgICAgICBmb3JtYXQ6ICdsZW5ndGgtcGVyY2VudGFnZSdcbiAgICB9KTsgfTtcbiAgICB2YXIgcGFkZGluZ1RvcCA9IHBhZGRpbmdGb3JTaWRlKCd0b3AnKTtcbiAgICB2YXIgcGFkZGluZ1JpZ2h0ID0gcGFkZGluZ0ZvclNpZGUoJ3JpZ2h0Jyk7XG4gICAgdmFyIHBhZGRpbmdCb3R0b20gPSBwYWRkaW5nRm9yU2lkZSgnYm90dG9tJyk7XG4gICAgdmFyIHBhZGRpbmdMZWZ0ID0gcGFkZGluZ0ZvclNpZGUoJ2xlZnQnKTtcblxuICAgIHZhciB0ZXh0QWxpZ24gPSB7XG4gICAgICAgIG5hbWU6ICd0ZXh0LWFsaWduJyxcbiAgICAgICAgaW5pdGlhbFZhbHVlOiAnbGVmdCcsXG4gICAgICAgIHByZWZpeDogZmFsc2UsXG4gICAgICAgIHR5cGU6IDIgLyogSURFTlRfVkFMVUUgKi8sXG4gICAgICAgIHBhcnNlOiBmdW5jdGlvbiAoX2NvbnRleHQsIHRleHRBbGlnbikge1xuICAgICAgICAgICAgc3dpdGNoICh0ZXh0QWxpZ24pIHtcbiAgICAgICAgICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAyIC8qIFJJR0hUICovO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnanVzdGlmeSc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxIC8qIENFTlRFUiAqLztcbiAgICAgICAgICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMCAvKiBMRUZUICovO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBwb3NpdGlvbiA9IHtcbiAgICAgICAgbmFtZTogJ3Bvc2l0aW9uJyxcbiAgICAgICAgaW5pdGlhbFZhbHVlOiAnc3RhdGljJyxcbiAgICAgICAgcHJlZml4OiBmYWxzZSxcbiAgICAgICAgdHlwZTogMiAvKiBJREVOVF9WQUxVRSAqLyxcbiAgICAgICAgcGFyc2U6IGZ1bmN0aW9uIChfY29udGV4dCwgcG9zaXRpb24pIHtcbiAgICAgICAgICAgIHN3aXRjaCAocG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICBjYXNlICdyZWxhdGl2ZSc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxIC8qIFJFTEFUSVZFICovO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2Fic29sdXRlJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDIgLyogQUJTT0xVVEUgKi87XG4gICAgICAgICAgICAgICAgY2FzZSAnZml4ZWQnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMyAvKiBGSVhFRCAqLztcbiAgICAgICAgICAgICAgICBjYXNlICdzdGlja3knOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gNCAvKiBTVElDS1kgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gMCAvKiBTVEFUSUMgKi87XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHRleHRTaGFkb3cgPSB7XG4gICAgICAgIG5hbWU6ICd0ZXh0LXNoYWRvdycsXG4gICAgICAgIGluaXRpYWxWYWx1ZTogJ25vbmUnLFxuICAgICAgICB0eXBlOiAxIC8qIExJU1QgKi8sXG4gICAgICAgIHByZWZpeDogZmFsc2UsXG4gICAgICAgIHBhcnNlOiBmdW5jdGlvbiAoY29udGV4dCwgdG9rZW5zKSB7XG4gICAgICAgICAgICBpZiAodG9rZW5zLmxlbmd0aCA9PT0gMSAmJiBpc0lkZW50V2l0aFZhbHVlKHRva2Vuc1swXSwgJ25vbmUnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwYXJzZUZ1bmN0aW9uQXJncyh0b2tlbnMpLm1hcChmdW5jdGlvbiAodmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNoYWRvdyA9IHtcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6IENPTE9SUy5UUkFOU1BBUkVOVCxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0WDogWkVST19MRU5HVEgsXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldFk6IFpFUk9fTEVOR1RILFxuICAgICAgICAgICAgICAgICAgICBibHVyOiBaRVJPX0xFTkdUSFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdmFyIGMgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0b2tlbiA9IHZhbHVlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTGVuZ3RoKHRva2VuKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFkb3cub2Zmc2V0WCA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYyA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYWRvdy5vZmZzZXRZID0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFkb3cuYmx1ciA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYysrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hhZG93LmNvbG9yID0gY29sb3IkMS5wYXJzZShjb250ZXh0LCB0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNoYWRvdztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciB0ZXh0VHJhbnNmb3JtID0ge1xuICAgICAgICBuYW1lOiAndGV4dC10cmFuc2Zvcm0nLFxuICAgICAgICBpbml0aWFsVmFsdWU6ICdub25lJyxcbiAgICAgICAgcHJlZml4OiBmYWxzZSxcbiAgICAgICAgdHlwZTogMiAvKiBJREVOVF9WQUxVRSAqLyxcbiAgICAgICAgcGFyc2U6IGZ1bmN0aW9uIChfY29udGV4dCwgdGV4dFRyYW5zZm9ybSkge1xuICAgICAgICAgICAgc3dpdGNoICh0ZXh0VHJhbnNmb3JtKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAndXBwZXJjYXNlJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDIgLyogVVBQRVJDQVNFICovO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2xvd2VyY2FzZSc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxIC8qIExPV0VSQ0FTRSAqLztcbiAgICAgICAgICAgICAgICBjYXNlICdjYXBpdGFsaXplJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDMgLyogQ0FQSVRBTElaRSAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwIC8qIE5PTkUgKi87XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHRyYW5zZm9ybSQxID0ge1xuICAgICAgICBuYW1lOiAndHJhbnNmb3JtJyxcbiAgICAgICAgaW5pdGlhbFZhbHVlOiAnbm9uZScsXG4gICAgICAgIHByZWZpeDogdHJ1ZSxcbiAgICAgICAgdHlwZTogMCAvKiBWQUxVRSAqLyxcbiAgICAgICAgcGFyc2U6IGZ1bmN0aW9uIChfY29udGV4dCwgdG9rZW4pIHtcbiAgICAgICAgICAgIGlmICh0b2tlbi50eXBlID09PSAyMCAvKiBJREVOVF9UT0tFTiAqLyAmJiB0b2tlbi52YWx1ZSA9PT0gJ25vbmUnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gMTggLyogRlVOQ1RJT04gKi8pIHtcbiAgICAgICAgICAgICAgICB2YXIgdHJhbnNmb3JtRnVuY3Rpb24gPSBTVVBQT1JURURfVFJBTlNGT1JNX0ZVTkNUSU9OU1t0b2tlbi5uYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRyYW5zZm9ybUZ1bmN0aW9uID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBdHRlbXB0aW5nIHRvIHBhcnNlIGFuIHVuc3VwcG9ydGVkIHRyYW5zZm9ybSBmdW5jdGlvbiBcXFwiXCIgKyB0b2tlbi5uYW1lICsgXCJcXFwiXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJhbnNmb3JtRnVuY3Rpb24odG9rZW4udmFsdWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgbWF0cml4ID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IGFyZ3MuZmlsdGVyKGZ1bmN0aW9uIChhcmcpIHsgcmV0dXJuIGFyZy50eXBlID09PSAxNyAvKiBOVU1CRVJfVE9LRU4gKi87IH0pLm1hcChmdW5jdGlvbiAoYXJnKSB7IHJldHVybiBhcmcubnVtYmVyOyB9KTtcbiAgICAgICAgcmV0dXJuIHZhbHVlcy5sZW5ndGggPT09IDYgPyB2YWx1ZXMgOiBudWxsO1xuICAgIH07XG4gICAgLy8gZG9lc24ndCBzdXBwb3J0IDNEIHRyYW5zZm9ybXMgYXQgdGhlIG1vbWVudFxuICAgIHZhciBtYXRyaXgzZCA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBhcmdzLmZpbHRlcihmdW5jdGlvbiAoYXJnKSB7IHJldHVybiBhcmcudHlwZSA9PT0gMTcgLyogTlVNQkVSX1RPS0VOICovOyB9KS5tYXAoZnVuY3Rpb24gKGFyZykgeyByZXR1cm4gYXJnLm51bWJlcjsgfSk7XG4gICAgICAgIHZhciBhMSA9IHZhbHVlc1swXSwgYjEgPSB2YWx1ZXNbMV07IHZhbHVlc1syXTsgdmFsdWVzWzNdOyB2YXIgYTIgPSB2YWx1ZXNbNF0sIGIyID0gdmFsdWVzWzVdOyB2YWx1ZXNbNl07IHZhbHVlc1s3XTsgdmFsdWVzWzhdOyB2YWx1ZXNbOV07IHZhbHVlc1sxMF07IHZhbHVlc1sxMV07IHZhciBhNCA9IHZhbHVlc1sxMl0sIGI0ID0gdmFsdWVzWzEzXTsgdmFsdWVzWzE0XTsgdmFsdWVzWzE1XTtcbiAgICAgICAgcmV0dXJuIHZhbHVlcy5sZW5ndGggPT09IDE2ID8gW2ExLCBiMSwgYTIsIGIyLCBhNCwgYjRdIDogbnVsbDtcbiAgICB9O1xuICAgIHZhciBTVVBQT1JURURfVFJBTlNGT1JNX0ZVTkNUSU9OUyA9IHtcbiAgICAgICAgbWF0cml4OiBtYXRyaXgsXG4gICAgICAgIG1hdHJpeDNkOiBtYXRyaXgzZFxuICAgIH07XG5cbiAgICB2YXIgREVGQVVMVF9WQUxVRSA9IHtcbiAgICAgICAgdHlwZTogMTYgLyogUEVSQ0VOVEFHRV9UT0tFTiAqLyxcbiAgICAgICAgbnVtYmVyOiA1MCxcbiAgICAgICAgZmxhZ3M6IEZMQUdfSU5URUdFUlxuICAgIH07XG4gICAgdmFyIERFRkFVTFQgPSBbREVGQVVMVF9WQUxVRSwgREVGQVVMVF9WQUxVRV07XG4gICAgdmFyIHRyYW5zZm9ybU9yaWdpbiA9IHtcbiAgICAgICAgbmFtZTogJ3RyYW5zZm9ybS1vcmlnaW4nLFxuICAgICAgICBpbml0aWFsVmFsdWU6ICc1MCUgNTAlJyxcbiAgICAgICAgcHJlZml4OiB0cnVlLFxuICAgICAgICB0eXBlOiAxIC8qIExJU1QgKi8sXG4gICAgICAgIHBhcnNlOiBmdW5jdGlvbiAoX2NvbnRleHQsIHRva2Vucykge1xuICAgICAgICAgICAgdmFyIG9yaWdpbnMgPSB0b2tlbnMuZmlsdGVyKGlzTGVuZ3RoUGVyY2VudGFnZSk7XG4gICAgICAgICAgICBpZiAob3JpZ2lucy5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gREVGQVVMVDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbb3JpZ2luc1swXSwgb3JpZ2luc1sxXV07XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHZpc2liaWxpdHkgPSB7XG4gICAgICAgIG5hbWU6ICd2aXNpYmxlJyxcbiAgICAgICAgaW5pdGlhbFZhbHVlOiAnbm9uZScsXG4gICAgICAgIHByZWZpeDogZmFsc2UsXG4gICAgICAgIHR5cGU6IDIgLyogSURFTlRfVkFMVUUgKi8sXG4gICAgICAgIHBhcnNlOiBmdW5jdGlvbiAoX2NvbnRleHQsIHZpc2liaWxpdHkpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodmlzaWJpbGl0eSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2hpZGRlbic6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxIC8qIEhJRERFTiAqLztcbiAgICAgICAgICAgICAgICBjYXNlICdjb2xsYXBzZSc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAyIC8qIENPTExBUFNFICovO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3Zpc2libGUnOlxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwIC8qIFZJU0lCTEUgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIFdPUkRfQlJFQUs7XG4gICAgKGZ1bmN0aW9uIChXT1JEX0JSRUFLKSB7XG4gICAgICAgIFdPUkRfQlJFQUtbXCJOT1JNQUxcIl0gPSBcIm5vcm1hbFwiO1xuICAgICAgICBXT1JEX0JSRUFLW1wiQlJFQUtfQUxMXCJdID0gXCJicmVhay1hbGxcIjtcbiAgICAgICAgV09SRF9CUkVBS1tcIktFRVBfQUxMXCJdID0gXCJrZWVwLWFsbFwiO1xuICAgIH0pKFdPUkRfQlJFQUsgfHwgKFdPUkRfQlJFQUsgPSB7fSkpO1xuICAgIHZhciB3b3JkQnJlYWsgPSB7XG4gICAgICAgIG5hbWU6ICd3b3JkLWJyZWFrJyxcbiAgICAgICAgaW5pdGlhbFZhbHVlOiAnbm9ybWFsJyxcbiAgICAgICAgcHJlZml4OiBmYWxzZSxcbiAgICAgICAgdHlwZTogMiAvKiBJREVOVF9WQUxVRSAqLyxcbiAgICAgICAgcGFyc2U6IGZ1bmN0aW9uIChfY29udGV4dCwgd29yZEJyZWFrKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHdvcmRCcmVhaykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2JyZWFrLWFsbCc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBXT1JEX0JSRUFLLkJSRUFLX0FMTDtcbiAgICAgICAgICAgICAgICBjYXNlICdrZWVwLWFsbCc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBXT1JEX0JSRUFLLktFRVBfQUxMO1xuICAgICAgICAgICAgICAgIGNhc2UgJ25vcm1hbCc6XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFdPUkRfQlJFQUsuTk9STUFMO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciB6SW5kZXggPSB7XG4gICAgICAgIG5hbWU6ICd6LWluZGV4JyxcbiAgICAgICAgaW5pdGlhbFZhbHVlOiAnYXV0bycsXG4gICAgICAgIHByZWZpeDogZmFsc2UsXG4gICAgICAgIHR5cGU6IDAgLyogVkFMVUUgKi8sXG4gICAgICAgIHBhcnNlOiBmdW5jdGlvbiAoX2NvbnRleHQsIHRva2VuKSB7XG4gICAgICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gMjAgLyogSURFTlRfVE9LRU4gKi8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBhdXRvOiB0cnVlLCBvcmRlcjogMCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzTnVtYmVyVG9rZW4odG9rZW4pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgYXV0bzogZmFsc2UsIG9yZGVyOiB0b2tlbi5udW1iZXIgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgei1pbmRleCBudW1iZXIgcGFyc2VkXCIpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciB0aW1lID0ge1xuICAgICAgICBuYW1lOiAndGltZScsXG4gICAgICAgIHBhcnNlOiBmdW5jdGlvbiAoX2NvbnRleHQsIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUudHlwZSA9PT0gMTUgLyogRElNRU5TSU9OX1RPS0VOICovKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh2YWx1ZS51bml0LnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncyc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTAwMCAqIHZhbHVlLm51bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbXMnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLm51bWJlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCB0aW1lIHR5cGVcIik7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIG9wYWNpdHkgPSB7XG4gICAgICAgIG5hbWU6ICdvcGFjaXR5JyxcbiAgICAgICAgaW5pdGlhbFZhbHVlOiAnMScsXG4gICAgICAgIHR5cGU6IDAgLyogVkFMVUUgKi8sXG4gICAgICAgIHByZWZpeDogZmFsc2UsXG4gICAgICAgIHBhcnNlOiBmdW5jdGlvbiAoX2NvbnRleHQsIHRva2VuKSB7XG4gICAgICAgICAgICBpZiAoaXNOdW1iZXJUb2tlbih0b2tlbikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW4ubnVtYmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHRleHREZWNvcmF0aW9uQ29sb3IgPSB7XG4gICAgICAgIG5hbWU6IFwidGV4dC1kZWNvcmF0aW9uLWNvbG9yXCIsXG4gICAgICAgIGluaXRpYWxWYWx1ZTogJ3RyYW5zcGFyZW50JyxcbiAgICAgICAgcHJlZml4OiBmYWxzZSxcbiAgICAgICAgdHlwZTogMyAvKiBUWVBFX1ZBTFVFICovLFxuICAgICAgICBmb3JtYXQ6ICdjb2xvcidcbiAgICB9O1xuXG4gICAgdmFyIHRleHREZWNvcmF0aW9uTGluZSA9IHtcbiAgICAgICAgbmFtZTogJ3RleHQtZGVjb3JhdGlvbi1saW5lJyxcbiAgICAgICAgaW5pdGlhbFZhbHVlOiAnbm9uZScsXG4gICAgICAgIHByZWZpeDogZmFsc2UsXG4gICAgICAgIHR5cGU6IDEgLyogTElTVCAqLyxcbiAgICAgICAgcGFyc2U6IGZ1bmN0aW9uIChfY29udGV4dCwgdG9rZW5zKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW5zXG4gICAgICAgICAgICAgICAgLmZpbHRlcihpc0lkZW50VG9rZW4pXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRva2VuLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3VuZGVybGluZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMSAvKiBVTkRFUkxJTkUgKi87XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ292ZXJsaW5lJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAyIC8qIE9WRVJMSU5FICovO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdsaW5lLXRocm91Z2gnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDMgLyogTElORV9USFJPVUdIICovO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdub25lJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA0IC8qIEJMSU5LICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gMCAvKiBOT05FICovO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChsaW5lKSB7IHJldHVybiBsaW5lICE9PSAwIC8qIE5PTkUgKi87IH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBmb250RmFtaWx5ID0ge1xuICAgICAgICBuYW1lOiBcImZvbnQtZmFtaWx5XCIsXG4gICAgICAgIGluaXRpYWxWYWx1ZTogJycsXG4gICAgICAgIHByZWZpeDogZmFsc2UsXG4gICAgICAgIHR5cGU6IDEgLyogTElTVCAqLyxcbiAgICAgICAgcGFyc2U6IGZ1bmN0aW9uIChfY29udGV4dCwgdG9rZW5zKSB7XG4gICAgICAgICAgICB2YXIgYWNjdW11bGF0b3IgPSBbXTtcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgICAgICB0b2tlbnMuZm9yRWFjaChmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRva2VuLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyMCAvKiBJREVOVF9UT0tFTiAqLzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwIC8qIFNUUklOR19UT0tFTiAqLzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjY3VtdWxhdG9yLnB1c2godG9rZW4udmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTcgLyogTlVNQkVSX1RPS0VOICovOlxuICAgICAgICAgICAgICAgICAgICAgICAgYWNjdW11bGF0b3IucHVzaCh0b2tlbi5udW1iZXIudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0IC8qIENPTU1BX1RPS0VOICovOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGFjY3VtdWxhdG9yLmpvaW4oJyAnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY2N1bXVsYXRvci5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoYWNjdW11bGF0b3IubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGFjY3VtdWxhdG9yLmpvaW4oJyAnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cy5tYXAoZnVuY3Rpb24gKHJlc3VsdCkgeyByZXR1cm4gKHJlc3VsdC5pbmRleE9mKCcgJykgPT09IC0xID8gcmVzdWx0IDogXCInXCIgKyByZXN1bHQgKyBcIidcIik7IH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBmb250U2l6ZSA9IHtcbiAgICAgICAgbmFtZTogXCJmb250LXNpemVcIixcbiAgICAgICAgaW5pdGlhbFZhbHVlOiAnMCcsXG4gICAgICAgIHByZWZpeDogZmFsc2UsXG4gICAgICAgIHR5cGU6IDMgLyogVFlQRV9WQUxVRSAqLyxcbiAgICAgICAgZm9ybWF0OiAnbGVuZ3RoJ1xuICAgIH07XG5cbiAgICB2YXIgZm9udFdlaWdodCA9IHtcbiAgICAgICAgbmFtZTogJ2ZvbnQtd2VpZ2h0JyxcbiAgICAgICAgaW5pdGlhbFZhbHVlOiAnbm9ybWFsJyxcbiAgICAgICAgdHlwZTogMCAvKiBWQUxVRSAqLyxcbiAgICAgICAgcHJlZml4OiBmYWxzZSxcbiAgICAgICAgcGFyc2U6IGZ1bmN0aW9uIChfY29udGV4dCwgdG9rZW4pIHtcbiAgICAgICAgICAgIGlmIChpc051bWJlclRva2VuKHRva2VuKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbi5udW1iZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNJZGVudFRva2VuKHRva2VuKSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodG9rZW4udmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYm9sZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gNzAwO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdub3JtYWwnOlxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDQwMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gNDAwO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBmb250VmFyaWFudCA9IHtcbiAgICAgICAgbmFtZTogJ2ZvbnQtdmFyaWFudCcsXG4gICAgICAgIGluaXRpYWxWYWx1ZTogJ25vbmUnLFxuICAgICAgICB0eXBlOiAxIC8qIExJU1QgKi8sXG4gICAgICAgIHByZWZpeDogZmFsc2UsXG4gICAgICAgIHBhcnNlOiBmdW5jdGlvbiAoX2NvbnRleHQsIHRva2Vucykge1xuICAgICAgICAgICAgcmV0dXJuIHRva2Vucy5maWx0ZXIoaXNJZGVudFRva2VuKS5tYXAoZnVuY3Rpb24gKHRva2VuKSB7IHJldHVybiB0b2tlbi52YWx1ZTsgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGZvbnRTdHlsZSA9IHtcbiAgICAgICAgbmFtZTogJ2ZvbnQtc3R5bGUnLFxuICAgICAgICBpbml0aWFsVmFsdWU6ICdub3JtYWwnLFxuICAgICAgICBwcmVmaXg6IGZhbHNlLFxuICAgICAgICB0eXBlOiAyIC8qIElERU5UX1ZBTFVFICovLFxuICAgICAgICBwYXJzZTogZnVuY3Rpb24gKF9jb250ZXh0LCBvdmVyZmxvdykge1xuICAgICAgICAgICAgc3dpdGNoIChvdmVyZmxvdykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ29ibGlxdWUnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJvYmxpcXVlXCIgLyogT0JMSVFVRSAqLztcbiAgICAgICAgICAgICAgICBjYXNlICdpdGFsaWMnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJpdGFsaWNcIiAvKiBJVEFMSUMgKi87XG4gICAgICAgICAgICAgICAgY2FzZSAnbm9ybWFsJzpcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJub3JtYWxcIiAvKiBOT1JNQUwgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGNvbnRhaW5zID0gZnVuY3Rpb24gKGJpdCwgdmFsdWUpIHsgcmV0dXJuIChiaXQgJiB2YWx1ZSkgIT09IDA7IH07XG5cbiAgICB2YXIgY29udGVudCA9IHtcbiAgICAgICAgbmFtZTogJ2NvbnRlbnQnLFxuICAgICAgICBpbml0aWFsVmFsdWU6ICdub25lJyxcbiAgICAgICAgdHlwZTogMSAvKiBMSVNUICovLFxuICAgICAgICBwcmVmaXg6IGZhbHNlLFxuICAgICAgICBwYXJzZTogZnVuY3Rpb24gKF9jb250ZXh0LCB0b2tlbnMpIHtcbiAgICAgICAgICAgIGlmICh0b2tlbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGZpcnN0ID0gdG9rZW5zWzBdO1xuICAgICAgICAgICAgaWYgKGZpcnN0LnR5cGUgPT09IDIwIC8qIElERU5UX1RPS0VOICovICYmIGZpcnN0LnZhbHVlID09PSAnbm9uZScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdG9rZW5zO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBjb3VudGVySW5jcmVtZW50ID0ge1xuICAgICAgICBuYW1lOiAnY291bnRlci1pbmNyZW1lbnQnLFxuICAgICAgICBpbml0aWFsVmFsdWU6ICdub25lJyxcbiAgICAgICAgcHJlZml4OiB0cnVlLFxuICAgICAgICB0eXBlOiAxIC8qIExJU1QgKi8sXG4gICAgICAgIHBhcnNlOiBmdW5jdGlvbiAoX2NvbnRleHQsIHRva2Vucykge1xuICAgICAgICAgICAgaWYgKHRva2Vucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBmaXJzdCA9IHRva2Vuc1swXTtcbiAgICAgICAgICAgIGlmIChmaXJzdC50eXBlID09PSAyMCAvKiBJREVOVF9UT0tFTiAqLyAmJiBmaXJzdC52YWx1ZSA9PT0gJ25vbmUnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaW5jcmVtZW50cyA9IFtdO1xuICAgICAgICAgICAgdmFyIGZpbHRlcmVkID0gdG9rZW5zLmZpbHRlcihub25XaGl0ZVNwYWNlKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmlsdGVyZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY291bnRlciA9IGZpbHRlcmVkW2ldO1xuICAgICAgICAgICAgICAgIHZhciBuZXh0ID0gZmlsdGVyZWRbaSArIDFdO1xuICAgICAgICAgICAgICAgIGlmIChjb3VudGVyLnR5cGUgPT09IDIwIC8qIElERU5UX1RPS0VOICovKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmNyZW1lbnQgPSBuZXh0ICYmIGlzTnVtYmVyVG9rZW4obmV4dCkgPyBuZXh0Lm51bWJlciA6IDE7XG4gICAgICAgICAgICAgICAgICAgIGluY3JlbWVudHMucHVzaCh7IGNvdW50ZXI6IGNvdW50ZXIudmFsdWUsIGluY3JlbWVudDogaW5jcmVtZW50IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpbmNyZW1lbnRzO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBjb3VudGVyUmVzZXQgPSB7XG4gICAgICAgIG5hbWU6ICdjb3VudGVyLXJlc2V0JyxcbiAgICAgICAgaW5pdGlhbFZhbHVlOiAnbm9uZScsXG4gICAgICAgIHByZWZpeDogdHJ1ZSxcbiAgICAgICAgdHlwZTogMSAvKiBMSVNUICovLFxuICAgICAgICBwYXJzZTogZnVuY3Rpb24gKF9jb250ZXh0LCB0b2tlbnMpIHtcbiAgICAgICAgICAgIGlmICh0b2tlbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJlc2V0cyA9IFtdO1xuICAgICAgICAgICAgdmFyIGZpbHRlcmVkID0gdG9rZW5zLmZpbHRlcihub25XaGl0ZVNwYWNlKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmlsdGVyZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY291bnRlciA9IGZpbHRlcmVkW2ldO1xuICAgICAgICAgICAgICAgIHZhciBuZXh0ID0gZmlsdGVyZWRbaSArIDFdO1xuICAgICAgICAgICAgICAgIGlmIChpc0lkZW50VG9rZW4oY291bnRlcikgJiYgY291bnRlci52YWx1ZSAhPT0gJ25vbmUnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXNldCA9IG5leHQgJiYgaXNOdW1iZXJUb2tlbihuZXh0KSA/IG5leHQubnVtYmVyIDogMDtcbiAgICAgICAgICAgICAgICAgICAgcmVzZXRzLnB1c2goeyBjb3VudGVyOiBjb3VudGVyLnZhbHVlLCByZXNldDogcmVzZXQgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc2V0cztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgZHVyYXRpb24gPSB7XG4gICAgICAgIG5hbWU6ICdkdXJhdGlvbicsXG4gICAgICAgIGluaXRpYWxWYWx1ZTogJzBzJyxcbiAgICAgICAgcHJlZml4OiBmYWxzZSxcbiAgICAgICAgdHlwZTogMSAvKiBMSVNUICovLFxuICAgICAgICBwYXJzZTogZnVuY3Rpb24gKGNvbnRleHQsIHRva2Vucykge1xuICAgICAgICAgICAgcmV0dXJuIHRva2Vucy5maWx0ZXIoaXNEaW1lbnNpb25Ub2tlbikubWFwKGZ1bmN0aW9uICh0b2tlbikgeyByZXR1cm4gdGltZS5wYXJzZShjb250ZXh0LCB0b2tlbik7IH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBxdW90ZXMgPSB7XG4gICAgICAgIG5hbWU6ICdxdW90ZXMnLFxuICAgICAgICBpbml0aWFsVmFsdWU6ICdub25lJyxcbiAgICAgICAgcHJlZml4OiB0cnVlLFxuICAgICAgICB0eXBlOiAxIC8qIExJU1QgKi8sXG4gICAgICAgIHBhcnNlOiBmdW5jdGlvbiAoX2NvbnRleHQsIHRva2Vucykge1xuICAgICAgICAgICAgaWYgKHRva2Vucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBmaXJzdCA9IHRva2Vuc1swXTtcbiAgICAgICAgICAgIGlmIChmaXJzdC50eXBlID09PSAyMCAvKiBJREVOVF9UT0tFTiAqLyAmJiBmaXJzdC52YWx1ZSA9PT0gJ25vbmUnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcXVvdGVzID0gW107XG4gICAgICAgICAgICB2YXIgZmlsdGVyZWQgPSB0b2tlbnMuZmlsdGVyKGlzU3RyaW5nVG9rZW4pO1xuICAgICAgICAgICAgaWYgKGZpbHRlcmVkLmxlbmd0aCAlIDIgIT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmlsdGVyZWQubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3Blbl8xID0gZmlsdGVyZWRbaV0udmFsdWU7XG4gICAgICAgICAgICAgICAgdmFyIGNsb3NlXzEgPSBmaWx0ZXJlZFtpICsgMV0udmFsdWU7XG4gICAgICAgICAgICAgICAgcXVvdGVzLnB1c2goeyBvcGVuOiBvcGVuXzEsIGNsb3NlOiBjbG9zZV8xIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHF1b3RlcztcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIGdldFF1b3RlID0gZnVuY3Rpb24gKHF1b3RlcywgZGVwdGgsIG9wZW4pIHtcbiAgICAgICAgaWYgKCFxdW90ZXMpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgcXVvdGUgPSBxdW90ZXNbTWF0aC5taW4oZGVwdGgsIHF1b3Rlcy5sZW5ndGggLSAxKV07XG4gICAgICAgIGlmICghcXVvdGUpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3BlbiA/IHF1b3RlLm9wZW4gOiBxdW90ZS5jbG9zZTtcbiAgICB9O1xuXG4gICAgdmFyIGJveFNoYWRvdyA9IHtcbiAgICAgICAgbmFtZTogJ2JveC1zaGFkb3cnLFxuICAgICAgICBpbml0aWFsVmFsdWU6ICdub25lJyxcbiAgICAgICAgdHlwZTogMSAvKiBMSVNUICovLFxuICAgICAgICBwcmVmaXg6IGZhbHNlLFxuICAgICAgICBwYXJzZTogZnVuY3Rpb24gKGNvbnRleHQsIHRva2Vucykge1xuICAgICAgICAgICAgaWYgKHRva2Vucy5sZW5ndGggPT09IDEgJiYgaXNJZGVudFdpdGhWYWx1ZSh0b2tlbnNbMF0sICdub25lJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VGdW5jdGlvbkFyZ3ModG9rZW5zKS5tYXAoZnVuY3Rpb24gKHZhbHVlcykge1xuICAgICAgICAgICAgICAgIHZhciBzaGFkb3cgPSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiAweDAwMDAwMGZmLFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXRYOiBaRVJPX0xFTkdUSCxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0WTogWkVST19MRU5HVEgsXG4gICAgICAgICAgICAgICAgICAgIGJsdXI6IFpFUk9fTEVOR1RILFxuICAgICAgICAgICAgICAgICAgICBzcHJlYWQ6IFpFUk9fTEVOR1RILFxuICAgICAgICAgICAgICAgICAgICBpbnNldDogZmFsc2VcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHZhciBjID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdG9rZW4gPSB2YWx1ZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0lkZW50V2l0aFZhbHVlKHRva2VuLCAnaW5zZXQnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hhZG93Lmluc2V0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0xlbmd0aCh0b2tlbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhZG93Lm9mZnNldFggPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGMgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFkb3cub2Zmc2V0WSA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYyA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYWRvdy5ibHVyID0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFkb3cuc3ByZWFkID0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaGFkb3cuY29sb3IgPSBjb2xvciQxLnBhcnNlKGNvbnRleHQsIHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gc2hhZG93O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHBhaW50T3JkZXIgPSB7XG4gICAgICAgIG5hbWU6ICdwYWludC1vcmRlcicsXG4gICAgICAgIGluaXRpYWxWYWx1ZTogJ25vcm1hbCcsXG4gICAgICAgIHByZWZpeDogZmFsc2UsXG4gICAgICAgIHR5cGU6IDEgLyogTElTVCAqLyxcbiAgICAgICAgcGFyc2U6IGZ1bmN0aW9uIChfY29udGV4dCwgdG9rZW5zKSB7XG4gICAgICAgICAgICB2YXIgREVGQVVMVF9WQUxVRSA9IFswIC8qIEZJTEwgKi8sIDEgLyogU1RST0tFICovLCAyIC8qIE1BUktFUlMgKi9dO1xuICAgICAgICAgICAgdmFyIGxheWVycyA9IFtdO1xuICAgICAgICAgICAgdG9rZW5zLmZpbHRlcihpc0lkZW50VG9rZW4pLmZvckVhY2goZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0b2tlbi52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdzdHJva2UnOlxuICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXJzLnB1c2goMSAvKiBTVFJPS0UgKi8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2ZpbGwnOlxuICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXJzLnB1c2goMCAvKiBGSUxMICovKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdtYXJrZXJzJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheWVycy5wdXNoKDIgLyogTUFSS0VSUyAqLyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIERFRkFVTFRfVkFMVUUuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAobGF5ZXJzLmluZGV4T2YodmFsdWUpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBsYXllcnMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gbGF5ZXJzO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciB3ZWJraXRUZXh0U3Ryb2tlQ29sb3IgPSB7XG4gICAgICAgIG5hbWU6IFwiLXdlYmtpdC10ZXh0LXN0cm9rZS1jb2xvclwiLFxuICAgICAgICBpbml0aWFsVmFsdWU6ICdjdXJyZW50Y29sb3InLFxuICAgICAgICBwcmVmaXg6IGZhbHNlLFxuICAgICAgICB0eXBlOiAzIC8qIFRZUEVfVkFMVUUgKi8sXG4gICAgICAgIGZvcm1hdDogJ2NvbG9yJ1xuICAgIH07XG5cbiAgICB2YXIgd2Via2l0VGV4dFN0cm9rZVdpZHRoID0ge1xuICAgICAgICBuYW1lOiBcIi13ZWJraXQtdGV4dC1zdHJva2Utd2lkdGhcIixcbiAgICAgICAgaW5pdGlhbFZhbHVlOiAnMCcsXG4gICAgICAgIHR5cGU6IDAgLyogVkFMVUUgKi8sXG4gICAgICAgIHByZWZpeDogZmFsc2UsXG4gICAgICAgIHBhcnNlOiBmdW5jdGlvbiAoX2NvbnRleHQsIHRva2VuKSB7XG4gICAgICAgICAgICBpZiAoaXNEaW1lbnNpb25Ub2tlbih0b2tlbikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW4ubnVtYmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIENTU1BhcnNlZERlY2xhcmF0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBDU1NQYXJzZWREZWNsYXJhdGlvbihjb250ZXh0LCBkZWNsYXJhdGlvbikge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uRHVyYXRpb24gPSBwYXJzZShjb250ZXh0LCBkdXJhdGlvbiwgZGVjbGFyYXRpb24uYW5pbWF0aW9uRHVyYXRpb24pO1xuICAgICAgICAgICAgdGhpcy5iYWNrZ3JvdW5kQ2xpcCA9IHBhcnNlKGNvbnRleHQsIGJhY2tncm91bmRDbGlwLCBkZWNsYXJhdGlvbi5iYWNrZ3JvdW5kQ2xpcCk7XG4gICAgICAgICAgICB0aGlzLmJhY2tncm91bmRDb2xvciA9IHBhcnNlKGNvbnRleHQsIGJhY2tncm91bmRDb2xvciwgZGVjbGFyYXRpb24uYmFja2dyb3VuZENvbG9yKTtcbiAgICAgICAgICAgIHRoaXMuYmFja2dyb3VuZEltYWdlID0gcGFyc2UoY29udGV4dCwgYmFja2dyb3VuZEltYWdlLCBkZWNsYXJhdGlvbi5iYWNrZ3JvdW5kSW1hZ2UpO1xuICAgICAgICAgICAgdGhpcy5iYWNrZ3JvdW5kT3JpZ2luID0gcGFyc2UoY29udGV4dCwgYmFja2dyb3VuZE9yaWdpbiwgZGVjbGFyYXRpb24uYmFja2dyb3VuZE9yaWdpbik7XG4gICAgICAgICAgICB0aGlzLmJhY2tncm91bmRQb3NpdGlvbiA9IHBhcnNlKGNvbnRleHQsIGJhY2tncm91bmRQb3NpdGlvbiwgZGVjbGFyYXRpb24uYmFja2dyb3VuZFBvc2l0aW9uKTtcbiAgICAgICAgICAgIHRoaXMuYmFja2dyb3VuZFJlcGVhdCA9IHBhcnNlKGNvbnRleHQsIGJhY2tncm91bmRSZXBlYXQsIGRlY2xhcmF0aW9uLmJhY2tncm91bmRSZXBlYXQpO1xuICAgICAgICAgICAgdGhpcy5iYWNrZ3JvdW5kU2l6ZSA9IHBhcnNlKGNvbnRleHQsIGJhY2tncm91bmRTaXplLCBkZWNsYXJhdGlvbi5iYWNrZ3JvdW5kU2l6ZSk7XG4gICAgICAgICAgICB0aGlzLmJvcmRlclRvcENvbG9yID0gcGFyc2UoY29udGV4dCwgYm9yZGVyVG9wQ29sb3IsIGRlY2xhcmF0aW9uLmJvcmRlclRvcENvbG9yKTtcbiAgICAgICAgICAgIHRoaXMuYm9yZGVyUmlnaHRDb2xvciA9IHBhcnNlKGNvbnRleHQsIGJvcmRlclJpZ2h0Q29sb3IsIGRlY2xhcmF0aW9uLmJvcmRlclJpZ2h0Q29sb3IpO1xuICAgICAgICAgICAgdGhpcy5ib3JkZXJCb3R0b21Db2xvciA9IHBhcnNlKGNvbnRleHQsIGJvcmRlckJvdHRvbUNvbG9yLCBkZWNsYXJhdGlvbi5ib3JkZXJCb3R0b21Db2xvcik7XG4gICAgICAgICAgICB0aGlzLmJvcmRlckxlZnRDb2xvciA9IHBhcnNlKGNvbnRleHQsIGJvcmRlckxlZnRDb2xvciwgZGVjbGFyYXRpb24uYm9yZGVyTGVmdENvbG9yKTtcbiAgICAgICAgICAgIHRoaXMuYm9yZGVyVG9wTGVmdFJhZGl1cyA9IHBhcnNlKGNvbnRleHQsIGJvcmRlclRvcExlZnRSYWRpdXMsIGRlY2xhcmF0aW9uLmJvcmRlclRvcExlZnRSYWRpdXMpO1xuICAgICAgICAgICAgdGhpcy5ib3JkZXJUb3BSaWdodFJhZGl1cyA9IHBhcnNlKGNvbnRleHQsIGJvcmRlclRvcFJpZ2h0UmFkaXVzLCBkZWNsYXJhdGlvbi5ib3JkZXJUb3BSaWdodFJhZGl1cyk7XG4gICAgICAgICAgICB0aGlzLmJvcmRlckJvdHRvbVJpZ2h0UmFkaXVzID0gcGFyc2UoY29udGV4dCwgYm9yZGVyQm90dG9tUmlnaHRSYWRpdXMsIGRlY2xhcmF0aW9uLmJvcmRlckJvdHRvbVJpZ2h0UmFkaXVzKTtcbiAgICAgICAgICAgIHRoaXMuYm9yZGVyQm90dG9tTGVmdFJhZGl1cyA9IHBhcnNlKGNvbnRleHQsIGJvcmRlckJvdHRvbUxlZnRSYWRpdXMsIGRlY2xhcmF0aW9uLmJvcmRlckJvdHRvbUxlZnRSYWRpdXMpO1xuICAgICAgICAgICAgdGhpcy5ib3JkZXJUb3BTdHlsZSA9IHBhcnNlKGNvbnRleHQsIGJvcmRlclRvcFN0eWxlLCBkZWNsYXJhdGlvbi5ib3JkZXJUb3BTdHlsZSk7XG4gICAgICAgICAgICB0aGlzLmJvcmRlclJpZ2h0U3R5bGUgPSBwYXJzZShjb250ZXh0LCBib3JkZXJSaWdodFN0eWxlLCBkZWNsYXJhdGlvbi5ib3JkZXJSaWdodFN0eWxlKTtcbiAgICAgICAgICAgIHRoaXMuYm9yZGVyQm90dG9tU3R5bGUgPSBwYXJzZShjb250ZXh0LCBib3JkZXJCb3R0b21TdHlsZSwgZGVjbGFyYXRpb24uYm9yZGVyQm90dG9tU3R5bGUpO1xuICAgICAgICAgICAgdGhpcy5ib3JkZXJMZWZ0U3R5bGUgPSBwYXJzZShjb250ZXh0LCBib3JkZXJMZWZ0U3R5bGUsIGRlY2xhcmF0aW9uLmJvcmRlckxlZnRTdHlsZSk7XG4gICAgICAgICAgICB0aGlzLmJvcmRlclRvcFdpZHRoID0gcGFyc2UoY29udGV4dCwgYm9yZGVyVG9wV2lkdGgsIGRlY2xhcmF0aW9uLmJvcmRlclRvcFdpZHRoKTtcbiAgICAgICAgICAgIHRoaXMuYm9yZGVyUmlnaHRXaWR0aCA9IHBhcnNlKGNvbnRleHQsIGJvcmRlclJpZ2h0V2lkdGgsIGRlY2xhcmF0aW9uLmJvcmRlclJpZ2h0V2lkdGgpO1xuICAgICAgICAgICAgdGhpcy5ib3JkZXJCb3R0b21XaWR0aCA9IHBhcnNlKGNvbnRleHQsIGJvcmRlckJvdHRvbVdpZHRoLCBkZWNsYXJhdGlvbi5ib3JkZXJCb3R0b21XaWR0aCk7XG4gICAgICAgICAgICB0aGlzLmJvcmRlckxlZnRXaWR0aCA9IHBhcnNlKGNvbnRleHQsIGJvcmRlckxlZnRXaWR0aCwgZGVjbGFyYXRpb24uYm9yZGVyTGVmdFdpZHRoKTtcbiAgICAgICAgICAgIHRoaXMuYm94U2hhZG93ID0gcGFyc2UoY29udGV4dCwgYm94U2hhZG93LCBkZWNsYXJhdGlvbi5ib3hTaGFkb3cpO1xuICAgICAgICAgICAgdGhpcy5jb2xvciA9IHBhcnNlKGNvbnRleHQsIGNvbG9yLCBkZWNsYXJhdGlvbi5jb2xvcik7XG4gICAgICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IHBhcnNlKGNvbnRleHQsIGRpcmVjdGlvbiwgZGVjbGFyYXRpb24uZGlyZWN0aW9uKTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGxheSA9IHBhcnNlKGNvbnRleHQsIGRpc3BsYXksIGRlY2xhcmF0aW9uLmRpc3BsYXkpO1xuICAgICAgICAgICAgdGhpcy5mbG9hdCA9IHBhcnNlKGNvbnRleHQsIGZsb2F0LCBkZWNsYXJhdGlvbi5jc3NGbG9hdCk7XG4gICAgICAgICAgICB0aGlzLmZvbnRGYW1pbHkgPSBwYXJzZShjb250ZXh0LCBmb250RmFtaWx5LCBkZWNsYXJhdGlvbi5mb250RmFtaWx5KTtcbiAgICAgICAgICAgIHRoaXMuZm9udFNpemUgPSBwYXJzZShjb250ZXh0LCBmb250U2l6ZSwgZGVjbGFyYXRpb24uZm9udFNpemUpO1xuICAgICAgICAgICAgdGhpcy5mb250U3R5bGUgPSBwYXJzZShjb250ZXh0LCBmb250U3R5bGUsIGRlY2xhcmF0aW9uLmZvbnRTdHlsZSk7XG4gICAgICAgICAgICB0aGlzLmZvbnRWYXJpYW50ID0gcGFyc2UoY29udGV4dCwgZm9udFZhcmlhbnQsIGRlY2xhcmF0aW9uLmZvbnRWYXJpYW50KTtcbiAgICAgICAgICAgIHRoaXMuZm9udFdlaWdodCA9IHBhcnNlKGNvbnRleHQsIGZvbnRXZWlnaHQsIGRlY2xhcmF0aW9uLmZvbnRXZWlnaHQpO1xuICAgICAgICAgICAgdGhpcy5sZXR0ZXJTcGFjaW5nID0gcGFyc2UoY29udGV4dCwgbGV0dGVyU3BhY2luZywgZGVjbGFyYXRpb24ubGV0dGVyU3BhY2luZyk7XG4gICAgICAgICAgICB0aGlzLmxpbmVCcmVhayA9IHBhcnNlKGNvbnRleHQsIGxpbmVCcmVhaywgZGVjbGFyYXRpb24ubGluZUJyZWFrKTtcbiAgICAgICAgICAgIHRoaXMubGluZUhlaWdodCA9IHBhcnNlKGNvbnRleHQsIGxpbmVIZWlnaHQsIGRlY2xhcmF0aW9uLmxpbmVIZWlnaHQpO1xuICAgICAgICAgICAgdGhpcy5saXN0U3R5bGVJbWFnZSA9IHBhcnNlKGNvbnRleHQsIGxpc3RTdHlsZUltYWdlLCBkZWNsYXJhdGlvbi5saXN0U3R5bGVJbWFnZSk7XG4gICAgICAgICAgICB0aGlzLmxpc3RTdHlsZVBvc2l0aW9uID0gcGFyc2UoY29udGV4dCwgbGlzdFN0eWxlUG9zaXRpb24sIGRlY2xhcmF0aW9uLmxpc3RTdHlsZVBvc2l0aW9uKTtcbiAgICAgICAgICAgIHRoaXMubGlzdFN0eWxlVHlwZSA9IHBhcnNlKGNvbnRleHQsIGxpc3RTdHlsZVR5cGUsIGRlY2xhcmF0aW9uLmxpc3RTdHlsZVR5cGUpO1xuICAgICAgICAgICAgdGhpcy5tYXJnaW5Ub3AgPSBwYXJzZShjb250ZXh0LCBtYXJnaW5Ub3AsIGRlY2xhcmF0aW9uLm1hcmdpblRvcCk7XG4gICAgICAgICAgICB0aGlzLm1hcmdpblJpZ2h0ID0gcGFyc2UoY29udGV4dCwgbWFyZ2luUmlnaHQsIGRlY2xhcmF0aW9uLm1hcmdpblJpZ2h0KTtcbiAgICAgICAgICAgIHRoaXMubWFyZ2luQm90dG9tID0gcGFyc2UoY29udGV4dCwgbWFyZ2luQm90dG9tLCBkZWNsYXJhdGlvbi5tYXJnaW5Cb3R0b20pO1xuICAgICAgICAgICAgdGhpcy5tYXJnaW5MZWZ0ID0gcGFyc2UoY29udGV4dCwgbWFyZ2luTGVmdCwgZGVjbGFyYXRpb24ubWFyZ2luTGVmdCk7XG4gICAgICAgICAgICB0aGlzLm9wYWNpdHkgPSBwYXJzZShjb250ZXh0LCBvcGFjaXR5LCBkZWNsYXJhdGlvbi5vcGFjaXR5KTtcbiAgICAgICAgICAgIHZhciBvdmVyZmxvd1R1cGxlID0gcGFyc2UoY29udGV4dCwgb3ZlcmZsb3csIGRlY2xhcmF0aW9uLm92ZXJmbG93KTtcbiAgICAgICAgICAgIHRoaXMub3ZlcmZsb3dYID0gb3ZlcmZsb3dUdXBsZVswXTtcbiAgICAgICAgICAgIHRoaXMub3ZlcmZsb3dZID0gb3ZlcmZsb3dUdXBsZVtvdmVyZmxvd1R1cGxlLmxlbmd0aCA+IDEgPyAxIDogMF07XG4gICAgICAgICAgICB0aGlzLm92ZXJmbG93V3JhcCA9IHBhcnNlKGNvbnRleHQsIG92ZXJmbG93V3JhcCwgZGVjbGFyYXRpb24ub3ZlcmZsb3dXcmFwKTtcbiAgICAgICAgICAgIHRoaXMucGFkZGluZ1RvcCA9IHBhcnNlKGNvbnRleHQsIHBhZGRpbmdUb3AsIGRlY2xhcmF0aW9uLnBhZGRpbmdUb3ApO1xuICAgICAgICAgICAgdGhpcy5wYWRkaW5nUmlnaHQgPSBwYXJzZShjb250ZXh0LCBwYWRkaW5nUmlnaHQsIGRlY2xhcmF0aW9uLnBhZGRpbmdSaWdodCk7XG4gICAgICAgICAgICB0aGlzLnBhZGRpbmdCb3R0b20gPSBwYXJzZShjb250ZXh0LCBwYWRkaW5nQm90dG9tLCBkZWNsYXJhdGlvbi5wYWRkaW5nQm90dG9tKTtcbiAgICAgICAgICAgIHRoaXMucGFkZGluZ0xlZnQgPSBwYXJzZShjb250ZXh0LCBwYWRkaW5nTGVmdCwgZGVjbGFyYXRpb24ucGFkZGluZ0xlZnQpO1xuICAgICAgICAgICAgdGhpcy5wYWludE9yZGVyID0gcGFyc2UoY29udGV4dCwgcGFpbnRPcmRlciwgZGVjbGFyYXRpb24ucGFpbnRPcmRlcik7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uID0gcGFyc2UoY29udGV4dCwgcG9zaXRpb24sIGRlY2xhcmF0aW9uLnBvc2l0aW9uKTtcbiAgICAgICAgICAgIHRoaXMudGV4dEFsaWduID0gcGFyc2UoY29udGV4dCwgdGV4dEFsaWduLCBkZWNsYXJhdGlvbi50ZXh0QWxpZ24pO1xuICAgICAgICAgICAgdGhpcy50ZXh0RGVjb3JhdGlvbkNvbG9yID0gcGFyc2UoY29udGV4dCwgdGV4dERlY29yYXRpb25Db2xvciwgKF9hID0gZGVjbGFyYXRpb24udGV4dERlY29yYXRpb25Db2xvcikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZGVjbGFyYXRpb24uY29sb3IpO1xuICAgICAgICAgICAgdGhpcy50ZXh0RGVjb3JhdGlvbkxpbmUgPSBwYXJzZShjb250ZXh0LCB0ZXh0RGVjb3JhdGlvbkxpbmUsIChfYiA9IGRlY2xhcmF0aW9uLnRleHREZWNvcmF0aW9uTGluZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZGVjbGFyYXRpb24udGV4dERlY29yYXRpb24pO1xuICAgICAgICAgICAgdGhpcy50ZXh0U2hhZG93ID0gcGFyc2UoY29udGV4dCwgdGV4dFNoYWRvdywgZGVjbGFyYXRpb24udGV4dFNoYWRvdyk7XG4gICAgICAgICAgICB0aGlzLnRleHRUcmFuc2Zvcm0gPSBwYXJzZShjb250ZXh0LCB0ZXh0VHJhbnNmb3JtLCBkZWNsYXJhdGlvbi50ZXh0VHJhbnNmb3JtKTtcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtID0gcGFyc2UoY29udGV4dCwgdHJhbnNmb3JtJDEsIGRlY2xhcmF0aW9uLnRyYW5zZm9ybSk7XG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybU9yaWdpbiA9IHBhcnNlKGNvbnRleHQsIHRyYW5zZm9ybU9yaWdpbiwgZGVjbGFyYXRpb24udHJhbnNmb3JtT3JpZ2luKTtcbiAgICAgICAgICAgIHRoaXMudmlzaWJpbGl0eSA9IHBhcnNlKGNvbnRleHQsIHZpc2liaWxpdHksIGRlY2xhcmF0aW9uLnZpc2liaWxpdHkpO1xuICAgICAgICAgICAgdGhpcy53ZWJraXRUZXh0U3Ryb2tlQ29sb3IgPSBwYXJzZShjb250ZXh0LCB3ZWJraXRUZXh0U3Ryb2tlQ29sb3IsIGRlY2xhcmF0aW9uLndlYmtpdFRleHRTdHJva2VDb2xvcik7XG4gICAgICAgICAgICB0aGlzLndlYmtpdFRleHRTdHJva2VXaWR0aCA9IHBhcnNlKGNvbnRleHQsIHdlYmtpdFRleHRTdHJva2VXaWR0aCwgZGVjbGFyYXRpb24ud2Via2l0VGV4dFN0cm9rZVdpZHRoKTtcbiAgICAgICAgICAgIHRoaXMud29yZEJyZWFrID0gcGFyc2UoY29udGV4dCwgd29yZEJyZWFrLCBkZWNsYXJhdGlvbi53b3JkQnJlYWspO1xuICAgICAgICAgICAgdGhpcy56SW5kZXggPSBwYXJzZShjb250ZXh0LCB6SW5kZXgsIGRlY2xhcmF0aW9uLnpJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgQ1NTUGFyc2VkRGVjbGFyYXRpb24ucHJvdG90eXBlLmlzVmlzaWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRpc3BsYXkgPiAwICYmIHRoaXMub3BhY2l0eSA+IDAgJiYgdGhpcy52aXNpYmlsaXR5ID09PSAwIC8qIFZJU0lCTEUgKi87XG4gICAgICAgIH07XG4gICAgICAgIENTU1BhcnNlZERlY2xhcmF0aW9uLnByb3RvdHlwZS5pc1RyYW5zcGFyZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGlzVHJhbnNwYXJlbnQodGhpcy5iYWNrZ3JvdW5kQ29sb3IpO1xuICAgICAgICB9O1xuICAgICAgICBDU1NQYXJzZWREZWNsYXJhdGlvbi5wcm90b3R5cGUuaXNUcmFuc2Zvcm1lZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybSAhPT0gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgQ1NTUGFyc2VkRGVjbGFyYXRpb24ucHJvdG90eXBlLmlzUG9zaXRpb25lZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9uICE9PSAwIC8qIFNUQVRJQyAqLztcbiAgICAgICAgfTtcbiAgICAgICAgQ1NTUGFyc2VkRGVjbGFyYXRpb24ucHJvdG90eXBlLmlzUG9zaXRpb25lZFdpdGhaSW5kZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc1Bvc2l0aW9uZWQoKSAmJiAhdGhpcy56SW5kZXguYXV0bztcbiAgICAgICAgfTtcbiAgICAgICAgQ1NTUGFyc2VkRGVjbGFyYXRpb24ucHJvdG90eXBlLmlzRmxvYXRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mbG9hdCAhPT0gMCAvKiBOT05FICovO1xuICAgICAgICB9O1xuICAgICAgICBDU1NQYXJzZWREZWNsYXJhdGlvbi5wcm90b3R5cGUuaXNJbmxpbmVMZXZlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAoY29udGFpbnModGhpcy5kaXNwbGF5LCA0IC8qIElOTElORSAqLykgfHxcbiAgICAgICAgICAgICAgICBjb250YWlucyh0aGlzLmRpc3BsYXksIDMzNTU0NDMyIC8qIElOTElORV9CTE9DSyAqLykgfHxcbiAgICAgICAgICAgICAgICBjb250YWlucyh0aGlzLmRpc3BsYXksIDI2ODQzNTQ1NiAvKiBJTkxJTkVfRkxFWCAqLykgfHxcbiAgICAgICAgICAgICAgICBjb250YWlucyh0aGlzLmRpc3BsYXksIDUzNjg3MDkxMiAvKiBJTkxJTkVfR1JJRCAqLykgfHxcbiAgICAgICAgICAgICAgICBjb250YWlucyh0aGlzLmRpc3BsYXksIDY3MTA4ODY0IC8qIElOTElORV9MSVNUX0lURU0gKi8pIHx8XG4gICAgICAgICAgICAgICAgY29udGFpbnModGhpcy5kaXNwbGF5LCAxMzQyMTc3MjggLyogSU5MSU5FX1RBQkxFICovKSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBDU1NQYXJzZWREZWNsYXJhdGlvbjtcbiAgICB9KCkpO1xuICAgIHZhciBDU1NQYXJzZWRQc2V1ZG9EZWNsYXJhdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQ1NTUGFyc2VkUHNldWRvRGVjbGFyYXRpb24oY29udGV4dCwgZGVjbGFyYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuY29udGVudCA9IHBhcnNlKGNvbnRleHQsIGNvbnRlbnQsIGRlY2xhcmF0aW9uLmNvbnRlbnQpO1xuICAgICAgICAgICAgdGhpcy5xdW90ZXMgPSBwYXJzZShjb250ZXh0LCBxdW90ZXMsIGRlY2xhcmF0aW9uLnF1b3Rlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIENTU1BhcnNlZFBzZXVkb0RlY2xhcmF0aW9uO1xuICAgIH0oKSk7XG4gICAgdmFyIENTU1BhcnNlZENvdW50ZXJEZWNsYXJhdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQ1NTUGFyc2VkQ291bnRlckRlY2xhcmF0aW9uKGNvbnRleHQsIGRlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmNvdW50ZXJJbmNyZW1lbnQgPSBwYXJzZShjb250ZXh0LCBjb3VudGVySW5jcmVtZW50LCBkZWNsYXJhdGlvbi5jb3VudGVySW5jcmVtZW50KTtcbiAgICAgICAgICAgIHRoaXMuY291bnRlclJlc2V0ID0gcGFyc2UoY29udGV4dCwgY291bnRlclJlc2V0LCBkZWNsYXJhdGlvbi5jb3VudGVyUmVzZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBDU1NQYXJzZWRDb3VudGVyRGVjbGFyYXRpb247XG4gICAgfSgpKTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIHZhciBwYXJzZSA9IGZ1bmN0aW9uIChjb250ZXh0LCBkZXNjcmlwdG9yLCBzdHlsZSkge1xuICAgICAgICB2YXIgdG9rZW5pemVyID0gbmV3IFRva2VuaXplcigpO1xuICAgICAgICB2YXIgdmFsdWUgPSBzdHlsZSAhPT0gbnVsbCAmJiB0eXBlb2Ygc3R5bGUgIT09ICd1bmRlZmluZWQnID8gc3R5bGUudG9TdHJpbmcoKSA6IGRlc2NyaXB0b3IuaW5pdGlhbFZhbHVlO1xuICAgICAgICB0b2tlbml6ZXIud3JpdGUodmFsdWUpO1xuICAgICAgICB2YXIgcGFyc2VyID0gbmV3IFBhcnNlcih0b2tlbml6ZXIucmVhZCgpKTtcbiAgICAgICAgc3dpdGNoIChkZXNjcmlwdG9yLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgMiAvKiBJREVOVF9WQUxVRSAqLzpcbiAgICAgICAgICAgICAgICB2YXIgdG9rZW4gPSBwYXJzZXIucGFyc2VDb21wb25lbnRWYWx1ZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBkZXNjcmlwdG9yLnBhcnNlKGNvbnRleHQsIGlzSWRlbnRUb2tlbih0b2tlbikgPyB0b2tlbi52YWx1ZSA6IGRlc2NyaXB0b3IuaW5pdGlhbFZhbHVlKTtcbiAgICAgICAgICAgIGNhc2UgMCAvKiBWQUxVRSAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVzY3JpcHRvci5wYXJzZShjb250ZXh0LCBwYXJzZXIucGFyc2VDb21wb25lbnRWYWx1ZSgpKTtcbiAgICAgICAgICAgIGNhc2UgMSAvKiBMSVNUICovOlxuICAgICAgICAgICAgICAgIHJldHVybiBkZXNjcmlwdG9yLnBhcnNlKGNvbnRleHQsIHBhcnNlci5wYXJzZUNvbXBvbmVudFZhbHVlcygpKTtcbiAgICAgICAgICAgIGNhc2UgNCAvKiBUT0tFTl9WQUxVRSAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VyLnBhcnNlQ29tcG9uZW50VmFsdWUoKTtcbiAgICAgICAgICAgIGNhc2UgMyAvKiBUWVBFX1ZBTFVFICovOlxuICAgICAgICAgICAgICAgIHN3aXRjaCAoZGVzY3JpcHRvci5mb3JtYXQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYW5nbGUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFuZ2xlLnBhcnNlKGNvbnRleHQsIHBhcnNlci5wYXJzZUNvbXBvbmVudFZhbHVlKCkpO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdjb2xvcic6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29sb3IkMS5wYXJzZShjb250ZXh0LCBwYXJzZXIucGFyc2VDb21wb25lbnRWYWx1ZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnaW1hZ2UnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGltYWdlLnBhcnNlKGNvbnRleHQsIHBhcnNlci5wYXJzZUNvbXBvbmVudFZhbHVlKCkpO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdsZW5ndGgnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlbmd0aF8xID0gcGFyc2VyLnBhcnNlQ29tcG9uZW50VmFsdWUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpc0xlbmd0aChsZW5ndGhfMSkgPyBsZW5ndGhfMSA6IFpFUk9fTEVOR1RIO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdsZW5ndGgtcGVyY2VudGFnZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWVfMSA9IHBhcnNlci5wYXJzZUNvbXBvbmVudFZhbHVlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNMZW5ndGhQZXJjZW50YWdlKHZhbHVlXzEpID8gdmFsdWVfMSA6IFpFUk9fTEVOR1RIO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICd0aW1lJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aW1lLnBhcnNlKGNvbnRleHQsIHBhcnNlci5wYXJzZUNvbXBvbmVudFZhbHVlKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgZWxlbWVudERlYnVnZ2VyQXR0cmlidXRlID0gJ2RhdGEtaHRtbDJjYW52YXMtZGVidWcnO1xuICAgIHZhciBnZXRFbGVtZW50RGVidWdUeXBlID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKGVsZW1lbnREZWJ1Z2dlckF0dHJpYnV0ZSk7XG4gICAgICAgIHN3aXRjaCAoYXR0cmlidXRlKSB7XG4gICAgICAgICAgICBjYXNlICdhbGwnOlxuICAgICAgICAgICAgICAgIHJldHVybiAxIC8qIEFMTCAqLztcbiAgICAgICAgICAgIGNhc2UgJ2Nsb25lJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gMiAvKiBDTE9ORSAqLztcbiAgICAgICAgICAgIGNhc2UgJ3BhcnNlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gMyAvKiBQQVJTRSAqLztcbiAgICAgICAgICAgIGNhc2UgJ3JlbmRlcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDQgLyogUkVOREVSICovO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gMCAvKiBOT05FICovO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgaXNEZWJ1Z2dpbmcgPSBmdW5jdGlvbiAoZWxlbWVudCwgdHlwZSkge1xuICAgICAgICB2YXIgZWxlbWVudFR5cGUgPSBnZXRFbGVtZW50RGVidWdUeXBlKGVsZW1lbnQpO1xuICAgICAgICByZXR1cm4gZWxlbWVudFR5cGUgPT09IDEgLyogQUxMICovIHx8IHR5cGUgPT09IGVsZW1lbnRUeXBlO1xuICAgIH07XG5cbiAgICB2YXIgRWxlbWVudENvbnRhaW5lciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gRWxlbWVudENvbnRhaW5lcihjb250ZXh0LCBlbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICAgICAgdGhpcy50ZXh0Tm9kZXMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudHMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuZmxhZ3MgPSAwO1xuICAgICAgICAgICAgaWYgKGlzRGVidWdnaW5nKGVsZW1lbnQsIDMgLyogUEFSU0UgKi8pKSB7XG4gICAgICAgICAgICAgICAgZGVidWdnZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnN0eWxlcyA9IG5ldyBDU1NQYXJzZWREZWNsYXJhdGlvbihjb250ZXh0LCB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50LCBudWxsKSk7XG4gICAgICAgICAgICBpZiAoaXNIVE1MRWxlbWVudE5vZGUoZWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdHlsZXMuYW5pbWF0aW9uRHVyYXRpb24uc29tZShmdW5jdGlvbiAoZHVyYXRpb24pIHsgcmV0dXJuIGR1cmF0aW9uID4gMDsgfSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5hbmltYXRpb25EdXJhdGlvbiA9ICcwcyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0eWxlcy50cmFuc2Zvcm0gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZ2V0Qm91bmRpbmdDbGllbnRSZWN0IHRha2VzIHRyYW5zZm9ybXMgaW50byBhY2NvdW50XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUudHJhbnNmb3JtID0gJ25vbmUnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYm91bmRzID0gcGFyc2VCb3VuZHModGhpcy5jb250ZXh0LCBlbGVtZW50KTtcbiAgICAgICAgICAgIGlmIChpc0RlYnVnZ2luZyhlbGVtZW50LCA0IC8qIFJFTkRFUiAqLykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZsYWdzIHw9IDE2IC8qIERFQlVHX1JFTkRFUiAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRWxlbWVudENvbnRhaW5lcjtcbiAgICB9KCkpO1xuXG4gICAgLypcbiAgICAgKiB0ZXh0LXNlZ21lbnRhdGlvbiAxLjAuMyA8aHR0cHM6Ly9naXRodWIuY29tL25pa2xhc3ZoL3RleHQtc2VnbWVudGF0aW9uPlxuICAgICAqIENvcHlyaWdodCAoYykgMjAyMiBOaWtsYXMgdm9uIEhlcnR6ZW4gPGh0dHBzOi8vaGVydHplbi5jb20+XG4gICAgICogUmVsZWFzZWQgdW5kZXIgTUlUIExpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgYmFzZTY0ID0gJ0FBQUFBQUFBQUFBQUVBNEFHQmtBQUZBYUFBQUNBQUFBQUFBSUFCQUFHQUF3QURnQUNBQVFBQWdBRUFBSUFCQUFDQUFRQUFnQUVBQUlBQkFBQ0FBUUFBZ0FFQUFJQUJBQVFBQklBRVFBVEFBSUFCQUFDQUFRQUFnQUVBQUlBQkFBVkFCY0FBZ0FFQUFJQUJBQUNBQVFBR0FBYUFCd0FIZ0FnQUNJQUk0QWxnQUlBQkFBbXdDakFLZ0FzQUMyQUw0QXZRREZBTW9BMGdCUEFWWUJXZ0VJQUFnQUNBQ01BTm9BWWdGa0FXd0JkQUY4QVgwQmhRR05BWlVCbGdHZUFhTUJsUUdXQWFzQnN3RjhBYnNCd3dGMEFjc0JZd0hUQVFnQTJ3Ry9BT01CZEFGOEFla0I4UUYwQWZrQit3SGlBSFFCZkFFSUFBTUM1Z1FJQUFzQ0VnSUlBQWdBRmdJZUFnZ0FJZ0lwQWdnQU1RSTVBa0FDeWdFSUFBZ0FTQUpRQWxnQ1lBSUlBQWdBQ0FBS0JRb0ZDZ1VUQlJNRkdRVXJCU3NGQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FCZEFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUJvQW1nQ3J3R3ZBUWdBYmdKMkFnZ0FIZ0VJQUFnQUNBRG5BWHNDQ0FBSUFBZ0Fnd0lJQUFnQUNBQUlBQWdBQ0FDS0FnZ0FrUUtaQWdnQVBBREpBQWdBb1FLa0Fxd0NzZ0s2QXNJQ0NBREpBZ2dBMEFJSUFBZ0FDQUFJQU5ZQzNnSUlBQWdBQ0FBSUFBZ0FDQUJBQU9ZQ0NBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFrQVNvQitRSUVBQWdBQ0FBOEFFTUNDQUJDQlFnQUNBQkpCVkFGQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FCVEJWb0ZDQUFJQUZvRkNBQmZCV1VGQ0FBSUFBZ0FDQUFJQUFnQWJRVUlBQWdBQ0FBSUFBZ0FDQUJ6QlhzRmZRV0ZCWW9GaWdXS0JaRUZpZ1dLQllvRm1BV2ZCYVlGcmdXeEJia0ZDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQU1FRkNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFNZ0ZDQURRQlFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBTzRDQ0FBSUFBZ0FpUUFJQUFnQUNBQkFBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBRDBBZ2dBQ0FEOEFnZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBTllGQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQU1EdndBSUFBZ0FKQUlJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDd01UQXdnQUNBQjlCT3NFR3dNakF3Z0FLd015QXdzRllnRTNBL01FUHdNSUFFVURUUU5SQXdnQVdRT3NBR0VEQ0FBSUFBZ0FDQUFJQUFnQUNBQnBBelFGTlFVMkJUY0ZPQVU1QlRvRk5BVTFCVFlGTndVNEJUa0ZPZ1UwQlRVRk5nVTNCVGdGT1FVNkJUUUZOUVUyQlRjRk9BVTVCVG9GTkFVMUJUWUZOd1U0QlRrRk9nVTBCVFVGTmdVM0JUZ0ZPUVU2QlRRRk5RVTJCVGNGT0FVNUJUb0ZOQVUxQlRZRk53VTRCVGtGT2dVMEJUVUZOZ1UzQlRnRk9RVTZCVFFGTlFVMkJUY0ZPQVU1QlRvRk5BVTFCVFlGTndVNEJUa0ZPZ1UwQlRVRk5nVTNCVGdGT1FVNkJUUUZOUVUyQlRjRk9BVTVCVG9GTkFVMUJUWUZOd1U0QlRrRk9nVTBCVFVGTmdVM0JUZ0ZPUVU2QlRRRk5RVTJCVGNGT0FVNUJUb0ZOQVUxQlRZRk53VTRCVGtGT2dVMEJUVUZOZ1UzQlRnRk9RVTZCVFFGTlFVMkJUY0ZPQVU1QlRvRk5BVTFCVFlGTndVNEJUa0ZPZ1UwQlRVRk5nVTNCVGdGT1FVNkJUUUZOUVUyQlRjRk9BVTVCVG9GTkFVMUJUWUZOd1U0QlRrRk9nVTBCVFVGTmdVM0JUZ0ZPUVU2QlRRRk5RVTJCVGNGT0FVNUJUb0ZOQVUxQlRZRk53VTRCVGtGT2dVMEJUVUZOZ1UzQlRnRk9RVTZCVFFGTlFVMkJUY0ZPQVU1QlRvRk5BVTFCVFlGTndVNEJUa0ZPZ1UwQlRVRk5nVTNCVGdGT1FVNkJUUUZOUVUyQlRjRk9BVTVCVG9GTkFVMUJUWUZOd1U0QlRrRk9nVTBCVFVGTmdVM0JUZ0ZPUVU2QlRRRk5RVTJCVGNGT0FVNUJUb0ZOQVUxQlRZRk53VTRCVGtGT2dVMEJUVUZOZ1UzQlRnRk9RVTZCVFFGTlFVMkJUY0ZPQVU1QlRvRk5BVTFCVFlGTndVNEJUa0ZPZ1UwQlRVRk5nVTNCVGdGT1FVNkJUUUZOUVUyQlRjRk9BVTVCVG9GTkFVMUJUWUZOd1U0QlRrRk9nVTBCVFVGTmdVM0JUZ0ZPUVU2QlRRRk5RVTJCVGNGT0FVNUJUb0ZOQVUxQlRZRk53VTRCVGtGT2dVMEJUVUZOZ1UzQlRnRk9RVTZCVFFGTlFVMkJUY0ZPQVU1QlRvRk5BVTFCVFlGTndVNEJUa0ZPZ1UwQlRVRk5nVTNCVGdGT1FVNkJUUUZOUVUyQlRjRk9BVTVCVG9GTkFVMUJUWUZOd1U0QlRrRklRVW9CU3dGQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FCdEF3Z0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQk1BRXdBQ0FBSUFBZ0FDQUFJQUJnQUNBQUlBQWdBQ0FDL0FBZ0FDQUF5QVFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FDQUFJQUF3QUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFBQVJBQklBQWdBQ0FBSUFCUUFTQUFJQUFnQUlBQndBRUFBamdDSUFCc0FxQUMyQUwwQWlnRFFBdHdDK0lKSVFxVkFaVUJXUXFWQVpVQmxRR1ZBWlVCbFFHckM1VUJsUUdWQVpVQmxRR1ZBWlVCbFFHVkFYc0tsUUdWQWJBSzZ3c3JER1VNcFF6bERKVUJsUUdWQVpVQmxRR1ZBWlVCbFFHVkFaVUJsUUdWQVpVQmxRR1ZBWlVCbFFHVkFaVUJsUUdWQVpVQmxRR1ZBWlVCbFFHVkFaVUJsUUdWQVpVQmxRR1ZBWlVCbFFHVkFaVUJsUUdWQVpVQmxRR1ZBWlVCbFFHVkFaVUJsUUdWQVpVQmxRR1ZBWlVCbFFHVkFaVUJsUUdWQVpVQmxRR1ZBWlVCbFFHVkFaVUJsUUdWQVpVQmxRR1ZBWlVCbFFHVkFaVUJsUUdWQVpVQmxRR1ZBWlVCbFFHVkFaVUJsUUdWQVpVQmxRR1ZBWlVCbFFHVkFaVUJsUUdWQVpVQmxRR1ZBWlVCbFFHVkFaVUJsUUdWQVpVQmxRR1ZBWlVCbFFHVkFaVUJsUUdWQVpVQmxRR1ZBWlVCbFFHVkFaVUJsUUdWQVpVQmxRR1ZBWlVCbFFHVkFaVUJsUUdWQVpVQmxRR1ZBWlVCbFFHVkFaVUJsUUdWQVpVQmxRR1ZBWlVCbFFHVkFaVUJsUUdWQVpVQmxRR1ZBWlVCbFFHVkFaVUJsUUdWQVpVQmxRR1ZBWlVCbFFHVkFaVUJsUUdWQVpVQmxRR1ZBWlVCbFFHVkFaVUJsUUdWQVpVQmxRR1ZBWlVCbFFHVkFaVUJsUUdWQVpVQmxRR1ZBWlVCbFFHVkFaVUJsUUdWQVpVQmxRR1ZBWlVCbFFHVkFaVUJsUUdWQVpVQmxRR1ZBWlVCbFFHVkFaVUJsUUdWQVpVQmxRR1ZBWlVCbFFHVkFaVUJsUUdWQVpVQmxRR1ZBWlVCbFFHVkFaVUJsUUdWQVpVQmxRR1ZBWlVCbFFHVkFaVUJsUUdWQVpVQmxRR1ZBWlVCbFFHVkFaVUJsUUdWQVpVQmxRR1ZBWlVCbFFHVkFaVUJsUUdWQVpVQmxRR1ZBWlVCbFFHVkFaVUJsUUdWQVpVQmxRR1ZBWlVCbFFHVkFaVUJsUUdWQVpVQmxRR1ZBWlVCbFFHVkFaVUJsUUdWQVpVQmxRR1ZBWlVCbFFHVkFaVUJsUUdWQVpVQmxRR1ZBWlVCbFFHVkFaVUJsUUdWQVpVQmxRR1ZBWlVCbFFHVkFaVUJsUUdWQVpVQmxRR1ZBWlVCbFFHVkFaVUJsUUdWQVpVQmxRR1ZBWlVCbFFHVkFaVUJsUUdWQVpVQmxRR1ZBWlVCbFFHVkFaVUJsUUdWQVpVQmxRR1ZBWlVCbFFHVkFaVUJsUUdWQVpVQmxRR1ZBWlVCbFFHVkFaVUJsUUdWQVpVQmxRR1ZBWlVCbFFHVkFaVUJsUUdWQVpVQmxRR1ZBWlVCbFFHVkFaVUJsUUdWQVpVQmxRR1ZBWlVCbFFHVkFaVUJsUUdWQVpVQmxRR1ZBZkFLQUF1WkE2NEF0d0NKQUxvQzZBRHdBQWdBdUFDZ0Evb0VwZ082QXFzRCtBQUlBQWdBc3dNSUFBZ0FDQUFJQUlrQXV3UDVBZnNCd3dQTEF3Z0FDQUFJQUFnQUNBRFJBOWtEQ0FBSUFPRUQ2UU1JQUFnQUNBQUlBQWdBQ0FEdUEvWURDQUFJQVA0RHlRQUlBQWdBQmdRSUFBZ0FYUUFPQkFnQUNBQUlBQWdBQ0FBSUFCTUVDQUFJQUFnQUNBQUlBQWdBQ0FEOEFBUUJDQUFJQUFnQUdnUWlCQ29FQ0FFeEJBZ0FFQUVJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQTRCQWdBQ0FCQUJFWUVDQUFJQUFnQVRBUVlBUWdBVkFRSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFGb0VDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBT1FFSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FCK0JBY0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFFQUJoZ1NNQkFnQUNBQUlBQWdBbEFRSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBd0FFQUFRQUJBQURBQU1BQXdBREFBUUFCQUFFQUFRQUJBQUVBQVFBQkhBVEFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQWRRTUlBQWdBQ0FBSUFBZ0FDQUFJQU1rQUNBQUlBQWdBZlFNSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FDRkE0a0RDQUFJQUFnQUNBQUlBT2NCQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBSWNEQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFKRURDQUFJQUFnQUNBREZBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUJnQkFnQVpnUUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FiQVFDQlhJRUNBQUlBSGtFQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQkFBSndFUUFDakJLb0VzZ1FJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FDNkJNSUVDQUFJQUFnQUNBQUlBQWdBQ0FCbUJBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQXh3UUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFHWUVDQUFJQUFnQXpnUUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQWlnV0tCWW9GaWdXS0JZb0ZpZ1dLQmQwRlh3VUlBT0lGNmdYeEJZb0YzZ1Q1QlFBR0NBYUtCWW9GaWdXS0JZb0ZpZ1dLQllvRmlnV0tCWW9GaWdYV0JJb0ZpZ1dLQllvRmlnV0tCWW9GaWdXS0JZc0ZFQWFLQllvRmlnV0tCWW9GaWdXS0JSUUdDQUNLQllvRmlnV0tCUWdBQ0FBSUFORUVDQUFJQUJnR2lnVWdCZ2dBSmdZSUFDNEdNd2FLQllvRjB3UTNCajRHaWdXS0JZb0ZpZ1dLQllvRmlnV0tCWW9GaWdXS0JZb0ZpZ1VJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FpZ1dLQllvRmlnV0tCWW9GaWdXS0JZb0ZpZ1dLQllvRmlnV0tCWW9GaWdXS0JZb0ZpZ1dLQllvRmlnV0tCWW9GaWdXS0JZb0ZpZ1dLQllvRmlnV0xCZi8vLy8vLy93UUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFBd0FFQUFRQUFnQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBT0FBQUFBQUFBQUFRQURnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVVBQlFBRkFBVUFCUUFGQUFVQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUFBQVVBQUFBRkFBVUFBQUFGQUFVQUFBQUZBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQkFBRUFBUUFCQUFFQUFRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBQUFBUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFVQUJRQUZBQVVBQlFBRkFBVUFBUUFBQUFVQUJRQUZBQVVBQlFBRkFBQUFBQUFGQUFVQUFBQUZBQVVBQlFBRkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFFQUFBQUZBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUZBQUFBQUFBRkFBVUFBUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJ3QUZBQVVBQlFBRkFBQUFCd0FIQUFjQUFBQUhBQWNBQndBRkFBRUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBVUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBSEFBY0FCd0FGQUFVQUJRQUZBQWNBQndBRkFBVUFBQUFBQUFFQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFIQUFBQUFRQUJBQUFBQUFBQUFBQUFBQUFGQUFVQUJRQUZBQUFBQndBRkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlFBSEFBY0FCd0FIQUFjQUFBQUhBQWNBQUFBQUFBVUFCUUFIQUFVQUFRQUhBQUVBQndBRkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJRQUZBQVVBQlFBRkFBVUFCd0FCQUFVQUJRQUZBQVVBQUFBQUFBQUFBQUFBQUFFQUFRQUJBQUVBQVFBQkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJ3QUZBQVVBQUFBQUFBQUFBQUFBQUFBQUJRQUZBQVVBQlFBRkFBVUFBUUFGQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFVQUJRQUZBQVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBUUFCUUFOQUFRQUJBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFRQUJBQUVBQVFBQkFBRUFBUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQU9BQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlFBSEFBVUFCUUFGQUFBQUFBQUFBQWNBQlFBRkFBVUFCUUFGQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFVQUJRQUZBQVVBQUFBRkFBVUFCUUFGQUFVQUFBQUZBQVVBQlFBQUFBVUFCUUFGQUFVQUJRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUZBQVVBQlFBQUFBQUFBQUFBQUFVQUJRQUZBQWNBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUUFIQUFVQUFBQUhBQWNBQndBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQndBSEFBY0FCd0FGQUFjQUJ3QUFBQVVBQlFBRkFBVUFCUUFGQUFVQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUZBQVVBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBVUFCd0FIQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJRQUFBQVVBQndBSEFBVUFCUUFGQUFVQUFBQUFBQWNBQndBQUFBQUFCd0FIQUFVQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVVBQlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlFBQUFBQUFCUUFGQUFjQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUZBQUFBQndBSEFBY0FCUUFGQUFBQUFBQUFBQUFBQlFBRkFBQUFBQUFGQUFVQUJRQUFBQUFBQUFBRkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBVUFCUUFBQUFBQUFBQUZBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQndBRkFBVUFCUUFGQUFVQUFBQUZBQVVBQndBQUFBY0FCd0FGQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUZBQVVBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFGQUFVQUJRQUZBQVVBQlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBVUFBQUFGQUFVQUJ3QUZBQVVBQlFBRkFBQUFBQUFIQUFjQUFBQUFBQWNBQndBRkFBQUFBQUFBQUFBQUFBQUFBQUFBQlFBRkFBVUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFGQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUZBQWNBQndBQUFBQUFBQUFIQUFjQUJ3QUFBQWNBQndBSEFBVUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUUFIQUFjQUJ3QUZBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVVBQndBSEFBY0FCd0FBQUFVQUJRQUZBQUFBQlFBRkFBVUFCUUFBQUFBQUFBQUFBQUFBQUFBQUFBVUFCUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJRQUFBQWNBQlFBSEFBY0FCUUFIQUFjQUFBQUZBQWNBQndBQUFBY0FCd0FGQUFVQUFBQUFBQUFBQUFBQUFBQUFBQUFGQUFVQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJRQUZBQWNBQndBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFVQUJRQUFBQVVBQndBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBVUFBQUFBQUFBQUFBQUZBQWNBQndBRkFBVUFCUUFBQUFVQUFBQUhBQWNBQndBSEFBY0FCd0FIQUFVQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFVQUFBQUhBQVVBQlFBRkFBVUFCUUFGQUFVQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFGQUFBQUJ3QUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlFBRkFBVUFCUUFGQUFVQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFVQUJRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUUFBQUFVQUFBQUZBQUFBQUFBQUFBQUFCd0FIQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQndBRkFBVUFCUUFGQUFVQUFBQUZBQVVBQUFBQUFBQUFBQUFBQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUFBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBVUFCUUFGQUFVQUJ3QUZBQVVBQlFBRkFBVUFCUUFBQUFVQUJRQUhBQWNBQlFBRkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUhBQWNBQlFBRkFBQUFBQUFBQUFBQUJRQUZBQVVBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUZBQVVBQlFBRkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJRQUFBQWNBQlFBRkFBQUFBQUFBQUFBQUFBQUFBQVVBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlFBRkFBVUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVVBQlFBSEFBVUFCUUFGQUFVQUJRQUZBQVVBQndBSEFBY0FCd0FIQUFjQUJ3QUhBQVVBQndBSEFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFGQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlFBRkFBVUFCd0FIQUFjQUJ3QUZBQVVBQndBSEFBY0FBQUFBQUFBQUFBQUhBQWNBQlFBSEFBY0FCd0FIQUFjQUJ3QUZBQVVBQlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJRQUZBQWNBQndBRkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFjQUJRQUhBQVVBQlFBRkFBVUFCUUFGQUFVQUFBQUZBQUFBQlFBQUFBQUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBY0FCd0FIQUFjQUJ3QUhBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQUFBQUFBVUFCUUFGQUFVQUJRQUhBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVVBQlFBRkFBVUFCUUFGQUFVQUJ3QUZBQWNBQndBSEFBY0FCd0FGQUFjQUJ3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFGQUFVQUJ3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBSEFBVUFCUUFGQUFVQUJ3QUhBQVVBQlFBSEFBVUFCUUFGQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUZBQWNBQlFBRkFBY0FCd0FIQUFVQUJ3QUZBQVVBQlFBSEFBY0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJ3QUhBQWNBQndBSEFBY0FCd0FIQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFIQUFjQUJRQUZBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJRQUZBQVVBQUFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFjQUJRQUZBQVVBQlFBRkFBVUFCUUFBQUFBQUFBQUFBQVVBQUFBQUFBQUFBQUFBQUFBQUJRQUFBQUFBQndBRkFBVUFBQUFBQUFBQUFBQUFBQUFBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQUFBQlFBRkFBVUFCUUFGQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBVUFCUUFGQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUUFGQUFVQUJRQUZBQVVBRGdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFPQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFVQUJRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFVQUJRQUZBQVVBQUFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBQUFBQUFBQUFBQUJRQUFBQUFBQUFBRkFBQUFBQUFBQUFBQUJRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCd0FIQUFVQUJRQUhBQUFBQUFBQUFBQUFCUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFjQUJ3QUhBQWNBQlFBRkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFVQUFBQUFBQUFBQUFBQUFBQUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUhBQWNBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRkFBY0FCd0FGQUFVQUJRQUZBQWNBQndBRkFBVUFCd0FIQUFBQUFBQUFBQUFBQUFBRkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBVUFCUUFGQUFVQUJRQUZBQWNBQndBRkFBVUFCd0FIQUFVQUJRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRkFBY0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVVBQUFBRkFBVUFCUUFBQUFBQUJRQUZBQUFBQUFBQUFBQUFBQUFGQUFVQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQWNBQlFBRkFBY0FCd0FBQUFBQUFBQUFBQUFBQndBRkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFjQUJ3QUZBQWNBQndBRkFBY0FCd0FBQUFjQUJRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUZBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFVQUJRQUZBQVVBQlFBQUFBQUFBQUFBQUFBQUFBQUZBQVVBQlFBQUFBVUFCUUFBQUFBQUFBQUFBQUFBQlFBRkFBVUFCUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRkFBVUFCUUFBQUFBQUFBQUFBQVVBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBVUFCUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFjQUJRQUhBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFGQUFVQUJRQUZBQVVBQndBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFGQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJ3QUhBQWNBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQndBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFIQUFjQUJ3QUZBQVVBQlFBSEFBY0FCUUFIQUFVQUJRQUFBQUFBQUFBQUFBQUFBQUFGQUFBQUJ3QUhBQWNBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBVUFCd0FIQUFjQUJ3QUFBQUFBQndBSEFBQUFBQUFIQUFjQUJ3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUZBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQndBSEFBQUFBQUFGQUFVQUJRQUZBQVVBQlFBRkFBQUFBQUFBQUFVQUJRQUZBQVVBQlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUhBQWNBQndBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQndBSEFBVUFCUUFGQUFjQUJRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUUFIQUFjQUJRQUZBQVVBQlFBRkFBVUFCd0FGQUFjQUJ3QUZBQWNBQlFBRkFBY0FCUUFGQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlFBSEFBY0FCUUFGQUFVQUJRQUFBQUFBQndBSEFBY0FCd0FGQUFVQUJ3QUZBQVVBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlFBRkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBY0FCd0FIQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFIQUFjQUJRQUhBQVVBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBVUFCd0FGQUFjQUJ3QUZBQVVBQlFBRkFBVUFCUUFIQUFVQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFjQUJ3QUZBQVVBQlFBRkFBY0FCUUFGQUFVQUJRQUZBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBSEFBY0FCd0FGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFIQUFVQUJRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUhBQWNBQndBRkFBVUFCUUFGQUFBQUFBQUZBQVVBQndBSEFBY0FCd0FGQUFBQUFBQUFBQWNBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVVBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlFBRkFBVUFCUUFGQUFVQUJ3QUhBQVVBQlFBRkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQWNBQlFBRkFBVUFCUUFGQUFVQUJRQUFBQVVBQlFBRkFBVUFCUUFGQUFjQUJRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFBQUFIQUFVQUJRQUZBQVVBQlFBRkFBVUFCd0FGQUFVQUJ3QUZBQVVBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlFBRkFBVUFCUUFGQUFVQUFBQUFBQUFBQlFBQUFBVUFCUUFBQUFVQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUhBQWNBQndBSEFBY0FBQUFGQUFVQUFBQUhBQWNBQlFBSEFBVUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFGQUFVQUJ3QUhBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUZBQVVBQlFBRkFBVUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFGQUFVQUJRQUZBQVVBQlFBRkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlFBQUFBY0FCd0FIQUFjQUJ3QUhBQWNBQndBSEFBY0FCd0FIQUFjQUJ3QUhBQUFBQUFBQUFBQUFBQUFBQUFBQUJRQUZBQVVBQlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFVQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQWNBQndBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFVQUJRQUFBQVVBQlFBRkFBQUFBQUFGQUFVQUJRQUZBQVVBQlFBRkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJRQUZBQVVBQlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUUFGQUFVQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBQUFBQUFBQUFBQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVVBQlFBRkFBVUFCUUFBQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlFBRkFBVUFCUUFGQUFVQUJRQUFBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUFBQUFBQlFBRkFBVUFCUUFGQUFVQUJRQUFBQVVBQlFBQUFBVUFCUUFGQUFVQUJRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRkFBVUFCUUFGQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUUFGQUFVQUJRQUZBQVVBQlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFPQUE0QURnQU9BQTRBRGdBT0FBNEFEZ0FPQUE0QURnQU9BQTRBRGdBT0FBNEFEZ0FPQUE0QURnQU9BQTRBRGdBT0FBNEFEZ0FGQUFVQUJRQUZBQVVBRGdBT0FBNEFEZ0FPQUE0QUR3QVBBQThBRHdBUEFBOEFEd0FQQUE4QUR3QVBBQThBRHdBUEFBOEFEd0FQQUE4QUR3QVBBQThBRHdBUEFBOEFEd0FQQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFjQUJ3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQndBSEFBY0FCd0FIQUFjQUJ3QUhBQWNBQndBSEFBY0FCd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQndBSEFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQndBSEFBY0FCd0FIQUFjQUJ3QUhBQWNBQndBSEFBY0FCd0FIQUFjQUJ3QUhBQWNBQndBSEFBY0FCd0FIQUFjQUJ3QUhBQWNBQndBSEFBY0FCd0FIQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBQUFBQUFBQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBS0FBb0FDZ0FLQUFvQUNnQUtBQW9BQ2dBS0FBb0FDZ0FLQUFvQUNnQUtBQW9BQ2dBS0FBb0FDZ0FLQUFvQUNnQU1BQXdBREFBTUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUFBQUFBQUFBQUFBS0FBb0FDZ0FLQUFvQUNnQUtBQW9BQ2dBS0FBb0FDZ0FLQUFvQUNnQUtBQW9BQ2dBS0FBb0FDZ0FLQUFvQUNnQUtBQW9BQ2dBS0FBb0FDZ0FLQUFvQUNnQUFBQUFBQUFBQUFBc0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FDd0FNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFBQUFBQURnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBNEFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQU9BQTRBRGdBT0FBNEFEZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQURnQU9BQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQTRBRGdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRGdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRGdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRGdBT0FBNEFEZ0FPQUE0QURnQU9BQTRBRGdBT0FBQUFBQUFBQUFBQURnQU9BQTRBQUFBQUFBQUFBQUFBQUFBQUFBQU9BQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFEZ0FPQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQURnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQU9BQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQURnQU9BQTRBRGdBQUFBNEFEZ0FPQUE0QURnQU9BQUFBRGdBT0FBNEFEZ0FPQUE0QURnQU9BQTRBRGdBT0FBNEFBQUFPQUE0QURnQU9BQTRBRGdBT0FBNEFEZ0FPQUE0QURnQU9BQTRBRGdBT0FBNEFEZ0FPQUE0QURnQU9BQTRBRGdBT0FBNEFEZ0FPQUE0QURnQU9BQTRBRGdBT0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFEZ0FPQUE0QURnQU9BQTRBRGdBT0FBNEFEZ0FPQUE0QURnQU9BQTRBRGdBT0FBNEFBQUFBQUE0QURnQU9BQTRBRGdBT0FBNEFEZ0FPQUE0QURnQUFBQTRBQUFBT0FBQUFBQUFBQUFBQUFBQUFBQTRBQUFBQUFBQUFBQUFBQUFBQURnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQTRBRGdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFEZ0FBQUFBQURnQUFBQUFBQUFBQUFBNEFBQUFPQUFBQUFBQUFBQUFBRGdBT0FBNEFBQUFPQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQU9BQTRBRGdBT0FBNEFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBT0FBNEFEZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFPQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBT0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQU9BQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBT0FBNEFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUE0QURnQU9BQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRGdBT0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFEZ0FBQUFBQUFBQUFBQTRBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQU9BQUFBRGdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQU9BQTRBRGdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQTRBRGdBT0FBNEFEZ0FPQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQTRBRGdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQURnQUFBQUFBRGdBT0FBNEFEZ0FPQUE0QURnQU9BQTRBRGdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQURnQU9BQTRBRGdBT0FBNEFEZ0FPQUE0QURnQU9BQTRBRGdBT0FBNEFEZ0FPQUE0QURnQUFBQTRBRGdBT0FBNEFEZ0FPQUE0QURnQU9BQTRBRGdBT0FBNEFEZ0FPQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQURnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUE0QUFBQUFBQTRBRGdBT0FBNEFEZ0FPQUE0QURnQU9BQUFBRGdBT0FBNEFEZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFPQUE0QURnQU9BQTRBRGdBT0FBNEFEZ0FPQUE0QURnQU9BQTRBRGdBT0FBNEFEZ0FPQUE0QURnQU9BQTRBQUFBQUFBQUFBQUFBQUFBQURnQU9BQTRBRGdBT0FBNEFEZ0FPQUE0QURnQU9BQTRBRGdBT0FBNEFEZ0FPQUE0QURnQU9BQTRBRGdBT0FBNEFEZ0FPQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQTRBRGdBT0FBNEFEZ0FPQUE0QURnQU9BQTRBRGdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFPQUE0QURnQU9BQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQURnQU9BQTRBRGdBT0FBNEFEZ0FPQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQURnQU9BQTRBRGdBT0FBNEFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBNEFEZ0FPQUE0QURnQU9BQTRBRGdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBT0FBNEFEZ0FPQUE0QURnQU9BQTRBRGdBT0FBNEFEZ0FPQUE0QURnQU9BQTRBRGdBT0FBNEFEZ0FPQUE0QURnQU9BQTRBRGdBT0FBNEFBQUFPQUE0QURnQU9BQTRBRGdBQUFBNEFEZ0FPQUE0QURnQU9BQTRBRGdBT0FBNEFEZ0FPQUE0QURnQU9BQTRBRGdBT0FBNEFEZ0FPQUE0QURnQU9BQTRBQUFBQUFBQUFBQUE9JztcblxuICAgIC8qXG4gICAgICogdXRyaWUgMS4wLjIgPGh0dHBzOi8vZ2l0aHViLmNvbS9uaWtsYXN2aC91dHJpZT5cbiAgICAgKiBDb3B5cmlnaHQgKGMpIDIwMjIgTmlrbGFzIHZvbiBIZXJ0emVuIDxodHRwczovL2hlcnR6ZW4uY29tPlxuICAgICAqIFJlbGVhc2VkIHVuZGVyIE1JVCBMaWNlbnNlXG4gICAgICovXG4gICAgdmFyIGNoYXJzJDEgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyc7XG4gICAgLy8gVXNlIGEgbG9va3VwIHRhYmxlIHRvIGZpbmQgdGhlIGluZGV4LlxuICAgIHZhciBsb29rdXAkMSA9IHR5cGVvZiBVaW50OEFycmF5ID09PSAndW5kZWZpbmVkJyA/IFtdIDogbmV3IFVpbnQ4QXJyYXkoMjU2KTtcbiAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjaGFycyQxLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgbG9va3VwJDFbY2hhcnMkMS5jaGFyQ29kZUF0KGkkMSldID0gaSQxO1xuICAgIH1cbiAgICB2YXIgZGVjb2RlID0gZnVuY3Rpb24gKGJhc2U2NCkge1xuICAgICAgICB2YXIgYnVmZmVyTGVuZ3RoID0gYmFzZTY0Lmxlbmd0aCAqIDAuNzUsIGxlbiA9IGJhc2U2NC5sZW5ndGgsIGksIHAgPSAwLCBlbmNvZGVkMSwgZW5jb2RlZDIsIGVuY29kZWQzLCBlbmNvZGVkNDtcbiAgICAgICAgaWYgKGJhc2U2NFtiYXNlNjQubGVuZ3RoIC0gMV0gPT09ICc9Jykge1xuICAgICAgICAgICAgYnVmZmVyTGVuZ3RoLS07XG4gICAgICAgICAgICBpZiAoYmFzZTY0W2Jhc2U2NC5sZW5ndGggLSAyXSA9PT0gJz0nKSB7XG4gICAgICAgICAgICAgICAgYnVmZmVyTGVuZ3RoLS07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJ1ZmZlciA9IHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgIHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNsaWNlICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgPyBuZXcgQXJyYXlCdWZmZXIoYnVmZmVyTGVuZ3RoKVxuICAgICAgICAgICAgOiBuZXcgQXJyYXkoYnVmZmVyTGVuZ3RoKTtcbiAgICAgICAgdmFyIGJ5dGVzID0gQXJyYXkuaXNBcnJheShidWZmZXIpID8gYnVmZmVyIDogbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgICAgICAgICBlbmNvZGVkMSA9IGxvb2t1cCQxW2Jhc2U2NC5jaGFyQ29kZUF0KGkpXTtcbiAgICAgICAgICAgIGVuY29kZWQyID0gbG9va3VwJDFbYmFzZTY0LmNoYXJDb2RlQXQoaSArIDEpXTtcbiAgICAgICAgICAgIGVuY29kZWQzID0gbG9va3VwJDFbYmFzZTY0LmNoYXJDb2RlQXQoaSArIDIpXTtcbiAgICAgICAgICAgIGVuY29kZWQ0ID0gbG9va3VwJDFbYmFzZTY0LmNoYXJDb2RlQXQoaSArIDMpXTtcbiAgICAgICAgICAgIGJ5dGVzW3ArK10gPSAoZW5jb2RlZDEgPDwgMikgfCAoZW5jb2RlZDIgPj4gNCk7XG4gICAgICAgICAgICBieXRlc1twKytdID0gKChlbmNvZGVkMiAmIDE1KSA8PCA0KSB8IChlbmNvZGVkMyA+PiAyKTtcbiAgICAgICAgICAgIGJ5dGVzW3ArK10gPSAoKGVuY29kZWQzICYgMykgPDwgNikgfCAoZW5jb2RlZDQgJiA2Myk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICB9O1xuICAgIHZhciBwb2x5VWludDE2QXJyYXkgPSBmdW5jdGlvbiAoYnVmZmVyKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBidWZmZXIubGVuZ3RoO1xuICAgICAgICB2YXIgYnl0ZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgYnl0ZXMucHVzaCgoYnVmZmVyW2kgKyAxXSA8PCA4KSB8IGJ1ZmZlcltpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIH07XG4gICAgdmFyIHBvbHlVaW50MzJBcnJheSA9IGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGJ1ZmZlci5sZW5ndGg7XG4gICAgICAgIHZhciBieXRlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSA0KSB7XG4gICAgICAgICAgICBieXRlcy5wdXNoKChidWZmZXJbaSArIDNdIDw8IDI0KSB8IChidWZmZXJbaSArIDJdIDw8IDE2KSB8IChidWZmZXJbaSArIDFdIDw8IDgpIHwgYnVmZmVyW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnl0ZXM7XG4gICAgfTtcblxuICAgIC8qKiBTaGlmdCBzaXplIGZvciBnZXR0aW5nIHRoZSBpbmRleC0yIHRhYmxlIG9mZnNldC4gKi9cbiAgICB2YXIgVVRSSUUyX1NISUZUXzIgPSA1O1xuICAgIC8qKiBTaGlmdCBzaXplIGZvciBnZXR0aW5nIHRoZSBpbmRleC0xIHRhYmxlIG9mZnNldC4gKi9cbiAgICB2YXIgVVRSSUUyX1NISUZUXzEgPSA2ICsgNTtcbiAgICAvKipcbiAgICAgKiBTaGlmdCBzaXplIGZvciBzaGlmdGluZyBsZWZ0IHRoZSBpbmRleCBhcnJheSB2YWx1ZXMuXG4gICAgICogSW5jcmVhc2VzIHBvc3NpYmxlIGRhdGEgc2l6ZSB3aXRoIDE2LWJpdCBpbmRleCB2YWx1ZXMgYXQgdGhlIGNvc3RcbiAgICAgKiBvZiBjb21wYWN0YWJpbGl0eS5cbiAgICAgKiBUaGlzIHJlcXVpcmVzIGRhdGEgYmxvY2tzIHRvIGJlIGFsaWduZWQgYnkgVVRSSUUyX0RBVEFfR1JBTlVMQVJJVFkuXG4gICAgICovXG4gICAgdmFyIFVUUklFMl9JTkRFWF9TSElGVCA9IDI7XG4gICAgLyoqXG4gICAgICogRGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSB0d28gc2hpZnQgc2l6ZXMsXG4gICAgICogZm9yIGdldHRpbmcgYW4gaW5kZXgtMSBvZmZzZXQgZnJvbSBhbiBpbmRleC0yIG9mZnNldC4gNj0xMS01XG4gICAgICovXG4gICAgdmFyIFVUUklFMl9TSElGVF8xXzIgPSBVVFJJRTJfU0hJRlRfMSAtIFVUUklFMl9TSElGVF8yO1xuICAgIC8qKlxuICAgICAqIFRoZSBwYXJ0IG9mIHRoZSBpbmRleC0yIHRhYmxlIGZvciBVK0Q4MDAuLlUrREJGRiBzdG9yZXMgdmFsdWVzIGZvclxuICAgICAqIGxlYWQgc3Vycm9nYXRlIGNvZGUgX3VuaXRzXyBub3QgY29kZSBfcG9pbnRzXy5cbiAgICAgKiBWYWx1ZXMgZm9yIGxlYWQgc3Vycm9nYXRlIGNvZGUgX3BvaW50c18gYXJlIGluZGV4ZWQgd2l0aCB0aGlzIHBvcnRpb24gb2YgdGhlIHRhYmxlLlxuICAgICAqIExlbmd0aD0zMj0weDIwPTB4NDAwPj5VVFJJRTJfU0hJRlRfMi4gKFRoZXJlIGFyZSAxMDI0PTB4NDAwIGxlYWQgc3Vycm9nYXRlcy4pXG4gICAgICovXG4gICAgdmFyIFVUUklFMl9MU0NQX0lOREVYXzJfT0ZGU0VUID0gMHgxMDAwMCA+PiBVVFJJRTJfU0hJRlRfMjtcbiAgICAvKiogTnVtYmVyIG9mIGVudHJpZXMgaW4gYSBkYXRhIGJsb2NrLiAzMj0weDIwICovXG4gICAgdmFyIFVUUklFMl9EQVRBX0JMT0NLX0xFTkdUSCA9IDEgPDwgVVRSSUUyX1NISUZUXzI7XG4gICAgLyoqIE1hc2sgZm9yIGdldHRpbmcgdGhlIGxvd2VyIGJpdHMgZm9yIHRoZSBpbi1kYXRhLWJsb2NrIG9mZnNldC4gKi9cbiAgICB2YXIgVVRSSUUyX0RBVEFfTUFTSyA9IFVUUklFMl9EQVRBX0JMT0NLX0xFTkdUSCAtIDE7XG4gICAgdmFyIFVUUklFMl9MU0NQX0lOREVYXzJfTEVOR1RIID0gMHg0MDAgPj4gVVRSSUUyX1NISUZUXzI7XG4gICAgLyoqIENvdW50IHRoZSBsZW5ndGhzIG9mIGJvdGggQk1QIHBpZWNlcy4gMjA4MD0weDgyMCAqL1xuICAgIHZhciBVVFJJRTJfSU5ERVhfMl9CTVBfTEVOR1RIID0gVVRSSUUyX0xTQ1BfSU5ERVhfMl9PRkZTRVQgKyBVVFJJRTJfTFNDUF9JTkRFWF8yX0xFTkdUSDtcbiAgICAvKipcbiAgICAgKiBUaGUgMi1ieXRlIFVURi04IHZlcnNpb24gb2YgdGhlIGluZGV4LTIgdGFibGUgZm9sbG93cyBhdCBvZmZzZXQgMjA4MD0weDgyMC5cbiAgICAgKiBMZW5ndGggMzI9MHgyMCBmb3IgbGVhZCBieXRlcyBDMC4uREYsIHJlZ2FyZGxlc3Mgb2YgVVRSSUUyX1NISUZUXzIuXG4gICAgICovXG4gICAgdmFyIFVUUklFMl9VVEY4XzJCX0lOREVYXzJfT0ZGU0VUID0gVVRSSUUyX0lOREVYXzJfQk1QX0xFTkdUSDtcbiAgICB2YXIgVVRSSUUyX1VURjhfMkJfSU5ERVhfMl9MRU5HVEggPSAweDgwMCA+PiA2OyAvKiBVKzA4MDAgaXMgdGhlIGZpcnN0IGNvZGUgcG9pbnQgYWZ0ZXIgMi1ieXRlIFVURi04ICovXG4gICAgLyoqXG4gICAgICogVGhlIGluZGV4LTEgdGFibGUsIG9ubHkgdXNlZCBmb3Igc3VwcGxlbWVudGFyeSBjb2RlIHBvaW50cywgYXQgb2Zmc2V0IDIxMTI9MHg4NDAuXG4gICAgICogVmFyaWFibGUgbGVuZ3RoLCBmb3IgY29kZSBwb2ludHMgdXAgdG8gaGlnaFN0YXJ0LCB3aGVyZSB0aGUgbGFzdCBzaW5nbGUtdmFsdWUgcmFuZ2Ugc3RhcnRzLlxuICAgICAqIE1heGltdW0gbGVuZ3RoIDUxMj0weDIwMD0weDEwMDAwMD4+VVRSSUUyX1NISUZUXzEuXG4gICAgICogKEZvciAweDEwMDAwMCBzdXBwbGVtZW50YXJ5IGNvZGUgcG9pbnRzIFUrMTAwMDAuLlUrMTBmZmZmLilcbiAgICAgKlxuICAgICAqIFRoZSBwYXJ0IG9mIHRoZSBpbmRleC0yIHRhYmxlIGZvciBzdXBwbGVtZW50YXJ5IGNvZGUgcG9pbnRzIHN0YXJ0c1xuICAgICAqIGFmdGVyIHRoaXMgaW5kZXgtMSB0YWJsZS5cbiAgICAgKlxuICAgICAqIEJvdGggdGhlIGluZGV4LTEgdGFibGUgYW5kIHRoZSBmb2xsb3dpbmcgcGFydCBvZiB0aGUgaW5kZXgtMiB0YWJsZVxuICAgICAqIGFyZSBvbWl0dGVkIGNvbXBsZXRlbHkgaWYgdGhlcmUgaXMgb25seSBCTVAgZGF0YS5cbiAgICAgKi9cbiAgICB2YXIgVVRSSUUyX0lOREVYXzFfT0ZGU0VUID0gVVRSSUUyX1VURjhfMkJfSU5ERVhfMl9PRkZTRVQgKyBVVFJJRTJfVVRGOF8yQl9JTkRFWF8yX0xFTkdUSDtcbiAgICAvKipcbiAgICAgKiBOdW1iZXIgb2YgaW5kZXgtMSBlbnRyaWVzIGZvciB0aGUgQk1QLiAzMj0weDIwXG4gICAgICogVGhpcyBwYXJ0IG9mIHRoZSBpbmRleC0xIHRhYmxlIGlzIG9taXR0ZWQgZnJvbSB0aGUgc2VyaWFsaXplZCBmb3JtLlxuICAgICAqL1xuICAgIHZhciBVVFJJRTJfT01JVFRFRF9CTVBfSU5ERVhfMV9MRU5HVEggPSAweDEwMDAwID4+IFVUUklFMl9TSElGVF8xO1xuICAgIC8qKiBOdW1iZXIgb2YgZW50cmllcyBpbiBhbiBpbmRleC0yIGJsb2NrLiA2ND0weDQwICovXG4gICAgdmFyIFVUUklFMl9JTkRFWF8yX0JMT0NLX0xFTkdUSCA9IDEgPDwgVVRSSUUyX1NISUZUXzFfMjtcbiAgICAvKiogTWFzayBmb3IgZ2V0dGluZyB0aGUgbG93ZXIgYml0cyBmb3IgdGhlIGluLWluZGV4LTItYmxvY2sgb2Zmc2V0LiAqL1xuICAgIHZhciBVVFJJRTJfSU5ERVhfMl9NQVNLID0gVVRSSUUyX0lOREVYXzJfQkxPQ0tfTEVOR1RIIC0gMTtcbiAgICB2YXIgc2xpY2UxNiA9IGZ1bmN0aW9uICh2aWV3LCBzdGFydCwgZW5kKSB7XG4gICAgICAgIGlmICh2aWV3LnNsaWNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmlldy5zbGljZShzdGFydCwgZW5kKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFVpbnQxNkFycmF5KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHZpZXcsIHN0YXJ0LCBlbmQpKTtcbiAgICB9O1xuICAgIHZhciBzbGljZTMyID0gZnVuY3Rpb24gKHZpZXcsIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgaWYgKHZpZXcuc2xpY2UpIHtcbiAgICAgICAgICAgIHJldHVybiB2aWV3LnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVWludDMyQXJyYXkoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodmlldywgc3RhcnQsIGVuZCkpO1xuICAgIH07XG4gICAgdmFyIGNyZWF0ZVRyaWVGcm9tQmFzZTY0ID0gZnVuY3Rpb24gKGJhc2U2NCwgX2J5dGVMZW5ndGgpIHtcbiAgICAgICAgdmFyIGJ1ZmZlciA9IGRlY29kZShiYXNlNjQpO1xuICAgICAgICB2YXIgdmlldzMyID0gQXJyYXkuaXNBcnJheShidWZmZXIpID8gcG9seVVpbnQzMkFycmF5KGJ1ZmZlcikgOiBuZXcgVWludDMyQXJyYXkoYnVmZmVyKTtcbiAgICAgICAgdmFyIHZpZXcxNiA9IEFycmF5LmlzQXJyYXkoYnVmZmVyKSA/IHBvbHlVaW50MTZBcnJheShidWZmZXIpIDogbmV3IFVpbnQxNkFycmF5KGJ1ZmZlcik7XG4gICAgICAgIHZhciBoZWFkZXJMZW5ndGggPSAyNDtcbiAgICAgICAgdmFyIGluZGV4ID0gc2xpY2UxNih2aWV3MTYsIGhlYWRlckxlbmd0aCAvIDIsIHZpZXczMls0XSAvIDIpO1xuICAgICAgICB2YXIgZGF0YSA9IHZpZXczMls1XSA9PT0gMlxuICAgICAgICAgICAgPyBzbGljZTE2KHZpZXcxNiwgKGhlYWRlckxlbmd0aCArIHZpZXczMls0XSkgLyAyKVxuICAgICAgICAgICAgOiBzbGljZTMyKHZpZXczMiwgTWF0aC5jZWlsKChoZWFkZXJMZW5ndGggKyB2aWV3MzJbNF0pIC8gNCkpO1xuICAgICAgICByZXR1cm4gbmV3IFRyaWUodmlldzMyWzBdLCB2aWV3MzJbMV0sIHZpZXczMlsyXSwgdmlldzMyWzNdLCBpbmRleCwgZGF0YSk7XG4gICAgfTtcbiAgICB2YXIgVHJpZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gVHJpZShpbml0aWFsVmFsdWUsIGVycm9yVmFsdWUsIGhpZ2hTdGFydCwgaGlnaFZhbHVlSW5kZXgsIGluZGV4LCBkYXRhKSB7XG4gICAgICAgICAgICB0aGlzLmluaXRpYWxWYWx1ZSA9IGluaXRpYWxWYWx1ZTtcbiAgICAgICAgICAgIHRoaXMuZXJyb3JWYWx1ZSA9IGVycm9yVmFsdWU7XG4gICAgICAgICAgICB0aGlzLmhpZ2hTdGFydCA9IGhpZ2hTdGFydDtcbiAgICAgICAgICAgIHRoaXMuaGlnaFZhbHVlSW5kZXggPSBoaWdoVmFsdWVJbmRleDtcbiAgICAgICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgdmFsdWUgZm9yIGEgY29kZSBwb2ludCBhcyBzdG9yZWQgaW4gdGhlIFRyaWUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBjb2RlUG9pbnQgdGhlIGNvZGUgcG9pbnRcbiAgICAgICAgICogQHJldHVybiB0aGUgdmFsdWVcbiAgICAgICAgICovXG4gICAgICAgIFRyaWUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChjb2RlUG9pbnQpIHtcbiAgICAgICAgICAgIHZhciBpeDtcbiAgICAgICAgICAgIGlmIChjb2RlUG9pbnQgPj0gMCkge1xuICAgICAgICAgICAgICAgIGlmIChjb2RlUG9pbnQgPCAweDBkODAwIHx8IChjb2RlUG9pbnQgPiAweDBkYmZmICYmIGNvZGVQb2ludCA8PSAweDBmZmZmKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBPcmRpbmFyeSBCTVAgY29kZSBwb2ludCwgZXhjbHVkaW5nIGxlYWRpbmcgc3Vycm9nYXRlcy5cbiAgICAgICAgICAgICAgICAgICAgLy8gQk1QIHVzZXMgYSBzaW5nbGUgbGV2ZWwgbG9va3VwLiAgQk1QIGluZGV4IHN0YXJ0cyBhdCBvZmZzZXQgMCBpbiB0aGUgVHJpZTIgaW5kZXguXG4gICAgICAgICAgICAgICAgICAgIC8vIDE2IGJpdCBkYXRhIGlzIHN0b3JlZCBpbiB0aGUgaW5kZXggYXJyYXkgaXRzZWxmLlxuICAgICAgICAgICAgICAgICAgICBpeCA9IHRoaXMuaW5kZXhbY29kZVBvaW50ID4+IFVUUklFMl9TSElGVF8yXTtcbiAgICAgICAgICAgICAgICAgICAgaXggPSAoaXggPDwgVVRSSUUyX0lOREVYX1NISUZUKSArIChjb2RlUG9pbnQgJiBVVFJJRTJfREFUQV9NQVNLKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVtpeF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjb2RlUG9pbnQgPD0gMHhmZmZmKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIExlYWQgU3Vycm9nYXRlIENvZGUgUG9pbnQuICBBIFNlcGFyYXRlIGluZGV4IHNlY3Rpb24gaXMgc3RvcmVkIGZvclxuICAgICAgICAgICAgICAgICAgICAvLyBsZWFkIHN1cnJvZ2F0ZSBjb2RlIHVuaXRzIGFuZCBjb2RlIHBvaW50cy5cbiAgICAgICAgICAgICAgICAgICAgLy8gICBUaGUgbWFpbiBpbmRleCBoYXMgdGhlIGNvZGUgdW5pdCBkYXRhLlxuICAgICAgICAgICAgICAgICAgICAvLyAgIEZvciB0aGlzIGZ1bmN0aW9uLCB3ZSBuZWVkIHRoZSBjb2RlIHBvaW50IGRhdGEuXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdGU6IHRoaXMgZXhwcmVzc2lvbiBjb3VsZCBiZSByZWZhY3RvcmVkIGZvciBzbGlnaHRseSBpbXByb3ZlZCBlZmZpY2llbmN5LCBidXRcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgc3Vycm9nYXRlIGNvZGUgcG9pbnRzIHdpbGwgYmUgc28gcmFyZSBpbiBwcmFjdGljZSB0aGF0IGl0J3Mgbm90IHdvcnRoIGl0LlxuICAgICAgICAgICAgICAgICAgICBpeCA9IHRoaXMuaW5kZXhbVVRSSUUyX0xTQ1BfSU5ERVhfMl9PRkZTRVQgKyAoKGNvZGVQb2ludCAtIDB4ZDgwMCkgPj4gVVRSSUUyX1NISUZUXzIpXTtcbiAgICAgICAgICAgICAgICAgICAgaXggPSAoaXggPDwgVVRSSUUyX0lOREVYX1NISUZUKSArIChjb2RlUG9pbnQgJiBVVFJJRTJfREFUQV9NQVNLKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVtpeF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjb2RlUG9pbnQgPCB0aGlzLmhpZ2hTdGFydCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTdXBwbGVtZW50YWwgY29kZSBwb2ludCwgdXNlIHR3by1sZXZlbCBsb29rdXAuXG4gICAgICAgICAgICAgICAgICAgIGl4ID0gVVRSSUUyX0lOREVYXzFfT0ZGU0VUIC0gVVRSSUUyX09NSVRURURfQk1QX0lOREVYXzFfTEVOR1RIICsgKGNvZGVQb2ludCA+PiBVVFJJRTJfU0hJRlRfMSk7XG4gICAgICAgICAgICAgICAgICAgIGl4ID0gdGhpcy5pbmRleFtpeF07XG4gICAgICAgICAgICAgICAgICAgIGl4ICs9IChjb2RlUG9pbnQgPj4gVVRSSUUyX1NISUZUXzIpICYgVVRSSUUyX0lOREVYXzJfTUFTSztcbiAgICAgICAgICAgICAgICAgICAgaXggPSB0aGlzLmluZGV4W2l4XTtcbiAgICAgICAgICAgICAgICAgICAgaXggPSAoaXggPDwgVVRSSUUyX0lOREVYX1NISUZUKSArIChjb2RlUG9pbnQgJiBVVFJJRTJfREFUQV9NQVNLKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVtpeF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjb2RlUG9pbnQgPD0gMHgxMGZmZmYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVt0aGlzLmhpZ2hWYWx1ZUluZGV4XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGYWxsIHRocm91Z2guICBUaGUgY29kZSBwb2ludCBpcyBvdXRzaWRlIG9mIHRoZSBsZWdhbCByYW5nZSBvZiAwLi4weDEwZmZmZi5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVycm9yVmFsdWU7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBUcmllO1xuICAgIH0oKSk7XG5cbiAgICAvKlxuICAgICAqIGJhc2U2NC1hcnJheWJ1ZmZlciAxLjAuMiA8aHR0cHM6Ly9naXRodWIuY29tL25pa2xhc3ZoL2Jhc2U2NC1hcnJheWJ1ZmZlcj5cbiAgICAgKiBDb3B5cmlnaHQgKGMpIDIwMjIgTmlrbGFzIHZvbiBIZXJ0emVuIDxodHRwczovL2hlcnR6ZW4uY29tPlxuICAgICAqIFJlbGVhc2VkIHVuZGVyIE1JVCBMaWNlbnNlXG4gICAgICovXG4gICAgdmFyIGNoYXJzID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nO1xuICAgIC8vIFVzZSBhIGxvb2t1cCB0YWJsZSB0byBmaW5kIHRoZSBpbmRleC5cbiAgICB2YXIgbG9va3VwID0gdHlwZW9mIFVpbnQ4QXJyYXkgPT09ICd1bmRlZmluZWQnID8gW10gOiBuZXcgVWludDhBcnJheSgyNTYpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbG9va3VwW2NoYXJzLmNoYXJDb2RlQXQoaSldID0gaTtcbiAgICB9XG5cbiAgICB2YXIgUHJlcGVuZCA9IDE7XG4gICAgdmFyIENSID0gMjtcbiAgICB2YXIgTEYgPSAzO1xuICAgIHZhciBDb250cm9sID0gNDtcbiAgICB2YXIgRXh0ZW5kID0gNTtcbiAgICB2YXIgU3BhY2luZ01hcmsgPSA3O1xuICAgIHZhciBMID0gODtcbiAgICB2YXIgViA9IDk7XG4gICAgdmFyIFQgPSAxMDtcbiAgICB2YXIgTFYgPSAxMTtcbiAgICB2YXIgTFZUID0gMTI7XG4gICAgdmFyIFpXSiA9IDEzO1xuICAgIHZhciBFeHRlbmRlZF9QaWN0b2dyYXBoaWMgPSAxNDtcbiAgICB2YXIgUkkgPSAxNTtcbiAgICB2YXIgdG9Db2RlUG9pbnRzID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICB2YXIgY29kZVBvaW50cyA9IFtdO1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHZhciBsZW5ndGggPSBzdHIubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaSA8IGxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gc3RyLmNoYXJDb2RlQXQoaSsrKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA+PSAweGQ4MDAgJiYgdmFsdWUgPD0gMHhkYmZmICYmIGkgPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXh0cmEgPSBzdHIuY2hhckNvZGVBdChpKyspO1xuICAgICAgICAgICAgICAgIGlmICgoZXh0cmEgJiAweGZjMDApID09PSAweGRjMDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZVBvaW50cy5wdXNoKCgodmFsdWUgJiAweDNmZikgPDwgMTApICsgKGV4dHJhICYgMHgzZmYpICsgMHgxMDAwMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb2RlUG9pbnRzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBpLS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29kZVBvaW50cy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29kZVBvaW50cztcbiAgICB9O1xuICAgIHZhciBmcm9tQ29kZVBvaW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29kZVBvaW50cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgY29kZVBvaW50c1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChTdHJpbmcuZnJvbUNvZGVQb2ludCkge1xuICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ29kZVBvaW50LmFwcGx5KFN0cmluZywgY29kZVBvaW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxlbmd0aCA9IGNvZGVQb2ludHMubGVuZ3RoO1xuICAgICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb2RlVW5pdHMgPSBbXTtcbiAgICAgICAgdmFyIGluZGV4ID0gLTE7XG4gICAgICAgIHZhciByZXN1bHQgPSAnJztcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBjb2RlUG9pbnQgPSBjb2RlUG9pbnRzW2luZGV4XTtcbiAgICAgICAgICAgIGlmIChjb2RlUG9pbnQgPD0gMHhmZmZmKSB7XG4gICAgICAgICAgICAgICAgY29kZVVuaXRzLnB1c2goY29kZVBvaW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwO1xuICAgICAgICAgICAgICAgIGNvZGVVbml0cy5wdXNoKChjb2RlUG9pbnQgPj4gMTApICsgMHhkODAwLCAoY29kZVBvaW50ICUgMHg0MDApICsgMHhkYzAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbmRleCArIDEgPT09IGxlbmd0aCB8fCBjb2RlVW5pdHMubGVuZ3RoID4gMHg0MDAwKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlVW5pdHMpO1xuICAgICAgICAgICAgICAgIGNvZGVVbml0cy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICB2YXIgVW5pY29kZVRyaWUgPSBjcmVhdGVUcmllRnJvbUJhc2U2NChiYXNlNjQpO1xuICAgIHZhciBCUkVBS19OT1RfQUxMT1dFRCA9ICfDlyc7XG4gICAgdmFyIEJSRUFLX0FMTE9XRUQgPSAnw7cnO1xuICAgIHZhciBjb2RlUG9pbnRUb0NsYXNzID0gZnVuY3Rpb24gKGNvZGVQb2ludCkgeyByZXR1cm4gVW5pY29kZVRyaWUuZ2V0KGNvZGVQb2ludCk7IH07XG4gICAgdmFyIF9ncmFwaGVtZUJyZWFrQXRJbmRleCA9IGZ1bmN0aW9uIChfY29kZVBvaW50cywgY2xhc3NUeXBlcywgaW5kZXgpIHtcbiAgICAgICAgdmFyIHByZXZJbmRleCA9IGluZGV4IC0gMjtcbiAgICAgICAgdmFyIHByZXYgPSBjbGFzc1R5cGVzW3ByZXZJbmRleF07XG4gICAgICAgIHZhciBjdXJyZW50ID0gY2xhc3NUeXBlc1tpbmRleCAtIDFdO1xuICAgICAgICB2YXIgbmV4dCA9IGNsYXNzVHlwZXNbaW5kZXhdO1xuICAgICAgICAvLyBHQjMgRG8gbm90IGJyZWFrIGJldHdlZW4gYSBDUiBhbmQgTEZcbiAgICAgICAgaWYgKGN1cnJlbnQgPT09IENSICYmIG5leHQgPT09IExGKSB7XG4gICAgICAgICAgICByZXR1cm4gQlJFQUtfTk9UX0FMTE9XRUQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gR0I0IE90aGVyd2lzZSwgYnJlYWsgYmVmb3JlIGFuZCBhZnRlciBjb250cm9scy5cbiAgICAgICAgaWYgKGN1cnJlbnQgPT09IENSIHx8IGN1cnJlbnQgPT09IExGIHx8IGN1cnJlbnQgPT09IENvbnRyb2wpIHtcbiAgICAgICAgICAgIHJldHVybiBCUkVBS19BTExPV0VEO1xuICAgICAgICB9XG4gICAgICAgIC8vIEdCNVxuICAgICAgICBpZiAobmV4dCA9PT0gQ1IgfHwgbmV4dCA9PT0gTEYgfHwgbmV4dCA9PT0gQ29udHJvbCkge1xuICAgICAgICAgICAgcmV0dXJuIEJSRUFLX0FMTE9XRUQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRG8gbm90IGJyZWFrIEhhbmd1bCBzeWxsYWJsZSBzZXF1ZW5jZXMuXG4gICAgICAgIC8vIEdCNlxuICAgICAgICBpZiAoY3VycmVudCA9PT0gTCAmJiBbTCwgViwgTFYsIExWVF0uaW5kZXhPZihuZXh0KSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBCUkVBS19OT1RfQUxMT1dFRDtcbiAgICAgICAgfVxuICAgICAgICAvLyBHQjdcbiAgICAgICAgaWYgKChjdXJyZW50ID09PSBMViB8fCBjdXJyZW50ID09PSBWKSAmJiAobmV4dCA9PT0gViB8fCBuZXh0ID09PSBUKSkge1xuICAgICAgICAgICAgcmV0dXJuIEJSRUFLX05PVF9BTExPV0VEO1xuICAgICAgICB9XG4gICAgICAgIC8vIEdCOFxuICAgICAgICBpZiAoKGN1cnJlbnQgPT09IExWVCB8fCBjdXJyZW50ID09PSBUKSAmJiBuZXh0ID09PSBUKSB7XG4gICAgICAgICAgICByZXR1cm4gQlJFQUtfTk9UX0FMTE9XRUQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gR0I5IERvIG5vdCBicmVhayBiZWZvcmUgZXh0ZW5kaW5nIGNoYXJhY3RlcnMgb3IgWldKLlxuICAgICAgICBpZiAobmV4dCA9PT0gWldKIHx8IG5leHQgPT09IEV4dGVuZCkge1xuICAgICAgICAgICAgcmV0dXJuIEJSRUFLX05PVF9BTExPV0VEO1xuICAgICAgICB9XG4gICAgICAgIC8vIERvIG5vdCBicmVhayBiZWZvcmUgU3BhY2luZ01hcmtzLCBvciBhZnRlciBQcmVwZW5kIGNoYXJhY3RlcnMuXG4gICAgICAgIC8vIEdCOWFcbiAgICAgICAgaWYgKG5leHQgPT09IFNwYWNpbmdNYXJrKSB7XG4gICAgICAgICAgICByZXR1cm4gQlJFQUtfTk9UX0FMTE9XRUQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gR0I5YVxuICAgICAgICBpZiAoY3VycmVudCA9PT0gUHJlcGVuZCkge1xuICAgICAgICAgICAgcmV0dXJuIEJSRUFLX05PVF9BTExPV0VEO1xuICAgICAgICB9XG4gICAgICAgIC8vIEdCMTEgRG8gbm90IGJyZWFrIHdpdGhpbiBlbW9qaSBtb2RpZmllciBzZXF1ZW5jZXMgb3IgZW1vamkgendqIHNlcXVlbmNlcy5cbiAgICAgICAgaWYgKGN1cnJlbnQgPT09IFpXSiAmJiBuZXh0ID09PSBFeHRlbmRlZF9QaWN0b2dyYXBoaWMpIHtcbiAgICAgICAgICAgIHdoaWxlIChwcmV2ID09PSBFeHRlbmQpIHtcbiAgICAgICAgICAgICAgICBwcmV2ID0gY2xhc3NUeXBlc1stLXByZXZJbmRleF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJldiA9PT0gRXh0ZW5kZWRfUGljdG9ncmFwaGljKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEJSRUFLX05PVF9BTExPV0VEO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEdCMTIgRG8gbm90IGJyZWFrIHdpdGhpbiBlbW9qaSBmbGFnIHNlcXVlbmNlcy5cbiAgICAgICAgLy8gVGhhdCBpcywgZG8gbm90IGJyZWFrIGJldHdlZW4gcmVnaW9uYWwgaW5kaWNhdG9yIChSSSkgc3ltYm9sc1xuICAgICAgICAvLyBpZiB0aGVyZSBpcyBhbiBvZGQgbnVtYmVyIG9mIFJJIGNoYXJhY3RlcnMgYmVmb3JlIHRoZSBicmVhayBwb2ludC5cbiAgICAgICAgaWYgKGN1cnJlbnQgPT09IFJJICYmIG5leHQgPT09IFJJKSB7XG4gICAgICAgICAgICB2YXIgY291bnRSSSA9IDA7XG4gICAgICAgICAgICB3aGlsZSAocHJldiA9PT0gUkkpIHtcbiAgICAgICAgICAgICAgICBjb3VudFJJKys7XG4gICAgICAgICAgICAgICAgcHJldiA9IGNsYXNzVHlwZXNbLS1wcmV2SW5kZXhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvdW50UkkgJSAyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEJSRUFLX05PVF9BTExPV0VEO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBCUkVBS19BTExPV0VEO1xuICAgIH07XG4gICAgdmFyIEdyYXBoZW1lQnJlYWtlciA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgdmFyIGNvZGVQb2ludHMgPSB0b0NvZGVQb2ludHMoc3RyKTtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGNvZGVQb2ludHMubGVuZ3RoO1xuICAgICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgICB2YXIgbGFzdEVuZCA9IDA7XG4gICAgICAgIHZhciBjbGFzc1R5cGVzID0gY29kZVBvaW50cy5tYXAoY29kZVBvaW50VG9DbGFzcyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID49IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlLCB2YWx1ZTogbnVsbCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgZ3JhcGhlbWVCcmVhayA9IEJSRUFLX05PVF9BTExPV0VEO1xuICAgICAgICAgICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICAgICAoZ3JhcGhlbWVCcmVhayA9IF9ncmFwaGVtZUJyZWFrQXRJbmRleChjb2RlUG9pbnRzLCBjbGFzc1R5cGVzLCArK2luZGV4KSkgPT09IEJSRUFLX05PVF9BTExPV0VEKSB7IH1cbiAgICAgICAgICAgICAgICBpZiAoZ3JhcGhlbWVCcmVhayAhPT0gQlJFQUtfTk9UX0FMTE9XRUQgfHwgaW5kZXggPT09IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBmcm9tQ29kZVBvaW50LmFwcGx5KG51bGwsIGNvZGVQb2ludHMuc2xpY2UobGFzdEVuZCwgaW5kZXgpKTtcbiAgICAgICAgICAgICAgICAgICAgbGFzdEVuZCA9IGluZGV4O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdmFsdWUsIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7IGRvbmU6IHRydWUsIHZhbHVlOiBudWxsIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH07XG4gICAgdmFyIHNwbGl0R3JhcGhlbWVzID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICB2YXIgYnJlYWtlciA9IEdyYXBoZW1lQnJlYWtlcihzdHIpO1xuICAgICAgICB2YXIgZ3JhcGhlbWVzID0gW107XG4gICAgICAgIHZhciBiaztcbiAgICAgICAgd2hpbGUgKCEoYmsgPSBicmVha2VyLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgaWYgKGJrLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgZ3JhcGhlbWVzLnB1c2goYmsudmFsdWUuc2xpY2UoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdyYXBoZW1lcztcbiAgICB9O1xuXG4gICAgdmFyIHRlc3RSYW5nZUJvdW5kcyA9IGZ1bmN0aW9uIChkb2N1bWVudCkge1xuICAgICAgICB2YXIgVEVTVF9IRUlHSFQgPSAxMjM7XG4gICAgICAgIGlmIChkb2N1bWVudC5jcmVhdGVSYW5nZSkge1xuICAgICAgICAgICAgdmFyIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgICAgIGlmIChyYW5nZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGVzdEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdib3VuZHRlc3QnKTtcbiAgICAgICAgICAgICAgICB0ZXN0RWxlbWVudC5zdHlsZS5oZWlnaHQgPSBURVNUX0hFSUdIVCArIFwicHhcIjtcbiAgICAgICAgICAgICAgICB0ZXN0RWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRlc3RFbGVtZW50KTtcbiAgICAgICAgICAgICAgICByYW5nZS5zZWxlY3ROb2RlKHRlc3RFbGVtZW50KTtcbiAgICAgICAgICAgICAgICB2YXIgcmFuZ2VCb3VuZHMgPSByYW5nZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICB2YXIgcmFuZ2VIZWlnaHQgPSBNYXRoLnJvdW5kKHJhbmdlQm91bmRzLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0ZXN0RWxlbWVudCk7XG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlSGVpZ2h0ID09PSBURVNUX0hFSUdIVCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgdmFyIHRlc3RJT1NMaW5lQnJlYWsgPSBmdW5jdGlvbiAoZG9jdW1lbnQpIHtcbiAgICAgICAgdmFyIHRlc3RFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYm91bmR0ZXN0Jyk7XG4gICAgICAgIHRlc3RFbGVtZW50LnN0eWxlLndpZHRoID0gJzUwcHgnO1xuICAgICAgICB0ZXN0RWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgdGVzdEVsZW1lbnQuc3R5bGUuZm9udFNpemUgPSAnMTJweCc7XG4gICAgICAgIHRlc3RFbGVtZW50LnN0eWxlLmxldHRlclNwYWNpbmcgPSAnMHB4JztcbiAgICAgICAgdGVzdEVsZW1lbnQuc3R5bGUud29yZFNwYWNpbmcgPSAnMHB4JztcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0ZXN0RWxlbWVudCk7XG4gICAgICAgIHZhciByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgIHRlc3RFbGVtZW50LmlubmVySFRNTCA9IHR5cGVvZiAnJy5yZXBlYXQgPT09ICdmdW5jdGlvbicgPyAnJiMxMjgxMDQ7Jy5yZXBlYXQoMTApIDogJyc7XG4gICAgICAgIHZhciBub2RlID0gdGVzdEVsZW1lbnQuZmlyc3RDaGlsZDtcbiAgICAgICAgdmFyIHRleHRMaXN0ID0gdG9Db2RlUG9pbnRzJDEobm9kZS5kYXRhKS5tYXAoZnVuY3Rpb24gKGkpIHsgcmV0dXJuIGZyb21Db2RlUG9pbnQkMShpKTsgfSk7XG4gICAgICAgIHZhciBvZmZzZXQgPSAwO1xuICAgICAgICB2YXIgcHJldiA9IHt9O1xuICAgICAgICAvLyBpb3MgMTMgZG9lcyBub3QgaGFuZGxlIHJhbmdlIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBsaW5lIGNoYW5nZXMgY29ycmVjdGx5ICMyMTc3XG4gICAgICAgIHZhciBzdXBwb3J0cyA9IHRleHRMaXN0LmV2ZXJ5KGZ1bmN0aW9uICh0ZXh0LCBpKSB7XG4gICAgICAgICAgICByYW5nZS5zZXRTdGFydChub2RlLCBvZmZzZXQpO1xuICAgICAgICAgICAgcmFuZ2Uuc2V0RW5kKG5vZGUsIG9mZnNldCArIHRleHQubGVuZ3RoKTtcbiAgICAgICAgICAgIHZhciByZWN0ID0gcmFuZ2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICBvZmZzZXQgKz0gdGV4dC5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgYm91bmRBaGVhZCA9IHJlY3QueCA+IHByZXYueCB8fCByZWN0LnkgPiBwcmV2Lnk7XG4gICAgICAgICAgICBwcmV2ID0gcmVjdDtcbiAgICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYm91bmRBaGVhZDtcbiAgICAgICAgfSk7XG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQodGVzdEVsZW1lbnQpO1xuICAgICAgICByZXR1cm4gc3VwcG9ydHM7XG4gICAgfTtcbiAgICB2YXIgdGVzdENPUlMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0eXBlb2YgbmV3IEltYWdlKCkuY3Jvc3NPcmlnaW4gIT09ICd1bmRlZmluZWQnOyB9O1xuICAgIHZhciB0ZXN0UmVzcG9uc2VUeXBlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdHlwZW9mIG5ldyBYTUxIdHRwUmVxdWVzdCgpLnJlc3BvbnNlVHlwZSA9PT0gJ3N0cmluZyc7IH07XG4gICAgdmFyIHRlc3RTVkcgPSBmdW5jdGlvbiAoZG9jdW1lbnQpIHtcbiAgICAgICAgdmFyIGltZyA9IG5ldyBJbWFnZSgpO1xuICAgICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgaWYgKCFjdHgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpbWcuc3JjID0gXCJkYXRhOmltYWdlL3N2Zyt4bWwsPHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnPjwvc3ZnPlwiO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShpbWcsIDAsIDApO1xuICAgICAgICAgICAgY2FudmFzLnRvRGF0YVVSTCgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICB2YXIgaXNHcmVlblBpeGVsID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGRhdGFbMF0gPT09IDAgJiYgZGF0YVsxXSA9PT0gMjU1ICYmIGRhdGFbMl0gPT09IDAgJiYgZGF0YVszXSA9PT0gMjU1O1xuICAgIH07XG4gICAgdmFyIHRlc3RGb3JlaWduT2JqZWN0ID0gZnVuY3Rpb24gKGRvY3VtZW50KSB7XG4gICAgICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgdmFyIHNpemUgPSAxMDA7XG4gICAgICAgIGNhbnZhcy53aWR0aCA9IHNpemU7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBzaXplO1xuICAgICAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIGlmICghY3R4KSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSAncmdiKDAsIDI1NSwgMCknO1xuICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgc2l6ZSwgc2l6ZSk7XG4gICAgICAgIHZhciBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgdmFyIGdyZWVuSW1hZ2VTcmMgPSBjYW52YXMudG9EYXRhVVJMKCk7XG4gICAgICAgIGltZy5zcmMgPSBncmVlbkltYWdlU3JjO1xuICAgICAgICB2YXIgc3ZnID0gY3JlYXRlRm9yZWlnbk9iamVjdFNWRyhzaXplLCBzaXplLCAwLCAwLCBpbWcpO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gJ3JlZCc7XG4gICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCBzaXplLCBzaXplKTtcbiAgICAgICAgcmV0dXJuIGxvYWRTZXJpYWxpemVkU1ZHJDEoc3ZnKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGltZykge1xuICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShpbWcsIDAsIDApO1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIHNpemUsIHNpemUpLmRhdGE7XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gJ3JlZCc7XG4gICAgICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgc2l6ZSwgc2l6ZSk7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgbm9kZS5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgPSBcInVybChcIiArIGdyZWVuSW1hZ2VTcmMgKyBcIilcIjtcbiAgICAgICAgICAgIG5vZGUuc3R5bGUuaGVpZ2h0ID0gc2l6ZSArIFwicHhcIjtcbiAgICAgICAgICAgIC8vIEZpcmVmb3ggNTUgZG9lcyBub3QgcmVuZGVyIGlubGluZSA8aW1nIC8+IHRhZ3NcbiAgICAgICAgICAgIHJldHVybiBpc0dyZWVuUGl4ZWwoZGF0YSlcbiAgICAgICAgICAgICAgICA/IGxvYWRTZXJpYWxpemVkU1ZHJDEoY3JlYXRlRm9yZWlnbk9iamVjdFNWRyhzaXplLCBzaXplLCAwLCAwLCBub2RlKSlcbiAgICAgICAgICAgICAgICA6IFByb21pc2UucmVqZWN0KGZhbHNlKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChpbWcpIHtcbiAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoaW1nLCAwLCAwKTtcbiAgICAgICAgICAgIC8vIEVkZ2UgZG9lcyBub3QgcmVuZGVyIGJhY2tncm91bmQtaW1hZ2VzXG4gICAgICAgICAgICByZXR1cm4gaXNHcmVlblBpeGVsKGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgc2l6ZSwgc2l6ZSkuZGF0YSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFsc2U7IH0pO1xuICAgIH07XG4gICAgdmFyIGNyZWF0ZUZvcmVpZ25PYmplY3RTVkcgPSBmdW5jdGlvbiAod2lkdGgsIGhlaWdodCwgeCwgeSwgbm9kZSkge1xuICAgICAgICB2YXIgeG1sbnMgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnO1xuICAgICAgICB2YXIgc3ZnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHhtbG5zLCAnc3ZnJyk7XG4gICAgICAgIHZhciBmb3JlaWduT2JqZWN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHhtbG5zLCAnZm9yZWlnbk9iamVjdCcpO1xuICAgICAgICBzdmcuc2V0QXR0cmlidXRlTlMobnVsbCwgJ3dpZHRoJywgd2lkdGgudG9TdHJpbmcoKSk7XG4gICAgICAgIHN2Zy5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnaGVpZ2h0JywgaGVpZ2h0LnRvU3RyaW5nKCkpO1xuICAgICAgICBmb3JlaWduT2JqZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsICd3aWR0aCcsICcxMDAlJyk7XG4gICAgICAgIGZvcmVpZ25PYmplY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgJ2hlaWdodCcsICcxMDAlJyk7XG4gICAgICAgIGZvcmVpZ25PYmplY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgJ3gnLCB4LnRvU3RyaW5nKCkpO1xuICAgICAgICBmb3JlaWduT2JqZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsICd5JywgeS50b1N0cmluZygpKTtcbiAgICAgICAgZm9yZWlnbk9iamVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCcsICd0cnVlJyk7XG4gICAgICAgIHN2Zy5hcHBlbmRDaGlsZChmb3JlaWduT2JqZWN0KTtcbiAgICAgICAgZm9yZWlnbk9iamVjdC5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgICAgcmV0dXJuIHN2ZztcbiAgICB9O1xuICAgIHZhciBsb2FkU2VyaWFsaXplZFNWRyQxID0gZnVuY3Rpb24gKHN2Zykge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgdmFyIGltZyA9IG5ldyBJbWFnZSgpO1xuICAgICAgICAgICAgaW1nLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlc29sdmUoaW1nKTsgfTtcbiAgICAgICAgICAgIGltZy5vbmVycm9yID0gcmVqZWN0O1xuICAgICAgICAgICAgaW1nLnNyYyA9IFwiZGF0YTppbWFnZS9zdmcreG1sO2NoYXJzZXQ9dXRmLTgsXCIgKyBlbmNvZGVVUklDb21wb25lbnQobmV3IFhNTFNlcmlhbGl6ZXIoKS5zZXJpYWxpemVUb1N0cmluZyhzdmcpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICB2YXIgRkVBVFVSRVMgPSB7XG4gICAgICAgIGdldCBTVVBQT1JUX1JBTkdFX0JPVU5EUygpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRlc3RSYW5nZUJvdW5kcyhkb2N1bWVudCk7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRkVBVFVSRVMsICdTVVBQT1JUX1JBTkdFX0JPVU5EUycsIHsgdmFsdWU6IHZhbHVlIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgU1VQUE9SVF9XT1JEX0JSRUFLSU5HKCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gRkVBVFVSRVMuU1VQUE9SVF9SQU5HRV9CT1VORFMgJiYgdGVzdElPU0xpbmVCcmVhayhkb2N1bWVudCk7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRkVBVFVSRVMsICdTVVBQT1JUX1dPUkRfQlJFQUtJTkcnLCB7IHZhbHVlOiB2YWx1ZSB9KTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IFNVUFBPUlRfU1ZHX0RSQVdJTkcoKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB0ZXN0U1ZHKGRvY3VtZW50KTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGRUFUVVJFUywgJ1NVUFBPUlRfU1ZHX0RSQVdJTkcnLCB7IHZhbHVlOiB2YWx1ZSB9KTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IFNVUFBPUlRfRk9SRUlHTk9CSkVDVF9EUkFXSU5HKCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gdHlwZW9mIEFycmF5LmZyb20gPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHdpbmRvdy5mZXRjaCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgICAgID8gdGVzdEZvcmVpZ25PYmplY3QoZG9jdW1lbnQpXG4gICAgICAgICAgICAgICAgOiBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZFQVRVUkVTLCAnU1VQUE9SVF9GT1JFSUdOT0JKRUNUX0RSQVdJTkcnLCB7IHZhbHVlOiB2YWx1ZSB9KTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IFNVUFBPUlRfQ09SU19JTUFHRVMoKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB0ZXN0Q09SUygpO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZFQVRVUkVTLCAnU1VQUE9SVF9DT1JTX0lNQUdFUycsIHsgdmFsdWU6IHZhbHVlIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgU1VQUE9SVF9SRVNQT05TRV9UWVBFKCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gdGVzdFJlc3BvbnNlVHlwZSgpO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZFQVRVUkVTLCAnU1VQUE9SVF9SRVNQT05TRV9UWVBFJywgeyB2YWx1ZTogdmFsdWUgfSk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBTVVBQT1JUX0NPUlNfWEhSKCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gJ3dpdGhDcmVkZW50aWFscycgaW4gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRkVBVFVSRVMsICdTVVBQT1JUX0NPUlNfWEhSJywgeyB2YWx1ZTogdmFsdWUgfSk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBTVVBQT1JUX05BVElWRV9URVhUX1NFR01FTlRBVElPTigpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSAhISh0eXBlb2YgSW50bCAhPT0gJ3VuZGVmaW5lZCcgJiYgSW50bC5TZWdtZW50ZXIpO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZFQVRVUkVTLCAnU1VQUE9SVF9OQVRJVkVfVEVYVF9TRUdNRU5UQVRJT04nLCB7IHZhbHVlOiB2YWx1ZSB9KTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgVGV4dEJvdW5kcyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gVGV4dEJvdW5kcyh0ZXh0LCBib3VuZHMpIHtcbiAgICAgICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgICAgICAgICB0aGlzLmJvdW5kcyA9IGJvdW5kcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVGV4dEJvdW5kcztcbiAgICB9KCkpO1xuICAgIHZhciBwYXJzZVRleHRCb3VuZHMgPSBmdW5jdGlvbiAoY29udGV4dCwgdmFsdWUsIHN0eWxlcywgbm9kZSkge1xuICAgICAgICB2YXIgdGV4dExpc3QgPSBicmVha1RleHQodmFsdWUsIHN0eWxlcyk7XG4gICAgICAgIHZhciB0ZXh0Qm91bmRzID0gW107XG4gICAgICAgIHZhciBvZmZzZXQgPSAwO1xuICAgICAgICB0ZXh0TGlzdC5mb3JFYWNoKGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICAgICAgICBpZiAoc3R5bGVzLnRleHREZWNvcmF0aW9uTGluZS5sZW5ndGggfHwgdGV4dC50cmltKCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGlmIChGRUFUVVJFUy5TVVBQT1JUX1JBTkdFX0JPVU5EUykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2xpZW50UmVjdHMgPSBjcmVhdGVSYW5nZShub2RlLCBvZmZzZXQsIHRleHQubGVuZ3RoKS5nZXRDbGllbnRSZWN0cygpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2xpZW50UmVjdHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN1YlNlZ21lbnRzID0gc2VnbWVudEdyYXBoZW1lcyh0ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdWJPZmZzZXRfMSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJTZWdtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChzdWJTZWdtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dEJvdW5kcy5wdXNoKG5ldyBUZXh0Qm91bmRzKHN1YlNlZ21lbnQsIEJvdW5kcy5mcm9tRE9NUmVjdExpc3QoY29udGV4dCwgY3JlYXRlUmFuZ2Uobm9kZSwgc3ViT2Zmc2V0XzEgKyBvZmZzZXQsIHN1YlNlZ21lbnQubGVuZ3RoKS5nZXRDbGllbnRSZWN0cygpKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Yk9mZnNldF8xICs9IHN1YlNlZ21lbnQubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0Qm91bmRzLnB1c2gobmV3IFRleHRCb3VuZHModGV4dCwgQm91bmRzLmZyb21ET01SZWN0TGlzdChjb250ZXh0LCBjbGllbnRSZWN0cykpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlcGxhY2VtZW50Tm9kZSA9IG5vZGUuc3BsaXRUZXh0KHRleHQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgdGV4dEJvdW5kcy5wdXNoKG5ldyBUZXh0Qm91bmRzKHRleHQsIGdldFdyYXBwZXJCb3VuZHMoY29udGV4dCwgbm9kZSkpKTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IHJlcGxhY2VtZW50Tm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghRkVBVFVSRVMuU1VQUE9SVF9SQU5HRV9CT1VORFMpIHtcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5zcGxpdFRleHQodGV4dC5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2Zmc2V0ICs9IHRleHQubGVuZ3RoO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRleHRCb3VuZHM7XG4gICAgfTtcbiAgICB2YXIgZ2V0V3JhcHBlckJvdW5kcyA9IGZ1bmN0aW9uIChjb250ZXh0LCBub2RlKSB7XG4gICAgICAgIHZhciBvd25lckRvY3VtZW50ID0gbm9kZS5vd25lckRvY3VtZW50O1xuICAgICAgICBpZiAob3duZXJEb2N1bWVudCkge1xuICAgICAgICAgICAgdmFyIHdyYXBwZXIgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2h0bWwyY2FudmFzd3JhcHBlcicpO1xuICAgICAgICAgICAgd3JhcHBlci5hcHBlbmRDaGlsZChub2RlLmNsb25lTm9kZSh0cnVlKSk7XG4gICAgICAgICAgICB2YXIgcGFyZW50Tm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIGlmIChwYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQod3JhcHBlciwgbm9kZSk7XG4gICAgICAgICAgICAgICAgdmFyIGJvdW5kcyA9IHBhcnNlQm91bmRzKGNvbnRleHQsIHdyYXBwZXIpO1xuICAgICAgICAgICAgICAgIGlmICh3cmFwcGVyLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQod3JhcHBlci5maXJzdENoaWxkLCB3cmFwcGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJvdW5kcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQm91bmRzLkVNUFRZO1xuICAgIH07XG4gICAgdmFyIGNyZWF0ZVJhbmdlID0gZnVuY3Rpb24gKG5vZGUsIG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBvd25lckRvY3VtZW50ID0gbm9kZS5vd25lckRvY3VtZW50O1xuICAgICAgICBpZiAoIW93bmVyRG9jdW1lbnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm9kZSBoYXMgbm8gb3duZXIgZG9jdW1lbnQnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmFuZ2UgPSBvd25lckRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgIHJhbmdlLnNldFN0YXJ0KG5vZGUsIG9mZnNldCk7XG4gICAgICAgIHJhbmdlLnNldEVuZChub2RlLCBvZmZzZXQgKyBsZW5ndGgpO1xuICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgfTtcbiAgICB2YXIgc2VnbWVudEdyYXBoZW1lcyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAoRkVBVFVSRVMuU1VQUE9SVF9OQVRJVkVfVEVYVF9TRUdNRU5UQVRJT04pIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICB2YXIgc2VnbWVudGVyID0gbmV3IEludGwuU2VnbWVudGVyKHZvaWQgMCwgeyBncmFudWxhcml0eTogJ2dyYXBoZW1lJyB9KTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShzZWdtZW50ZXIuc2VnbWVudCh2YWx1ZSkpLm1hcChmdW5jdGlvbiAoc2VnbWVudCkgeyByZXR1cm4gc2VnbWVudC5zZWdtZW50OyB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3BsaXRHcmFwaGVtZXModmFsdWUpO1xuICAgIH07XG4gICAgdmFyIHNlZ21lbnRXb3JkcyA9IGZ1bmN0aW9uICh2YWx1ZSwgc3R5bGVzKSB7XG4gICAgICAgIGlmIChGRUFUVVJFUy5TVVBQT1JUX05BVElWRV9URVhUX1NFR01FTlRBVElPTikge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIHZhciBzZWdtZW50ZXIgPSBuZXcgSW50bC5TZWdtZW50ZXIodm9pZCAwLCB7XG4gICAgICAgICAgICAgICAgZ3JhbnVsYXJpdHk6ICd3b3JkJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oc2VnbWVudGVyLnNlZ21lbnQodmFsdWUpKS5tYXAoZnVuY3Rpb24gKHNlZ21lbnQpIHsgcmV0dXJuIHNlZ21lbnQuc2VnbWVudDsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJyZWFrV29yZHModmFsdWUsIHN0eWxlcyk7XG4gICAgfTtcbiAgICB2YXIgYnJlYWtUZXh0ID0gZnVuY3Rpb24gKHZhbHVlLCBzdHlsZXMpIHtcbiAgICAgICAgcmV0dXJuIHN0eWxlcy5sZXR0ZXJTcGFjaW5nICE9PSAwID8gc2VnbWVudEdyYXBoZW1lcyh2YWx1ZSkgOiBzZWdtZW50V29yZHModmFsdWUsIHN0eWxlcyk7XG4gICAgfTtcbiAgICAvLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3NzLXRleHQvI3dvcmQtc2VwYXJhdG9yXG4gICAgdmFyIHdvcmRTZXBhcmF0b3JzID0gWzB4MDAyMCwgMHgwMGEwLCAweDEzNjEsIDB4MTAxMDAsIDB4MTAxMDEsIDB4MTAzOSwgMHgxMDkxXTtcbiAgICB2YXIgYnJlYWtXb3JkcyA9IGZ1bmN0aW9uIChzdHIsIHN0eWxlcykge1xuICAgICAgICB2YXIgYnJlYWtlciA9IExpbmVCcmVha2VyKHN0ciwge1xuICAgICAgICAgICAgbGluZUJyZWFrOiBzdHlsZXMubGluZUJyZWFrLFxuICAgICAgICAgICAgd29yZEJyZWFrOiBzdHlsZXMub3ZlcmZsb3dXcmFwID09PSBcImJyZWFrLXdvcmRcIiAvKiBCUkVBS19XT1JEICovID8gJ2JyZWFrLXdvcmQnIDogc3R5bGVzLndvcmRCcmVha1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHdvcmRzID0gW107XG4gICAgICAgIHZhciBiaztcbiAgICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoYmsudmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBiay52YWx1ZS5zbGljZSgpO1xuICAgICAgICAgICAgICAgIHZhciBjb2RlUG9pbnRzID0gdG9Db2RlUG9pbnRzJDEodmFsdWUpO1xuICAgICAgICAgICAgICAgIHZhciB3b3JkXzEgPSAnJztcbiAgICAgICAgICAgICAgICBjb2RlUG9pbnRzLmZvckVhY2goZnVuY3Rpb24gKGNvZGVQb2ludCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAod29yZFNlcGFyYXRvcnMuaW5kZXhPZihjb2RlUG9pbnQpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd29yZF8xICs9IGZyb21Db2RlUG9pbnQkMShjb2RlUG9pbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdvcmRfMS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3b3Jkcy5wdXNoKHdvcmRfMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB3b3Jkcy5wdXNoKGZyb21Db2RlUG9pbnQkMShjb2RlUG9pbnQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmRfMSA9ICcnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHdvcmRfMS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgd29yZHMucHVzaCh3b3JkXzEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgd2hpbGUgKCEoYmsgPSBicmVha2VyLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgX2xvb3BfMSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3b3JkcztcbiAgICB9O1xuXG4gICAgdmFyIFRleHRDb250YWluZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFRleHRDb250YWluZXIoY29udGV4dCwgbm9kZSwgc3R5bGVzKSB7XG4gICAgICAgICAgICB0aGlzLnRleHQgPSB0cmFuc2Zvcm0obm9kZS5kYXRhLCBzdHlsZXMudGV4dFRyYW5zZm9ybSk7XG4gICAgICAgICAgICB0aGlzLnRleHRCb3VuZHMgPSBwYXJzZVRleHRCb3VuZHMoY29udGV4dCwgdGhpcy50ZXh0LCBzdHlsZXMsIG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBUZXh0Q29udGFpbmVyO1xuICAgIH0oKSk7XG4gICAgdmFyIHRyYW5zZm9ybSA9IGZ1bmN0aW9uICh0ZXh0LCB0cmFuc2Zvcm0pIHtcbiAgICAgICAgc3dpdGNoICh0cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIGNhc2UgMSAvKiBMT1dFUkNBU0UgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRleHQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGNhc2UgMyAvKiBDQVBJVEFMSVpFICovOlxuICAgICAgICAgICAgICAgIHJldHVybiB0ZXh0LnJlcGxhY2UoQ0FQSVRBTElaRSwgY2FwaXRhbGl6ZSk7XG4gICAgICAgICAgICBjYXNlIDIgLyogVVBQRVJDQVNFICovOlxuICAgICAgICAgICAgICAgIHJldHVybiB0ZXh0LnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB0ZXh0O1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgQ0FQSVRBTElaRSA9IC8oXnxcXHN8OnwtfFxcKHxcXCkpKFthLXpdKS9nO1xuICAgIHZhciBjYXBpdGFsaXplID0gZnVuY3Rpb24gKG0sIHAxLCBwMikge1xuICAgICAgICBpZiAobS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gcDEgKyBwMi50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtO1xuICAgIH07XG5cbiAgICB2YXIgSW1hZ2VFbGVtZW50Q29udGFpbmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoSW1hZ2VFbGVtZW50Q29udGFpbmVyLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBJbWFnZUVsZW1lbnRDb250YWluZXIoY29udGV4dCwgaW1nKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb250ZXh0LCBpbWcpIHx8IHRoaXM7XG4gICAgICAgICAgICBfdGhpcy5zcmMgPSBpbWcuY3VycmVudFNyYyB8fCBpbWcuc3JjO1xuICAgICAgICAgICAgX3RoaXMuaW50cmluc2ljV2lkdGggPSBpbWcubmF0dXJhbFdpZHRoO1xuICAgICAgICAgICAgX3RoaXMuaW50cmluc2ljSGVpZ2h0ID0gaW1nLm5hdHVyYWxIZWlnaHQ7XG4gICAgICAgICAgICBfdGhpcy5jb250ZXh0LmNhY2hlLmFkZEltYWdlKF90aGlzLnNyYyk7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEltYWdlRWxlbWVudENvbnRhaW5lcjtcbiAgICB9KEVsZW1lbnRDb250YWluZXIpKTtcblxuICAgIHZhciBDYW52YXNFbGVtZW50Q29udGFpbmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoQ2FudmFzRWxlbWVudENvbnRhaW5lciwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gQ2FudmFzRWxlbWVudENvbnRhaW5lcihjb250ZXh0LCBjYW52YXMpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbnRleHQsIGNhbnZhcykgfHwgdGhpcztcbiAgICAgICAgICAgIF90aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICAgICAgICAgIF90aGlzLmludHJpbnNpY1dpZHRoID0gY2FudmFzLndpZHRoO1xuICAgICAgICAgICAgX3RoaXMuaW50cmluc2ljSGVpZ2h0ID0gY2FudmFzLmhlaWdodDtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQ2FudmFzRWxlbWVudENvbnRhaW5lcjtcbiAgICB9KEVsZW1lbnRDb250YWluZXIpKTtcblxuICAgIHZhciBTVkdFbGVtZW50Q29udGFpbmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoU1ZHRWxlbWVudENvbnRhaW5lciwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gU1ZHRWxlbWVudENvbnRhaW5lcihjb250ZXh0LCBpbWcpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbnRleHQsIGltZykgfHwgdGhpcztcbiAgICAgICAgICAgIHZhciBzID0gbmV3IFhNTFNlcmlhbGl6ZXIoKTtcbiAgICAgICAgICAgIHZhciBib3VuZHMgPSBwYXJzZUJvdW5kcyhjb250ZXh0LCBpbWcpO1xuICAgICAgICAgICAgaW1nLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCBib3VuZHMud2lkdGggKyBcInB4XCIpO1xuICAgICAgICAgICAgaW1nLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgYm91bmRzLmhlaWdodCArIFwicHhcIik7XG4gICAgICAgICAgICBfdGhpcy5zdmcgPSBcImRhdGE6aW1hZ2Uvc3ZnK3htbCxcIiArIGVuY29kZVVSSUNvbXBvbmVudChzLnNlcmlhbGl6ZVRvU3RyaW5nKGltZykpO1xuICAgICAgICAgICAgX3RoaXMuaW50cmluc2ljV2lkdGggPSBpbWcud2lkdGguYmFzZVZhbC52YWx1ZTtcbiAgICAgICAgICAgIF90aGlzLmludHJpbnNpY0hlaWdodCA9IGltZy5oZWlnaHQuYmFzZVZhbC52YWx1ZTtcbiAgICAgICAgICAgIF90aGlzLmNvbnRleHQuY2FjaGUuYWRkSW1hZ2UoX3RoaXMuc3ZnKTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU1ZHRWxlbWVudENvbnRhaW5lcjtcbiAgICB9KEVsZW1lbnRDb250YWluZXIpKTtcblxuICAgIHZhciBMSUVsZW1lbnRDb250YWluZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhMSUVsZW1lbnRDb250YWluZXIsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIExJRWxlbWVudENvbnRhaW5lcihjb250ZXh0LCBlbGVtZW50KSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb250ZXh0LCBlbGVtZW50KSB8fCB0aGlzO1xuICAgICAgICAgICAgX3RoaXMudmFsdWUgPSBlbGVtZW50LnZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBMSUVsZW1lbnRDb250YWluZXI7XG4gICAgfShFbGVtZW50Q29udGFpbmVyKSk7XG5cbiAgICB2YXIgT0xFbGVtZW50Q29udGFpbmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoT0xFbGVtZW50Q29udGFpbmVyLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBPTEVsZW1lbnRDb250YWluZXIoY29udGV4dCwgZWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29udGV4dCwgZWxlbWVudCkgfHwgdGhpcztcbiAgICAgICAgICAgIF90aGlzLnN0YXJ0ID0gZWxlbWVudC5zdGFydDtcbiAgICAgICAgICAgIF90aGlzLnJldmVyc2VkID0gdHlwZW9mIGVsZW1lbnQucmV2ZXJzZWQgPT09ICdib29sZWFuJyAmJiBlbGVtZW50LnJldmVyc2VkID09PSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPTEVsZW1lbnRDb250YWluZXI7XG4gICAgfShFbGVtZW50Q29udGFpbmVyKSk7XG5cbiAgICB2YXIgQ0hFQ0tCT1hfQk9SREVSX1JBRElVUyA9IFtcbiAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogMTUgLyogRElNRU5TSU9OX1RPS0VOICovLFxuICAgICAgICAgICAgZmxhZ3M6IDAsXG4gICAgICAgICAgICB1bml0OiAncHgnLFxuICAgICAgICAgICAgbnVtYmVyOiAzXG4gICAgICAgIH1cbiAgICBdO1xuICAgIHZhciBSQURJT19CT1JERVJfUkFESVVTID0gW1xuICAgICAgICB7XG4gICAgICAgICAgICB0eXBlOiAxNiAvKiBQRVJDRU5UQUdFX1RPS0VOICovLFxuICAgICAgICAgICAgZmxhZ3M6IDAsXG4gICAgICAgICAgICBudW1iZXI6IDUwXG4gICAgICAgIH1cbiAgICBdO1xuICAgIHZhciByZWZvcm1hdElucHV0Qm91bmRzID0gZnVuY3Rpb24gKGJvdW5kcykge1xuICAgICAgICBpZiAoYm91bmRzLndpZHRoID4gYm91bmRzLmhlaWdodCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCb3VuZHMoYm91bmRzLmxlZnQgKyAoYm91bmRzLndpZHRoIC0gYm91bmRzLmhlaWdodCkgLyAyLCBib3VuZHMudG9wLCBib3VuZHMuaGVpZ2h0LCBib3VuZHMuaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChib3VuZHMud2lkdGggPCBib3VuZHMuaGVpZ2h0KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJvdW5kcyhib3VuZHMubGVmdCwgYm91bmRzLnRvcCArIChib3VuZHMuaGVpZ2h0IC0gYm91bmRzLndpZHRoKSAvIDIsIGJvdW5kcy53aWR0aCwgYm91bmRzLndpZHRoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYm91bmRzO1xuICAgIH07XG4gICAgdmFyIGdldElucHV0VmFsdWUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBub2RlLnR5cGUgPT09IFBBU1NXT1JEID8gbmV3IEFycmF5KG5vZGUudmFsdWUubGVuZ3RoICsgMSkuam9pbignXFx1MjAyMicpIDogbm9kZS52YWx1ZTtcbiAgICAgICAgcmV0dXJuIHZhbHVlLmxlbmd0aCA9PT0gMCA/IG5vZGUucGxhY2Vob2xkZXIgfHwgJycgOiB2YWx1ZTtcbiAgICB9O1xuICAgIHZhciBDSEVDS0JPWCA9ICdjaGVja2JveCc7XG4gICAgdmFyIFJBRElPID0gJ3JhZGlvJztcbiAgICB2YXIgUEFTU1dPUkQgPSAncGFzc3dvcmQnO1xuICAgIHZhciBJTlBVVF9DT0xPUiA9IDB4MmEyYTJhZmY7XG4gICAgdmFyIElucHV0RWxlbWVudENvbnRhaW5lciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKElucHV0RWxlbWVudENvbnRhaW5lciwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gSW5wdXRFbGVtZW50Q29udGFpbmVyKGNvbnRleHQsIGlucHV0KSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb250ZXh0LCBpbnB1dCkgfHwgdGhpcztcbiAgICAgICAgICAgIF90aGlzLnR5cGUgPSBpbnB1dC50eXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBfdGhpcy5jaGVja2VkID0gaW5wdXQuY2hlY2tlZDtcbiAgICAgICAgICAgIF90aGlzLnZhbHVlID0gZ2V0SW5wdXRWYWx1ZShpbnB1dCk7XG4gICAgICAgICAgICBpZiAoX3RoaXMudHlwZSA9PT0gQ0hFQ0tCT1ggfHwgX3RoaXMudHlwZSA9PT0gUkFESU8pIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zdHlsZXMuYmFja2dyb3VuZENvbG9yID0gMHhkZWRlZGVmZjtcbiAgICAgICAgICAgICAgICBfdGhpcy5zdHlsZXMuYm9yZGVyVG9wQ29sb3IgPVxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zdHlsZXMuYm9yZGVyUmlnaHRDb2xvciA9XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zdHlsZXMuYm9yZGVyQm90dG9tQ29sb3IgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnN0eWxlcy5ib3JkZXJMZWZ0Q29sb3IgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweGE1YTVhNWZmO1xuICAgICAgICAgICAgICAgIF90aGlzLnN0eWxlcy5ib3JkZXJUb3BXaWR0aCA9XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnN0eWxlcy5ib3JkZXJSaWdodFdpZHRoID1cbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnN0eWxlcy5ib3JkZXJCb3R0b21XaWR0aCA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc3R5bGVzLmJvcmRlckxlZnRXaWR0aCA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDE7XG4gICAgICAgICAgICAgICAgX3RoaXMuc3R5bGVzLmJvcmRlclRvcFN0eWxlID1cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc3R5bGVzLmJvcmRlclJpZ2h0U3R5bGUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc3R5bGVzLmJvcmRlckJvdHRvbVN0eWxlID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zdHlsZXMuYm9yZGVyTGVmdFN0eWxlID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMSAvKiBTT0xJRCAqLztcbiAgICAgICAgICAgICAgICBfdGhpcy5zdHlsZXMuYmFja2dyb3VuZENsaXAgPSBbMCAvKiBCT1JERVJfQk9YICovXTtcbiAgICAgICAgICAgICAgICBfdGhpcy5zdHlsZXMuYmFja2dyb3VuZE9yaWdpbiA9IFswIC8qIEJPUkRFUl9CT1ggKi9dO1xuICAgICAgICAgICAgICAgIF90aGlzLmJvdW5kcyA9IHJlZm9ybWF0SW5wdXRCb3VuZHMoX3RoaXMuYm91bmRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAoX3RoaXMudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgQ0hFQ0tCT1g6XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnN0eWxlcy5ib3JkZXJUb3BSaWdodFJhZGl1cyA9XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zdHlsZXMuYm9yZGVyVG9wTGVmdFJhZGl1cyA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc3R5bGVzLmJvcmRlckJvdHRvbVJpZ2h0UmFkaXVzID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc3R5bGVzLmJvcmRlckJvdHRvbUxlZnRSYWRpdXMgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ0hFQ0tCT1hfQk9SREVSX1JBRElVUztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBSQURJTzpcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc3R5bGVzLmJvcmRlclRvcFJpZ2h0UmFkaXVzID1cbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnN0eWxlcy5ib3JkZXJUb3BMZWZ0UmFkaXVzID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zdHlsZXMuYm9yZGVyQm90dG9tUmlnaHRSYWRpdXMgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zdHlsZXMuYm9yZGVyQm90dG9tTGVmdFJhZGl1cyA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBSQURJT19CT1JERVJfUkFESVVTO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSW5wdXRFbGVtZW50Q29udGFpbmVyO1xuICAgIH0oRWxlbWVudENvbnRhaW5lcikpO1xuXG4gICAgdmFyIFNlbGVjdEVsZW1lbnRDb250YWluZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhTZWxlY3RFbGVtZW50Q29udGFpbmVyLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBTZWxlY3RFbGVtZW50Q29udGFpbmVyKGNvbnRleHQsIGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbnRleHQsIGVsZW1lbnQpIHx8IHRoaXM7XG4gICAgICAgICAgICB2YXIgb3B0aW9uID0gZWxlbWVudC5vcHRpb25zW2VsZW1lbnQuc2VsZWN0ZWRJbmRleCB8fCAwXTtcbiAgICAgICAgICAgIF90aGlzLnZhbHVlID0gb3B0aW9uID8gb3B0aW9uLnRleHQgfHwgJycgOiAnJztcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU2VsZWN0RWxlbWVudENvbnRhaW5lcjtcbiAgICB9KEVsZW1lbnRDb250YWluZXIpKTtcblxuICAgIHZhciBUZXh0YXJlYUVsZW1lbnRDb250YWluZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhUZXh0YXJlYUVsZW1lbnRDb250YWluZXIsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIFRleHRhcmVhRWxlbWVudENvbnRhaW5lcihjb250ZXh0LCBlbGVtZW50KSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb250ZXh0LCBlbGVtZW50KSB8fCB0aGlzO1xuICAgICAgICAgICAgX3RoaXMudmFsdWUgPSBlbGVtZW50LnZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBUZXh0YXJlYUVsZW1lbnRDb250YWluZXI7XG4gICAgfShFbGVtZW50Q29udGFpbmVyKSk7XG5cbiAgICB2YXIgSUZyYW1lRWxlbWVudENvbnRhaW5lciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKElGcmFtZUVsZW1lbnRDb250YWluZXIsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIElGcmFtZUVsZW1lbnRDb250YWluZXIoY29udGV4dCwgaWZyYW1lKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb250ZXh0LCBpZnJhbWUpIHx8IHRoaXM7XG4gICAgICAgICAgICBfdGhpcy5zcmMgPSBpZnJhbWUuc3JjO1xuICAgICAgICAgICAgX3RoaXMud2lkdGggPSBwYXJzZUludChpZnJhbWUud2lkdGgsIDEwKSB8fCAwO1xuICAgICAgICAgICAgX3RoaXMuaGVpZ2h0ID0gcGFyc2VJbnQoaWZyYW1lLmhlaWdodCwgMTApIHx8IDA7XG4gICAgICAgICAgICBfdGhpcy5iYWNrZ3JvdW5kQ29sb3IgPSBfdGhpcy5zdHlsZXMuYmFja2dyb3VuZENvbG9yO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoaWZyYW1lLmNvbnRlbnRXaW5kb3cgJiZcbiAgICAgICAgICAgICAgICAgICAgaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQgJiZcbiAgICAgICAgICAgICAgICAgICAgaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnRyZWUgPSBwYXJzZVRyZWUoY29udGV4dCwgaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1iYWNrZ3JvdW5kLyNzcGVjaWFsLWJhY2tncm91bmRzXG4gICAgICAgICAgICAgICAgICAgIHZhciBkb2N1bWVudEJhY2tncm91bmRDb2xvciA9IGlmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBwYXJzZUNvbG9yKGNvbnRleHQsIGdldENvbXB1dGVkU3R5bGUoaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KS5iYWNrZ3JvdW5kQ29sb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IENPTE9SUy5UUkFOU1BBUkVOVDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJvZHlCYWNrZ3JvdW5kQ29sb3IgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudC5ib2R5XG4gICAgICAgICAgICAgICAgICAgICAgICA/IHBhcnNlQ29sb3IoY29udGV4dCwgZ2V0Q29tcHV0ZWRTdHlsZShpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudC5ib2R5KS5iYWNrZ3JvdW5kQ29sb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IENPTE9SUy5UUkFOU1BBUkVOVDtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYmFja2dyb3VuZENvbG9yID0gaXNUcmFuc3BhcmVudChkb2N1bWVudEJhY2tncm91bmRDb2xvcilcbiAgICAgICAgICAgICAgICAgICAgICAgID8gaXNUcmFuc3BhcmVudChib2R5QmFja2dyb3VuZENvbG9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gX3RoaXMuc3R5bGVzLmJhY2tncm91bmRDb2xvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogYm9keUJhY2tncm91bmRDb2xvclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBkb2N1bWVudEJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIElGcmFtZUVsZW1lbnRDb250YWluZXI7XG4gICAgfShFbGVtZW50Q29udGFpbmVyKSk7XG5cbiAgICB2YXIgTElTVF9PV05FUlMgPSBbJ09MJywgJ1VMJywgJ01FTlUnXTtcbiAgICB2YXIgcGFyc2VOb2RlVHJlZSA9IGZ1bmN0aW9uIChjb250ZXh0LCBub2RlLCBwYXJlbnQsIHJvb3QpIHtcbiAgICAgICAgZm9yICh2YXIgY2hpbGROb2RlID0gbm9kZS5maXJzdENoaWxkLCBuZXh0Tm9kZSA9IHZvaWQgMDsgY2hpbGROb2RlOyBjaGlsZE5vZGUgPSBuZXh0Tm9kZSkge1xuICAgICAgICAgICAgbmV4dE5vZGUgPSBjaGlsZE5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICBpZiAoaXNUZXh0Tm9kZShjaGlsZE5vZGUpICYmIGNoaWxkTm9kZS5kYXRhLnRyaW0oKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50LnRleHROb2Rlcy5wdXNoKG5ldyBUZXh0Q29udGFpbmVyKGNvbnRleHQsIGNoaWxkTm9kZSwgcGFyZW50LnN0eWxlcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNFbGVtZW50Tm9kZShjaGlsZE5vZGUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzU2xvdEVsZW1lbnQoY2hpbGROb2RlKSAmJiBjaGlsZE5vZGUuYXNzaWduZWROb2Rlcykge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZE5vZGUuYXNzaWduZWROb2RlcygpLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkTm9kZSkgeyByZXR1cm4gcGFyc2VOb2RlVHJlZShjb250ZXh0LCBjaGlsZE5vZGUsIHBhcmVudCwgcm9vdCk7IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IGNyZWF0ZUNvbnRhaW5lcihjb250ZXh0LCBjaGlsZE5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGFpbmVyLnN0eWxlcy5pc1Zpc2libGUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNyZWF0ZXNSZWFsU3RhY2tpbmdDb250ZXh0KGNoaWxkTm9kZSwgY29udGFpbmVyLCByb290KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lci5mbGFncyB8PSA0IC8qIENSRUFURVNfUkVBTF9TVEFDS0lOR19DT05URVhUICovO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY3JlYXRlc1N0YWNraW5nQ29udGV4dChjb250YWluZXIuc3R5bGVzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lci5mbGFncyB8PSAyIC8qIENSRUFURVNfU1RBQ0tJTkdfQ09OVEVYVCAqLztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChMSVNUX09XTkVSUy5pbmRleE9mKGNoaWxkTm9kZS50YWdOYW1lKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250YWluZXIuZmxhZ3MgfD0gOCAvKiBJU19MSVNUX09XTkVSICovO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50LmVsZW1lbnRzLnB1c2goY29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkTm9kZS5zbG90O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkTm9kZS5zaGFkb3dSb290KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VOb2RlVHJlZShjb250ZXh0LCBjaGlsZE5vZGUuc2hhZG93Um9vdCwgY29udGFpbmVyLCByb290KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFpc1RleHRhcmVhRWxlbWVudChjaGlsZE5vZGUpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIWlzU1ZHRWxlbWVudChjaGlsZE5vZGUpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIWlzU2VsZWN0RWxlbWVudChjaGlsZE5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VOb2RlVHJlZShjb250ZXh0LCBjaGlsZE5vZGUsIGNvbnRhaW5lciwgcm9vdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBjcmVhdGVDb250YWluZXIgPSBmdW5jdGlvbiAoY29udGV4dCwgZWxlbWVudCkge1xuICAgICAgICBpZiAoaXNJbWFnZUVsZW1lbnQoZWxlbWVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW1hZ2VFbGVtZW50Q29udGFpbmVyKGNvbnRleHQsIGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0NhbnZhc0VsZW1lbnQoZWxlbWVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2FudmFzRWxlbWVudENvbnRhaW5lcihjb250ZXh0LCBlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNTVkdFbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNWR0VsZW1lbnRDb250YWluZXIoY29udGV4dCwgZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTElFbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IExJRWxlbWVudENvbnRhaW5lcihjb250ZXh0LCBlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNPTEVsZW1lbnQoZWxlbWVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgT0xFbGVtZW50Q29udGFpbmVyKGNvbnRleHQsIGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0lucHV0RWxlbWVudChlbGVtZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnB1dEVsZW1lbnRDb250YWluZXIoY29udGV4dCwgZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzU2VsZWN0RWxlbWVudChlbGVtZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTZWxlY3RFbGVtZW50Q29udGFpbmVyKGNvbnRleHQsIGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1RleHRhcmVhRWxlbWVudChlbGVtZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBUZXh0YXJlYUVsZW1lbnRDb250YWluZXIoY29udGV4dCwgZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzSUZyYW1lRWxlbWVudChlbGVtZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBJRnJhbWVFbGVtZW50Q29udGFpbmVyKGNvbnRleHQsIGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRWxlbWVudENvbnRhaW5lcihjb250ZXh0LCBlbGVtZW50KTtcbiAgICB9O1xuICAgIHZhciBwYXJzZVRyZWUgPSBmdW5jdGlvbiAoY29udGV4dCwgZWxlbWVudCkge1xuICAgICAgICB2YXIgY29udGFpbmVyID0gY3JlYXRlQ29udGFpbmVyKGNvbnRleHQsIGVsZW1lbnQpO1xuICAgICAgICBjb250YWluZXIuZmxhZ3MgfD0gNCAvKiBDUkVBVEVTX1JFQUxfU1RBQ0tJTkdfQ09OVEVYVCAqLztcbiAgICAgICAgcGFyc2VOb2RlVHJlZShjb250ZXh0LCBlbGVtZW50LCBjb250YWluZXIsIGNvbnRhaW5lcik7XG4gICAgICAgIHJldHVybiBjb250YWluZXI7XG4gICAgfTtcbiAgICB2YXIgY3JlYXRlc1JlYWxTdGFja2luZ0NvbnRleHQgPSBmdW5jdGlvbiAobm9kZSwgY29udGFpbmVyLCByb290KSB7XG4gICAgICAgIHJldHVybiAoY29udGFpbmVyLnN0eWxlcy5pc1Bvc2l0aW9uZWRXaXRoWkluZGV4KCkgfHxcbiAgICAgICAgICAgIGNvbnRhaW5lci5zdHlsZXMub3BhY2l0eSA8IDEgfHxcbiAgICAgICAgICAgIGNvbnRhaW5lci5zdHlsZXMuaXNUcmFuc2Zvcm1lZCgpIHx8XG4gICAgICAgICAgICAoaXNCb2R5RWxlbWVudChub2RlKSAmJiByb290LnN0eWxlcy5pc1RyYW5zcGFyZW50KCkpKTtcbiAgICB9O1xuICAgIHZhciBjcmVhdGVzU3RhY2tpbmdDb250ZXh0ID0gZnVuY3Rpb24gKHN0eWxlcykgeyByZXR1cm4gc3R5bGVzLmlzUG9zaXRpb25lZCgpIHx8IHN0eWxlcy5pc0Zsb2F0aW5nKCk7IH07XG4gICAgdmFyIGlzVGV4dE5vZGUgPSBmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREU7IH07XG4gICAgdmFyIGlzRWxlbWVudE5vZGUgPSBmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREU7IH07XG4gICAgdmFyIGlzSFRNTEVsZW1lbnROb2RlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIGlzRWxlbWVudE5vZGUobm9kZSkgJiYgdHlwZW9mIG5vZGUuc3R5bGUgIT09ICd1bmRlZmluZWQnICYmICFpc1NWR0VsZW1lbnROb2RlKG5vZGUpO1xuICAgIH07XG4gICAgdmFyIGlzU1ZHRWxlbWVudE5vZGUgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIGVsZW1lbnQuY2xhc3NOYW1lID09PSAnb2JqZWN0JztcbiAgICB9O1xuICAgIHZhciBpc0xJRWxlbWVudCA9IGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLnRhZ05hbWUgPT09ICdMSSc7IH07XG4gICAgdmFyIGlzT0xFbGVtZW50ID0gZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUudGFnTmFtZSA9PT0gJ09MJzsgfTtcbiAgICB2YXIgaXNJbnB1dEVsZW1lbnQgPSBmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS50YWdOYW1lID09PSAnSU5QVVQnOyB9O1xuICAgIHZhciBpc0hUTUxFbGVtZW50ID0gZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUudGFnTmFtZSA9PT0gJ0hUTUwnOyB9O1xuICAgIHZhciBpc1NWR0VsZW1lbnQgPSBmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS50YWdOYW1lID09PSAnc3ZnJzsgfTtcbiAgICB2YXIgaXNCb2R5RWxlbWVudCA9IGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLnRhZ05hbWUgPT09ICdCT0RZJzsgfTtcbiAgICB2YXIgaXNDYW52YXNFbGVtZW50ID0gZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUudGFnTmFtZSA9PT0gJ0NBTlZBUyc7IH07XG4gICAgdmFyIGlzVmlkZW9FbGVtZW50ID0gZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUudGFnTmFtZSA9PT0gJ1ZJREVPJzsgfTtcbiAgICB2YXIgaXNJbWFnZUVsZW1lbnQgPSBmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS50YWdOYW1lID09PSAnSU1HJzsgfTtcbiAgICB2YXIgaXNJRnJhbWVFbGVtZW50ID0gZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUudGFnTmFtZSA9PT0gJ0lGUkFNRSc7IH07XG4gICAgdmFyIGlzU3R5bGVFbGVtZW50ID0gZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUudGFnTmFtZSA9PT0gJ1NUWUxFJzsgfTtcbiAgICB2YXIgaXNTY3JpcHRFbGVtZW50ID0gZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUudGFnTmFtZSA9PT0gJ1NDUklQVCc7IH07XG4gICAgdmFyIGlzVGV4dGFyZWFFbGVtZW50ID0gZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUudGFnTmFtZSA9PT0gJ1RFWFRBUkVBJzsgfTtcbiAgICB2YXIgaXNTZWxlY3RFbGVtZW50ID0gZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUudGFnTmFtZSA9PT0gJ1NFTEVDVCc7IH07XG4gICAgdmFyIGlzU2xvdEVsZW1lbnQgPSBmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS50YWdOYW1lID09PSAnU0xPVCc7IH07XG4gICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvY3VzdG9tLWVsZW1lbnRzLmh0bWwjdmFsaWQtY3VzdG9tLWVsZW1lbnQtbmFtZVxuICAgIHZhciBpc0N1c3RvbUVsZW1lbnQgPSBmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS50YWdOYW1lLmluZGV4T2YoJy0nKSA+IDA7IH07XG5cbiAgICB2YXIgQ291bnRlclN0YXRlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBDb3VudGVyU3RhdGUoKSB7XG4gICAgICAgICAgICB0aGlzLmNvdW50ZXJzID0ge307XG4gICAgICAgIH1cbiAgICAgICAgQ291bnRlclN0YXRlLnByb3RvdHlwZS5nZXRDb3VudGVyVmFsdWUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgdmFyIGNvdW50ZXIgPSB0aGlzLmNvdW50ZXJzW25hbWVdO1xuICAgICAgICAgICAgaWYgKGNvdW50ZXIgJiYgY291bnRlci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY291bnRlcltjb3VudGVyLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH07XG4gICAgICAgIENvdW50ZXJTdGF0ZS5wcm90b3R5cGUuZ2V0Q291bnRlclZhbHVlcyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICB2YXIgY291bnRlciA9IHRoaXMuY291bnRlcnNbbmFtZV07XG4gICAgICAgICAgICByZXR1cm4gY291bnRlciA/IGNvdW50ZXIgOiBbXTtcbiAgICAgICAgfTtcbiAgICAgICAgQ291bnRlclN0YXRlLnByb3RvdHlwZS5wb3AgPSBmdW5jdGlvbiAoY291bnRlcnMpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICBjb3VudGVycy5mb3JFYWNoKGZ1bmN0aW9uIChjb3VudGVyKSB7IHJldHVybiBfdGhpcy5jb3VudGVyc1tjb3VudGVyXS5wb3AoKTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIENvdW50ZXJTdGF0ZS5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoc3R5bGUpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgY291bnRlckluY3JlbWVudCA9IHN0eWxlLmNvdW50ZXJJbmNyZW1lbnQ7XG4gICAgICAgICAgICB2YXIgY291bnRlclJlc2V0ID0gc3R5bGUuY291bnRlclJlc2V0O1xuICAgICAgICAgICAgdmFyIGNhblJlc2V0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChjb3VudGVySW5jcmVtZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY291bnRlckluY3JlbWVudC5mb3JFYWNoKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY291bnRlciA9IF90aGlzLmNvdW50ZXJzW2VudHJ5LmNvdW50ZXJdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY291bnRlciAmJiBlbnRyeS5pbmNyZW1lbnQgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhblJlc2V0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNvdW50ZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlci5wdXNoKDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlcltNYXRoLm1heCgwLCBjb3VudGVyLmxlbmd0aCAtIDEpXSArPSBlbnRyeS5pbmNyZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjb3VudGVyTmFtZXMgPSBbXTtcbiAgICAgICAgICAgIGlmIChjYW5SZXNldCkge1xuICAgICAgICAgICAgICAgIGNvdW50ZXJSZXNldC5mb3JFYWNoKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY291bnRlciA9IF90aGlzLmNvdW50ZXJzW2VudHJ5LmNvdW50ZXJdO1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyTmFtZXMucHVzaChlbnRyeS5jb3VudGVyKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb3VudGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyID0gX3RoaXMuY291bnRlcnNbZW50cnkuY291bnRlcl0gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb3VudGVyLnB1c2goZW50cnkucmVzZXQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvdW50ZXJOYW1lcztcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIENvdW50ZXJTdGF0ZTtcbiAgICB9KCkpO1xuICAgIHZhciBST01BTl9VUFBFUiA9IHtcbiAgICAgICAgaW50ZWdlcnM6IFsxMDAwLCA5MDAsIDUwMCwgNDAwLCAxMDAsIDkwLCA1MCwgNDAsIDEwLCA5LCA1LCA0LCAxXSxcbiAgICAgICAgdmFsdWVzOiBbJ00nLCAnQ00nLCAnRCcsICdDRCcsICdDJywgJ1hDJywgJ0wnLCAnWEwnLCAnWCcsICdJWCcsICdWJywgJ0lWJywgJ0knXVxuICAgIH07XG4gICAgdmFyIEFSTUVOSUFOID0ge1xuICAgICAgICBpbnRlZ2VyczogW1xuICAgICAgICAgICAgOTAwMCwgODAwMCwgNzAwMCwgNjAwMCwgNTAwMCwgNDAwMCwgMzAwMCwgMjAwMCwgMTAwMCwgOTAwLCA4MDAsIDcwMCwgNjAwLCA1MDAsIDQwMCwgMzAwLCAyMDAsIDEwMCwgOTAsIDgwLCA3MCxcbiAgICAgICAgICAgIDYwLCA1MCwgNDAsIDMwLCAyMCwgMTAsIDksIDgsIDcsIDYsIDUsIDQsIDMsIDIsIDFcbiAgICAgICAgXSxcbiAgICAgICAgdmFsdWVzOiBbXG4gICAgICAgICAgICAn1ZQnLFxuICAgICAgICAgICAgJ9WTJyxcbiAgICAgICAgICAgICfVkicsXG4gICAgICAgICAgICAn1ZEnLFxuICAgICAgICAgICAgJ9WQJyxcbiAgICAgICAgICAgICfVjycsXG4gICAgICAgICAgICAn1Y4nLFxuICAgICAgICAgICAgJ9WNJyxcbiAgICAgICAgICAgICfVjCcsXG4gICAgICAgICAgICAn1YsnLFxuICAgICAgICAgICAgJ9WKJyxcbiAgICAgICAgICAgICfViScsXG4gICAgICAgICAgICAn1YgnLFxuICAgICAgICAgICAgJ9WHJyxcbiAgICAgICAgICAgICfVhicsXG4gICAgICAgICAgICAn1YUnLFxuICAgICAgICAgICAgJ9WEJyxcbiAgICAgICAgICAgICfVgycsXG4gICAgICAgICAgICAn1YInLFxuICAgICAgICAgICAgJ9WBJyxcbiAgICAgICAgICAgICfVgCcsXG4gICAgICAgICAgICAn1L8nLFxuICAgICAgICAgICAgJ9S+JyxcbiAgICAgICAgICAgICfUvScsXG4gICAgICAgICAgICAn1LwnLFxuICAgICAgICAgICAgJ9S7JyxcbiAgICAgICAgICAgICfUuicsXG4gICAgICAgICAgICAn1LknLFxuICAgICAgICAgICAgJ9S4JyxcbiAgICAgICAgICAgICfUtycsXG4gICAgICAgICAgICAn1LYnLFxuICAgICAgICAgICAgJ9S1JyxcbiAgICAgICAgICAgICfUtCcsXG4gICAgICAgICAgICAn1LMnLFxuICAgICAgICAgICAgJ9SyJyxcbiAgICAgICAgICAgICfUsSdcbiAgICAgICAgXVxuICAgIH07XG4gICAgdmFyIEhFQlJFVyA9IHtcbiAgICAgICAgaW50ZWdlcnM6IFtcbiAgICAgICAgICAgIDEwMDAwLCA5MDAwLCA4MDAwLCA3MDAwLCA2MDAwLCA1MDAwLCA0MDAwLCAzMDAwLCAyMDAwLCAxMDAwLCA0MDAsIDMwMCwgMjAwLCAxMDAsIDkwLCA4MCwgNzAsIDYwLCA1MCwgNDAsIDMwLCAyMCxcbiAgICAgICAgICAgIDE5LCAxOCwgMTcsIDE2LCAxNSwgMTAsIDksIDgsIDcsIDYsIDUsIDQsIDMsIDIsIDFcbiAgICAgICAgXSxcbiAgICAgICAgdmFsdWVzOiBbXG4gICAgICAgICAgICAn15nXsycsXG4gICAgICAgICAgICAn15jXsycsXG4gICAgICAgICAgICAn15fXsycsXG4gICAgICAgICAgICAn15bXsycsXG4gICAgICAgICAgICAn15XXsycsXG4gICAgICAgICAgICAn15TXsycsXG4gICAgICAgICAgICAn15PXsycsXG4gICAgICAgICAgICAn15LXsycsXG4gICAgICAgICAgICAn15HXsycsXG4gICAgICAgICAgICAn15DXsycsXG4gICAgICAgICAgICAn16onLFxuICAgICAgICAgICAgJ9epJyxcbiAgICAgICAgICAgICfXqCcsXG4gICAgICAgICAgICAn16cnLFxuICAgICAgICAgICAgJ9emJyxcbiAgICAgICAgICAgICfXpCcsXG4gICAgICAgICAgICAn16InLFxuICAgICAgICAgICAgJ9ehJyxcbiAgICAgICAgICAgICfXoCcsXG4gICAgICAgICAgICAn154nLFxuICAgICAgICAgICAgJ9ecJyxcbiAgICAgICAgICAgICfXmycsXG4gICAgICAgICAgICAn15nXmCcsXG4gICAgICAgICAgICAn15nXlycsXG4gICAgICAgICAgICAn15nXlicsXG4gICAgICAgICAgICAn15jXlicsXG4gICAgICAgICAgICAn15jXlScsXG4gICAgICAgICAgICAn15knLFxuICAgICAgICAgICAgJ9eYJyxcbiAgICAgICAgICAgICfXlycsXG4gICAgICAgICAgICAn15YnLFxuICAgICAgICAgICAgJ9eVJyxcbiAgICAgICAgICAgICfXlCcsXG4gICAgICAgICAgICAn15MnLFxuICAgICAgICAgICAgJ9eSJyxcbiAgICAgICAgICAgICfXkScsXG4gICAgICAgICAgICAn15AnXG4gICAgICAgIF1cbiAgICB9O1xuICAgIHZhciBHRU9SR0lBTiA9IHtcbiAgICAgICAgaW50ZWdlcnM6IFtcbiAgICAgICAgICAgIDEwMDAwLCA5MDAwLCA4MDAwLCA3MDAwLCA2MDAwLCA1MDAwLCA0MDAwLCAzMDAwLCAyMDAwLCAxMDAwLCA5MDAsIDgwMCwgNzAwLCA2MDAsIDUwMCwgNDAwLCAzMDAsIDIwMCwgMTAwLCA5MCxcbiAgICAgICAgICAgIDgwLCA3MCwgNjAsIDUwLCA0MCwgMzAsIDIwLCAxMCwgOSwgOCwgNywgNiwgNSwgNCwgMywgMiwgMVxuICAgICAgICBdLFxuICAgICAgICB2YWx1ZXM6IFtcbiAgICAgICAgICAgICfhg7UnLFxuICAgICAgICAgICAgJ+GDsCcsXG4gICAgICAgICAgICAn4YOvJyxcbiAgICAgICAgICAgICfhg7QnLFxuICAgICAgICAgICAgJ+GDricsXG4gICAgICAgICAgICAn4YOtJyxcbiAgICAgICAgICAgICfhg6wnLFxuICAgICAgICAgICAgJ+GDqycsXG4gICAgICAgICAgICAn4YOqJyxcbiAgICAgICAgICAgICfhg6knLFxuICAgICAgICAgICAgJ+GDqCcsXG4gICAgICAgICAgICAn4YOnJyxcbiAgICAgICAgICAgICfhg6YnLFxuICAgICAgICAgICAgJ+GDpScsXG4gICAgICAgICAgICAn4YOkJyxcbiAgICAgICAgICAgICfhg7MnLFxuICAgICAgICAgICAgJ+GDoicsXG4gICAgICAgICAgICAn4YOhJyxcbiAgICAgICAgICAgICfhg6AnLFxuICAgICAgICAgICAgJ+GDnycsXG4gICAgICAgICAgICAn4YOeJyxcbiAgICAgICAgICAgICfhg50nLFxuICAgICAgICAgICAgJ+GDsicsXG4gICAgICAgICAgICAn4YOcJyxcbiAgICAgICAgICAgICfhg5snLFxuICAgICAgICAgICAgJ+GDmicsXG4gICAgICAgICAgICAn4YOZJyxcbiAgICAgICAgICAgICfhg5gnLFxuICAgICAgICAgICAgJ+GDlycsXG4gICAgICAgICAgICAn4YOxJyxcbiAgICAgICAgICAgICfhg5YnLFxuICAgICAgICAgICAgJ+GDlScsXG4gICAgICAgICAgICAn4YOUJyxcbiAgICAgICAgICAgICfhg5MnLFxuICAgICAgICAgICAgJ+GDkicsXG4gICAgICAgICAgICAn4YORJyxcbiAgICAgICAgICAgICfhg5AnXG4gICAgICAgIF1cbiAgICB9O1xuICAgIHZhciBjcmVhdGVBZGRpdGl2ZUNvdW50ZXIgPSBmdW5jdGlvbiAodmFsdWUsIG1pbiwgbWF4LCBzeW1ib2xzLCBmYWxsYmFjaywgc3VmZml4KSB7XG4gICAgICAgIGlmICh2YWx1ZSA8IG1pbiB8fCB2YWx1ZSA+IG1heCkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvdW50ZXJUZXh0KHZhbHVlLCBmYWxsYmFjaywgc3VmZml4Lmxlbmd0aCA+IDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoc3ltYm9scy5pbnRlZ2Vycy5yZWR1Y2UoZnVuY3Rpb24gKHN0cmluZywgaW50ZWdlciwgaW5kZXgpIHtcbiAgICAgICAgICAgIHdoaWxlICh2YWx1ZSA+PSBpbnRlZ2VyKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgLT0gaW50ZWdlcjtcbiAgICAgICAgICAgICAgICBzdHJpbmcgKz0gc3ltYm9scy52YWx1ZXNbaW5kZXhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgICAgfSwgJycpICsgc3VmZml4KTtcbiAgICB9O1xuICAgIHZhciBjcmVhdGVDb3VudGVyU3R5bGVXaXRoU3ltYm9sUmVzb2x2ZXIgPSBmdW5jdGlvbiAodmFsdWUsIGNvZGVQb2ludFJhbmdlTGVuZ3RoLCBpc051bWVyaWMsIHJlc29sdmVyKSB7XG4gICAgICAgIHZhciBzdHJpbmcgPSAnJztcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgaWYgKCFpc051bWVyaWMpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZS0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RyaW5nID0gcmVzb2x2ZXIodmFsdWUpICsgc3RyaW5nO1xuICAgICAgICAgICAgdmFsdWUgLz0gY29kZVBvaW50UmFuZ2VMZW5ndGg7XG4gICAgICAgIH0gd2hpbGUgKHZhbHVlICogY29kZVBvaW50UmFuZ2VMZW5ndGggPj0gY29kZVBvaW50UmFuZ2VMZW5ndGgpO1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgIH07XG4gICAgdmFyIGNyZWF0ZUNvdW50ZXJTdHlsZUZyb21SYW5nZSA9IGZ1bmN0aW9uICh2YWx1ZSwgY29kZVBvaW50UmFuZ2VTdGFydCwgY29kZVBvaW50UmFuZ2VFbmQsIGlzTnVtZXJpYywgc3VmZml4KSB7XG4gICAgICAgIHZhciBjb2RlUG9pbnRSYW5nZUxlbmd0aCA9IGNvZGVQb2ludFJhbmdlRW5kIC0gY29kZVBvaW50UmFuZ2VTdGFydCArIDE7XG4gICAgICAgIHJldHVybiAoKHZhbHVlIDwgMCA/ICctJyA6ICcnKSArXG4gICAgICAgICAgICAoY3JlYXRlQ291bnRlclN0eWxlV2l0aFN5bWJvbFJlc29sdmVyKE1hdGguYWJzKHZhbHVlKSwgY29kZVBvaW50UmFuZ2VMZW5ndGgsIGlzTnVtZXJpYywgZnVuY3Rpb24gKGNvZGVQb2ludCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmcm9tQ29kZVBvaW50JDEoTWF0aC5mbG9vcihjb2RlUG9pbnQgJSBjb2RlUG9pbnRSYW5nZUxlbmd0aCkgKyBjb2RlUG9pbnRSYW5nZVN0YXJ0KTtcbiAgICAgICAgICAgIH0pICtcbiAgICAgICAgICAgICAgICBzdWZmaXgpKTtcbiAgICB9O1xuICAgIHZhciBjcmVhdGVDb3VudGVyU3R5bGVGcm9tU3ltYm9scyA9IGZ1bmN0aW9uICh2YWx1ZSwgc3ltYm9scywgc3VmZml4KSB7XG4gICAgICAgIGlmIChzdWZmaXggPT09IHZvaWQgMCkgeyBzdWZmaXggPSAnLiAnOyB9XG4gICAgICAgIHZhciBjb2RlUG9pbnRSYW5nZUxlbmd0aCA9IHN5bWJvbHMubGVuZ3RoO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUNvdW50ZXJTdHlsZVdpdGhTeW1ib2xSZXNvbHZlcihNYXRoLmFicyh2YWx1ZSksIGNvZGVQb2ludFJhbmdlTGVuZ3RoLCBmYWxzZSwgZnVuY3Rpb24gKGNvZGVQb2ludCkgeyByZXR1cm4gc3ltYm9sc1tNYXRoLmZsb29yKGNvZGVQb2ludCAlIGNvZGVQb2ludFJhbmdlTGVuZ3RoKV07IH0pICsgc3VmZml4KTtcbiAgICB9O1xuICAgIHZhciBDSktfWkVST1MgPSAxIDw8IDA7XG4gICAgdmFyIENKS19URU5fQ09FRkZJQ0lFTlRTID0gMSA8PCAxO1xuICAgIHZhciBDSktfVEVOX0hJR0hfQ09FRkZJQ0lFTlRTID0gMSA8PCAyO1xuICAgIHZhciBDSktfSFVORFJFRF9DT0VGRklDSUVOVFMgPSAxIDw8IDM7XG4gICAgdmFyIGNyZWF0ZUNKS0NvdW50ZXIgPSBmdW5jdGlvbiAodmFsdWUsIG51bWJlcnMsIG11bHRpcGxpZXJzLCBuZWdhdGl2ZVNpZ24sIHN1ZmZpeCwgZmxhZ3MpIHtcbiAgICAgICAgaWYgKHZhbHVlIDwgLTk5OTkgfHwgdmFsdWUgPiA5OTk5KSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlQ291bnRlclRleHQodmFsdWUsIDQgLyogQ0pLX0RFQ0lNQUwgKi8sIHN1ZmZpeC5sZW5ndGggPiAwKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdG1wID0gTWF0aC5hYnModmFsdWUpO1xuICAgICAgICB2YXIgc3RyaW5nID0gc3VmZml4O1xuICAgICAgICBpZiAodG1wID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyc1swXSArIHN0cmluZztcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBkaWdpdCA9IDA7IHRtcCA+IDAgJiYgZGlnaXQgPD0gNDsgZGlnaXQrKykge1xuICAgICAgICAgICAgdmFyIGNvZWZmaWNpZW50ID0gdG1wICUgMTA7XG4gICAgICAgICAgICBpZiAoY29lZmZpY2llbnQgPT09IDAgJiYgY29udGFpbnMoZmxhZ3MsIENKS19aRVJPUykgJiYgc3RyaW5nICE9PSAnJykge1xuICAgICAgICAgICAgICAgIHN0cmluZyA9IG51bWJlcnNbY29lZmZpY2llbnRdICsgc3RyaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY29lZmZpY2llbnQgPiAxIHx8XG4gICAgICAgICAgICAgICAgKGNvZWZmaWNpZW50ID09PSAxICYmIGRpZ2l0ID09PSAwKSB8fFxuICAgICAgICAgICAgICAgIChjb2VmZmljaWVudCA9PT0gMSAmJiBkaWdpdCA9PT0gMSAmJiBjb250YWlucyhmbGFncywgQ0pLX1RFTl9DT0VGRklDSUVOVFMpKSB8fFxuICAgICAgICAgICAgICAgIChjb2VmZmljaWVudCA9PT0gMSAmJiBkaWdpdCA9PT0gMSAmJiBjb250YWlucyhmbGFncywgQ0pLX1RFTl9ISUdIX0NPRUZGSUNJRU5UUykgJiYgdmFsdWUgPiAxMDApIHx8XG4gICAgICAgICAgICAgICAgKGNvZWZmaWNpZW50ID09PSAxICYmIGRpZ2l0ID4gMSAmJiBjb250YWlucyhmbGFncywgQ0pLX0hVTkRSRURfQ09FRkZJQ0lFTlRTKSkpIHtcbiAgICAgICAgICAgICAgICBzdHJpbmcgPSBudW1iZXJzW2NvZWZmaWNpZW50XSArIChkaWdpdCA+IDAgPyBtdWx0aXBsaWVyc1tkaWdpdCAtIDFdIDogJycpICsgc3RyaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY29lZmZpY2llbnQgPT09IDEgJiYgZGlnaXQgPiAwKSB7XG4gICAgICAgICAgICAgICAgc3RyaW5nID0gbXVsdGlwbGllcnNbZGlnaXQgLSAxXSArIHN0cmluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRtcCA9IE1hdGguZmxvb3IodG1wIC8gMTApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAodmFsdWUgPCAwID8gbmVnYXRpdmVTaWduIDogJycpICsgc3RyaW5nO1xuICAgIH07XG4gICAgdmFyIENISU5FU0VfSU5GT1JNQUxfTVVMVElQTElFUlMgPSAn5Y2B55m+5Y2D6JCsJztcbiAgICB2YXIgQ0hJTkVTRV9GT1JNQUxfTVVMVElQTElFUlMgPSAn5ou+5L2w5Luf6JCsJztcbiAgICB2YXIgSkFQQU5FU0VfTkVHQVRJVkUgPSAn44Oe44Kk44OK44K5JztcbiAgICB2YXIgS09SRUFOX05FR0FUSVZFID0gJ+uniOydtOuEiOyKpCc7XG4gICAgdmFyIGNyZWF0ZUNvdW50ZXJUZXh0ID0gZnVuY3Rpb24gKHZhbHVlLCB0eXBlLCBhcHBlbmRTdWZmaXgpIHtcbiAgICAgICAgdmFyIGRlZmF1bHRTdWZmaXggPSBhcHBlbmRTdWZmaXggPyAnLiAnIDogJyc7XG4gICAgICAgIHZhciBjamtTdWZmaXggPSBhcHBlbmRTdWZmaXggPyAn44CBJyA6ICcnO1xuICAgICAgICB2YXIga29yZWFuU3VmZml4ID0gYXBwZW5kU3VmZml4ID8gJywgJyA6ICcnO1xuICAgICAgICB2YXIgc3BhY2VTdWZmaXggPSBhcHBlbmRTdWZmaXggPyAnICcgOiAnJztcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlIDAgLyogRElTQyAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ+KAoicgKyBzcGFjZVN1ZmZpeDtcbiAgICAgICAgICAgIGNhc2UgMSAvKiBDSVJDTEUgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuICfil6YnICsgc3BhY2VTdWZmaXg7XG4gICAgICAgICAgICBjYXNlIDIgLyogU1FVQVJFICovOlxuICAgICAgICAgICAgICAgIHJldHVybiAn4pe+JyArIHNwYWNlU3VmZml4O1xuICAgICAgICAgICAgY2FzZSA1IC8qIERFQ0lNQUxfTEVBRElOR19aRVJPICovOlxuICAgICAgICAgICAgICAgIHZhciBzdHJpbmcgPSBjcmVhdGVDb3VudGVyU3R5bGVGcm9tUmFuZ2UodmFsdWUsIDQ4LCA1NywgdHJ1ZSwgZGVmYXVsdFN1ZmZpeCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZy5sZW5ndGggPCA0ID8gXCIwXCIgKyBzdHJpbmcgOiBzdHJpbmc7XG4gICAgICAgICAgICBjYXNlIDQgLyogQ0pLX0RFQ0lNQUwgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvdW50ZXJTdHlsZUZyb21TeW1ib2xzKHZhbHVlLCAn44CH5LiA5LqM5LiJ5Zub5LqU5YWt5LiD5YWr5LmdJywgY2prU3VmZml4KTtcbiAgICAgICAgICAgIGNhc2UgNiAvKiBMT1dFUl9ST01BTiAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQWRkaXRpdmVDb3VudGVyKHZhbHVlLCAxLCAzOTk5LCBST01BTl9VUFBFUiwgMyAvKiBERUNJTUFMICovLCBkZWZhdWx0U3VmZml4KS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgY2FzZSA3IC8qIFVQUEVSX1JPTUFOICovOlxuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVBZGRpdGl2ZUNvdW50ZXIodmFsdWUsIDEsIDM5OTksIFJPTUFOX1VQUEVSLCAzIC8qIERFQ0lNQUwgKi8sIGRlZmF1bHRTdWZmaXgpO1xuICAgICAgICAgICAgY2FzZSA4IC8qIExPV0VSX0dSRUVLICovOlxuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb3VudGVyU3R5bGVGcm9tUmFuZ2UodmFsdWUsIDk0NSwgOTY5LCBmYWxzZSwgZGVmYXVsdFN1ZmZpeCk7XG4gICAgICAgICAgICBjYXNlIDkgLyogTE9XRVJfQUxQSEEgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvdW50ZXJTdHlsZUZyb21SYW5nZSh2YWx1ZSwgOTcsIDEyMiwgZmFsc2UsIGRlZmF1bHRTdWZmaXgpO1xuICAgICAgICAgICAgY2FzZSAxMCAvKiBVUFBFUl9BTFBIQSAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ291bnRlclN0eWxlRnJvbVJhbmdlKHZhbHVlLCA2NSwgOTAsIGZhbHNlLCBkZWZhdWx0U3VmZml4KTtcbiAgICAgICAgICAgIGNhc2UgMTEgLyogQVJBQklDX0lORElDICovOlxuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb3VudGVyU3R5bGVGcm9tUmFuZ2UodmFsdWUsIDE2MzIsIDE2NDEsIHRydWUsIGRlZmF1bHRTdWZmaXgpO1xuICAgICAgICAgICAgY2FzZSAxMiAvKiBBUk1FTklBTiAqLzpcbiAgICAgICAgICAgIGNhc2UgNDkgLyogVVBQRVJfQVJNRU5JQU4gKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUFkZGl0aXZlQ291bnRlcih2YWx1ZSwgMSwgOTk5OSwgQVJNRU5JQU4sIDMgLyogREVDSU1BTCAqLywgZGVmYXVsdFN1ZmZpeCk7XG4gICAgICAgICAgICBjYXNlIDM1IC8qIExPV0VSX0FSTUVOSUFOICovOlxuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVBZGRpdGl2ZUNvdW50ZXIodmFsdWUsIDEsIDk5OTksIEFSTUVOSUFOLCAzIC8qIERFQ0lNQUwgKi8sIGRlZmF1bHRTdWZmaXgpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBjYXNlIDEzIC8qIEJFTkdBTEkgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvdW50ZXJTdHlsZUZyb21SYW5nZSh2YWx1ZSwgMjUzNCwgMjU0MywgdHJ1ZSwgZGVmYXVsdFN1ZmZpeCk7XG4gICAgICAgICAgICBjYXNlIDE0IC8qIENBTUJPRElBTiAqLzpcbiAgICAgICAgICAgIGNhc2UgMzAgLyogS0hNRVIgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvdW50ZXJTdHlsZUZyb21SYW5nZSh2YWx1ZSwgNjExMiwgNjEyMSwgdHJ1ZSwgZGVmYXVsdFN1ZmZpeCk7XG4gICAgICAgICAgICBjYXNlIDE1IC8qIENKS19FQVJUSExZX0JSQU5DSCAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ291bnRlclN0eWxlRnJvbVN5bWJvbHModmFsdWUsICflrZDkuJHlr4Xlja/ovrDlt7PljYjmnKrnlLPphYnmiIzkuqUnLCBjamtTdWZmaXgpO1xuICAgICAgICAgICAgY2FzZSAxNiAvKiBDSktfSEVBVkVOTFlfU1RFTSAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ291bnRlclN0eWxlRnJvbVN5bWJvbHModmFsdWUsICfnlLLkuZnkuJnkuIHmiIrlt7Hluprovpvlo6znmbgnLCBjamtTdWZmaXgpO1xuICAgICAgICAgICAgY2FzZSAxNyAvKiBDSktfSURFT0dSQVBISUMgKi86XG4gICAgICAgICAgICBjYXNlIDQ4IC8qIFRSQURfQ0hJTkVTRV9JTkZPUk1BTCAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ0pLQ291bnRlcih2YWx1ZSwgJ+mbtuS4gOS6jOS4ieWbm+S6lOWFreS4g+WFq+S5nScsIENISU5FU0VfSU5GT1JNQUxfTVVMVElQTElFUlMsICfosqAnLCBjamtTdWZmaXgsIENKS19URU5fQ09FRkZJQ0lFTlRTIHwgQ0pLX1RFTl9ISUdIX0NPRUZGSUNJRU5UUyB8IENKS19IVU5EUkVEX0NPRUZGSUNJRU5UUyk7XG4gICAgICAgICAgICBjYXNlIDQ3IC8qIFRSQURfQ0hJTkVTRV9GT1JNQUwgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNKS0NvdW50ZXIodmFsdWUsICfpm7blo7nosrPlj4PogobkvI3pmbjmn5LmjYznjpYnLCBDSElORVNFX0ZPUk1BTF9NVUxUSVBMSUVSUywgJ+iyoCcsIGNqa1N1ZmZpeCwgQ0pLX1pFUk9TIHwgQ0pLX1RFTl9DT0VGRklDSUVOVFMgfCBDSktfVEVOX0hJR0hfQ09FRkZJQ0lFTlRTIHwgQ0pLX0hVTkRSRURfQ09FRkZJQ0lFTlRTKTtcbiAgICAgICAgICAgIGNhc2UgNDIgLyogU0lNUF9DSElORVNFX0lORk9STUFMICovOlxuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDSktDb3VudGVyKHZhbHVlLCAn6Zu25LiA5LqM5LiJ5Zub5LqU5YWt5LiD5YWr5LmdJywgQ0hJTkVTRV9JTkZPUk1BTF9NVUxUSVBMSUVSUywgJ+i0nycsIGNqa1N1ZmZpeCwgQ0pLX1RFTl9DT0VGRklDSUVOVFMgfCBDSktfVEVOX0hJR0hfQ09FRkZJQ0lFTlRTIHwgQ0pLX0hVTkRSRURfQ09FRkZJQ0lFTlRTKTtcbiAgICAgICAgICAgIGNhc2UgNDEgLyogU0lNUF9DSElORVNFX0ZPUk1BTCAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ0pLQ291bnRlcih2YWx1ZSwgJ+mbtuWjuei0sOWPgeiChuS8jemZhuafkuaNjOeOlicsIENISU5FU0VfRk9STUFMX01VTFRJUExJRVJTLCAn6LSfJywgY2prU3VmZml4LCBDSktfWkVST1MgfCBDSktfVEVOX0NPRUZGSUNJRU5UUyB8IENKS19URU5fSElHSF9DT0VGRklDSUVOVFMgfCBDSktfSFVORFJFRF9DT0VGRklDSUVOVFMpO1xuICAgICAgICAgICAgY2FzZSAyNiAvKiBKQVBBTkVTRV9JTkZPUk1BTCAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ0pLQ291bnRlcih2YWx1ZSwgJ+OAh+S4gOS6jOS4ieWbm+S6lOWFreS4g+WFq+S5nScsICfljYHnmb7ljYPkuIcnLCBKQVBBTkVTRV9ORUdBVElWRSwgY2prU3VmZml4LCAwKTtcbiAgICAgICAgICAgIGNhc2UgMjUgLyogSkFQQU5FU0VfRk9STUFMICovOlxuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDSktDb3VudGVyKHZhbHVlLCAn6Zu25aOx5byQ5Y+C5Zub5LyN5YWt5LiD5YWr5LmdJywgJ+aLvueZvuWNg+S4hycsIEpBUEFORVNFX05FR0FUSVZFLCBjamtTdWZmaXgsIENKS19aRVJPUyB8IENKS19URU5fQ09FRkZJQ0lFTlRTIHwgQ0pLX1RFTl9ISUdIX0NPRUZGSUNJRU5UUyk7XG4gICAgICAgICAgICBjYXNlIDMxIC8qIEtPUkVBTl9IQU5HVUxfRk9STUFMICovOlxuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDSktDb3VudGVyKHZhbHVlLCAn7JiB7J287J207IK87IKs7Jik7Jyh7Lmg7YyU6rWsJywgJ+yLreuwseyynOunjCcsIEtPUkVBTl9ORUdBVElWRSwga29yZWFuU3VmZml4LCBDSktfWkVST1MgfCBDSktfVEVOX0NPRUZGSUNJRU5UUyB8IENKS19URU5fSElHSF9DT0VGRklDSUVOVFMpO1xuICAgICAgICAgICAgY2FzZSAzMyAvKiBLT1JFQU5fSEFOSkFfSU5GT1JNQUwgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNKS0NvdW50ZXIodmFsdWUsICfpm7bkuIDkuozkuInlm5vkupTlha3kuIPlhavkuZ0nLCAn5Y2B55m+5Y2D6JCsJywgS09SRUFOX05FR0FUSVZFLCBrb3JlYW5TdWZmaXgsIDApO1xuICAgICAgICAgICAgY2FzZSAzMiAvKiBLT1JFQU5fSEFOSkFfRk9STUFMICovOlxuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDSktDb3VudGVyKHZhbHVlLCAn6Zu25aO56LKz5Y+D5Zub5LqU5YWt5LiD5YWr5LmdJywgJ+aLvueZvuWNgycsIEtPUkVBTl9ORUdBVElWRSwga29yZWFuU3VmZml4LCBDSktfWkVST1MgfCBDSktfVEVOX0NPRUZGSUNJRU5UUyB8IENKS19URU5fSElHSF9DT0VGRklDSUVOVFMpO1xuICAgICAgICAgICAgY2FzZSAxOCAvKiBERVZBTkFHQVJJICovOlxuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb3VudGVyU3R5bGVGcm9tUmFuZ2UodmFsdWUsIDB4OTY2LCAweDk2ZiwgdHJ1ZSwgZGVmYXVsdFN1ZmZpeCk7XG4gICAgICAgICAgICBjYXNlIDIwIC8qIEdFT1JHSUFOICovOlxuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVBZGRpdGl2ZUNvdW50ZXIodmFsdWUsIDEsIDE5OTk5LCBHRU9SR0lBTiwgMyAvKiBERUNJTUFMICovLCBkZWZhdWx0U3VmZml4KTtcbiAgICAgICAgICAgIGNhc2UgMjEgLyogR1VKQVJBVEkgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvdW50ZXJTdHlsZUZyb21SYW5nZSh2YWx1ZSwgMHhhZTYsIDB4YWVmLCB0cnVlLCBkZWZhdWx0U3VmZml4KTtcbiAgICAgICAgICAgIGNhc2UgMjIgLyogR1VSTVVLSEkgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvdW50ZXJTdHlsZUZyb21SYW5nZSh2YWx1ZSwgMHhhNjYsIDB4YTZmLCB0cnVlLCBkZWZhdWx0U3VmZml4KTtcbiAgICAgICAgICAgIGNhc2UgMjIgLyogSEVCUkVXICovOlxuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVBZGRpdGl2ZUNvdW50ZXIodmFsdWUsIDEsIDEwOTk5LCBIRUJSRVcsIDMgLyogREVDSU1BTCAqLywgZGVmYXVsdFN1ZmZpeCk7XG4gICAgICAgICAgICBjYXNlIDIzIC8qIEhJUkFHQU5BICovOlxuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb3VudGVyU3R5bGVGcm9tU3ltYm9scyh2YWx1ZSwgJ+OBguOBhOOBhuOBiOOBiuOBi+OBjeOBj+OBkeOBk+OBleOBl+OBmeOBm+OBneOBn+OBoeOBpOOBpuOBqOOBquOBq+OBrOOBreOBruOBr+OBsuOBteOBuOOBu+OBvuOBv+OCgOOCgeOCguOChOOChuOCiOOCieOCiuOCi+OCjOOCjeOCj+OCkOOCkeOCkuOCkycpO1xuICAgICAgICAgICAgY2FzZSAyNCAvKiBISVJBR0FOQV9JUk9IQSAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ291bnRlclN0eWxlRnJvbVN5bWJvbHModmFsdWUsICfjgYTjgo3jga/jgavjgbvjgbjjgajjgaHjgorjgazjgovjgpLjgo/jgYvjgojjgZ/jgozjgZ3jgaTjga3jgarjgonjgoDjgYbjgpDjga7jgYrjgY/jgoTjgb7jgZHjgbXjgZPjgYjjgabjgYLjgZXjgY3jgobjgoHjgb/jgZfjgpHjgbLjgoLjgZvjgZknKTtcbiAgICAgICAgICAgIGNhc2UgMjcgLyogS0FOTkFEQSAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ291bnRlclN0eWxlRnJvbVJhbmdlKHZhbHVlLCAweGNlNiwgMHhjZWYsIHRydWUsIGRlZmF1bHRTdWZmaXgpO1xuICAgICAgICAgICAgY2FzZSAyOCAvKiBLQVRBS0FOQSAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ291bnRlclN0eWxlRnJvbVN5bWJvbHModmFsdWUsICfjgqLjgqTjgqbjgqjjgqrjgqvjgq3jgq/jgrHjgrPjgrXjgrfjgrnjgrvjgr3jgr/jg4Hjg4Tjg4bjg4jjg4rjg4vjg4zjg43jg47jg4/jg5Ljg5Xjg5jjg5vjg57jg5/jg6Djg6Hjg6Ljg6Tjg6bjg6jjg6njg6rjg6vjg6zjg63jg6/jg7Djg7Hjg7Ljg7MnLCBjamtTdWZmaXgpO1xuICAgICAgICAgICAgY2FzZSAyOSAvKiBLQVRBS0FOQV9JUk9IQSAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ291bnRlclN0eWxlRnJvbVN5bWJvbHModmFsdWUsICfjgqTjg63jg4/jg4vjg5vjg5jjg4jjg4Hjg6rjg4zjg6vjg7Ljg6/jgqvjg6jjgr/jg6zjgr3jg4Tjg43jg4rjg6njg6Djgqbjg7Djg47jgqrjgq/jg6Tjg57jgrHjg5XjgrPjgqjjg4bjgqLjgrXjgq3jg6bjg6Hjg5/jgrfjg7Hjg5Ljg6LjgrvjgrknLCBjamtTdWZmaXgpO1xuICAgICAgICAgICAgY2FzZSAzNCAvKiBMQU8gKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvdW50ZXJTdHlsZUZyb21SYW5nZSh2YWx1ZSwgMHhlZDAsIDB4ZWQ5LCB0cnVlLCBkZWZhdWx0U3VmZml4KTtcbiAgICAgICAgICAgIGNhc2UgMzcgLyogTU9OR09MSUFOICovOlxuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb3VudGVyU3R5bGVGcm9tUmFuZ2UodmFsdWUsIDB4MTgxMCwgMHgxODE5LCB0cnVlLCBkZWZhdWx0U3VmZml4KTtcbiAgICAgICAgICAgIGNhc2UgMzggLyogTVlBTk1BUiAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ291bnRlclN0eWxlRnJvbVJhbmdlKHZhbHVlLCAweDEwNDAsIDB4MTA0OSwgdHJ1ZSwgZGVmYXVsdFN1ZmZpeCk7XG4gICAgICAgICAgICBjYXNlIDM5IC8qIE9SSVlBICovOlxuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb3VudGVyU3R5bGVGcm9tUmFuZ2UodmFsdWUsIDB4YjY2LCAweGI2ZiwgdHJ1ZSwgZGVmYXVsdFN1ZmZpeCk7XG4gICAgICAgICAgICBjYXNlIDQwIC8qIFBFUlNJQU4gKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvdW50ZXJTdHlsZUZyb21SYW5nZSh2YWx1ZSwgMHg2ZjAsIDB4NmY5LCB0cnVlLCBkZWZhdWx0U3VmZml4KTtcbiAgICAgICAgICAgIGNhc2UgNDMgLyogVEFNSUwgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvdW50ZXJTdHlsZUZyb21SYW5nZSh2YWx1ZSwgMHhiZTYsIDB4YmVmLCB0cnVlLCBkZWZhdWx0U3VmZml4KTtcbiAgICAgICAgICAgIGNhc2UgNDQgLyogVEVMVUdVICovOlxuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb3VudGVyU3R5bGVGcm9tUmFuZ2UodmFsdWUsIDB4YzY2LCAweGM2ZiwgdHJ1ZSwgZGVmYXVsdFN1ZmZpeCk7XG4gICAgICAgICAgICBjYXNlIDQ1IC8qIFRIQUkgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvdW50ZXJTdHlsZUZyb21SYW5nZSh2YWx1ZSwgMHhlNTAsIDB4ZTU5LCB0cnVlLCBkZWZhdWx0U3VmZml4KTtcbiAgICAgICAgICAgIGNhc2UgNDYgLyogVElCRVRBTiAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ291bnRlclN0eWxlRnJvbVJhbmdlKHZhbHVlLCAweGYyMCwgMHhmMjksIHRydWUsIGRlZmF1bHRTdWZmaXgpO1xuICAgICAgICAgICAgY2FzZSAzIC8qIERFQ0lNQUwgKi86XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb3VudGVyU3R5bGVGcm9tUmFuZ2UodmFsdWUsIDQ4LCA1NywgdHJ1ZSwgZGVmYXVsdFN1ZmZpeCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIElHTk9SRV9BVFRSSUJVVEUgPSAnZGF0YS1odG1sMmNhbnZhcy1pZ25vcmUnO1xuICAgIHZhciBEb2N1bWVudENsb25lciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gRG9jdW1lbnRDbG9uZXIoY29udGV4dCwgZWxlbWVudCwgb3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbGVkRWxlbWVudHMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMucmVmZXJlbmNlRWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLmNvdW50ZXJzID0gbmV3IENvdW50ZXJTdGF0ZSgpO1xuICAgICAgICAgICAgdGhpcy5xdW90ZURlcHRoID0gMDtcbiAgICAgICAgICAgIGlmICghZWxlbWVudC5vd25lckRvY3VtZW50KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDbG9uZWQgZWxlbWVudCBkb2VzIG5vdCBoYXZlIGFuIG93bmVyIGRvY3VtZW50Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRvY3VtZW50RWxlbWVudCA9IHRoaXMuY2xvbmVOb2RlKGVsZW1lbnQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBEb2N1bWVudENsb25lci5wcm90b3R5cGUudG9JRnJhbWUgPSBmdW5jdGlvbiAob3duZXJEb2N1bWVudCwgd2luZG93U2l6ZSkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBpZnJhbWUgPSBjcmVhdGVJRnJhbWVDb250YWluZXIob3duZXJEb2N1bWVudCwgd2luZG93U2l6ZSk7XG4gICAgICAgICAgICBpZiAoIWlmcmFtZS5jb250ZW50V2luZG93KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KFwiVW5hYmxlIHRvIGZpbmQgaWZyYW1lIHdpbmRvd1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzY3JvbGxYID0gb3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldy5wYWdlWE9mZnNldDtcbiAgICAgICAgICAgIHZhciBzY3JvbGxZID0gb3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldy5wYWdlWU9mZnNldDtcbiAgICAgICAgICAgIHZhciBjbG9uZVdpbmRvdyA9IGlmcmFtZS5jb250ZW50V2luZG93O1xuICAgICAgICAgICAgdmFyIGRvY3VtZW50Q2xvbmUgPSBjbG9uZVdpbmRvdy5kb2N1bWVudDtcbiAgICAgICAgICAgIC8qIENocm9tZSBkb2Vzbid0IGRldGVjdCByZWxhdGl2ZSBiYWNrZ3JvdW5kLWltYWdlcyBhc3NpZ25lZCBpbiBpbmxpbmUgPHN0eWxlPiBzaGVldHMgd2hlbiBmZXRjaGVkIHRocm91Z2ggZ2V0Q29tcHV0ZWRTdHlsZVxuICAgICAgICAgICAgIGlmIHdpbmRvdyB1cmwgaXMgYWJvdXQ6YmxhbmssIHdlIGNhbiBhc3NpZ24gdGhlIHVybCB0byBjdXJyZW50IGJ5IHdyaXRpbmcgb250byB0aGUgZG9jdW1lbnRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmFyIGlmcmFtZUxvYWQgPSBpZnJhbWVMb2FkZXIoaWZyYW1lKS50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9fYXdhaXRlcihfdGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgb25jbG9uZSwgcmVmZXJlbmNlRWxlbWVudDtcbiAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbGVkRWxlbWVudHMuZm9yRWFjaChyZXN0b3JlTm9kZVNjcm9sbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNsb25lV2luZG93KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lV2luZG93LnNjcm9sbFRvKHdpbmRvd1NpemUubGVmdCwgd2luZG93U2l6ZS50b3ApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoLyhpUGFkfGlQaG9uZXxpUG9kKS9nLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjbG9uZVdpbmRvdy5zY3JvbGxZICE9PSB3aW5kb3dTaXplLnRvcCB8fCBjbG9uZVdpbmRvdy5zY3JvbGxYICE9PSB3aW5kb3dTaXplLmxlZnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQubG9nZ2VyLndhcm4oJ1VuYWJsZSB0byByZXN0b3JlIHNjcm9sbCBwb3NpdGlvbiBmb3IgY2xvbmVkIGRvY3VtZW50Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQud2luZG93Qm91bmRzID0gdGhpcy5jb250ZXh0LndpbmRvd0JvdW5kcy5hZGQoY2xvbmVXaW5kb3cuc2Nyb2xsWCAtIHdpbmRvd1NpemUubGVmdCwgY2xvbmVXaW5kb3cuc2Nyb2xsWSAtIHdpbmRvd1NpemUudG9wLCAwLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbmNsb25lID0gdGhpcy5vcHRpb25zLm9uY2xvbmU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlRWxlbWVudCA9IHRoaXMuY2xvbmVkUmVmZXJlbmNlRWxlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlZmVyZW5jZUVsZW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBQcm9taXNlLnJlamVjdChcIkVycm9yIGZpbmRpbmcgdGhlIFwiICsgdGhpcy5yZWZlcmVuY2VFbGVtZW50Lm5vZGVOYW1lICsgXCIgaW4gdGhlIGNsb25lZCBkb2N1bWVudFwiKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGRvY3VtZW50Q2xvbmUuZm9udHMgJiYgZG9jdW1lbnRDbG9uZS5mb250cy5yZWFkeSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGRvY3VtZW50Q2xvbmUuZm9udHMucmVhZHldO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEvKEFwcGxlV2ViS2l0KS9nLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGltYWdlc1JlYWR5KGRvY3VtZW50Q2xvbmUpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSA0O1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb25jbG9uZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiBvbmNsb25lKGRvY3VtZW50Q2xvbmUsIHJlZmVyZW5jZUVsZW1lbnQpOyB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGlmcmFtZTsgfSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgaWZyYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7IH0pO1xuICAgICAgICAgICAgZG9jdW1lbnRDbG9uZS5vcGVuKCk7XG4gICAgICAgICAgICBkb2N1bWVudENsb25lLndyaXRlKHNlcmlhbGl6ZURvY3R5cGUoZG9jdW1lbnQuZG9jdHlwZSkgKyBcIjxodG1sPjwvaHRtbD5cIik7XG4gICAgICAgICAgICAvLyBDaHJvbWUgc2Nyb2xscyB0aGUgcGFyZW50IGRvY3VtZW50IGZvciBzb21lIHJlYXNvbiBhZnRlciB0aGUgd3JpdGUgdG8gdGhlIGNsb25lZCB3aW5kb3c/Pz9cbiAgICAgICAgICAgIHJlc3RvcmVPd25lclNjcm9sbCh0aGlzLnJlZmVyZW5jZUVsZW1lbnQub3duZXJEb2N1bWVudCwgc2Nyb2xsWCwgc2Nyb2xsWSk7XG4gICAgICAgICAgICBkb2N1bWVudENsb25lLnJlcGxhY2VDaGlsZChkb2N1bWVudENsb25lLmFkb3B0Tm9kZSh0aGlzLmRvY3VtZW50RWxlbWVudCksIGRvY3VtZW50Q2xvbmUuZG9jdW1lbnRFbGVtZW50KTtcbiAgICAgICAgICAgIGRvY3VtZW50Q2xvbmUuY2xvc2UoKTtcbiAgICAgICAgICAgIHJldHVybiBpZnJhbWVMb2FkO1xuICAgICAgICB9O1xuICAgICAgICBEb2N1bWVudENsb25lci5wcm90b3R5cGUuY3JlYXRlRWxlbWVudENsb25lID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIGlmIChpc0RlYnVnZ2luZyhub2RlLCAyIC8qIENMT05FICovKSkge1xuICAgICAgICAgICAgICAgIGRlYnVnZ2VyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzQ2FudmFzRWxlbWVudChub2RlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUNhbnZhc0Nsb25lKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzVmlkZW9FbGVtZW50KG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlVmlkZW9DbG9uZShub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1N0eWxlRWxlbWVudChub2RlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVN0eWxlQ2xvbmUobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY2xvbmUgPSBub2RlLmNsb25lTm9kZShmYWxzZSk7XG4gICAgICAgICAgICBpZiAoaXNJbWFnZUVsZW1lbnQoY2xvbmUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzSW1hZ2VFbGVtZW50KG5vZGUpICYmIG5vZGUuY3VycmVudFNyYyAmJiBub2RlLmN1cnJlbnRTcmMgIT09IG5vZGUuc3JjKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsb25lLnNyYyA9IG5vZGUuY3VycmVudFNyYztcbiAgICAgICAgICAgICAgICAgICAgY2xvbmUuc3Jjc2V0ID0gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjbG9uZS5sb2FkaW5nID09PSAnbGF6eScpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xvbmUubG9hZGluZyA9ICdlYWdlcic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzQ3VzdG9tRWxlbWVudChjbG9uZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVDdXN0b21FbGVtZW50Q2xvbmUoY2xvbmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xuICAgICAgICB9O1xuICAgICAgICBEb2N1bWVudENsb25lci5wcm90b3R5cGUuY3JlYXRlQ3VzdG9tRWxlbWVudENsb25lID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIHZhciBjbG9uZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2h0bWwyY2FudmFzY3VzdG9tZWxlbWVudCcpO1xuICAgICAgICAgICAgY29weUNTU1N0eWxlcyhub2RlLnN0eWxlLCBjbG9uZSk7XG4gICAgICAgICAgICByZXR1cm4gY2xvbmU7XG4gICAgICAgIH07XG4gICAgICAgIERvY3VtZW50Q2xvbmVyLnByb3RvdHlwZS5jcmVhdGVTdHlsZUNsb25lID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIHNoZWV0ID0gbm9kZS5zaGVldDtcbiAgICAgICAgICAgICAgICBpZiAoc2hlZXQgJiYgc2hlZXQuY3NzUnVsZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNzcyA9IFtdLnNsaWNlLmNhbGwoc2hlZXQuY3NzUnVsZXMsIDApLnJlZHVjZShmdW5jdGlvbiAoY3NzLCBydWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocnVsZSAmJiB0eXBlb2YgcnVsZS5jc3NUZXh0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjc3MgKyBydWxlLmNzc1RleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3NzO1xuICAgICAgICAgICAgICAgICAgICB9LCAnJyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdHlsZSA9IG5vZGUuY2xvbmVOb2RlKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUudGV4dENvbnRlbnQgPSBjc3M7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHlsZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8vIGFjY2Vzc2luZyBub2RlLnNoZWV0LmNzc1J1bGVzIHRocm93cyBhIERPTUV4Y2VwdGlvblxuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5sb2dnZXIuZXJyb3IoJ1VuYWJsZSB0byBhY2Nlc3MgY3NzUnVsZXMgcHJvcGVydHknLCBlKTtcbiAgICAgICAgICAgICAgICBpZiAoZS5uYW1lICE9PSAnU2VjdXJpdHlFcnJvcicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5jbG9uZU5vZGUoZmFsc2UpO1xuICAgICAgICB9O1xuICAgICAgICBEb2N1bWVudENsb25lci5wcm90b3R5cGUuY3JlYXRlQ2FudmFzQ2xvbmUgPSBmdW5jdGlvbiAoY2FudmFzKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmlubGluZUltYWdlcyAmJiBjYW52YXMub3duZXJEb2N1bWVudCkge1xuICAgICAgICAgICAgICAgIHZhciBpbWcgPSBjYW52YXMub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpbWcuc3JjID0gY2FudmFzLnRvRGF0YVVSTCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW1nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQubG9nZ2VyLmluZm8oXCJVbmFibGUgdG8gaW5saW5lIGNhbnZhcyBjb250ZW50cywgY2FudmFzIGlzIHRhaW50ZWRcIiwgY2FudmFzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY2xvbmVkQ2FudmFzID0gY2FudmFzLmNsb25lTm9kZShmYWxzZSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNsb25lZENhbnZhcy53aWR0aCA9IGNhbnZhcy53aWR0aDtcbiAgICAgICAgICAgICAgICBjbG9uZWRDYW52YXMuaGVpZ2h0ID0gY2FudmFzLmhlaWdodDtcbiAgICAgICAgICAgICAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgICAgICAgdmFyIGNsb25lZEN0eCA9IGNsb25lZENhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAgICAgICAgIGlmIChjbG9uZWRDdHgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuYWxsb3dUYWludCAmJiBjdHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lZEN0eC5wdXRJbWFnZURhdGEoY3R4LmdldEltYWdlRGF0YSgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpLCAwLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBnbCA9IChfYSA9IGNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbDInKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY2FudmFzLmdldENvbnRleHQoJ3dlYmdsJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ2wpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cmlicyA9IGdsLmdldENvbnRleHRBdHRyaWJ1dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChhdHRyaWJzID09PSBudWxsIHx8IGF0dHJpYnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGF0dHJpYnMucHJlc2VydmVEcmF3aW5nQnVmZmVyKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmxvZ2dlci53YXJuKCdVbmFibGUgdG8gY2xvbmUgV2ViR0wgY29udGV4dCBhcyBpdCBoYXMgcHJlc2VydmVEcmF3aW5nQnVmZmVyPWZhbHNlJywgY2FudmFzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9uZWRDdHguZHJhd0ltYWdlKGNhbnZhcywgMCwgMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsb25lZENhbnZhcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmxvZ2dlci5pbmZvKFwiVW5hYmxlIHRvIGNsb25lIGNhbnZhcyBhcyBpdCBpcyB0YWludGVkXCIsIGNhbnZhcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2xvbmVkQ2FudmFzO1xuICAgICAgICB9O1xuICAgICAgICBEb2N1bWVudENsb25lci5wcm90b3R5cGUuY3JlYXRlVmlkZW9DbG9uZSA9IGZ1bmN0aW9uICh2aWRlbykge1xuICAgICAgICAgICAgdmFyIGNhbnZhcyA9IHZpZGVvLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICBjYW52YXMud2lkdGggPSB2aWRlby5vZmZzZXRXaWR0aDtcbiAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSB2aWRlby5vZmZzZXRIZWlnaHQ7XG4gICAgICAgICAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmRyYXdJbWFnZSh2aWRlbywgMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuYWxsb3dUYWludCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmdldEltYWdlRGF0YSgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjYW52YXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5sb2dnZXIuaW5mbyhcIlVuYWJsZSB0byBjbG9uZSB2aWRlbyBhcyBpdCBpcyB0YWludGVkXCIsIHZpZGVvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBibGFua0NhbnZhcyA9IHZpZGVvLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICBibGFua0NhbnZhcy53aWR0aCA9IHZpZGVvLm9mZnNldFdpZHRoO1xuICAgICAgICAgICAgYmxhbmtDYW52YXMuaGVpZ2h0ID0gdmlkZW8ub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgICAgcmV0dXJuIGJsYW5rQ2FudmFzO1xuICAgICAgICB9O1xuICAgICAgICBEb2N1bWVudENsb25lci5wcm90b3R5cGUuYXBwZW5kQ2hpbGROb2RlID0gZnVuY3Rpb24gKGNsb25lLCBjaGlsZCwgY29weVN0eWxlcykge1xuICAgICAgICAgICAgaWYgKCFpc0VsZW1lbnROb2RlKGNoaWxkKSB8fFxuICAgICAgICAgICAgICAgICghaXNTY3JpcHRFbGVtZW50KGNoaWxkKSAmJlxuICAgICAgICAgICAgICAgICAgICAhY2hpbGQuaGFzQXR0cmlidXRlKElHTk9SRV9BVFRSSUJVVEUpICYmXG4gICAgICAgICAgICAgICAgICAgICh0eXBlb2YgdGhpcy5vcHRpb25zLmlnbm9yZUVsZW1lbnRzICE9PSAnZnVuY3Rpb24nIHx8ICF0aGlzLm9wdGlvbnMuaWdub3JlRWxlbWVudHMoY2hpbGQpKSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5jb3B5U3R5bGVzIHx8ICFpc0VsZW1lbnROb2RlKGNoaWxkKSB8fCAhaXNTdHlsZUVsZW1lbnQoY2hpbGQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsb25lLmFwcGVuZENoaWxkKHRoaXMuY2xvbmVOb2RlKGNoaWxkLCBjb3B5U3R5bGVzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBEb2N1bWVudENsb25lci5wcm90b3R5cGUuY2xvbmVDaGlsZE5vZGVzID0gZnVuY3Rpb24gKG5vZGUsIGNsb25lLCBjb3B5U3R5bGVzKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgZm9yICh2YXIgY2hpbGQgPSBub2RlLnNoYWRvd1Jvb3QgPyBub2RlLnNoYWRvd1Jvb3QuZmlyc3RDaGlsZCA6IG5vZGUuZmlyc3RDaGlsZDsgY2hpbGQ7IGNoaWxkID0gY2hpbGQubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNFbGVtZW50Tm9kZShjaGlsZCkgJiYgaXNTbG90RWxlbWVudChjaGlsZCkgJiYgdHlwZW9mIGNoaWxkLmFzc2lnbmVkTm9kZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFzc2lnbmVkTm9kZXMgPSBjaGlsZC5hc3NpZ25lZE5vZGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhc3NpZ25lZE5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzaWduZWROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChhc3NpZ25lZE5vZGUpIHsgcmV0dXJuIF90aGlzLmFwcGVuZENoaWxkTm9kZShjbG9uZSwgYXNzaWduZWROb2RlLCBjb3B5U3R5bGVzKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwZW5kQ2hpbGROb2RlKGNsb25lLCBjaGlsZCwgY29weVN0eWxlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBEb2N1bWVudENsb25lci5wcm90b3R5cGUuY2xvbmVOb2RlID0gZnVuY3Rpb24gKG5vZGUsIGNvcHlTdHlsZXMpIHtcbiAgICAgICAgICAgIGlmIChpc1RleHROb2RlKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKG5vZGUuZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW5vZGUub3duZXJEb2N1bWVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmNsb25lTm9kZShmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgd2luZG93ID0gbm9kZS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuICAgICAgICAgICAgaWYgKHdpbmRvdyAmJiBpc0VsZW1lbnROb2RlKG5vZGUpICYmIChpc0hUTUxFbGVtZW50Tm9kZShub2RlKSB8fCBpc1NWR0VsZW1lbnROb2RlKG5vZGUpKSkge1xuICAgICAgICAgICAgICAgIHZhciBjbG9uZSA9IHRoaXMuY3JlYXRlRWxlbWVudENsb25lKG5vZGUpO1xuICAgICAgICAgICAgICAgIGNsb25lLnN0eWxlLnRyYW5zaXRpb25Qcm9wZXJ0eSA9ICdub25lJztcbiAgICAgICAgICAgICAgICB2YXIgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcbiAgICAgICAgICAgICAgICB2YXIgc3R5bGVCZWZvcmUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShub2RlLCAnOmJlZm9yZScpO1xuICAgICAgICAgICAgICAgIHZhciBzdHlsZUFmdGVyID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUobm9kZSwgJzphZnRlcicpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlZmVyZW5jZUVsZW1lbnQgPT09IG5vZGUgJiYgaXNIVE1MRWxlbWVudE5vZGUoY2xvbmUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xvbmVkUmVmZXJlbmNlRWxlbWVudCA9IGNsb25lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNCb2R5RWxlbWVudChjbG9uZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlUHNldWRvSGlkZVN0eWxlcyhjbG9uZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBjb3VudGVycyA9IHRoaXMuY291bnRlcnMucGFyc2UobmV3IENTU1BhcnNlZENvdW50ZXJEZWNsYXJhdGlvbih0aGlzLmNvbnRleHQsIHN0eWxlKSk7XG4gICAgICAgICAgICAgICAgdmFyIGJlZm9yZSA9IHRoaXMucmVzb2x2ZVBzZXVkb0NvbnRlbnQobm9kZSwgY2xvbmUsIHN0eWxlQmVmb3JlLCBQc2V1ZG9FbGVtZW50VHlwZS5CRUZPUkUpO1xuICAgICAgICAgICAgICAgIGlmIChpc0N1c3RvbUVsZW1lbnQobm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29weVN0eWxlcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghaXNWaWRlb0VsZW1lbnQobm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbG9uZUNoaWxkTm9kZXMobm9kZSwgY2xvbmUsIGNvcHlTdHlsZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYmVmb3JlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsb25lLmluc2VydEJlZm9yZShiZWZvcmUsIGNsb25lLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgYWZ0ZXIgPSB0aGlzLnJlc29sdmVQc2V1ZG9Db250ZW50KG5vZGUsIGNsb25lLCBzdHlsZUFmdGVyLCBQc2V1ZG9FbGVtZW50VHlwZS5BRlRFUik7XG4gICAgICAgICAgICAgICAgaWYgKGFmdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsb25lLmFwcGVuZENoaWxkKGFmdGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5jb3VudGVycy5wb3AoY291bnRlcnMpO1xuICAgICAgICAgICAgICAgIGlmICgoc3R5bGUgJiYgKHRoaXMub3B0aW9ucy5jb3B5U3R5bGVzIHx8IGlzU1ZHRWxlbWVudE5vZGUobm9kZSkpICYmICFpc0lGcmFtZUVsZW1lbnQobm9kZSkpIHx8XG4gICAgICAgICAgICAgICAgICAgIGNvcHlTdHlsZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29weUNTU1N0eWxlcyhzdHlsZSwgY2xvbmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobm9kZS5zY3JvbGxUb3AgIT09IDAgfHwgbm9kZS5zY3JvbGxMZWZ0ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsZWRFbGVtZW50cy5wdXNoKFtjbG9uZSwgbm9kZS5zY3JvbGxMZWZ0LCBub2RlLnNjcm9sbFRvcF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoKGlzVGV4dGFyZWFFbGVtZW50KG5vZGUpIHx8IGlzU2VsZWN0RWxlbWVudChub2RlKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgKGlzVGV4dGFyZWFFbGVtZW50KGNsb25lKSB8fCBpc1NlbGVjdEVsZW1lbnQoY2xvbmUpKSkge1xuICAgICAgICAgICAgICAgICAgICBjbG9uZS52YWx1ZSA9IG5vZGUudmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjbG9uZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBub2RlLmNsb25lTm9kZShmYWxzZSk7XG4gICAgICAgIH07XG4gICAgICAgIERvY3VtZW50Q2xvbmVyLnByb3RvdHlwZS5yZXNvbHZlUHNldWRvQ29udGVudCA9IGZ1bmN0aW9uIChub2RlLCBjbG9uZSwgc3R5bGUsIHBzZXVkb0VsdCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIGlmICghc3R5bGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBzdHlsZS5jb250ZW50O1xuICAgICAgICAgICAgdmFyIGRvY3VtZW50ID0gY2xvbmUub3duZXJEb2N1bWVudDtcbiAgICAgICAgICAgIGlmICghZG9jdW1lbnQgfHwgIXZhbHVlIHx8IHZhbHVlID09PSAnbm9uZScgfHwgdmFsdWUgPT09ICctbW96LWFsdC1jb250ZW50JyB8fCBzdHlsZS5kaXNwbGF5ID09PSAnbm9uZScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNvdW50ZXJzLnBhcnNlKG5ldyBDU1NQYXJzZWRDb3VudGVyRGVjbGFyYXRpb24odGhpcy5jb250ZXh0LCBzdHlsZSkpO1xuICAgICAgICAgICAgdmFyIGRlY2xhcmF0aW9uID0gbmV3IENTU1BhcnNlZFBzZXVkb0RlY2xhcmF0aW9uKHRoaXMuY29udGV4dCwgc3R5bGUpO1xuICAgICAgICAgICAgdmFyIGFub255bW91c1JlcGxhY2VkRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2h0bWwyY2FudmFzcHNldWRvZWxlbWVudCcpO1xuICAgICAgICAgICAgY29weUNTU1N0eWxlcyhzdHlsZSwgYW5vbnltb3VzUmVwbGFjZWRFbGVtZW50KTtcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uLmNvbnRlbnQuZm9yRWFjaChmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gMCAvKiBTVFJJTkdfVE9LRU4gKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgYW5vbnltb3VzUmVwbGFjZWRFbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRva2VuLnZhbHVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuLnR5cGUgPT09IDIyIC8qIFVSTF9UT0tFTiAqLykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XG4gICAgICAgICAgICAgICAgICAgIGltZy5zcmMgPSB0b2tlbi52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaW1nLnN0eWxlLm9wYWNpdHkgPSAnMSc7XG4gICAgICAgICAgICAgICAgICAgIGFub255bW91c1JlcGxhY2VkRWxlbWVudC5hcHBlbmRDaGlsZChpbWcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0b2tlbi50eXBlID09PSAxOCAvKiBGVU5DVElPTiAqLykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4ubmFtZSA9PT0gJ2F0dHInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXR0ciA9IHRva2VuLnZhbHVlcy5maWx0ZXIoaXNJZGVudFRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhdHRyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFub255bW91c1JlcGxhY2VkRWxlbWVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShub2RlLmdldEF0dHJpYnV0ZShhdHRyWzBdLnZhbHVlKSB8fCAnJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuLm5hbWUgPT09ICdjb3VudGVyJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hID0gdG9rZW4udmFsdWVzLmZpbHRlcihub25GdW5jdGlvbkFyZ1NlcGFyYXRvciksIGNvdW50ZXIgPSBfYVswXSwgY291bnRlclN0eWxlID0gX2FbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY291bnRlciAmJiBpc0lkZW50VG9rZW4oY291bnRlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY291bnRlclN0YXRlID0gX3RoaXMuY291bnRlcnMuZ2V0Q291bnRlclZhbHVlKGNvdW50ZXIudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb3VudGVyVHlwZSA9IGNvdW50ZXJTdHlsZSAmJiBpc0lkZW50VG9rZW4oY291bnRlclN0eWxlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGxpc3RTdHlsZVR5cGUucGFyc2UoX3RoaXMuY29udGV4dCwgY291bnRlclN0eWxlLnZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IDMgLyogREVDSU1BTCAqLztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbm9ueW1vdXNSZXBsYWNlZEVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3JlYXRlQ291bnRlclRleHQoY291bnRlclN0YXRlLCBjb3VudGVyVHlwZSwgZmFsc2UpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodG9rZW4ubmFtZSA9PT0gJ2NvdW50ZXJzJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9iID0gdG9rZW4udmFsdWVzLmZpbHRlcihub25GdW5jdGlvbkFyZ1NlcGFyYXRvciksIGNvdW50ZXIgPSBfYlswXSwgZGVsaW0gPSBfYlsxXSwgY291bnRlclN0eWxlID0gX2JbMl07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY291bnRlciAmJiBpc0lkZW50VG9rZW4oY291bnRlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY291bnRlclN0YXRlcyA9IF90aGlzLmNvdW50ZXJzLmdldENvdW50ZXJWYWx1ZXMoY291bnRlci52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvdW50ZXJUeXBlXzEgPSBjb3VudGVyU3R5bGUgJiYgaXNJZGVudFRva2VuKGNvdW50ZXJTdHlsZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBsaXN0U3R5bGVUeXBlLnBhcnNlKF90aGlzLmNvbnRleHQsIGNvdW50ZXJTdHlsZS52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAzIC8qIERFQ0lNQUwgKi87XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNlcGFyYXRvciA9IGRlbGltICYmIGRlbGltLnR5cGUgPT09IDAgLyogU1RSSU5HX1RPS0VOICovID8gZGVsaW0udmFsdWUgOiAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dCA9IGNvdW50ZXJTdGF0ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIGNyZWF0ZUNvdW50ZXJUZXh0KHZhbHVlLCBjb3VudGVyVHlwZV8xLCBmYWxzZSk7IH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5qb2luKHNlcGFyYXRvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5vbnltb3VzUmVwbGFjZWRFbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRleHQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodG9rZW4udHlwZSA9PT0gMjAgLyogSURFTlRfVE9LRU4gKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0b2tlbi52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnb3Blbi1xdW90ZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5vbnltb3VzUmVwbGFjZWRFbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGdldFF1b3RlKGRlY2xhcmF0aW9uLnF1b3RlcywgX3RoaXMucXVvdGVEZXB0aCsrLCB0cnVlKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnY2xvc2UtcXVvdGUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFub255bW91c1JlcGxhY2VkRWxlbWVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShnZXRRdW90ZShkZWNsYXJhdGlvbi5xdW90ZXMsIC0tX3RoaXMucXVvdGVEZXB0aCwgZmFsc2UpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNhZmFyaSBkb2Vzbid0IHBhcnNlIHN0cmluZyB0b2tlbnMgY29ycmVjdGx5IGJlY2F1c2Ugb2YgbGFjayBvZiBxdW90ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbm9ueW1vdXNSZXBsYWNlZEVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodG9rZW4udmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYW5vbnltb3VzUmVwbGFjZWRFbGVtZW50LmNsYXNzTmFtZSA9IFBTRVVET19ISURFX0VMRU1FTlRfQ0xBU1NfQkVGT1JFICsgXCIgXCIgKyBQU0VVRE9fSElERV9FTEVNRU5UX0NMQVNTX0FGVEVSO1xuICAgICAgICAgICAgdmFyIG5ld0NsYXNzTmFtZSA9IHBzZXVkb0VsdCA9PT0gUHNldWRvRWxlbWVudFR5cGUuQkVGT1JFXG4gICAgICAgICAgICAgICAgPyBcIiBcIiArIFBTRVVET19ISURFX0VMRU1FTlRfQ0xBU1NfQkVGT1JFXG4gICAgICAgICAgICAgICAgOiBcIiBcIiArIFBTRVVET19ISURFX0VMRU1FTlRfQ0xBU1NfQUZURVI7XG4gICAgICAgICAgICBpZiAoaXNTVkdFbGVtZW50Tm9kZShjbG9uZSkpIHtcbiAgICAgICAgICAgICAgICBjbG9uZS5jbGFzc05hbWUuYmFzZVZhbHVlICs9IG5ld0NsYXNzTmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNsb25lLmNsYXNzTmFtZSArPSBuZXdDbGFzc05hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYW5vbnltb3VzUmVwbGFjZWRFbGVtZW50O1xuICAgICAgICB9O1xuICAgICAgICBEb2N1bWVudENsb25lci5kZXN0cm95ID0gZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuICAgICAgICAgICAgaWYgKGNvbnRhaW5lci5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIERvY3VtZW50Q2xvbmVyO1xuICAgIH0oKSk7XG4gICAgdmFyIFBzZXVkb0VsZW1lbnRUeXBlO1xuICAgIChmdW5jdGlvbiAoUHNldWRvRWxlbWVudFR5cGUpIHtcbiAgICAgICAgUHNldWRvRWxlbWVudFR5cGVbUHNldWRvRWxlbWVudFR5cGVbXCJCRUZPUkVcIl0gPSAwXSA9IFwiQkVGT1JFXCI7XG4gICAgICAgIFBzZXVkb0VsZW1lbnRUeXBlW1BzZXVkb0VsZW1lbnRUeXBlW1wiQUZURVJcIl0gPSAxXSA9IFwiQUZURVJcIjtcbiAgICB9KShQc2V1ZG9FbGVtZW50VHlwZSB8fCAoUHNldWRvRWxlbWVudFR5cGUgPSB7fSkpO1xuICAgIHZhciBjcmVhdGVJRnJhbWVDb250YWluZXIgPSBmdW5jdGlvbiAob3duZXJEb2N1bWVudCwgYm91bmRzKSB7XG4gICAgICAgIHZhciBjbG9uZUlmcmFtZUNvbnRhaW5lciA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgICAgIGNsb25lSWZyYW1lQ29udGFpbmVyLmNsYXNzTmFtZSA9ICdodG1sMmNhbnZhcy1jb250YWluZXInO1xuICAgICAgICBjbG9uZUlmcmFtZUNvbnRhaW5lci5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgICAgIGNsb25lSWZyYW1lQ29udGFpbmVyLnN0eWxlLnBvc2l0aW9uID0gJ2ZpeGVkJztcbiAgICAgICAgY2xvbmVJZnJhbWVDb250YWluZXIuc3R5bGUubGVmdCA9ICctMTAwMDBweCc7XG4gICAgICAgIGNsb25lSWZyYW1lQ29udGFpbmVyLnN0eWxlLnRvcCA9ICcwcHgnO1xuICAgICAgICBjbG9uZUlmcmFtZUNvbnRhaW5lci5zdHlsZS5ib3JkZXIgPSAnMCc7XG4gICAgICAgIGNsb25lSWZyYW1lQ29udGFpbmVyLndpZHRoID0gYm91bmRzLndpZHRoLnRvU3RyaW5nKCk7XG4gICAgICAgIGNsb25lSWZyYW1lQ29udGFpbmVyLmhlaWdodCA9IGJvdW5kcy5oZWlnaHQudG9TdHJpbmcoKTtcbiAgICAgICAgY2xvbmVJZnJhbWVDb250YWluZXIuc2Nyb2xsaW5nID0gJ25vJzsgLy8gaW9zIHdvbid0IHNjcm9sbCB3aXRob3V0IGl0XG4gICAgICAgIGNsb25lSWZyYW1lQ29udGFpbmVyLnNldEF0dHJpYnV0ZShJR05PUkVfQVRUUklCVVRFLCAndHJ1ZScpO1xuICAgICAgICBvd25lckRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY2xvbmVJZnJhbWVDb250YWluZXIpO1xuICAgICAgICByZXR1cm4gY2xvbmVJZnJhbWVDb250YWluZXI7XG4gICAgfTtcbiAgICB2YXIgaW1hZ2VSZWFkeSA9IGZ1bmN0aW9uIChpbWcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgICBpZiAoaW1nLmNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaW1nLnNyYykge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbWcub25sb2FkID0gcmVzb2x2ZTtcbiAgICAgICAgICAgIGltZy5vbmVycm9yID0gcmVzb2x2ZTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICB2YXIgaW1hZ2VzUmVhZHkgPSBmdW5jdGlvbiAoZG9jdW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtdLnNsaWNlLmNhbGwoZG9jdW1lbnQuaW1hZ2VzLCAwKS5tYXAoaW1hZ2VSZWFkeSkpO1xuICAgIH07XG4gICAgdmFyIGlmcmFtZUxvYWRlciA9IGZ1bmN0aW9uIChpZnJhbWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHZhciBjbG9uZVdpbmRvdyA9IGlmcmFtZS5jb250ZW50V2luZG93O1xuICAgICAgICAgICAgaWYgKCFjbG9uZVdpbmRvdykge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoXCJObyB3aW5kb3cgYXNzaWduZWQgZm9yIGlmcmFtZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBkb2N1bWVudENsb25lID0gY2xvbmVXaW5kb3cuZG9jdW1lbnQ7XG4gICAgICAgICAgICBjbG9uZVdpbmRvdy5vbmxvYWQgPSBpZnJhbWUub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGNsb25lV2luZG93Lm9ubG9hZCA9IGlmcmFtZS5vbmxvYWQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHZhciBpbnRlcnZhbCA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvY3VtZW50Q2xvbmUuYm9keS5jaGlsZE5vZGVzLmxlbmd0aCA+IDAgJiYgZG9jdW1lbnRDbG9uZS5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoaWZyYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIDUwKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgdmFyIGlnbm9yZWRTdHlsZVByb3BlcnRpZXMgPSBbXG4gICAgICAgICdhbGwnLFxuICAgICAgICAnZCcsXG4gICAgICAgICdjb250ZW50JyAvLyBTYWZhcmkgc2hvd3MgcHNldWRvZWxlbWVudHMgaWYgY29udGVudCBpcyBzZXRcbiAgICBdO1xuICAgIHZhciBjb3B5Q1NTU3R5bGVzID0gZnVuY3Rpb24gKHN0eWxlLCB0YXJnZXQpIHtcbiAgICAgICAgLy8gRWRnZSBkb2VzIG5vdCBwcm92aWRlIHZhbHVlIGZvciBjc3NUZXh0XG4gICAgICAgIGZvciAodmFyIGkgPSBzdHlsZS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgdmFyIHByb3BlcnR5ID0gc3R5bGUuaXRlbShpKTtcbiAgICAgICAgICAgIGlmIChpZ25vcmVkU3R5bGVQcm9wZXJ0aWVzLmluZGV4T2YocHJvcGVydHkpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHRhcmdldC5zdHlsZS5zZXRQcm9wZXJ0eShwcm9wZXJ0eSwgc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShwcm9wZXJ0eSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfTtcbiAgICB2YXIgc2VyaWFsaXplRG9jdHlwZSA9IGZ1bmN0aW9uIChkb2N0eXBlKSB7XG4gICAgICAgIHZhciBzdHIgPSAnJztcbiAgICAgICAgaWYgKGRvY3R5cGUpIHtcbiAgICAgICAgICAgIHN0ciArPSAnPCFET0NUWVBFICc7XG4gICAgICAgICAgICBpZiAoZG9jdHlwZS5uYW1lKSB7XG4gICAgICAgICAgICAgICAgc3RyICs9IGRvY3R5cGUubmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkb2N0eXBlLmludGVybmFsU3Vic2V0KSB7XG4gICAgICAgICAgICAgICAgc3RyICs9IGRvY3R5cGUuaW50ZXJuYWxTdWJzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZG9jdHlwZS5wdWJsaWNJZCkge1xuICAgICAgICAgICAgICAgIHN0ciArPSBcIlxcXCJcIiArIGRvY3R5cGUucHVibGljSWQgKyBcIlxcXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkb2N0eXBlLnN5c3RlbUlkKSB7XG4gICAgICAgICAgICAgICAgc3RyICs9IFwiXFxcIlwiICsgZG9jdHlwZS5zeXN0ZW1JZCArIFwiXFxcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RyICs9ICc+JztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH07XG4gICAgdmFyIHJlc3RvcmVPd25lclNjcm9sbCA9IGZ1bmN0aW9uIChvd25lckRvY3VtZW50LCB4LCB5KSB7XG4gICAgICAgIGlmIChvd25lckRvY3VtZW50ICYmXG4gICAgICAgICAgICBvd25lckRvY3VtZW50LmRlZmF1bHRWaWV3ICYmXG4gICAgICAgICAgICAoeCAhPT0gb3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldy5wYWdlWE9mZnNldCB8fCB5ICE9PSBvd25lckRvY3VtZW50LmRlZmF1bHRWaWV3LnBhZ2VZT2Zmc2V0KSkge1xuICAgICAgICAgICAgb3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldy5zY3JvbGxUbyh4LCB5KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIHJlc3RvcmVOb2RlU2Nyb2xsID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gX2FbMF0sIHggPSBfYVsxXSwgeSA9IF9hWzJdO1xuICAgICAgICBlbGVtZW50LnNjcm9sbExlZnQgPSB4O1xuICAgICAgICBlbGVtZW50LnNjcm9sbFRvcCA9IHk7XG4gICAgfTtcbiAgICB2YXIgUFNFVURPX0JFRk9SRSA9ICc6YmVmb3JlJztcbiAgICB2YXIgUFNFVURPX0FGVEVSID0gJzphZnRlcic7XG4gICAgdmFyIFBTRVVET19ISURFX0VMRU1FTlRfQ0xBU1NfQkVGT1JFID0gJ19fX2h0bWwyY2FudmFzX19fcHNldWRvZWxlbWVudF9iZWZvcmUnO1xuICAgIHZhciBQU0VVRE9fSElERV9FTEVNRU5UX0NMQVNTX0FGVEVSID0gJ19fX2h0bWwyY2FudmFzX19fcHNldWRvZWxlbWVudF9hZnRlcic7XG4gICAgdmFyIFBTRVVET19ISURFX0VMRU1FTlRfU1RZTEUgPSBcIntcXG4gICAgY29udGVudDogXFxcIlxcXCIgIWltcG9ydGFudDtcXG4gICAgZGlzcGxheTogbm9uZSAhaW1wb3J0YW50O1xcbn1cIjtcbiAgICB2YXIgY3JlYXRlUHNldWRvSGlkZVN0eWxlcyA9IGZ1bmN0aW9uIChib2R5KSB7XG4gICAgICAgIGNyZWF0ZVN0eWxlcyhib2R5LCBcIi5cIiArIFBTRVVET19ISURFX0VMRU1FTlRfQ0xBU1NfQkVGT1JFICsgUFNFVURPX0JFRk9SRSArIFBTRVVET19ISURFX0VMRU1FTlRfU1RZTEUgKyBcIlxcbiAgICAgICAgIC5cIiArIFBTRVVET19ISURFX0VMRU1FTlRfQ0xBU1NfQUZURVIgKyBQU0VVRE9fQUZURVIgKyBQU0VVRE9fSElERV9FTEVNRU5UX1NUWUxFKTtcbiAgICB9O1xuICAgIHZhciBjcmVhdGVTdHlsZXMgPSBmdW5jdGlvbiAoYm9keSwgc3R5bGVzKSB7XG4gICAgICAgIHZhciBkb2N1bWVudCA9IGJvZHkub3duZXJEb2N1bWVudDtcbiAgICAgICAgaWYgKGRvY3VtZW50KSB7XG4gICAgICAgICAgICB2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgICAgICAgICAgc3R5bGUudGV4dENvbnRlbnQgPSBzdHlsZXM7XG4gICAgICAgICAgICBib2R5LmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgQ2FjaGVTdG9yYWdlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBDYWNoZVN0b3JhZ2UoKSB7XG4gICAgICAgIH1cbiAgICAgICAgQ2FjaGVTdG9yYWdlLmdldE9yaWdpbiA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgICAgIHZhciBsaW5rID0gQ2FjaGVTdG9yYWdlLl9saW5rO1xuICAgICAgICAgICAgaWYgKCFsaW5rKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdhYm91dDpibGFuayc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaW5rLmhyZWYgPSB1cmw7XG4gICAgICAgICAgICBsaW5rLmhyZWYgPSBsaW5rLmhyZWY7IC8vIElFOSwgTE9MISAtIGh0dHA6Ly9qc2ZpZGRsZS5uZXQvbmlrbGFzdmgvMmU0OGIvXG4gICAgICAgICAgICByZXR1cm4gbGluay5wcm90b2NvbCArIGxpbmsuaG9zdG5hbWUgKyBsaW5rLnBvcnQ7XG4gICAgICAgIH07XG4gICAgICAgIENhY2hlU3RvcmFnZS5pc1NhbWVPcmlnaW4gPSBmdW5jdGlvbiAoc3JjKSB7XG4gICAgICAgICAgICByZXR1cm4gQ2FjaGVTdG9yYWdlLmdldE9yaWdpbihzcmMpID09PSBDYWNoZVN0b3JhZ2UuX29yaWdpbjtcbiAgICAgICAgfTtcbiAgICAgICAgQ2FjaGVTdG9yYWdlLnNldENvbnRleHQgPSBmdW5jdGlvbiAod2luZG93KSB7XG4gICAgICAgICAgICBDYWNoZVN0b3JhZ2UuX2xpbmsgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgICAgICAgICAgQ2FjaGVTdG9yYWdlLl9vcmlnaW4gPSBDYWNoZVN0b3JhZ2UuZ2V0T3JpZ2luKHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcbiAgICAgICAgfTtcbiAgICAgICAgQ2FjaGVTdG9yYWdlLl9vcmlnaW4gPSAnYWJvdXQ6YmxhbmsnO1xuICAgICAgICByZXR1cm4gQ2FjaGVTdG9yYWdlO1xuICAgIH0oKSk7XG4gICAgdmFyIENhY2hlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBDYWNoZShjb250ZXh0LCBfb3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgICAgIHRoaXMuX29wdGlvbnMgPSBfb3B0aW9ucztcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICB0aGlzLl9jYWNoZSA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIENhY2hlLnByb3RvdHlwZS5hZGRJbWFnZSA9IGZ1bmN0aW9uIChzcmMpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmhhcyhzcmMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0Jsb2JJbWFnZShzcmMpIHx8IGlzUmVuZGVyYWJsZShzcmMpKSB7XG4gICAgICAgICAgICAgICAgKHRoaXMuX2NhY2hlW3NyY10gPSB0aGlzLmxvYWRJbWFnZShzcmMpKS5jYXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHByZXZlbnQgdW5oYW5kbGVkIHJlamVjdGlvblxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBDYWNoZS5wcm90b3R5cGUubWF0Y2ggPSBmdW5jdGlvbiAoc3JjKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVbc3JjXTtcbiAgICAgICAgfTtcbiAgICAgICAgQ2FjaGUucHJvdG90eXBlLmxvYWRJbWFnZSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXNTYW1lT3JpZ2luLCB1c2VDT1JTLCB1c2VQcm94eSwgc3JjO1xuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNTYW1lT3JpZ2luID0gQ2FjaGVTdG9yYWdlLmlzU2FtZU9yaWdpbihrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZUNPUlMgPSAhaXNJbmxpbmVJbWFnZShrZXkpICYmIHRoaXMuX29wdGlvbnMudXNlQ09SUyA9PT0gdHJ1ZSAmJiBGRUFUVVJFUy5TVVBQT1JUX0NPUlNfSU1BR0VTICYmICFpc1NhbWVPcmlnaW47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlUHJveHkgPSAhaXNJbmxpbmVJbWFnZShrZXkpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICFpc1NhbWVPcmlnaW4gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIWlzQmxvYkltYWdlKGtleSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHRoaXMuX29wdGlvbnMucHJveHkgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEZFQVRVUkVTLlNVUFBPUlRfQ09SU19YSFIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIXVzZUNPUlM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1NhbWVPcmlnaW4gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb3B0aW9ucy5hbGxvd1RhaW50ID09PSBmYWxzZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhaXNJbmxpbmVJbWFnZShrZXkpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICFpc0Jsb2JJbWFnZShrZXkpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICF1c2VQcm94eSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhdXNlQ09SUykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNyYyA9IGtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXVzZVByb3h5KSByZXR1cm4gWzMgLypicmVhayovLCAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnByb3h5KHNyYyldO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNyYyA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmxvZ2dlci5kZWJ1ZyhcIkFkZGVkIGltYWdlIFwiICsga2V5LnN1YnN0cmluZygwLCAyNTYpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWcub25sb2FkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVzb2x2ZShpbWcpOyB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1nLm9uZXJyb3IgPSByZWplY3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2lvcyBzYWZhcmkgMTAuMyB0YWludHMgY2FudmFzIHdpdGggZGF0YSB1cmxzIHVubGVzcyBjcm9zc09yaWdpbiBpcyBzZXQgdG8gYW5vbnltb3VzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNJbmxpbmVCYXNlNjRJbWFnZShzcmMpIHx8IHVzZUNPUlMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWcuY3Jvc3NPcmlnaW4gPSAnYW5vbnltb3VzJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltZy5zcmMgPSBzcmM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW1nLmNvbXBsZXRlID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW5saW5lIFhNTCBpbWFnZXMgbWF5IGZhaWwgdG8gcGFyc2UsIHRocm93aW5nIGFuIEVycm9yIGxhdGVyIG9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiByZXNvbHZlKGltZyk7IH0sIDUwMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX29wdGlvbnMuaW1hZ2VUaW1lb3V0ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVqZWN0KFwiVGltZWQgb3V0IChcIiArIF90aGlzLl9vcHRpb25zLmltYWdlVGltZW91dCArIFwibXMpIGxvYWRpbmcgaW1hZ2VcIik7IH0sIF90aGlzLl9vcHRpb25zLmltYWdlVGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBDYWNoZS5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB0aGlzLl9jYWNoZVtrZXldICE9PSAndW5kZWZpbmVkJztcbiAgICAgICAgfTtcbiAgICAgICAgQ2FjaGUucHJvdG90eXBlLmtleXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKE9iamVjdC5rZXlzKHRoaXMuX2NhY2hlKSk7XG4gICAgICAgIH07XG4gICAgICAgIENhY2hlLnByb3RvdHlwZS5wcm94eSA9IGZ1bmN0aW9uIChzcmMpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgcHJveHkgPSB0aGlzLl9vcHRpb25zLnByb3h5O1xuICAgICAgICAgICAgaWYgKCFwcm94eSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gcHJveHkgZGVmaW5lZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGtleSA9IHNyYy5zdWJzdHJpbmcoMCwgMjU2KTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3BvbnNlVHlwZSA9IEZFQVRVUkVTLlNVUFBPUlRfUkVTUE9OU0VfVFlQRSA/ICdibG9iJyA6ICd0ZXh0JztcbiAgICAgICAgICAgICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgICAgICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHhoci5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlVHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh4aHIucmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlYWRlcl8xID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkZXJfMS5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVzb2x2ZShyZWFkZXJfMS5yZXN1bHQpOyB9LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGVyXzEuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBmdW5jdGlvbiAoZSkgeyByZXR1cm4gcmVqZWN0KGUpOyB9LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGVyXzEucmVhZEFzRGF0YVVSTCh4aHIucmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KFwiRmFpbGVkIHRvIHByb3h5IHJlc291cmNlIFwiICsga2V5ICsgXCIgd2l0aCBzdGF0dXMgY29kZSBcIiArIHhoci5zdGF0dXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB4aHIub25lcnJvciA9IHJlamVjdDtcbiAgICAgICAgICAgICAgICB2YXIgcXVlcnlTdHJpbmcgPSBwcm94eS5pbmRleE9mKCc/JykgPiAtMSA/ICcmJyA6ICc/JztcbiAgICAgICAgICAgICAgICB4aHIub3BlbignR0VUJywgXCJcIiArIHByb3h5ICsgcXVlcnlTdHJpbmcgKyBcInVybD1cIiArIGVuY29kZVVSSUNvbXBvbmVudChzcmMpICsgXCImcmVzcG9uc2VUeXBlPVwiICsgcmVzcG9uc2VUeXBlKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2VUeXBlICE9PSAndGV4dCcgJiYgeGhyIGluc3RhbmNlb2YgWE1MSHR0cFJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9IHJlc3BvbnNlVHlwZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLl9vcHRpb25zLmltYWdlVGltZW91dCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGltZW91dF8xID0gX3RoaXMuX29wdGlvbnMuaW1hZ2VUaW1lb3V0O1xuICAgICAgICAgICAgICAgICAgICB4aHIudGltZW91dCA9IHRpbWVvdXRfMTtcbiAgICAgICAgICAgICAgICAgICAgeGhyLm9udGltZW91dCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlamVjdChcIlRpbWVkIG91dCAoXCIgKyB0aW1lb3V0XzEgKyBcIm1zKSBwcm94eWluZyBcIiArIGtleSk7IH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHhoci5zZW5kKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIENhY2hlO1xuICAgIH0oKSk7XG4gICAgdmFyIElOTElORV9TVkcgPSAvXmRhdGE6aW1hZ2VcXC9zdmdcXCt4bWwvaTtcbiAgICB2YXIgSU5MSU5FX0JBU0U2NCA9IC9eZGF0YTppbWFnZVxcLy4qO2Jhc2U2NCwvaTtcbiAgICB2YXIgSU5MSU5FX0lNRyA9IC9eZGF0YTppbWFnZVxcLy4qL2k7XG4gICAgdmFyIGlzUmVuZGVyYWJsZSA9IGZ1bmN0aW9uIChzcmMpIHsgcmV0dXJuIEZFQVRVUkVTLlNVUFBPUlRfU1ZHX0RSQVdJTkcgfHwgIWlzU1ZHKHNyYyk7IH07XG4gICAgdmFyIGlzSW5saW5lSW1hZ2UgPSBmdW5jdGlvbiAoc3JjKSB7IHJldHVybiBJTkxJTkVfSU1HLnRlc3Qoc3JjKTsgfTtcbiAgICB2YXIgaXNJbmxpbmVCYXNlNjRJbWFnZSA9IGZ1bmN0aW9uIChzcmMpIHsgcmV0dXJuIElOTElORV9CQVNFNjQudGVzdChzcmMpOyB9O1xuICAgIHZhciBpc0Jsb2JJbWFnZSA9IGZ1bmN0aW9uIChzcmMpIHsgcmV0dXJuIHNyYy5zdWJzdHIoMCwgNCkgPT09ICdibG9iJzsgfTtcbiAgICB2YXIgaXNTVkcgPSBmdW5jdGlvbiAoc3JjKSB7IHJldHVybiBzcmMuc3Vic3RyKC0zKS50b0xvd2VyQ2FzZSgpID09PSAnc3ZnJyB8fCBJTkxJTkVfU1ZHLnRlc3Qoc3JjKTsgfTtcblxuICAgIHZhciBWZWN0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFZlY3Rvcih4LCB5KSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSAwIC8qIFZFQ1RPUiAqLztcbiAgICAgICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICB9XG4gICAgICAgIFZlY3Rvci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGRlbHRhWCwgZGVsdGFZKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFZlY3Rvcih0aGlzLnggKyBkZWx0YVgsIHRoaXMueSArIGRlbHRhWSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBWZWN0b3I7XG4gICAgfSgpKTtcblxuICAgIHZhciBsZXJwID0gZnVuY3Rpb24gKGEsIGIsIHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IoYS54ICsgKGIueCAtIGEueCkgKiB0LCBhLnkgKyAoYi55IC0gYS55KSAqIHQpO1xuICAgIH07XG4gICAgdmFyIEJlemllckN1cnZlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBCZXppZXJDdXJ2ZShzdGFydCwgc3RhcnRDb250cm9sLCBlbmRDb250cm9sLCBlbmQpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IDEgLyogQkVaSUVSX0NVUlZFICovO1xuICAgICAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgdGhpcy5zdGFydENvbnRyb2wgPSBzdGFydENvbnRyb2w7XG4gICAgICAgICAgICB0aGlzLmVuZENvbnRyb2wgPSBlbmRDb250cm9sO1xuICAgICAgICAgICAgdGhpcy5lbmQgPSBlbmQ7XG4gICAgICAgIH1cbiAgICAgICAgQmV6aWVyQ3VydmUucHJvdG90eXBlLnN1YmRpdmlkZSA9IGZ1bmN0aW9uICh0LCBmaXJzdEhhbGYpIHtcbiAgICAgICAgICAgIHZhciBhYiA9IGxlcnAodGhpcy5zdGFydCwgdGhpcy5zdGFydENvbnRyb2wsIHQpO1xuICAgICAgICAgICAgdmFyIGJjID0gbGVycCh0aGlzLnN0YXJ0Q29udHJvbCwgdGhpcy5lbmRDb250cm9sLCB0KTtcbiAgICAgICAgICAgIHZhciBjZCA9IGxlcnAodGhpcy5lbmRDb250cm9sLCB0aGlzLmVuZCwgdCk7XG4gICAgICAgICAgICB2YXIgYWJiYyA9IGxlcnAoYWIsIGJjLCB0KTtcbiAgICAgICAgICAgIHZhciBiY2NkID0gbGVycChiYywgY2QsIHQpO1xuICAgICAgICAgICAgdmFyIGRlc3QgPSBsZXJwKGFiYmMsIGJjY2QsIHQpO1xuICAgICAgICAgICAgcmV0dXJuIGZpcnN0SGFsZiA/IG5ldyBCZXppZXJDdXJ2ZSh0aGlzLnN0YXJ0LCBhYiwgYWJiYywgZGVzdCkgOiBuZXcgQmV6aWVyQ3VydmUoZGVzdCwgYmNjZCwgY2QsIHRoaXMuZW5kKTtcbiAgICAgICAgfTtcbiAgICAgICAgQmV6aWVyQ3VydmUucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChkZWx0YVgsIGRlbHRhWSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCZXppZXJDdXJ2ZSh0aGlzLnN0YXJ0LmFkZChkZWx0YVgsIGRlbHRhWSksIHRoaXMuc3RhcnRDb250cm9sLmFkZChkZWx0YVgsIGRlbHRhWSksIHRoaXMuZW5kQ29udHJvbC5hZGQoZGVsdGFYLCBkZWx0YVkpLCB0aGlzLmVuZC5hZGQoZGVsdGFYLCBkZWx0YVkpKTtcbiAgICAgICAgfTtcbiAgICAgICAgQmV6aWVyQ3VydmUucHJvdG90eXBlLnJldmVyc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJlemllckN1cnZlKHRoaXMuZW5kLCB0aGlzLmVuZENvbnRyb2wsIHRoaXMuc3RhcnRDb250cm9sLCB0aGlzLnN0YXJ0KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEJlemllckN1cnZlO1xuICAgIH0oKSk7XG4gICAgdmFyIGlzQmV6aWVyQ3VydmUgPSBmdW5jdGlvbiAocGF0aCkgeyByZXR1cm4gcGF0aC50eXBlID09PSAxIC8qIEJFWklFUl9DVVJWRSAqLzsgfTtcblxuICAgIHZhciBCb3VuZEN1cnZlcyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQm91bmRDdXJ2ZXMoZWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIHN0eWxlcyA9IGVsZW1lbnQuc3R5bGVzO1xuICAgICAgICAgICAgdmFyIGJvdW5kcyA9IGVsZW1lbnQuYm91bmRzO1xuICAgICAgICAgICAgdmFyIF9hID0gZ2V0QWJzb2x1dGVWYWx1ZUZvclR1cGxlKHN0eWxlcy5ib3JkZXJUb3BMZWZ0UmFkaXVzLCBib3VuZHMud2lkdGgsIGJvdW5kcy5oZWlnaHQpLCB0bGggPSBfYVswXSwgdGx2ID0gX2FbMV07XG4gICAgICAgICAgICB2YXIgX2IgPSBnZXRBYnNvbHV0ZVZhbHVlRm9yVHVwbGUoc3R5bGVzLmJvcmRlclRvcFJpZ2h0UmFkaXVzLCBib3VuZHMud2lkdGgsIGJvdW5kcy5oZWlnaHQpLCB0cmggPSBfYlswXSwgdHJ2ID0gX2JbMV07XG4gICAgICAgICAgICB2YXIgX2MgPSBnZXRBYnNvbHV0ZVZhbHVlRm9yVHVwbGUoc3R5bGVzLmJvcmRlckJvdHRvbVJpZ2h0UmFkaXVzLCBib3VuZHMud2lkdGgsIGJvdW5kcy5oZWlnaHQpLCBicmggPSBfY1swXSwgYnJ2ID0gX2NbMV07XG4gICAgICAgICAgICB2YXIgX2QgPSBnZXRBYnNvbHV0ZVZhbHVlRm9yVHVwbGUoc3R5bGVzLmJvcmRlckJvdHRvbUxlZnRSYWRpdXMsIGJvdW5kcy53aWR0aCwgYm91bmRzLmhlaWdodCksIGJsaCA9IF9kWzBdLCBibHYgPSBfZFsxXTtcbiAgICAgICAgICAgIHZhciBmYWN0b3JzID0gW107XG4gICAgICAgICAgICBmYWN0b3JzLnB1c2goKHRsaCArIHRyaCkgLyBib3VuZHMud2lkdGgpO1xuICAgICAgICAgICAgZmFjdG9ycy5wdXNoKChibGggKyBicmgpIC8gYm91bmRzLndpZHRoKTtcbiAgICAgICAgICAgIGZhY3RvcnMucHVzaCgodGx2ICsgYmx2KSAvIGJvdW5kcy5oZWlnaHQpO1xuICAgICAgICAgICAgZmFjdG9ycy5wdXNoKCh0cnYgKyBicnYpIC8gYm91bmRzLmhlaWdodCk7XG4gICAgICAgICAgICB2YXIgbWF4RmFjdG9yID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgZmFjdG9ycyk7XG4gICAgICAgICAgICBpZiAobWF4RmFjdG9yID4gMSkge1xuICAgICAgICAgICAgICAgIHRsaCAvPSBtYXhGYWN0b3I7XG4gICAgICAgICAgICAgICAgdGx2IC89IG1heEZhY3RvcjtcbiAgICAgICAgICAgICAgICB0cmggLz0gbWF4RmFjdG9yO1xuICAgICAgICAgICAgICAgIHRydiAvPSBtYXhGYWN0b3I7XG4gICAgICAgICAgICAgICAgYnJoIC89IG1heEZhY3RvcjtcbiAgICAgICAgICAgICAgICBicnYgLz0gbWF4RmFjdG9yO1xuICAgICAgICAgICAgICAgIGJsaCAvPSBtYXhGYWN0b3I7XG4gICAgICAgICAgICAgICAgYmx2IC89IG1heEZhY3RvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0b3BXaWR0aCA9IGJvdW5kcy53aWR0aCAtIHRyaDtcbiAgICAgICAgICAgIHZhciByaWdodEhlaWdodCA9IGJvdW5kcy5oZWlnaHQgLSBicnY7XG4gICAgICAgICAgICB2YXIgYm90dG9tV2lkdGggPSBib3VuZHMud2lkdGggLSBicmg7XG4gICAgICAgICAgICB2YXIgbGVmdEhlaWdodCA9IGJvdW5kcy5oZWlnaHQgLSBibHY7XG4gICAgICAgICAgICB2YXIgYm9yZGVyVG9wV2lkdGggPSBzdHlsZXMuYm9yZGVyVG9wV2lkdGg7XG4gICAgICAgICAgICB2YXIgYm9yZGVyUmlnaHRXaWR0aCA9IHN0eWxlcy5ib3JkZXJSaWdodFdpZHRoO1xuICAgICAgICAgICAgdmFyIGJvcmRlckJvdHRvbVdpZHRoID0gc3R5bGVzLmJvcmRlckJvdHRvbVdpZHRoO1xuICAgICAgICAgICAgdmFyIGJvcmRlckxlZnRXaWR0aCA9IHN0eWxlcy5ib3JkZXJMZWZ0V2lkdGg7XG4gICAgICAgICAgICB2YXIgcGFkZGluZ1RvcCA9IGdldEFic29sdXRlVmFsdWUoc3R5bGVzLnBhZGRpbmdUb3AsIGVsZW1lbnQuYm91bmRzLndpZHRoKTtcbiAgICAgICAgICAgIHZhciBwYWRkaW5nUmlnaHQgPSBnZXRBYnNvbHV0ZVZhbHVlKHN0eWxlcy5wYWRkaW5nUmlnaHQsIGVsZW1lbnQuYm91bmRzLndpZHRoKTtcbiAgICAgICAgICAgIHZhciBwYWRkaW5nQm90dG9tID0gZ2V0QWJzb2x1dGVWYWx1ZShzdHlsZXMucGFkZGluZ0JvdHRvbSwgZWxlbWVudC5ib3VuZHMud2lkdGgpO1xuICAgICAgICAgICAgdmFyIHBhZGRpbmdMZWZ0ID0gZ2V0QWJzb2x1dGVWYWx1ZShzdHlsZXMucGFkZGluZ0xlZnQsIGVsZW1lbnQuYm91bmRzLndpZHRoKTtcbiAgICAgICAgICAgIHRoaXMudG9wTGVmdEJvcmRlckRvdWJsZU91dGVyQm94ID1cbiAgICAgICAgICAgICAgICB0bGggPiAwIHx8IHRsdiA+IDBcbiAgICAgICAgICAgICAgICAgICAgPyBnZXRDdXJ2ZVBvaW50cyhib3VuZHMubGVmdCArIGJvcmRlckxlZnRXaWR0aCAvIDMsIGJvdW5kcy50b3AgKyBib3JkZXJUb3BXaWR0aCAvIDMsIHRsaCAtIGJvcmRlckxlZnRXaWR0aCAvIDMsIHRsdiAtIGJvcmRlclRvcFdpZHRoIC8gMywgQ09STkVSLlRPUF9MRUZUKVxuICAgICAgICAgICAgICAgICAgICA6IG5ldyBWZWN0b3IoYm91bmRzLmxlZnQgKyBib3JkZXJMZWZ0V2lkdGggLyAzLCBib3VuZHMudG9wICsgYm9yZGVyVG9wV2lkdGggLyAzKTtcbiAgICAgICAgICAgIHRoaXMudG9wUmlnaHRCb3JkZXJEb3VibGVPdXRlckJveCA9XG4gICAgICAgICAgICAgICAgdGxoID4gMCB8fCB0bHYgPiAwXG4gICAgICAgICAgICAgICAgICAgID8gZ2V0Q3VydmVQb2ludHMoYm91bmRzLmxlZnQgKyB0b3BXaWR0aCwgYm91bmRzLnRvcCArIGJvcmRlclRvcFdpZHRoIC8gMywgdHJoIC0gYm9yZGVyUmlnaHRXaWR0aCAvIDMsIHRydiAtIGJvcmRlclRvcFdpZHRoIC8gMywgQ09STkVSLlRPUF9SSUdIVClcbiAgICAgICAgICAgICAgICAgICAgOiBuZXcgVmVjdG9yKGJvdW5kcy5sZWZ0ICsgYm91bmRzLndpZHRoIC0gYm9yZGVyUmlnaHRXaWR0aCAvIDMsIGJvdW5kcy50b3AgKyBib3JkZXJUb3BXaWR0aCAvIDMpO1xuICAgICAgICAgICAgdGhpcy5ib3R0b21SaWdodEJvcmRlckRvdWJsZU91dGVyQm94ID1cbiAgICAgICAgICAgICAgICBicmggPiAwIHx8IGJydiA+IDBcbiAgICAgICAgICAgICAgICAgICAgPyBnZXRDdXJ2ZVBvaW50cyhib3VuZHMubGVmdCArIGJvdHRvbVdpZHRoLCBib3VuZHMudG9wICsgcmlnaHRIZWlnaHQsIGJyaCAtIGJvcmRlclJpZ2h0V2lkdGggLyAzLCBicnYgLSBib3JkZXJCb3R0b21XaWR0aCAvIDMsIENPUk5FUi5CT1RUT01fUklHSFQpXG4gICAgICAgICAgICAgICAgICAgIDogbmV3IFZlY3Rvcihib3VuZHMubGVmdCArIGJvdW5kcy53aWR0aCAtIGJvcmRlclJpZ2h0V2lkdGggLyAzLCBib3VuZHMudG9wICsgYm91bmRzLmhlaWdodCAtIGJvcmRlckJvdHRvbVdpZHRoIC8gMyk7XG4gICAgICAgICAgICB0aGlzLmJvdHRvbUxlZnRCb3JkZXJEb3VibGVPdXRlckJveCA9XG4gICAgICAgICAgICAgICAgYmxoID4gMCB8fCBibHYgPiAwXG4gICAgICAgICAgICAgICAgICAgID8gZ2V0Q3VydmVQb2ludHMoYm91bmRzLmxlZnQgKyBib3JkZXJMZWZ0V2lkdGggLyAzLCBib3VuZHMudG9wICsgbGVmdEhlaWdodCwgYmxoIC0gYm9yZGVyTGVmdFdpZHRoIC8gMywgYmx2IC0gYm9yZGVyQm90dG9tV2lkdGggLyAzLCBDT1JORVIuQk9UVE9NX0xFRlQpXG4gICAgICAgICAgICAgICAgICAgIDogbmV3IFZlY3Rvcihib3VuZHMubGVmdCArIGJvcmRlckxlZnRXaWR0aCAvIDMsIGJvdW5kcy50b3AgKyBib3VuZHMuaGVpZ2h0IC0gYm9yZGVyQm90dG9tV2lkdGggLyAzKTtcbiAgICAgICAgICAgIHRoaXMudG9wTGVmdEJvcmRlckRvdWJsZUlubmVyQm94ID1cbiAgICAgICAgICAgICAgICB0bGggPiAwIHx8IHRsdiA+IDBcbiAgICAgICAgICAgICAgICAgICAgPyBnZXRDdXJ2ZVBvaW50cyhib3VuZHMubGVmdCArIChib3JkZXJMZWZ0V2lkdGggKiAyKSAvIDMsIGJvdW5kcy50b3AgKyAoYm9yZGVyVG9wV2lkdGggKiAyKSAvIDMsIHRsaCAtIChib3JkZXJMZWZ0V2lkdGggKiAyKSAvIDMsIHRsdiAtIChib3JkZXJUb3BXaWR0aCAqIDIpIC8gMywgQ09STkVSLlRPUF9MRUZUKVxuICAgICAgICAgICAgICAgICAgICA6IG5ldyBWZWN0b3IoYm91bmRzLmxlZnQgKyAoYm9yZGVyTGVmdFdpZHRoICogMikgLyAzLCBib3VuZHMudG9wICsgKGJvcmRlclRvcFdpZHRoICogMikgLyAzKTtcbiAgICAgICAgICAgIHRoaXMudG9wUmlnaHRCb3JkZXJEb3VibGVJbm5lckJveCA9XG4gICAgICAgICAgICAgICAgdGxoID4gMCB8fCB0bHYgPiAwXG4gICAgICAgICAgICAgICAgICAgID8gZ2V0Q3VydmVQb2ludHMoYm91bmRzLmxlZnQgKyB0b3BXaWR0aCwgYm91bmRzLnRvcCArIChib3JkZXJUb3BXaWR0aCAqIDIpIC8gMywgdHJoIC0gKGJvcmRlclJpZ2h0V2lkdGggKiAyKSAvIDMsIHRydiAtIChib3JkZXJUb3BXaWR0aCAqIDIpIC8gMywgQ09STkVSLlRPUF9SSUdIVClcbiAgICAgICAgICAgICAgICAgICAgOiBuZXcgVmVjdG9yKGJvdW5kcy5sZWZ0ICsgYm91bmRzLndpZHRoIC0gKGJvcmRlclJpZ2h0V2lkdGggKiAyKSAvIDMsIGJvdW5kcy50b3AgKyAoYm9yZGVyVG9wV2lkdGggKiAyKSAvIDMpO1xuICAgICAgICAgICAgdGhpcy5ib3R0b21SaWdodEJvcmRlckRvdWJsZUlubmVyQm94ID1cbiAgICAgICAgICAgICAgICBicmggPiAwIHx8IGJydiA+IDBcbiAgICAgICAgICAgICAgICAgICAgPyBnZXRDdXJ2ZVBvaW50cyhib3VuZHMubGVmdCArIGJvdHRvbVdpZHRoLCBib3VuZHMudG9wICsgcmlnaHRIZWlnaHQsIGJyaCAtIChib3JkZXJSaWdodFdpZHRoICogMikgLyAzLCBicnYgLSAoYm9yZGVyQm90dG9tV2lkdGggKiAyKSAvIDMsIENPUk5FUi5CT1RUT01fUklHSFQpXG4gICAgICAgICAgICAgICAgICAgIDogbmV3IFZlY3Rvcihib3VuZHMubGVmdCArIGJvdW5kcy53aWR0aCAtIChib3JkZXJSaWdodFdpZHRoICogMikgLyAzLCBib3VuZHMudG9wICsgYm91bmRzLmhlaWdodCAtIChib3JkZXJCb3R0b21XaWR0aCAqIDIpIC8gMyk7XG4gICAgICAgICAgICB0aGlzLmJvdHRvbUxlZnRCb3JkZXJEb3VibGVJbm5lckJveCA9XG4gICAgICAgICAgICAgICAgYmxoID4gMCB8fCBibHYgPiAwXG4gICAgICAgICAgICAgICAgICAgID8gZ2V0Q3VydmVQb2ludHMoYm91bmRzLmxlZnQgKyAoYm9yZGVyTGVmdFdpZHRoICogMikgLyAzLCBib3VuZHMudG9wICsgbGVmdEhlaWdodCwgYmxoIC0gKGJvcmRlckxlZnRXaWR0aCAqIDIpIC8gMywgYmx2IC0gKGJvcmRlckJvdHRvbVdpZHRoICogMikgLyAzLCBDT1JORVIuQk9UVE9NX0xFRlQpXG4gICAgICAgICAgICAgICAgICAgIDogbmV3IFZlY3Rvcihib3VuZHMubGVmdCArIChib3JkZXJMZWZ0V2lkdGggKiAyKSAvIDMsIGJvdW5kcy50b3AgKyBib3VuZHMuaGVpZ2h0IC0gKGJvcmRlckJvdHRvbVdpZHRoICogMikgLyAzKTtcbiAgICAgICAgICAgIHRoaXMudG9wTGVmdEJvcmRlclN0cm9rZSA9XG4gICAgICAgICAgICAgICAgdGxoID4gMCB8fCB0bHYgPiAwXG4gICAgICAgICAgICAgICAgICAgID8gZ2V0Q3VydmVQb2ludHMoYm91bmRzLmxlZnQgKyBib3JkZXJMZWZ0V2lkdGggLyAyLCBib3VuZHMudG9wICsgYm9yZGVyVG9wV2lkdGggLyAyLCB0bGggLSBib3JkZXJMZWZ0V2lkdGggLyAyLCB0bHYgLSBib3JkZXJUb3BXaWR0aCAvIDIsIENPUk5FUi5UT1BfTEVGVClcbiAgICAgICAgICAgICAgICAgICAgOiBuZXcgVmVjdG9yKGJvdW5kcy5sZWZ0ICsgYm9yZGVyTGVmdFdpZHRoIC8gMiwgYm91bmRzLnRvcCArIGJvcmRlclRvcFdpZHRoIC8gMik7XG4gICAgICAgICAgICB0aGlzLnRvcFJpZ2h0Qm9yZGVyU3Ryb2tlID1cbiAgICAgICAgICAgICAgICB0bGggPiAwIHx8IHRsdiA+IDBcbiAgICAgICAgICAgICAgICAgICAgPyBnZXRDdXJ2ZVBvaW50cyhib3VuZHMubGVmdCArIHRvcFdpZHRoLCBib3VuZHMudG9wICsgYm9yZGVyVG9wV2lkdGggLyAyLCB0cmggLSBib3JkZXJSaWdodFdpZHRoIC8gMiwgdHJ2IC0gYm9yZGVyVG9wV2lkdGggLyAyLCBDT1JORVIuVE9QX1JJR0hUKVxuICAgICAgICAgICAgICAgICAgICA6IG5ldyBWZWN0b3IoYm91bmRzLmxlZnQgKyBib3VuZHMud2lkdGggLSBib3JkZXJSaWdodFdpZHRoIC8gMiwgYm91bmRzLnRvcCArIGJvcmRlclRvcFdpZHRoIC8gMik7XG4gICAgICAgICAgICB0aGlzLmJvdHRvbVJpZ2h0Qm9yZGVyU3Ryb2tlID1cbiAgICAgICAgICAgICAgICBicmggPiAwIHx8IGJydiA+IDBcbiAgICAgICAgICAgICAgICAgICAgPyBnZXRDdXJ2ZVBvaW50cyhib3VuZHMubGVmdCArIGJvdHRvbVdpZHRoLCBib3VuZHMudG9wICsgcmlnaHRIZWlnaHQsIGJyaCAtIGJvcmRlclJpZ2h0V2lkdGggLyAyLCBicnYgLSBib3JkZXJCb3R0b21XaWR0aCAvIDIsIENPUk5FUi5CT1RUT01fUklHSFQpXG4gICAgICAgICAgICAgICAgICAgIDogbmV3IFZlY3Rvcihib3VuZHMubGVmdCArIGJvdW5kcy53aWR0aCAtIGJvcmRlclJpZ2h0V2lkdGggLyAyLCBib3VuZHMudG9wICsgYm91bmRzLmhlaWdodCAtIGJvcmRlckJvdHRvbVdpZHRoIC8gMik7XG4gICAgICAgICAgICB0aGlzLmJvdHRvbUxlZnRCb3JkZXJTdHJva2UgPVxuICAgICAgICAgICAgICAgIGJsaCA+IDAgfHwgYmx2ID4gMFxuICAgICAgICAgICAgICAgICAgICA/IGdldEN1cnZlUG9pbnRzKGJvdW5kcy5sZWZ0ICsgYm9yZGVyTGVmdFdpZHRoIC8gMiwgYm91bmRzLnRvcCArIGxlZnRIZWlnaHQsIGJsaCAtIGJvcmRlckxlZnRXaWR0aCAvIDIsIGJsdiAtIGJvcmRlckJvdHRvbVdpZHRoIC8gMiwgQ09STkVSLkJPVFRPTV9MRUZUKVxuICAgICAgICAgICAgICAgICAgICA6IG5ldyBWZWN0b3IoYm91bmRzLmxlZnQgKyBib3JkZXJMZWZ0V2lkdGggLyAyLCBib3VuZHMudG9wICsgYm91bmRzLmhlaWdodCAtIGJvcmRlckJvdHRvbVdpZHRoIC8gMik7XG4gICAgICAgICAgICB0aGlzLnRvcExlZnRCb3JkZXJCb3ggPVxuICAgICAgICAgICAgICAgIHRsaCA+IDAgfHwgdGx2ID4gMFxuICAgICAgICAgICAgICAgICAgICA/IGdldEN1cnZlUG9pbnRzKGJvdW5kcy5sZWZ0LCBib3VuZHMudG9wLCB0bGgsIHRsdiwgQ09STkVSLlRPUF9MRUZUKVxuICAgICAgICAgICAgICAgICAgICA6IG5ldyBWZWN0b3IoYm91bmRzLmxlZnQsIGJvdW5kcy50b3ApO1xuICAgICAgICAgICAgdGhpcy50b3BSaWdodEJvcmRlckJveCA9XG4gICAgICAgICAgICAgICAgdHJoID4gMCB8fCB0cnYgPiAwXG4gICAgICAgICAgICAgICAgICAgID8gZ2V0Q3VydmVQb2ludHMoYm91bmRzLmxlZnQgKyB0b3BXaWR0aCwgYm91bmRzLnRvcCwgdHJoLCB0cnYsIENPUk5FUi5UT1BfUklHSFQpXG4gICAgICAgICAgICAgICAgICAgIDogbmV3IFZlY3Rvcihib3VuZHMubGVmdCArIGJvdW5kcy53aWR0aCwgYm91bmRzLnRvcCk7XG4gICAgICAgICAgICB0aGlzLmJvdHRvbVJpZ2h0Qm9yZGVyQm94ID1cbiAgICAgICAgICAgICAgICBicmggPiAwIHx8IGJydiA+IDBcbiAgICAgICAgICAgICAgICAgICAgPyBnZXRDdXJ2ZVBvaW50cyhib3VuZHMubGVmdCArIGJvdHRvbVdpZHRoLCBib3VuZHMudG9wICsgcmlnaHRIZWlnaHQsIGJyaCwgYnJ2LCBDT1JORVIuQk9UVE9NX1JJR0hUKVxuICAgICAgICAgICAgICAgICAgICA6IG5ldyBWZWN0b3IoYm91bmRzLmxlZnQgKyBib3VuZHMud2lkdGgsIGJvdW5kcy50b3AgKyBib3VuZHMuaGVpZ2h0KTtcbiAgICAgICAgICAgIHRoaXMuYm90dG9tTGVmdEJvcmRlckJveCA9XG4gICAgICAgICAgICAgICAgYmxoID4gMCB8fCBibHYgPiAwXG4gICAgICAgICAgICAgICAgICAgID8gZ2V0Q3VydmVQb2ludHMoYm91bmRzLmxlZnQsIGJvdW5kcy50b3AgKyBsZWZ0SGVpZ2h0LCBibGgsIGJsdiwgQ09STkVSLkJPVFRPTV9MRUZUKVxuICAgICAgICAgICAgICAgICAgICA6IG5ldyBWZWN0b3IoYm91bmRzLmxlZnQsIGJvdW5kcy50b3AgKyBib3VuZHMuaGVpZ2h0KTtcbiAgICAgICAgICAgIHRoaXMudG9wTGVmdFBhZGRpbmdCb3ggPVxuICAgICAgICAgICAgICAgIHRsaCA+IDAgfHwgdGx2ID4gMFxuICAgICAgICAgICAgICAgICAgICA/IGdldEN1cnZlUG9pbnRzKGJvdW5kcy5sZWZ0ICsgYm9yZGVyTGVmdFdpZHRoLCBib3VuZHMudG9wICsgYm9yZGVyVG9wV2lkdGgsIE1hdGgubWF4KDAsIHRsaCAtIGJvcmRlckxlZnRXaWR0aCksIE1hdGgubWF4KDAsIHRsdiAtIGJvcmRlclRvcFdpZHRoKSwgQ09STkVSLlRPUF9MRUZUKVxuICAgICAgICAgICAgICAgICAgICA6IG5ldyBWZWN0b3IoYm91bmRzLmxlZnQgKyBib3JkZXJMZWZ0V2lkdGgsIGJvdW5kcy50b3AgKyBib3JkZXJUb3BXaWR0aCk7XG4gICAgICAgICAgICB0aGlzLnRvcFJpZ2h0UGFkZGluZ0JveCA9XG4gICAgICAgICAgICAgICAgdHJoID4gMCB8fCB0cnYgPiAwXG4gICAgICAgICAgICAgICAgICAgID8gZ2V0Q3VydmVQb2ludHMoYm91bmRzLmxlZnQgKyBNYXRoLm1pbih0b3BXaWR0aCwgYm91bmRzLndpZHRoIC0gYm9yZGVyUmlnaHRXaWR0aCksIGJvdW5kcy50b3AgKyBib3JkZXJUb3BXaWR0aCwgdG9wV2lkdGggPiBib3VuZHMud2lkdGggKyBib3JkZXJSaWdodFdpZHRoID8gMCA6IE1hdGgubWF4KDAsIHRyaCAtIGJvcmRlclJpZ2h0V2lkdGgpLCBNYXRoLm1heCgwLCB0cnYgLSBib3JkZXJUb3BXaWR0aCksIENPUk5FUi5UT1BfUklHSFQpXG4gICAgICAgICAgICAgICAgICAgIDogbmV3IFZlY3Rvcihib3VuZHMubGVmdCArIGJvdW5kcy53aWR0aCAtIGJvcmRlclJpZ2h0V2lkdGgsIGJvdW5kcy50b3AgKyBib3JkZXJUb3BXaWR0aCk7XG4gICAgICAgICAgICB0aGlzLmJvdHRvbVJpZ2h0UGFkZGluZ0JveCA9XG4gICAgICAgICAgICAgICAgYnJoID4gMCB8fCBicnYgPiAwXG4gICAgICAgICAgICAgICAgICAgID8gZ2V0Q3VydmVQb2ludHMoYm91bmRzLmxlZnQgKyBNYXRoLm1pbihib3R0b21XaWR0aCwgYm91bmRzLndpZHRoIC0gYm9yZGVyTGVmdFdpZHRoKSwgYm91bmRzLnRvcCArIE1hdGgubWluKHJpZ2h0SGVpZ2h0LCBib3VuZHMuaGVpZ2h0IC0gYm9yZGVyQm90dG9tV2lkdGgpLCBNYXRoLm1heCgwLCBicmggLSBib3JkZXJSaWdodFdpZHRoKSwgTWF0aC5tYXgoMCwgYnJ2IC0gYm9yZGVyQm90dG9tV2lkdGgpLCBDT1JORVIuQk9UVE9NX1JJR0hUKVxuICAgICAgICAgICAgICAgICAgICA6IG5ldyBWZWN0b3IoYm91bmRzLmxlZnQgKyBib3VuZHMud2lkdGggLSBib3JkZXJSaWdodFdpZHRoLCBib3VuZHMudG9wICsgYm91bmRzLmhlaWdodCAtIGJvcmRlckJvdHRvbVdpZHRoKTtcbiAgICAgICAgICAgIHRoaXMuYm90dG9tTGVmdFBhZGRpbmdCb3ggPVxuICAgICAgICAgICAgICAgIGJsaCA+IDAgfHwgYmx2ID4gMFxuICAgICAgICAgICAgICAgICAgICA/IGdldEN1cnZlUG9pbnRzKGJvdW5kcy5sZWZ0ICsgYm9yZGVyTGVmdFdpZHRoLCBib3VuZHMudG9wICsgTWF0aC5taW4obGVmdEhlaWdodCwgYm91bmRzLmhlaWdodCAtIGJvcmRlckJvdHRvbVdpZHRoKSwgTWF0aC5tYXgoMCwgYmxoIC0gYm9yZGVyTGVmdFdpZHRoKSwgTWF0aC5tYXgoMCwgYmx2IC0gYm9yZGVyQm90dG9tV2lkdGgpLCBDT1JORVIuQk9UVE9NX0xFRlQpXG4gICAgICAgICAgICAgICAgICAgIDogbmV3IFZlY3Rvcihib3VuZHMubGVmdCArIGJvcmRlckxlZnRXaWR0aCwgYm91bmRzLnRvcCArIGJvdW5kcy5oZWlnaHQgLSBib3JkZXJCb3R0b21XaWR0aCk7XG4gICAgICAgICAgICB0aGlzLnRvcExlZnRDb250ZW50Qm94ID1cbiAgICAgICAgICAgICAgICB0bGggPiAwIHx8IHRsdiA+IDBcbiAgICAgICAgICAgICAgICAgICAgPyBnZXRDdXJ2ZVBvaW50cyhib3VuZHMubGVmdCArIGJvcmRlckxlZnRXaWR0aCArIHBhZGRpbmdMZWZ0LCBib3VuZHMudG9wICsgYm9yZGVyVG9wV2lkdGggKyBwYWRkaW5nVG9wLCBNYXRoLm1heCgwLCB0bGggLSAoYm9yZGVyTGVmdFdpZHRoICsgcGFkZGluZ0xlZnQpKSwgTWF0aC5tYXgoMCwgdGx2IC0gKGJvcmRlclRvcFdpZHRoICsgcGFkZGluZ1RvcCkpLCBDT1JORVIuVE9QX0xFRlQpXG4gICAgICAgICAgICAgICAgICAgIDogbmV3IFZlY3Rvcihib3VuZHMubGVmdCArIGJvcmRlckxlZnRXaWR0aCArIHBhZGRpbmdMZWZ0LCBib3VuZHMudG9wICsgYm9yZGVyVG9wV2lkdGggKyBwYWRkaW5nVG9wKTtcbiAgICAgICAgICAgIHRoaXMudG9wUmlnaHRDb250ZW50Qm94ID1cbiAgICAgICAgICAgICAgICB0cmggPiAwIHx8IHRydiA+IDBcbiAgICAgICAgICAgICAgICAgICAgPyBnZXRDdXJ2ZVBvaW50cyhib3VuZHMubGVmdCArIE1hdGgubWluKHRvcFdpZHRoLCBib3VuZHMud2lkdGggKyBib3JkZXJMZWZ0V2lkdGggKyBwYWRkaW5nTGVmdCksIGJvdW5kcy50b3AgKyBib3JkZXJUb3BXaWR0aCArIHBhZGRpbmdUb3AsIHRvcFdpZHRoID4gYm91bmRzLndpZHRoICsgYm9yZGVyTGVmdFdpZHRoICsgcGFkZGluZ0xlZnQgPyAwIDogdHJoIC0gYm9yZGVyTGVmdFdpZHRoICsgcGFkZGluZ0xlZnQsIHRydiAtIChib3JkZXJUb3BXaWR0aCArIHBhZGRpbmdUb3ApLCBDT1JORVIuVE9QX1JJR0hUKVxuICAgICAgICAgICAgICAgICAgICA6IG5ldyBWZWN0b3IoYm91bmRzLmxlZnQgKyBib3VuZHMud2lkdGggLSAoYm9yZGVyUmlnaHRXaWR0aCArIHBhZGRpbmdSaWdodCksIGJvdW5kcy50b3AgKyBib3JkZXJUb3BXaWR0aCArIHBhZGRpbmdUb3ApO1xuICAgICAgICAgICAgdGhpcy5ib3R0b21SaWdodENvbnRlbnRCb3ggPVxuICAgICAgICAgICAgICAgIGJyaCA+IDAgfHwgYnJ2ID4gMFxuICAgICAgICAgICAgICAgICAgICA/IGdldEN1cnZlUG9pbnRzKGJvdW5kcy5sZWZ0ICsgTWF0aC5taW4oYm90dG9tV2lkdGgsIGJvdW5kcy53aWR0aCAtIChib3JkZXJMZWZ0V2lkdGggKyBwYWRkaW5nTGVmdCkpLCBib3VuZHMudG9wICsgTWF0aC5taW4ocmlnaHRIZWlnaHQsIGJvdW5kcy5oZWlnaHQgKyBib3JkZXJUb3BXaWR0aCArIHBhZGRpbmdUb3ApLCBNYXRoLm1heCgwLCBicmggLSAoYm9yZGVyUmlnaHRXaWR0aCArIHBhZGRpbmdSaWdodCkpLCBicnYgLSAoYm9yZGVyQm90dG9tV2lkdGggKyBwYWRkaW5nQm90dG9tKSwgQ09STkVSLkJPVFRPTV9SSUdIVClcbiAgICAgICAgICAgICAgICAgICAgOiBuZXcgVmVjdG9yKGJvdW5kcy5sZWZ0ICsgYm91bmRzLndpZHRoIC0gKGJvcmRlclJpZ2h0V2lkdGggKyBwYWRkaW5nUmlnaHQpLCBib3VuZHMudG9wICsgYm91bmRzLmhlaWdodCAtIChib3JkZXJCb3R0b21XaWR0aCArIHBhZGRpbmdCb3R0b20pKTtcbiAgICAgICAgICAgIHRoaXMuYm90dG9tTGVmdENvbnRlbnRCb3ggPVxuICAgICAgICAgICAgICAgIGJsaCA+IDAgfHwgYmx2ID4gMFxuICAgICAgICAgICAgICAgICAgICA/IGdldEN1cnZlUG9pbnRzKGJvdW5kcy5sZWZ0ICsgYm9yZGVyTGVmdFdpZHRoICsgcGFkZGluZ0xlZnQsIGJvdW5kcy50b3AgKyBsZWZ0SGVpZ2h0LCBNYXRoLm1heCgwLCBibGggLSAoYm9yZGVyTGVmdFdpZHRoICsgcGFkZGluZ0xlZnQpKSwgYmx2IC0gKGJvcmRlckJvdHRvbVdpZHRoICsgcGFkZGluZ0JvdHRvbSksIENPUk5FUi5CT1RUT01fTEVGVClcbiAgICAgICAgICAgICAgICAgICAgOiBuZXcgVmVjdG9yKGJvdW5kcy5sZWZ0ICsgYm9yZGVyTGVmdFdpZHRoICsgcGFkZGluZ0xlZnQsIGJvdW5kcy50b3AgKyBib3VuZHMuaGVpZ2h0IC0gKGJvcmRlckJvdHRvbVdpZHRoICsgcGFkZGluZ0JvdHRvbSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBCb3VuZEN1cnZlcztcbiAgICB9KCkpO1xuICAgIHZhciBDT1JORVI7XG4gICAgKGZ1bmN0aW9uIChDT1JORVIpIHtcbiAgICAgICAgQ09STkVSW0NPUk5FUltcIlRPUF9MRUZUXCJdID0gMF0gPSBcIlRPUF9MRUZUXCI7XG4gICAgICAgIENPUk5FUltDT1JORVJbXCJUT1BfUklHSFRcIl0gPSAxXSA9IFwiVE9QX1JJR0hUXCI7XG4gICAgICAgIENPUk5FUltDT1JORVJbXCJCT1RUT01fUklHSFRcIl0gPSAyXSA9IFwiQk9UVE9NX1JJR0hUXCI7XG4gICAgICAgIENPUk5FUltDT1JORVJbXCJCT1RUT01fTEVGVFwiXSA9IDNdID0gXCJCT1RUT01fTEVGVFwiO1xuICAgIH0pKENPUk5FUiB8fCAoQ09STkVSID0ge30pKTtcbiAgICB2YXIgZ2V0Q3VydmVQb2ludHMgPSBmdW5jdGlvbiAoeCwgeSwgcjEsIHIyLCBwb3NpdGlvbikge1xuICAgICAgICB2YXIga2FwcGEgPSA0ICogKChNYXRoLnNxcnQoMikgLSAxKSAvIDMpO1xuICAgICAgICB2YXIgb3ggPSByMSAqIGthcHBhOyAvLyBjb250cm9sIHBvaW50IG9mZnNldCBob3Jpem9udGFsXG4gICAgICAgIHZhciBveSA9IHIyICoga2FwcGE7IC8vIGNvbnRyb2wgcG9pbnQgb2Zmc2V0IHZlcnRpY2FsXG4gICAgICAgIHZhciB4bSA9IHggKyByMTsgLy8geC1taWRkbGVcbiAgICAgICAgdmFyIHltID0geSArIHIyOyAvLyB5LW1pZGRsZVxuICAgICAgICBzd2l0Y2ggKHBvc2l0aW9uKSB7XG4gICAgICAgICAgICBjYXNlIENPUk5FUi5UT1BfTEVGVDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJlemllckN1cnZlKG5ldyBWZWN0b3IoeCwgeW0pLCBuZXcgVmVjdG9yKHgsIHltIC0gb3kpLCBuZXcgVmVjdG9yKHhtIC0gb3gsIHkpLCBuZXcgVmVjdG9yKHhtLCB5KSk7XG4gICAgICAgICAgICBjYXNlIENPUk5FUi5UT1BfUklHSFQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCZXppZXJDdXJ2ZShuZXcgVmVjdG9yKHgsIHkpLCBuZXcgVmVjdG9yKHggKyBveCwgeSksIG5ldyBWZWN0b3IoeG0sIHltIC0gb3kpLCBuZXcgVmVjdG9yKHhtLCB5bSkpO1xuICAgICAgICAgICAgY2FzZSBDT1JORVIuQk9UVE9NX1JJR0hUOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQmV6aWVyQ3VydmUobmV3IFZlY3Rvcih4bSwgeSksIG5ldyBWZWN0b3IoeG0sIHkgKyBveSksIG5ldyBWZWN0b3IoeCArIG94LCB5bSksIG5ldyBWZWN0b3IoeCwgeW0pKTtcbiAgICAgICAgICAgIGNhc2UgQ09STkVSLkJPVFRPTV9MRUZUOlxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJlemllckN1cnZlKG5ldyBWZWN0b3IoeG0sIHltKSwgbmV3IFZlY3Rvcih4bSAtIG94LCB5bSksIG5ldyBWZWN0b3IoeCwgeSArIG95KSwgbmV3IFZlY3Rvcih4LCB5KSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBjYWxjdWxhdGVCb3JkZXJCb3hQYXRoID0gZnVuY3Rpb24gKGN1cnZlcykge1xuICAgICAgICByZXR1cm4gW2N1cnZlcy50b3BMZWZ0Qm9yZGVyQm94LCBjdXJ2ZXMudG9wUmlnaHRCb3JkZXJCb3gsIGN1cnZlcy5ib3R0b21SaWdodEJvcmRlckJveCwgY3VydmVzLmJvdHRvbUxlZnRCb3JkZXJCb3hdO1xuICAgIH07XG4gICAgdmFyIGNhbGN1bGF0ZUNvbnRlbnRCb3hQYXRoID0gZnVuY3Rpb24gKGN1cnZlcykge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgY3VydmVzLnRvcExlZnRDb250ZW50Qm94LFxuICAgICAgICAgICAgY3VydmVzLnRvcFJpZ2h0Q29udGVudEJveCxcbiAgICAgICAgICAgIGN1cnZlcy5ib3R0b21SaWdodENvbnRlbnRCb3gsXG4gICAgICAgICAgICBjdXJ2ZXMuYm90dG9tTGVmdENvbnRlbnRCb3hcbiAgICAgICAgXTtcbiAgICB9O1xuICAgIHZhciBjYWxjdWxhdGVQYWRkaW5nQm94UGF0aCA9IGZ1bmN0aW9uIChjdXJ2ZXMpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGN1cnZlcy50b3BMZWZ0UGFkZGluZ0JveCxcbiAgICAgICAgICAgIGN1cnZlcy50b3BSaWdodFBhZGRpbmdCb3gsXG4gICAgICAgICAgICBjdXJ2ZXMuYm90dG9tUmlnaHRQYWRkaW5nQm94LFxuICAgICAgICAgICAgY3VydmVzLmJvdHRvbUxlZnRQYWRkaW5nQm94XG4gICAgICAgIF07XG4gICAgfTtcblxuICAgIHZhciBUcmFuc2Zvcm1FZmZlY3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFRyYW5zZm9ybUVmZmVjdChvZmZzZXRYLCBvZmZzZXRZLCBtYXRyaXgpIHtcbiAgICAgICAgICAgIHRoaXMub2Zmc2V0WCA9IG9mZnNldFg7XG4gICAgICAgICAgICB0aGlzLm9mZnNldFkgPSBvZmZzZXRZO1xuICAgICAgICAgICAgdGhpcy5tYXRyaXggPSBtYXRyaXg7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSAwIC8qIFRSQU5TRk9STSAqLztcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0ID0gMiAvKiBCQUNLR1JPVU5EX0JPUkRFUlMgKi8gfCA0IC8qIENPTlRFTlQgKi87XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFRyYW5zZm9ybUVmZmVjdDtcbiAgICB9KCkpO1xuICAgIHZhciBDbGlwRWZmZWN0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBDbGlwRWZmZWN0KHBhdGgsIHRhcmdldCkge1xuICAgICAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICAgICAgdGhpcy50eXBlID0gMSAvKiBDTElQICovO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBDbGlwRWZmZWN0O1xuICAgIH0oKSk7XG4gICAgdmFyIE9wYWNpdHlFZmZlY3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIE9wYWNpdHlFZmZlY3Qob3BhY2l0eSkge1xuICAgICAgICAgICAgdGhpcy5vcGFjaXR5ID0gb3BhY2l0eTtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IDIgLyogT1BBQ0lUWSAqLztcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0ID0gMiAvKiBCQUNLR1JPVU5EX0JPUkRFUlMgKi8gfCA0IC8qIENPTlRFTlQgKi87XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9wYWNpdHlFZmZlY3Q7XG4gICAgfSgpKTtcbiAgICB2YXIgaXNUcmFuc2Zvcm1FZmZlY3QgPSBmdW5jdGlvbiAoZWZmZWN0KSB7XG4gICAgICAgIHJldHVybiBlZmZlY3QudHlwZSA9PT0gMCAvKiBUUkFOU0ZPUk0gKi87XG4gICAgfTtcbiAgICB2YXIgaXNDbGlwRWZmZWN0ID0gZnVuY3Rpb24gKGVmZmVjdCkgeyByZXR1cm4gZWZmZWN0LnR5cGUgPT09IDEgLyogQ0xJUCAqLzsgfTtcbiAgICB2YXIgaXNPcGFjaXR5RWZmZWN0ID0gZnVuY3Rpb24gKGVmZmVjdCkgeyByZXR1cm4gZWZmZWN0LnR5cGUgPT09IDIgLyogT1BBQ0lUWSAqLzsgfTtcblxuICAgIHZhciBlcXVhbFBhdGggPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICBpZiAoYS5sZW5ndGggPT09IGIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gYS5zb21lKGZ1bmN0aW9uICh2LCBpKSB7IHJldHVybiB2ID09PSBiW2ldOyB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICB2YXIgdHJhbnNmb3JtUGF0aCA9IGZ1bmN0aW9uIChwYXRoLCBkZWx0YVgsIGRlbHRhWSwgZGVsdGFXLCBkZWx0YUgpIHtcbiAgICAgICAgcmV0dXJuIHBhdGgubWFwKGZ1bmN0aW9uIChwb2ludCwgaW5kZXgpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwb2ludC5hZGQoZGVsdGFYLCBkZWx0YVkpO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBvaW50LmFkZChkZWx0YVggKyBkZWx0YVcsIGRlbHRhWSk7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcG9pbnQuYWRkKGRlbHRhWCArIGRlbHRhVywgZGVsdGFZICsgZGVsdGFIKTtcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwb2ludC5hZGQoZGVsdGFYLCBkZWx0YVkgKyBkZWx0YUgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBvaW50O1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIFN0YWNraW5nQ29udGV4dCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gU3RhY2tpbmdDb250ZXh0KGNvbnRhaW5lcikge1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50ID0gY29udGFpbmVyO1xuICAgICAgICAgICAgdGhpcy5pbmxpbmVMZXZlbCA9IFtdO1xuICAgICAgICAgICAgdGhpcy5ub25JbmxpbmVMZXZlbCA9IFtdO1xuICAgICAgICAgICAgdGhpcy5uZWdhdGl2ZVpJbmRleCA9IFtdO1xuICAgICAgICAgICAgdGhpcy56ZXJvT3JBdXRvWkluZGV4T3JUcmFuc2Zvcm1lZE9yT3BhY2l0eSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5wb3NpdGl2ZVpJbmRleCA9IFtdO1xuICAgICAgICAgICAgdGhpcy5ub25Qb3NpdGlvbmVkRmxvYXRzID0gW107XG4gICAgICAgICAgICB0aGlzLm5vblBvc2l0aW9uZWRJbmxpbmVMZXZlbCA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTdGFja2luZ0NvbnRleHQ7XG4gICAgfSgpKTtcbiAgICB2YXIgRWxlbWVudFBhaW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBFbGVtZW50UGFpbnQoY29udGFpbmVyLCBwYXJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgICAgICB0aGlzLmVmZmVjdHMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuY3VydmVzID0gbmV3IEJvdW5kQ3VydmVzKHRoaXMuY29udGFpbmVyKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRhaW5lci5zdHlsZXMub3BhY2l0eSA8IDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVmZmVjdHMucHVzaChuZXcgT3BhY2l0eUVmZmVjdCh0aGlzLmNvbnRhaW5lci5zdHlsZXMub3BhY2l0eSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29udGFpbmVyLnN0eWxlcy50cmFuc2Zvcm0gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0WCA9IHRoaXMuY29udGFpbmVyLmJvdW5kcy5sZWZ0ICsgdGhpcy5jb250YWluZXIuc3R5bGVzLnRyYW5zZm9ybU9yaWdpblswXS5udW1iZXI7XG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldFkgPSB0aGlzLmNvbnRhaW5lci5ib3VuZHMudG9wICsgdGhpcy5jb250YWluZXIuc3R5bGVzLnRyYW5zZm9ybU9yaWdpblsxXS5udW1iZXI7XG4gICAgICAgICAgICAgICAgdmFyIG1hdHJpeCA9IHRoaXMuY29udGFpbmVyLnN0eWxlcy50cmFuc2Zvcm07XG4gICAgICAgICAgICAgICAgdGhpcy5lZmZlY3RzLnB1c2gobmV3IFRyYW5zZm9ybUVmZmVjdChvZmZzZXRYLCBvZmZzZXRZLCBtYXRyaXgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRhaW5lci5zdHlsZXMub3ZlcmZsb3dYICE9PSAwIC8qIFZJU0lCTEUgKi8pIHtcbiAgICAgICAgICAgICAgICB2YXIgYm9yZGVyQm94ID0gY2FsY3VsYXRlQm9yZGVyQm94UGF0aCh0aGlzLmN1cnZlcyk7XG4gICAgICAgICAgICAgICAgdmFyIHBhZGRpbmdCb3ggPSBjYWxjdWxhdGVQYWRkaW5nQm94UGF0aCh0aGlzLmN1cnZlcyk7XG4gICAgICAgICAgICAgICAgaWYgKGVxdWFsUGF0aChib3JkZXJCb3gsIHBhZGRpbmdCb3gpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWZmZWN0cy5wdXNoKG5ldyBDbGlwRWZmZWN0KGJvcmRlckJveCwgMiAvKiBCQUNLR1JPVU5EX0JPUkRFUlMgKi8gfCA0IC8qIENPTlRFTlQgKi8pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWZmZWN0cy5wdXNoKG5ldyBDbGlwRWZmZWN0KGJvcmRlckJveCwgMiAvKiBCQUNLR1JPVU5EX0JPUkRFUlMgKi8pKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lZmZlY3RzLnB1c2gobmV3IENsaXBFZmZlY3QocGFkZGluZ0JveCwgNCAvKiBDT05URU5UICovKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIEVsZW1lbnRQYWludC5wcm90b3R5cGUuZ2V0RWZmZWN0cyA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgICAgIHZhciBpbkZsb3cgPSBbMiAvKiBBQlNPTFVURSAqLywgMyAvKiBGSVhFRCAqL10uaW5kZXhPZih0aGlzLmNvbnRhaW5lci5zdHlsZXMucG9zaXRpb24pID09PSAtMTtcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudDtcbiAgICAgICAgICAgIHZhciBlZmZlY3RzID0gdGhpcy5lZmZlY3RzLnNsaWNlKDApO1xuICAgICAgICAgICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgICAgICAgICAgIHZhciBjcm9wbGVzc0VmZmVjdHMgPSBwYXJlbnQuZWZmZWN0cy5maWx0ZXIoZnVuY3Rpb24gKGVmZmVjdCkgeyByZXR1cm4gIWlzQ2xpcEVmZmVjdChlZmZlY3QpOyB9KTtcbiAgICAgICAgICAgICAgICBpZiAoaW5GbG93IHx8IHBhcmVudC5jb250YWluZXIuc3R5bGVzLnBvc2l0aW9uICE9PSAwIC8qIFNUQVRJQyAqLyB8fCAhcGFyZW50LnBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICBlZmZlY3RzLnVuc2hpZnQuYXBwbHkoZWZmZWN0cywgY3JvcGxlc3NFZmZlY3RzKTtcbiAgICAgICAgICAgICAgICAgICAgaW5GbG93ID0gWzIgLyogQUJTT0xVVEUgKi8sIDMgLyogRklYRUQgKi9dLmluZGV4T2YocGFyZW50LmNvbnRhaW5lci5zdHlsZXMucG9zaXRpb24pID09PSAtMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudC5jb250YWluZXIuc3R5bGVzLm92ZXJmbG93WCAhPT0gMCAvKiBWSVNJQkxFICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYm9yZGVyQm94ID0gY2FsY3VsYXRlQm9yZGVyQm94UGF0aChwYXJlbnQuY3VydmVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYWRkaW5nQm94ID0gY2FsY3VsYXRlUGFkZGluZ0JveFBhdGgocGFyZW50LmN1cnZlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWVxdWFsUGF0aChib3JkZXJCb3gsIHBhZGRpbmdCb3gpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWZmZWN0cy51bnNoaWZ0KG5ldyBDbGlwRWZmZWN0KHBhZGRpbmdCb3gsIDIgLyogQkFDS0dST1VORF9CT1JERVJTICovIHwgNCAvKiBDT05URU5UICovKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVmZmVjdHMudW5zaGlmdC5hcHBseShlZmZlY3RzLCBjcm9wbGVzc0VmZmVjdHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGVmZmVjdHMuZmlsdGVyKGZ1bmN0aW9uIChlZmZlY3QpIHsgcmV0dXJuIGNvbnRhaW5zKGVmZmVjdC50YXJnZXQsIHRhcmdldCk7IH0pO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gRWxlbWVudFBhaW50O1xuICAgIH0oKSk7XG4gICAgdmFyIHBhcnNlU3RhY2tUcmVlID0gZnVuY3Rpb24gKHBhcmVudCwgc3RhY2tpbmdDb250ZXh0LCByZWFsU3RhY2tpbmdDb250ZXh0LCBsaXN0SXRlbXMpIHtcbiAgICAgICAgcGFyZW50LmNvbnRhaW5lci5lbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgdmFyIHRyZWF0QXNSZWFsU3RhY2tpbmdDb250ZXh0ID0gY29udGFpbnMoY2hpbGQuZmxhZ3MsIDQgLyogQ1JFQVRFU19SRUFMX1NUQUNLSU5HX0NPTlRFWFQgKi8pO1xuICAgICAgICAgICAgdmFyIGNyZWF0ZXNTdGFja2luZ0NvbnRleHQgPSBjb250YWlucyhjaGlsZC5mbGFncywgMiAvKiBDUkVBVEVTX1NUQUNLSU5HX0NPTlRFWFQgKi8pO1xuICAgICAgICAgICAgdmFyIHBhaW50Q29udGFpbmVyID0gbmV3IEVsZW1lbnRQYWludChjaGlsZCwgcGFyZW50KTtcbiAgICAgICAgICAgIGlmIChjb250YWlucyhjaGlsZC5zdHlsZXMuZGlzcGxheSwgMjA0OCAvKiBMSVNUX0lURU0gKi8pKSB7XG4gICAgICAgICAgICAgICAgbGlzdEl0ZW1zLnB1c2gocGFpbnRDb250YWluZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGxpc3RPd25lckl0ZW1zID0gY29udGFpbnMoY2hpbGQuZmxhZ3MsIDggLyogSVNfTElTVF9PV05FUiAqLykgPyBbXSA6IGxpc3RJdGVtcztcbiAgICAgICAgICAgIGlmICh0cmVhdEFzUmVhbFN0YWNraW5nQ29udGV4dCB8fCBjcmVhdGVzU3RhY2tpbmdDb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudFN0YWNrID0gdHJlYXRBc1JlYWxTdGFja2luZ0NvbnRleHQgfHwgY2hpbGQuc3R5bGVzLmlzUG9zaXRpb25lZCgpID8gcmVhbFN0YWNraW5nQ29udGV4dCA6IHN0YWNraW5nQ29udGV4dDtcbiAgICAgICAgICAgICAgICB2YXIgc3RhY2sgPSBuZXcgU3RhY2tpbmdDb250ZXh0KHBhaW50Q29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQuc3R5bGVzLmlzUG9zaXRpb25lZCgpIHx8IGNoaWxkLnN0eWxlcy5vcGFjaXR5IDwgMSB8fCBjaGlsZC5zdHlsZXMuaXNUcmFuc2Zvcm1lZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvcmRlcl8xID0gY2hpbGQuc3R5bGVzLnpJbmRleC5vcmRlcjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9yZGVyXzEgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXhfMSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRTdGFjay5uZWdhdGl2ZVpJbmRleC5zb21lKGZ1bmN0aW9uIChjdXJyZW50LCBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9yZGVyXzEgPiBjdXJyZW50LmVsZW1lbnQuY29udGFpbmVyLnN0eWxlcy56SW5kZXgub3JkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXhfMSA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaW5kZXhfMSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50U3RhY2submVnYXRpdmVaSW5kZXguc3BsaWNlKGluZGV4XzEsIDAsIHN0YWNrKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChvcmRlcl8xID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4XzIgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50U3RhY2sucG9zaXRpdmVaSW5kZXguc29tZShmdW5jdGlvbiAoY3VycmVudCwgaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcmRlcl8xID49IGN1cnJlbnQuZWxlbWVudC5jb250YWluZXIuc3R5bGVzLnpJbmRleC5vcmRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleF8yID0gaSArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaW5kZXhfMiA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50U3RhY2sucG9zaXRpdmVaSW5kZXguc3BsaWNlKGluZGV4XzIsIDAsIHN0YWNrKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudFN0YWNrLnplcm9PckF1dG9aSW5kZXhPclRyYW5zZm9ybWVkT3JPcGFjaXR5LnB1c2goc3RhY2spO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQuc3R5bGVzLmlzRmxvYXRpbmcoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50U3RhY2subm9uUG9zaXRpb25lZEZsb2F0cy5wdXNoKHN0YWNrKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudFN0YWNrLm5vblBvc2l0aW9uZWRJbmxpbmVMZXZlbC5wdXNoKHN0YWNrKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJzZVN0YWNrVHJlZShwYWludENvbnRhaW5lciwgc3RhY2ssIHRyZWF0QXNSZWFsU3RhY2tpbmdDb250ZXh0ID8gc3RhY2sgOiByZWFsU3RhY2tpbmdDb250ZXh0LCBsaXN0T3duZXJJdGVtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQuc3R5bGVzLmlzSW5saW5lTGV2ZWwoKSkge1xuICAgICAgICAgICAgICAgICAgICBzdGFja2luZ0NvbnRleHQuaW5saW5lTGV2ZWwucHVzaChwYWludENvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdGFja2luZ0NvbnRleHQubm9uSW5saW5lTGV2ZWwucHVzaChwYWludENvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhcnNlU3RhY2tUcmVlKHBhaW50Q29udGFpbmVyLCBzdGFja2luZ0NvbnRleHQsIHJlYWxTdGFja2luZ0NvbnRleHQsIGxpc3RPd25lckl0ZW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb250YWlucyhjaGlsZC5mbGFncywgOCAvKiBJU19MSVNUX09XTkVSICovKSkge1xuICAgICAgICAgICAgICAgIHByb2Nlc3NMaXN0SXRlbXMoY2hpbGQsIGxpc3RPd25lckl0ZW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICB2YXIgcHJvY2Vzc0xpc3RJdGVtcyA9IGZ1bmN0aW9uIChvd25lciwgZWxlbWVudHMpIHtcbiAgICAgICAgdmFyIG51bWJlcmluZyA9IG93bmVyIGluc3RhbmNlb2YgT0xFbGVtZW50Q29udGFpbmVyID8gb3duZXIuc3RhcnQgOiAxO1xuICAgICAgICB2YXIgcmV2ZXJzZWQgPSBvd25lciBpbnN0YW5jZW9mIE9MRWxlbWVudENvbnRhaW5lciA/IG93bmVyLnJldmVyc2VkIDogZmFsc2U7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gZWxlbWVudHNbaV07XG4gICAgICAgICAgICBpZiAoaXRlbS5jb250YWluZXIgaW5zdGFuY2VvZiBMSUVsZW1lbnRDb250YWluZXIgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgaXRlbS5jb250YWluZXIudmFsdWUgPT09ICdudW1iZXInICYmXG4gICAgICAgICAgICAgICAgaXRlbS5jb250YWluZXIudmFsdWUgIT09IDApIHtcbiAgICAgICAgICAgICAgICBudW1iZXJpbmcgPSBpdGVtLmNvbnRhaW5lci52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGl0ZW0ubGlzdFZhbHVlID0gY3JlYXRlQ291bnRlclRleHQobnVtYmVyaW5nLCBpdGVtLmNvbnRhaW5lci5zdHlsZXMubGlzdFN0eWxlVHlwZSwgdHJ1ZSk7XG4gICAgICAgICAgICBudW1iZXJpbmcgKz0gcmV2ZXJzZWQgPyAtMSA6IDE7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBwYXJzZVN0YWNraW5nQ29udGV4dHMgPSBmdW5jdGlvbiAoY29udGFpbmVyKSB7XG4gICAgICAgIHZhciBwYWludENvbnRhaW5lciA9IG5ldyBFbGVtZW50UGFpbnQoY29udGFpbmVyLCBudWxsKTtcbiAgICAgICAgdmFyIHJvb3QgPSBuZXcgU3RhY2tpbmdDb250ZXh0KHBhaW50Q29udGFpbmVyKTtcbiAgICAgICAgdmFyIGxpc3RJdGVtcyA9IFtdO1xuICAgICAgICBwYXJzZVN0YWNrVHJlZShwYWludENvbnRhaW5lciwgcm9vdCwgcm9vdCwgbGlzdEl0ZW1zKTtcbiAgICAgICAgcHJvY2Vzc0xpc3RJdGVtcyhwYWludENvbnRhaW5lci5jb250YWluZXIsIGxpc3RJdGVtcyk7XG4gICAgICAgIHJldHVybiByb290O1xuICAgIH07XG5cbiAgICB2YXIgcGFyc2VQYXRoRm9yQm9yZGVyID0gZnVuY3Rpb24gKGN1cnZlcywgYm9yZGVyU2lkZSkge1xuICAgICAgICBzd2l0Y2ggKGJvcmRlclNpZGUpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlUGF0aEZyb21DdXJ2ZXMoY3VydmVzLnRvcExlZnRCb3JkZXJCb3gsIGN1cnZlcy50b3BMZWZ0UGFkZGluZ0JveCwgY3VydmVzLnRvcFJpZ2h0Qm9yZGVyQm94LCBjdXJ2ZXMudG9wUmlnaHRQYWRkaW5nQm94KTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlUGF0aEZyb21DdXJ2ZXMoY3VydmVzLnRvcFJpZ2h0Qm9yZGVyQm94LCBjdXJ2ZXMudG9wUmlnaHRQYWRkaW5nQm94LCBjdXJ2ZXMuYm90dG9tUmlnaHRCb3JkZXJCb3gsIGN1cnZlcy5ib3R0b21SaWdodFBhZGRpbmdCb3gpO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVQYXRoRnJvbUN1cnZlcyhjdXJ2ZXMuYm90dG9tUmlnaHRCb3JkZXJCb3gsIGN1cnZlcy5ib3R0b21SaWdodFBhZGRpbmdCb3gsIGN1cnZlcy5ib3R0b21MZWZ0Qm9yZGVyQm94LCBjdXJ2ZXMuYm90dG9tTGVmdFBhZGRpbmdCb3gpO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlUGF0aEZyb21DdXJ2ZXMoY3VydmVzLmJvdHRvbUxlZnRCb3JkZXJCb3gsIGN1cnZlcy5ib3R0b21MZWZ0UGFkZGluZ0JveCwgY3VydmVzLnRvcExlZnRCb3JkZXJCb3gsIGN1cnZlcy50b3BMZWZ0UGFkZGluZ0JveCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBwYXJzZVBhdGhGb3JCb3JkZXJEb3VibGVPdXRlciA9IGZ1bmN0aW9uIChjdXJ2ZXMsIGJvcmRlclNpZGUpIHtcbiAgICAgICAgc3dpdGNoIChib3JkZXJTaWRlKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVBhdGhGcm9tQ3VydmVzKGN1cnZlcy50b3BMZWZ0Qm9yZGVyQm94LCBjdXJ2ZXMudG9wTGVmdEJvcmRlckRvdWJsZU91dGVyQm94LCBjdXJ2ZXMudG9wUmlnaHRCb3JkZXJCb3gsIGN1cnZlcy50b3BSaWdodEJvcmRlckRvdWJsZU91dGVyQm94KTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlUGF0aEZyb21DdXJ2ZXMoY3VydmVzLnRvcFJpZ2h0Qm9yZGVyQm94LCBjdXJ2ZXMudG9wUmlnaHRCb3JkZXJEb3VibGVPdXRlckJveCwgY3VydmVzLmJvdHRvbVJpZ2h0Qm9yZGVyQm94LCBjdXJ2ZXMuYm90dG9tUmlnaHRCb3JkZXJEb3VibGVPdXRlckJveCk7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVBhdGhGcm9tQ3VydmVzKGN1cnZlcy5ib3R0b21SaWdodEJvcmRlckJveCwgY3VydmVzLmJvdHRvbVJpZ2h0Qm9yZGVyRG91YmxlT3V0ZXJCb3gsIGN1cnZlcy5ib3R0b21MZWZ0Qm9yZGVyQm94LCBjdXJ2ZXMuYm90dG9tTGVmdEJvcmRlckRvdWJsZU91dGVyQm94KTtcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVBhdGhGcm9tQ3VydmVzKGN1cnZlcy5ib3R0b21MZWZ0Qm9yZGVyQm94LCBjdXJ2ZXMuYm90dG9tTGVmdEJvcmRlckRvdWJsZU91dGVyQm94LCBjdXJ2ZXMudG9wTGVmdEJvcmRlckJveCwgY3VydmVzLnRvcExlZnRCb3JkZXJEb3VibGVPdXRlckJveCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBwYXJzZVBhdGhGb3JCb3JkZXJEb3VibGVJbm5lciA9IGZ1bmN0aW9uIChjdXJ2ZXMsIGJvcmRlclNpZGUpIHtcbiAgICAgICAgc3dpdGNoIChib3JkZXJTaWRlKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVBhdGhGcm9tQ3VydmVzKGN1cnZlcy50b3BMZWZ0Qm9yZGVyRG91YmxlSW5uZXJCb3gsIGN1cnZlcy50b3BMZWZ0UGFkZGluZ0JveCwgY3VydmVzLnRvcFJpZ2h0Qm9yZGVyRG91YmxlSW5uZXJCb3gsIGN1cnZlcy50b3BSaWdodFBhZGRpbmdCb3gpO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVQYXRoRnJvbUN1cnZlcyhjdXJ2ZXMudG9wUmlnaHRCb3JkZXJEb3VibGVJbm5lckJveCwgY3VydmVzLnRvcFJpZ2h0UGFkZGluZ0JveCwgY3VydmVzLmJvdHRvbVJpZ2h0Qm9yZGVyRG91YmxlSW5uZXJCb3gsIGN1cnZlcy5ib3R0b21SaWdodFBhZGRpbmdCb3gpO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVQYXRoRnJvbUN1cnZlcyhjdXJ2ZXMuYm90dG9tUmlnaHRCb3JkZXJEb3VibGVJbm5lckJveCwgY3VydmVzLmJvdHRvbVJpZ2h0UGFkZGluZ0JveCwgY3VydmVzLmJvdHRvbUxlZnRCb3JkZXJEb3VibGVJbm5lckJveCwgY3VydmVzLmJvdHRvbUxlZnRQYWRkaW5nQm94KTtcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVBhdGhGcm9tQ3VydmVzKGN1cnZlcy5ib3R0b21MZWZ0Qm9yZGVyRG91YmxlSW5uZXJCb3gsIGN1cnZlcy5ib3R0b21MZWZ0UGFkZGluZ0JveCwgY3VydmVzLnRvcExlZnRCb3JkZXJEb3VibGVJbm5lckJveCwgY3VydmVzLnRvcExlZnRQYWRkaW5nQm94KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIHBhcnNlUGF0aEZvckJvcmRlclN0cm9rZSA9IGZ1bmN0aW9uIChjdXJ2ZXMsIGJvcmRlclNpZGUpIHtcbiAgICAgICAgc3dpdGNoIChib3JkZXJTaWRlKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVN0cm9rZVBhdGhGcm9tQ3VydmVzKGN1cnZlcy50b3BMZWZ0Qm9yZGVyU3Ryb2tlLCBjdXJ2ZXMudG9wUmlnaHRCb3JkZXJTdHJva2UpO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVTdHJva2VQYXRoRnJvbUN1cnZlcyhjdXJ2ZXMudG9wUmlnaHRCb3JkZXJTdHJva2UsIGN1cnZlcy5ib3R0b21SaWdodEJvcmRlclN0cm9rZSk7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVN0cm9rZVBhdGhGcm9tQ3VydmVzKGN1cnZlcy5ib3R0b21SaWdodEJvcmRlclN0cm9rZSwgY3VydmVzLmJvdHRvbUxlZnRCb3JkZXJTdHJva2UpO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlU3Ryb2tlUGF0aEZyb21DdXJ2ZXMoY3VydmVzLmJvdHRvbUxlZnRCb3JkZXJTdHJva2UsIGN1cnZlcy50b3BMZWZ0Qm9yZGVyU3Ryb2tlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIGNyZWF0ZVN0cm9rZVBhdGhGcm9tQ3VydmVzID0gZnVuY3Rpb24gKG91dGVyMSwgb3V0ZXIyKSB7XG4gICAgICAgIHZhciBwYXRoID0gW107XG4gICAgICAgIGlmIChpc0JlemllckN1cnZlKG91dGVyMSkpIHtcbiAgICAgICAgICAgIHBhdGgucHVzaChvdXRlcjEuc3ViZGl2aWRlKDAuNSwgZmFsc2UpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhdGgucHVzaChvdXRlcjEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0JlemllckN1cnZlKG91dGVyMikpIHtcbiAgICAgICAgICAgIHBhdGgucHVzaChvdXRlcjIuc3ViZGl2aWRlKDAuNSwgdHJ1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGF0aC5wdXNoKG91dGVyMik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfTtcbiAgICB2YXIgY3JlYXRlUGF0aEZyb21DdXJ2ZXMgPSBmdW5jdGlvbiAob3V0ZXIxLCBpbm5lcjEsIG91dGVyMiwgaW5uZXIyKSB7XG4gICAgICAgIHZhciBwYXRoID0gW107XG4gICAgICAgIGlmIChpc0JlemllckN1cnZlKG91dGVyMSkpIHtcbiAgICAgICAgICAgIHBhdGgucHVzaChvdXRlcjEuc3ViZGl2aWRlKDAuNSwgZmFsc2UpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhdGgucHVzaChvdXRlcjEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0JlemllckN1cnZlKG91dGVyMikpIHtcbiAgICAgICAgICAgIHBhdGgucHVzaChvdXRlcjIuc3ViZGl2aWRlKDAuNSwgdHJ1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGF0aC5wdXNoKG91dGVyMik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQmV6aWVyQ3VydmUoaW5uZXIyKSkge1xuICAgICAgICAgICAgcGF0aC5wdXNoKGlubmVyMi5zdWJkaXZpZGUoMC41LCB0cnVlKS5yZXZlcnNlKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGF0aC5wdXNoKGlubmVyMik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQmV6aWVyQ3VydmUoaW5uZXIxKSkge1xuICAgICAgICAgICAgcGF0aC5wdXNoKGlubmVyMS5zdWJkaXZpZGUoMC41LCBmYWxzZSkucmV2ZXJzZSgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhdGgucHVzaChpbm5lcjEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgIH07XG5cbiAgICB2YXIgcGFkZGluZ0JveCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHZhciBib3VuZHMgPSBlbGVtZW50LmJvdW5kcztcbiAgICAgICAgdmFyIHN0eWxlcyA9IGVsZW1lbnQuc3R5bGVzO1xuICAgICAgICByZXR1cm4gYm91bmRzLmFkZChzdHlsZXMuYm9yZGVyTGVmdFdpZHRoLCBzdHlsZXMuYm9yZGVyVG9wV2lkdGgsIC0oc3R5bGVzLmJvcmRlclJpZ2h0V2lkdGggKyBzdHlsZXMuYm9yZGVyTGVmdFdpZHRoKSwgLShzdHlsZXMuYm9yZGVyVG9wV2lkdGggKyBzdHlsZXMuYm9yZGVyQm90dG9tV2lkdGgpKTtcbiAgICB9O1xuICAgIHZhciBjb250ZW50Qm94ID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIHN0eWxlcyA9IGVsZW1lbnQuc3R5bGVzO1xuICAgICAgICB2YXIgYm91bmRzID0gZWxlbWVudC5ib3VuZHM7XG4gICAgICAgIHZhciBwYWRkaW5nTGVmdCA9IGdldEFic29sdXRlVmFsdWUoc3R5bGVzLnBhZGRpbmdMZWZ0LCBib3VuZHMud2lkdGgpO1xuICAgICAgICB2YXIgcGFkZGluZ1JpZ2h0ID0gZ2V0QWJzb2x1dGVWYWx1ZShzdHlsZXMucGFkZGluZ1JpZ2h0LCBib3VuZHMud2lkdGgpO1xuICAgICAgICB2YXIgcGFkZGluZ1RvcCA9IGdldEFic29sdXRlVmFsdWUoc3R5bGVzLnBhZGRpbmdUb3AsIGJvdW5kcy53aWR0aCk7XG4gICAgICAgIHZhciBwYWRkaW5nQm90dG9tID0gZ2V0QWJzb2x1dGVWYWx1ZShzdHlsZXMucGFkZGluZ0JvdHRvbSwgYm91bmRzLndpZHRoKTtcbiAgICAgICAgcmV0dXJuIGJvdW5kcy5hZGQocGFkZGluZ0xlZnQgKyBzdHlsZXMuYm9yZGVyTGVmdFdpZHRoLCBwYWRkaW5nVG9wICsgc3R5bGVzLmJvcmRlclRvcFdpZHRoLCAtKHN0eWxlcy5ib3JkZXJSaWdodFdpZHRoICsgc3R5bGVzLmJvcmRlckxlZnRXaWR0aCArIHBhZGRpbmdMZWZ0ICsgcGFkZGluZ1JpZ2h0KSwgLShzdHlsZXMuYm9yZGVyVG9wV2lkdGggKyBzdHlsZXMuYm9yZGVyQm90dG9tV2lkdGggKyBwYWRkaW5nVG9wICsgcGFkZGluZ0JvdHRvbSkpO1xuICAgIH07XG5cbiAgICB2YXIgY2FsY3VsYXRlQmFja2dyb3VuZFBvc2l0aW9uaW5nQXJlYSA9IGZ1bmN0aW9uIChiYWNrZ3JvdW5kT3JpZ2luLCBlbGVtZW50KSB7XG4gICAgICAgIGlmIChiYWNrZ3JvdW5kT3JpZ2luID09PSAwIC8qIEJPUkRFUl9CT1ggKi8pIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50LmJvdW5kcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoYmFja2dyb3VuZE9yaWdpbiA9PT0gMiAvKiBDT05URU5UX0JPWCAqLykge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnRCb3goZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhZGRpbmdCb3goZWxlbWVudCk7XG4gICAgfTtcbiAgICB2YXIgY2FsY3VsYXRlQmFja2dyb3VuZFBhaW50aW5nQXJlYSA9IGZ1bmN0aW9uIChiYWNrZ3JvdW5kQ2xpcCwgZWxlbWVudCkge1xuICAgICAgICBpZiAoYmFja2dyb3VuZENsaXAgPT09IDAgLyogQk9SREVSX0JPWCAqLykge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQuYm91bmRzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiYWNrZ3JvdW5kQ2xpcCA9PT0gMiAvKiBDT05URU5UX0JPWCAqLykge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnRCb3goZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhZGRpbmdCb3goZWxlbWVudCk7XG4gICAgfTtcbiAgICB2YXIgY2FsY3VsYXRlQmFja2dyb3VuZFJlbmRlcmluZyA9IGZ1bmN0aW9uIChjb250YWluZXIsIGluZGV4LCBpbnRyaW5zaWNTaXplKSB7XG4gICAgICAgIHZhciBiYWNrZ3JvdW5kUG9zaXRpb25pbmdBcmVhID0gY2FsY3VsYXRlQmFja2dyb3VuZFBvc2l0aW9uaW5nQXJlYShnZXRCYWNrZ3JvdW5kVmFsdWVGb3JJbmRleChjb250YWluZXIuc3R5bGVzLmJhY2tncm91bmRPcmlnaW4sIGluZGV4KSwgY29udGFpbmVyKTtcbiAgICAgICAgdmFyIGJhY2tncm91bmRQYWludGluZ0FyZWEgPSBjYWxjdWxhdGVCYWNrZ3JvdW5kUGFpbnRpbmdBcmVhKGdldEJhY2tncm91bmRWYWx1ZUZvckluZGV4KGNvbnRhaW5lci5zdHlsZXMuYmFja2dyb3VuZENsaXAsIGluZGV4KSwgY29udGFpbmVyKTtcbiAgICAgICAgdmFyIGJhY2tncm91bmRJbWFnZVNpemUgPSBjYWxjdWxhdGVCYWNrZ3JvdW5kU2l6ZShnZXRCYWNrZ3JvdW5kVmFsdWVGb3JJbmRleChjb250YWluZXIuc3R5bGVzLmJhY2tncm91bmRTaXplLCBpbmRleCksIGludHJpbnNpY1NpemUsIGJhY2tncm91bmRQb3NpdGlvbmluZ0FyZWEpO1xuICAgICAgICB2YXIgc2l6ZVdpZHRoID0gYmFja2dyb3VuZEltYWdlU2l6ZVswXSwgc2l6ZUhlaWdodCA9IGJhY2tncm91bmRJbWFnZVNpemVbMV07XG4gICAgICAgIHZhciBwb3NpdGlvbiA9IGdldEFic29sdXRlVmFsdWVGb3JUdXBsZShnZXRCYWNrZ3JvdW5kVmFsdWVGb3JJbmRleChjb250YWluZXIuc3R5bGVzLmJhY2tncm91bmRQb3NpdGlvbiwgaW5kZXgpLCBiYWNrZ3JvdW5kUG9zaXRpb25pbmdBcmVhLndpZHRoIC0gc2l6ZVdpZHRoLCBiYWNrZ3JvdW5kUG9zaXRpb25pbmdBcmVhLmhlaWdodCAtIHNpemVIZWlnaHQpO1xuICAgICAgICB2YXIgcGF0aCA9IGNhbGN1bGF0ZUJhY2tncm91bmRSZXBlYXRQYXRoKGdldEJhY2tncm91bmRWYWx1ZUZvckluZGV4KGNvbnRhaW5lci5zdHlsZXMuYmFja2dyb3VuZFJlcGVhdCwgaW5kZXgpLCBwb3NpdGlvbiwgYmFja2dyb3VuZEltYWdlU2l6ZSwgYmFja2dyb3VuZFBvc2l0aW9uaW5nQXJlYSwgYmFja2dyb3VuZFBhaW50aW5nQXJlYSk7XG4gICAgICAgIHZhciBvZmZzZXRYID0gTWF0aC5yb3VuZChiYWNrZ3JvdW5kUG9zaXRpb25pbmdBcmVhLmxlZnQgKyBwb3NpdGlvblswXSk7XG4gICAgICAgIHZhciBvZmZzZXRZID0gTWF0aC5yb3VuZChiYWNrZ3JvdW5kUG9zaXRpb25pbmdBcmVhLnRvcCArIHBvc2l0aW9uWzFdKTtcbiAgICAgICAgcmV0dXJuIFtwYXRoLCBvZmZzZXRYLCBvZmZzZXRZLCBzaXplV2lkdGgsIHNpemVIZWlnaHRdO1xuICAgIH07XG4gICAgdmFyIGlzQXV0byA9IGZ1bmN0aW9uICh0b2tlbikgeyByZXR1cm4gaXNJZGVudFRva2VuKHRva2VuKSAmJiB0b2tlbi52YWx1ZSA9PT0gQkFDS0dST1VORF9TSVpFLkFVVE87IH07XG4gICAgdmFyIGhhc0ludHJpbnNpY1ZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInOyB9O1xuICAgIHZhciBjYWxjdWxhdGVCYWNrZ3JvdW5kU2l6ZSA9IGZ1bmN0aW9uIChzaXplLCBfYSwgYm91bmRzKSB7XG4gICAgICAgIHZhciBpbnRyaW5zaWNXaWR0aCA9IF9hWzBdLCBpbnRyaW5zaWNIZWlnaHQgPSBfYVsxXSwgaW50cmluc2ljUHJvcG9ydGlvbiA9IF9hWzJdO1xuICAgICAgICB2YXIgZmlyc3QgPSBzaXplWzBdLCBzZWNvbmQgPSBzaXplWzFdO1xuICAgICAgICBpZiAoIWZpcnN0KSB7XG4gICAgICAgICAgICByZXR1cm4gWzAsIDBdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0xlbmd0aFBlcmNlbnRhZ2UoZmlyc3QpICYmIHNlY29uZCAmJiBpc0xlbmd0aFBlcmNlbnRhZ2Uoc2Vjb25kKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtnZXRBYnNvbHV0ZVZhbHVlKGZpcnN0LCBib3VuZHMud2lkdGgpLCBnZXRBYnNvbHV0ZVZhbHVlKHNlY29uZCwgYm91bmRzLmhlaWdodCldO1xuICAgICAgICB9XG4gICAgICAgIHZhciBoYXNJbnRyaW5zaWNQcm9wb3J0aW9uID0gaGFzSW50cmluc2ljVmFsdWUoaW50cmluc2ljUHJvcG9ydGlvbik7XG4gICAgICAgIGlmIChpc0lkZW50VG9rZW4oZmlyc3QpICYmIChmaXJzdC52YWx1ZSA9PT0gQkFDS0dST1VORF9TSVpFLkNPTlRBSU4gfHwgZmlyc3QudmFsdWUgPT09IEJBQ0tHUk9VTkRfU0laRS5DT1ZFUikpIHtcbiAgICAgICAgICAgIGlmIChoYXNJbnRyaW5zaWNWYWx1ZShpbnRyaW5zaWNQcm9wb3J0aW9uKSkge1xuICAgICAgICAgICAgICAgIHZhciB0YXJnZXRSYXRpbyA9IGJvdW5kcy53aWR0aCAvIGJvdW5kcy5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldFJhdGlvIDwgaW50cmluc2ljUHJvcG9ydGlvbiAhPT0gKGZpcnN0LnZhbHVlID09PSBCQUNLR1JPVU5EX1NJWkUuQ09WRVIpXG4gICAgICAgICAgICAgICAgICAgID8gW2JvdW5kcy53aWR0aCwgYm91bmRzLndpZHRoIC8gaW50cmluc2ljUHJvcG9ydGlvbl1cbiAgICAgICAgICAgICAgICAgICAgOiBbYm91bmRzLmhlaWdodCAqIGludHJpbnNpY1Byb3BvcnRpb24sIGJvdW5kcy5oZWlnaHRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtib3VuZHMud2lkdGgsIGJvdW5kcy5oZWlnaHRdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBoYXNJbnRyaW5zaWNXaWR0aCA9IGhhc0ludHJpbnNpY1ZhbHVlKGludHJpbnNpY1dpZHRoKTtcbiAgICAgICAgdmFyIGhhc0ludHJpbnNpY0hlaWdodCA9IGhhc0ludHJpbnNpY1ZhbHVlKGludHJpbnNpY0hlaWdodCk7XG4gICAgICAgIHZhciBoYXNJbnRyaW5zaWNEaW1lbnNpb25zID0gaGFzSW50cmluc2ljV2lkdGggfHwgaGFzSW50cmluc2ljSGVpZ2h0O1xuICAgICAgICAvLyBJZiB0aGUgYmFja2dyb3VuZC1zaXplIGlzIGF1dG8gb3IgYXV0byBhdXRvOlxuICAgICAgICBpZiAoaXNBdXRvKGZpcnN0KSAmJiAoIXNlY29uZCB8fCBpc0F1dG8oc2Vjb25kKSkpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBpbWFnZSBoYXMgYm90aCBob3Jpem9udGFsIGFuZCB2ZXJ0aWNhbCBpbnRyaW5zaWMgZGltZW5zaW9ucywgaXQncyByZW5kZXJlZCBhdCB0aGF0IHNpemUuXG4gICAgICAgICAgICBpZiAoaGFzSW50cmluc2ljV2lkdGggJiYgaGFzSW50cmluc2ljSGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtpbnRyaW5zaWNXaWR0aCwgaW50cmluc2ljSGVpZ2h0XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHRoZSBpbWFnZSBoYXMgbm8gaW50cmluc2ljIGRpbWVuc2lvbnMgYW5kIGhhcyBubyBpbnRyaW5zaWMgcHJvcG9ydGlvbnMsXG4gICAgICAgICAgICAvLyBpdCdzIHJlbmRlcmVkIGF0IHRoZSBzaXplIG9mIHRoZSBiYWNrZ3JvdW5kIHBvc2l0aW9uaW5nIGFyZWEuXG4gICAgICAgICAgICBpZiAoIWhhc0ludHJpbnNpY1Byb3BvcnRpb24gJiYgIWhhc0ludHJpbnNpY0RpbWVuc2lvbnMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW2JvdW5kcy53aWR0aCwgYm91bmRzLmhlaWdodF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUT0RPIElmIHRoZSBpbWFnZSBoYXMgbm8gaW50cmluc2ljIGRpbWVuc2lvbnMgYnV0IGhhcyBpbnRyaW5zaWMgcHJvcG9ydGlvbnMsIGl0J3MgcmVuZGVyZWQgYXMgaWYgY29udGFpbiBoYWQgYmVlbiBzcGVjaWZpZWQgaW5zdGVhZC5cbiAgICAgICAgICAgIC8vIElmIHRoZSBpbWFnZSBoYXMgb25seSBvbmUgaW50cmluc2ljIGRpbWVuc2lvbiBhbmQgaGFzIGludHJpbnNpYyBwcm9wb3J0aW9ucywgaXQncyByZW5kZXJlZCBhdCB0aGUgc2l6ZSBjb3JyZXNwb25kaW5nIHRvIHRoYXQgb25lIGRpbWVuc2lvbi5cbiAgICAgICAgICAgIC8vIFRoZSBvdGhlciBkaW1lbnNpb24gaXMgY29tcHV0ZWQgdXNpbmcgdGhlIHNwZWNpZmllZCBkaW1lbnNpb24gYW5kIHRoZSBpbnRyaW5zaWMgcHJvcG9ydGlvbnMuXG4gICAgICAgICAgICBpZiAoaGFzSW50cmluc2ljRGltZW5zaW9ucyAmJiBoYXNJbnRyaW5zaWNQcm9wb3J0aW9uKSB7XG4gICAgICAgICAgICAgICAgdmFyIHdpZHRoXzEgPSBoYXNJbnRyaW5zaWNXaWR0aFxuICAgICAgICAgICAgICAgICAgICA/IGludHJpbnNpY1dpZHRoXG4gICAgICAgICAgICAgICAgICAgIDogaW50cmluc2ljSGVpZ2h0ICogaW50cmluc2ljUHJvcG9ydGlvbjtcbiAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0XzEgPSBoYXNJbnRyaW5zaWNIZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgPyBpbnRyaW5zaWNIZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgOiBpbnRyaW5zaWNXaWR0aCAvIGludHJpbnNpY1Byb3BvcnRpb247XG4gICAgICAgICAgICAgICAgcmV0dXJuIFt3aWR0aF8xLCBoZWlnaHRfMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB0aGUgaW1hZ2UgaGFzIG9ubHkgb25lIGludHJpbnNpYyBkaW1lbnNpb24gYnV0IGhhcyBubyBpbnRyaW5zaWMgcHJvcG9ydGlvbnMsXG4gICAgICAgICAgICAvLyBpdCdzIHJlbmRlcmVkIHVzaW5nIHRoZSBzcGVjaWZpZWQgZGltZW5zaW9uIGFuZCB0aGUgb3RoZXIgZGltZW5zaW9uIG9mIHRoZSBiYWNrZ3JvdW5kIHBvc2l0aW9uaW5nIGFyZWEuXG4gICAgICAgICAgICB2YXIgd2lkdGhfMiA9IGhhc0ludHJpbnNpY1dpZHRoID8gaW50cmluc2ljV2lkdGggOiBib3VuZHMud2lkdGg7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0XzIgPSBoYXNJbnRyaW5zaWNIZWlnaHQgPyBpbnRyaW5zaWNIZWlnaHQgOiBib3VuZHMuaGVpZ2h0O1xuICAgICAgICAgICAgcmV0dXJuIFt3aWR0aF8yLCBoZWlnaHRfMl07XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIGltYWdlIGhhcyBpbnRyaW5zaWMgcHJvcG9ydGlvbnMsIGl0J3Mgc3RyZXRjaGVkIHRvIHRoZSBzcGVjaWZpZWQgZGltZW5zaW9uLlxuICAgICAgICAvLyBUaGUgdW5zcGVjaWZpZWQgZGltZW5zaW9uIGlzIGNvbXB1dGVkIHVzaW5nIHRoZSBzcGVjaWZpZWQgZGltZW5zaW9uIGFuZCB0aGUgaW50cmluc2ljIHByb3BvcnRpb25zLlxuICAgICAgICBpZiAoaGFzSW50cmluc2ljUHJvcG9ydGlvbikge1xuICAgICAgICAgICAgdmFyIHdpZHRoXzMgPSAwO1xuICAgICAgICAgICAgdmFyIGhlaWdodF8zID0gMDtcbiAgICAgICAgICAgIGlmIChpc0xlbmd0aFBlcmNlbnRhZ2UoZmlyc3QpKSB7XG4gICAgICAgICAgICAgICAgd2lkdGhfMyA9IGdldEFic29sdXRlVmFsdWUoZmlyc3QsIGJvdW5kcy53aWR0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0xlbmd0aFBlcmNlbnRhZ2Uoc2Vjb25kKSkge1xuICAgICAgICAgICAgICAgIGhlaWdodF8zID0gZ2V0QWJzb2x1dGVWYWx1ZShzZWNvbmQsIGJvdW5kcy5oZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzQXV0byhmaXJzdCkpIHtcbiAgICAgICAgICAgICAgICB3aWR0aF8zID0gaGVpZ2h0XzMgKiBpbnRyaW5zaWNQcm9wb3J0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIXNlY29uZCB8fCBpc0F1dG8oc2Vjb25kKSkge1xuICAgICAgICAgICAgICAgIGhlaWdodF8zID0gd2lkdGhfMyAvIGludHJpbnNpY1Byb3BvcnRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW3dpZHRoXzMsIGhlaWdodF8zXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgaW1hZ2UgaGFzIG5vIGludHJpbnNpYyBwcm9wb3J0aW9ucywgaXQncyBzdHJldGNoZWQgdG8gdGhlIHNwZWNpZmllZCBkaW1lbnNpb24uXG4gICAgICAgIC8vIFRoZSB1bnNwZWNpZmllZCBkaW1lbnNpb24gaXMgY29tcHV0ZWQgdXNpbmcgdGhlIGltYWdlJ3MgY29ycmVzcG9uZGluZyBpbnRyaW5zaWMgZGltZW5zaW9uLFxuICAgICAgICAvLyBpZiB0aGVyZSBpcyBvbmUuIElmIHRoZXJlIGlzIG5vIHN1Y2ggaW50cmluc2ljIGRpbWVuc2lvbixcbiAgICAgICAgLy8gaXQgYmVjb21lcyB0aGUgY29ycmVzcG9uZGluZyBkaW1lbnNpb24gb2YgdGhlIGJhY2tncm91bmQgcG9zaXRpb25pbmcgYXJlYS5cbiAgICAgICAgdmFyIHdpZHRoID0gbnVsbDtcbiAgICAgICAgdmFyIGhlaWdodCA9IG51bGw7XG4gICAgICAgIGlmIChpc0xlbmd0aFBlcmNlbnRhZ2UoZmlyc3QpKSB7XG4gICAgICAgICAgICB3aWR0aCA9IGdldEFic29sdXRlVmFsdWUoZmlyc3QsIGJvdW5kcy53aWR0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2Vjb25kICYmIGlzTGVuZ3RoUGVyY2VudGFnZShzZWNvbmQpKSB7XG4gICAgICAgICAgICBoZWlnaHQgPSBnZXRBYnNvbHV0ZVZhbHVlKHNlY29uZCwgYm91bmRzLmhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdpZHRoICE9PSBudWxsICYmICghc2Vjb25kIHx8IGlzQXV0byhzZWNvbmQpKSkge1xuICAgICAgICAgICAgaGVpZ2h0ID1cbiAgICAgICAgICAgICAgICBoYXNJbnRyaW5zaWNXaWR0aCAmJiBoYXNJbnRyaW5zaWNIZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgPyAod2lkdGggLyBpbnRyaW5zaWNXaWR0aCkgKiBpbnRyaW5zaWNIZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgOiBib3VuZHMuaGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZWlnaHQgIT09IG51bGwgJiYgaXNBdXRvKGZpcnN0KSkge1xuICAgICAgICAgICAgd2lkdGggPVxuICAgICAgICAgICAgICAgIGhhc0ludHJpbnNpY1dpZHRoICYmIGhhc0ludHJpbnNpY0hlaWdodFxuICAgICAgICAgICAgICAgICAgICA/IChoZWlnaHQgLyBpbnRyaW5zaWNIZWlnaHQpICogaW50cmluc2ljV2lkdGhcbiAgICAgICAgICAgICAgICAgICAgOiBib3VuZHMud2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdpZHRoICE9PSBudWxsICYmIGhlaWdodCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFt3aWR0aCwgaGVpZ2h0XTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gY2FsY3VsYXRlIGJhY2tncm91bmQtc2l6ZSBmb3IgZWxlbWVudFwiKTtcbiAgICB9O1xuICAgIHZhciBnZXRCYWNrZ3JvdW5kVmFsdWVGb3JJbmRleCA9IGZ1bmN0aW9uICh2YWx1ZXMsIGluZGV4KSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHZhbHVlc1tpbmRleF07XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVzWzBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIHZhciBjYWxjdWxhdGVCYWNrZ3JvdW5kUmVwZWF0UGF0aCA9IGZ1bmN0aW9uIChyZXBlYXQsIF9hLCBfYiwgYmFja2dyb3VuZFBvc2l0aW9uaW5nQXJlYSwgYmFja2dyb3VuZFBhaW50aW5nQXJlYSkge1xuICAgICAgICB2YXIgeCA9IF9hWzBdLCB5ID0gX2FbMV07XG4gICAgICAgIHZhciB3aWR0aCA9IF9iWzBdLCBoZWlnaHQgPSBfYlsxXTtcbiAgICAgICAgc3dpdGNoIChyZXBlYXQpIHtcbiAgICAgICAgICAgIGNhc2UgMiAvKiBSRVBFQVRfWCAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICBuZXcgVmVjdG9yKE1hdGgucm91bmQoYmFja2dyb3VuZFBvc2l0aW9uaW5nQXJlYS5sZWZ0KSwgTWF0aC5yb3VuZChiYWNrZ3JvdW5kUG9zaXRpb25pbmdBcmVhLnRvcCArIHkpKSxcbiAgICAgICAgICAgICAgICAgICAgbmV3IFZlY3RvcihNYXRoLnJvdW5kKGJhY2tncm91bmRQb3NpdGlvbmluZ0FyZWEubGVmdCArIGJhY2tncm91bmRQb3NpdGlvbmluZ0FyZWEud2lkdGgpLCBNYXRoLnJvdW5kKGJhY2tncm91bmRQb3NpdGlvbmluZ0FyZWEudG9wICsgeSkpLFxuICAgICAgICAgICAgICAgICAgICBuZXcgVmVjdG9yKE1hdGgucm91bmQoYmFja2dyb3VuZFBvc2l0aW9uaW5nQXJlYS5sZWZ0ICsgYmFja2dyb3VuZFBvc2l0aW9uaW5nQXJlYS53aWR0aCksIE1hdGgucm91bmQoaGVpZ2h0ICsgYmFja2dyb3VuZFBvc2l0aW9uaW5nQXJlYS50b3AgKyB5KSksXG4gICAgICAgICAgICAgICAgICAgIG5ldyBWZWN0b3IoTWF0aC5yb3VuZChiYWNrZ3JvdW5kUG9zaXRpb25pbmdBcmVhLmxlZnQpLCBNYXRoLnJvdW5kKGhlaWdodCArIGJhY2tncm91bmRQb3NpdGlvbmluZ0FyZWEudG9wICsgeSkpXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGNhc2UgMyAvKiBSRVBFQVRfWSAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICBuZXcgVmVjdG9yKE1hdGgucm91bmQoYmFja2dyb3VuZFBvc2l0aW9uaW5nQXJlYS5sZWZ0ICsgeCksIE1hdGgucm91bmQoYmFja2dyb3VuZFBvc2l0aW9uaW5nQXJlYS50b3ApKSxcbiAgICAgICAgICAgICAgICAgICAgbmV3IFZlY3RvcihNYXRoLnJvdW5kKGJhY2tncm91bmRQb3NpdGlvbmluZ0FyZWEubGVmdCArIHggKyB3aWR0aCksIE1hdGgucm91bmQoYmFja2dyb3VuZFBvc2l0aW9uaW5nQXJlYS50b3ApKSxcbiAgICAgICAgICAgICAgICAgICAgbmV3IFZlY3RvcihNYXRoLnJvdW5kKGJhY2tncm91bmRQb3NpdGlvbmluZ0FyZWEubGVmdCArIHggKyB3aWR0aCksIE1hdGgucm91bmQoYmFja2dyb3VuZFBvc2l0aW9uaW5nQXJlYS5oZWlnaHQgKyBiYWNrZ3JvdW5kUG9zaXRpb25pbmdBcmVhLnRvcCkpLFxuICAgICAgICAgICAgICAgICAgICBuZXcgVmVjdG9yKE1hdGgucm91bmQoYmFja2dyb3VuZFBvc2l0aW9uaW5nQXJlYS5sZWZ0ICsgeCksIE1hdGgucm91bmQoYmFja2dyb3VuZFBvc2l0aW9uaW5nQXJlYS5oZWlnaHQgKyBiYWNrZ3JvdW5kUG9zaXRpb25pbmdBcmVhLnRvcCkpXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGNhc2UgMSAvKiBOT19SRVBFQVQgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgbmV3IFZlY3RvcihNYXRoLnJvdW5kKGJhY2tncm91bmRQb3NpdGlvbmluZ0FyZWEubGVmdCArIHgpLCBNYXRoLnJvdW5kKGJhY2tncm91bmRQb3NpdGlvbmluZ0FyZWEudG9wICsgeSkpLFxuICAgICAgICAgICAgICAgICAgICBuZXcgVmVjdG9yKE1hdGgucm91bmQoYmFja2dyb3VuZFBvc2l0aW9uaW5nQXJlYS5sZWZ0ICsgeCArIHdpZHRoKSwgTWF0aC5yb3VuZChiYWNrZ3JvdW5kUG9zaXRpb25pbmdBcmVhLnRvcCArIHkpKSxcbiAgICAgICAgICAgICAgICAgICAgbmV3IFZlY3RvcihNYXRoLnJvdW5kKGJhY2tncm91bmRQb3NpdGlvbmluZ0FyZWEubGVmdCArIHggKyB3aWR0aCksIE1hdGgucm91bmQoYmFja2dyb3VuZFBvc2l0aW9uaW5nQXJlYS50b3AgKyB5ICsgaGVpZ2h0KSksXG4gICAgICAgICAgICAgICAgICAgIG5ldyBWZWN0b3IoTWF0aC5yb3VuZChiYWNrZ3JvdW5kUG9zaXRpb25pbmdBcmVhLmxlZnQgKyB4KSwgTWF0aC5yb3VuZChiYWNrZ3JvdW5kUG9zaXRpb25pbmdBcmVhLnRvcCArIHkgKyBoZWlnaHQpKVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIG5ldyBWZWN0b3IoTWF0aC5yb3VuZChiYWNrZ3JvdW5kUGFpbnRpbmdBcmVhLmxlZnQpLCBNYXRoLnJvdW5kKGJhY2tncm91bmRQYWludGluZ0FyZWEudG9wKSksXG4gICAgICAgICAgICAgICAgICAgIG5ldyBWZWN0b3IoTWF0aC5yb3VuZChiYWNrZ3JvdW5kUGFpbnRpbmdBcmVhLmxlZnQgKyBiYWNrZ3JvdW5kUGFpbnRpbmdBcmVhLndpZHRoKSwgTWF0aC5yb3VuZChiYWNrZ3JvdW5kUGFpbnRpbmdBcmVhLnRvcCkpLFxuICAgICAgICAgICAgICAgICAgICBuZXcgVmVjdG9yKE1hdGgucm91bmQoYmFja2dyb3VuZFBhaW50aW5nQXJlYS5sZWZ0ICsgYmFja2dyb3VuZFBhaW50aW5nQXJlYS53aWR0aCksIE1hdGgucm91bmQoYmFja2dyb3VuZFBhaW50aW5nQXJlYS5oZWlnaHQgKyBiYWNrZ3JvdW5kUGFpbnRpbmdBcmVhLnRvcCkpLFxuICAgICAgICAgICAgICAgICAgICBuZXcgVmVjdG9yKE1hdGgucm91bmQoYmFja2dyb3VuZFBhaW50aW5nQXJlYS5sZWZ0KSwgTWF0aC5yb3VuZChiYWNrZ3JvdW5kUGFpbnRpbmdBcmVhLmhlaWdodCArIGJhY2tncm91bmRQYWludGluZ0FyZWEudG9wKSlcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBTTUFMTF9JTUFHRSA9ICdkYXRhOmltYWdlL2dpZjtiYXNlNjQsUjBsR09EbGhBUUFCQUlBQUFBQUFBUC8vL3lINUJBRUFBQUFBTEFBQUFBQUJBQUVBQUFJQlJBQTcnO1xuXG4gICAgdmFyIFNBTVBMRV9URVhUID0gJ0hpZGRlbiBUZXh0JztcbiAgICB2YXIgRm9udE1ldHJpY3MgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEZvbnRNZXRyaWNzKGRvY3VtZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9kYXRhID0ge307XG4gICAgICAgICAgICB0aGlzLl9kb2N1bWVudCA9IGRvY3VtZW50O1xuICAgICAgICB9XG4gICAgICAgIEZvbnRNZXRyaWNzLnByb3RvdHlwZS5wYXJzZU1ldHJpY3MgPSBmdW5jdGlvbiAoZm9udEZhbWlseSwgZm9udFNpemUpIHtcbiAgICAgICAgICAgIHZhciBjb250YWluZXIgPSB0aGlzLl9kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIHZhciBpbWcgPSB0aGlzLl9kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgICAgICAgICAgIHZhciBzcGFuID0gdGhpcy5fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICAgICAgdmFyIGJvZHkgPSB0aGlzLl9kb2N1bWVudC5ib2R5O1xuICAgICAgICAgICAgY29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAgICAgICAgIGNvbnRhaW5lci5zdHlsZS5mb250RmFtaWx5ID0gZm9udEZhbWlseTtcbiAgICAgICAgICAgIGNvbnRhaW5lci5zdHlsZS5mb250U2l6ZSA9IGZvbnRTaXplO1xuICAgICAgICAgICAgY29udGFpbmVyLnN0eWxlLm1hcmdpbiA9ICcwJztcbiAgICAgICAgICAgIGNvbnRhaW5lci5zdHlsZS5wYWRkaW5nID0gJzAnO1xuICAgICAgICAgICAgY29udGFpbmVyLnN0eWxlLndoaXRlU3BhY2UgPSAnbm93cmFwJztcbiAgICAgICAgICAgIGJvZHkuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcbiAgICAgICAgICAgIGltZy5zcmMgPSBTTUFMTF9JTUFHRTtcbiAgICAgICAgICAgIGltZy53aWR0aCA9IDE7XG4gICAgICAgICAgICBpbWcuaGVpZ2h0ID0gMTtcbiAgICAgICAgICAgIGltZy5zdHlsZS5tYXJnaW4gPSAnMCc7XG4gICAgICAgICAgICBpbWcuc3R5bGUucGFkZGluZyA9ICcwJztcbiAgICAgICAgICAgIGltZy5zdHlsZS52ZXJ0aWNhbEFsaWduID0gJ2Jhc2VsaW5lJztcbiAgICAgICAgICAgIHNwYW4uc3R5bGUuZm9udEZhbWlseSA9IGZvbnRGYW1pbHk7XG4gICAgICAgICAgICBzcGFuLnN0eWxlLmZvbnRTaXplID0gZm9udFNpemU7XG4gICAgICAgICAgICBzcGFuLnN0eWxlLm1hcmdpbiA9ICcwJztcbiAgICAgICAgICAgIHNwYW4uc3R5bGUucGFkZGluZyA9ICcwJztcbiAgICAgICAgICAgIHNwYW4uYXBwZW5kQ2hpbGQodGhpcy5fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoU0FNUExFX1RFWFQpKTtcbiAgICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChzcGFuKTtcbiAgICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChpbWcpO1xuICAgICAgICAgICAgdmFyIGJhc2VsaW5lID0gaW1nLm9mZnNldFRvcCAtIHNwYW4ub2Zmc2V0VG9wICsgMjtcbiAgICAgICAgICAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZChzcGFuKTtcbiAgICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLl9kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShTQU1QTEVfVEVYVCkpO1xuICAgICAgICAgICAgY29udGFpbmVyLnN0eWxlLmxpbmVIZWlnaHQgPSAnbm9ybWFsJztcbiAgICAgICAgICAgIGltZy5zdHlsZS52ZXJ0aWNhbEFsaWduID0gJ3N1cGVyJztcbiAgICAgICAgICAgIHZhciBtaWRkbGUgPSBpbWcub2Zmc2V0VG9wIC0gY29udGFpbmVyLm9mZnNldFRvcCArIDI7XG4gICAgICAgICAgICBib2R5LnJlbW92ZUNoaWxkKGNvbnRhaW5lcik7XG4gICAgICAgICAgICByZXR1cm4geyBiYXNlbGluZTogYmFzZWxpbmUsIG1pZGRsZTogbWlkZGxlIH07XG4gICAgICAgIH07XG4gICAgICAgIEZvbnRNZXRyaWNzLnByb3RvdHlwZS5nZXRNZXRyaWNzID0gZnVuY3Rpb24gKGZvbnRGYW1pbHksIGZvbnRTaXplKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gZm9udEZhbWlseSArIFwiIFwiICsgZm9udFNpemU7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuX2RhdGFba2V5XSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kYXRhW2tleV0gPSB0aGlzLnBhcnNlTWV0cmljcyhmb250RmFtaWx5LCBmb250U2l6ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YVtrZXldO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gRm9udE1ldHJpY3M7XG4gICAgfSgpKTtcblxuICAgIHZhciBSZW5kZXJlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gUmVuZGVyZXIoY29udGV4dCwgb3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFJlbmRlcmVyO1xuICAgIH0oKSk7XG5cbiAgICB2YXIgTUFTS19PRkZTRVQgPSAxMDAwMDtcbiAgICB2YXIgQ2FudmFzUmVuZGVyZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhDYW52YXNSZW5kZXJlciwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gQ2FudmFzUmVuZGVyZXIoY29udGV4dCwgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29udGV4dCwgb3B0aW9ucykgfHwgdGhpcztcbiAgICAgICAgICAgIF90aGlzLl9hY3RpdmVFZmZlY3RzID0gW107XG4gICAgICAgICAgICBfdGhpcy5jYW52YXMgPSBvcHRpb25zLmNhbnZhcyA/IG9wdGlvbnMuY2FudmFzIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICBfdGhpcy5jdHggPSBfdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5jYW52YXMpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5jYW52YXMud2lkdGggPSBNYXRoLmZsb29yKG9wdGlvbnMud2lkdGggKiBvcHRpb25zLnNjYWxlKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5jYW52YXMuaGVpZ2h0ID0gTWF0aC5mbG9vcihvcHRpb25zLmhlaWdodCAqIG9wdGlvbnMuc2NhbGUpO1xuICAgICAgICAgICAgICAgIF90aGlzLmNhbnZhcy5zdHlsZS53aWR0aCA9IG9wdGlvbnMud2lkdGggKyBcInB4XCI7XG4gICAgICAgICAgICAgICAgX3RoaXMuY2FudmFzLnN0eWxlLmhlaWdodCA9IG9wdGlvbnMuaGVpZ2h0ICsgXCJweFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuZm9udE1ldHJpY3MgPSBuZXcgRm9udE1ldHJpY3MoZG9jdW1lbnQpO1xuICAgICAgICAgICAgX3RoaXMuY3R4LnNjYWxlKF90aGlzLm9wdGlvbnMuc2NhbGUsIF90aGlzLm9wdGlvbnMuc2NhbGUpO1xuICAgICAgICAgICAgX3RoaXMuY3R4LnRyYW5zbGF0ZSgtb3B0aW9ucy54LCAtb3B0aW9ucy55KTtcbiAgICAgICAgICAgIF90aGlzLmN0eC50ZXh0QmFzZWxpbmUgPSAnYm90dG9tJztcbiAgICAgICAgICAgIF90aGlzLl9hY3RpdmVFZmZlY3RzID0gW107XG4gICAgICAgICAgICBfdGhpcy5jb250ZXh0LmxvZ2dlci5kZWJ1ZyhcIkNhbnZhcyByZW5kZXJlciBpbml0aWFsaXplZCAoXCIgKyBvcHRpb25zLndpZHRoICsgXCJ4XCIgKyBvcHRpb25zLmhlaWdodCArIFwiKSB3aXRoIHNjYWxlIFwiICsgb3B0aW9ucy5zY2FsZSk7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLmFwcGx5RWZmZWN0cyA9IGZ1bmN0aW9uIChlZmZlY3RzKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMuX2FjdGl2ZUVmZmVjdHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3BFZmZlY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVmZmVjdHMuZm9yRWFjaChmdW5jdGlvbiAoZWZmZWN0KSB7IHJldHVybiBfdGhpcy5hcHBseUVmZmVjdChlZmZlY3QpOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLmFwcGx5RWZmZWN0ID0gZnVuY3Rpb24gKGVmZmVjdCkge1xuICAgICAgICAgICAgdGhpcy5jdHguc2F2ZSgpO1xuICAgICAgICAgICAgaWYgKGlzT3BhY2l0eUVmZmVjdChlZmZlY3QpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdHguZ2xvYmFsQWxwaGEgPSBlZmZlY3Qub3BhY2l0eTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1RyYW5zZm9ybUVmZmVjdChlZmZlY3QpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdHgudHJhbnNsYXRlKGVmZmVjdC5vZmZzZXRYLCBlZmZlY3Qub2Zmc2V0WSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jdHgudHJhbnNmb3JtKGVmZmVjdC5tYXRyaXhbMF0sIGVmZmVjdC5tYXRyaXhbMV0sIGVmZmVjdC5tYXRyaXhbMl0sIGVmZmVjdC5tYXRyaXhbM10sIGVmZmVjdC5tYXRyaXhbNF0sIGVmZmVjdC5tYXRyaXhbNV0pO1xuICAgICAgICAgICAgICAgIHRoaXMuY3R4LnRyYW5zbGF0ZSgtZWZmZWN0Lm9mZnNldFgsIC1lZmZlY3Qub2Zmc2V0WSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNDbGlwRWZmZWN0KGVmZmVjdCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhdGgoZWZmZWN0LnBhdGgpO1xuICAgICAgICAgICAgICAgIHRoaXMuY3R4LmNsaXAoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2FjdGl2ZUVmZmVjdHMucHVzaChlZmZlY3QpO1xuICAgICAgICB9O1xuICAgICAgICBDYW52YXNSZW5kZXJlci5wcm90b3R5cGUucG9wRWZmZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fYWN0aXZlRWZmZWN0cy5wb3AoKTtcbiAgICAgICAgICAgIHRoaXMuY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlclN0YWNrID0gZnVuY3Rpb24gKHN0YWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0eWxlcztcbiAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZXMgPSBzdGFjay5lbGVtZW50LmNvbnRhaW5lci5zdHlsZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzdHlsZXMuaXNWaXNpYmxlKCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucmVuZGVyU3RhY2tDb250ZW50KHN0YWNrKV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlck5vZGUgPSBmdW5jdGlvbiAocGFpbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGFpbnMocGFpbnQuY29udGFpbmVyLmZsYWdzLCAxNiAvKiBERUJVR19SRU5ERVIgKi8pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnZ2VyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBhaW50LmNvbnRhaW5lci5zdHlsZXMuaXNWaXNpYmxlKCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucmVuZGVyTm9kZUJhY2tncm91bmRBbmRCb3JkZXJzKHBhaW50KV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucmVuZGVyTm9kZUNvbnRlbnQocGFpbnQpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBDYW52YXNSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyVGV4dFdpdGhMZXR0ZXJTcGFjaW5nID0gZnVuY3Rpb24gKHRleHQsIGxldHRlclNwYWNpbmcsIGJhc2VsaW5lKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKGxldHRlclNwYWNpbmcgPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN0eC5maWxsVGV4dCh0ZXh0LnRleHQsIHRleHQuYm91bmRzLmxlZnQsIHRleHQuYm91bmRzLnRvcCArIGJhc2VsaW5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBsZXR0ZXJzID0gc2VnbWVudEdyYXBoZW1lcyh0ZXh0LnRleHQpO1xuICAgICAgICAgICAgICAgIGxldHRlcnMucmVkdWNlKGZ1bmN0aW9uIChsZWZ0LCBsZXR0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY3R4LmZpbGxUZXh0KGxldHRlciwgbGVmdCwgdGV4dC5ib3VuZHMudG9wICsgYmFzZWxpbmUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGVmdCArIF90aGlzLmN0eC5tZWFzdXJlVGV4dChsZXR0ZXIpLndpZHRoO1xuICAgICAgICAgICAgICAgIH0sIHRleHQuYm91bmRzLmxlZnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBDYW52YXNSZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlRm9udFN0eWxlID0gZnVuY3Rpb24gKHN0eWxlcykge1xuICAgICAgICAgICAgdmFyIGZvbnRWYXJpYW50ID0gc3R5bGVzLmZvbnRWYXJpYW50XG4gICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAodmFyaWFudCkgeyByZXR1cm4gdmFyaWFudCA9PT0gJ25vcm1hbCcgfHwgdmFyaWFudCA9PT0gJ3NtYWxsLWNhcHMnOyB9KVxuICAgICAgICAgICAgICAgIC5qb2luKCcnKTtcbiAgICAgICAgICAgIHZhciBmb250RmFtaWx5ID0gZml4SU9TU3lzdGVtRm9udHMoc3R5bGVzLmZvbnRGYW1pbHkpLmpvaW4oJywgJyk7XG4gICAgICAgICAgICB2YXIgZm9udFNpemUgPSBpc0RpbWVuc2lvblRva2VuKHN0eWxlcy5mb250U2l6ZSlcbiAgICAgICAgICAgICAgICA/IFwiXCIgKyBzdHlsZXMuZm9udFNpemUubnVtYmVyICsgc3R5bGVzLmZvbnRTaXplLnVuaXRcbiAgICAgICAgICAgICAgICA6IHN0eWxlcy5mb250U2l6ZS5udW1iZXIgKyBcInB4XCI7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIFtzdHlsZXMuZm9udFN0eWxlLCBmb250VmFyaWFudCwgc3R5bGVzLmZvbnRXZWlnaHQsIGZvbnRTaXplLCBmb250RmFtaWx5XS5qb2luKCcgJyksXG4gICAgICAgICAgICAgICAgZm9udEZhbWlseSxcbiAgICAgICAgICAgICAgICBmb250U2l6ZVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfTtcbiAgICAgICAgQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlclRleHROb2RlID0gZnVuY3Rpb24gKHRleHQsIHN0eWxlcykge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgZm9udCwgZm9udEZhbWlseSwgZm9udFNpemUsIF9iLCBiYXNlbGluZSwgbWlkZGxlLCBwYWludE9yZGVyO1xuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYykge1xuICAgICAgICAgICAgICAgICAgICBfYSA9IHRoaXMuY3JlYXRlRm9udFN0eWxlKHN0eWxlcyksIGZvbnQgPSBfYVswXSwgZm9udEZhbWlseSA9IF9hWzFdLCBmb250U2l6ZSA9IF9hWzJdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN0eC5mb250ID0gZm9udDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdHguZGlyZWN0aW9uID0gc3R5bGVzLmRpcmVjdGlvbiA9PT0gMSAvKiBSVEwgKi8gPyAncnRsJyA6ICdsdHInO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN0eC50ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3R4LnRleHRCYXNlbGluZSA9ICdhbHBoYWJldGljJztcbiAgICAgICAgICAgICAgICAgICAgX2IgPSB0aGlzLmZvbnRNZXRyaWNzLmdldE1ldHJpY3MoZm9udEZhbWlseSwgZm9udFNpemUpLCBiYXNlbGluZSA9IF9iLmJhc2VsaW5lLCBtaWRkbGUgPSBfYi5taWRkbGU7XG4gICAgICAgICAgICAgICAgICAgIHBhaW50T3JkZXIgPSBzdHlsZXMucGFpbnRPcmRlcjtcbiAgICAgICAgICAgICAgICAgICAgdGV4dC50ZXh0Qm91bmRzLmZvckVhY2goZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhaW50T3JkZXIuZm9yRWFjaChmdW5jdGlvbiAocGFpbnRPcmRlckxheWVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChwYWludE9yZGVyTGF5ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwIC8qIEZJTEwgKi86XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5jdHguZmlsbFN0eWxlID0gYXNTdHJpbmcoc3R5bGVzLmNvbG9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnJlbmRlclRleHRXaXRoTGV0dGVyU3BhY2luZyh0ZXh0LCBzdHlsZXMubGV0dGVyU3BhY2luZywgYmFzZWxpbmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRleHRTaGFkb3dzID0gc3R5bGVzLnRleHRTaGFkb3c7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGV4dFNoYWRvd3MubGVuZ3RoICYmIHRleHQudGV4dC50cmltKCkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dFNoYWRvd3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnNsaWNlKDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXZlcnNlKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKHRleHRTaGFkb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuY3R4LnNoYWRvd0NvbG9yID0gYXNTdHJpbmcodGV4dFNoYWRvdy5jb2xvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmN0eC5zaGFkb3dPZmZzZXRYID0gdGV4dFNoYWRvdy5vZmZzZXRYLm51bWJlciAqIF90aGlzLm9wdGlvbnMuc2NhbGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmN0eC5zaGFkb3dPZmZzZXRZID0gdGV4dFNoYWRvdy5vZmZzZXRZLm51bWJlciAqIF90aGlzLm9wdGlvbnMuc2NhbGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmN0eC5zaGFkb3dCbHVyID0gdGV4dFNoYWRvdy5ibHVyLm51bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVuZGVyVGV4dFdpdGhMZXR0ZXJTcGFjaW5nKHRleHQsIHN0eWxlcy5sZXR0ZXJTcGFjaW5nLCBiYXNlbGluZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuY3R4LnNoYWRvd0NvbG9yID0gJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuY3R4LnNoYWRvd09mZnNldFggPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmN0eC5zaGFkb3dPZmZzZXRZID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5jdHguc2hhZG93Qmx1ciA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3R5bGVzLnRleHREZWNvcmF0aW9uTGluZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5jdHguZmlsbFN0eWxlID0gYXNTdHJpbmcoc3R5bGVzLnRleHREZWNvcmF0aW9uQ29sb3IgfHwgc3R5bGVzLmNvbG9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZXMudGV4dERlY29yYXRpb25MaW5lLmZvckVhY2goZnVuY3Rpb24gKHRleHREZWNvcmF0aW9uTGluZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHRleHREZWNvcmF0aW9uTGluZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxIC8qIFVOREVSTElORSAqLzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEcmF3cyBhIGxpbmUgYXQgdGhlIGJhc2VsaW5lIG9mIHRoZSBmb250XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBBcyBzb21lIGJyb3dzZXJzIGRpc3BsYXkgdGhlIGxpbmUgYXMgbW9yZSB0aGFuIDFweCBpZiB0aGUgZm9udC1zaXplIGlzIGJpZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBuZWVkIHRvIHRha2UgdGhhdCBpbnRvIGFjY291bnQgYm90aCBpbiBwb3NpdGlvbiBhbmQgc2l6ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmN0eC5maWxsUmVjdCh0ZXh0LmJvdW5kcy5sZWZ0LCBNYXRoLnJvdW5kKHRleHQuYm91bmRzLnRvcCArIGJhc2VsaW5lKSwgdGV4dC5ib3VuZHMud2lkdGgsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyIC8qIE9WRVJMSU5FICovOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmN0eC5maWxsUmVjdCh0ZXh0LmJvdW5kcy5sZWZ0LCBNYXRoLnJvdW5kKHRleHQuYm91bmRzLnRvcCksIHRleHQuYm91bmRzLndpZHRoLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMyAvKiBMSU5FX1RIUk9VR0ggKi86XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyB0cnkgYW5kIGZpbmQgZXhhY3QgcG9zaXRpb24gZm9yIGxpbmUtdGhyb3VnaFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmN0eC5maWxsUmVjdCh0ZXh0LmJvdW5kcy5sZWZ0LCBNYXRoLmNlaWwodGV4dC5ib3VuZHMudG9wICsgbWlkZGxlKSwgdGV4dC5ib3VuZHMud2lkdGgsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxIC8qIFNUUk9LRSAqLzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdHlsZXMud2Via2l0VGV4dFN0cm9rZVdpZHRoICYmIHRleHQudGV4dC50cmltKCkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuY3R4LnN0cm9rZVN0eWxlID0gYXNTdHJpbmcoc3R5bGVzLndlYmtpdFRleHRTdHJva2VDb2xvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuY3R4LmxpbmVXaWR0aCA9IHN0eWxlcy53ZWJraXRUZXh0U3Ryb2tlV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5jdHgubGluZUpvaW4gPSAhIXdpbmRvdy5jaHJvbWUgPyAnbWl0ZXInIDogJ3JvdW5kJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5jdHguc3Ryb2tlVGV4dCh0ZXh0LnRleHQsIHRleHQuYm91bmRzLmxlZnQsIHRleHQuYm91bmRzLnRvcCArIGJhc2VsaW5lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmN0eC5zdHJva2VTdHlsZSA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuY3R4LmxpbmVXaWR0aCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5jdHgubGluZUpvaW4gPSAnbWl0ZXInO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlclJlcGxhY2VkRWxlbWVudCA9IGZ1bmN0aW9uIChjb250YWluZXIsIGN1cnZlcywgaW1hZ2UpIHtcbiAgICAgICAgICAgIGlmIChpbWFnZSAmJiBjb250YWluZXIuaW50cmluc2ljV2lkdGggPiAwICYmIGNvbnRhaW5lci5pbnRyaW5zaWNIZWlnaHQgPiAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJveCA9IGNvbnRlbnRCb3goY29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICB2YXIgcGF0aCA9IGNhbGN1bGF0ZVBhZGRpbmdCb3hQYXRoKGN1cnZlcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXRoKHBhdGgpO1xuICAgICAgICAgICAgICAgIHRoaXMuY3R4LnNhdmUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmN0eC5jbGlwKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jdHguZHJhd0ltYWdlKGltYWdlLCAwLCAwLCBjb250YWluZXIuaW50cmluc2ljV2lkdGgsIGNvbnRhaW5lci5pbnRyaW5zaWNIZWlnaHQsIGJveC5sZWZ0LCBib3gudG9wLCBib3gud2lkdGgsIGJveC5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIHRoaXMuY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlck5vZGVDb250ZW50ID0gZnVuY3Rpb24gKHBhaW50KSB7XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRhaW5lciwgY3VydmVzLCBzdHlsZXMsIF9pLCBfYSwgY2hpbGQsIGltYWdlLCBpbWFnZSwgaWZyYW1lUmVuZGVyZXIsIGNhbnZhcywgc2l6ZSwgX2IsIGZvbnRGYW1pbHksIGZvbnRTaXplLCBiYXNlbGluZSwgYm91bmRzLCB4LCB0ZXh0Qm91bmRzLCBpbWcsIGltYWdlLCB1cmwsIGZvbnRGYW1pbHksIGJvdW5kcztcbiAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9jKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2MubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcGx5RWZmZWN0cyhwYWludC5nZXRFZmZlY3RzKDQgLyogQ09OVEVOVCAqLykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lciA9IHBhaW50LmNvbnRhaW5lcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJ2ZXMgPSBwYWludC5jdXJ2ZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVzID0gY29udGFpbmVyLnN0eWxlcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaSA9IDAsIF9hID0gY29udGFpbmVyLnRleHROb2RlcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYy5sYWJlbCA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoX2kgPCBfYS5sZW5ndGgpKSByZXR1cm4gWzMgLypicmVhayovLCA0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZCA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnJlbmRlclRleHROb2RlKGNoaWxkLCBzdHlsZXMpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYy5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2MubGFiZWwgPSAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9pKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoY29udGFpbmVyIGluc3RhbmNlb2YgSW1hZ2VFbGVtZW50Q29udGFpbmVyKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgOF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2MubGFiZWwgPSA1O1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jLnRyeXMucHVzaChbNSwgNywgLCA4XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5jb250ZXh0LmNhY2hlLm1hdGNoKGNvbnRhaW5lci5zcmMpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZSA9IF9jLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlclJlcGxhY2VkRWxlbWVudChjb250YWluZXIsIGN1cnZlcywgaW1hZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQubG9nZ2VyLmVycm9yKFwiRXJyb3IgbG9hZGluZyBpbWFnZSBcIiArIGNvbnRhaW5lci5zcmMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250YWluZXIgaW5zdGFuY2VvZiBDYW52YXNFbGVtZW50Q29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyUmVwbGFjZWRFbGVtZW50KGNvbnRhaW5lciwgY3VydmVzLCBjb250YWluZXIuY2FudmFzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoY29udGFpbmVyIGluc3RhbmNlb2YgU1ZHRWxlbWVudENvbnRhaW5lcikpIHJldHVybiBbMyAvKmJyZWFrKi8sIDEyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYy5sYWJlbCA9IDk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2MudHJ5cy5wdXNoKFs5LCAxMSwgLCAxMl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuY29udGV4dC5jYWNoZS5tYXRjaChjb250YWluZXIuc3ZnKV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlID0gX2Muc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyUmVwbGFjZWRFbGVtZW50KGNvbnRhaW5lciwgY3VydmVzLCBpbWFnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMTJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYy5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmxvZ2dlci5lcnJvcihcIkVycm9yIGxvYWRpbmcgc3ZnIFwiICsgY29udGFpbmVyLnN2Zy5zdWJzdHJpbmcoMCwgMjU1KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMTJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShjb250YWluZXIgaW5zdGFuY2VvZiBJRnJhbWVFbGVtZW50Q29udGFpbmVyICYmIGNvbnRhaW5lci50cmVlKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMTRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmcmFtZVJlbmRlcmVyID0gbmV3IENhbnZhc1JlbmRlcmVyKHRoaXMuY29udGV4dCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2FsZTogdGhpcy5vcHRpb25zLnNjYWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGNvbnRhaW5lci5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBjb250YWluZXIud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogY29udGFpbmVyLmhlaWdodFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGlmcmFtZVJlbmRlcmVyLnJlbmRlcihjb250YWluZXIudHJlZSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW52YXMgPSBfYy5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRhaW5lci53aWR0aCAmJiBjb250YWluZXIuaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3R4LmRyYXdJbWFnZShjYW52YXMsIDAsIDAsIGNvbnRhaW5lci53aWR0aCwgY29udGFpbmVyLmhlaWdodCwgY29udGFpbmVyLmJvdW5kcy5sZWZ0LCBjb250YWluZXIuYm91bmRzLnRvcCwgY29udGFpbmVyLmJvdW5kcy53aWR0aCwgY29udGFpbmVyLmJvdW5kcy5oZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYy5sYWJlbCA9IDE0O1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGFpbmVyIGluc3RhbmNlb2YgSW5wdXRFbGVtZW50Q29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpemUgPSBNYXRoLm1pbihjb250YWluZXIuYm91bmRzLndpZHRoLCBjb250YWluZXIuYm91bmRzLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250YWluZXIudHlwZSA9PT0gQ0hFQ0tCT1gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250YWluZXIuY2hlY2tlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3R4LnNhdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhdGgoW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgVmVjdG9yKGNvbnRhaW5lci5ib3VuZHMubGVmdCArIHNpemUgKiAwLjM5MzYzLCBjb250YWluZXIuYm91bmRzLnRvcCArIHNpemUgKiAwLjc5KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFZlY3Rvcihjb250YWluZXIuYm91bmRzLmxlZnQgKyBzaXplICogMC4xNiwgY29udGFpbmVyLmJvdW5kcy50b3AgKyBzaXplICogMC41NTQ5KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFZlY3Rvcihjb250YWluZXIuYm91bmRzLmxlZnQgKyBzaXplICogMC4yNzM0NywgY29udGFpbmVyLmJvdW5kcy50b3AgKyBzaXplICogMC40NDA3MSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBWZWN0b3IoY29udGFpbmVyLmJvdW5kcy5sZWZ0ICsgc2l6ZSAqIDAuMzk2OTQsIGNvbnRhaW5lci5ib3VuZHMudG9wICsgc2l6ZSAqIDAuNTY0OSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBWZWN0b3IoY29udGFpbmVyLmJvdW5kcy5sZWZ0ICsgc2l6ZSAqIDAuNzI5ODMsIGNvbnRhaW5lci5ib3VuZHMudG9wICsgc2l6ZSAqIDAuMjMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgVmVjdG9yKGNvbnRhaW5lci5ib3VuZHMubGVmdCArIHNpemUgKiAwLjg0LCBjb250YWluZXIuYm91bmRzLnRvcCArIHNpemUgKiAwLjM0MDg1KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFZlY3Rvcihjb250YWluZXIuYm91bmRzLmxlZnQgKyBzaXplICogMC4zOTM2MywgY29udGFpbmVyLmJvdW5kcy50b3AgKyBzaXplICogMC43OSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmN0eC5maWxsU3R5bGUgPSBhc1N0cmluZyhJTlBVVF9DT0xPUik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jdHguZmlsbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjb250YWluZXIudHlwZSA9PT0gUkFESU8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250YWluZXIuY2hlY2tlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3R4LnNhdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmN0eC5hcmMoY29udGFpbmVyLmJvdW5kcy5sZWZ0ICsgc2l6ZSAvIDIsIGNvbnRhaW5lci5ib3VuZHMudG9wICsgc2l6ZSAvIDIsIHNpemUgLyA0LCAwLCBNYXRoLlBJICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jdHguZmlsbFN0eWxlID0gYXNTdHJpbmcoSU5QVVRfQ09MT1IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3R4LmZpbGwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzVGV4dElucHV0RWxlbWVudChjb250YWluZXIpICYmIGNvbnRhaW5lci52YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2IgPSB0aGlzLmNyZWF0ZUZvbnRTdHlsZShzdHlsZXMpLCBmb250RmFtaWx5ID0gX2JbMF0sIGZvbnRTaXplID0gX2JbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhc2VsaW5lID0gdGhpcy5mb250TWV0cmljcy5nZXRNZXRyaWNzKGZvbnRGYW1pbHksIGZvbnRTaXplKS5iYXNlbGluZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jdHguZm9udCA9IGZvbnRGYW1pbHk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3R4LmZpbGxTdHlsZSA9IGFzU3RyaW5nKHN0eWxlcy5jb2xvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3R4LnRleHRCYXNlbGluZSA9ICdhbHBoYWJldGljJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jdHgudGV4dEFsaWduID0gY2FudmFzVGV4dEFsaWduKGNvbnRhaW5lci5zdHlsZXMudGV4dEFsaWduKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm91bmRzID0gY29udGVudEJveChjb250YWluZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjb250YWluZXIuc3R5bGVzLnRleHRBbGlnbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxIC8qIENFTlRFUiAqLzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4ICs9IGJvdW5kcy53aWR0aCAvIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDIgLyogUklHSFQgKi86XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeCArPSBib3VuZHMud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dEJvdW5kcyA9IGJvdW5kcy5hZGQoeCwgMCwgMCwgLWJvdW5kcy5oZWlnaHQgLyAyICsgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3R4LnNhdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXRoKFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBWZWN0b3IoYm91bmRzLmxlZnQsIGJvdW5kcy50b3ApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFZlY3Rvcihib3VuZHMubGVmdCArIGJvdW5kcy53aWR0aCwgYm91bmRzLnRvcCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgVmVjdG9yKGJvdW5kcy5sZWZ0ICsgYm91bmRzLndpZHRoLCBib3VuZHMudG9wICsgYm91bmRzLmhlaWdodCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgVmVjdG9yKGJvdW5kcy5sZWZ0LCBib3VuZHMudG9wICsgYm91bmRzLmhlaWdodClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3R4LmNsaXAoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJUZXh0V2l0aExldHRlclNwYWNpbmcobmV3IFRleHRCb3VuZHMoY29udGFpbmVyLnZhbHVlLCB0ZXh0Qm91bmRzKSwgc3R5bGVzLmxldHRlclNwYWNpbmcsIGJhc2VsaW5lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmN0eC50ZXh0QmFzZWxpbmUgPSAnYWxwaGFiZXRpYyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3R4LnRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjb250YWlucyhjb250YWluZXIuc3R5bGVzLmRpc3BsYXksIDIwNDggLyogTElTVF9JVEVNICovKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMjBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGNvbnRhaW5lci5zdHlsZXMubGlzdFN0eWxlSW1hZ2UgIT09IG51bGwpKSByZXR1cm4gWzMgLypicmVhayovLCAxOV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1nID0gY29udGFpbmVyLnN0eWxlcy5saXN0U3R5bGVJbWFnZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShpbWcudHlwZSA9PT0gMCAvKiBVUkwgKi8pKSByZXR1cm4gWzMgLypicmVhayovLCAxOF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2UgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gaW1nLnVybDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYy5sYWJlbCA9IDE1O1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYy50cnlzLnB1c2goWzE1LCAxNywgLCAxOF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuY29udGV4dC5jYWNoZS5tYXRjaCh1cmwpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2UgPSBfYy5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jdHguZHJhd0ltYWdlKGltYWdlLCBjb250YWluZXIuYm91bmRzLmxlZnQgLSAoaW1hZ2Uud2lkdGggKyAxMCksIGNvbnRhaW5lci5ib3VuZHMudG9wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxOF07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQubG9nZ2VyLmVycm9yKFwiRXJyb3IgbG9hZGluZyBsaXN0LXN0eWxlLWltYWdlIFwiICsgdXJsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxOF07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE4OiByZXR1cm4gWzMgLypicmVhayovLCAyMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYWludC5saXN0VmFsdWUgJiYgY29udGFpbmVyLnN0eWxlcy5saXN0U3R5bGVUeXBlICE9PSAtMSAvKiBOT05FICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRGYW1pbHkgPSB0aGlzLmNyZWF0ZUZvbnRTdHlsZShzdHlsZXMpWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmN0eC5mb250ID0gZm9udEZhbWlseTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jdHguZmlsbFN0eWxlID0gYXNTdHJpbmcoc3R5bGVzLmNvbG9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3R4LnRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5kcyA9IG5ldyBCb3VuZHMoY29udGFpbmVyLmJvdW5kcy5sZWZ0LCBjb250YWluZXIuYm91bmRzLnRvcCArIGdldEFic29sdXRlVmFsdWUoY29udGFpbmVyLnN0eWxlcy5wYWRkaW5nVG9wLCBjb250YWluZXIuYm91bmRzLndpZHRoKSwgY29udGFpbmVyLmJvdW5kcy53aWR0aCwgY29tcHV0ZUxpbmVIZWlnaHQoc3R5bGVzLmxpbmVIZWlnaHQsIHN0eWxlcy5mb250U2l6ZS5udW1iZXIpIC8gMiArIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlclRleHRXaXRoTGV0dGVyU3BhY2luZyhuZXcgVGV4dEJvdW5kcyhwYWludC5saXN0VmFsdWUsIGJvdW5kcyksIHN0eWxlcy5sZXR0ZXJTcGFjaW5nLCBjb21wdXRlTGluZUhlaWdodChzdHlsZXMubGluZUhlaWdodCwgc3R5bGVzLmZvbnRTaXplLm51bWJlcikgLyAyICsgMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3R4LnRleHRCYXNlbGluZSA9ICdib3R0b20nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmN0eC50ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jLmxhYmVsID0gMjA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDIwOiByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBDYW52YXNSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyU3RhY2tDb250ZW50ID0gZnVuY3Rpb24gKHN0YWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9pLCBfYSwgY2hpbGQsIF9iLCBfYywgY2hpbGQsIF9kLCBfZSwgY2hpbGQsIF9mLCBfZywgY2hpbGQsIF9oLCBfaiwgY2hpbGQsIF9rLCBfbCwgY2hpbGQsIF9tLCBfbywgY2hpbGQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfcCkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9wLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRhaW5zKHN0YWNrLmVsZW1lbnQuY29udGFpbmVyLmZsYWdzLCAxNiAvKiBERUJVR19SRU5ERVIgKi8pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnZ2VyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvY3NzLXBvc2l0aW9uLTMvI3BhaW50aW5nLW9yZGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMS4gdGhlIGJhY2tncm91bmQgYW5kIGJvcmRlcnMgb2YgdGhlIGVsZW1lbnQgZm9ybWluZyB0aGUgc3RhY2tpbmcgY29udGV4dC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnJlbmRlck5vZGVCYWNrZ3JvdW5kQW5kQm9yZGVycyhzdGFjay5lbGVtZW50KV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL2Nzcy1wb3NpdGlvbi0zLyNwYWludGluZy1vcmRlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDEuIHRoZSBiYWNrZ3JvdW5kIGFuZCBib3JkZXJzIG9mIHRoZSBlbGVtZW50IGZvcm1pbmcgdGhlIHN0YWNraW5nIGNvbnRleHQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3Auc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9pID0gMCwgX2EgPSBzdGFjay5uZWdhdGl2ZVpJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcC5sYWJlbCA9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoX2kgPCBfYS5sZW5ndGgpKSByZXR1cm4gWzMgLypicmVhayovLCA1XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZCA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnJlbmRlclN0YWNrKGNoaWxkKV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3Auc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9wLmxhYmVsID0gNDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaSsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA1OiBcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIDMuIEZvciBhbGwgaXRzIGluLWZsb3csIG5vbi1wb3NpdGlvbmVkLCBibG9jay1sZXZlbCBkZXNjZW5kYW50cyBpbiB0cmVlIG9yZGVyOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5yZW5kZXJOb2RlQ29udGVudChzdGFjay5lbGVtZW50KV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMy4gRm9yIGFsbCBpdHMgaW4tZmxvdywgbm9uLXBvc2l0aW9uZWQsIGJsb2NrLWxldmVsIGRlc2NlbmRhbnRzIGluIHRyZWUgb3JkZXI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3Auc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iID0gMCwgX2MgPSBzdGFjay5ub25JbmxpbmVMZXZlbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcC5sYWJlbCA9IDc7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoX2IgPCBfYy5sZW5ndGgpKSByZXR1cm4gWzMgLypicmVhayovLCAxMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQgPSBfY1tfYl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5yZW5kZXJOb2RlKGNoaWxkKV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3Auc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9wLmxhYmVsID0gOTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYisrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDddO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZCA9IDAsIF9lID0gc3RhY2subm9uUG9zaXRpb25lZEZsb2F0cztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcC5sYWJlbCA9IDExO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShfZCA8IF9lLmxlbmd0aCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDE0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZCA9IF9lW19kXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnJlbmRlclN0YWNrKGNoaWxkKV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9wLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcC5sYWJlbCA9IDEzO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDExXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2YgPSAwLCBfZyA9IHN0YWNrLm5vblBvc2l0aW9uZWRJbmxpbmVMZXZlbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcC5sYWJlbCA9IDE1O1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShfZiA8IF9nLmxlbmd0aCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDE4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZCA9IF9nW19mXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnJlbmRlclN0YWNrKGNoaWxkKV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9wLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcC5sYWJlbCA9IDE3O1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZisrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDE1XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTg6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2ggPSAwLCBfaiA9IHN0YWNrLmlubGluZUxldmVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9wLmxhYmVsID0gMTk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKF9oIDwgX2oubGVuZ3RoKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMjJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkID0gX2pbX2hdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucmVuZGVyTm9kZShjaGlsZCldO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcC5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3AubGFiZWwgPSAyMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2grKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxOV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9rID0gMCwgX2wgPSBzdGFjay56ZXJvT3JBdXRvWkluZGV4T3JUcmFuc2Zvcm1lZE9yT3BhY2l0eTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcC5sYWJlbCA9IDIzO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShfayA8IF9sLmxlbmd0aCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDI2XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZCA9IF9sW19rXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnJlbmRlclN0YWNrKGNoaWxkKV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9wLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcC5sYWJlbCA9IDI1O1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyNTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaysrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDIzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjY6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX20gPSAwLCBfbyA9IHN0YWNrLnBvc2l0aXZlWkluZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9wLmxhYmVsID0gMjc7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI3OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKF9tIDwgX28ubGVuZ3RoKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkID0gX29bX21dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucmVuZGVyU3RhY2soY2hpbGQpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjg6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3Auc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9wLmxhYmVsID0gMjk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI5OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9tKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMjddO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzMDogcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLm1hc2sgPSBmdW5jdGlvbiAocGF0aHMpIHtcbiAgICAgICAgICAgIHRoaXMuY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgdGhpcy5jdHgubW92ZVRvKDAsIDApO1xuICAgICAgICAgICAgdGhpcy5jdHgubGluZVRvKHRoaXMuY2FudmFzLndpZHRoLCAwKTtcbiAgICAgICAgICAgIHRoaXMuY3R4LmxpbmVUbyh0aGlzLmNhbnZhcy53aWR0aCwgdGhpcy5jYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgICAgIHRoaXMuY3R4LmxpbmVUbygwLCB0aGlzLmNhbnZhcy5oZWlnaHQpO1xuICAgICAgICAgICAgdGhpcy5jdHgubGluZVRvKDAsIDApO1xuICAgICAgICAgICAgdGhpcy5mb3JtYXRQYXRoKHBhdGhzLnNsaWNlKDApLnJldmVyc2UoKSk7XG4gICAgICAgICAgICB0aGlzLmN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgfTtcbiAgICAgICAgQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLnBhdGggPSBmdW5jdGlvbiAocGF0aHMpIHtcbiAgICAgICAgICAgIHRoaXMuY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgdGhpcy5mb3JtYXRQYXRoKHBhdGhzKTtcbiAgICAgICAgICAgIHRoaXMuY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICB9O1xuICAgICAgICBDYW52YXNSZW5kZXJlci5wcm90b3R5cGUuZm9ybWF0UGF0aCA9IGZ1bmN0aW9uIChwYXRocykge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHBhdGhzLmZvckVhY2goZnVuY3Rpb24gKHBvaW50LCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IGlzQmV6aWVyQ3VydmUocG9pbnQpID8gcG9pbnQuc3RhcnQgOiBwb2ludDtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY3R4Lm1vdmVUbyhzdGFydC54LCBzdGFydC55KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmN0eC5saW5lVG8oc3RhcnQueCwgc3RhcnQueSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc0JlemllckN1cnZlKHBvaW50KSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jdHguYmV6aWVyQ3VydmVUbyhwb2ludC5zdGFydENvbnRyb2wueCwgcG9pbnQuc3RhcnRDb250cm9sLnksIHBvaW50LmVuZENvbnRyb2wueCwgcG9pbnQuZW5kQ29udHJvbC55LCBwb2ludC5lbmQueCwgcG9pbnQuZW5kLnkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBDYW52YXNSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyUmVwZWF0ID0gZnVuY3Rpb24gKHBhdGgsIHBhdHRlcm4sIG9mZnNldFgsIG9mZnNldFkpIHtcbiAgICAgICAgICAgIHRoaXMucGF0aChwYXRoKTtcbiAgICAgICAgICAgIHRoaXMuY3R4LmZpbGxTdHlsZSA9IHBhdHRlcm47XG4gICAgICAgICAgICB0aGlzLmN0eC50cmFuc2xhdGUob2Zmc2V0WCwgb2Zmc2V0WSk7XG4gICAgICAgICAgICB0aGlzLmN0eC5maWxsKCk7XG4gICAgICAgICAgICB0aGlzLmN0eC50cmFuc2xhdGUoLW9mZnNldFgsIC1vZmZzZXRZKTtcbiAgICAgICAgfTtcbiAgICAgICAgQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLnJlc2l6ZUltYWdlID0gZnVuY3Rpb24gKGltYWdlLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBpZiAoaW1hZ2Uud2lkdGggPT09IHdpZHRoICYmIGltYWdlLmhlaWdodCA9PT0gaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGltYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG93bmVyRG9jdW1lbnQgPSAoX2EgPSB0aGlzLmNhbnZhcy5vd25lckRvY3VtZW50KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBkb2N1bWVudDtcbiAgICAgICAgICAgIHZhciBjYW52YXMgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICAgICAgY2FudmFzLndpZHRoID0gTWF0aC5tYXgoMSwgd2lkdGgpO1xuICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IE1hdGgubWF4KDEsIGhlaWdodCk7XG4gICAgICAgICAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgICBjdHguZHJhd0ltYWdlKGltYWdlLCAwLCAwLCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0LCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgIHJldHVybiBjYW52YXM7XG4gICAgICAgIH07XG4gICAgICAgIENhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJCYWNrZ3JvdW5kSW1hZ2UgPSBmdW5jdGlvbiAoY29udGFpbmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4LCBfbG9vcF8xLCB0aGlzXzEsIF9pLCBfYSwgYmFja2dyb3VuZEltYWdlO1xuICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gY29udGFpbmVyLnN0eWxlcy5iYWNrZ3JvdW5kSW1hZ2UubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfbG9vcF8xID0gZnVuY3Rpb24gKGJhY2tncm91bmRJbWFnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW1hZ2UsIHVybCwgX2MsIHBhdGgsIHgsIHksIHdpZHRoLCBoZWlnaHQsIHBhdHRlcm4sIF9kLCBwYXRoLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBfZSwgbGluZUxlbmd0aCwgeDAsIHgxLCB5MCwgeTEsIGNhbnZhcywgY3R4LCBncmFkaWVudF8xLCBwYXR0ZXJuLCBfZiwgcGF0aCwgbGVmdCwgdG9wXzEsIHdpZHRoLCBoZWlnaHQsIHBvc2l0aW9uLCB4LCB5LCBfZywgcngsIHJ5LCByYWRpYWxHcmFkaWVudF8xLCBtaWRYLCBtaWRZLCBmLCBpbnZGO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9oLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShiYWNrZ3JvdW5kSW1hZ2UudHlwZSA9PT0gMCAvKiBVUkwgKi8pKSByZXR1cm4gWzMgLypicmVhayovLCA1XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2UgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IGJhY2tncm91bmRJbWFnZS51cmw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9oLmxhYmVsID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9oLnRyeXMucHVzaChbMSwgMywgLCA0XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXNfMS5jb250ZXh0LmNhY2hlLm1hdGNoKHVybCldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2UgPSBfaC5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2guc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzXzEuY29udGV4dC5sb2dnZXIuZXJyb3IoXCJFcnJvciBsb2FkaW5nIGJhY2tncm91bmQtaW1hZ2UgXCIgKyB1cmwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbWFnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2MgPSBjYWxjdWxhdGVCYWNrZ3JvdW5kUmVuZGVyaW5nKGNvbnRhaW5lciwgaW5kZXgsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZS53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZS5oZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2Uud2lkdGggLyBpbWFnZS5oZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pLCBwYXRoID0gX2NbMF0sIHggPSBfY1sxXSwgeSA9IF9jWzJdLCB3aWR0aCA9IF9jWzNdLCBoZWlnaHQgPSBfY1s0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdHRlcm4gPSB0aGlzXzEuY3R4LmNyZWF0ZVBhdHRlcm4odGhpc18xLnJlc2l6ZUltYWdlKGltYWdlLCB3aWR0aCwgaGVpZ2h0KSwgJ3JlcGVhdCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc18xLnJlbmRlclJlcGVhdChwYXRoLCBwYXR0ZXJuLCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA2XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0xpbmVhckdyYWRpZW50KGJhY2tncm91bmRJbWFnZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9kID0gY2FsY3VsYXRlQmFja2dyb3VuZFJlbmRlcmluZyhjb250YWluZXIsIGluZGV4LCBbbnVsbCwgbnVsbCwgbnVsbF0pLCBwYXRoID0gX2RbMF0sIHggPSBfZFsxXSwgeSA9IF9kWzJdLCB3aWR0aCA9IF9kWzNdLCBoZWlnaHQgPSBfZFs0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9lID0gY2FsY3VsYXRlR3JhZGllbnREaXJlY3Rpb24oYmFja2dyb3VuZEltYWdlLmFuZ2xlLCB3aWR0aCwgaGVpZ2h0KSwgbGluZUxlbmd0aCA9IF9lWzBdLCB4MCA9IF9lWzFdLCB4MSA9IF9lWzJdLCB5MCA9IF9lWzNdLCB5MSA9IF9lWzRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyYWRpZW50XzEgPSBjdHguY3JlYXRlTGluZWFyR3JhZGllbnQoeDAsIHkwLCB4MSwgeTEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc0NvbG9yU3RvcHMoYmFja2dyb3VuZEltYWdlLnN0b3BzLCBsaW5lTGVuZ3RoKS5mb3JFYWNoKGZ1bmN0aW9uIChjb2xvclN0b3ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ3JhZGllbnRfMS5hZGRDb2xvclN0b3AoY29sb3JTdG9wLnN0b3AsIGFzU3RyaW5nKGNvbG9yU3RvcC5jb2xvcikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gZ3JhZGllbnRfMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3aWR0aCA+IDAgJiYgaGVpZ2h0ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdHRlcm4gPSB0aGlzXzEuY3R4LmNyZWF0ZVBhdHRlcm4oY2FudmFzLCAncmVwZWF0Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc18xLnJlbmRlclJlcGVhdChwYXRoLCBwYXR0ZXJuLCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc1JhZGlhbEdyYWRpZW50KGJhY2tncm91bmRJbWFnZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9mID0gY2FsY3VsYXRlQmFja2dyb3VuZFJlbmRlcmluZyhjb250YWluZXIsIGluZGV4LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pLCBwYXRoID0gX2ZbMF0sIGxlZnQgPSBfZlsxXSwgdG9wXzEgPSBfZlsyXSwgd2lkdGggPSBfZlszXSwgaGVpZ2h0ID0gX2ZbNF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IGJhY2tncm91bmRJbWFnZS5wb3NpdGlvbi5sZW5ndGggPT09IDAgPyBbRklGVFlfUEVSQ0VOVF0gOiBiYWNrZ3JvdW5kSW1hZ2UucG9zaXRpb247XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4ID0gZ2V0QWJzb2x1dGVWYWx1ZShwb3NpdGlvblswXSwgd2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeSA9IGdldEFic29sdXRlVmFsdWUocG9zaXRpb25bcG9zaXRpb24ubGVuZ3RoIC0gMV0sIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZyA9IGNhbGN1bGF0ZVJhZGl1cyhiYWNrZ3JvdW5kSW1hZ2UsIHgsIHksIHdpZHRoLCBoZWlnaHQpLCByeCA9IF9nWzBdLCByeSA9IF9nWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJ4ID4gMCAmJiByeSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYWRpYWxHcmFkaWVudF8xID0gdGhpc18xLmN0eC5jcmVhdGVSYWRpYWxHcmFkaWVudChsZWZ0ICsgeCwgdG9wXzEgKyB5LCAwLCBsZWZ0ICsgeCwgdG9wXzEgKyB5LCByeCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc0NvbG9yU3RvcHMoYmFja2dyb3VuZEltYWdlLnN0b3BzLCByeCAqIDIpLmZvckVhY2goZnVuY3Rpb24gKGNvbG9yU3RvcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmFkaWFsR3JhZGllbnRfMS5hZGRDb2xvclN0b3AoY29sb3JTdG9wLnN0b3AsIGFzU3RyaW5nKGNvbG9yU3RvcC5jb2xvcikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNfMS5wYXRoKHBhdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNfMS5jdHguZmlsbFN0eWxlID0gcmFkaWFsR3JhZGllbnRfMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocnggIT09IHJ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pZFggPSBjb250YWluZXIuYm91bmRzLmxlZnQgKyAwLjUgKiBjb250YWluZXIuYm91bmRzLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaWRZID0gY29udGFpbmVyLmJvdW5kcy50b3AgKyAwLjUgKiBjb250YWluZXIuYm91bmRzLmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZiA9IHJ5IC8gcng7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludkYgPSAxIC8gZjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc18xLmN0eC5zYXZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNfMS5jdHgudHJhbnNsYXRlKG1pZFgsIG1pZFkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzXzEuY3R4LnRyYW5zZm9ybSgxLCAwLCAwLCBmLCAwLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc18xLmN0eC50cmFuc2xhdGUoLW1pZFgsIC1taWRZKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc18xLmN0eC5maWxsUmVjdChsZWZ0LCBpbnZGICogKHRvcF8xIC0gbWlkWSkgKyBtaWRZLCB3aWR0aCwgaGVpZ2h0ICogaW52Rik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNfMS5jdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc18xLmN0eC5maWxsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9oLmxhYmVsID0gNjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4LS07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzXzEgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9pID0gMCwgX2EgPSBjb250YWluZXIuc3R5bGVzLmJhY2tncm91bmRJbWFnZS5zbGljZSgwKS5yZXZlcnNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKF9pIDwgX2EubGVuZ3RoKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZEltYWdlID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNSAvKnlpZWxkKiovLCBfbG9vcF8xKGJhY2tncm91bmRJbWFnZSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDM7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2krKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlclNvbGlkQm9yZGVyID0gZnVuY3Rpb24gKGNvbG9yLCBzaWRlLCBjdXJ2ZVBvaW50cykge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXRoKHBhcnNlUGF0aEZvckJvcmRlcihjdXJ2ZVBvaW50cywgc2lkZSkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN0eC5maWxsU3R5bGUgPSBhc1N0cmluZyhjb2xvcik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3R4LmZpbGwoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIENhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJEb3VibGVCb3JkZXIgPSBmdW5jdGlvbiAoY29sb3IsIHdpZHRoLCBzaWRlLCBjdXJ2ZVBvaW50cykge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBvdXRlclBhdGhzLCBpbm5lclBhdGhzO1xuICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHdpZHRoIDwgMykpIHJldHVybiBbMyAvKmJyZWFrKi8sIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucmVuZGVyU29saWRCb3JkZXIoY29sb3IsIHNpZGUsIGN1cnZlUG9pbnRzKV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRlclBhdGhzID0gcGFyc2VQYXRoRm9yQm9yZGVyRG91YmxlT3V0ZXIoY3VydmVQb2ludHMsIHNpZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGF0aChvdXRlclBhdGhzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmN0eC5maWxsU3R5bGUgPSBhc1N0cmluZyhjb2xvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jdHguZmlsbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlubmVyUGF0aHMgPSBwYXJzZVBhdGhGb3JCb3JkZXJEb3VibGVJbm5lcihjdXJ2ZVBvaW50cywgc2lkZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXRoKGlubmVyUGF0aHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3R4LmZpbGwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBDYW52YXNSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyTm9kZUJhY2tncm91bmRBbmRCb3JkZXJzID0gZnVuY3Rpb24gKHBhaW50KSB7XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0eWxlcywgaGFzQmFja2dyb3VuZCwgYm9yZGVycywgYmFja2dyb3VuZFBhaW50aW5nQXJlYSwgc2lkZSwgX2ksIGJvcmRlcnNfMSwgYm9yZGVyO1xuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBseUVmZmVjdHMocGFpbnQuZ2V0RWZmZWN0cygyIC8qIEJBQ0tHUk9VTkRfQk9SREVSUyAqLykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlcyA9IHBhaW50LmNvbnRhaW5lci5zdHlsZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzQmFja2dyb3VuZCA9ICFpc1RyYW5zcGFyZW50KHN0eWxlcy5iYWNrZ3JvdW5kQ29sb3IpIHx8IHN0eWxlcy5iYWNrZ3JvdW5kSW1hZ2UubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlcnMgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgc3R5bGU6IHN0eWxlcy5ib3JkZXJUb3BTdHlsZSwgY29sb3I6IHN0eWxlcy5ib3JkZXJUb3BDb2xvciwgd2lkdGg6IHN0eWxlcy5ib3JkZXJUb3BXaWR0aCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHN0eWxlOiBzdHlsZXMuYm9yZGVyUmlnaHRTdHlsZSwgY29sb3I6IHN0eWxlcy5ib3JkZXJSaWdodENvbG9yLCB3aWR0aDogc3R5bGVzLmJvcmRlclJpZ2h0V2lkdGggfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBzdHlsZTogc3R5bGVzLmJvcmRlckJvdHRvbVN0eWxlLCBjb2xvcjogc3R5bGVzLmJvcmRlckJvdHRvbUNvbG9yLCB3aWR0aDogc3R5bGVzLmJvcmRlckJvdHRvbVdpZHRoIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgc3R5bGU6IHN0eWxlcy5ib3JkZXJMZWZ0U3R5bGUsIGNvbG9yOiBzdHlsZXMuYm9yZGVyTGVmdENvbG9yLCB3aWR0aDogc3R5bGVzLmJvcmRlckxlZnRXaWR0aCB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kUGFpbnRpbmdBcmVhID0gY2FsY3VsYXRlQmFja2dyb3VuZEN1cnZlZFBhaW50aW5nQXJlYShnZXRCYWNrZ3JvdW5kVmFsdWVGb3JJbmRleChzdHlsZXMuYmFja2dyb3VuZENsaXAsIDApLCBwYWludC5jdXJ2ZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGhhc0JhY2tncm91bmQgfHwgc3R5bGVzLmJveFNoYWRvdy5sZW5ndGgpKSByZXR1cm4gWzMgLypicmVhayovLCAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmN0eC5zYXZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXRoKGJhY2tncm91bmRQYWludGluZ0FyZWEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3R4LmNsaXAoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzVHJhbnNwYXJlbnQoc3R5bGVzLmJhY2tncm91bmRDb2xvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jdHguZmlsbFN0eWxlID0gYXNTdHJpbmcoc3R5bGVzLmJhY2tncm91bmRDb2xvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3R4LmZpbGwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5yZW5kZXJCYWNrZ3JvdW5kSW1hZ2UocGFpbnQuY29udGFpbmVyKV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZXMuYm94U2hhZG93XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zbGljZSgwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmV2ZXJzZSgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChzaGFkb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuY3R4LnNhdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJvcmRlckJveEFyZWEgPSBjYWxjdWxhdGVCb3JkZXJCb3hQYXRoKHBhaW50LmN1cnZlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXNrT2Zmc2V0ID0gc2hhZG93Lmluc2V0ID8gMCA6IE1BU0tfT0ZGU0VUO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2hhZG93UGFpbnRpbmdBcmVhID0gdHJhbnNmb3JtUGF0aChib3JkZXJCb3hBcmVhLCAtbWFza09mZnNldCArIChzaGFkb3cuaW5zZXQgPyAxIDogLTEpICogc2hhZG93LnNwcmVhZC5udW1iZXIsIChzaGFkb3cuaW5zZXQgPyAxIDogLTEpICogc2hhZG93LnNwcmVhZC5udW1iZXIsIHNoYWRvdy5zcHJlYWQubnVtYmVyICogKHNoYWRvdy5pbnNldCA/IC0yIDogMiksIHNoYWRvdy5zcHJlYWQubnVtYmVyICogKHNoYWRvdy5pbnNldCA/IC0yIDogMikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2hhZG93Lmluc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5wYXRoKGJvcmRlckJveEFyZWEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuY3R4LmNsaXAoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm1hc2soc2hhZG93UGFpbnRpbmdBcmVhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm1hc2soYm9yZGVyQm94QXJlYSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5jdHguY2xpcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucGF0aChzaGFkb3dQYWludGluZ0FyZWEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmN0eC5zaGFkb3dPZmZzZXRYID0gc2hhZG93Lm9mZnNldFgubnVtYmVyICsgbWFza09mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuY3R4LnNoYWRvd09mZnNldFkgPSBzaGFkb3cub2Zmc2V0WS5udW1iZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmN0eC5zaGFkb3dDb2xvciA9IGFzU3RyaW5nKHNoYWRvdy5jb2xvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmN0eC5zaGFkb3dCbHVyID0gc2hhZG93LmJsdXIubnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5jdHguZmlsbFN0eWxlID0gc2hhZG93Lmluc2V0ID8gYXNTdHJpbmcoc2hhZG93LmNvbG9yKSA6ICdyZ2JhKDAsMCwwLDEpJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuY3R4LmZpbGwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2lkZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2kgPSAwLCBib3JkZXJzXzEgPSBib3JkZXJzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShfaSA8IGJvcmRlcnNfMS5sZW5ndGgpKSByZXR1cm4gWzMgLypicmVhayovLCAxM107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyID0gYm9yZGVyc18xW19pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShib3JkZXIuc3R5bGUgIT09IDAgLyogTk9ORSAqLyAmJiAhaXNUcmFuc3BhcmVudChib3JkZXIuY29sb3IpICYmIGJvcmRlci53aWR0aCA+IDApKSByZXR1cm4gWzMgLypicmVhayovLCAxMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoYm9yZGVyLnN0eWxlID09PSAyIC8qIERBU0hFRCAqLykpIHJldHVybiBbMyAvKmJyZWFrKi8sIDVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucmVuZGVyRGFzaGVkRG90dGVkQm9yZGVyKGJvcmRlci5jb2xvciwgYm9yZGVyLndpZHRoLCBzaWRlLCBwYWludC5jdXJ2ZXMsIDIgLyogREFTSEVEICovKV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDExXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShib3JkZXIuc3R5bGUgPT09IDMgLyogRE9UVEVEICovKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgN107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5yZW5kZXJEYXNoZWREb3R0ZWRCb3JkZXIoYm9yZGVyLmNvbG9yLCBib3JkZXIud2lkdGgsIHNpZGUsIHBhaW50LmN1cnZlcywgMyAvKiBET1RURUQgKi8pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMTFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGJvcmRlci5zdHlsZSA9PT0gNCAvKiBET1VCTEUgKi8pKSByZXR1cm4gWzMgLypicmVhayovLCA5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnJlbmRlckRvdWJsZUJvcmRlcihib3JkZXIuY29sb3IsIGJvcmRlci53aWR0aCwgc2lkZSwgcGFpbnQuY3VydmVzKV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDExXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgOTogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5yZW5kZXJTb2xpZEJvcmRlcihib3JkZXIuY29sb3IsIHNpZGUsIHBhaW50LmN1cnZlcyldO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAxMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2lkZSsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMTI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9pKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgM107XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEzOiByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBDYW52YXNSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyRGFzaGVkRG90dGVkQm9yZGVyID0gZnVuY3Rpb24gKGNvbG9yLCB3aWR0aCwgc2lkZSwgY3VydmVQb2ludHMsIHN0eWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0cm9rZVBhdGhzLCBib3hQYXRocywgc3RhcnRYLCBzdGFydFksIGVuZFgsIGVuZFksIGxlbmd0aCwgZGFzaExlbmd0aCwgc3BhY2VMZW5ndGgsIHVzZUxpbmVEYXNoLCBtdWx0aXBsaWVyLCBudW1iZXJPZkRhc2hlcywgbWluU3BhY2UsIG1heFNwYWNlLCBwYXRoMSwgcGF0aDIsIHBhdGgxLCBwYXRoMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3R4LnNhdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlUGF0aHMgPSBwYXJzZVBhdGhGb3JCb3JkZXJTdHJva2UoY3VydmVQb2ludHMsIHNpZGUpO1xuICAgICAgICAgICAgICAgICAgICBib3hQYXRocyA9IHBhcnNlUGF0aEZvckJvcmRlcihjdXJ2ZVBvaW50cywgc2lkZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHlsZSA9PT0gMiAvKiBEQVNIRUQgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGF0aChib3hQYXRocyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmN0eC5jbGlwKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQmV6aWVyQ3VydmUoYm94UGF0aHNbMF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydFggPSBib3hQYXRoc1swXS5zdGFydC54O1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRZID0gYm94UGF0aHNbMF0uc3RhcnQueTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0WCA9IGJveFBhdGhzWzBdLng7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydFkgPSBib3hQYXRoc1swXS55O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0JlemllckN1cnZlKGJveFBhdGhzWzFdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5kWCA9IGJveFBhdGhzWzFdLmVuZC54O1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5kWSA9IGJveFBhdGhzWzFdLmVuZC55O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5kWCA9IGJveFBhdGhzWzFdLng7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRZID0gYm94UGF0aHNbMV0ueTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc2lkZSA9PT0gMCB8fCBzaWRlID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSBNYXRoLmFicyhzdGFydFggLSBlbmRYKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IE1hdGguYWJzKHN0YXJ0WSAtIGVuZFkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3R5bGUgPT09IDMgLyogRE9UVEVEICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZvcm1hdFBhdGgoc3Ryb2tlUGF0aHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5mb3JtYXRQYXRoKGJveFBhdGhzLnNsaWNlKDAsIDIpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkYXNoTGVuZ3RoID0gd2lkdGggPCAzID8gd2lkdGggKiAzIDogd2lkdGggKiAyO1xuICAgICAgICAgICAgICAgICAgICBzcGFjZUxlbmd0aCA9IHdpZHRoIDwgMyA/IHdpZHRoICogMiA6IHdpZHRoO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3R5bGUgPT09IDMgLyogRE9UVEVEICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXNoTGVuZ3RoID0gd2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcGFjZUxlbmd0aCA9IHdpZHRoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHVzZUxpbmVEYXNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxlbmd0aCA8PSBkYXNoTGVuZ3RoICogMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXNlTGluZURhc2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChsZW5ndGggPD0gZGFzaExlbmd0aCAqIDIgKyBzcGFjZUxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlwbGllciA9IGxlbmd0aCAvICgyICogZGFzaExlbmd0aCArIHNwYWNlTGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhc2hMZW5ndGggKj0gbXVsdGlwbGllcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwYWNlTGVuZ3RoICo9IG11bHRpcGxpZXI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBudW1iZXJPZkRhc2hlcyA9IE1hdGguZmxvb3IoKGxlbmd0aCArIHNwYWNlTGVuZ3RoKSAvIChkYXNoTGVuZ3RoICsgc3BhY2VMZW5ndGgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pblNwYWNlID0gKGxlbmd0aCAtIG51bWJlck9mRGFzaGVzICogZGFzaExlbmd0aCkgLyAobnVtYmVyT2ZEYXNoZXMgLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heFNwYWNlID0gKGxlbmd0aCAtIChudW1iZXJPZkRhc2hlcyArIDEpICogZGFzaExlbmd0aCkgLyBudW1iZXJPZkRhc2hlcztcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwYWNlTGVuZ3RoID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhTcGFjZSA8PSAwIHx8IE1hdGguYWJzKHNwYWNlTGVuZ3RoIC0gbWluU3BhY2UpIDwgTWF0aC5hYnMoc3BhY2VMZW5ndGggLSBtYXhTcGFjZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBtaW5TcGFjZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IG1heFNwYWNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh1c2VMaW5lRGFzaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0eWxlID09PSAzIC8qIERPVFRFRCAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3R4LnNldExpbmVEYXNoKFswLCBkYXNoTGVuZ3RoICsgc3BhY2VMZW5ndGhdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3R4LnNldExpbmVEYXNoKFtkYXNoTGVuZ3RoLCBzcGFjZUxlbmd0aF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHlsZSA9PT0gMyAvKiBET1RURUQgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3R4LmxpbmVDYXAgPSAncm91bmQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jdHgubGluZVdpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmN0eC5saW5lV2lkdGggPSB3aWR0aCAqIDIgKyAxLjE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdHguc3Ryb2tlU3R5bGUgPSBhc1N0cmluZyhjb2xvcik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3R4LnN0cm9rZSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN0eC5zZXRMaW5lRGFzaChbXSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRhc2hlZCByb3VuZCBlZGdlIGdhcFxuICAgICAgICAgICAgICAgICAgICBpZiAoc3R5bGUgPT09IDIgLyogREFTSEVEICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNCZXppZXJDdXJ2ZShib3hQYXRoc1swXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoMSA9IGJveFBhdGhzWzNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGgyID0gYm94UGF0aHNbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5mb3JtYXRQYXRoKFtuZXcgVmVjdG9yKHBhdGgxLmVuZC54LCBwYXRoMS5lbmQueSksIG5ldyBWZWN0b3IocGF0aDIuc3RhcnQueCwgcGF0aDIuc3RhcnQueSldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0JlemllckN1cnZlKGJveFBhdGhzWzFdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGgxID0gYm94UGF0aHNbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDIgPSBib3hQYXRoc1syXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZvcm1hdFBhdGgoW25ldyBWZWN0b3IocGF0aDEuZW5kLngsIHBhdGgxLmVuZC55KSwgbmV3IFZlY3RvcihwYXRoMi5zdGFydC54LCBwYXRoMi5zdGFydC55KV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3R4LnN0cm9rZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIENhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBzdGFjaztcbiAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmJhY2tncm91bmRDb2xvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmN0eC5maWxsU3R5bGUgPSBhc1N0cmluZyh0aGlzLm9wdGlvbnMuYmFja2dyb3VuZENvbG9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jdHguZmlsbFJlY3QodGhpcy5vcHRpb25zLngsIHRoaXMub3B0aW9ucy55LCB0aGlzLm9wdGlvbnMud2lkdGgsIHRoaXMub3B0aW9ucy5oZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFjayA9IHBhcnNlU3RhY2tpbmdDb250ZXh0cyhlbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnJlbmRlclN0YWNrKHN0YWNrKV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwbHlFZmZlY3RzKFtdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5jYW52YXNdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIENhbnZhc1JlbmRlcmVyO1xuICAgIH0oUmVuZGVyZXIpKTtcbiAgICB2YXIgaXNUZXh0SW5wdXRFbGVtZW50ID0gZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuICAgICAgICBpZiAoY29udGFpbmVyIGluc3RhbmNlb2YgVGV4dGFyZWFFbGVtZW50Q29udGFpbmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb250YWluZXIgaW5zdGFuY2VvZiBTZWxlY3RFbGVtZW50Q29udGFpbmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb250YWluZXIgaW5zdGFuY2VvZiBJbnB1dEVsZW1lbnRDb250YWluZXIgJiYgY29udGFpbmVyLnR5cGUgIT09IFJBRElPICYmIGNvbnRhaW5lci50eXBlICE9PSBDSEVDS0JPWCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgdmFyIGNhbGN1bGF0ZUJhY2tncm91bmRDdXJ2ZWRQYWludGluZ0FyZWEgPSBmdW5jdGlvbiAoY2xpcCwgY3VydmVzKSB7XG4gICAgICAgIHN3aXRjaCAoY2xpcCkge1xuICAgICAgICAgICAgY2FzZSAwIC8qIEJPUkRFUl9CT1ggKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGN1bGF0ZUJvcmRlckJveFBhdGgoY3VydmVzKTtcbiAgICAgICAgICAgIGNhc2UgMiAvKiBDT05URU5UX0JPWCAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsY3VsYXRlQ29udGVudEJveFBhdGgoY3VydmVzKTtcbiAgICAgICAgICAgIGNhc2UgMSAvKiBQQURESU5HX0JPWCAqLzpcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGN1bGF0ZVBhZGRpbmdCb3hQYXRoKGN1cnZlcyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBjYW52YXNUZXh0QWxpZ24gPSBmdW5jdGlvbiAodGV4dEFsaWduKSB7XG4gICAgICAgIHN3aXRjaCAodGV4dEFsaWduKSB7XG4gICAgICAgICAgICBjYXNlIDEgLyogQ0VOVEVSICovOlxuICAgICAgICAgICAgICAgIHJldHVybiAnY2VudGVyJztcbiAgICAgICAgICAgIGNhc2UgMiAvKiBSSUdIVCAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3JpZ2h0JztcbiAgICAgICAgICAgIGNhc2UgMCAvKiBMRUZUICovOlxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2xlZnQnO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL25pa2xhc3ZoL2h0bWwyY2FudmFzL3B1bGwvMjY0NVxuICAgIHZhciBpT1NCcm9rZW5Gb250cyA9IFsnLWFwcGxlLXN5c3RlbScsICdzeXN0ZW0tdWknXTtcbiAgICB2YXIgZml4SU9TU3lzdGVtRm9udHMgPSBmdW5jdGlvbiAoZm9udEZhbWlsaWVzKSB7XG4gICAgICAgIHJldHVybiAvaVBob25lIE9TIDE1XygwfDEpLy50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KVxuICAgICAgICAgICAgPyBmb250RmFtaWxpZXMuZmlsdGVyKGZ1bmN0aW9uIChmb250RmFtaWx5KSB7IHJldHVybiBpT1NCcm9rZW5Gb250cy5pbmRleE9mKGZvbnRGYW1pbHkpID09PSAtMTsgfSlcbiAgICAgICAgICAgIDogZm9udEZhbWlsaWVzO1xuICAgIH07XG5cbiAgICB2YXIgRm9yZWlnbk9iamVjdFJlbmRlcmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoRm9yZWlnbk9iamVjdFJlbmRlcmVyLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBGb3JlaWduT2JqZWN0UmVuZGVyZXIoY29udGV4dCwgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29udGV4dCwgb3B0aW9ucykgfHwgdGhpcztcbiAgICAgICAgICAgIF90aGlzLmNhbnZhcyA9IG9wdGlvbnMuY2FudmFzID8gb3B0aW9ucy5jYW52YXMgOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICAgIF90aGlzLmN0eCA9IF90aGlzLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAgICAgX3RoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgICAgICBfdGhpcy5jYW52YXMud2lkdGggPSBNYXRoLmZsb29yKG9wdGlvbnMud2lkdGggKiBvcHRpb25zLnNjYWxlKTtcbiAgICAgICAgICAgIF90aGlzLmNhbnZhcy5oZWlnaHQgPSBNYXRoLmZsb29yKG9wdGlvbnMuaGVpZ2h0ICogb3B0aW9ucy5zY2FsZSk7XG4gICAgICAgICAgICBfdGhpcy5jYW52YXMuc3R5bGUud2lkdGggPSBvcHRpb25zLndpZHRoICsgXCJweFwiO1xuICAgICAgICAgICAgX3RoaXMuY2FudmFzLnN0eWxlLmhlaWdodCA9IG9wdGlvbnMuaGVpZ2h0ICsgXCJweFwiO1xuICAgICAgICAgICAgX3RoaXMuY3R4LnNjYWxlKF90aGlzLm9wdGlvbnMuc2NhbGUsIF90aGlzLm9wdGlvbnMuc2NhbGUpO1xuICAgICAgICAgICAgX3RoaXMuY3R4LnRyYW5zbGF0ZSgtb3B0aW9ucy54LCAtb3B0aW9ucy55KTtcbiAgICAgICAgICAgIF90aGlzLmNvbnRleHQubG9nZ2VyLmRlYnVnKFwiRVhQRVJJTUVOVEFMIEZvcmVpZ25PYmplY3QgcmVuZGVyZXIgaW5pdGlhbGl6ZWQgKFwiICsgb3B0aW9ucy53aWR0aCArIFwieFwiICsgb3B0aW9ucy5oZWlnaHQgKyBcIiBhdCBcIiArIG9wdGlvbnMueCArIFwiLFwiICsgb3B0aW9ucy55ICsgXCIpIHdpdGggc2NhbGUgXCIgKyBvcHRpb25zLnNjYWxlKTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgfVxuICAgICAgICBGb3JlaWduT2JqZWN0UmVuZGVyZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN2ZywgaW1nO1xuICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN2ZyA9IGNyZWF0ZUZvcmVpZ25PYmplY3RTVkcodGhpcy5vcHRpb25zLndpZHRoICogdGhpcy5vcHRpb25zLnNjYWxlLCB0aGlzLm9wdGlvbnMuaGVpZ2h0ICogdGhpcy5vcHRpb25zLnNjYWxlLCB0aGlzLm9wdGlvbnMuc2NhbGUsIHRoaXMub3B0aW9ucy5zY2FsZSwgZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgbG9hZFNlcmlhbGl6ZWRTVkcoc3ZnKV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1nID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYmFja2dyb3VuZENvbG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3R4LmZpbGxTdHlsZSA9IGFzU3RyaW5nKHRoaXMub3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmN0eC5maWxsUmVjdCgwLCAwLCB0aGlzLm9wdGlvbnMud2lkdGggKiB0aGlzLm9wdGlvbnMuc2NhbGUsIHRoaXMub3B0aW9ucy5oZWlnaHQgKiB0aGlzLm9wdGlvbnMuc2NhbGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmN0eC5kcmF3SW1hZ2UoaW1nLCAtdGhpcy5vcHRpb25zLnggKiB0aGlzLm9wdGlvbnMuc2NhbGUsIC10aGlzLm9wdGlvbnMueSAqIHRoaXMub3B0aW9ucy5zY2FsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuY2FudmFzXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBGb3JlaWduT2JqZWN0UmVuZGVyZXI7XG4gICAgfShSZW5kZXJlcikpO1xuICAgIHZhciBsb2FkU2VyaWFsaXplZFNWRyA9IGZ1bmN0aW9uIChzdmcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHZhciBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgICAgIGltZy5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShpbWcpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGltZy5vbmVycm9yID0gcmVqZWN0O1xuICAgICAgICAgICAgaW1nLnNyYyA9IFwiZGF0YTppbWFnZS9zdmcreG1sO2NoYXJzZXQ9dXRmLTgsXCIgKyBlbmNvZGVVUklDb21wb25lbnQobmV3IFhNTFNlcmlhbGl6ZXIoKS5zZXJpYWxpemVUb1N0cmluZyhzdmcpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHZhciBMb2dnZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIExvZ2dlcihfYSkge1xuICAgICAgICAgICAgdmFyIGlkID0gX2EuaWQsIGVuYWJsZWQgPSBfYS5lbmFibGVkO1xuICAgICAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICAgICAgdGhpcy5lbmFibGVkID0gZW5hYmxlZDtcbiAgICAgICAgICAgIHRoaXMuc3RhcnQgPSBEYXRlLm5vdygpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIExvZ2dlci5wcm90b3R5cGUuZGVidWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5lbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmNvbnNvbGUgJiYgdHlwZW9mIGNvbnNvbGUuZGVidWcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5kZWJ1Zy5hcHBseShjb25zb2xlLCBfX3NwcmVhZEFycmF5KFt0aGlzLmlkLCB0aGlzLmdldFRpbWUoKSArIFwibXNcIl0sIGFyZ3MpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5mby5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIExvZ2dlci5wcm90b3R5cGUuZ2V0VGltZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBEYXRlLm5vdygpIC0gdGhpcy5zdGFydDtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgTG9nZ2VyLnByb3RvdHlwZS5pbmZvID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5jb25zb2xlICYmIHR5cGVvZiBjb25zb2xlLmluZm8gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5pbmZvLmFwcGx5KGNvbnNvbGUsIF9fc3ByZWFkQXJyYXkoW3RoaXMuaWQsIHRoaXMuZ2V0VGltZSgpICsgXCJtc1wiXSwgYXJncykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgTG9nZ2VyLnByb3RvdHlwZS53YXJuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5jb25zb2xlICYmIHR5cGVvZiBjb25zb2xlLndhcm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuLmFwcGx5KGNvbnNvbGUsIF9fc3ByZWFkQXJyYXkoW3RoaXMuaWQsIHRoaXMuZ2V0VGltZSgpICsgXCJtc1wiXSwgYXJncykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmZvLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgTG9nZ2VyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuY29uc29sZSAmJiB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yLmFwcGx5KGNvbnNvbGUsIF9fc3ByZWFkQXJyYXkoW3RoaXMuaWQsIHRoaXMuZ2V0VGltZSgpICsgXCJtc1wiXSwgYXJncykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmZvLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgTG9nZ2VyLmluc3RhbmNlcyA9IHt9O1xuICAgICAgICByZXR1cm4gTG9nZ2VyO1xuICAgIH0oKSk7XG5cbiAgICB2YXIgQ29udGV4dCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQ29udGV4dChvcHRpb25zLCB3aW5kb3dCb3VuZHMpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHRoaXMud2luZG93Qm91bmRzID0gd2luZG93Qm91bmRzO1xuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZU5hbWUgPSBcIiNcIiArIENvbnRleHQuaW5zdGFuY2VDb3VudCsrO1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIgPSBuZXcgTG9nZ2VyKHsgaWQ6IHRoaXMuaW5zdGFuY2VOYW1lLCBlbmFibGVkOiBvcHRpb25zLmxvZ2dpbmcgfSk7XG4gICAgICAgICAgICB0aGlzLmNhY2hlID0gKF9hID0gb3B0aW9ucy5jYWNoZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbmV3IENhY2hlKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIENvbnRleHQuaW5zdGFuY2VDb3VudCA9IDE7XG4gICAgICAgIHJldHVybiBDb250ZXh0O1xuICAgIH0oKSk7XG5cbiAgICB2YXIgaHRtbDJjYW52YXMgPSBmdW5jdGlvbiAoZWxlbWVudCwgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICByZXR1cm4gcmVuZGVyRWxlbWVudChlbGVtZW50LCBvcHRpb25zKTtcbiAgICB9O1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBDYWNoZVN0b3JhZ2Uuc2V0Q29udGV4dCh3aW5kb3cpO1xuICAgIH1cbiAgICB2YXIgcmVuZGVyRWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50LCBvcHRzKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb3duZXJEb2N1bWVudCwgZGVmYXVsdFZpZXcsIHJlc291cmNlT3B0aW9ucywgY29udGV4dE9wdGlvbnMsIHdpbmRvd09wdGlvbnMsIHdpbmRvd0JvdW5kcywgY29udGV4dCwgZm9yZWlnbk9iamVjdFJlbmRlcmluZywgY2xvbmVPcHRpb25zLCBkb2N1bWVudENsb25lciwgY2xvbmVkRWxlbWVudCwgY29udGFpbmVyLCBfYSwgd2lkdGgsIGhlaWdodCwgbGVmdCwgdG9wLCBiYWNrZ3JvdW5kQ29sb3IsIHJlbmRlck9wdGlvbnMsIGNhbnZhcywgcmVuZGVyZXIsIHJvb3QsIHJlbmRlcmVyO1xuICAgICAgICB2YXIgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2gsIF9qLCBfaywgX2wsIF9tLCBfbywgX3AsIF9xLCBfciwgX3MsIF90O1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF91KSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF91LmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICBpZiAoIWVsZW1lbnQgfHwgdHlwZW9mIGVsZW1lbnQgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgUHJvbWlzZS5yZWplY3QoJ0ludmFsaWQgZWxlbWVudCBwcm92aWRlZCBhcyBmaXJzdCBhcmd1bWVudCcpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvd25lckRvY3VtZW50ID0gZWxlbWVudC5vd25lckRvY3VtZW50O1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW93bmVyRG9jdW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVsZW1lbnQgaXMgbm90IGF0dGFjaGVkIHRvIGEgRG9jdW1lbnRcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFZpZXcgPSBvd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWRlZmF1bHRWaWV3KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEb2N1bWVudCBpcyBub3QgYXR0YWNoZWQgdG8gYSBXaW5kb3dcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2VPcHRpb25zID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dUYWludDogKF9iID0gb3B0cy5hbGxvd1RhaW50KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlVGltZW91dDogKF9jID0gb3B0cy5pbWFnZVRpbWVvdXQpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IDE1MDAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJveHk6IG9wdHMucHJveHksXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VDT1JTOiAoX2QgPSBvcHRzLnVzZUNPUlMpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHRPcHRpb25zID0gX19hc3NpZ24oeyBsb2dnaW5nOiAoX2UgPSBvcHRzLmxvZ2dpbmcpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IHRydWUsIGNhY2hlOiBvcHRzLmNhY2hlIH0sIHJlc291cmNlT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvd09wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3dXaWR0aDogKF9mID0gb3B0cy53aW5kb3dXaWR0aCkgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogZGVmYXVsdFZpZXcuaW5uZXJXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvd0hlaWdodDogKF9nID0gb3B0cy53aW5kb3dIZWlnaHQpICE9PSBudWxsICYmIF9nICE9PSB2b2lkIDAgPyBfZyA6IGRlZmF1bHRWaWV3LmlubmVySGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsWDogKF9oID0gb3B0cy5zY3JvbGxYKSAhPT0gbnVsbCAmJiBfaCAhPT0gdm9pZCAwID8gX2ggOiBkZWZhdWx0Vmlldy5wYWdlWE9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbFk6IChfaiA9IG9wdHMuc2Nyb2xsWSkgIT09IG51bGwgJiYgX2ogIT09IHZvaWQgMCA/IF9qIDogZGVmYXVsdFZpZXcucGFnZVlPZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93Qm91bmRzID0gbmV3IEJvdW5kcyh3aW5kb3dPcHRpb25zLnNjcm9sbFgsIHdpbmRvd09wdGlvbnMuc2Nyb2xsWSwgd2luZG93T3B0aW9ucy53aW5kb3dXaWR0aCwgd2luZG93T3B0aW9ucy53aW5kb3dIZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0ID0gbmV3IENvbnRleHQoY29udGV4dE9wdGlvbnMsIHdpbmRvd0JvdW5kcyk7XG4gICAgICAgICAgICAgICAgICAgIGZvcmVpZ25PYmplY3RSZW5kZXJpbmcgPSAoX2sgPSBvcHRzLmZvcmVpZ25PYmplY3RSZW5kZXJpbmcpICE9PSBudWxsICYmIF9rICE9PSB2b2lkIDAgPyBfayA6IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjbG9uZU9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxvd1RhaW50OiAoX2wgPSBvcHRzLmFsbG93VGFpbnQpICE9PSBudWxsICYmIF9sICE9PSB2b2lkIDAgPyBfbCA6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgb25jbG9uZTogb3B0cy5vbmNsb25lLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWdub3JlRWxlbWVudHM6IG9wdHMuaWdub3JlRWxlbWVudHMsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmxpbmVJbWFnZXM6IGZvcmVpZ25PYmplY3RSZW5kZXJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3B5U3R5bGVzOiBmb3JlaWduT2JqZWN0UmVuZGVyaW5nXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQubG9nZ2VyLmRlYnVnKFwiU3RhcnRpbmcgZG9jdW1lbnQgY2xvbmUgd2l0aCBzaXplIFwiICsgd2luZG93Qm91bmRzLndpZHRoICsgXCJ4XCIgKyB3aW5kb3dCb3VuZHMuaGVpZ2h0ICsgXCIgc2Nyb2xsZWQgdG8gXCIgKyAtd2luZG93Qm91bmRzLmxlZnQgKyBcIixcIiArIC13aW5kb3dCb3VuZHMudG9wKTtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnRDbG9uZXIgPSBuZXcgRG9jdW1lbnRDbG9uZXIoY29udGV4dCwgZWxlbWVudCwgY2xvbmVPcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgY2xvbmVkRWxlbWVudCA9IGRvY3VtZW50Q2xvbmVyLmNsb25lZFJlZmVyZW5jZUVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2xvbmVkRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIFByb21pc2UucmVqZWN0KFwiVW5hYmxlIHRvIGZpbmQgZWxlbWVudCBpbiBjbG9uZWQgaWZyYW1lXCIpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBkb2N1bWVudENsb25lci50b0lGcmFtZShvd25lckRvY3VtZW50LCB3aW5kb3dCb3VuZHMpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lciA9IF91LnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgX2EgPSBpc0JvZHlFbGVtZW50KGNsb25lZEVsZW1lbnQpIHx8IGlzSFRNTEVsZW1lbnQoY2xvbmVkRWxlbWVudClcbiAgICAgICAgICAgICAgICAgICAgICAgID8gcGFyc2VEb2N1bWVudFNpemUoY2xvbmVkRWxlbWVudC5vd25lckRvY3VtZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBwYXJzZUJvdW5kcyhjb250ZXh0LCBjbG9uZWRFbGVtZW50KSwgd2lkdGggPSBfYS53aWR0aCwgaGVpZ2h0ID0gX2EuaGVpZ2h0LCBsZWZ0ID0gX2EubGVmdCwgdG9wID0gX2EudG9wO1xuICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3IgPSBwYXJzZUJhY2tncm91bmRDb2xvcihjb250ZXh0LCBjbG9uZWRFbGVtZW50LCBvcHRzLmJhY2tncm91bmRDb2xvcik7XG4gICAgICAgICAgICAgICAgICAgIHJlbmRlck9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYW52YXM6IG9wdHMuY2FudmFzLFxuICAgICAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBiYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICBzY2FsZTogKF9vID0gKF9tID0gb3B0cy5zY2FsZSkgIT09IG51bGwgJiYgX20gIT09IHZvaWQgMCA/IF9tIDogZGVmYXVsdFZpZXcuZGV2aWNlUGl4ZWxSYXRpbykgIT09IG51bGwgJiYgX28gIT09IHZvaWQgMCA/IF9vIDogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6ICgoX3AgPSBvcHRzLngpICE9PSBudWxsICYmIF9wICE9PSB2b2lkIDAgPyBfcCA6IDApICsgbGVmdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6ICgoX3EgPSBvcHRzLnkpICE9PSBudWxsICYmIF9xICE9PSB2b2lkIDAgPyBfcSA6IDApICsgdG9wLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IChfciA9IG9wdHMud2lkdGgpICE9PSBudWxsICYmIF9yICE9PSB2b2lkIDAgPyBfciA6IE1hdGguY2VpbCh3aWR0aCksXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IChfcyA9IG9wdHMuaGVpZ2h0KSAhPT0gbnVsbCAmJiBfcyAhPT0gdm9pZCAwID8gX3MgOiBNYXRoLmNlaWwoaGVpZ2h0KVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWZvcmVpZ25PYmplY3RSZW5kZXJpbmcpIHJldHVybiBbMyAvKmJyZWFrKi8sIDNdO1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmxvZ2dlci5kZWJ1ZyhcIkRvY3VtZW50IGNsb25lZCwgdXNpbmcgZm9yZWlnbiBvYmplY3QgcmVuZGVyaW5nXCIpO1xuICAgICAgICAgICAgICAgICAgICByZW5kZXJlciA9IG5ldyBGb3JlaWduT2JqZWN0UmVuZGVyZXIoY29udGV4dCwgcmVuZGVyT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHJlbmRlcmVyLnJlbmRlcihjbG9uZWRFbGVtZW50KV07XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBjYW52YXMgPSBfdS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDVdO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5sb2dnZXIuZGVidWcoXCJEb2N1bWVudCBjbG9uZWQsIGVsZW1lbnQgbG9jYXRlZCBhdCBcIiArIGxlZnQgKyBcIixcIiArIHRvcCArIFwiIHdpdGggc2l6ZSBcIiArIHdpZHRoICsgXCJ4XCIgKyBoZWlnaHQgKyBcIiB1c2luZyBjb21wdXRlZCByZW5kZXJpbmdcIik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQubG9nZ2VyLmRlYnVnKFwiU3RhcnRpbmcgRE9NIHBhcnNpbmdcIik7XG4gICAgICAgICAgICAgICAgICAgIHJvb3QgPSBwYXJzZVRyZWUoY29udGV4dCwgY2xvbmVkRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiYWNrZ3JvdW5kQ29sb3IgPT09IHJvb3Quc3R5bGVzLmJhY2tncm91bmRDb2xvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm9vdC5zdHlsZXMuYmFja2dyb3VuZENvbG9yID0gQ09MT1JTLlRSQU5TUEFSRU5UO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQubG9nZ2VyLmRlYnVnKFwiU3RhcnRpbmcgcmVuZGVyZXIgZm9yIGVsZW1lbnQgYXQgXCIgKyByZW5kZXJPcHRpb25zLnggKyBcIixcIiArIHJlbmRlck9wdGlvbnMueSArIFwiIHdpdGggc2l6ZSBcIiArIHJlbmRlck9wdGlvbnMud2lkdGggKyBcInhcIiArIHJlbmRlck9wdGlvbnMuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyZXIgPSBuZXcgQ2FudmFzUmVuZGVyZXIoY29udGV4dCwgcmVuZGVyT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHJlbmRlcmVyLnJlbmRlcihyb290KV07XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICBjYW52YXMgPSBfdS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIF91LmxhYmVsID0gNTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgIGlmICgoX3QgPSBvcHRzLnJlbW92ZUNvbnRhaW5lcikgIT09IG51bGwgJiYgX3QgIT09IHZvaWQgMCA/IF90IDogdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFEb2N1bWVudENsb25lci5kZXN0cm95KGNvbnRhaW5lcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmxvZ2dlci5lcnJvcihcIkNhbm5vdCBkZXRhY2ggY2xvbmVkIGlmcmFtZSBhcyBpdCBpcyBub3QgaW4gdGhlIERPTSBhbnltb3JlXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQubG9nZ2VyLmRlYnVnKFwiRmluaXNoZWQgcmVuZGVyaW5nXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgY2FudmFzXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7IH07XG4gICAgdmFyIHBhcnNlQmFja2dyb3VuZENvbG9yID0gZnVuY3Rpb24gKGNvbnRleHQsIGVsZW1lbnQsIGJhY2tncm91bmRDb2xvck92ZXJyaWRlKSB7XG4gICAgICAgIHZhciBvd25lckRvY3VtZW50ID0gZWxlbWVudC5vd25lckRvY3VtZW50O1xuICAgICAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLWJhY2tncm91bmQvI3NwZWNpYWwtYmFja2dyb3VuZHNcbiAgICAgICAgdmFyIGRvY3VtZW50QmFja2dyb3VuZENvbG9yID0gb3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnRcbiAgICAgICAgICAgID8gcGFyc2VDb2xvcihjb250ZXh0LCBnZXRDb21wdXRlZFN0eWxlKG93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KS5iYWNrZ3JvdW5kQ29sb3IpXG4gICAgICAgICAgICA6IENPTE9SUy5UUkFOU1BBUkVOVDtcbiAgICAgICAgdmFyIGJvZHlCYWNrZ3JvdW5kQ29sb3IgPSBvd25lckRvY3VtZW50LmJvZHlcbiAgICAgICAgICAgID8gcGFyc2VDb2xvcihjb250ZXh0LCBnZXRDb21wdXRlZFN0eWxlKG93bmVyRG9jdW1lbnQuYm9keSkuYmFja2dyb3VuZENvbG9yKVxuICAgICAgICAgICAgOiBDT0xPUlMuVFJBTlNQQVJFTlQ7XG4gICAgICAgIHZhciBkZWZhdWx0QmFja2dyb3VuZENvbG9yID0gdHlwZW9mIGJhY2tncm91bmRDb2xvck92ZXJyaWRlID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgPyBwYXJzZUNvbG9yKGNvbnRleHQsIGJhY2tncm91bmRDb2xvck92ZXJyaWRlKVxuICAgICAgICAgICAgOiBiYWNrZ3JvdW5kQ29sb3JPdmVycmlkZSA9PT0gbnVsbFxuICAgICAgICAgICAgICAgID8gQ09MT1JTLlRSQU5TUEFSRU5UXG4gICAgICAgICAgICAgICAgOiAweGZmZmZmZmZmO1xuICAgICAgICByZXR1cm4gZWxlbWVudCA9PT0gb3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnRcbiAgICAgICAgICAgID8gaXNUcmFuc3BhcmVudChkb2N1bWVudEJhY2tncm91bmRDb2xvcilcbiAgICAgICAgICAgICAgICA/IGlzVHJhbnNwYXJlbnQoYm9keUJhY2tncm91bmRDb2xvcilcbiAgICAgICAgICAgICAgICAgICAgPyBkZWZhdWx0QmFja2dyb3VuZENvbG9yXG4gICAgICAgICAgICAgICAgICAgIDogYm9keUJhY2tncm91bmRDb2xvclxuICAgICAgICAgICAgICAgIDogZG9jdW1lbnRCYWNrZ3JvdW5kQ29sb3JcbiAgICAgICAgICAgIDogZGVmYXVsdEJhY2tncm91bmRDb2xvcjtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGh0bWwyY2FudmFzO1xuXG59KSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aHRtbDJjYW52YXMuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/html2canvas/dist/html2canvas.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/dhtmlx-gantt/codebase/dhtmlxgantt.css":
/*!************************************************************!*\
  !*** ./node_modules/dhtmlx-gantt/codebase/dhtmlxgantt.css ***!
  \************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"ac74541e009c\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9kaHRtbHgtZ2FudHQvY29kZWJhc2UvZGh0bWx4Z2FudHQuY3NzIiwibWFwcGluZ3MiOiI7QUFBQSwrREFBZSxjQUFjO0FBQzdCLElBQUksSUFBVSxJQUFJLGlCQUFpQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZGh0bWx4LWdhbnR0L2NvZGViYXNlL2RodG1seGdhbnR0LmNzcz82YThlIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiYWM3NDU0MWUwMDljXCJcbmlmIChtb2R1bGUuaG90KSB7IG1vZHVsZS5ob3QuYWNjZXB0KCkgfVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/dhtmlx-gantt/codebase/dhtmlxgantt.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./components/gantt/GanttChart.tsx":
/*!*****************************************!*\
  !*** ./components/gantt/GanttChart.tsx ***!
  \*****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ GanttChart; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var dhtmlx_gantt__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! dhtmlx-gantt */ \"(app-pages-browser)/./node_modules/dhtmlx-gantt/codebase/dhtmlxgantt.es.js\");\n/* harmony import */ var dhtmlx_gantt_codebase_dhtmlxgantt_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! dhtmlx-gantt/codebase/dhtmlxgantt.css */ \"(app-pages-browser)/./node_modules/dhtmlx-gantt/codebase/dhtmlxgantt.css\");\n/* harmony import */ var html2canvas__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! html2canvas */ \"(app-pages-browser)/./node_modules/html2canvas/dist/html2canvas.js\");\n/* harmony import */ var html2canvas__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(html2canvas__WEBPACK_IMPORTED_MODULE_4__);\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\nfunction GanttChart(param) {\n    let { organizationId } = param;\n    _s();\n    const ganttContainer = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const saveToServer = async ()=>{\n        const data = dhtmlx_gantt__WEBPACK_IMPORTED_MODULE_2__[\"default\"].serialize().data;\n        try {\n            await fetch(\"/api/gantt/\".concat(organizationId), {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    data,\n                    links: []\n                })\n            });\n        } catch (error) {\n            console.error(\"Error al guardar datos de Gantt:\", error);\n        }\n    };\n    const exportAsImage = async ()=>{\n        const element = ganttContainer.current;\n        if (element) {\n            const canvas = await html2canvas__WEBPACK_IMPORTED_MODULE_4___default()(element);\n            const link = document.createElement(\"a\");\n            link.download = \"diagrama-gantt.png\";\n            link.href = canvas.toDataURL();\n            link.click();\n        }\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        dhtmlx_gantt__WEBPACK_IMPORTED_MODULE_2__[\"default\"].config.xml_date = \"%Y-%m-%d %H:%i\";\n        dhtmlx_gantt__WEBPACK_IMPORTED_MODULE_2__[\"default\"].config.date_format = \"%Y-%m-%d\";\n        dhtmlx_gantt__WEBPACK_IMPORTED_MODULE_2__[\"default\"].config.scale_unit = \"day\";\n        dhtmlx_gantt__WEBPACK_IMPORTED_MODULE_2__[\"default\"].config.date_scale = \"%d %M\";\n        dhtmlx_gantt__WEBPACK_IMPORTED_MODULE_2__[\"default\"].config.duration_step = 1;\n        dhtmlx_gantt__WEBPACK_IMPORTED_MODULE_2__[\"default\"].config.bar_height = 30;\n        dhtmlx_gantt__WEBPACK_IMPORTED_MODULE_2__[\"default\"].config.min_column_width = 50;\n        dhtmlx_gantt__WEBPACK_IMPORTED_MODULE_2__[\"default\"].config.show_chart = true;\n        dhtmlx_gantt__WEBPACK_IMPORTED_MODULE_2__[\"default\"].config.show_grid = true;\n        dhtmlx_gantt__WEBPACK_IMPORTED_MODULE_2__[\"default\"].config.autosize = \"y\";\n        dhtmlx_gantt__WEBPACK_IMPORTED_MODULE_2__[\"default\"].config.fit_tasks = true;\n        dhtmlx_gantt__WEBPACK_IMPORTED_MODULE_2__[\"default\"].config.readonly = false;\n        dhtmlx_gantt__WEBPACK_IMPORTED_MODULE_2__[\"default\"].config.details_on_create = true;\n        dhtmlx_gantt__WEBPACK_IMPORTED_MODULE_2__[\"default\"].config.details_on_dblclick = true;\n        dhtmlx_gantt__WEBPACK_IMPORTED_MODULE_2__[\"default\"].config.drag_resize = true;\n        dhtmlx_gantt__WEBPACK_IMPORTED_MODULE_2__[\"default\"].config.drag_move = true;\n        dhtmlx_gantt__WEBPACK_IMPORTED_MODULE_2__[\"default\"].config.drag_progress = true;\n        dhtmlx_gantt__WEBPACK_IMPORTED_MODULE_2__[\"default\"].config.drag_links = false;\n        dhtmlx_gantt__WEBPACK_IMPORTED_MODULE_2__[\"default\"].config.show_links = false;\n        const customDateFormat = dhtmlx_gantt__WEBPACK_IMPORTED_MODULE_2__[\"default\"].date.date_to_str(\"%d-%m-%Y\");\n        dhtmlx_gantt__WEBPACK_IMPORTED_MODULE_2__[\"default\"].templates.task_class = function(_start, _end, task) {\n            return task.duration <= 1 ? \"one-day-task\" : \"\";\n        };\n        dhtmlx_gantt__WEBPACK_IMPORTED_MODULE_2__[\"default\"].config.lightbox.sections = [\n            {\n                name: \"description\",\n                height: 38,\n                map_to: \"text\",\n                type: \"textarea\",\n                focus: true\n            },\n            {\n                name: \"priority\",\n                height: 30,\n                map_to: \"priority\",\n                type: \"select\",\n                options: [\n                    {\n                        key: \"baja\",\n                        label: \"Baja\"\n                    },\n                    {\n                        key: \"media\",\n                        label: \"Media\"\n                    },\n                    {\n                        key: \"alta\",\n                        label: \"Alta\"\n                    }\n                ]\n            },\n            {\n                name: \"time\",\n                type: \"time\",\n                map_to: \"auto\"\n            }\n        ];\n        dhtmlx_gantt__WEBPACK_IMPORTED_MODULE_2__[\"default\"].config.columns = [\n            {\n                name: \"text\",\n                label: \"Tarea\",\n                tree: true,\n                width: 200\n            },\n            {\n                name: \"start_date\",\n                label: \"Inicio\",\n                align: \"center\",\n                width: 100,\n                template: function(task) {\n                    return customDateFormat(task.start_date);\n                }\n            },\n            {\n                name: \"end_date\",\n                label: \"Fin\",\n                align: \"center\",\n                width: 100,\n                template: function(task) {\n                    const end = dhtmlx_gantt__WEBPACK_IMPORTED_MODULE_2__[\"default\"].calculateEndDate(task);\n                    return customDateFormat(end);\n                }\n            },\n            {\n                name: \"duration\",\n                label: \"Duraci\\xf3n\",\n                align: \"center\",\n                width: 80\n            },\n            {\n                name: \"priority\",\n                label: \"Prioridad\",\n                align: \"center\",\n                width: 100,\n                template: function(task) {\n                    return task.priority || \"media\";\n                }\n            }\n        ];\n        dhtmlx_gantt__WEBPACK_IMPORTED_MODULE_2__[\"default\"].attachEvent(\"onTaskDblClick\", function(id) {\n            dhtmlx_gantt__WEBPACK_IMPORTED_MODULE_2__[\"default\"].showLightbox(id);\n            return false;\n        });\n        dhtmlx_gantt__WEBPACK_IMPORTED_MODULE_2__[\"default\"].attachEvent(\"onAfterTaskAdd\", saveToServer);\n        dhtmlx_gantt__WEBPACK_IMPORTED_MODULE_2__[\"default\"].attachEvent(\"onAfterTaskUpdate\", saveToServer);\n        dhtmlx_gantt__WEBPACK_IMPORTED_MODULE_2__[\"default\"].attachEvent(\"onAfterTaskDelete\", saveToServer);\n        dhtmlx_gantt__WEBPACK_IMPORTED_MODULE_2__[\"default\"].init(ganttContainer.current);\n        //  Cargar archivo del servidor por organizacin\n        fetch(\"/api/gantt/\".concat(organizationId)).then((res)=>res.json()).then((data)=>{\n            dhtmlx_gantt__WEBPACK_IMPORTED_MODULE_2__[\"default\"].parse(data);\n        }).catch((err)=>{\n            console.warn(\"No se encontraron datos Gantt:\", err);\n        });\n        return ()=>{\n            dhtmlx_gantt__WEBPACK_IMPORTED_MODULE_2__[\"default\"].clearAll();\n        };\n    }, [\n        organizationId\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"w-full h-full flex flex-col gap-4 p-4 bg-white border border-gray-200 rounded-lg shadow-sm\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"flex items-center gap-4\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                        className: \"text-lg font-semibold text-neutral-800\",\n                        children: \"Diagrama de Gantt\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\allga\\\\nextjs-trello-main\\\\components\\\\gantt\\\\GanttChart.tsx\",\n                        lineNumber: 152,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        onClick: ()=>{\n                            const id = dhtmlx_gantt__WEBPACK_IMPORTED_MODULE_2__[\"default\"].uid();\n                            dhtmlx_gantt__WEBPACK_IMPORTED_MODULE_2__[\"default\"].addTask({\n                                id,\n                                text: \"Nueva tarea\",\n                                start_date: dhtmlx_gantt__WEBPACK_IMPORTED_MODULE_2__[\"default\"].date.date_to_str(\"%Y-%m-%d %H:%i\")(new Date()),\n                                duration: 1,\n                                priority: \"media\"\n                            });\n                            dhtmlx_gantt__WEBPACK_IMPORTED_MODULE_2__[\"default\"].showTask(id);\n                            dhtmlx_gantt__WEBPACK_IMPORTED_MODULE_2__[\"default\"].showLightbox(id);\n                            dhtmlx_gantt__WEBPACK_IMPORTED_MODULE_2__[\"default\"].render();\n                        },\n                        className: \"bg-blue-600 text-white px-3 py-1.5 text-sm rounded-md hover:bg-blue-700 transition\",\n                        children: \"Nueva tarea\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\allga\\\\nextjs-trello-main\\\\components\\\\gantt\\\\GanttChart.tsx\",\n                        lineNumber: 154,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        onClick: exportAsImage,\n                        className: \"bg-green-600 text-white px-3 py-1.5 text-sm rounded-md hover:bg-green-700 transition\",\n                        children: \"Exportar como imagen\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\allga\\\\nextjs-trello-main\\\\components\\\\gantt\\\\GanttChart.tsx\",\n                        lineNumber: 173,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\allga\\\\nextjs-trello-main\\\\components\\\\gantt\\\\GanttChart.tsx\",\n                lineNumber: 151,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                ref: ganttContainer,\n                style: {\n                    height: \"500px\",\n                    overflow: \"auto\"\n                },\n                className: \"w-full border border-gray-300 rounded-md bg-white\"\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\allga\\\\nextjs-trello-main\\\\components\\\\gantt\\\\GanttChart.tsx\",\n                lineNumber: 181,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"style\", {\n                dangerouslySetInnerHTML: {\n                    __html: \"\\n            .one-day-task .gantt_task_content {\\n              background-color: #5e92f3 !important;\\n              border-radius: 4px;\\n              min-width: 30px;\\n            }\\n            .gantt_link_control {\\n              cursor: crosshair !important;\\n            }\\n          \"\n                }\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\allga\\\\nextjs-trello-main\\\\components\\\\gantt\\\\GanttChart.tsx\",\n                lineNumber: 187,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Users\\\\allga\\\\nextjs-trello-main\\\\components\\\\gantt\\\\GanttChart.tsx\",\n        lineNumber: 150,\n        columnNumber: 5\n    }, this);\n}\n_s(GanttChart, \"7ge4rkhIh1BhRUwpac6/FYQHyVU=\");\n_c = GanttChart;\nvar _c;\n$RefreshReg$(_c, \"GanttChart\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvZ2FudHQvR2FudHRDaGFydC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUUwQztBQUNUO0FBQ2M7QUFDVDtBQWN2QixTQUFTSSxXQUFXLEtBQW1DO1FBQW5DLEVBQUVDLGNBQWMsRUFBbUIsR0FBbkM7O0lBQ2pDLE1BQU1DLGlCQUFpQkwsNkNBQU1BLENBQWlCO0lBRTlDLE1BQU1NLGVBQWU7UUFDbkIsTUFBTUMsT0FBT04sb0RBQUtBLENBQUNPLFNBQVMsR0FBR0QsSUFBSTtRQUNuQyxJQUFJO1lBQ0YsTUFBTUUsTUFBTSxjQUE2QixPQUFmTCxpQkFBa0I7Z0JBQzFDTSxRQUFRO2dCQUNSQyxTQUFTO29CQUFFLGdCQUFnQjtnQkFBbUI7Z0JBQzlDQyxNQUFNQyxLQUFLQyxTQUFTLENBQUM7b0JBQUVQO29CQUFNUSxPQUFPLEVBQUU7Z0JBQUM7WUFDekM7UUFDRixFQUFFLE9BQU9DLE9BQU87WUFDZEMsUUFBUUQsS0FBSyxDQUFDLG9DQUFvQ0E7UUFDcEQ7SUFDRjtJQUVBLE1BQU1FLGdCQUFnQjtRQUNwQixNQUFNQyxVQUFVZCxlQUFlZSxPQUFPO1FBQ3RDLElBQUlELFNBQVM7WUFDWCxNQUFNRSxTQUFTLE1BQU1uQixrREFBV0EsQ0FBQ2lCO1lBQ2pDLE1BQU1HLE9BQU9DLFNBQVNDLGFBQWEsQ0FBQztZQUNwQ0YsS0FBS0csUUFBUSxHQUFHO1lBQ2hCSCxLQUFLSSxJQUFJLEdBQUdMLE9BQU9NLFNBQVM7WUFDNUJMLEtBQUtNLEtBQUs7UUFDWjtJQUNGO0lBRUE3QixnREFBU0EsQ0FBQztRQUNSRSxvREFBS0EsQ0FBQzRCLE1BQU0sQ0FBQ0MsUUFBUSxHQUFHO1FBQ3hCN0Isb0RBQUtBLENBQUM0QixNQUFNLENBQUNFLFdBQVcsR0FBRztRQUMzQjlCLG9EQUFLQSxDQUFDNEIsTUFBTSxDQUFDRyxVQUFVLEdBQUc7UUFDMUIvQixvREFBS0EsQ0FBQzRCLE1BQU0sQ0FBQ0ksVUFBVSxHQUFH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QkFDZDt3QkFDQVQsV0FBVTtrQ0FDWDs7Ozs7O2tDQUlELDhEQUFDRTt3QkFDQ0MsU0FBUzNFO3dCQUNUd0UsV0FBVTtrQ0FDWDs7Ozs7Ozs7Ozs7OzBCQUtILDhEQUFDRDtnQkFDQ1csS0FBSy9GO2dCQUNMZ0csT0FBTztvQkFBRXhDLFFBQVE7b0JBQVN5QyxVQUFVO2dCQUFPO2dCQUMzQ1osV0FBVTs7Ozs7OzBCQUdaLDhEQUFDVztnQkFDQ0UseUJBQXlCO29CQUN2QkMsUUFBUztnQkFVWDs7Ozs7Ozs7Ozs7O0FBSVI7R0F2THdCckc7S0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9nYW50dC9HYW50dENoYXJ0LnRzeD9jOWFhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xyXG5cclxuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tIFwicmVhY3RcIjtcclxuaW1wb3J0IGdhbnR0IGZyb20gXCJkaHRtbHgtZ2FudHRcIjtcclxuaW1wb3J0IFwiZGh0bWx4LWdhbnR0L2NvZGViYXNlL2RodG1seGdhbnR0LmNzc1wiO1xyXG5pbXBvcnQgaHRtbDJjYW52YXMgZnJvbSBcImh0bWwyY2FudmFzXCI7XHJcblxyXG5pbnRlcmZhY2UgR2FudHRUYXNrIHtcclxuICBpZDogc3RyaW5nIHwgbnVtYmVyO1xyXG4gIHRleHQ6IHN0cmluZztcclxuICBzdGFydF9kYXRlOiBEYXRlO1xyXG4gIGR1cmF0aW9uOiBudW1iZXI7XHJcbiAgcHJpb3JpdHk/OiBcImJhamFcIiB8IFwibWVkaWFcIiB8IFwiYWx0YVwiO1xyXG59XHJcblxyXG5pbnRlcmZhY2UgR2FudHRDaGFydFByb3BzIHtcclxuICBvcmdhbml6YXRpb25JZDogc3RyaW5nO1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBHYW50dENoYXJ0KHsgb3JnYW5pemF0aW9uSWQgfTogR2FudHRDaGFydFByb3BzKSB7XHJcbiAgY29uc3QgZ2FudHRDb250YWluZXIgPSB1c2VSZWY8SFRNTERpdkVsZW1lbnQ+KG51bGwpO1xyXG5cclxuICBjb25zdCBzYXZlVG9TZXJ2ZXIgPSBhc3luYyAoKSA9PiB7XHJcbiAgICBjb25zdCBkYXRhID0gZ2FudHQuc2VyaWFsaXplKCkuZGF0YTtcclxuICAgIHRyeSB7XHJcbiAgICAgIGF3YWl0IGZldGNoKGAvYXBpL2dhbnR0LyR7b3JnYW5pemF0aW9uSWR9YCwge1xyXG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXHJcbiAgICAgICAgaGVhZGVyczogeyBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxyXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgZGF0YSwgbGlua3M6IFtdIH0pLFxyXG4gICAgICB9KTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBhbCBndWFyZGFyIGRhdG9zIGRlIEdhbnR0OlwiLCBlcnJvcik7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgZXhwb3J0QXNJbWFnZSA9IGFzeW5jICgpID0+IHtcclxuICAgIGNvbnN0IGVsZW1lbnQgPSBnYW50dENvbnRhaW5lci5jdXJyZW50O1xyXG4gICAgaWYgKGVsZW1lbnQpIHtcclxuICAgICAgY29uc3QgY2FudmFzID0gYXdhaXQgaHRtbDJjYW52YXMoZWxlbWVudCk7XHJcbiAgICAgIGNvbnN0IGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtcclxuICAgICAgbGluay5kb3dubG9hZCA9IFwiZGlhZ3JhbWEtZ2FudHQucG5nXCI7XHJcbiAgICAgIGxpbmsuaHJlZiA9IGNhbnZhcy50b0RhdGFVUkwoKTtcclxuICAgICAgbGluay5jbGljaygpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBnYW50dC5jb25maWcueG1sX2RhdGUgPSBcIiVZLSVtLSVkICVIOiVpXCI7XHJcbiAgICBnYW50dC5jb25maWcuZGF0ZV9mb3JtYXQgPSBcIiVZLSVtLSVkXCI7XHJcbiAgICBnYW50dC5jb25maWcuc2NhbGVfdW5pdCA9IFwiZGF5XCI7XHJcbiAgICBnYW50dC5jb25maWcuZGF0ZV9zY2FsZSA9IFwiJWQgJU1cIjtcclxuICAgIGdhbnR0LmNvbmZpZy5kdXJhdGlvbl9zdGVwID0gMTtcclxuICAgIGdhbnR0LmNvbmZpZy5iYXJfaGVpZ2h0ID0gMzA7XHJcbiAgICBnYW50dC5jb25maWcubWluX2NvbHVtbl93aWR0aCA9IDUwO1xyXG4gICAgZ2FudHQuY29uZmlnLnNob3dfY2hhcnQgPSB0cnVlO1xyXG4gICAgZ2FudHQuY29uZmlnLnNob3dfZ3JpZCA9IHRydWU7XHJcbiAgICBnYW50dC5jb25maWcuYXV0b3NpemUgPSBcInlcIjtcclxuICAgIGdhbnR0LmNvbmZpZy5maXRfdGFza3MgPSB0cnVlO1xyXG4gICAgZ2FudHQuY29uZmlnLnJlYWRvbmx5ID0gZmFsc2U7XHJcbiAgICBnYW50dC5jb25maWcuZGV0YWlsc19vbl9jcmVhdGUgPSB0cnVlO1xyXG4gICAgZ2FudHQuY29uZmlnLmRldGFpbHNfb25fZGJsY2xpY2sgPSB0cnVlO1xyXG4gICAgZ2FudHQuY29uZmlnLmRyYWdfcmVzaXplID0gdHJ1ZTtcclxuICAgIGdhbnR0LmNvbmZpZy5kcmFnX21vdmUgPSB0cnVlO1xyXG4gICAgZ2FudHQuY29uZmlnLmRyYWdfcHJvZ3Jlc3MgPSB0cnVlO1xyXG4gICAgZ2FudHQuY29uZmlnLmRyYWdfbGlua3MgPSBmYWxzZTtcclxuICAgIGdhbnR0LmNvbmZpZy5zaG93X2xpbmtzID0gZmFsc2U7XHJcblxyXG4gICAgY29uc3QgY3VzdG9tRGF0ZUZvcm1hdCA9IGdhbnR0LmRhdGUuZGF0ZV90b19zdHIoXCIlZC0lbS0lWVwiKTtcclxuXHJcbiAgICBnYW50dC50ZW1wbGF0ZXMudGFza19jbGFzcyA9IGZ1bmN0aW9uIChfc3RhcnQsIF9lbmQsIHRhc2s6IEdhbnR0VGFzaykge1xyXG4gICAgICByZXR1cm4gdGFzay5kdXJhdGlvbiA8PSAxID8gXCJvbmUtZGF5LXRhc2tcIiA6IFwiXCI7XHJcbiAgICB9O1xyXG5cclxuICAgIGdhbnR0LmNvbmZpZy5saWdodGJveC5zZWN0aW9ucyA9IFtcclxuICAgICAgeyBuYW1lOiBcImRlc2NyaXB0aW9uXCIsIGhlaWdodDogMzgsIG1hcF90bzogXCJ0ZXh0XCIsIHR5cGU6IFwidGV4dGFyZWFcIiwgZm9jdXM6IHRydWUgfSxcclxuICAgICAge1xyXG4gICAgICAgIG5hbWU6IFwicHJpb3JpdHlcIixcclxuICAgICAgICBoZWlnaHQ6IDMwLFxyXG4gICAgICAgIG1hcF90bzogXCJwcmlvcml0eVwiLFxyXG4gICAgICAgIHR5cGU6IFwic2VsZWN0XCIsXHJcbiAgICAgICAgb3B0aW9uczogW1xyXG4gICAgICAgICAgeyBrZXk6IFwiYmFqYVwiLCBsYWJlbDogXCJCYWphXCIgfSxcclxuICAgICAgICAgIHsga2V5OiBcIm1lZGlhXCIsIGxhYmVsOiBcIk1lZGlhXCIgfSxcclxuICAgICAgICAgIHsga2V5OiBcImFsdGFcIiwgbGFiZWw6IFwiQWx0YVwiIH0sXHJcbiAgICAgICAgXSxcclxuICAgICAgfSxcclxuICAgICAgeyBuYW1lOiBcInRpbWVcIiwgdHlwZTogXCJ0aW1lXCIsIG1hcF90bzogXCJhdXRvXCIgfSxcclxuICAgIF07XHJcblxyXG4gICAgZ2FudHQuY29uZmlnLmNvbHVtbnMgPSBbXHJcbiAgICAgIHsgbmFtZTogXCJ0ZXh0XCIsIGxhYmVsOiBcIlRhcmVhXCIsIHRyZWU6IHRydWUsIHdpZHRoOiAyMDAgfSxcclxuICAgICAge1xyXG4gICAgICAgIG5hbWU6IFwic3RhcnRfZGF0ZVwiLFxyXG4gICAgICAgIGxhYmVsOiBcIkluaWNpb1wiLFxyXG4gICAgICAgIGFsaWduOiBcImNlbnRlclwiLFxyXG4gICAgICAgIHdpZHRoOiAxMDAsXHJcbiAgICAgICAgdGVtcGxhdGU6IGZ1bmN0aW9uICh0YXNrOiBHYW50dFRhc2spIHtcclxuICAgICAgICAgIHJldHVybiBjdXN0b21EYXRlRm9ybWF0KHRhc2suc3RhcnRfZGF0ZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgfSxcclxuICAgICAge1xyXG4gICAgICAgIG5hbWU6IFwiZW5kX2RhdGVcIixcclxuICAgICAgICBsYWJlbDogXCJGaW5cIixcclxuICAgICAgICBhbGlnbjogXCJjZW50ZXJcIixcclxuICAgICAgICB3aWR0aDogMTAwLFxyXG4gICAgICAgIHRlbXBsYXRlOiBmdW5jdGlvbiAodGFzazogR2FudHRUYXNrKSB7XHJcbiAgICAgICAgICBjb25zdCBlbmQgPSBnYW50dC5jYWxjdWxhdGVFbmREYXRlKHRhc2spO1xyXG4gICAgICAgICAgcmV0dXJuIGN1c3RvbURhdGVGb3JtYXQoZW5kKTtcclxuICAgICAgICB9LFxyXG4gICAgICB9LFxyXG4gICAgICB7IG5hbWU6IFwiZHVyYXRpb25cIiwgbGFiZWw6IFwiRHVyYWNpw7NuXCIsIGFsaWduOiBcImNlbnRlclwiLCB3aWR0aDogODAgfSxcclxuICAgICAge1xyXG4gICAgICAgIG5hbWU6IFwicHJpb3JpdHlcIixcclxuICAgICAgICBsYWJlbDogXCJQcmlvcmlkYWRcIixcclxuICAgICAgICBhbGlnbjogXCJjZW50ZXJcIixcclxuICAgICAgICB3aWR0aDogMTAwLFxyXG4gICAgICAgIHRlbXBsYXRlOiBmdW5jdGlvbiAodGFzazogR2FudHRUYXNrKSB7XHJcbiAgICAgICAgICByZXR1cm4gdGFzay5wcmlvcml0eSB8fCBcIm1lZGlhXCI7XHJcbiAgICAgICAgfSxcclxuICAgICAgfSxcclxuICAgIF07XHJcblxyXG4gICAgZ2FudHQuYXR0YWNoRXZlbnQoXCJvblRhc2tEYmxDbGlja1wiLCBmdW5jdGlvbiAoaWQpIHtcclxuICAgICAgZ2FudHQuc2hvd0xpZ2h0Ym94KGlkKTtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfSk7XHJcblxyXG4gICAgZ2FudHQuYXR0YWNoRXZlbnQoXCJvbkFmdGVyVGFza0FkZFwiLCBzYXZlVG9TZXJ2ZXIpO1xyXG4gICAgZ2FudHQuYXR0YWNoRXZlbnQoXCJvbkFmdGVyVGFza1VwZGF0ZVwiLCBzYXZlVG9TZXJ2ZXIpO1xyXG4gICAgZ2FudHQuYXR0YWNoRXZlbnQoXCJvbkFmdGVyVGFza0RlbGV0ZVwiLCBzYXZlVG9TZXJ2ZXIpO1xyXG5cclxuICAgIGdhbnR0LmluaXQoZ2FudHRDb250YWluZXIuY3VycmVudCEpO1xyXG5cclxuICAgIC8vIPCflL0gQ2FyZ2FyIGFyY2hpdm8gZGVsIHNlcnZpZG9yIHBvciBvcmdhbml6YWNpw7NuXHJcbiAgICBmZXRjaChgL2FwaS9nYW50dC8ke29yZ2FuaXphdGlvbklkfWApXHJcbiAgICAgIC50aGVuKChyZXMpID0+IHJlcy5qc29uKCkpXHJcbiAgICAgIC50aGVuKChkYXRhKSA9PiB7XHJcbiAgICAgICAgZ2FudHQucGFyc2UoZGF0YSk7XHJcbiAgICAgIH0pXHJcbiAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKFwiTm8gc2UgZW5jb250cmFyb24gZGF0b3MgR2FudHQ6XCIsIGVycik7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgIGdhbnR0LmNsZWFyQWxsKCk7XHJcbiAgICB9O1xyXG4gIH0sIFtvcmdhbml6YXRpb25JZF0pO1xyXG5cclxuICByZXR1cm4gKFxyXG4gICAgPGRpdiBjbGFzc05hbWU9XCJ3LWZ1bGwgaC1mdWxsIGZsZXggZmxleC1jb2wgZ2FwLTQgcC00IGJnLXdoaXRlIGJvcmRlciBib3JkZXItZ3JheS0yMDAgcm91bmRlZC1sZyBzaGFkb3ctc21cIj5cclxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGl0ZW1zLWNlbnRlciBnYXAtNFwiPlxyXG4gICAgICAgIDxoMiBjbGFzc05hbWU9XCJ0ZXh0LWxnIGZvbnQtc2VtaWJvbGQgdGV4dC1uZXV0cmFsLTgwMFwiPkRpYWdyYW1hIGRlIEdhbnR0PC9oMj5cclxuXHJcbiAgICAgICAgPGJ1dHRvblxyXG4gICAgICAgICAgb25DbGljaz17KCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBpZCA9IGdhbnR0LnVpZCgpO1xyXG4gICAgICAgICAgICBnYW50dC5hZGRUYXNrKHtcclxuICAgICAgICAgICAgICBpZCxcclxuICAgICAgICAgICAgICB0ZXh0OiBcIk51ZXZhIHRhcmVhXCIsXHJcbiAgICAgICAgICAgICAgc3RhcnRfZGF0ZTogZ2FudHQuZGF0ZS5kYXRlX3RvX3N0cihcIiVZLSVtLSVkICVIOiVpXCIpKG5ldyBEYXRlKCkpLFxyXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiAxLFxyXG4gICAgICAgICAgICAgIHByaW9yaXR5OiBcIm1lZGlhXCIsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBnYW50dC5zaG93VGFzayhpZCk7XHJcbiAgICAgICAgICAgIGdhbnR0LnNob3dMaWdodGJveChpZCk7XHJcbiAgICAgICAgICAgIGdhbnR0LnJlbmRlcigpO1xyXG4gICAgICAgICAgfX1cclxuICAgICAgICAgIGNsYXNzTmFtZT1cImJnLWJsdWUtNjAwIHRleHQtd2hpdGUgcHgtMyBweS0xLjUgdGV4dC1zbSByb3VuZGVkLW1kIGhvdmVyOmJnLWJsdWUtNzAwIHRyYW5zaXRpb25cIlxyXG4gICAgICAgID5cclxuICAgICAgICAgIE51ZXZhIHRhcmVhXHJcbiAgICAgICAgPC9idXR0b24+XHJcblxyXG4gICAgICAgIDxidXR0b25cclxuICAgICAgICAgIG9uQ2xpY2s9e2V4cG9ydEFzSW1hZ2V9XHJcbiAgICAgICAgICBjbGFzc05hbWU9XCJiZy1ncmVlbi02MDAgdGV4dC13aGl0ZSBweC0zIHB5LTEuNSB0ZXh0LXNtIHJvdW5kZWQtbWQgaG92ZXI6YmctZ3JlZW4tNzAwIHRyYW5zaXRpb25cIlxyXG4gICAgICAgID5cclxuICAgICAgICAgIEV4cG9ydGFyIGNvbW8gaW1hZ2VuXHJcbiAgICAgICAgPC9idXR0b24+XHJcbiAgICAgIDwvZGl2PlxyXG5cclxuICAgICAgPGRpdlxyXG4gICAgICAgIHJlZj17Z2FudHRDb250YWluZXJ9XHJcbiAgICAgICAgc3R5bGU9e3sgaGVpZ2h0OiBcIjUwMHB4XCIsIG92ZXJmbG93OiBcImF1dG9cIiB9fVxyXG4gICAgICAgIGNsYXNzTmFtZT1cInctZnVsbCBib3JkZXIgYm9yZGVyLWdyYXktMzAwIHJvdW5kZWQtbWQgYmctd2hpdGVcIlxyXG4gICAgICAvPlxyXG5cclxuICAgICAgPHN0eWxlXHJcbiAgICAgICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw9e3tcclxuICAgICAgICAgIF9faHRtbDogYFxyXG4gICAgICAgICAgICAub25lLWRheS10YXNrIC5nYW50dF90YXNrX2NvbnRlbnQge1xyXG4gICAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6ICM1ZTkyZjMgIWltcG9ydGFudDtcclxuICAgICAgICAgICAgICBib3JkZXItcmFkaXVzOiA0cHg7XHJcbiAgICAgICAgICAgICAgbWluLXdpZHRoOiAzMHB4O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC5nYW50dF9saW5rX2NvbnRyb2wge1xyXG4gICAgICAgICAgICAgIGN1cnNvcjogY3Jvc3NoYWlyICFpbXBvcnRhbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIGAsXHJcbiAgICAgICAgfX1cclxuICAgICAgLz5cclxuICAgIDwvZGl2PlxyXG4gICk7XHJcbn1cclxuIl0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVJlZiIsImdhbnR0IiwiaHRtbDJjYW52YXMiLCJHYW50dENoYXJ0Iiwib3JnYW5pemF0aW9uSWQiLCJnYW50dENvbnRhaW5lciIsInNhdmVUb1NlcnZlciIsImRhdGEiLCJzZXJpYWxpemUiLCJmZXRjaCIsIm1ldGhvZCIsImhlYWRlcnMiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsImxpbmtzIiwiZXJyb3IiLCJjb25zb2xlIiwiZXhwb3J0QXNJbWFnZSIsImVsZW1lbnQiLCJjdXJyZW50IiwiY2FudmFzIiwibGluayIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImRvd25sb2FkIiwiaHJlZiIsInRvRGF0YVVSTCIsImNsaWNrIiwiY29uZmlnIiwieG1sX2RhdGUiLCJkYXRlX2Zvcm1hdCIsInNjYWxlX3VuaXQiLCJkYXRlX3NjYWxlIiwiZHVyYXRpb25fc3RlcCIsImJhcl9oZWlnaHQiLCJtaW5fY29sdW1uX3dpZHRoIiwic2hvd19jaGFydCIsInNob3dfZ3JpZCIsImF1dG9zaXplIiwiZml0X3Rhc2tzIiwicmVhZG9ubHkiLCJkZXRhaWxzX29uX2NyZWF0ZSIsImRldGFpbHNfb25fZGJsY2xpY2siLCJkcmFnX3Jlc2l6ZSIsImRyYWdfbW92ZSIsImRyYWdfcHJvZ3Jlc3MiLCJkcmFnX2xpbmtzIiwic2hvd19saW5rcyIsImN1c3RvbURhdGVGb3JtYXQiLCJkYXRlIiwiZGF0ZV90b19zdHIiLCJ0ZW1wbGF0ZXMiLCJ0YXNrX2NsYXNzIiwiX3N0YXJ0IiwiX2VuZCIsInRhc2siLCJkdXJhdGlvbiIsImxpZ2h0Ym94Iiwic2VjdGlvbnMiLCJuYW1lIiwiaGVpZ2h0IiwibWFwX3RvIiwidHlwZSIsImZvY3VzIiwib3B0aW9ucyIsImtleSIsImxhYmVsIiwiY29sdW1ucyIsInRyZWUiLCJ3aWR0aCIsImFsaWduIiwidGVtcGxhdGUiLCJzdGFydF9kYXRlIiwiZW5kIiwiY2FsY3VsYXRlRW5kRGF0ZSIsInByaW9yaXR5IiwiYXR0YWNoRXZlbnQiLCJpZCIsInNob3dMaWdodGJveCIsImluaXQiLCJ0aGVuIiwicmVzIiwianNvbiIsInBhcnNlIiwiY2F0Y2giLCJlcnIiLCJ3YXJuIiwiY2xlYXJBbGwiLCJkaXYiLCJjbGFzc05hbWUiLCJoMiIsImJ1dHRvbiIsIm9uQ2xpY2siLCJ1aWQiLCJhZGRUYXNrIiwidGV4dCIsIkRhdGUiLCJzaG93VGFzayIsInJlbmRlciIsInJlZiIsInN0eWxlIiwib3ZlcmZsb3ciLCJkYW5nZXJvdXNseVNldElubmVySFRNTCIsIl9faHRtbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/gantt/GanttChart.tsx\n"));

/***/ })

}]);